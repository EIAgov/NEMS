# $Header: M:/default/scripts/RCS/nemspar.shell,v 1.57 2020/03/24 20:16:31 jpg Exp $
# This script is created by submit.sh (alias runnems).  After that, it can be
# reexecuted. 
# The run will be stored in $OUTDIR/$scenario/$datekey
TK_ECHO_USE_BASH_BEHAVIOR=1
if [ "$OSTYPE" = "cygwin" ] ; then
  shopt -s nocaseglob
fi





 OUTDIR=?OUTDIR@
 scenario=?SCEN@
 datekey=?DATE@
 HOSTPC=?HOSTPC@
 nemspyenv=?NEMSPYENV@
 echo $nemspyenv
 gamsvers=?GAMSVERS@
 echo $gamsvers
 


# We need to know where the runnems files were located,which is the present directory
 OLDDIR=$PWD

echo
if [ ! -f jcl.dat.$scenario.$datekey ]; then
echo ' NO jcl.dat FILE !!!!! '
echo ' SCRIPT ENDING '
exit
fi
if [ ! -f FILELIST.$scenario.$datekey ]; then
echo ' NO FILELIST FILE !!!!! '
echo ' SCRIPT ENDING '
exit
fi

if [ ! -f keys.sed.$scenario.$datekey ]; then
echo " NO keys.sed.$scenario.$datekey  FILE !!!!! "
echo ' using keys.sed '
cp keys.sed keys.sed.$scenario.$datekey
fi
echo -n 'setting up NEMS scenario ';echo $scenario

if [ -d $OUTDIR/$scenario ]; then
   echo directory $OUTDIR/$scenario exists
   echo continuing
else
   echo creating $OUTDIR/$scenario
   mkdir $OUTDIR/$scenario
   chmod 777 $OUTDIR/$scenario
fi
cd $OUTDIR/$scenario

echo -n 'setting up datekey ';echo $datekey    
if [ -d $datekey ]; then
   echo directory $datekey exists
   echo continuing
else
   echo creating $datekey
   mkdir $datekey
   chmod 777 $datekey
fi 

cd $NEMS
Echo "Last commit before this run was made:" > $OUTDIR/$scenario/$datekey/commit_head
Git log --name-only -n 1  >> $OUTDIR/$scenario/$datekey/commit_head
Echo "  " >> $OUTDIR/$scenario/$datekey/commit_head
Echo "Files modified but not committed:" >> $OUTDIR/$scenario/$datekey/commit_head
Git ls-files -m >> $OUTDIR/$scenario/$datekey/commit_head
Echo "  " >> $OUTDIR/$scenario/$datekey/commit_head
Echo "All commits from the last month:" >> $OUTDIR/$scenario/$datekey/commit_head
Git log --name-only --since="1 month ago"  >> $OUTDIR/$scenario/$datekey/commit_head


# write out scedeshash.all
Echo "Files modified but not committed:" > $OUTDIR/$scenario/$datekey/scedeshash.all
Git ls-files -m >> $OUTDIR/$scenario/$datekey/scedeshash.all
Echo "  " >> $OUTDIR/$scenario/$datekey/scedeshash.all

cd $NEMS/source
Ls *.f *.f90 > $OUTDIR/$scenario/$datekey/sourcefiles
input1="$OUTDIR/$scenario/$datekey/sourcefiles"
Echo "getting hash codes for " $input1
while IFS= read -r line
  do
     git log -n1 --oneline -- "$line" | awk -v var="$line" '{print $1,var}' >>$OUTDIR/$scenario/$datekey/scedeshash.all
  done < "$input1"
Echo "  " >> $OUTDIR/$scenario/$datekey/scedeshash.all

cd $NEMS/input
Ls  > $OUTDIR/$scenario/$datekey/inputfiles
input2="$OUTDIR/$scenario/$datekey/inputfiles"
Echo "getting hash codes for "  $input2
while IFS= read -r line2
  do
    git log -n1 --oneline -- "$line2" | awk -v var="$line2" '{print $1,var}' >>$OUTDIR/$scenario/$datekey/scedeshash.all
  done < "$input2"
Echo "  " >> $OUTDIR/$scenario/$datekey/scedeshash.all

cd  $OUTDIR/$scenario/$datekey
TY=$(date '+%Y')  # Year for today as YYYY (string)
TM=$(date '+%m')  # Month for today as number (string)
TD=$(date '+%d')  # Day for today (string)

retainrun=?RETAIN@
# make sure it is valid retention period...theoretically, we can accept any multiple of 30 though
# note for possible future change:  in testing a bad number, it seems to use just the integer part
#      of the divide by 30 - i.e., if 66 was given, it evaluates using 2 months
#      so theoretically, we can accept any integer,
if [[ ( "$retainrun" != "30" ) && ( "$retainrun" != "90" ) && ( "$retainrun" != "180" ) && ( "$retainrun" != "360" ) && ( "$retainrun" != "0" ) ]] ; then
   echo "Bad retention period requested, resetting to 90 days."
   retainrun=90
fi
# the parentheses allow for math with string numbers, which come from date
# but we have to use the let command to do this as the parentheses don't work when executing via sh
#    (as opposed to executing via ., or sh -K, or by name of script file)
let NM=retainrun/30
let FM=TM+NM
let FY=TY
if [[ ( "$retainrun" != "360" ) && ( "$FM" = "13" || "$FM" = "14" || "$FM" = "15" || "$FM" = "16" || "$FM" = "17" || "$FM" = "18" || "$FM" = "19" || "$FM" = "20" || "$FM" = "21" || "$FM" = "22" || "$FM" = "23" || "$FM" = "24" ) ]] ; then
   let FY=FY+1
   let FM=FM-12
fi
if [[ "$retainrun" = "360" ]] ; then
   let FY=TY+1
   let FM=TM
fi
if [[ "$FM" = "10" || "$FM" = "11" || "$FM" = "12" ]] ; then
   FUTURE="$FY$FM$TD"
else
   FUTURE="$FY""0""$FM$TD"
fi

if [ "$retainrun" = "30" ] ; then
   echo "Retention period set to $retainrun days"
   echo "Retain this run for 30 days (automatically delete after 1 month)" > retain_30.txt
   echo "Retain this run for 30 days (automatically delete after 1 month)" > remove_$FUTURE.txt
fi
if [ "$retainrun" = "90" ] ; then
   echo "Retention period set to $retainrun days"
   echo "Retain this run for 90 days (automatically delete after 3 months)" > retain_90.txt
   echo "Retain this run for 90 days (automatically delete after 3 months)" > remove_$FUTURE.txt
fi
if [ "$retainrun" = "180" ] ; then
   echo "Retention period set to $retainrun days"
   echo "Retain this run for 180 days (automatically delete after 6 months)" > retain_180.txt
   echo "Retain this run for 180 days (automatically delete after 6 months)" > remove_$FUTURE.txt
fi
if [ "$retainrun" = "360" ] ; then
   echo "Retention period set to $retainrun days"
   echo "Retain this run for 360 days (automatically delete after 1 year (more or less))" > retain_360.txt
   echo "Retain this run for 360 days (automatically delete after 1 year (more or less))" > remove_$FUTURE.txt
fi
if [ "$retainrun" = "0" ] ; then
   echo "Retention period set to permanent retention"
   echo "Retain this run at level 5 (no automatic deletion)" > retain_permanent.txt
   echo "Retain this run at level 5 (no automatic deletion)" > remove_permanent.txt
fi

datekey=$datekey

#Moving of PyFiler to Output Folder
cp -R $NEMS/scripts/PyFiler ./PyFiler

# build Validator input files
echo "start building Validator input files"
if [ ! -d ./Validator ] ; then
   cp -r $NEMS/scripts/Validator .
   cd Validator

   echo "creating Validator input folder"
   mkdir ./input
   cp -f ?STEOVARSN@ ./input/steovars.csv
   cp -f $NEMS/input/validator_controller.csv ./input/validator_controller.csv
   cp -f $NEMS/input/ngas/steo_benchmark_ngmm.csv ./input/steo_benchmark_ngmm.csv
   cp -f $NEMS/input/coal/steo_benchmark_cmm.csv ./input/steo_benchmark_cmm.csv
   cp -f $NEMS/input/emm/steo_benchmark_emm.csv ./input/steo_benchmark_emm.csv
   cp -f $NEMS/input/bld/steo_benchmark_buildings.csv ./input/steo_benchmark_buildings.csv
   cp -f $NEMS/input/idm/steo_benchmark_industrial.csv ./input/steo_benchmark_industrial.csv
   cp -f $NEMS/input/itg/steo_benchmark_integration.csv ./input/steo_benchmark_integration.csv
   cp -f $NEMS/input/lfmm/steo_benchmark_liquids.csv ./input/steo_benchmark_liquids.csv
   cp -f $NEMS/input/ogsm/steo_benchmark_ogsm.csv ./input/steo_benchmark_ogsm.csv
   cp -f $NEMS/input/macro/steo_benchmark_macro.csv ./input/steo_benchmark_macro.csv
   cd .. #back to the output root
fi



cp -f $NEMS/scripts/cycle_par.sh cycle.sh
cp -f $NEMS/scripts/ftabdb.xsd .
if [ -f $OLDDIR/cycle_par.sh ] ; then
   echo " Local cycle.sh found!  How exciting!  I am confident you want to use it."
   cp -f $OLDDIR/cycle_par.sh cycle.sh
   # $OLDDIR=$PWD as been set above. If the current work dir has cycle_par exists, we use it instead.
fi

echo "$scenario/$datekey launched from $OLDDIR by $USER on " > launched.from
date >> launched.from
echo "using NEMS platform stored here: $NEMS" >> launched.from
sh $NEMS/scripts/firstname.sh >> launched.from 

rm -f intercv.objs
rm -f ftab.objs
rm -f tfiler.objs

 # parallel version. Make passes to create child folders in $datekey
passes="p1 p2 p3"
for p in $passes
do
    echo ; echo; echo "======================================================="
    echo "setting up part $p"
    if [ -d $p ] ; then
      echo directory $p exists
    else
      mkdir $p
      chmod 777 $p
    fi
    
    cd $p
    pwd  


    cp  $OLDDIR/keys.sed.$scenario.$datekey keys.sed;chmod 666 keys.sed
    cp  $OLDDIR/FILELIST.$scenario.$datekey FILELIST;chmod 666 FILELIST
    cp  $OLDDIR/jcl.dat.$scenario.$datekey  jcl.dat;chmod 666 jcl.dat
    cp  $OLDDIR/MOREOPT.$scenario.$datekey  MOREOPT;chmod 666 MOREOPT
    if [ -f $OLDDIR/scentext.$scenario.$datekey ] ; then
      cp $OLDDIR/scentext.$scenario.$datekey scentext;chmod 666 scentext
    fi
    
    rm -f nems.objs

    
    # Check for, and delete, existing .Z files in output directory.
    # These would be there if performing a re-run.
    rm -f *.gz
    
    # COPYINP is a parameter in each secedes file, to on/off(1/0) copy input files to subdirectory of run output directory.
    copyem=?COPYINP@

    # replace optional "$NEMS" string in scedes file names with the value of environment variable $NEMS
    cat FILELIST | sed "s@\$NEMS@$NEMS@g" > filelist.tmp
    mv filelist.tmp FILELIST

    if [ "$copyem" != "0" ] ; then
      rm -f filelist.changed
      rm -f cpcmds.sh
      $NEMS/scripts/cac_filelist.exe FILELIST ?COPYDIR@
      rm -f FILELIST
      sh $NEMS/scripts/trim.sh filelist.changed FILELIST
      rm -f filelist.changed
      if [ ! -d ?COPYDIR@ ] ; then
        mkdir ?COPYDIR@
      fi
    # cac_filelist creates uncmprss.sh and cpcmds.sh to uncompress files and then copy them
      sh uncmprss.sh
      rm -f uncmprss.sh
      sh cpcmds.sh
      rm -f cpcmds.sh

    else
    #  the u as the directory to copy input files to really means do an "uncompress only"
      $NEMS/scripts/cac_filelist.exe FILELIST u
    # cac_filelist creates uncmprss.sh to uncompress files
      sh uncmprss.sh
      rm -f uncmprss.sh
    fi

    rm -f hswrk.bat
    rm -f nohup.out
    
    # finding error string
    ?O@cp $NEMS/scripts/lffindstr.bat lffindstr.bat

    ?N@ if [ "$p" = "p2" ] ; then
    ?N@ cd ?COPYDIR@	#?COPYDIR@=./input
#    ?N@ c:/progra~1/winzip/wzunzip.exe -o ?PSBASEUNFN@ > /dev/null
	?N@ powershell -Command "Expand-Archive PSBASEUNF.zip -DestinationPath ." 
    ?N@ cd -
    ?N@ fi

#  put coal units file in p2 for coal model at beginning of run so it will be there for project open/read
    ?C@ cp -f ?COALUNITSN@?COALUNITSD@ COALEMM_EMM_CL_UNITS.txt
#  unzipped the coal aimms files to the p2 folder only
    ?C@ access="$NEMS/scripts/access.dsn"
    ?C@ AIMMSBIT=?AIMMS64@
    ?C@ echo "AIMMSBIT option to use 64-bit odbc template: $AIMMSBIT"
    ?C@ if [[ "$AIMMSBIT" = "1" && "?AIMMSVER@" = "4" ]] ; then
    ?C@   access="$NEMS/scripts/access64.dsn"
    ?C@ fi
    ?C@ echo "aimms odbc template file: $access"
    ?C@ if [ "$p" = "p2" ] ; then
    ?C@   echo "coal directory for coal AIMMS project"
    ?C@   if [ ! -d coal ] ; then
    ?C@     mkdir coal
    ?C@   fi
# We touch the .ams file after unzipping to update the time stamp to prevent possible errors from cygwin
    ?C@ # Copy over the entire unzipped coal folder, instead of winzip unzip -od command
    ?C@   cp -rf ?COALN@/* ./coal > /dev/null
    ?C@   touch ./coal/mainproject/coal.ams
    ?C@ # python alternative to winzip:
    ?C@ # python $NEMS/scripts/unzip.py ?COPYDIR@/coal.zip ./coal
    ?C@   cp $access coal/coal_out.mdb.dsn
    ?C@   echo "DBQ=coal_out.mdb"         >> coal/coal_out.mdb.dsn
    ?C@ fi
    # The following line sets up diagnostic messaging for the AIMMS SDK "aimmslink" process. for NGMM and COAL
    cp $NEMS/scripts/*.logger.xml .

# these 3 small AIMMS database description files are sometimes needed after the run, so put them in all input folders, not just p2,
# since only one copy of the input folder (p3) is saved after the run (when invoked via runit.exe)
    ?C@ cp $access ?COPYDIR@/cmm.mdb.dsn
    ?C@ cp $access ?COPYDIR@/cmm2.mdb.dsn
    ?C@ cp $access ?COPYDIR@/cps.mdb.dsn
    ?C@ if [ "?AIMMSVER@" = "4" ] ; then
    ?C@ #  add extra "." so it looks for the input (copydir) in the parent folder 
    ?C@   echo "DBQ=.?COPYDIR@/cmm.mdb"    | sed 's/\//\\/g'          >> ?COPYDIR@/cmm.mdb.dsn
    ?C@   echo "DBQ=.?COPYDIR@/cmm2.mdb"   | sed 's/\//\\/g'          >> ?COPYDIR@/cmm2.mdb.dsn
    ?C@   echo "DBQ=.?COPYDIR@/cps.mdb"    | sed 's/\//\\/g'          >> ?COPYDIR@/cps.mdb.dsn
    ?C@ else
    ?C@   echo "DBQ=?COPYDIR@/cmm.mdb"    | sed 's/\//\\/g'          >> ?COPYDIR@/cmm.mdb.dsn
    ?C@   echo "DBQ=?COPYDIR@/cmm2.mdb"   | sed 's/\//\\/g'          >> ?COPYDIR@/cmm2.mdb.dsn
    ?C@   echo "DBQ=?COPYDIR@/cps.mdb"    | sed 's/\//\\/g'          >> ?COPYDIR@/cps.mdb.dsn
    ?C@ fi

    ?E@ if [ "$p" = "p2" ] ; then
# only add these AIMMS EFD files for the p2 run
    ?E@   if [ "?AIMMSEFD@" = "1" ] ; then
    ?E@     echo "efd directory for efd AIMMS project"
    ?E@     if [ ! -d efd ] ; then
    ?E@       mkdir efd
    ?E@     fi
    ?E@     cp -rf ?EFDN@/* ./efd > /dev/null
    ?E@     touch ./efd/mainproject/efd.ams
    ?E@   fi
    ?E@   if [ "?AIMMSECP@" = "1" ] ; then
    ?E@     echo "ecp directory for ecp AIMMS project" 
    ?E@     if [ ! -d ecp ] ; then
    ?E@       mkdir ecp
    ?E@     fi
    ?E@     cp -rf ?ECPN@/* ./ecp > /dev/null
    ?E@     touch ./ecp/mainproject/ecp.ams
    ?E@   fi
    ?E@   if [ "?RUNSTORE@" = "1" ] ; then
    ?E@     echo "rest directory for wind, solar, and electricity storage project"
    ?E@     if [ ! -d rest ] ; then
    ?E@       mkdir rest
    ?E@     fi
    ?E@     cp -rf ?RESTOREN@/* ./rest > /dev/null
    ?E@     touch ./rest/mainproject/EMM_renewable.ams
    ?E@   fi
	?E@   if [ "?RUNEMMSQL@" = "1" ] ; then
    ?E@     echo "emm_db directory for emm_db AIMMS project"
    ?E@     if [ ! -d emm_db ] ; then
    ?E@       mkdir emm_db
    ?E@     fi
    ?E@     cp -rf ?EMM_DBN@/* ./emm_db > /dev/null
    ?E@   fi
    ?E@ fi


    ?G@ if [ "$p" = "p1" ] ; then
    ?G@   if [ "?AIMMSNG@" = "1" ] ; then
    ?G@     echo "ngas directory for ngas AIMMS project"
    ?G@     if [ ! -d ngas ] ; then
    ?G@       mkdir ngas
    ?G@     fi
    ?G@     cp -rf ?NGAIMMSN@/* ./ngas > /dev/null
    ?G@     touch ./ngas/mainproject/natgas.ams
    ?G@   fi
    ?G@ fi

    cat $NEMS/scripts/deloml.bat > hswrk.bat
    runoml=`expr ?EXE@ + ?EXC@ + ?EXH@`
    if [ $runoml -gt 0 ] ; then
      runoml=1
      echo "OML is being used in this run"
    else
      runoml=0
      echo "OML is not being used in this run"
    fi 
     if [ "$copyem" != "0" ] ; then
       if [ "?NRUNS@" = 1 ] ; then
            echo "NRUNS set to 1"
    ?E@     cp -f ?BASEMMIN@?BASEMMID@ ?COPYDIR@/basemmi.txt
    ?E@     echo "copy ?COPYDIR@/basemmi.txt BASEMMI.dat" | sed 's/\//\\/g' >> hswrk.bat
    ?E@     cp -f ?BASEFDIN@?BASEFDID@ ?COPYDIR@/BASEFDi.txt
    ?E@     echo "copy ?COPYDIR@/BASEFDi.txt BASEFDI.dat" | sed 's/\//\\/g' >> hswrk.bat
    ?C@     echo "copy ?COPYDIR@/BASCMMi.dat BASCMMI.dat" | sed 's/\//\\/g' >> hswrk.bat
       else
         echo "NRUNS set to ?NRUNS@"
    ?E@     echo "copy basemmi BASEMMI.dat"  >> hswrk.bat
    ?E@     echo "copy basefdi BASEFDI.dat"  >> hswrk.bat
    ?C@     echo "copy bascmmi BASCMMI.dat"  >> hswrk.bat
       fi
    ?E@   echo "copy ?COPYDIR@/basemmo.txt BASEMMO.dat" | sed 's/\//\\/g' >> hswrk.bat
    ?E@   cp -f ?PLNTDAFN@?PLNTDAFD@ ?COPYDIR@/plntdaf.daf
    ?E@   echo "copy ?COPYDIR@/plntdaf.daf PLNTTMP.daf" | sed 's/\//\\/g' >> hswrk.bat
    ?E@   cp -f ?CTSSHELLN@?CTSSHELLD@ ?COPYDIR@/ctsshell.gms
    ?E@   echo "copy ?COPYDIR@/ctsshell.gms ctsshell.gms" | sed 's/\//\\/g' >> hswrk.bat
    ?E@   cp -f ?CTSINDATN@?CTSINDATD@ ?COPYDIR@/ctsindat.gms
    ?E@   echo "copy ?COPYDIR@/ctsindat.gms ctsindat.gms" | sed 's/\//\\/g' >> hswrk.bat
    ?E@   cp -f ?CTSPREPN@?CTSPREPD@ ?COPYDIR@/ctsprep.gms
    ?E@   echo "copy ?COPYDIR@/ctsprep.gms ctsprep.gms" | sed 's/\//\\/g' >> hswrk.bat
    ?E@   cp -f ?CTSMODELN@?CTSMODELD@ ?COPYDIR@/ctsmodel.gms
    ?E@   echo "copy ?COPYDIR@/ctsmodel.gms ctsmodel.gms" | sed 's/\//\\/g' >> hswrk.bat
    ?E@   cp -f ?CTSCHECKN@?CTSCHECKD@ ?COPYDIR@/ctscheck.gms
    ?E@   echo "copy ?COPYDIR@/ctscheck.gms ctscheck.gms" | sed 's/\//\\/g' >> hswrk.bat
    ?E@   cp -f ?CTSREPRTN@?CTSREPRTD@ ?COPYDIR@/ctsreprt.gms
    ?E@   echo "copy ?COPYDIR@/ctsreprt.gms ctsreprt.gms" | sed 's/\//\\/g' >> hswrk.bat
       cp -f ?EMMDBN@?EMMDBD@ ?COPYDIR@/emmdb.mdb
       echo "copy ?COPYDIR@/emmdb.mdb EMMDB.mdb" | sed 's/\//\\/g' >> hswrk.bat
    ?C@   echo "copy ?COPYDIR@/coal_out.mdb     coal_out.mdb"     | sed 's/\//\\/g' >> hswrk.bat
    ?M@   cp -f ?MCHIGHLON@?MCHIGHLOD@ ?COPYDIR@/mchighlo.xls
    ?M@   echo "copy ?COPYDIR@/mchighlo.xls mchighlo.xls" | sed 's/\//\\/g' >> hswrk.bat
    ?M@   cp -f ?COMFLOORN@?COMFLOORD@ ?COPYDIR@/comfloor.xls
    ?M@   echo "copy ?COPYDIR@/comfloor.xls comfloor.xls" | sed 's/\//\\/g' >> hswrk.bat
    ?M@   cp -f ?EVIEWS32N@?EVIEWS32D@ ?COPYDIR@/eviews32.ini
    ?M@   echo "copy ?COPYDIR@/eviews32.ini eviews32.ini" | sed 's/\//\\/g' >> hswrk.bat
    ?E@   cp -f ?ETTDEMN@?ETTDEMD@ ?COPYDIR@/ettdem.daf
    ?E@   echo "copy ?COPYDIR@/ettdem.daf ETTTMP.daf" | sed 's/\//\\/g' >> hswrk.bat
     else
       if [ "?NRUNS@" = 1 ] ; then
            echo "NRUNS set to 1"
    ?E@     echo "copy ?BASEMMIN@?BASEMMID@ BASEMMI.dat" | sed 's/\//\\/g' >> hswrk.bat
    ?E@     echo "copy ?BASEFDIN@?BASEFDID@ BASEFDI.dat" | sed 's/\//\\/g' >> hswrk.bat
       else
         echo "NRUNS set to ?NRUNS@"
    ?E@     echo "copy basemmi BASEMMI.dat"  >> hswrk.bat
    ?E@     echo "copy basefdi BASEFDI.dat"  >> hswrk.bat
    ?C@     echo "copy bascmmi BASCMMI.dat"  >> hswrk.bat
       fi
    ?E@   echo "copy ?PLNTDAFN@?PLNTDAFD@ PLNTTMP.daf" | sed 's/\//\\/g' >> hswrk.bat
    ?E@   echo "copy ?CTSSHELLN@?CTSSHELLD@ ctsshell.gms" | sed 's/\//\\/g' >> hswrk.bat
    ?E@   echo "copy ?CTSINDATN@?CTSINDATD@ ctsindat.gms" | sed 's/\//\\/g' >> hswrk.bat
    ?E@   echo "copy ?CTSPREPN@?CTSPREPD@ ctsprep.gms" | sed 's/\//\\/g' >> hswrk.bat
    ?E@   echo "copy ?CTSMODELN@?CTSMODELD@ ctsmodel.gms" | sed 's/\//\\/g' >> hswrk.bat
    ?E@   echo "copy ?CTSCHECKN@?CTSCHECKD@ ctscheck.gms" | sed 's/\//\\/g' >> hswrk.bat
    ?E@   echo "copy ?CTSREPRTN@?CTSREPRTD@ ctsreprt.gms" | sed 's/\//\\/g' >> hswrk.bat
    ?M@   echo "copy ?MCHIGHLON@?MCHIGHLOD@ mchighlo.xls" | sed 's/\//\\/g' >> hswrk.bat
    ?M@   echo "copy ?COMFLOORN@?COMFLOORD@ comfloor.xls" | sed 's/\//\\/g' >> hswrk.bat
    ?M@   echo "copy ?EVIEWS32N@?EVIEWS32D@ eviews32.ini" | sed 's/\//\\/g' >> hswrk.bat
    ?E@   echo "copy ?ETTDEMN@?ETTDEMD@ ETTTMP.daf" | sed 's/\//\\/g' >> hswrk.bat
     fi
    ?O@ if [ "$copyem" != "0" ] ; then
    ?O@   cp -f ?LF_NEMN@?LF_NEMD@ ?COPYDIR@/lf_nem.gms
    ?O@   echo "copy ?COPYDIR@/lf_nem.gms lf_nem.gms" | sed 's/\//\\/g' >> hswrk.bat
    ?O@   cp -f ?LFINPUTN@?LFINPUTD@ ?COPYDIR@/lfinput.gms
    ?O@   echo "copy ?COPYDIR@/lfinput.gms lfinput.gms" | sed 's/\//\\/g' >> hswrk.bat
    ?O@   cp -f ?LFMODELN@?LFMODELD@ ?COPYDIR@/lfmodel.gms
    ?O@   echo "copy ?COPYDIR@/lfmodel.gms lfmodel.gms" | sed 's/\//\\/g' >> hswrk.bat
    ?O@   cp -f ?LFPREPN@?LFPREPD@ ?COPYDIR@/lfprep.gms
    ?O@   echo "copy ?COPYDIR@/lfprep.gms lfprep.gms" | sed 's/\//\\/g' >> hswrk.bat
    ?O@   cp -f ?LFREPSETN@?LFREPSETD@ ?COPYDIR@/lfrepset.gms
    ?O@   echo "copy ?COPYDIR@/lfrepset.gms lfrepset.gms" | sed 's/\//\\/g' >> hswrk.bat
    ?O@   cp -f ?LFREPORTN@?LFREPORTD@ ?COPYDIR@/lfreport.gms
    ?O@   echo "copy ?COPYDIR@/lfreport.gms lfreport.gms" | sed 's/\//\\/g' >> hswrk.bat
    ?O@   cp -f ?LFSHELLN@?LFSHELLD@ ?COPYDIR@/lfshell.gms
    ?O@   echo "copy ?COPYDIR@/lfshell.gms lfshell.gms" | sed 's/\//\\/g' >> hswrk.bat
    ?O@   cp -f ?MPSSHELLN@?MPSSHELLD@ ?COPYDIR@/mpsshell.gms
    ?O@   echo "copy ?COPYDIR@/mpsshell.gms mpsshell.gms" | sed 's/\//\\/g' >> hswrk.bat
    ?O@   cp -f ?CRE8MPSN@?CRE8MPSD@ ?COPYDIR@/cre8mps.gms
    ?O@   echo "copy ?COPYDIR@/cre8mps.gms cre8mps.gms" | sed 's/\//\\/g' >> hswrk.bat
    ?O@ else
    ?O@   echo "copy ?LF_NEMN@?LF_NEMD@ lf_nem.gms" | sed 's/\//\\/g' >> hswrk.bat
    ?O@   echo "copy ?LFINPUTN@?LFINPUTD@ lfinput.gms" | sed 's/\//\\/g' >> hswrk.bat
    ?O@   echo "copy ?LFMODELN@?LFMODELD@ lfmodel.gms" | sed 's/\//\\/g' >> hswrk.bat
    ?O@   echo "copy ?LFPREPN@?LFPREPD@ lfprep.gms" | sed 's/\//\\/g' >> hswrk.bat
    ?O@   echo "copy ?LFREPSETN@?LFREPSETD@ lfrepset.gms" | sed 's/\//\\/g' >> hswrk.bat
    ?O@   echo "copy ?LFREPORTN@?LFREPORTD@ lfreport.gms" | sed 's/\//\\/g' >> hswrk.bat
    ?O@   echo "copy ?LFSHELLN@?LFSHELLD@ lfshell.gms" | sed 's/\//\\/g' >> hswrk.bat
    ?O@   echo "copy ?MPSSHELLN@?MPSSHELLD@ mpsshell.gms" | sed 's/\//\\/g' >> hswrk.bat
    ?O@   echo "copy ?CRE8MPSN@?CRE8MPSD@ cre8mps.gms" | sed 's/\//\\/g' >> hswrk.bat
    ?O@ fi
    
    echo " Linking NEMS object code to create an executable"
    
    OMLVERS="?OMLVERS@"
    echo  "$LIB \n" | grep -i "$OMLVERS" > /dev/null 
    if [ $? -eq 1 ] ; then
      LIB="$NEMS\\OML\\$OMLVERS;$LIB"
    fi
    LIB="$LIB;$NEMS\\scripts" ;# To find aimmslink.lib and delayimp.lib
    
    OMLLIBS=" OMLDB32.LIB OMLLIB32.LIB OMLLP32.LIB OMLWIN32.LIB OMLXPR32.LIB CRP32DLL.LIB user32.lib gdi32.lib xprs.lib"
    if [ "$OMLVERS" = "oml32" ] ; then
      OMLLIBS=" OMLDB32.LIB OMLLIB32.LIB OMLLP32.LIB OMLWIN32.LIB OMLXPRS32.LIB"
    fi

    lnkinems=?LNKINEMS@
    if [[ "$lnkinems" = "4" || "$lnkinems" = "5" ]] ; then
      OMLLIBS=" OMLDB64.LIB OMLLIB64.LIB OMLLP64.LIB OMLWIN64.LIB OMLXPRS64.LIB"
    fi

    dbwrite=0 
    dbmodon=0
    dbwrite=`expr $dbwrite + ?ORCLECP@ + ?ORCLEFD@ + ?ORCLEFP@`
    dbmodon=`expr $dbmodon + ?EXE@`
 
#   Everything except electricity, renewables, and coal 
    OBJS1="\
    ?MAINN@?MAIND@.obj \
    ?NEMSFUNCTN@?NEMSFUNCTD@.obj \
    ?EPMN@?EPMD@.obj \
    ?FILEMGRN@?FILEMGRD@.obj \
    ?FILERN@?FILERD@.obj \
    ?GDXF9DEFN@?GDXF9DEFD@.obj \
    ?GDXF9GLUN@?GDXF9GLUD@.obj \
    ?FWK1ION@?FWK1IOD@.obj \
    ?R@?HEMN@?HEMD@.obj \
    ?I@?INDN@?INDD@.obj \
    ?M@?MACN@?MACD@.obj \
    ?O@?REFINEN@?REFINED@.obj \
    ?O@?REFETHN@?REFETHD@.obj \
    ?O@?REFRPTN@?REFRPTD@.obj \
    ?O@?REFCHGN@?REFCHGD@.obj \
    ?O@?REFSLNN@?REFSLND@.obj \
    ?O@?REFINTLN@?REFINTLD@.obj \
    ?O@?REFCO2N@?REFCO2D@.obj \
    ?T@?TRANN@?TRAND@.obj \
    ?T@?TRANFRTN@?TRANFRTD@.obj \
    ?T@?TRANAIRN@?TRANAIRD@.obj \
    ?L@?WELLAKN@?WELLAKD@.obj \
    ?L@?WELLEORN@?WELLEORD@.obj \
    ?L@?WELLIMPN@?WELLIMPD@.obj \
    ?L@?WELLONN@?WELLOND@.obj \
    ?L@?WELLOFFN@?WELLOFFD@.obj \
    ?L@?WELLOGSN@?WELLOGSD@.obj \
    ?L@?WELLCOSTN@?WELLCOSTD@.obj \
    ?L@?WELLDCFN@?WELLDCFD@.obj \
    ?L@?WELLEXPN@?WELLEXPD@.obj \
    ?L@?WELLREPN@?WELLREPD@.obj \
    ?L@?WELLUGRN@?WELLUGRD@.obj \
    ?L@?CTUSN@?CTUSD@.obj \
    ?W@?WORLDN@?WORLDD@.obj \
    ?K@?COMMN@?COMMD@.obj \
    ?R@?RESDN@?RESDD@.obj \
    ?NEMSWK1N@?NEMSWK1D@.obj \
    ?CIO4WK1N@?CIO4WK1D@.obj \
    ?DUMMYXN@?DUMMYXD@.obj "   

    if [[ $dbwrite -gt 0 && $dbmodon -gt 0 ]] ; then
      OBJS1="$OBJS1 \
      ?ORCLTABSN@?ORCLTABSD@.obj \
      "
    fi    
    
# Electric/Coal/Renewables/residential/ngmm/ogsm   
    OBJS2="\
    ?MAINN@?MAIND@.obj \
    ?NEMSFUNCTN@?NEMSFUNCTD@.obj \
    ?EPMN@?EPMD@.obj \
    ?FILEMGRN@?FILEMGRD@.obj \
    ?FILERN@?FILERD@.obj \
    ?GDXF9DEFN@?GDXF9DEFD@.obj \
    ?GDXF9GLUN@?GDXF9GLUD@.obj \
    ?FWK1ION@?FWK1IOD@.obj \
    ?N@?RENEWN@?RENEWD@.obj \
    ?UREADN@?UREADD@.obj \
    ?E@?UCAPEN@?UCAPED@.obj \
    ?E@?UDAFN@?UDAFD@.obj \
    ?E@?UDATN@?UDATD@.obj \
    ?E@?UECPN@?UECPD@.obj \
	?E@?UESQLN@?UESQLD@.obj \
	?E@?FSQLITEN@?FSQLITED@.obj \
    ?E@?UEFDN@?UEFDD@.obj \
    ?E@?UEFPN@?UEFPD@.obj \
    ?E@?ULDSMN@?ULDSMD@.obj \
    ?E@?UNUGSN@?UNUGSD@.obj \
    ?E@?UTILN@?UTILD@.obj \
    ?E@?UAIMMSN@?UAIMMSD@.obj \
    ?E@?ECP_ROW_COLN@?ECP_ROW_COLD@.obj \
    ?E@?EFD_ROW_COLN@?EFD_ROW_COLD@.obj \
    ?R@?RESDN@?RESDD@.obj \
    ?K@?COMMN@?COMMD@.obj \
    ?R@?HEMN@?HEMD@.obj \
    ?H@?HMMN@?HMMD@.obj \
    ?NEMSWK1N@?NEMSWK1D@.obj \
    ?CIO4WK1N@?CIO4WK1D@.obj \
    ?DUMMYXN@?DUMMYXD@.obj "   

    if [[ $dbwrite -gt 0 && $dbmodon -gt 0 ]] ; then
      OBJS2="$OBJS2 \
      ?ORCLTABSN@?ORCLTABSD@.obj \
      "
    fi

#   Emissions and industrial to recompute emissions and totals.   
    OBJS3="\
    ?MAINN@?MAIND@.obj \
    ?NEMSFUNCTN@?NEMSFUNCTD@.obj \
    ?EPMN@?EPMD@.obj \
    ?FILEMGRN@?FILEMGRD@.obj \
    ?FILERN@?FILERD@.obj \
    ?GDXF9DEFN@?GDXF9DEFD@.obj \
    ?GDXF9GLUN@?GDXF9GLUD@.obj \
    ?FWK1ION@?FWK1IOD@.obj \
    ?I@?INDN@?INDD@.obj \
    ?NEMSWK1N@?NEMSWK1D@.obj \
    ?CIO4WK1N@?CIO4WK1D@.obj "

    if [[ $dbwrite -gt 0 && $dbmodon -gt 0 ]] ; then
      OBJS3="$OBJS3 \
      ?ORCLTABSN@?ORCLTABSD@.obj \
      "
    fi
   
    if [ "$p" = "p1" ] ; then
      OBJS=$OBJS1
      # Switch off Electric and Coal
      sed "/ EXN/s/^1/0/;/ EXE/s/^1/0/;/ EXC/s/^1/0/" jcl.dat > jclnew.dat;mv jclnew.dat jcl.dat
    elif [ "$p" = "p2" ] ; then
      OBJS=$OBJS2
      # Switch off everything, then turn on Coal, Electric, Renewable, Residential, Commercial
      sed "/ EX/s/^1/0/;/ EXC/s/^0/?EXC@/;/ EXE/s/^0/?EXE@/;/ EXN/s/^0/?EXN@/;/ EXR/s/^0/?EXR@/;/ EXK/s/^0/?EXK@/;" jcl.dat > jclnew.dat;mv jclnew.dat jcl.dat
      cp -f input/varlist.txt input/varlistall.txt
      cp -f input/varlistrec.txt input/varlist.txt

# copy executable for converting plant group data from text file to access database
      if [[ $dbwrite -gt 0 && $dbmodon -gt 0 ]] ; then
        cp ?UDBPN@?UDBPD@ udbp.exe
      fi
    else
      # p3:  leave on industrial as small module so epm will run.  
      OBJS=$OBJS3
      sed "/ EX/s/^1/0/;/ EXI/s/^0/1/" jcl.dat > jclnew.dat;mv jclnew.dat jcl.dat
      grep -iv iterdump MOREOPT > m
      echo "ITERDUMP 0" >> m
      mv m MOREOPT
    fi
   
    if [ "$runoml" = 1 ] ; then
      OBJS="$OBJS ?DUMPACKN@?DUMPACKD@.obj "
    else
      OMLLIBS=" "
    fi 
     notthere=0
     for item in $OBJS
     do
        echo "$item" | sed 's/\/\//\\\\/;s/\//\\/g' >> nems.objs
        sh $NEMS/scripts/checkfor.z.sh $item print
        if [ $? -ne "0" ] ; then
          notthere=1
        fi
     done
     if [ $notthere -eq 1 ] ;then
       echo "not continuing because of missing object files"

       exit
     fi
  
    # set the directory for link files to the current directory
    TMP="$PWD"
    export TMP
    
    if [ "$lnkinems" = "0" ] ; then
    # link with CVF linker
      link /out:nems.exe /warn:0 /debug:full /map:nems.map /FORCE @nems.objs $OMLLIBS f90sql.lib
    else
    # link with Intel (version number set above).  Set required environment strings and search paths first.
      if [ "$lnkinems" = "3" ] ; then
          IVERS="11.1";export IVERS
          . $NEMS/scripts/ifortvars.sh
        xilink /out:nems.exe /incremental:no  /debug /map:nems.map /FORCE /NODEFAULTLIB:"libc.lib" /DELAYLOAD:"aimmslink.dll" @nems.objs $OMLLIBS f90sql.lib aimmslink.lib delayimp.lib
   
      elif [ "$lnkinems" = "4" ] ; then
          IVERS="11.1";export IVERS
          . $NEMS/scripts/ifortvars64x64.sh
		  if [ "?RUNEMMSQL@" = "1" ] ; then
		     xilink /out:nems.exe /incremental:no  /debug /map:nems.map /FORCE /NODEFAULTLIB:"libc.lib" /DELAYLOAD:"aimmslink.dll" @nems.objs $OMLLIBS aimmslink64.lib delayimp64.lib libfsqlite.lib
		  else
             xilink /out:nems.exe /incremental:no  /debug /map:nems.map /FORCE /NODEFAULTLIB:"libc.lib" /DELAYLOAD:"aimmslink.dll" @nems.objs $OMLLIBS aimmslink64.lib delayimp64.lib
		  fi
      elif [ "$lnkinems" = "5" ] ; then
          IVERS="18.1";export IVERS
          . $NEMS/scripts/ifortvars18.sh
		  if [ "?RUNEMMSQL@" = "1" ] ; then
		     xilink /out:nems.exe /incremental:no  /subsystem:console /debug /map:nems.map /FORCE /NODEFAULTLIB:"libc.lib" /DELAYLOAD:"aimmslink.dll" @nems.objs $OMLLIBS aimmslink64.lib delayimp64.lib legacy_stdio_definitions.lib libfsqlite.lib
		  else
             xilink /out:nems.exe /incremental:no  /subsystem:console /debug /map:nems.map /FORCE /NODEFAULTLIB:"libc.lib" /DELAYLOAD:"aimmslink.dll" @nems.objs $OMLLIBS aimmslink64.lib delayimp64.lib legacy_stdio_definitions.lib
		  fi
      else
        if [ "$lnkinems" = "2" ] ; then
          IVERS="9.1";export IVERS
            . $NEMS/scripts/ifortvars.sh
        else
          IVERS="9.0";export IVERS
          . $NEMS/scripts/ifortvars.sh
        fi
        xilink /out:nems.exe /incremental:no    /debug:full /map:nems.map /FORCE /DELAYLOAD:"aimmslink.dll" @nems.objs $OMLLIBS f90sql.lib aimmslink.lib delayimp.lib
      fi
    fi
    # copy dll required for GDX and AIMMS interfaces
    if [[ "$lnkinems" = "4" || "$lnkinems" = "5" ]] ; then
      if [ ! -f gdxdclib64.dll ] ; then
        echo copying gdxdclib64.dll
        cp $NEMS/scripts/gdxdclib64.dll .
      fi
      if [ ! -f aimmslink.dll ] ; then
        echo copying aimmslink64.dll
        cp $NEMS/scripts/aimmslink64.dll aimmslink.dll
      fi
    
    else
    # copy 32-bit dll required for GDX and AIMMS interfaces
      if [ ! -f gdxdclib.dll ] ; then
        echo copying gdxdclib.dll
        cp $NEMS/scripts/gdxdclib.dll .
      fi
      if [ ! -f aimmslink.dll ] ; then
        echo copying aimmslink.dll
        cp $NEMS/scripts/aimmslink.dll .
      fi
    fi
    
    if [ "$runoml" = 1 ] ; then
      cp -f $NEMS/oml/$OMLVERS/*.dll .
    # cp master.cr to mps.cr in output directory. mps.cr gets used if it is found there
      cp ?MASTERN@?MASTERD@ mps.cr
      cp ?XPRESSINN@?XPRESSIND@ xprsparms.txt
    fi 
    
    # cycle restart file  and EMM basis files if this is a multi-cycle run
    if [ ?NRUNS@ -gt 1 ] ; then
      cp ?RESTARTN@?RESTARTD@ RESTART.IN
      ?E@  cp ?BASEMMIN@?BASEMMID@ basemmi
      ?E@  cp ?BASEFDIN@?BASEFDID@ basefdi
    fi 

    # make sure everything is readable and writable 
    chmod ug+rw *
    chmod 777 input    
   
    # clean-up script
    nems="$NEMS"
    cp ?CLEANUP@ cleanup.sh
    chmod 777 cleanup.sh 
   
# end of loop for setting up parallel folders.  
   
   cd .. 
done
#=====================================================================================================================================
# Remainder sets up the parent folder.

if [ "$copyem" != "0" ] ; then
  # set up the input folder for ftab inputs
  if [ ! -d ?COPYDIR@ ] ; then
    mkdir ?COPYDIR@
  fi
  echo "           ?COPYDIR@/iccnvrg.txt" >> intercvfiles.txt
fi

if [ "$copyem" != "0" ] ; then
  if [ "?NRUNS@" = 1 ] ; then
     cp -f ?RESTARTN@?RESTARTD@ ?COPYDIR@/restarti.unf
     echo "           RESTART.unf" > intercvfiles.txt
     echo "           1" >> intercvfiles.txt
     echo "           ?COPYDIR@/restarti.unf" >> intercvfiles.txt
     echo "           1" >> intercvfiles.txt
  else
     cp -f $NEMS/scripts/intercvfiles.txt .
     chmod 666 intercvfiles.txt
  fi
  cp -f ?ICCNVRGN@?ICCNVRGD@ ?COPYDIR@/iccnvrg.txt
  echo "           ?COPYDIR@/iccnvrg.txt" >> intercvfiles.txt
  cp -f ?DICTN@?DICTD@ ?COPYDIR@/dict.txt
  echo "           ?COPYDIR@/dict.txt" >> intercvfiles.txt
  cp -f ?VARLISTN@?VARLISTD@ ?COPYDIR@/varlist.txt
  echo "           ?COPYDIR@/varlist.txt" >> intercvfiles.txt
  echo "           ?FILERN@?FILERD@" >> intercvfiles.txt
else
  if [ "?NRUNS@" = 1 ] ; then
     echo "           RESTART.unf" > intercvfiles.txt
     echo "           1" >> intercvfiles.txt
     echo "           ?RESTARTN@?RESTARTD@" >> intercvfiles.txt
     echo "           1" >> intercvfiles.txt
  else
     cp $NEMS/scripts/intercvfiles.txt .
  fi
  echo "           ?ICCNVRGN@?ICCNVRGD@" >> intercvfiles.txt
  echo "           ?DICTN@?DICTD@" >> intercvfiles.txt
  echo "           ?VARLISTN@?VARLISTD@" >> intercvfiles.txt
  echo "           ?FILERN@?FILERD@" >> intercvfiles.txt
fi



interobs="\
?INTERCVN@?INTERCVD@.obj \
?FILERN@?FILERD@.obj \
?GDXF9DEFN@?GDXF9DEFD@.obj \
?GDXF9GLUN@?GDXF9GLUD@.obj \
?CIO4WK1N@?CIO4WK1D@.obj \
?FWK1ION@?FWK1IOD@.obj \
" 

 notthere=0
 for item in $interobs
 do
    echo "$item" | sed 's/\/\//\\\\/;s/\//\\/g' >>  intercv.objs 
    sh $NEMS/scripts/checkfor.z.sh $item print
    if [ $? -ne "0" ] ; then
      notthere=1
    fi
 done
 if [ $notthere -eq 1 ] ;then
   echo "not continuing because of missing intercv object files"
   echo -n "Hit Enter";read ans
   exit
 fi

# always build filer which will be used to combine the two parallel restart files.
tfobs="\
?TFILERN@?TFILERD@.obj \
?R@?RESDN@?RESDD@.obj \
?K@?COMMN@?COMMD@.obj \
?FILEMGRN@?FILEMGRD@.obj \
?FILERN@?FILERD@.obj \
?GDXF9DEFN@?GDXF9DEFD@.obj \
?GDXF9GLUN@?GDXF9GLUD@.obj \
?CIO4WK1N@?CIO4WK1D@.obj \
?FWK1ION@?FWK1IOD@.obj \
?NEMSWK1N@?NEMSWK1D@.obj \
?DUMMYXN@?DUMMYXD@.obj "

 notthere=0
 for item in $tfobs
 do
    echo "$item" | sed 's/\/\//\\\\/;s/\//\\/g' >>  tfiler.objs 
    sh $NEMS/scripts/checkfor.z.sh $item print
    if [ $? -ne "0" ] ; then
      notthere=1
    fi
 done
 if [ $notthere -eq 1 ] ;then
   echo "not continuing because of missing tfiler object files"
   echo -n "Hit Enter";read ans
   exit
 fi

echo " "
echo " Linking FTAB object code to create an executable"
OBJSFTAB="\
?FTABN@?FTABD@.obj \
?FTAB2N@?FTAB2D@.obj \
?FILERN@?FILERD@.obj \
?GDXF9DEFN@?GDXF9DEFD@.obj \
?GDXF9GLUN@?GDXF9GLUD@.obj \
?FWK1ION@?FWK1IOD@.obj \
?CIO4WK1N@?CIO4WK1D@.obj "
 notthere=0
 for item in $OBJSFTAB
 do
    echo "$item" | sed 's/\/\//\\\\/;s/\//\\/g' >> ftab.objs
    sh $NEMS/scripts/checkfor.z.sh $item print
    if [ $? -ne "0" ] ; then
      notthere=1
    fi
 done
 if [ $notthere -eq 1 ] ;then
   echo "not continuing because of missing object files"
   exit
 fi
if [ "$lnkinems" = "0" ] ; then
  link /out:ftab.exe /warn:0 /debug:full /FORCE @ftab.objs
  link /out:intercv.exe /incremental:no /warn:0 /debug:full @intercv.objs
  link /out:tfiler.exe /incremental:no /warn:0 /debug:full /map:tfiler.map /FORCE @tfiler.objs
elif [ "$lnkinems" = "4" ] ; then
  xilink /out:ftab.exe /debug /FORCE /NODEFAULTLIB:"libc.lib" /DELAYLOAD:"aimmslink.dll" @ftab.objs aimmslink64.lib delayimp64.lib 
  xilink /out:intercv.exe /incremental:no /debug /FORCE /NODEFAULTLIB:"libc.lib" /DELAYLOAD:"aimmslink.dll" @intercv.objs aimmslink64.lib delayimp64.lib
  xilink /out:tfiler.exe /incremental:no /debug /map:tfiler.map /FORCE /NODEFAULTLIB:"libc.lib" /DELAYLOAD:"aimmslink.dll" @tfiler.objs aimmslink64.lib delayimp64.lib
elif [ "$lnkinems" = "5" ] ; then
  xilink /out:ftab.exe /subsystem:console /debug /FORCE /NODEFAULTLIB:"libc.lib" /DELAYLOAD:"aimmslink.dll" @ftab.objs aimmslink64.lib delayimp64.lib legacy_stdio_definitions.lib
  xilink /out:intercv.exe /subsystem:console /incremental:no /debug /FORCE /NODEFAULTLIB:"libc.lib" /DELAYLOAD:"aimmslink.dll" @intercv.objs aimmslink64.lib delayimp64.lib legacy_stdio_definitions.lib
  xilink /out:tfiler.exe /subsystem:console /incremental:no /debug /map:tfiler.map /FORCE /NODEFAULTLIB:"libc.lib" /DELAYLOAD:"aimmslink.dll" @tfiler.objs aimmslink64.lib delayimp64.lib legacy_stdio_definitions.lib
else
  xilink /out:ftab.exe /debug /FORCE /NODEFAULTLIB:"libc.lib" /DELAYLOAD:"aimmslink.dll" @ftab.objs aimmslink.lib delayimp.lib  legacy_stdio_definitions.lib
  xilink /out:intercv.exe /incremental:no /debug /FORCE /NODEFAULTLIB:"libc.lib" /DELAYLOAD:"aimmslink.dll" @intercv.objs aimmslink.lib delayimp.lib
  xilink /out:tfiler.exe /incremental:no /debug /map:tfiler.map /FORCE /NODEFAULTLIB:"libc.lib" /DELAYLOAD:"aimmslink.dll" @tfiler.objs aimmslink.lib delayimp.lib
fi

#  create scedes.all so future run replication/archival will work
if [ -f $OLDDIR/scedes.all.$scenario.$datekey ] ; then
  cp $OLDDIR/scedes.all.$scenario.$datekey scedes.all
# rm $OLDDIR/scedes.all.$scenario.$datekey
fi


#$NEMS/scripts/saverun.exe keys.sed.$scenario.$datekey


# 
echo "*********************************"
echo " "
 
DATE=`date`
echo "$scenario     " > ftab.dat
echo "$datekey      " >> ftab.dat
echo "run in $OUTDIR on $DATE" >> ftab.dat
echo "?FTABCOLS@              MAXCOL               MAX COLS/PG" >> ftab.dat
echo "?FTABCOLW@               ICOLWD       REPORT COLUMN WIDTH" >> ftab.dat
echo "?FTABREG@               IPREGD     PRINT REGIONS (1=YES)" >> ftab.dat
echo "?FOOTNOTE@               IPRFTN    PRINT FOOTNOTES (1=YES)" >> ftab.dat
echo "?FTAB1ST@            IFSTYR    FIRST PRINT YEAR" >> ftab.dat
echo "?FTABLAST@            ILSTYR    LAST PRINT YEAR" >> ftab.dat
echo "?FTABGROW@          IGROWO,IGRWYR GROWTH RATE OPTION (1=YES), START YEAR" >> ftab.dat
echo "?FTABSKIP@          ISKIPO,ISKIPY 5-YEAR OPTION (1=YES), START YEAR" >> ftab.dat
echo "1               NSCEN NUMBER OF SCENARIOS" >> ftab.dat
echo "?YEARPR@            FYRPRC  YEAR INDEX FOR REAL $ PRICE YEAR" >> ftab.dat
echo "?FTABWK1@          WK1 FILE SWITCH (1=CALL FWK1 TO CREATE IT)" >> ftab.dat
echo "1,1,1,1,1,1,1        RESTART FILE FORMAT SWITCH (1=UNFORMATTED)" >> ftab.dat
if [ "$copyem" != "0" ] ; then
   cp -f ?TABREQN@?TABREQD@ ?COPYDIR@/tabreq.txt
   cp -f ?DICTN@?DICTD@ ?COPYDIR@/dict.txt
   cp -f ?LAYOUTN@?LAYOUTD@ ?COPYDIR@/layout.txt
   cp -f ?VARLISTN@?VARLISTD@ ?COPYDIR@/varlist.txt
   echo "?COPYDIR@/tabreq.txt" >> ftab.dat 
   echo "?COPYDIR@/dict.txt" >> ftab.dat 
   echo "?COPYDIR@/layout.txt" >> ftab.dat 
else
   echo "?TABREQN@?TABREQD@" >> ftab.dat 
   echo "?DICTN@?DICTD@" >> ftab.dat 
   echo "?LAYOUTN@?LAYOUTD@" >> ftab.dat 
fi
echo "../../$scenario/$datekey/RESTART.unf" >> ftab.dat 
echo "RESTART2" >> ftab.dat
echo "RESTART3" >> ftab.dat
echo "RESTART4" >> ftab.dat
echo "RESTART5" >> ftab.dat
echo "RESTART6" >> ftab.dat
echo "RESTART7" >> ftab.dat
if [ "$copyem" != "0" ] ; then
   cp -f ?FTABXMLN@?FTABXMLD@ ?COPYDIR@/ftabxml.txt
   cp -f ?CITATIONN@?CITATIOND@ ?COPYDIR@/citation.txt
   echo "?COPYDIR@/ftabxml.txt" >> ftab.dat
   echo "?COPYDIR@/citation.txt" >> ftab.dat
else
   echo "?FTABXMLN@?FTABXMLD@" >> ftab.dat
   echo "?CITATIONN@?CITATIOND@" >> ftab.dat
fi
echo "?LADYFILE@             Switch for graf2000 .ran file" >> ftab.dat
echo "?CUMCAP@       Year cumulative capacity additions begin from" >> ftab.dat
echo "?CUMPROD@      Year cumulative oil and gas production begins" >> ftab.dat
echo "?FTABCARB@     Print carbon or carbon dioxide" >> ftab.dat
echo "?FTABBONE@     Print bonus rows as designated by DRForm in layout" >> ftab.dat 
echo "?UTILDR@       Discount rate for table 116" >> ftab.dat 
cp ftab.dat ftab.running.dat
# create 2nd ftab.dat to be the ftab.dat after the run is history
echo "$scenario     " > ftab.final.dat
echo "$datekey      " >> ftab.final.dat
echo "run in $OUTDIR on $DATE" >> ftab.final.dat
echo "?FTABCOLS@              MAXCOL               MAX COLS/PG" >> ftab.final.dat
echo "?FTABCOLW@               ICOLWD       REPORT COLUMN WIDTH" >> ftab.final.dat
echo "?FTABREG@               IPREGD     PRINT REGIONS (1=YES)" >> ftab.final.dat
echo "?FOOTNOTE@               IPRFTN    PRINT FOOTNOTES (1=YES)" >> ftab.final.dat
echo "?FTAB1ST@            IFSTYR    FIRST PRINT YEAR" >> ftab.final.dat
echo "?FTABLAST@            ILSTYR    LAST PRINT YEAR" >> ftab.final.dat
echo "?FTABGROW@          IGROWO,IGRWYR GROWTH RATE OPTION (1=YES), START YEAR" >> ftab.final.dat
echo "?FTABSKIP@          ISKIPO,ISKIPY 5-YEAR OPTION (1=YES), START YEAR" >> ftab.final.dat
echo "1               NSCEN NUMBER OF SCENARIOS" >> ftab.final.dat
echo "?YEARPR@            FYRPRC  YEAR INDEX FOR REAL $ PRICE YEAR" >> ftab.final.dat
echo "?FTABWK1@          WK1 FILE SWITCH (1=CALL FWK1 TO CREATE IT)" >> ftab.final.dat
echo "1,1,1,1,1,1,1        RESTART FILE FORMAT SWITCH (1=UNFORMATTED)" >> ftab.final.dat
   echo "?TABREQN@?TABREQD@" >> ftab.final.dat
   echo "?DICTN@?DICTD@" >> ftab.final.dat
   echo "?LAYOUTN@?LAYOUTD@" >> ftab.final.dat
echo "?OUTDIR@/?SCEN@/?DATE@/RESTART.unf" >> ftab.final.dat
echo "RESTART2" >> ftab.final.dat
echo "RESTART3" >> ftab.final.dat
echo "RESTART4" >> ftab.final.dat
echo "RESTART5" >> ftab.final.dat
echo "RESTART6" >> ftab.final.dat
echo "RESTART7" >> ftab.final.dat
   echo "?FTABXMLN@?FTABXMLD@" >> ftab.final.dat
   echo "?CITATIONN@?CITATIOND@" >> ftab.final.dat
echo "?LADYFILE@             Switch for graf2000 .ran file" >> ftab.final.dat
echo "?CUMCAP@       Year cumulative capacity additions begin from" >> ftab.final.dat
echo "?CUMPROD@      Year cumulative oil and gas production begins" >> ftab.final.dat
echo "?FTABCARB@     Print carbon or carbon dioxide" >> ftab.final.dat
echo "?FTABBONE@     Print bonus rows as designated by DRForm in layout" >> ftab.final.dat 
echo "?UTILDR@       Discount rate for table 116" >> ftab.final.dat
#
# Create controlfile.single.txt, controlfile.compare.txt, and controlfile.txt for RanToRTF program
tabreq="?TABREQN@?TABREQD@"
. $NEMS/scripts/RanToRTF_ControlFile.sh


# make sure everything is readable and writable 
chmod ug+rw *

 hogw=0
 hogm=0
 hogr=1
 hogk=1
 hogi=0
 hogt=0
 hoge=5
 hogc=15
 hogl=1
 hogg=0
 hogo=20
 hogn=1
 hogecp=70
 runecp=?EXE@

 numyears=`expr ?LASTYR@ - 2010`
 
 aveiter=`expr ?MAXITR@ + 1` 

 overhead=60
 periter=0 
 periter=`expr $periter + $hogw \* ?EXW@`
 periter=`expr $periter + $hogm \* ?EXM@`
 periter=`expr $periter + $hogr \* ?EXR@`
 periter=`expr $periter + $hogk \* ?EXK@`
 periter=`expr $periter + $hogi \* ?EXI@`
 periter=`expr $periter + $hogt \* ?EXT@`
 periter=`expr $periter + $hoge \* ?EXE@`
 periter=`expr $periter + $hogc \* ?EXC@`
 periter=`expr $periter + $hogl \* ?EXL@`
 periter=`expr $periter + $hogg \* ?EXG@`
 periter=`expr $periter + $hogo \* ?EXO@`
 periter=`expr $periter + $hogn \* ?EXN@`

hogindex=`expr $numyears \* \( \( $runecp \* $hogecp \* ?EXE@ \) / 2 + $aveiter \* $periter \)`
hogindex=`expr $hogindex + $overhead`
hogindex=`expr $hogindex \* ?NRUNS@`

cutoff=500
if [[ $hogindex -gt $cutoff ]] ; then
   jobclass="big"
else
   jobclass="small"
fi
echo "Estimated Wall time for this job is $hogindex seconds"
#
# check for whether this is an older version of nems that used a different jobcontrol file/system.
# if so, submit the run directly rather than via jobinit.exe
# search for string jobqueue.daf in nems.exe.  if not found, must be old version

  if [ "$HOSTPC" = "pick" ] ; then
    HOSTPC=`$NEMS/scripts/suggest_host.sh | grep speed | sed 's/.* is  //'`
    echo "Best available host is $HOSTPC" 
  fi
# check presence of job initiator on preferred host, if specified in scedes file
  fresh=1
  echo "Preferred host (HOSTPC in scedes) = $HOSTPC"
  if [ "$HOSTPC" != "none" ] ; then
    host="$HOSTPC"
    if [ "$host" = "" ] ; then
      host=`hostname`
      fi
# check for active queue initiator files signaling batch jobs will be run
    $NEMS/scripts/freshness.exe $NEMSJOBLOG/queue.$host.$jobclass* 
    fresh=$?
    if [ $fresh -eq 1 ] ; then
      echo "No active NEMS batch queues for job class $jobclass running on host $host " 
    fi
  fi

# if no job initiators on preferred host, or if no preferred host specified,
# check presences of job initiator on current host
  if [[ "$host" = "" || $fresh -eq 1 ]] ; then
    host=`hostname`
#   check on current host, provided that differs from preferred host. 
    if [ "$host" != "$HOSTPC" ] ; then
#     check for active queue initiator files signaling batch jobs will be run
      $NEMS/scripts/freshness.exe $NEMSJOBLOG/queue.$host.$jobclass* 
      fresh=$?
      if [ $fresh -eq 1 ] ; then
        echo "No active NEMS batch queues for job class $jobclass running on current host $host " 
      fi
    fi 
  fi

# Check for xpress on hosts that don't have it and turn it off
if [ "?XPRESSSW@" != "0" ] ; then
# no licenses on these PCs
   if [[ "$host" = "a11111" || "$host" = "a99999" ]] ; then
      echo "   Notice:  XPRESS requested but $host is not capable of running it.  So we won't run it."
      grep -v XPRESSSW MOREOPT > m
      echo "XPRESSSW 0" >> m
      cp m MOREOPT
      rm m
   fi
else
   echo "   XPRESS not turned on"
fi

# Just Do It
  hold=?HOLD@
  runcob=?RUNCOB@
  release=?RELEASE@
  delay=""
  if [ $hold -eq 1 ] ; then
    delay="hold"
  fi
  if [ $runcob -eq 1 ] ; then
    delay="18:00"
  fi
  if [ $release -eq 1 ] ; then
    delay="release"
  fi
  if [ $fresh -eq 0 ] ; then
    echo "Submitting NEMS run in class $jobclass for host $host"
    $NEMS/scripts/jobinit.exe $jobclass $host
  else
    echo "Submitting NEMS run in class debug on this computer $COMPUTERNAME"
    if [ "$OSTYPE" = "cygwin" ] ; then
      runname="$scenario $datekey"
      cygstart --minimize -d $OUTDIR/$scenario/$datekey "$NEMS/scripts/sys.exe" bash -c "$OUTDIR/$scenario/$datekey/cycle.sh" "$jobclass $delay >nohup.out 2>&1"
    else
      start /separate /min "$scenario $datekey" "$NEMS/scripts/sys.exe" sh "$OUTDIR/$scenario/$datekey/cycle.sh $jobclass $delay > nohup.out 2>&1"
    fi
  fi
 
