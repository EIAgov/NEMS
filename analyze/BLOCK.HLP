   Function: Block LP for macro view
   Syntax:   BLOCK [{ROW | COL {option}
                    |NETFORM
                    |PICTURE
                    |GRAPH
                    |SAVE    [filename]
                    |LOAD    [filename] }]

     The ROW | COL options are:
                           SYNTAX [?_mask] [//FILL char]
                          |MERGE  block1  block2 [new_name]
                          |ERASE  block [...] | *
                          |COPY   TO|FROM  block
                          |RENAME block new_name
                          |DISPLAY
                          |PLOT [//form]

        ................................................
        : All blocking is performed on the submatrix.  :
        : Use SUBMAT or any direct setting;  eg,       :
        :            COUNT *,*                         :
        : will set all rows and columns into submatrix :
        :..............................................:

   Without arguments BLOCK determines components of the submatrix,
   creating blocks named COMP.001, COMP.002, ...

   ROW|COL creates or modifies a row or column block from the current
      submatrix by the following ways.

      SYNTAX ?_mask tallies names, forming classes that define blocks
       ...default ?_mask = ?  (ie, first character of name).  In
          forming classes, trailing blanks of names are filled with a
          character whose default is ~.  The FILL option (following //)
          allows you to change the fill character.  For example, suppose
          the query mask is *****??? and we have names ABCDEFGH and
          ABCDEF (so they both match the query mask).  The second name
          is seen as ABCDEF~~ which gives class F distinct from the
          first class, which is FGH (see, also, TALLY command).

          Also, to keep syntax block names within the 8 character limit,
          consecutive mask characters (*) are replaced by ~ in forming
          the block name.  For example, if the query mask is *****???
          and a class is FGH, the block name will be SYN.~FGH.

      MERGE merges block2 into block1
           (use BLOCK {ROW|COL} DISPLAY to get block names)
      ...if new name is not given, block1 prevails

      ERASE block frees the rows or columns, erasing the block
      ...additional blocks may be erased with the same command
      ...if * is given, all row or column blocks are erased

      COPY TO block copies rows or columns in submatrix to block
      ...merged if block exists...block created if new

      COPY FROM block copies rows or columns to the submatrix, which is
       also a merger (clear submatrix first to set submatrix to block)

      RENAME renames block.

      PLOT plots bar graph of number in blocks, where
               form := GRAPHIC | PRINTABL
         Note:  not available in DOS version;  for non-DOS version,
                see GRAPHICS.DOC

   NETFORM blocks submatrix by netform properties...single nonzero or
     oppositely signed pair of nonzeroes.  This results in 3 column
     blocks, according to IO:

        + only is Production, - only is Consumption, and -+ is Transfer

      Note this presumes a signing convention, where the submatrix is the
      node-arc incidence matrix.  The IO option adjusts the sign by
      reversing L-rows.

   Block names at their creation follow the following conventions.

    For BLOCK with no parameters the components are named COMP.001,...

    For SYNTAX, the block names are of the form, [SYN.]class, where
    class is the name class from the query mask.  If the number of
    query characters is less than 4 (which is the length of the class
    name), the prefix, SYN. is included;  otherwise, just the class
    name is used to name the block.

    For NETFORM, the column blocks are NET.PROD, NET.CONS, and NET.TRAN
    for Production, Consumption and Transfer activities, respectively.

    CARE MUST BE TAKEN NOT TO CAUSE A NAME CONFLICT.

  These automatic blocking procedures operate on the submatrix, but rows
  and columns that are already in another block do not enter the new block.

  ROW|COL DISPLAY gives list of row/column block statistics.

  PICTURE shows row block x column block picture...
      [ ] (null) means there are no nonzeroes in row x column intersection
      [-] means not null and all nonzeroes are negative
      [+] means not null and all nonzeroes are positive
      [*] means there is a mixture of negative and positive nonzeroes

  ...IO option reverses signs of nonzeroes in L-rows (<).  For the
     canonical LP: min cx: Ax >= b, L<=x<=U, the IO sign pattern
     may be interpreted as activity inputs (-) and outputs (+),
     as in a network model (where A is the node-arc incidence
     matrix and b < 0 for supplies).

  SAVE and LOAD use filename.BLK as (unformatted) disk file of blocks
     ...if filename is omitted, problem name is used.


  Examples:

  BLOCK R S ?
  ...this causes all rows in submatrix to be blocked according to the
     first character in their names (see SYNTAX command)

  BLOCK C S P??
  ...this causes a blocking of the submatrix columns whose name
     begins with P according to characters 2&3 in their name (eg,
     regional blocking if ?? is a region code in the name)

  BLOC  N
  ...this causes a blocking of the submatrix according to NETFORM:

         ...... Columns in netform (N) are singletons and
         |      oppositely signed doubletons
         |
         N *
         0 *

  BL C M NET.TRAN NET.PROD MYNET
  BL C M MYNET NET.CONS
  ...these 2 mergers combine all network columns (put into blocks
     NET.PROD, NET.TRAN and NET.CONS) into 1 block, called MYNET.
     That is, the first BLOCK (abbreviated BL) merges blocks NET.TRAN
     and NET.PROD, putting the result into a (newly created) block,
     named MYNET.  The second BLOCK command merges NET.CONS into MYNET.

  BLOCK C E *
  ...erases all column blocks

  BLOCK S MYPROB
  ...saves blocked matrix in file named MYPROB.BLK

  BLOCK L MYPROB
  ...loads blocks from file named MYPROB.BLK

  BLOCK P
  ...pictures row x column blocks (no sign adjustment)

  BLOCK P IO
  ...pictures row x column blocks according to activity inputs (-)
     and outputs (+) after adjusting signs of nonzeroes

  BLOCK R D
  ...displays row blocks

  BLOCK C D
  ...displays column blocks

  As a final example, consider an LP with the following 'linked-block'
  structure.

           B1         |
             B2       |
               .      |
                .     |    N   (network columns)
                 .    |
                  Bk  |
          <--blocks-->|<--links-->

  This can be found by the following sequence.

     COUNT *,*          ...sets submatrix to all rows/cols
     BLOCK N            ...obtains netform (N)
     BLOCK              ...obtains components B1,...,Bk
     BLOCK P            ...pictures linked-block structure

    For the sample, BLOCKNET.MAT, the result picture looks like this:

                C C C N N N
                O O O E E E
                M M M T T T
                P P P . . .
                . . . T P C
                0 0 0 R R O
                0 0 0 A O N
                1 2 3 N D S
     COMP.001   *     - +
     COMP.002     *   *
     COMP.003       * +   -
