                 SYNTAX GENERATE [filespec] [//USING filespec]

    Without the USING option, you will be prompted for row classes, then
    for column classes.  Respond to each prompt with the following form:

                            name[(set[,set[,...]])]

    For example, the response A(I,J) defines a (row or column) class A,
    whose domain is composed of sets I and J.  The name of each row or
    column in this class is of the form Aij (note the length).  If the name
    should be of the form Ai.j.. (that is, 2 chars for set I and 3 for set
    J), then you should respond with A(I.,J..) (where the period is an
    arbitrary char; you could also specify II and JJJ, just to get the
    lengths equal to the name field lengths of 2 and 3, resp.).  The length
    of each set referenced in the domain is assumed to be the length of
    each member in the row or column name.

    The parentheses delimit the domain spec, which is not mandatory.  For
    example, you can respond with A to define a class A, which has null
    domain.  It is not necessary to define the objective row as a class, as
    that is recognized, and you will be so informed if you do specify the
    objective during the prompt for row classes.

    When you finish defining classes, just press enter (giving a null
    string as a response).  After row and column classes are defined, set
    members will be inferred from the resident row and column names.  The
    final result will be a skeleton syntax file.  You must use an editor to
    enter meanings to each set and its members, and you must complete the
    syntax specs for the row and column classes.  If you make a mistake,
    you can abort by specifying * at the next prompt (this will be treated
    as an error).

    You can avoid terminal discourse by specifying the USING option (this
    is useful if you tend to make keyboard errors).  For an example,
    READ P WOODNET and enter SYN GEN TEST //USING RCPROMPT (note the
    filespec to avoid over-writing the WOODNET syntax file, WOODNET.SYN).
    Look at RCPROMPT.SYN, which came with ANALYZE, so you can see the
    responses.

    You can then READ SYN [filespec] to read the syntax (the filespec is
    the same as you generated).  This will not give you English
    translations, such as with the EXPLAIN command, until you fill in the
    meanings.  However, this will enable you to use the SCHEMA and TABLE
    commands, which just need the row and column classes and their domain
    sets (meanings not needed).

