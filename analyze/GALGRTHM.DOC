                                GALGRTHM.DOC

    This describes algorithms for the following procedures.

             1. TRACE
             2. REDUCE
             3. Basis agenda (supports RATEOF)
             4. Basis ranges (supports BASIS REDUND)

    1.  TRACE Algorithm

    The purpose of the TRACE procedure is to determine a substructure
    that helps to explain a flow or price.  It begins with a submatrix
    and adds rows and columns according to the criteria described below
    until a "complete" submatrix is obtained.  A submatrix is complete if
    the following conditions hold for each row in the submatrix.

    If the row is G-type (ie, Ax >= b), it must contain a positive
    coefficient.

    If the row is L-type (ie, Ax <= b), it must contain a negative
    coefficient.

    If the row is E-type (ie, Ax = b), it must contain both signs.

    Free rows play no role, and ranged rows are treated as their binding
    inequality dictates, according to the resident solution.

    For example, the following submatrix is complete.

                         +  -        = 0
                            +  -     = +
                         +     +    >= +
                            -  -    <= -

    The idea is that it is possible to marginally increase the levels of
    the activities in the submatrix and remain feasible.  It is the
    "possible" perturbation that we seek, ignoring the magnitudes of the
    coefficients and right-hand sides.  Only sign patterns determine the
    final submatrix of a trace.

    If the submatrix is not complete, the columns are interrogated.  To
    be a candidate to enter the submatrix, a column must "cover" at least
    one "uncovered" row.  A row is uncovered if it is in the submatrix
    but violates the condition for completeness.  Such rows enter the
    submatrix either by the initial specification or by having a nonzero
    in a column that is added to the path.  A column covers an uncovered
    row if it supplies the needed sign of the coefficient.

    Among candidates that cover some uncovered row, there are two figures
    of merit used.  The first is the "net cover" of the column.  This
    equals the number of rows already in the submatrix that become
    covered upon adding this column (which must be at least 1) minus the
    number of uncovered rows that would enter the submatrix.  This net
    cover is allowed to be negative, and the greatest net cover is
    preferred.  The second figure of merit is the status, relative to the
    resident solution, called the "rank" of the column.  Since we are
    seeking an explanation of perturbation, we use the following ranking.

            Rank = 1 if L > X or X > U  (ie, Status = Infeasible )
                 = 2 if L < X < U
                 = 3 if L = X < U & D <= 0
                 = 4 if L < X = U & D >= 0
                 = 5 else

    The rationale is that if the LP is infeasible, the most preferred
    column to add to the submatrix is one that is infeasible.  Otherwise,
    if LP is feasible, we seek room for the activity level (X) to vary
    marginally.

    For rank 2 the activity must be basic (assuming simplex method was
    used, as in available systems), so D=0.  For rank 3, if the resident
    solution is optimal, we will have D >= 0 (for min), so rank 3 really
    implies D=0.  This is a degenerate situation:  either the activity is
    basic in the primal at its bound (L), or the dual (D) is.  Similar
    comments apply to rank 4.  Rank 5 includes fixed variables (L=U) and
    conditions under which the solution does not satisfy the primal-dual
    optimality conditions.

    The algorithm first removes free rows from the submatrix.  Then, it
    initializes cover properties of the rows in the initial submatrix and
    adds rows with coefficients in the initial columns (if they are
    uncovered, for example), not adding free rows.  Then, if all rows are
    covered, the algorithm stops.  Otherwise, the general iterations
    begin.

    At a general iteration, at least one row is uncovered, so the columns
    are interrogated.  If no column covers an uncovered row, the
    algorithm stops (with a message).  Otherwise, when a candidate column
    is found (ie, it covers an uncovered row), its net cover is computed.
    If this is worse than the current best, it is dismissed; otherwise,
    its rank is computed.  If its rank is 1 or 2, the column is
    immediately added, and the iteration is complete (upon adding its
    uncovered rows to the submatrix).  If its net cover is strictly
    better than the current best or its rank is strictly better than the
    current best, the column becomes the current best; otherwise, it is
    dismissed.

    The iterations continue until a complete path is obtained or
    uncovered rows cannot be covered.

    This algorithm is sometimes called a "path trace," because it obtains
    a path in the ususal sense if the LP is a network model.  Current
    research will expand the variations of this algorithm to deal with a
    variety of analysis questions for non-network models.  To be useful,
    more experience with this rudimentary implementation is needed.

    2.  REDUCE Algorithm (for submatrix)

    The bounds on primal quantities and dual prices are successively
    reduced until either an infeasibility is detected or no further
    reduction is found.  Here is notation we shall use:

      variable  VALUE             meaning
               Pointer
      -----------------------------------------------------------------
      XL        IXL      lower bound for X (primal activity level)
      XU        IXU      upper bound for X
      YL        IYL      lower bound for Y = AX
      YU        IYU      upper bound for Y
      YMIN      IYMIN    min[y: y = Ax, YL <= y <= YU, XL <= x <= XU]
      YMAX      IYMAX    max[y: y = Ax, YL <= y <= YU, XL <= x <= XU]
      PL        IPL      lower bound for P (dual price)
      PU        IPU      upper bound for P
      DMIN      none     min[d: d = c-pA, PL <= p <= PU,
                             d >= 0 if XL infinite, d <= 0 if XU infinite]
      DMAX      none     max[d: d = c-pA, PL <= p <= PU,
                            d >= 0 if XL infinite, d <= 0 if XU infinite]
      ------------------------------------------------------------------

    Initially, XL,XU,YL,YU are set to their given bound values (infinity
    included).  The price range PL,PU is initialized according to row
    type:

                PL = -infinity if YU is finite; else, 0.
                PU =  infinity if YL is finite; else, 0.

    At a general iteration (PASS) YMIN and YMAX are initialized to 0 upon
    beginning the column loop.  The column loop accumulates YMIN and
    YMAX; and, it tests for dual infeasibility and forcing prices.

    For each row (in the submatrix) the extremes are determined, XL or
    XU, according to whether the nonzero is positive or negative.  At the
    end of the nonzero interrogation, DMIN and DMAX are set.  If the
    column is already fixed (ie, XL=XU), there is no further action
    (beyond updating YMIN and YMAX).  If some row was determined forcing
    (see below) on the last iteration, the column becomes fixed by
    setting XL = XU = extreme value.  Otherwise, the dual test is
    performed.

    The dual test is simply this.  If DMAX is less than the required
    minimum reduced cost (0 if XU is infinite), we have dual
    infeasibility.  Similarly, if DMIN is greater than the required
    maximum reduced cost (0 if XL is infinite), we have dual
    infeasibility.  In either of these cases the algorithm terminates
    with infeasibility detection.  Otherwise, DMAX and DMIN are compared
    to these limits (within absolute tolerance, VTOLAB).  If either
    "equals" its threshold value, this forces the dual prices of the rows
    of the nonzeroes to their extreme values (ie, PL and PU become equal
    to the forced dual price), which will affect subsequent iterations
    for other columns.

    Once the column loop is completed, the rows are interrogated to see
    if YMIN or YMAX yields a row that is primal infeasible, forcing or
    redundant.  A row is infeasible if YMAX < YL or YMIN > YU.  A row is
    forcing if either YMAX=YL or YMIN=YU.  A row's inequalilty y >= YL is
    redundant if YMIN >= YL and YL is finite; and, y <= YU is redundant
    if YMAX <= YU and YU is finite.  In such cases a price bound is
    tightened (ie, PU=0 in the first case and PL=0 in the second case).

    Iterations continue as long as some reduction occurs; otherwise,
    successive bound reduction terminates.  Special tests are applied to
    binary (and more general integer) variables.  At least once, there is
    a set of "expensive" tests performed.  The reduce routines are in the
    following FORTRAN files, which contain additional algorithm and
    implementation notes.

        GREDUCE ...Link with outside world and master algorithm control
        GREDBIN ...Second column loop, integer tests, logical (binary)
                   implications
        GREDEXP ...Expensive tests (quadratic complexity)

    (Also, GREDMAT contains support routines, but not specifically tests
     for reduction.)


    Summary of elementary tests.
       Condition                Action
    =========================   ========================================
    Row tests
       YMIN > YU or YMAX < YL   Return primal infeasible
       YMIN = YU                Force adjacent variables at YMIN
                                extremes, then free row
       YMAX = YL                Force adjacent variables at YMAX
                                extremes, then free row
       YMAX <= YU               Update PL >= 0 (Y <= YU redundant)
       YMIN >= YL               Update PU <= 0 (Y >= YL redundant)
    Column tests
       DMAX < 0 and XU = *      Return dual infeasible
       DMAX < 0 and XU < *      Fix X at XU (set XL = XU)
       DMIN > 0 and XL = -*     Return dual infeasible
       DMIN > 0 and XL > -*     Fix X at XL (set XU = XL)
       DMAX = 0                 Fix adjacent row prices at DMAX extremes
       DMIN = 0                 Fix adjacent row prices at DMIN extremes
       0 < XU - XL < tol        Fix X in [XL, XU] (special rules used)
    Row-Column tests
       A > 0                    Update XL >= (YL - YMAX)/A + XU and
                                       XU <= (YU - YMIN)/A + XL
       A < 0                    Update XL >= (YU - YMIN)/A + XU and
                                       XU <= (YL - YMAX)/A + XL
    ====================================================================
    Other, more expensive, tests are not shown here.

    3.  Basis Agenda Algorithm

    The RATEOF command gives the rate of substitution from the equation,
    y = Ax.  The y-variables are the basics, and the x-variables are the
    nonbasics.  The matrix A is computed from the original matrix by
    solving BA = A', where A' is the original matrix, and B is the basis
    associated with the solution.  This solution is obtained during the
    session by an algorithm known as "forward transformation" (or FTRAN).
    To do this efficiently, the basis is "factored." This factorization
    is performed the first time the RATEOF command is specified, after
    which the system knows the basis factorization has been setup.  (For
    large problems it is recommended that the matrix and solution be
    readin as a batch job, then the RATEOF command executed once, so the
    interactive session can then begin by reading a packed file that
    already has the basis setup to support the RATEOF command.)

    The objective of the basis agenda algorithm is to find as nearly a
    triangular rearrangement of the basis matrix as possible.  All
    network models completely triangularize, which saves both space and
    time when computing the rates of substitution.  Most large LP's have
    large embedded networks, so there are few disturbances to this
    triangularity.  Still there is some.  Here the basic agenda algorithm
    is described as it currently exists in the routines in files
    GBAGNDA1.FOR and GBAGNDA2.FOR.  There are many variations possible,
    so computational bottlenecks should be reported to improve later
    versions.

    The data structure for basis setup (agenda and alpha computation) is
    described in GETBASIS.DOC.  After initialization, the algorithm steps
    are as follows.

        1.  Execute FTRI (forward triangulation); if all columns are
        assigned, go to step 4.

        2.  Execute BTRI (backward triangulation).  If all columns are
        assigned, go to step 4.

        3.  Select the best assignment in the kernel (using min-degree
        algorithm, which assigns a row with min count to front and its
        other columns, if any, become spike.  This is repeated until
        all columns are assigned or classified as spike (with earliest
        insertion recorded), or until singularity is detected.  In
        the singular case, the algorithm terminates with no bais setup.
        In the successful case, we proceed to step 4.

        4.  Compute ALPHA vectors, assigning spikes as early as possible.
        Several passes may be needed to assign spikes;  if a spike does
        not have an acceptable pivot (tolerance = VPIVOT), it is stacked
        and re-entered later.  If there remain unassigned spikes with no
        acceptable pivot element, the basis setup fails.

    If the basis triangularizes, step 1 finds the triangular
    rearrangement and branches immediately to step 4.  With no spikes,
    each ALPHA vector in the basis is its original column, which is
    copied with the pivot row first (tagged by sign bit).

    If the basis does not triangularize, we enter step 3 with the
    following structure.

                   |.
                   | .  Forward triangle from FTRI
                   |  .
                   |.................
                   |   :            | Kernel
                   |   :            |   (every col and row has
                   |   :            |    at least 2 nonzeroes)
                   |   :            |
                   |   :            |
                   |   :............|
                   |                :.
                   |                : .
                   |                :  .  Backward triangle from BTRI
                   |________________:___.
                        F          R
                        R          E
                        O          A
                        N          R
                        T--->  <---

    Routine FTRI (Forward Triangulation).
        Among unassigned rows, find one with only one unassigned column
        (ie, count=1).  If a row is found, assign it and its only
        unassigned column to the front and repeat; otherwise, exit.

    Routine BTRI (Backward Triangulation).
        Among unassigned columns, find one with only one unassigned row.
        (ie, count=1).  If a column is found, assign it and its only
        unassigned row to the front and repeat; otherwise, exit.

    Kernel Assignment (simplest variation).
        Assign a row of min count to the front with one of its columns.
        This forces its other intersecting columns to be spike, and they
        are assigned to the (new) front without a pivot row.

    Assignments.
        If (ROW,COL) is assigned to the front, the remaining unassigned
        rows intersecting COL have their counts decremented by 1.  If
        there are any other unassigned columns intersecting ROW, they
        become spikes (updating BCSTAT).  For each of these spikes,
        their intersecting, unassigned rows have their counts
        decremented.

        If (ROW,COL) is assigned to the rear, in this version it must be
        a column singleton.  Any unassigned column intersecting ROW has
        its count decremented.  (In future versions we may assign a spike
        to the rear, in which case unassigned rows intersecting COL have
        their counts decremented.)

        Each assignment makes it possible to resume triangulation:  a
        front assignment can create row singletons, and a rear assignment
        can create column singletons.

    4. Basis Ranges.

    Subroutine GBARNG (in GBRANGE.FOR) obtains ranges of the basic
    variables.  Using the resident basis, the basic equations are of the
    form:  u=Mv, where u is the m-vector of basic variables, say
    [xB,yB]', and v is the n-vector of nonbasic variables, say [yN,xN]'.
    Then, M=B*N*, where B* is the (full) basis inverse:

                            |-B 0|-1
                       B* = |    |
                            |-R I|
                              : :...unit columns for yB
                              :
                              :....-basic columns from A

    and N* is the (full) nonbasic matrix:

                           |-I N|
                      N* = |    |
                           | 0 Q|
                             : :...nonbasic columns from A
                             :
                             :.....-unit columns for yN

    The (i,j) coefficient of M may be computed in either of 2 ways.
    First, we could FTRAN(a), where a is any column from N*, say the
    j-th.  Then, after the FTRAN, the i-th coordinate of a is M(i,j).
    Second, we could BTRAN(b), where b=e(i) is the i-th unit vector upon
    entering BTRAN.  Afterwards, b is the i-th row of B*.  The inner
    product (b,a) is M(i,j) if a is the j-th column of N*.

    In computing the range of a basic variable, its pivot row is
    BTRANned.  Then, looping over nonbasic variables, the inner product
    is computed to obtain its rate of substitution, M(i,j).  The nonbasic
    bounds determine the range of this term of the i-th basic equation.
    During the loop the min and max values are accumulated and stored
    into the ZVALUE array (double precision EQUIVALENCEd to the VALUE
    array) at IMIN and IMAX, respectively.  Then, SUBROUTINE GBRNGV
    retreives the stored range for each basic variable (as well as the
    basic variable's identity).

    Unlike the RATEOF command support, the ranging pre-processes the
    nonbasic rows to reduce their original bounds for the subsequent
    range computation.  In particular, an L-row has an infinite lower
    bound (-* <= y=Ax <= U), which may be made finite by scanning the
    row's range with the original matrix coefficients and the x-bounds.
