C                ::: RBSTACKS.FOR  7-05-95 :::
C
C LAST DATE:  Earlier dates deleted
C             8-07-93...Updated SYSCM0 (to agree with SYSCMD)
C             5-11-95...Updated FLCMN0 (to agree with FLCMND)
C
C This contains the following subroutines for the Rulebase module
C of ANALYZE.
C
C     RSTACK.....Initializes stack(s)
C     RSPOP......Pops stack (gets front entry)
C     RSPUSH.....Pushes stack (puts entry at front)
C     RSQUEU.....Queues stack (puts entry at rear)
C     FLCMN0.....copy of FLCMND....| to avoid
C     SYSCM0.....copy of SYSCMD....| re-entrance
C
      SUBROUTINE RSTACK(CLIST,FIRST,LAST,RCODE)
C     =================
      IMPLICIT INTEGER (A-U), DOUBLE PRECISION (Z)
C
      INCLUDE 'DCANAL.'
      INCLUDE 'DCRULE.'
CITSO      INCLUDE (DCANAL)
CITSO      INCLUDE (DCRULE)
CI$$INSERT DCANAL
CI$$INSERT DCRULE
C
C This initializes stack 1 and/or 2
C
C Syntax:  STACK [#]
C     # is 1 or 2  (no # clears both stacks)
C
      CHARACTER*(*) CLIST
C LOCAL
      CHARACTER*2  STACK
      CHARACTER*1  CHAR
C  ::::::::::::::::::::::: BEGIN ::::::::::::::::::::::::
C PARSE FOR STACK #
      CALL FTOKEN(CLIST,FIRST,LAST,STACK,2,CHAR)
      IF(STACK.NE.' '.AND.STACK.NE.'1 '.AND.STACK.NE.'2 ')THEN
         PRINT *,' ** RULEBASE ERROR...STACK INITIALIZATION',
     1           STACK
         RCODE = 1
         RETURN
      ENDIF
C STACK 1 GROWS FROM TOP (1) AND STACK 2 GROWS FROM BOTTOM (PMXRST)
      IF(STACK.EQ.'1 '.OR.STACK.EQ.' ')RSTCK1 = 0
      IF(STACK.EQ.'2 '.OR.STACK.EQ.' ')RSTCK2 = PMXRST+1
C
C ** RSTACK ENDS HERE
      END
      SUBROUTINE RSPOP(CLIST,FIRST,LAST,RCODE)
C     ================
      IMPLICIT INTEGER (A-U), DOUBLE PRECISION (Z)
C
      INCLUDE 'DCANAL.'
      INCLUDE 'DCRULE.'
CITSO      INCLUDE (DCANAL)
CITSO      INCLUDE (DCRULE)
CI$$INSERT DCANAL
CI$$INSERT DCRULE
C
C This pops stack (puts result into parameter parsed from CLIST)
C
C Syntax:  POP # parameter
C
      CHARACTER*128 CLIST
C LOCAL
      CHARACTER*16  CNAME,RNAME
      CHARACTER*2   STACK
      CHARACTER*1   CHAR
C :::::::::::::::::::::::: BEGIN ::::::::::::::::::::::::
C PARSE FOR STACK #
      CALL FTOKEN(CLIST,FIRST,LAST,STACK,2,CHAR)
      IF(STACK.EQ.'1 ')THEN
         IF(RSTCK1.EQ.0)THEN
            CNAME = ' '
         ELSE
            CNAME = RBSTAK(RSTCK1)
            RSTCK1 = RSTCK1 - 1
         ENDIF
      ELSE IF(STACK.EQ.'2 ')THEN
         IF(RSTCK2.GT.PMXRST)THEN
            CNAME = ' '
         ELSE
            CNAME = RBSTAK(RSTCK2)
            RSTCK2 = RSTCK2 + 1
         ENDIF
      ELSE
         PRINT *,' ** RULEBASE ERROR...STACK POP ',STACK
         GOTO 1300
      ENDIF
C GET PARAMETER NAME TO RECEIVE POP
      CALL FTOKEN(CLIST,FIRST,LAST,RNAME,8,CHAR)
C NOW RNAME = PARAMETER NAME, AND CNAME = VALUE FROM STACK
      IF(NRUPRM.GT.0)THEN
C LOOKUP PARAMETER NAME
         DO 200 I=1,NRUPRM
            IF(RNAME.EQ.RUPNAM(I))THEN
               RUPVAL(I) = CNAME
               RETURN
            ENDIF
200      CONTINUE
      ENDIF
C PARAMETER DOES NOT EXIST...ADD IF SPACE AVAILABLE
      IF(NRUPRM.LT.PMXRUP)GOTO 900
      PRINT *,' ** PARAMETER LIMIT REACHED IN RULEBASE...',PMXRUP
      GOTO 1300
C
C ADD PARAMETER
900   CONTINUE
C ...FIRST CHECK THAT WE HAVE A NAME
      IF(RNAME.EQ.' ')THEN
        PRINT *,' ** RULEBASE ERROR...MISSING PARAM NAME IN STACK POP'
         GOTO 1300
      ENDIF
C OK
      NRUPRM = NRUPRM + 1
      RUPNAM(NRUPRM) = RNAME
      RUPVAL(NRUPRM) = CNAME
      RETURN
C
C ALL ERROR RETURNS COME HERE
1300  CONTINUE
      RCODE = 1
      RETURN
C
C ** RSPOP ENDS HERE
      END
      SUBROUTINE RSPUSH(CLIST,FIRST,LAST,RCODE)
C     =================
      IMPLICIT INTEGER (A-U), DOUBLE PRECISION (Z)
C
      INCLUDE 'DCANAL.'
      INCLUDE 'DCRULE.'
CITSO      INCLUDE (DCANAL)
CITSO      INCLUDE (DCRULE)
CI$$INSERT DCANAL
CI$$INSERT DCRULE
C
C This pushes stack (from parameter parsed from CLIST)
C     Syntax: PUSH # string (16-char)
C
      CHARACTER*(*) CLIST
C LOCAL
      CHARACTER*16  CNAME
      CHARACTER*2   STACK
      CHARACTER*1   CHAR
C :::::::::::::::::::::::: BEGIN ::::::::::::::::::::::::
      IF(RSTCK1.GE.RSTCK2)THEN
         PRINT *,' ** RULEBASE ERROR...STACK OVERFLOW'
         GOTO 1300
      ENDIF
C PARSE FOR STACK #
      CALL FTOKEN(CLIST,FIRST,LAST,STACK,2,CHAR)
C PARSE FOR STRING TO PUSH
      CALL FTOKEN(CLIST,FIRST,LAST,CNAME,16,CHAR)
C
      IF(STACK.EQ.'1 ')THEN
         RSTCK1 = RSTCK1 + 1
         RBSTAK(RSTCK1) = CNAME
      ELSE IF(STACK.EQ.'2 ')THEN
         RSTCK2 = RSTCK2 - 1
         RBSTAK(RSTCK2) = CNAME
      ELSE
         PRINT *,' **  RULEBASE ERROR...STACK PUSH ',STACK
         GOTO 1300
      ENDIF
      RETURN
C
C ALL ERROR RETURNS COME HERE
1300  CONTINUE
      IF(SWDBG)THEN
         PRINT *,' AT 1300, RSTCK1,RSTCK2=',RSTCK1,RSTCK2
         CALL SYSDBG
      ENDIF
      RCODE = 1
      RETURN
C
C ** RSPUSH ENDS HERE
      END
      SUBROUTINE RSQUEU(CLIST,FIRST,LAST,RCODE)
C     =================
      IMPLICIT INTEGER (A-U), DOUBLE PRECISION (Z)
C
      INCLUDE 'DCANAL.'
      INCLUDE 'DCRULE.'
CITSO      INCLUDE (DCANAL)
CITSO      INCLUDE (DCRULE)
CI$$INSERT DCANAL
CI$$INSERT DCRULE
C
C This queues stack (from parameter parsed from CLIST)
C     Syntax: QUEUE # string (16-char)
C
      CHARACTER*(*) CLIST
C LOCAL
      CHARACTER*16  CNAME
      CHARACTER*2   STACK
      CHARACTER*1   CHAR
C :::::::::::::::::::::::: BEGIN ::::::::::::::::::::::::
      IF(RSTCK1.GE.RSTCK2)THEN
         PRINT *,' ** RULEBASE ERROR...STACK OVERFLOW'
         GOTO 1300
      ENDIF
C PARSE FOR STACK #
      CALL FTOKEN(CLIST,FIRST,LAST,STACK,2,CHAR)
C PARSE FOR STRING TO QUEUE
      CALL FTOKEN(CLIST,FIRST,LAST,CNAME,16,CHAR)
C
      IF(STACK.EQ.'1 ')THEN
         IF(RSTCK1.GT.0)THEN
C MOVE STACK TO MAKE ROOM
            DO 100 I=RSTCK1,1,-1
100         RBSTAK(I+1) = RBSTAK(I)
         ENDIF
C PUT ENTRY AT REAR (TOP ENTRY)
         RBSTAK(1) = CNAME
         RSTCK1 = RSTCK1 + 1
      ELSE IF(STACK.EQ.'2 ')THEN
         IF(RSTCK2.LE.PMXRST)THEN
C MOVE STACK TO MAKE ROOM
            DO 200 I=RSTCK2,PMXRST
200         RBSTAK(I-1) = RBSTAK(I)
         ENDIF
C PUT ENTRY AT REAR (BOTTOM ENTRY)
         RBSTAK(PMXRST) = CNAME
         RSTCK2 = RSTCK2 - 1
      ELSE
         PRINT *,' ** RULEBASE ERROR... STACK QUEUE',STACK
         GOTO 1300
      ENDIF
      RETURN
C
C ALL ERROR RETURNS COME HERE
1300  CONTINUE
      IF(SWDBG)THEN
         PRINT *,' AT 1300, RSTCK1,RSTCK2=',RSTCK1,RSTCK2
         CALL SYSDBG
      ENDIF
      RCODE = 1
      RETURN
C
C ** RSQUEU ENDS HERE
      END
      SUBROUTINE FLCMN0(CLIST,FIRST,LAST,RCODE)
C     =================
      IMPLICIT INTEGER (A-U), DOUBLE PRECISION (Z)
C
C Parses CLIST(FIRST:LAST) for command and executes it.
C
C If RCODE <> 0 UPON ENTRANCE, ERROR ACTION IS TAKEN (NO PARSE).
C
      INCLUDE 'DCFLIP.'
      INCLUDE 'DCFLCMND.'
CITSO      INCLUDE (DCFLIP)
CITSO      INCLUDE (DCFLCMND)
CI$$INSERT DCFLIP
CI$$INSERT DCFLCMND
C
      PARAMETER   (UABORT=10)
C                         :...RETURN CODE FOR USER ABORT (_PAUSE)
C LOCAL
      CHARACTER*128 CLIST,CTEMP,STR128
      EQUIVALENCE (STR128,CTEMP)
      CHARACTER*64  FILNAM
      CHARACTER*32  STRVAL
      CHARACTER*1   CHAR,DELMTR
      CHARACTER*8   OPLIST(4),TOKEN
      LOGICAL*1     SW
      LOGICAL       EXIST
C
CITSO      REAL*8 ERR212,ERR219
CICMS      REAL*8 ERR215
CITSO      CALL ERRSAV(212,ERR212)
CITSO      CALL ERRSET(212,1099,-1,1,1)
CICMS      CALL ERRSAV(215,ERR215)
CICMS      CALL ERRSET(215,1099,-1,1,1)
CITSO      CALL ERRSAV(219,ERR219)
CITSO      CALL ERRSET(219,1099,-1,1,1)
C ::::::::::::::::::::::::::::: BEGIN ::::::::::::::::::::::::::::::::
C DOES CALLER JUST WANT ERROR ACTION
      IF(RCODE)900,100,1000
100   CONTINUE
C NO...BEGIN PARSE
      CALL FTOKEN(CLIST,FIRST,LAST,TOKEN,8,DELMTR)
      C=0
C    :::LOOP OVER COMMANDS TO GET MATCH:::
      DO 700 I=1,NCMND
         CALL FMATCH(TOKEN,COMAND(I),' ',SW)
         IF(.NOT.SW)GOTO 700
C THIS COMMAND MATCHES
         IF(C.GT.0)THEN
            PRINT *,' ** ',TOKEN,' ambiguous...could be ',COMAND(C),
     1              ' or ',COMAND(I)
            GOTO 1000
         ENDIF
         C = I
700   CONTINUE
      IF(C.EQ.0)THEN
         PRINT *,' ** Command ',TOKEN,' not recognized'
         RCODE = 1
         GOTO 1000
      ENDIF
C
C         BRANCH ON COMMAND (C)
C         ~~~~~~~~~~~~~~~~~
      IF(C.GT.NCFLIP)THEN
C  SAVE FOR RECAP
         DO 760 I=2,NRECAP
760      CRECAP(I-1) = CRECAP(I)
         CRECAP(NRECAP)(2:) = CLIST(2:)
C  ADJUST COMMAND NUMBER FOR SYSTEM
         CMD = C - NCFLIP
         CALL SYSCM0(CMD,SWVALU,NSWSYS,CLIST,FIRST,LAST,RCODE)
C        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C BRANCH ON RETURN CODE (RCODE)
C ...RCODE = 0...ALL IS WELL
C          < 0...SYNTAX ERROR
C          > 0...OTHER ERROR
         IF(RCODE)900,1099,1000
      ENDIF
C
C   BRANCH ON FLIP COMMAND (SESSION CONTROL)
C   ======================
C           1    2    3    4    5    6    7    8    9
      GOTO(1100,1600,1500,1900,1300,1700,1800,1400,1200,
C           10   11   12   13   14   15   16
     1     2000,3000,3100,3200,4000,5000,6000,
     9     9000),C
C          ____ !CMS IS LAST COMMAND (IF IN CMS ENVIRONMENT)
C               !AIX IS LAST COMMAND (IF IN AIX ENVIRONMENT)
C               !DOS IS LAST COMMAND (IF IN DOS ENVIRONMENT)
C   =======================================================
900   CONTINUE
C SYNTAX ERROR
      IF(SWERR) PRINT *,' ** SYNTAX ERROR'
C FALL THRU TO CLOSE FILES
C
1000  CONTINUE
      IF(SWERR)THEN
C ERR_STOP SWITCH = TRUE ===> ABORT
         IF(INPUT.EQ.INPFIL)THEN
            CLOSE(UNIT=INPFIL)
            INPUT  = TTYIN
            INPLIN = 0
            IF(SWMSG) PRINT *,'...back to terminal input'
         ENDIF
         IF(OUTPUT.EQ.OUTFIL)THEN
            CLOSE(UNIT=OUTFIL)
            OUTPUT=TTYOUT
            IF(SWMSG) PRINT *,'...back to terminal output'
         ENDIF
CC       IF(C.GT.0.AND.C.LE.NCSYS)PRINT *,' ** ',COMAND(C),' aborted'
CC REMOVED 4-8-93
      ENDIF
1099  RETURN
C
C       ========================
C       SESSION CONTROL COMMANDS
C       ========================
C
1100  CONTINUE
C
C EXECUTE filename  [n] [//strings]
C =======
      CALL FLEXEC(CLIST,FIRST,LAST,RCODE)
      IF(RCODE)900,1099,1000
C
C SWITCH [swname [= setting] [...]]
C ======
1200  CONTINUE
      IF(FIRST.GT.LAST)THEN
C LIST SWITCHES
         WRITE(OUTPUT,1201,ERR=1000)(SWNAME(I),SWVALU(I),I=1,NSWTCH)
1201     FORMAT(6(3X,A8,'=',L1))
      ELSE
C CHANGE SWITCH(ES)
1250     NUMBER = NSWTCH
         CALL FTOKEN(CLIST,FIRST,LAST,TOKEN,8,CHAR)
         F = 1
         L = 8
         CALL FOPTN(TOKEN,F,L,SWNAME(1),NUMBER,RCODE)
         IF( RCODE.NE.0 )GOTO 900
         IF( NUMBER.EQ.0 )RETURN
         IF( CHAR.EQ.'=' )THEN
C ABSOLUTE SETTING (TRUE|FALSE)
            OPLIST(1) = 'TRUE'
            OPLIST(2) = 'FALSE'
            N = 2
            RCODE = -1
            CALL FOPTN(CLIST,FIRST,LAST,OPLIST,N,RCODE)
            IF( RCODE.NE.0 )GOTO 900
            SWVALU(NUMBER) = N.EQ.1
         ELSE
C TOGGLE
            SWVALU(NUMBER) = .NOT.SWVALU(NUMBER)
         ENDIF
         GOTO 1250
      ENDIF
      RETURN
C
C QUIT
C ====
1300  PRINT *,' Terminating ',SYSNAM
CITSO      CALL ERRSTR(212,ERR212)
CICMS      CALL ERRSTR(215,ERR215)
CITSO      CALL ERRSTR(219,ERR219)
      STOP
C IO ERRORS
1350  PRINT *,' ** IO ERROR'
      GOTO 1000
C
C STRING [{INCREMNT | name [= value]}]
C ======
1400  CONTINUE
      CALL FSTRNG(CLIST,FIRST,LAST,RCODE)
      IF(RCODE)900,1099,1000
C
C OUTPUT filename | *
C ======
1500  CONTINUE
      CALL FTOKEN(CLIST,FIRST,LAST,FILNAM,FLNLEN,DELMTR)
      IF(FILNAM.EQ.' ')THEN
         PRINT*,' ** MISSING FILENAME'
         GOTO 1000
      ENDIF
C
      IF( OUTPUT.EQ.OUTFIL )CLOSE(UNIT=OUTFIL)
      IF(FILNAM.EQ.'*')THEN
         OUTPUT = TTYOUT
         RETURN
      ENDIF
C
C GET SETUP'S PREFIX AND SUFFIX
      CALL FSETNM('OUTPUT',FILNAM,BEGEXT,RCODE)
      IF( RCODE.NE.0 )GOTO 1000
      CALL FILOUT(FILNAM,RCODE)
      IF( RCODE.NE.0 )GOTO 1000
C
      CALL FLOPEN(OUTFIL,FILNAM,'FORMATTED','UNKNOWN',*1000)
      OUTPUT = OUTFIL
      RETURN
C
C PRINT filename
C =====
C  GET FILE
1900  CALL FILEIN(CLIST,FIRST,LAST,'PRINT   ',FILNAM,RCODE)
      IF(RCODE.NE.0)GOTO 1000
      CALL FLOPEN(HLPFIL,FILNAM,'FORMATTED','OLD',*1000)
      LINE = 0
      CALL FPRINT(LINE,*1099)
      RETURN
C
C HELP [command_mask]
C ====
1600  CONTINUE
C SEE IF COMMAND MASK SPECIFIED
      CALL FTOKEN(CLIST,FIRST,LAST,TOKEN,8,DELMTR)
      IF(TOKEN.EQ.' ')THEN
C JUST SHOW COMMANDS
         WRITE(OUTPUT,1611)SYSNAM,NCFLIP
1611     FORMAT(10X,A8,' has ',I3,' session control commands:')
         WRITE(OUTPUT,1612)(COMAND(I),I=1,NCFLIP)
1612     FORMAT((5X,6(1X,A8)))
C WRITE SYSTEM COMMANDS (UNLESS THERE ARE NONE--IE, FLIPSYS)
         IF(NCSYS.GT.0)THEN
             WRITE(OUTPUT,1615)NCSYS
1615         FORMAT(10X,'and ',I3,' procedural commands:')
             I1=NCFLIP+1
             WRITE(OUTPUT,1612)(COMAND(I),I=I1,NCMND)
         ENDIF
         WRITE(OUTPUT,1619)
1619     FORMAT(/5X,'Enter HELP * to get help for each command')
         RETURN
      ENDIF
C
C COMMAND MASK SPECIFIED
C
      LINE = 1
      DO 1690 C=1,NCMND
          CALL FMATCH(TOKEN,COMAND(C),MASK,SW)
          IF(.NOT.SW)GOTO 1690
C
          IF(OUTPUT.EQ.TTYOUT)THEN
C OUTPUT = TERMINAL...CENTER COMMAND
             CLIST = COMAND(C)//' command'
             CALL FCENTR(CLIST,FIRST,LAST)
          ELSE
C OUTPUT = FILE...RIGHT JUSTIFY (FOR DOCUMENTATION)
             LAST = SCRWTH - 1
             CLIST = ' '
             CLIST(LAST-16:) = COMAND(C)
          ENDIF
C
          LINE = LINE + 1
          CALL FPRMPT(LINE,*1099)
          RCODE=0
C
C NOTE ON OUTPUT:
C
C  WITH OUTPUT=TTYOUT, WE FIRST PRINT COMMAND CENTERED, THUS ADDING
C  1 TO LINE COUNT BEFORE PROMPTING
C
C  WITH OUTPUT=file, WE WANT TO BEGIN ON NEW PAGE.  THIS HAPPENS IN FPRINT
C  AUTOMATICALLY DUE TO THE FACT THAT WE ARE PRINTING FROM THE .HLP FILE
C  TO OUTPUT (SEE FPRINT IN FLFILES).  IN ADDITION, WE SKIP 2 LINES BEFORE
C  PRINTING THE COMMAND RIGHT-JUSTIFIED, THEN ANOTHER LINE (LINE COUNT
C  DOES NOT MATTER WHEN PRINTING TO A FILE -- NO PROMPTING).
C
C  THE FORMAT LENGTHS ALSO DIFFER (128 FOR TERMINAL, 79 FOR FILE).
C
          IF( OUTPUT.EQ.TTYOUT )THEN
             WRITE(OUTPUT,'(128A1)')(CLIST(I:I),I=1,LAST)
          ELSE
             WRITE(OUTPUT,'(//79A1/)')(CLIST(I:I),I=1,LAST)
          ENDIF
C
C PRINT HLP FILE
C
          LENGTH = 8
CXTSO          LENGTH = 7
          CALL FSLEN(COMAND(C),LENGTH,LAST)
          FILNAM = COMAND(C)(:LAST)
          CALL FSETNM('HELP  ',FILNAM,BEGEXT,RCODE)
          RCODE = 0
C
          CALL FINQUR(FILNAM,IOSTAT,EXIST,*1690)
          IF(EXIST)THEN
              CALL FLOPEN(HLPFIL,FILNAM,'FORMATTED','UNKNOWN',*1613)
              CALL FPRINT(LINE,*1699)
              CLOSE(UNIT=HLPFIL)
              GOTO 1690
          ENDIF
1613      PRINT *,' No help available for ',COMAND(C)
1690  CONTINUE
C
      RETURN
C
1699  CLOSE(UNIT=HLPFIL)
      RETURN
C
C
C RETURN (OR EOF ON EXECUTE FILE)
C ======
1700  CONTINUE
      CLOSE(UNIT=INPFIL)
      IF(EXENUM.LE.0)THEN
C EXECUTE TERMINATES
         SW = LAST.GE.FIRST
         IF(SW)THEN
            CALL FTOKEN(CLIST,FIRST,LAST,TOKEN,8,DELMTR)
            CALL FMATCH(TOKEN,'QUIETLY',' ',SW)
         ENDIF
         IF(.NOT.SW .AND. SWMSG) PRINT *,' RETURN...back to terminal'
         INPUT  = TTYIN
         INPLIN = 0
      ELSE
C LOOP...OPEN EXECUTE FILE
         CALL FLOPEN(INPFIL,EXEFIL,'FORMATTED','OLD',*1000)
         EXENUM = EXENUM-1
      ENDIF
      RETURN
C
C SCREEN [WIDTH=value] [LENGTH=value]
C ======
1800  CONTINUE
C (RCODE=0 MEANS OPTIONS NOT MANDATORY)
      OPLIST(1)='WIDTH'
      OPLIST(2)='LENGTH'
      SW = .TRUE.
1810  NUMBER=2
      CALL FOPTN(CLIST,FIRST,LAST,OPLIST,NUMBER,RCODE)
      IF(RCODE.NE.0)GOTO 1000
      IF(NUMBER.EQ.0)THEN
         IF(SW)PRINT *,' Screen WIDTH=',SCRWTH,' LENGTH=',SCRLEN
         RETURN
      ENDIF
      SW = SWMSG
C GET VALUE OF SETTING
      CALL FTOKEN(CLIST,FIRST,LAST,STRVAL,32,DELMTR)
      IF(STRVAL.EQ.'*')THEN
         SETVAL=32000
      ELSE
         CALL FC2R(STRVAL,V,RCODE)
         IF(RCODE.NE.0)GOTO 900
         IF(V.GT.32000)THEN
             SETVAL=32000
         ELSE
             SETVAL=V+.0001
         ENDIF
      ENDIF
      IF(NUMBER.EQ.1)THEN
         IF(SETVAL.LT.20.OR.SETVAL.GT.127)THEN
             PRINT *,' ** SCREEN WIDTH MUST BE 21 TO 127'
             GOTO 1000
         ENDIF
C SET WIDTH
         SCRWTH=SETVAL
      ELSE
C SET LENGTH
         SCRLEN=SETVAL
      ENDIF
C REPEAT BECAUSE THERE MAY BE ANOTHER SETTING
      GOTO 1810
C
2000  CONTINUE
C RECAP
      CLIST = ' Recap of '//SYSNAM
      CALL FSLEN(CLIST,80,LAST)
      CLIST(LAST+2:) = 'Commands'
      LAST = LAST + 10
      WRITE(OUTPUT,2001,ERR=1350)(CLIST(K:K),K=1,LAST)
2001  FORMAT(1X,127A1)
      DO 2050 I=1,NRECAP
         CLIST = CRECAP(I)
         IF(CLIST.EQ.' ')GOTO 2050
         CALL FSLEN(CLIST,128,LAST)
         IF(LAST.GT.SCRWTH)THEN
            LAST = SCRWTH
            CLIST(LAST-3:) = ' ...'
         ENDIF
         WRITE(OUTPUT,2001,ERR=1350)(CLIST(K:K),K=1,LAST)
2050  CONTINUE
C
      RETURN
C
3000  CONTINUE
C _EJECT [condition]
      CALL FEJECT(CLIST,FIRST,LAST,LINE,RCODE)
      IF(RCODE)900,1099,1000
C
3100  CONTINUE
C _PAUSE [remark]
      CTEMP = CLIST(FIRST:)
C CLEAR TEXT BUFFER AND PROMPT
      CALL FSLEN(CTEMP,90,LAST)
      IF(LAST.GT.SCRWTH)THEN
         PRINT *,' ',CTEMP(:SCRWTH-1)
         LAST = 0
      ENDIF
      CTEMP(LAST+1:) = '...Continue (Y/N)?'
      CALL FSLEN(CTEMP,90,LAST)
      PRINT *,' ',CTEMP(:LAST)
C OK, NOW FIND OUT IF USER WANTS TO CONTINUE
      CALL FGTCHR('YN','Y',CHAR)
      IF(CHAR.EQ.'N' .OR. CHAR.EQ.' ')THEN
C ABORT...LET CALLER KNOW WITH RETURN CODE
         RCODE = UABORT
         GOTO 1000
      ENDIF
C CONTINUE, BUT WE CAN INITIALIZE LINE COUNT FOR COMMENT PROMPT
      LINE = 0
CIEIA      CALL FCLRSC
      RETURN
C
3200  CONTINUE
C _SETUP
      CALL FSETUP(CLIST,FIRST,LAST,RCODE)
      IF(RCODE)900,1099,1000
C
4000  CONTINUE
C _DICTNRY {LOAD CLEAR MERGE} filename
      CALL FDICIN(CLIST,FIRST,LAST,RCODE)
      RETURN
C
5000  CONTINUE
C _KEYWORD [CLEAR {LOAD|MERGE filename} SET key [= value] [...]]
      CALL FLKEYW(CLIST,FIRST,LAST,SWMSG,RCODE)
      RETURN
C
6000  CONTINUE
C _TYPE text [//justify]
      CALL FLOOK(CLIST,FIRST,LAST,'//',JUSTFY)
      IF(JUSTFY.GT.0)THEN
C   JUSTIFY OPTION
         F = JUSTFY+2
         OPLIST(1) = 'LEFT'
         OPLIST(2) = 'RIGHT'
         OPLIST(3) = 'CENTER'
         NUMBER = 3
         RCODE = -1
         CALL FOPTN(CLIST,F,LAST,OPLIST,NUMBER,RCODE)
         IF(RCODE.NE.0)RETURN
         LAST = JUSTFY-1
         IF(NUMBER-2)6010,6020,6030
6010     CONTINUE
C   LEFT JUSTIFY (REMOVE LEADING BLANKS)
          IF(CLIST(FIRST:FIRST).EQ.' ')THEN
             IF(FIRST.GE.LAST)THEN
                FIRST = LAST
             ELSE
                FIRST = FIRST+1
                GOTO 6010
             ENDIF
          ENDIF
          GOTO 6090
6020     CONTINUE
C    RIGHT JUSTIFY
          CTEMP = CLIST(FIRST:LAST)
          CLIST = ' '
          CALL FSLEN(CTEMP,128,LAST)
          IF(LAST.LT.SCRWTH-1)THEN
             CLIST(SCRWTH-LAST-1:) = CTEMP
          ELSE
             CLIST = CTEMP
          ENDIF
          FIRST = 1
          LAST = SCRWTH-1
          GOTO 6090
6030     CONTINUE
C    CENTER
         CTEMP = CLIST(FIRST:LAST)
         CLIST = CTEMP
         CALL FCENTR(CLIST,FIRST,LAST)
         FIRST = 1
      ELSE
C   NO JUSTIFY OPTION...BACKUP TO INCLUDE LEADING BLANKS
6050     FIRST = FIRST-1
         IF(CLIST(FIRST:FIRST).EQ.' ')GOTO 6050
         FIRST = FIRST+1
C        :...NOW POSITIONED JUST AFTER FIRST BLANK (FOLLOWING _TYPE)
      ENDIF
C OK, NOW TYPE TEXT...IN CLIST(FIRST:LAST)
6090  WRITE(OUTPUT,6001)(CLIST(I:I),I=FIRST,LAST)
6001  FORMAT(1X,127A1)
C               :....CHANGED 3-29-93 FROM 80A1
      RETURN
C
9000  CONTINUE
C !CMS, !AIX OR !DOS COMMAND
C ===   ====    ====
      CTEMP = CLIST(FIRST:)
CICMS      RCODE = 0
CICMS      CALL FVMCMD(CTEMP,RCODE)
CICMS      IF(SWMSG .OR. RCODE.NE.0)THEN
CICMS         CALL FSLEN(CTEMP,128,LAST)
CICMS         CTEMP(LAST+2:) = 'ISSUED WITH RCODE='
CICMS         STRVAL = ' '
CICMS         CALL FI2C(STRVAL,RCODE,FIRST)
CICMS         CALL FSLEN(CTEMP,128,LAST)
CICMS         CTEMP(LAST+2:) = STRVAL
CICMS         CALL FSLEN(CTEMP,128,LAST)
CICMS         PRINT *,' ',CTEMP(:LAST)
CICMS      ENDIF
CLAHEY       PRINT *,' '
CLAHEY       IF( CTEMP.EQ.' ' )CTEMP = 'COMMAND'
CLAHEY       CALL SYSTEM(CTEMP)
CIAIX       PRINT *,' '
CIAIX       CALL SYSTEM(CTEMP)
C
      RETURN
C
C ** FLCMN0 ENDS HERE
      END
      SUBROUTINE SYSCM0(CMD,SWVALU,NSWFLP,CLIST,FIRST,LAST,RCODE)
C     =================
      IMPLICIT INTEGER (A-U), DOUBLE PRECISION (Z)
C
      INCLUDE 'DCANAL.'
      INCLUDE 'DCFLIP.'
CITSO      INCLUDE (DCANAL)
CITSO      INCLUDE (DCFLIP)
CI$$INSERT DCANAL
CI$$INSERT DCFLIP
C
C This executes an ANALYZE command (copy of SYSCMD), except INTERPRT
C command is prohibited (affects statements at 4100).  This is entered
C only by the $INTERPRT command in a rule file.
C
      CHARACTER*128 CLIST
      LOGICAL*1     SWVALU(0:20)
      INTEGER*2     CMDMAP(29)
      COMMON/ANLCMD/CMDMAP
C :::::::::::::::::::::::::::: BEGIN :::::::::::::::::::::::::::::::
C ADJUST COMMAND NUMBER (CMD) FOR BRANCH
      CMD = CMDMAP(CMD)
C
C IF CMD > 1, THERE MUST BE LP IN MEMORY
C
      IF(CMD.GT.1.AND.PRBNAM.EQ.' ')THEN
           PRINT *,' No LP in memory...use READIN command'
           RCODE=1
           RETURN
      ENDIF
C
C COPY SWITCH VALUES
      SWDBG  = SWVALU(0) .OR. SWDBG
      SWMSG  = SWVALU(NSWFLP)
C     ^^^^^^^^^^^^^^^^^^FLIP SWITCHES, NOW COPY ANALYZE SWITCHES
      SWDISP = SWVALU(NSWFLP+1)
      IF(SWVALU(NSWFLP+2))THEN
           OPTNAM = 'MINIMIZE'
      ELSE
           OPTNAM = 'MAXIMIZE'
      ENDIF
      SWSYN = SWVALU(NSWFLP+3)
C
C LET GETMAT KNOW IF SENSE OF OPTIMIZATION HAS CHANGED
      CALL GSETOP(OPTNAM)
C     ______________________
C     BRANCH ON COMAND (CMD)
C
      GOTO(100,200,300,400,500,600,700,800,900,
     1    1000,1100,1200,1300,1400,1500,1600,
     2    2000,
     4    4000,4100,4200,  5000, 6000, 7000, 7100, 7500, 7600, 7700,
     5    8000,8100
     X ),CMD
           PRINT *,' SYSERR C',CMD
           STOP
C
100   CONTINUE
C READIN M|P|S|IIS [filename [options]]
      CALL AREAD(CLIST,FIRST,LAST,RCODE)
      GOTO 9000
C
200   CONTINUE
C SUMMARY (to OUTPUT)
      CALL ASUMRY
      RETURN
C
300   CONTINUE
C WRITEOUT [filename [FORMAT]]
      CALL AWRITE(CLIST,FIRST,LAST,RCODE)
      RETURN
C
400   CONTINUE
C SUBMAT {{ROW|COL} cond | CLEAR | SET | * | subcomand}
      CALL ASBSET(CLIST,FIRST,LAST,RCODE)
      RETURN
C
500   CONTINUE
C ADDRIM [ROW|COLUMN [conditional]]
      CALL ADDRIM(CLIST,FIRST,LAST,OUTPUT,RCODE)
      GOTO 9000
C
600   CONTINUE
C DISPLAY [ROW|COLUMN [conditional]]
      CALL ADSPLY(CLIST,FIRST,LAST,RCODE)
      GOTO 9000
C
700   CONTINUE
C COUNT [row_conditional] [,col_conditional]
      CALL ACOUNT(CLIST,FIRST,LAST,OUTPUT,RCODE)
      GOTO 9000
C
800   CONTINUE
C LIST [row_conditional] [,col_conditional] [//EQUATION]
      CALL AQLIST(CLIST,FIRST,LAST,RCODE)
      GOTO 9000
C
900   CONTINUE
C PICTURE [row_conditional] [,col_conditional]
      CALL APICTR(CLIST,FIRST,LAST,OUTPUT,RCODE)
      GOTO 9000
C
1000  CONTINUE
C SHOW [{ROW COLUMN} [conditional]]
      CALL AQSHOW(CLIST,FIRST,LAST,RCODE)
      GOTO 9000
C
1100  CONTINUE
C TALLY ?_mask [ROW|COLUMN [conditional]]
      CALL ATALLY(CLIST,FIRST,LAST,RCODE)
      GOTO 9000
C
1200  CONTINUE
C TRACE [row_conditional] [,col_conditional]
      CALL ATRACE(CLIST,FIRST,LAST,RCODE)
      GOTO 9000
C
1300  CONTINUE
C EXPLAIN [ROW|COLUMN [conditional]]
      IF( SWEXPL )THEN
         CALL EXPLAN(CLIST,FIRST,LAST,RCODE)
         GOTO 9000
      ENDIF
      PRINT *,' No syntax in memory...use READIN SYNTAX command'
      RETURN
C
1400  CONTINUE
C BLOCK see BLOCK.HLP or ABLOCK for command syntax (many options)
      CALL ABLOCK(CLIST,FIRST,LAST,RCODE)
      RETURN
C
1500  CONTINUE
C SYNTAX {ROWS,COLUMNS,SETS}
      LINE = 1
      CALL EXSYN(CLIST,FIRST,LAST,LINE,RCODE)
      RETURN
C
1600  CONTINUE
C REDUCE [conditional] [//specs]
      CALL AREDUC(CLIST,FIRST,LAST,RCODE)
      RETURN
C
2000  CONTINUE
C RATEOF [ROW|COL [conditional]]
      CALL ARATE(CLIST,FIRST,LAST,RCODE)
      GOTO 9000
C
4000  CONTINUE
C SOLUTION {MINOS | OB1 | OSL | MPS | XMP} [filespec]
      CALL ARDSOL(CLIST,FIRST,LAST,RCODE)
      RETURN
C
4100  CONTINUE
C INTERPRT [key]
      PRINT *,' ** CANNOT USE THE ANALYZE INTERPRT COMMAND',
     1        ' (USE $INTERPRT)'
      RCODE = 2
      RETURN
C
4200  CONTINUE
C BASIS [options]
      CALL ABASIS(CLIST,FIRST,LAST,RCODE)
      RETURN
C
5000  CONTINUE
C SCHEMA {DISPLAY | LOAD | READ}
      CALL ASCHMA(CLIST,FIRST,LAST,RCODE)
      RETURN
C
6000  CONTINUE
C AGGREGAT [{ROW | COL} [cond]]
      CALL AGGRG8(CLIST,FIRST,LAST,RCODE)
      GOTO 9000
C
7000  CONTINUE
C GRAPH
      CALL AGRAPH(CLIST,FIRST,LAST,RCODE)
      RETURN
C
7100  CONTINUE
C TABLE {ROW | COL} name key
      CALL TABLE(CLIST,FIRST,LAST,RCODE)
      RETURN
C
7500  CONTINUE
C FREE {LOWER,UPPER} [{ROW | COL [conditional]]
      CALL ANFREE(CLIST,FIRST,LAST,RCODE)
      GOTO 9000
C
7600  CONTINUE
C RENAME {PROBLEM | SOLVER | RHS | BOUNDS | RANGES} name [,...]
      CALL ARENAM(CLIST,FIRST,LAST,RCODE)
      RETURN
C
7700  CONTINUE
C FIX value [{ROW | COL [conditional]]
      CALL ANFIX(CLIST,FIRST,LAST,RCODE)
      GOTO 9000
8000  CONTINUE
C ROUND [conditional]
      CALL AROUND(CLIST,FIRST,LAST,RCODE)
      GOTO 9000
8100  CONTINUE
C VERIFY
      CALL AVERFY(CLIST,FIRST,LAST,RCODE)
C
9000  CONTINUE
C SET SWITCHES FOR FLIP (MAY HAVE CHANGED)
      SWVALU(NSWFLP+1) = SWDISP
      SWVALU(NSWFLP+2) = OPTNAM.EQ.'MINIMIZE'
C
      RETURN
C
C ** SYSCM0 ENDS HERE
      END
