C             ::: GETIOSOL.FOR  8-12-95 :::
C
C The code to read an MPS file is based on the code developed and tested
C by Milton M. Gutterman on the SUN4.
C
C Earlier dates deleted
C    10-13-93...Corrected MPS read (as per John Stone)
C    10-26-93...Changed MINOS format (CC) from E to G
C     1-08-95...Added wrap code for MINOS         \
C               Added free field for MINOS         > CC 7-20-95
C               REMOVED OB1 (SAVED IN GETOB1.FOR) /
C     7-21-95...Added some debug stuff
C
C This contains the following GETMAT IO subroutine.
C
C     GRDSOL...reads solution file (link with outside)
C     GRDMN1...reads lines of solution file to find keyword
C     MPSCHK...checks MPS name
C
      SUBROUTINE GRDSOL(SWMSG,FORMAT,RCODE)
C     =================
      IMPLICIT INTEGER (A-U), DOUBLE PRECISION (Z)
C
      INCLUDE 'DCGETMAT.'
CITSO      INCLUDE (DCGETMAT)
CI$$INSERT DCGETMAT
C
C This reads solution file, presumed open
C             .--  FROM DATFIL --.
C             \                  /
C    FORMAT =  MINOS | MPS |  OSL
C                      :....FROM PCKFIL (UNFORMATTED)
      LOGICAL*1     SWMSG
      CHARACTER*(*) FORMAT
C LOCAL
      CHARACTER*128 CLIST
      CHARACTER*64  SEARCH
      CHARACTER*32  STRVAL
      CHARACTER*16  RNAME,CNAME
      CHARACTER*1   STAT,CINF,CHAR
C THE FOLLOWING ARE FOR MPS SOLUTION FILE (MPSX, MPSIII, CPLEX)
      CHARACTER*200 MPSSTR
      CHARACTER*8  MPSNAM(25)
      CHARACTER*4  MPSCH4(50)
      EQUIVALENCE (MPSNAM(1),MPSCH4(1),MPSSTR)
      REAL*8       MPSVAL(25)
      INTEGER*4    MPSINT(50)
      EQUIVALENCE (MPSVAL(1),MPSINT(1))
C ::::::::::::::::::::::::::: BEGIN :::::::::::::::::::::::::::::
C COPY FILE UNIT (= DATFIL FOR ALL OPTIONS, EXCEPT MPS)
      TEMFIL = DATFIL
C COPY FORMAT (NAME OF SOLVER)
      SOLNAM = FORMAT
      CALL FSLEN(SOLNAM,16,LSOLN)
C INITIALIZE SOLUTION STAT-TYPES (DON'T KNOW)
      STBASC = 0
      STCOMP = 0
C INITIALIZE NUMBER OF NON-BASIC FREE COLS (BOUND ADJUSTED)
      NFRCOL = 0
C
1     FORMAT(A128)
      SEARCH = ' '
      LINE = 0
      IF( SWDBG )PRINT *,' GETIOSOL...SOLNAM=',SOLNAM
C              BRANCH ON SOLVER TYPE
C              ~~~~~~~~~~~~~~~~~~~~~
      IF( SOLNAM(1:LSOLN).NE.'MINOS' )GOTO 1000
C ============ MINOS SOLUTION FILE ============
C SEARCH ORDER
C       Keyword         Variable
C       =========       ========
C       NAME            prbnam
C       STATUS          solst
C       OBJECTIVE       objnam
C       RHS             rhsnam
C       RANGES          rngnam
C       BOUNDS          bndnam
C       SECTION 1 - ROWS
C       SECTION 2 - COLUMNS
C
                SEARCH = 'NAME'
100   CALL GRDMN1(TEMFIL,LINE,SEARCH,SWMSG,CLIST,FIRST,LAST,RCODE)
      IF( RCODE )1302,110,1301
110   CALL FTOKEN(CLIST,FIRST,LAST,CNAME,16,CHAR)
C CHECK PROBLEM NAME
      IF( CNAME.NE.PRBNAM )GOTO 1310
                SEARCH = 'STATUS'
      CALL GRDMN1(TEMFIL,LINE,SEARCH,SWMSG,CLIST,FIRST,LAST,RCODE)
      IF( RCODE )1302,120,1301
120   CALL FTOKEN(CLIST,FIRST,LAST,SOLST,16,CHAR)
C CHECK STATUS
      IF( SOLST.NE.'INFEASIBLE' .AND. SOLST.NE.'UNBOUNDED' .AND.
     1    SOLST.NE.'OPTIMAL   ' .AND. SOLST.NE.'FEASIBLE ' )THEN
         PRINT *,' Warning: Solution status not recognized: ',SOLST
         SOLST = 'unknown'
      ENDIF
                SEARCH = 'OBJECTIVE'
      CALL GRDMN1(TEMFIL,LINE,SEARCH,SWMSG,CLIST,FIRST,LAST,RCODE)
      IF( RCODE )1302,130,1301
130   CALL FTOKEN(CLIST,FIRST,LAST,CNAME,16,CHAR)
C CHECK OBJ NAME
      IF( CNAME.NE.OBJNAM )GOTO 1310
C ...SET SENSE OF OPTIMIZATION
      CALL FLOOKF(CLIST,FIRST,LAST,'(',I)
      IF( I.GT.0 )THEN
         FIRST = I+1
         CALL FLOOKF(CLIST,FIRST,LAST,')',I)
         IF( I.GT.0 )LAST = I-1
      ENDIF
      CALL FTOKEN(CLIST,FIRST,LAST,CNAME,16,CHAR)
      CNAME(4:) = ' '
      IF( CNAME.EQ.'MIN ' .OR. CNAME.EQ.'MAX ' )GOTO 135
      CALL FSCASE(CNAME,1,3)
      IF( CNAME.EQ.'MIN ' .OR. CNAME.EQ.'MAX ' )GOTO 135
      IF( SOLST.EQ.'OPTIMAL' )THEN
         PRINT *,' ** SENSE OF OPTIMIZATION SHOULD BE MIN OR MAX,',
     1           ' NOT ',CNAME(:3)
         GOTO 1390
      ENDIF
      PRINT *,' Warning: Expected MIN or MAX instead of ',CNAME(:3)
      GOTO 139
135   CALL GSETOP(CNAME)
139   CONTINUE
                SEARCH = 'RHS'
      CALL GRDMN1(TEMFIL,LINE,SEARCH,SWMSG,CLIST,FIRST,LAST,RCODE)
      IF( RCODE )1302,140,1301
140   CALL FTOKEN(CLIST,FIRST,LAST,CNAME,16,CHAR)
      IF( CNAME.NE.RHSNAM )GOTO 1310
                SEARCH = 'RANGES'
      CALL GRDMN1(TEMFIL,LINE,SEARCH,SWMSG,CLIST,FIRST,LAST,RCODE)
      IF( RCODE )1302,150,1301
150   CALL FTOKEN(CLIST,FIRST,LAST,CNAME,16,CHAR)
      IF( CNAME.EQ.' ' )CNAME='none'
      IF( CNAME.NE.RNGNAM )GOTO 1310
                SEARCH = 'BOUNDS'
      CALL GRDMN1(TEMFIL,LINE,SEARCH,SWMSG,CLIST,FIRST,LAST,RCODE)
      IF( RCODE )1302,160,1301
160   CALL FTOKEN(CLIST,FIRST,LAST,CNAME,16,CHAR)
      IF( CNAME.EQ.' ' )CNAME='none'
      IF( CNAME.NE.BNDNAM )GOTO 1310
C     ====================================
      IF( SWMSG )PRINT *,' Names verified'
C     ====================================
C SKIP TO:  SECTION 1 - ROWS
                SEARCH = 'SECTION 1 - ROWS'
      CALL GRDMN1(TEMFIL,LINE,SEARCH,SWMSG,CLIST,FIRST,LAST,RCODE)
      IF( RCODE )1302,200,1301
200   CONTINUE
C SKIP TO HEADER:  NUMBER    (SHOULD SKIP 1 LINE, THEN BINGO)
                SEARCH = 'NUMBER '
      CALL GRDMN1(TEMFIL,LINE,SEARCH,SWMSG,CLIST,BEGNAM,LAST,RCODE)
      IF( RCODE )1302,210,1301
210   CONTINUE
C HEADER SHOULD CONTAIN '.DUAL ACTIVITY' (IF FILE NOT WRAPPED)
      MPSSTR = ' '
      CALL FLOOK(CLIST,80,120,'.DUAL ACTIVITY',BEGP)
      IF( BEGP.EQ.0 )MPSSTR = CLIST
C NEXT LINE IS EITHER BLANK OR IT IS 2ND LINE OF HEADER (FILE WRAPPED)
      READ(TEMFIL,1,ERR=1301,END=1302)CLIST
      LINE = LINE+1
      IF( MPSSTR.NE.' ' )THEN
C ...2ND LINE OF WRAPPED FILE...MERGE 2 LINES
         MPSSTR(81:) = CLIST
         PRINT *,' Lines appear wrapped...'
         PRINT *,' ',MPSSTR(:80)
         PRINT *,' ',MPSSTR(81:127)
         PRINT *,' '
         PRINT *,' ...Merged:'
         PRINT *,' ',MPSSTR(:127)
         PRINT *,' '
         PRINT *,' ...Continue with wrap assumption (Y/N)? '
         CALL FGTCHR('YN',' ',CHAR)
         IF( CHAR.EQ.'N' )GOTO 9000
C SET FIELDS RELATIVE TO WHERE NAME BEGINS (BEGNAM SET BY ...ROW..)
         BEGINF = BEGNAM +  9
         BEGST  = BEGINF +  3
C ...LEVEL (BEGX) AND PRICE (BEGP) BEGIN 1 COLUMN BEFORE HEADER
         SEARCH = '...ACTIVITY'
         CALL FLOOKF(MPSSTR,1,80,SEARCH,BEGX)
         IF( BEGX.EQ.0 )THEN
            PRINT *,' ** CANNOT FIND ',SEARCH(:11),' IN HEADER'
            GOTO 1390
         ENDIF
         BEGX = BEGX-1
         SEARCH = '.DUAL ACTIVITY'
         CALL FLOOKF(MPSSTR,80,100,SEARCH,BEGP)
         IF( BEGP.EQ.0 )THEN
            PRINT *,' ** CANNOT FIND ',SEARCH(:14),' IN HEADER'
            GOTO 1390
         ENDIF
         BEGP = BEGP-1
C ...READ BLANK LINE
         READ(TEMFIL,1,ERR=1301,END=1302)CLIST
         LINE = LINE+1
      ENDIF
C SHOULD NOW BEGIN THE ROWS (1 OR 2 LINES PER ROW)
      CNAME = 'ROW '
C
C   ::: LOOP OVER ROWS :::
      DO 500 I=1,NROWS
300      CONTINUE
         IF( MPSSTR.EQ.' ' )THEN
C FILE NOT WRAPPED...USE FORMAT
            READ(TEMFIL,301,ERR=1301,END=1302)RNAME,CINF,STAT,VX,VP
            LINE = LINE+1
301         FORMAT(T11,A8,T20,A1,T23,A1,T25,G16.6,T89,G16.6)
            IF( RNAME.EQ.' ' )GOTO 300
         ELSE
C FILE WRAPPED...READ 2 LINES, MERGE, AND SET BY FIXED FIELD
            READ(TEMFIL,1,ERR=1301,END=1302)CLIST
            LINE = LINE+1
            IF( CLIST.EQ.' ' )GOTO 300
            MPSSTR = CLIST
            READ(TEMFIL,1,ERR=1301,END=1302)CLIST
            LINE = LINE+1
            MPSSTR(81:) = CLIST
            RNAME = MPSSTR(BEGNAM:BEGNAM+7)
            CINF  = MPSSTR(BEGINF:BEGINF)
            STAT  = MPSSTR(BEGST :BEGST )
            STRVAL= MPSSTR(BEGX  :BEGX+15)
            CALL FC2R(STRVAL,VX,RCODE)
            IF( RCODE.NE.0 )GOTO 1390
            STRVAL= MPSSTR(BEGP  :BEGP+15)
            CALL FC2R(STRVAL,VP,RCODE)
            IF( RCODE.NE.0 )GOTO 1390
         ENDIF
C LOOKUP ROW
         CALL GETNUM('ROW ',RNAME,ROW)
         IF( ROW.EQ.0 )GOTO 1340
C DECODE STATUS
         IF( STAT.EQ.'E' )THEN
            IF( VP*OPT.LE.0.0 )THEN
               STAT = 'L'
            ELSE
               STAT = 'U'
            ENDIF
         ELSE IF( STAT.EQ.'B'.AND.CINF.EQ.'I' )THEN
            STAT = 'I'
         ELSE IF( STAT.EQ.'F' )THEN
            STAT = 'B'
         ENDIF
C STORE SOLUTION
         CALL GPUTSL(IRSTAT+ROW,IRSOLV+ROW,STAT,VX,VP,RCODE)
         IF( RCODE.NE.0 )GOTO 1330
C NEXT ROW (I)
500   CONTINUE
C
      IF( SWMSG )PRINT *,'     MINOS Rows section read'
C
C SKIP TO:  SECTION 2 - COLUMNS
                SEARCH = 'SECTION 2 - COLUMNS'
      CALL GRDMN1(TEMFIL,LINE,SEARCH,SWMSG,CLIST,FIRST,LAST,RCODE)
      IF( RCODE )1302,600,1301
600   CONTINUE
C SKIP TO HEADER:  NUMBER    (SHOULD SKIP 1 LINE, THEN BINGO)
                SEARCH = 'NUMBER '
      CALL GRDMN1(TEMFIL,LINE,SEARCH,SWMSG,CLIST,FIRST,LAST,RCODE)
      IF( RCODE )1302,610,1301
610   CONTINUE
C HEADER SHOULD CONTAIN 'REDUCED GRADNT' (IF FILE NOT WRAPPED)
CC 7-20-95
      IF( MPSSTR.NE.' ' )THEN
C FILE IS WRAPPED
         READ(TEMFIL,1,ERR=1301,END=1302)CLIST
         LINE = LINE+1
         CALL FLOOK(CLIST,1,80,'REDUCED GRAD',I)
         IF( I.EQ.0 )THEN
            PRINT *,' ** 2ND HEADER LINE OF COLUMNS EXPECTED'
            GOTO 1390
         ENDIF
C PROCEED TO READ BLANK LINE FOLLOWING HEADER
      ENDIF
CC =======
      READ(TEMFIL,1,ERR=1301,END=1302)CLIST
      LINE = LINE+1
      CNAME = 'COLUMN '
C
C  ::: LOOP OVER COLUMNS :::
      DO 900 J=1,NCOLS
700      CONTINUE
         IF( MPSSTR.EQ.' ' )THEN
C FILE NOT WRAPPED
            READ(TEMFIL,301,ERR=1301,END=1302)RNAME,CINF,STAT,VX,VP
            LINE = LINE+1
            IF( RNAME.EQ.' ' )GOTO 700
         ELSE
C FILE WRAPPED...READ 2 LINES, MERGE, AND SET BY FIXED FIELD
            READ(TEMFIL,1,ERR=1301,END=1302)CLIST
            LINE = LINE+1
            IF( CLIST.EQ.' ' )GOTO 700
            MPSSTR = CLIST
            READ(TEMFIL,1,ERR=1301,END=1302)CLIST
            LINE = LINE+1
            MPSSTR(81:) = CLIST
            RNAME = MPSSTR(BEGNAM:BEGNAM+7)
            CINF  = MPSSTR(BEGINF:BEGINF)
            STAT  = MPSSTR(BEGST :BEGST )
            STRVAL= MPSSTR(BEGX  :BEGX+15)
            CALL FC2R(STRVAL,VX,RCODE)
            IF( RCODE.NE.0 )GOTO 1390
            STRVAL= MPSSTR(BEGP  :BEGP+15)
            CALL FC2R(STRVAL,VP,RCODE)
            IF( RCODE.NE.0 )GOTO 1390
         ENDIF
C LOOKUP COLUMN
         CALL GETNUM('COL ',RNAME,COL)
         IF( COL.EQ.0 )GOTO 1340
C DECODE STATUS
         IF( CINF.EQ.'I' .AND. STAT.EQ.'B' )THEN
            STAT = 'I'
         ELSE
            CALL GRDSTA('COL ',COL,VX,VP,STAT,NFRCOL,*1392)
         ENDIF
C STORE SOLUTION
         CALL GPUTSL(ICSTAT+COL,ICSOLV+COL,STAT,VX,VP,RCODE)
         IF( RCODE.NE.0 )GOTO 1330
C NEXT COLUMN (J)
900   CONTINUE
C
      GOTO 9000
C     =========
1000  CONTINUE
      IF( SOLNAM(1:LSOLN).NE.'OB1' )GOTO 3000
CC ====== OB1 REMOVED 7-20-95 ===============
      PRINT *,' ** SOLUTION OB1 not supported...contact author'
      GOTO 1399
C  ===========================================
3000  CONTINUE
      IF( SOLNAM(1:LSOLN).NE.'MPS' )GOTO 4000
C ============= MPS SOLUTION FILE =============
C UNFORMATTED...PCKFIL PRESUMED OPEN
      TEMFIL = PCKFIL
      CHAR = ' '
C
C RECORD 1:   NAME  deck_name
      READ(PCKFIL,ERR=1301,END=1302) MPSNAM(1),MPSNAM(2)
      LINE = LINE + 1
      IF( MPSNAM(1).NE.'NAME' )THEN
         PRINT *,' ** MPS FILE DOES NOT BEGIN WITH NAME RECORD'
         GOTO 1392
      ENDIF
      CALL MPSCHK(MPSNAM(2),PRBNAM,'Problem',*3001)
      GOTO 3009
3001  CHAR = '*'
C             :...FLAGS THAT WARNING WAS ISSUED
3009  CONTINUE
C RECORD 2:  SOLUTION  21 0 (CONSTANTS IGNORED)
      READ(TEMFIL,ERR=1301,END=1302) MPSNAM(1),MPSVAL(1)
      LINE = LINE+1
      IF( MPSNAM(1).NE.'SOLUTION' )THEN
         PRINT *,' ** MPS FILE DOES NOT CONTAIN SOLUTION'
         GOTO 1392
      ENDIF
C RECORDS 3 & 4:  column names and indicators of identification
C                 section ... IGNORE
      READ(TEMFIL,ERR=1301,END=1302)
      LINE = LINE+1
      READ(TEMFIL,ERR=1301,END=1302)
      LINE = LINE+1
C RECORD 5:  Data from identification section...
C      ...SOME ARE NUMERIC AND SOME ARE CHARACTER, SO WE SHALL
C         READ RECORD TWICE
      READ(TEMFIL,ERR=1301,END=1302) MPSNAM
      LINE = LINE+1
C READ MPSNAM AS INTERNAL FILE TO GET VALUES
      READ(MPSSTR,'(14A8)',ERR=1301,END=1302) (MPSVAL(I),I=1,14)
C CHECK NAMES
C ===========
C OBJECTIVE ROW
      CALL MPSCHK(MPSNAM(3),OBJNAM,'Objective',*1392)
C RHS
      RNAME = MPSNAM(4)
      IF( RNAME.EQ.'rhs' )RNAME = 'none'
      CALL MPSCHK(RNAME,RHSNAM,'RHS',*3011)
      GOTO 3012
3011  CHAR = '*'
C             :...FLAGS THAT WARNING WAS ISSUED
3012  CONTINUE
C BOUNDS
      IF( MPSINT(17).EQ.0 .AND. MPSINT(20).EQ.0 )THEN
         RNAME = 'none'
      ELSE
         RNAME = MPSNAM(9)
      ENDIF
      CALL MPSCHK(RNAME,BNDNAM,'Bound',*3021)
      GOTO 3022
3021  CHAR = '*'
3022  CONTINUE
C RANGES
      IF( MPSINT(19).EQ.0 .AND. MPSINT(20).EQ.0 )THEN
         RNAME = 'none'
      ELSE
         RNAME = MPSNAM(10)
      ENDIF
      CALL MPSCHK(RNAME,RNGNAM,'Range',*3031)
      GOTO 3032
3031  CHAR = '*'
3032  CONTINUE
      IF( CHAR.EQ.'*' )THEN
         PRINT *,' Do you want to continue (Y/N)? '
         CALL FGTCHR('YN','Y',CHAR)
         IF( CHAR.EQ.'N' )GOTO 1399
      ELSE IF( SWMSG )THEN
         PRINT *,' Names verified'
      ENDIF
C SOLUTION STATUS
      IF( MPSCH4(29).EQ.'OPTM' )THEN
         SOLST = 'OPTIMAL '
      ELSE IF( MPSCH4(29).EQ.'NOPT' )THEN
         SOLST = 'FEASIBLE'
      ELSE IF( MPSCH4(29).EQ.'NFES' )THEN
         SOLST = 'INFEASIBLE'
      ELSE
         SOLST = 'unknown'
      ENDIF
C SENSE OF OPTIMIZATION
      CALL GSETOP(MPSCH4(28))
      IF( SWMSG )PRINT *,' Solution status is ',SOLST(:10),
     1          '...Sense = ',MPSCH4(28)(:3),'IMIZE'
C CHECK NUMBERS
C =============
C ROWS
      IF( MPSINT(25).NE.NROWS )THEN
         PRINT *,' ** MPS FILE HAS',MPSINT(25),' ROWS'
         PRINT *,'          LP HAS',NROWS,     ' ROWS'
         GOTO 1392
      ENDIF
C COLUMNS
      IF( MPSINT(26).NE.NCOLS )THEN
         PRINT *,' ** MPS FILE HAS',MPSINT(26),' COLUMNS'
         PRINT *,'          LP HAS',NCOLS,     ' COLUMNS'
         GOTO 1392
      ENDIF
C ========================================
      IF( SWMSG )PRINT *,' Stats verified'
C ========================================
C RECORD 6:  $ENDSEC$ FOR IDENTIFCATION...IGNORE
      READ(TEMFIL,ERR=1301,END=1302)MPSNAM(1)
      LINE = LINE + 1
C BEGIN ROWS SECTION AT RECORD 7
C ==============================
C HEADER:  RSECTION  number (of items filed)
      READ(TEMFIL,ERR=1301,END=1302)MPSNAM(1),NUMBER
      LINE = LINE + 1
      IF( MPSNAM(1).NE.'RSECTION' )THEN
         PRINT *,' ** ROW SECTION NOT PRESENT ON MPS FILE'
         GOTO 1392
      ENDIF
      IF( NUMBER.LT.3 .OR. NUMBER.GT.25 )THEN
         PRINT *,' ** NUMBER OF ROW ITEMS =',NUMBER,
     1           '...MUST BE >= 3 AND <= 25'
         GOTO 1392
      ENDIF
C READ TITLES IN ROW RECORDS
      READ(TEMFIL,ERR=1301,END=1302) (MPSNAM(I),I=1,NUMBER)
      LINE = LINE + 1
C 'ACTIVITY' MUST BE PRESENT AND MUST BE FIRST
      IF( MPSNAM(1).NE.'ACTIVITY' )THEN
         PRINT *,' ** ACTIVITY (LITERALLY) NOT FILED IN ROW SECTION'
         GOTO 1392
      ENDIF
C DUAL PRICE ('DUALACT') IS NEXT ITEM WE NEED...SEARCH FOR IT
      DO 3050 LOCP=2,NUMBER-1
         IF( MPSNAM(LOCP).EQ.'DUALACT ')GOTO 3060
3050  CONTINUE
      PRINT *,' ** DUAL PRICE (DUALACT) NOT FILED IN ROW SECTION'
      GOTO 1392
C STATUS SHOULD BE NEXT TO LAST
3060  CONTINUE
      IF( MPSNAM(NUMBER-1).NE.'STATUS  ' ) THEN
         PRINT *,' ** STATUS (LITERALLY) NOT FILED IN ROW SECTION'
         GOTO 1392
      ENDIF
C ROW NAME IS LAST
C THE NEXT RECORD CONTAINS THE COLUMN INDICATORS OF THE ROWS SECTION
C ...SKIP IT
      READ (TEMFIL,ERR=1301,END=1302)
      LINE = LINE + 1
C IN A ROW'S RECORD, THE SOLUTION VALUES ARE LOCATED AT:
C       1        = LEVEL
C       LOCP     = PRICE
C       NUMBER-1 = STATUS
C       NUMBER   = NAME
C ::: LOOP OVER ROWS TO READ THEIR RECORDS :::
      CNAME = 'ROW'
      DO 3190 I=1,NROWS
         READ(TEMFIL,ERR=1301,END=1302) (MPSNAM(K),K=1,NUMBER)
         LINE = LINE + 1
         RNAME = MPSNAM(NUMBER)
C LOOK UP ROW
         CALL GETNUM('ROW ',RNAME,ROW)
         IF( ROW.EQ.0 )GOTO 1340
C READ MPSNAM AS INTERNAL FILE TO GET VALUES
         READ(MPSSTR,'(25A8)',ERR=1301,END=1302) (MPSVAL(K),K=1,NUMBER)
         VX = MPSVAL(1)
         VP = -MPSVAL(LOCP)
C             :...MPS SYSTEMS PUT MINUS ACTUAL DUAL PRICE
         IF( ROW.EQ.OBJNUM ) VP = OPT
         STAT = MPSNAM(NUMBER-1)(1:1)
C DECODE STATUS
         CALL GRDSTA('ROW ',ROW,VX,VP,STAT,DUMMY,*1392)
C STORE SOLUTION OF ROW
         CALL GPUTSL(IRSTAT+ROW,IRSOLV+ROW,STAT,VX,VP,RCODE)
         IF( RCODE.NE.0 )GOTO 1330
3190  CONTINUE
C  ::: END OF ROWS :::
C
      IF( SWMSG )PRINT *,' MPS ROWS SECTION READ'
C
C THERE SHOULD BE ANOTHER $ENDSEC$ RECORD...SKIP IT
      READ(TEMFIL,ERR=1301,END=1302)
      LINE = LINE + 1
C
C BEGIN COLUMNS SECTION
C =====================
C HEADER:  CSECTION number of items
      READ(TEMFIL,ERR=1301,END=1302)MPSNAM(1),NUMBER
      LINE = LINE+1
      IF( MPSNAM(1).NE.'CSECTION' )THEN
         PRINT *,' ** COLUMN SECTION NOT PRESENT'
         GOTO 1392
      ENDIF
      IF( NUMBER.LT.3 .OR. NUMBER.GT.25 )THEN
         PRINT *,' ** NUMBER OF COLUMN ITEMS =',NUMBER,
     1           '...MUST BE >= 3 AND <= 25'
         GOTO 1392
      ENDIF
C  READ TITLES OF COLUMN SECTION
      READ(TEMFIL,ERR=1301,END=1302) (MPSNAM(I),I=1,NUMBER)
      LINE = LINE + 1
C  ACTIVITY MUST BE PRESENT AND MUST BE FIRST
      IF( MPSNAM(1).NE.'ACTIVITY' )THEN
         PRINT *,' ** ACTIVITY (LITERALLY) NOT FILED IN COLUMN SECTION'
         GOTO 1392
      ENDIF
C  DUAL PRICE IS NEXT ITEM WE NEED IN COLUMN SECTION...SEARCH
      DO 3500 LOCP=2,NUMBER-2
        IF( MPSNAM(LOCP).EQ.'RCOST   ') GOTO 3510
3500  CONTINUE
      PRINT *,' ** DUAL ACTIVITY (RCOST) NOT FILED IN COLUMN SECTION'
      GOTO 1392
C
3510  CONTINUE
C  STATUS SHOULD BE NEXT TO LAST
      IF( MPSNAM(NUMBER-1).NE.'STATUS  ' )THEN
         PRINT *,' ** STATUS (LITERALLY) NOT FILED IN COLUMN SECTION'
         GOTO 1392
      ENDIF
C THE NEXT RECORD CONTAINS THE COLUMN INDICATORS OF THE COLUMNS SECTION
C ...SKIP IT
      READ(TEMFIL,ERR=1301,END=1302)
      LINE = LINE + 1
      CNAME = 'COLUMN'
C
C  ::: LOOP OVER COLUMNS TO READ THEIR RECORDS :::
      DO 3800 I=1,NCOLS
         READ(TEMFIL,ERR=1301,END=1302) (MPSNAM(K),K=1,NUMBER)
         LINE = LINE + 1
         RNAME = MPSNAM(NUMBER)
C LOOK UP COLUMN
         CALL GETNUM('COL ',RNAME,COL)
         IF( COL.EQ.0 )GOTO 1340
C READ MPSNAM AS INTERNAL FILE TO GET VALUES
         READ(MPSSTR,'(25A8)',ERR=1301,END=1302) (MPSVAL(K),K=1,NUMBER)
C SET LEVEL AND PRICE
         VX = MPSVAL(1)
         VP = MPSVAL(LOCP)
C DECODE STAT
         STAT = MPSNAM(NUMBER-1)(1:1)
         CALL GRDSTA('COL ',COL,VX,VP,STAT,NFRCOL,*1392)
         CALL GPUTSL(ICSTAT+COL,ICSOLV+COL,STAT,VX,VP,RCODE)
         IF( RCODE.NE.0 )GOTO 1330
3800  CONTINUE
C
      GOTO 9000
C     =========
4000  CONTINUE
      IF( SOLNAM(1:LSOLN).NE.'OSL' )GOTO 5000
C ============= OSL SOLUTION FILE =============
C OSL FILES HAVE 80 CHAR RECORDS (FROM OSLSOLVE.F), SO WE USE FLRDLN
4100  CONTINUE
      CALL FLRDLN(CLIST,TEMFIL,RCODE)
      IF( RCODE )1301,4101,1302
4101  LINE = LINE+1
C
      FIRST = 1
      LAST  = 80
C Header:  ProblemName Opt SolStat
C          RHS     Range     Bound
      CALL FTOKEN(CLIST,FIRST,LAST,RNAME,16,CHAR)
      IF( RNAME.NE.PRBNAM ) PRINT *,
     1  ' Warning: Problem name =',PRBNAM,' but OSL has ',RNAME
      CALL FTOKEN(CLIST,FIRST,LAST,RNAME,8,CHAR)
      CALL GSETOP(RNAME)
      CALL FTOKEN(CLIST,FIRST,LAST,SOLST,16,CHAR)
C Now RHS  Range  Bound
C READ NEW LINE (NEEDED FOR NEW OSLSOLVE FORMAT OF 6-9-93)
      CALL FLRDLN(CLIST,TEMFIL,RCODE)
      IF( RCODE )1301,4102,1302
4102  LINE = LINE+1
      FIRST = 1
      LAST  = 80
      CALL FTOKEN(CLIST,FIRST,LAST,RNAME,16,CHAR)
      IF( RNAME.NE.RHSNAM )THEN
         PRINT *,' ** OSL FILE HAS RHS = ',RNAME
         PRINT *,' **       LP HAS RHS = ',RHSNAM
         GOTO 1390
      ENDIF
      CALL FTOKEN(CLIST,FIRST,LAST,RNAME,16,CHAR)
      IF( RNAME.NE.RNGNAM )THEN
         PRINT *,' ** OSL FILE HAS RANGE SET = ',RNAME
         PRINT *,' **       LP HAS RANGE SET = ',RNGNAM
         GOTO 1390
      ENDIF
      CALL FTOKEN(CLIST,FIRST,LAST,RNAME,16,CHAR)
      IF( RNAME.NE.BNDNAM )THEN
         PRINT *,' ** OSL FILE HAS BOUND SET = ',RNAME
         PRINT *,' **       LP HAS BOUND SET = ',BNDNAM
         GOTO 1390
      ENDIF
      IF( SWMSG )PRINT *,' Names verified'
C     ====================================
C ROWS SECTION (excluding free rows, except objective)
      DO 4500 I=1,NROWS-NRFREE+1
         CALL FLRDLN(CLIST,TEMFIL,RCODE)
         IF( RCODE )1301,4301,1302
4301     LINE = LINE+1
C  RowName Stat  Level  Price
         FIRST = 1
         LAST  = 80
         CALL FTOKEN(CLIST,FIRST,LAST,RNAME,16,CHAR)
         IF( RNAME.EQ.' ')GOTO 1311
         CALL FTOKEN(CLIST,FIRST,LAST,STAT,1,CHAR)
         IF( STAT.EQ.' ')GOTO 1311
         CALL FTOKEN(CLIST,FIRST,LAST,STRVAL,32,CHAR)
         IF( STRVAL.EQ.' ')GOTO 1311
         CALL FC2R(STRVAL,VX,RCODE)
         IF( RCODE.NE.0 )GOTO 1390
         CALL FTOKEN(CLIST,FIRST,LAST,STRVAL,32,CHAR)
         IF( STRVAL.EQ.' ')GOTO 1311
         CALL FC2R(STRVAL,VP,RCODE)
         IF( RCODE.NE.0 )GOTO 1390
C NOW RNAME = NAME
C     STAT  = SOLUTION STATUS
C     VX    = LEVEL
C     VP    = DUAL PRICE
C LOOKUP ROW
         CALL GETNUM('ROW ',RNAME,ROW)
         IF( ROW.EQ.0 )GOTO 1340
C DECODE STATUS (NO NEED TO CALL GRDSTA BECAUSE OSLSOLVE SETS IT)
         IF( STAT.EQ.'F' ) STAT = 'B'
         CALL GPUTSL(IRSTAT+ROW,IRSOLV+ROW,STAT,VX,VP,RCODE)
         IF( RCODE.NE.0 )GOTO 1330
4500  CONTINUE
C
4510  CONTINUE
      IF( SWMSG )PRINT *,' OSL Rows section read'
C     ===========================================
C COLUMNS SECTION
      DO 4900 J=1,NCOLS
         CALL FLRDLN(CLIST,TEMFIL,RCODE)
         IF( RCODE )1301,4701,1302
4701     LINE = LINE+1
C ColumnName  Stat  Level Price
         FIRST = 1
         LAST  = 80
         CALL FTOKEN(CLIST,FIRST,LAST,RNAME,10,CHAR)
         IF( RNAME.EQ.' ')GOTO 1311
         CALL FTOKEN(CLIST,FIRST,LAST,STAT,1,CHAR)
         IF( STAT.EQ.' ')GOTO 1311
         CALL FTOKEN(CLIST,FIRST,LAST,STRVAL,32,CHAR)
         IF( STRVAL.EQ.' ')GOTO 1311
         CALL FC2R(STRVAL,VX,RCODE)
         IF( RCODE.NE.0 )GOTO 1390
         CALL FTOKEN(CLIST,FIRST,LAST,STRVAL,32,CHAR)
         IF( STRVAL.EQ.' ')GOTO 1311
         CALL FC2R(STRVAL,VP,RCODE)
         IF( RCODE.NE.0 )GOTO 1390
C  NOW RNAME = NAME
C      STAT  = SOLUTION STATUS
C      VX    = LEVEL
C      VP    = DUAL PRICE
C  LOOKUP COLUMN
         CALL GETNUM('COL ',RNAME,COL)
         IF( COL.EQ.0 )GOTO 1340
C  DECODE STATUS (MIGHT BE FREE OR FIXED COLUMN)
         CALL GRDSTA('COL ',COL,VX,VP,STAT,NFRCOL,*1392)
C  SET SOLUTION
         CALL GPUTSL(ICSTAT+COL,ICSOLV+COL,STAT,VX,VP,RCODE)
         IF( RCODE.NE.0 )GOTO 1330
4900  CONTINUE
      IF( SWMSG )PRINT *,' OSL Columns section read'
C     ==============================================
      IF( NRFREE.GT.1 )THEN
         CALL GSLFRE(SWMSG,RCODE)
         IF( RCODE.NE.0 )GOTO 1399
      ENDIF
      GOTO 9000
C
5000  CONTINUE
C
C RESERVED FOR OTHER FORMATS
      PRINT *,' ** '//SOLNAM(1:LSOLN)//' NOT RECOGNIZED'
      RCODE = 1
      GOTO 9000
C
C ** ERROR RETURNS
1301  PRINT *,' ** IO ERROR READING SOLUTION FILE'
      GOTO 1390
1302  PRINT *,' ** PREMATURE END OF FILE REACHED'
      IF( SEARCH.NE.' ' )PRINT *,' ...SEARCHING FOR ',SEARCH
      GOTO 1392
1310  CONTINUE
      CALL FSLEN(SEARCH,64,LS)
      PRINT *,' ? DISCREPANCY IN ',SEARCH(:16),'...FILE HAS ',CNAME
      PRINT *,' ...RESIDENT SOLUTION UNCHANGED'
      GOTO 1390
1311  PRINT *,' ** MISSING NAME, STATUS, LEVEL OR PRICE'
      GOTO 1390
1330  PRINT *,' ** ',CNAME(:6),' STATUS OF ',RNAME,' NOT RECOGNIZED'
      GOTO 1390
1340  PRINT *,' ** ',CNAME,' ',RNAME,' NOT FOUND'
C
1390  CONTINUE
      IF( LINE.EQ.0 )GOTO 1392
      BACKSPACE(TEMFIL,ERR=1392)
      READ(TEMFIL,1,ERR=1392)CLIST
      PRINT *,' ...Last line read is:'
      PRINT *,' ',CLIST
1392  PRINT *,' ...'//SOLNAM(1:LSOLN)//' Solution aborted after',
     1         LINE,' lines.'
      RCODE = 2
C
C ** ALL ERROR RETURNS COME HERE (CALLER MUST CALL GSETSL)
1399  SOLNAM = 'logical'
C RCODE COULD = 0, AS FROM BRANCH AT 3032, SO SET TO FORCE ABORT
      IF( RCODE.EQ.0 ) RCODE = 13
C
C     ALL RETURNS COME HERE
C     =====================
9000  CLOSE(TEMFIL)
      IF( RCODE.NE.0 )RETURN
      IF( SWMSG ) PRINT *,' '//SOLNAM(1:LSOLN)//' Solution read in.'
C INITIALIZE ALPHA FILE TO BE EMPTY
      IPIVOT = 0
      IF( NFRCOL.GT.0 )
     1   PRINT *,NFRCOL,' free columns are nonbasic...'//
     2          'one of their bounds was changed = level'
C
C FINALLY, LOOP OVER ROWS AND COLS TO SET SOLUTION TYPE
C CHECK NUMBER OF BASIC COLS AND ROWS = NUMBER OF ROWS (STBASC)
      REMAIN = NROWS
C ASSUME STRICT COMPLEMENTARITY
      STCOMP = 1
C
      DO 9100 I=1,NROWS
         CALL GETSOL('ROW ',I,VX,VP,STAT,STNUM)
         IF( STAT.EQ.'B' .OR. STAT.EQ.'I' )THEN
            REMAIN = REMAIN - 1
            IF( I.EQ.OBJNUM )GOTO 9100
            IF( STAT.EQ.'I' )THEN
               STCOMP = 2
            ELSE
               CALL GETBND('ROW ',I,VL,VU)
               IF( VX.LE.VL .OR. VX.GE.VU )STCOMP = 2
            ENDIF
         ELSE
            IF( ABS(VP).LE.VTOLAB )STCOMP = 2
         ENDIF
9100  CONTINUE
C
      DO 9200 J=1,NCOLS
         CALL GETSOL('COL ',J,VX,VP,STAT,STNUM)
         IF( STAT.EQ.'B' .OR. STAT.EQ.'I' )THEN
            REMAIN = REMAIN - 1
            IF( STAT.EQ.'I' )THEN
               STCOMP = 2
            ELSE
               CALL GETBND('COL ',J,VL,VU)
               IF( VX.LE.VL .OR. VX.GE.VU )STCOMP = 2
            ENDIF
            IF( REMAIN.LT.0 )THEN
               STBASC = 2
               IF( STCOMP.EQ.2 )RETURN
            ENDIF
         ELSE
            IF( ABS(VP).LT.VTOLAB )STCOMP = 2
         ENDIF
9200  CONTINUE
C
      IF( REMAIN.NE.0 )STBASC = 2
      RETURN
C
C ** GRDSOL ENDS HERE
      END
      SUBROUTINE GRDMN1(FILE,LINE,STRING,SWMSG,CLIST,FIRST,LAST,RCODE)
C     =================
      IMPLICIT INTEGER (A-U), DOUBLE PRECISION (Z)
C
      INCLUDE 'DCGETMAT.'
CITSO      INCLUDE (DCGETMAT)
CI$$INSERT DCGETMAT
C
C This reads FILE, incrementing LINE, until STRING is reached
C STRING null means keep reading until non-blank/comment line reached.
C         RCODE = -1 IF EOF REACHED
C                  1 IF IO  ERROR (FATAL)
C                  0 IF ALL IS WELL
C  CLIST = input at LINE (even if RCODE > 0)
C  [ ... STRING  * ... ]
C  1     :    :  :     :...LAST = END OF CLIST
C        :    :  :...FIRST = 1ST NON-BLANK PAST END OF STRING
C        :    :...END OF STRING
C        :...BEGINNING OF STRING
C
      CHARACTER*(*) STRING
      CHARACTER*128 CLIST
      LOGICAL*1     SWMSG
C LOCAL
      CHARACTER*128 STRLCL
C SET FREQUENCY CHECK
CLAHEY       PARAMETER (FREQCH=1 000)
      PARAMETER (FREQCH=10 000)
C ::::::::::::::::::::::::::::: BEGIN ::::::::::::::::::::::::::::::::
1     FORMAT(A128)
      IF( STRING.EQ.' ' )THEN
C CALLER WANTS FIRST NON-BLANK/COMMENT LINE
         FIRST = 1
      ELSE
C SET LENGTH OF SEARCH STRING
         STRLCL = STRING
         CALL FSLEN(STRLCL,128,LSRCH)
      ENDIF
      IF( SWMSG )THEN
         FREQ = FREQCH
      ELSE
         FREQ = 500 000
      ENDIF
      IF( SWDBG )THEN
13       STRLCL = ' '
         PRINT *,FREQ,'=FREQ...Change (blank to accept)? '
         READ(*,'(A2)')STRLCL
         IF( STRLCL.NE.' ' )THEN
            CALL FC2I(STRLCL,8,FREQ,RCODE)
            IF( RCODE.NE.0 )THEN
               PRINT *,' ?',STRLCL(:3),' ABORT (Y/N)? '
               READ(*,'(A1)')STRLCL
               IF( STRLCL.NE.'N' )GOTO 1301
               GOTO 13
            ENDIF
         ENDIF
      ENDIF
10    CONTINUE
        READ(FILE,1,ERR=1301,END=900)CLIST
        LINE = LINE+1
        IF( CLIST.EQ.' ' .OR. CLIST(1:1).EQ.'*' )GOTO 10
C NON-BLANK/COMMENT
        CALL FSLEN(CLIST,128,LAST)
        IF( STRING.EQ.' ' )RETURN
        FREQ = FREQ-1
        IF( FREQ.LE.0 )THEN
           PRINT *,' Searching for ',STRLCL(:LSRCH)
           PRINT *,LINE,':',CLIST(:LAST)
           FREQ = FREQCH
        ENDIF
        IF( LAST.LT.LSRCH )GOTO 10
C COPY INPUT LINE (WILL WANT LENGTH)
        STRLCL = CLIST
        CALL FLOOKF(CLIST,1,LAST,STRING,FIRST)
        IF( FIRST.EQ.0 )THEN
C TRY CONVERTING CASE OF INPUT LINE (USING STRLCL)
           CALL FSCASE(STRLCL,1,LAST)
           CALL FLOOKF(STRLCL,1,LAST,STRING,FIRST)
           IF( FIRST.EQ.0 )GOTO 10
        ENDIF
C STRING FOUND...ADVANCE FIRST TO 1ST NON-BLANK PAST END OF STRING
      FIRST = FIRST + LSRCH
      IF( CLIST(FIRST:).EQ.' ' )RETURN
C SKIP BLANKS
800   CONTINUE
        IF( CLIST(FIRST:FIRST).EQ.' ' )THEN
           FIRST = FIRST+1
           GOTO 800
        ENDIF
      RETURN
C
900   CONTINUE
C EOF
      RCODE = -1
      RETURN
C IO ERROR
1301  PRINT *,' ** IO ERROR READING SOLUTION FILE'
1390  RCODE = 1
      RETURN
C
C ** GRDMN1 ENDS HERE
      END
      SUBROUTINE MPSCHK(MPSNAM,LPNAME,WHAT,*)
C     =================
      IMPLICIT INTEGER (A-U), DOUBLE PRECISION (Z)
C
      INCLUDE 'DCGETMAT.'
CITSO      INCLUDE (DCGETMAT)
CI$$INSERT DCGETMAT
C
C This checks if MPSNAM = LPNAME
C ...Warning issued if disagree, and alternate return.
C
      CHARACTER*(*) MPSNAM,LPNAME,WHAT
C LOCAL
      CHARACTER*16  STR16
C ::::::::::::::::::::::::::: BEGIN :::::::::::::::::::::::::::::
      IF( MPSNAM.EQ.LPNAME .OR. MPSNAM.EQ.'Unknown' .OR.
     1   ( ( MPSNAM.EQ.' ' .OR. MPSNAM.EQ.'none' ) .AND.
     2     ( LPNAME.EQ.' ' .OR. LPNAME.EQ.'none' ) )
     X  ) RETURN
C
      STR16 = WHAT
      CALL FSLEN(STR16,16,L)
      PRINT *,' Warning:  ',STR16(:L),' name in MPS file is ',MPSNAM
      PRINT *,'    ...does not equal LP ',STR16(:L),' name =',LPNAME
      RETURN 1
C
C ** MPSCHK ENDS HERE
      END
