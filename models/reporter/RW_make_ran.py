# -*- coding: utf-8 -*-
"""
Created on Mon Jan 29 09:01:23 2024
Updated on Apr 3, 2024
Updated on Jun 3, 2024

@author: SZO
"""

# This script was created mainly based on EIA-provided ran.documentation.pdf and ftab2.f.
# Mike's read_ran_file.py was used to test the generated RAN file.

# Updates on 2024-03-06:
# Based on our tests with read_ran_file (a RAN file parser), GrafNEM (visualization),
# as well as debugging and FTab code analysis, the following updates were performed.
# (The RAN PDF document either lacks this information or does not provide sufficient details)
#
# 'HD' rows------------
# FTab hardcoded three HD rows for all tables in its generated RAN file. It also assumed
# one RH row for each table. However, when we extracted table format information from the layin,
# we found that tables have either one HD row or a maximum of two HD rows. Almost all tables
# have only one RH row, but a few have no RH row at all.
#
# A function called normalize_format was created to 'normalize' the table format to ensure
# all tables have three HD rows and one RH row.
#
# 'Subject'------------
# The subject represents a short heading for a table in FTab.
# We have written code to retrieve this data from the first HD row at column 'IROWS' and
# populate it to all HD rows.
#
# 'RowStrings'---------
# This string is for graphic spec identified in FTab
# We have written code to add the following piece of info for Data Type 3 rows:
#     'graph_units'  :  layin['Gunits'],
#     'graph_label'  :  layin['GLabel'],
#     'data_type'    :  layin['DaType'],
#     'sector'	     :  layin['Sector'],
#     'energy_source':  layin['Source'],
#     'geography'    :  layin['Geography Override'],
#     'var_units'	 :  layin['Var units'],
#     'expression'   :  layin[ 'Ftab Code for this row']

# Table order:
# The RAN generated by FTab arranges national tables first, followed by regional tables.
# To achieve this table order, we have modified the structure of RW_make_ran. It now iterates
# through the national tables by table number first and then iterates through the regional
# tables by table number.

# Additional info for regional table header:
# The RAN generated by FTab displays regional tables in GrafNEM with a table header that
# includes the region name and number, such as:
#   'Energy Consumption by Sector and Source New England - 01'
# To include this additional regional information, we have modified the code to retrieve
# it from the 'all row csv' data file, and then pass this information to the data sections
# of the regional tables to display it in GrafNEM

# HexEd (https://hexed.it/ is also a useful tool to help validate the generated RAN file.
# Something may be helpful in understanding binary files, such as:
#   little-endian & big-endian
#   commonly used format specifiers in the struct module for packing and unpacking binary data:
#     'b': Signed char (1 byte)
#     'B': Unsigned char (1 byte)
#     'h': Signed short (2 bytes)
#     'H': Unsigned short (2 bytes)
#     'i': Signed int (4 bytes)
#     'I': Unsigned int (4 bytes)
#     'l': Signed long (4 bytes)
#     'L': Unsigned long (4 bytes)
#     'q': Signed long long (8 bytes)
#     'Q': Unsigned long long (8 bytes)
#     'f': Float (4 bytes)
#     'd': Double (8 bytes)
# pylint: disable=invalid-name

import os
import time
from configparser import ConfigParser

import numpy as np
import pandas as pd

from RW_preprocessor import (
    get_table_format_csv,
    get_table_format,
    normalize_format,
    insert_citation,
)
from RW_debug import RAN_logger, log_execution

# Read config.ini
config = ConfigParser()
if os.getcwd()[-8:] != "reporter":
    configpath = os.getcwd() + "\\reporter\\config.ini"
else:
    configpath = os.getcwd() + "\\config.ini"
config.read(configpath)
config.sections()


def write_main_header(file, RMPtr, RMVer, RMLen, RSLen, RTLen, RDLen):
    """
    Writes the main header data to a file at the specified position.

    Parameters
    ----------
    file : file object
        The RAN file object to write the data to.
    RMPtr : int
        The position in the file to write the data.
    RMVer : str
        The RMVer value to be encoded and written.
    RMLen : int
        The Main Header Length.
    RSLen : int
        The Scenario Header Length.
    RTLen : int
        The Table Location Header Length.
    RDLen : int
        The DataRow Location Header Length.

    """
    # Example:
    # {'RMVer': b'001B', 'RMLen': 100, 'RSLen': 400, 'RTLen': 8000, 'RDLen': 750000}
    dt = [
        ("RMVer", "S4"),
        ("RMLen", "i4"),
        ("RSLen", "i4"),
        ("RTLen", "i4"),
        ("RDLen", "i4"),
    ]

    data = np.array([(RMVer.encode(), RMLen, RSLen, RTLen, RDLen)], np.dtype(dt))

    # Write to file
    file.seek(RMPtr)
    data.tofile(file)


def write_scenario_header(file, RSPtr, RSVer, RSFLen, RSFile, RSSLen, RSScen):
    """
    Writes the scenario header data to a file at the specified position.

    Parameters
    ----------
    file : file object
        The file object to write the data to.
    RSPtr : int
        The position in the file to write the data.
    RSVer : str
        The Scenario Header Version.
    RSFLen : int
        The Length of Restart File Name.
    RSFile : str
        The Restart File Name.
    RSSLen : int
        The Length of Scenario Description.
    RSScen : str
        The Scenario Description.

    Returns
    -------
    None
    """

    RAN_logger.info("\n============ write_scenario_header ============")
    # Example:
    # {'RSVer': b'AA01', 'RSFLen': 17, 'RSFile': b'ref2024.1013b.RAN',
    # 'RSSLen': 34, 'RSScen': b'../../ref2024/d101323b/RESTART.unf'}
    dt = [
        ("RSVer", "S4"),
        ("RSFLen", "i2"),
        ("RSFile", "S" + str(RSFLen)),
        ("RSSLen", "i2"),
        ("RSScen", "S" + str(RSSLen)),
    ]

    data = np.array([(RSVer, RSFLen, RSFile, RSSLen, RSScen)], np.dtype(dt))

    # Write to file
    file.seek(RSPtr)
    data.tofile(file)

    return


def write_table_location_header(
    file, RTPtr, RDPtr, RGPtr, RTKey, RTTRow, RTDRow, RTDLoc, RTILoc, table_info
):
    """
    Writes the table location header data to a file at the specified position.

    Parameters
    ----------
    file : file object
        The file object to write the data to.
    RTPtr : int
        Byte pointer to Table Location Header starting from 500.
    RDPtr : int
        Byte pointer to DataRow Location Header starting from 8500.
    RGPtr : int
        Byte pointer to pointer to Data Section starting from 758500
    RTKey : str
        The Table Keyword - (6-byte string).
    RTTRow : int
        The Number of All Rows.
    RTDRow : int
        The Number of Data Rows.
    RTDLoc : int
        The File Pointer to First Instance of This Table in the Data Section.
    RTILoc : int
        The File Pointer to First Instance of This Table in the DataRow Location Header.
    table_info : pandas DataFrame
        The table information data.

    Returns
    -------
    int
        The updated position in the file after writing the data.
    """

    dt_table_location_header = [
        ("RTKey", "S6"),
        ("RTTRow", "i2"),
        ("RTDRow", "i2"),
        ("RTDLoc", "i4"),
        ("RTILoc", "i4"),
    ]

    RTTRow = table_info[table_info["CM"] == "RL"].shape[0]
    RTDRow = table_info[table_info["VarNam2"] != ""].shape[0]
    RTDLoc = RGPtr
    RTILoc = RDPtr

    # TODO: double check if ftab/ran has a bug?
    # The Data Section starts at 758500 but RAN filled RTDLoc with 758501
    # The LableRow Location Header starts at 8500 but RAN filled 8501 ?
    data = np.array(
        [
            (
                RTKey,
                RTTRow,
                RTDRow,
                RTDLoc + 1,  # why add 1 - see comments above
                RTILoc + 1,  # why add 1 - see comments above
            )
        ],
        np.dtype(dt_table_location_header),
    )

    # Write to file
    file.seek(RTPtr)
    data.tofile(file)

    # Update pointer to Table Location Header
    RTPtr += data.nbytes

    return RTPtr


def write_table_row_location_header(file, RDPtr, RDKey, RDLoc):
    """
    Writes the table row location header data to a file at the specified position.

    Parameters
    ----------
    file : file object
        The file object to write the data to.
    RDPtr : int
        The pointer to DataRow Location Header starting from 8500.
    RDKey : str
        The DataRow Keyword - (6-byte string).
    RDLoc : int
        The File Pointer to Data Row 'Record' in the Data Section.

    Returns
    -------
    int
    The updated position in the file after writing the data.
    """
    dt = [("RDKey", "S16"), ("RDLoc", "i4")]

    # Prepare data
    data = np.array([(RDKey, RDLoc)], np.dtype(dt))

    file.seek(RDPtr)
    data.tofile(file)

    # Update pointer
    RDPtr += 16 + 4

    return RDPtr


def write_datatype_1(fmt_row, RGTNum, RGTKey, RGTAct, RGTReg, region_info):
    """
    Processes HD data rows of DataType 1 and returns the numpy array to be written to file.

    Parameters
    ----------
    fmt_row : pandas Series
        Row of the layin file to be processed
    RGTNum : 2-byte integer
        Table Sequence Number for all tables, including regions.
    RGTKey : 6-byte string
        Table Keyword - unique table keyword.
    RGTAct : 2-byte integer
        Table Actual Number - All regional tables have the same actual number.
    RGTReg : 2-byte integer
        Table Region Number - If this is a table that is one of several regions,
        then this contains the region number. Non-regional tables will have a zero value
        NOTE: There are different region schemes with different values.
    RGTTyp : 2-byte integer
        Text Type - This indicates the type of text that is included in this record.
        There are currently 4 types from 1 to 4, corresponding to the previous RAN version.
        ex. 1 indicates the main title.
    region_info : str
        Additional information for regional tables.

    Notes
    -----
    pdf proposes max of 4 HD (RGTTyp), but layin only found max 2 HD + 1RH
    ftab also implemented 3 HD (RGTTyp = 1, 2, 3) + 1RH (RGTTyp = 4).
    HD comes with 'Subject' while RH doesen't

    'Subject' (short heading for this table) was not specified in the pdf, but implemented in ftab
    """
    if fmt_row["CM"] != "HD":
        return
    if fmt_row["Level"] > 1:
        region_info = ""
    RGText = fmt_row["Label"] + region_info
    RGTLen = len(RGText)

    # Get Subject: ex.  table1('SUP'): 'Total Energy'
    Subject = fmt_row["IROWS"]
    LenSubject = len(Subject)

    # Define the dtype for DataType 1
    dt = [
        ("RGType", "i2"),
        ("RGSTyp", "i2"),
        ("RGLRem", "i2"),
        ("RGTNum", "i2"),
        ("RGTKey", "S6"),
        ("RGTAct", "i2"),
        ("RGTReg", "i2"),
        ("RGTTyp", "i2"),
        ("RGForm", "S6"),
        ("RGTLen", "i2"),
        ("RGText", f"S{RGTLen}"),
        ("LenSubject", "i2"),
        ("Subject", f"S{LenSubject}"),
    ]

    # Assign values to variables
    myRGType = 1  # Record Type 1
    myRGSTyp = 1  # has been included to provide flexibility to RAN file, but is currently not being used
    myRGLRem = 2 + 6 + 2 + 2 + 2 + 6 + 2 + RGTLen + 2 + LenSubject
    myRGTNum = RGTNum
    myRGTKey = RGTKey
    myRGTAct = RGTAct
    myRGTReg = RGTReg
    myRGTTyp = fmt_row["Level"]  # ftab has level 1,2,3, layin has only 1, 2
    myRGForm = " " * 6  # blank for Type 1 and 4 in f code
    myRGTLen = RGTLen
    myRGText = RGText
    myLenSubject = LenSubject
    mySubject = Subject

    # Prepare the data for the structured array
    data = np.array(
        [
            (
                myRGType,
                myRGSTyp,
                myRGLRem,
                myRGTNum,
                myRGTKey,
                myRGTAct,
                myRGTReg,
                myRGTTyp,
                myRGForm,
                myRGTLen,
                myRGText,
                myLenSubject,
                mySubject,
            )
        ],
        np.dtype(dt),
    )
    return data


def write_datatype_1_RH(fmt_row, RGTNum, RGTKey, RGTAct, RGTReg):
    """
    Writes RH data rows of DataType 1 to the file and returns the pointer to the next location in the data section.

    Parameters
    ----------
    fmt_row : pandas Series
        Row of the layin file to be processed
    RGTNum : 2-byte integer
        Table Sequence Number for all tables (including regions).
    RGTKey : 6-byte string
        Unique table keyword
    RGTAct : 2-bye integer
        Table Actual Number - all regional tables have the same actual number).
    RGTReg : 2-byte integer
        Table Region Number - If this is a table that is one of several regions,
        then this contains the region number (note that there are different region schemes).
        If this is not a table that is one of several regions, this number will be 0.

    Note
    ----
        pdf proposes max of 4 HD (RGTTyp), but layin only found 2 HD + 1RH
        ftab also implemented 3 HD (RGTTyp = 1, 2, 3) + 1RH (RGTTyp = 4).

        HD comes with 'Subject' while RH doesen't

    """
    if fmt_row["CM"] != "RH":
        return
    RGText = fmt_row["Label"]
    RGTLen = len(RGText)

    # Define the dtype for DataType 1
    dt = [
        ("RGType", "i2"),
        ("RGSTyp", "i2"),
        ("RGLRem", "i2"),
        ("RGTNum", "i2"),
        ("RGTKey", "S6"),
        ("RGTAct", "i2"),
        ("RGTReg", "i2"),
        ("RGTTyp", "i2"),
        ("RGForm", "S6"),
        ("RGTLen", "i2"),
        ("RGText", f"S{RGTLen}"),
    ]

    # Assign values to variables
    myRGType = 1  # Record Type 1
    myRGSTyp = 1  # has been included to provide flexibility to RAN file, but is currently not being used
    myRGLRem = 2 + 6 + 2 + 2 + 2 + 6 + 2 + RGTLen  # + LenSubject
    myRGTNum = RGTNum
    myRGTKey = RGTKey
    myRGTAct = RGTAct
    myRGTReg = RGTReg
    myRGTTyp = fmt_row["Level"]  # ftab has level 1,2,3, layin has only 1, 2
    myRGForm = " " * 6  # blank for Type 1 and 4 in f code
    myRGTLen = RGTLen
    myRGText = RGText
    # mySubject = Subject

    # Prepare the data for the structured array
    data = np.array(
        [
            (
                myRGType,
                myRGSTyp,
                myRGLRem,
                myRGTNum,
                myRGTKey,
                myRGTAct,
                myRGTReg,
                myRGTTyp,
                myRGForm,  # blank for Type 1 and 4 in f code
                myRGTLen,
                myRGText,
                # mySubject,
            )
        ],
        np.dtype(dt),
    )

    return data


def write_datatype_2(fmt_row, RGTNum, RGTKey):
    """
    Writes 'Floating' Label, Other Text rows of DataType 2 to the file and returns the pointer to the next location in the data section.

    Parameters
    ----------
    RGTNum : 2-byte integer
        Table Sequence Number for all tables (including regions).
    RGTKey : 6-byte string
        Unique table keyword
    """
    if fmt_row["CM"] != "RL" or fmt_row["VarNam2"] != "":
        return
    RGText = fmt_row["Label"]
    RGTLen = len(RGText)

    # Create the dtype for DataType 2
    dt = [
        ("RGType", "i2"),
        ("RGSTyp", "i2"),
        ("RGLRem", "i2"),
        ("RGTNum", "i2"),
        ("RGTKey", "S6"),
        ("RGRNum", "i2"),
        ("RGRKey", "S16"),
        ("RGTTyp", "i2"),
        ("RGForm", "S6"),
        ("RGTLen", "i2"),
        ("RGText", f"S{RGTLen}"),
    ]

    # Assign values to variables
    myRGType = 2
    myRGSTyp = 1
    # myRGLRem = 3*2 + 2 + 6 + 2 + 16 + 2 + 6 + 2 + RGTLen
    myRGLRem = 2 + 6 + 2 + 16 + 2 + 6 + 2 + RGTLen
    myRGTNum = RGTNum
    myRGTKey = RGTKey
    myRGRNum = fmt_row["RowNum"]
    myRGRKey = fmt_row["VarNam2"]
    myRGTTyp = 1
    myRGForm = fmt_row["DRForm"]
    myRGTLen = RGTLen
    myRGText = RGText

    # Prepare the data for the structured array
    data = np.array(
        [
            (
                myRGType,
                myRGSTyp,
                myRGLRem,
                myRGTNum,
                myRGTKey,
                myRGRNum,
                myRGRKey,
                myRGTTyp,
                myRGForm,
                myRGTLen,
                myRGText,
            )
        ],
        np.dtype(dt),
    )
    return data


def write_datatype_3(fmt_row, df_data, RGTNum, RGTKey, first_year, last_year):
    """
    Writes Data along with Label rows of DataType 3 to the file and returns the pointer to the next location in the data section.

    Parameters
    ----------
    fmt_row : pandas Series
        Row of the layin file to be processed
    RGTNum : 2-byte integer
        Table Sequence Number for all tables (including regions).
    RGTKey : 6-byte string
        Unique table keyword
    RGTAct : 2-bye integer
        Table Actual Number - all regional tables have the same actual number).
    RGTReg : 2-byte integer
        Table Region Number - If this is a table that is one of several regions,
        then this contains the region number (note that there are different region schemes).
        If this is not a table that is one of several regions, this number will be 0.
    first_year : int
        First year of the data item, ex. 1990.
    first_year : int
        First year of the data item, ex. 2050.

    Note
    ----
    RowStrings (graphy spec) was not specified in the pdf but implemented in ftab
    Each string needs a 2 bytes integer (RSLeni) before to specify its length.

    """
    if fmt_row["CM"] != "RL" or fmt_row["VarNam2"] == "":
        return
    try:
        data_row = df_data.loc[(slice(None), int(fmt_row["RowNum"]), slice(None)), :]
    except KeyError:
        return

    RGText = fmt_row["Label"]
    RGTLen = len(RGText)
    RGDFYr = first_year  # 1990
    RGDLYr = last_year  # 2050

    # Get graph strings
    row_strings = {
        "graph_units": fmt_row["Gunits"],
        "graph_label": fmt_row["GLabel"],
        "data_type": fmt_row["DaType"],
        "sector": fmt_row["Sector"],
        "energy_source": fmt_row["Source"],
        "geography": fmt_row["Geography Override"],
        "var_units": fmt_row["Var units"],
        "expression": fmt_row["Expression"],
    }

    # Calculate the sum of all strings
    len_row_strings_sum = sum(len(value) for value in row_strings.values())

    dt = [
        ("RGType", "i2"),
        ("RGSTyp", "i2"),
        ("RGLRem", "i2"),
        ("RGTNum", "i2"),
        ("RGTKey", "S6"),
        ("RGRNum", "i2"),
        ("RGRKey", "S16"),
        ("RGTTyp", "i2"),
        ("RGForm", "S6"),
        ("RGTLen", "i2"),
        ("RGText", f"S{RGTLen}"),
        ("RGDTyp", "i2"),
        ("RGDFYr", "i2"),
        ("RGDLYr", "i2"),
        ("RGData", "f4", (RGDLYr - RGDFYr + 1)),
        # ('RGData', f'S{len(GData_str)}'),
        ("RSLen1", "i2"),
        ("graph_units", f'S{len(row_strings["graph_units"])}'),
        ("RSLen2", "i2"),
        ("graph_label", f'S{len(row_strings["graph_label"])}'),
        ("RSLen3", "i2"),
        ("data_type", f'S{len(row_strings["data_type"])}'),
        ("RSLen4", "i2"),
        ("sector", f'S{len(row_strings["sector"])}'),
        ("RSLen5", "i2"),
        ("energy_source", f'S{len(row_strings["energy_source"])}'),
        ("RSLen6", "i2"),
        ("geography", f'S{len(row_strings["geography"])}'),
        ("RSLen7", "i2"),
        ("var_units", f'S{len(row_strings["var_units"])}'),
        ("RSLen8", "i2"),
        ("expression", f'S{len(row_strings["expression"])}'),
    ]

    data = np.array(
        [
            (
                3,  # RGType
                1,  # RGSTyp
                2
                + 6
                + 2
                + 16
                + 2
                + 6
                + 2
                + RGTLen
                + 2
                + 2
                + 2
                + (RGDLYr - RGDFYr + 1) * 4
                + 2 * 8
                + len_row_strings_sum,  # RGLRem
                RGTNum,  # RGTNum
                RGTKey,  # RGTKey
                fmt_row["RowNum"],  # RGRNum
                fmt_row["VarNam2"],  # RGRKey
                1,  # RGTTyp
                fmt_row["DRForm"],  # RGForm
                RGTLen,  # RGTLen
                RGText,  # RGText
                fmt_row["RowFmt"],  # RGDTyp
                RGDFYr,  # RGDFYr
                RGDLYr,  # RGDLYr
                np.array(data_row, dtype=np.float32),  # RGData
                # GData_str,
                len(row_strings["graph_units"]),
                row_strings["graph_units"],
                len(row_strings["graph_label"]),
                row_strings["graph_label"],
                len(row_strings["data_type"]),
                row_strings["data_type"],
                len(row_strings["sector"]),
                row_strings["sector"],
                len(row_strings["energy_source"]),
                row_strings["energy_source"],
                len(row_strings["geography"]),
                row_strings["geography"],
                len(row_strings["var_units"]),
                row_strings["var_units"],
                len(row_strings["expression"]),
                row_strings["expression"],
            )
        ],
        np.dtype(dt),
    )
    return data


def write_datatype_4(fmt_row, RGTNum, RGTKey):
    """
    Writes Data along with Label rows of DataType 3 to the file and returns the pointer to the next location in the data section.

    Parameters
    ----------
    fmt_row : pandas Series
        Row of the layin file to be processed
    RGTNum : 2-byte integer
        Table Sequence Number all tables (including regions).
    RGTKey : 6-byte string
        Unique table keyword

    """
    if fmt_row["CM"] != "FN":  # Avoid processing unnecessary rows
        return
    RGText = fmt_row["Label"]
    RGTLen = len(RGText)

    # Create the dtype for DataType 4
    dt = [
        ("RGType", "i2"),
        ("RGSTyp", "i2"),
        ("RGLRem", "i2"),
        ("RGTNum", "i2"),
        ("RGTKey", "S6"),
        ("RGTTyp", "i2"),
        ("RGForm", "S6"),
        ("RGTLen", "i2"),
        ("RGText", "S{}".format(RGTLen)),
    ]

    # Assign values to variables
    myRGType = 4
    myRGSTyp = 1
    myRGLRem = 2 + 6 + 2 + 6 + 2 + RGTLen
    myRGTNum = RGTNum
    myRGTKey = RGTKey
    myRGTTyp = 1
    myRGForm = " " * 6  # blank for Type 1 and 4 in f code
    myRGTLen = RGTLen
    myRGText = RGText

    # Prepare the data for the structured array
    data = np.array(
        [
            (
                myRGType,
                myRGSTyp,
                myRGLRem,
                myRGTNum,
                myRGTKey,
                myRGTTyp,
                myRGForm,
                myRGTLen,
                myRGText,
            )
        ],
        np.dtype(dt),
    )
    return data


@log_execution(RAN_logger, message="write_table")
def write_table(
    file,
    RTPtr,
    RDPtr,
    RGPtr,
    df_data,
    table_info,
    RGTNum,
    RGTReg,
    RGTKey,
    RGTAct,
    first_year,
    last_year,
):
    """
    Writes different types of data rows to a file based on the formatting information provided in a DataFrame.

    Parameters
    ----------
    file : str
        The file to write the data rows to.
    RTPtr : int
        Byte pointer to Table Location Header starting from 500.
    RDPtr : int
        Byte pointer to the DataRow Location Header starting from 8500.
    RGPtr : int
        Byte pointer to pointer to Data Section starting from 758500.
    df_data : pd.DataFrame
        The DataFrame containing the data to be written.
    table_info : pd.DataFrame
        The DataFrame containing the formatting information for each row.
    RGTNum : int
        Table Sequence Number - (2-byte integer, RGTNum) - This is the table number as a sequence number
        for all tables (including regions).
    RGTReg : int
        Table Region Number - (2-byte integer, RGTReg) - If this is a table that is one of several
        regions, then this contains the region number (note that there are different region schemes). If this
        is not a table that is one of several regions, this number will be 0..
    RGTKey : str
        Table Keyword - (6-byte string, RGTKey) - This is the unique table keyword.
    RGTAct : int
        Table Actual Number - (2-byte integer, RGTAct) - This is the actual table number (for example
        all regional tables have the same actual number)..

    Returns
    -------
    int
        Updated byte pointer to Byte pointer to DataRow Location Header.
    int
        Byte pointer to pointer to Data Section.
    """

    RAN_logger.info("\n============ write_table ============")

    # Get table number and region name
    region_num = int(df_data.index.get_level_values("RegionNum")[0])
    region_name = df_data["Geogr"].iloc[0]

    # Write log
    RAN_logger.info("TableNumber: %s", RGTAct)
    RAN_logger.info("region_num: %s", region_num)
    RAN_logger.info("region_name: %s", region_name)

    if region_num == 0:
        # National tables
        region_info = ""
    else:
        # Get region info for table header, e.g.,
        #   'Energy Consumption by Sector and Source New England - 01'
        region_info = f" {region_name} - {str(region_num).zfill(2)}"

    # Get digital columns only
    RGDFYr = first_year  # 1990
    RGDLYr = last_year  # 2050

    df_data = df_data[
        [str(num) for num in range(RGDFYr, RGDLYr + 1)]
    ]  # if read all row csv.csv

    # Data Sections - At the current time there are four types of data “records” defined in this version of the
    # RAN file, all of which can have varying lengths. These are all arranged in a similar fashion and all start
    # with exactly the same three data items consisting of:
    #     * Record Type - (2-byte integer, RGType) - This indicates that this “record” is one of several fixed
    # types (currently four) and is formatted for that type and if it is to be read must be read in that type's
    # format.
    #     * Record Sub-Type - (2-byte integer, RGSTyp) - This indicates a record sub-type. This has been
    # included to provide flexibility to the RAN file, but is currently not being used.
    #     *Remaining Length - (2-byte integer, RGLRem) - This indicates how may bytes of data are included
    # in the rest of this record. In other words, the next record begins immediately after that number of
    # bytes. This provides a way of reading past this record if it is determined that it is a type that is of no
    # interest.
    # """
    # Row identifiers of layin:
    # CM = ['HD', 'RH', 'RL', 'RN', 'TF', 'TN', 'FN']

    # Data Type 1 - Titles, Labels, Other Text - General cateogory currently
    # being used like the previous RAN file where it contains the 4 levels of headings.
    # But layin has max of 3 levels (2 HD + 1 RH). We coded following layin
    table_info = table_info.assign(type=0)

    table_info.loc[table_info["CM"] == "HD", "type"] = 1
    table_info.loc[table_info["CM"] == "HD", "data"] = table_info.apply(
        write_datatype_1,
        axis=1,
        args=(RGTNum, RGTKey, RGTAct, RGTReg, region_info),
    )

    # Data Type 1H
    table_info.loc[table_info["CM"] == "RH", "type"] = 1
    table_info.loc[table_info["CM"] == "RH", "data"] = table_info.apply(
        write_datatype_1_RH,
        axis=1,
        args=(RGTNum, RGTKey, RGTAct, RGTReg),
    )

    # Data Type 2 - “Floating” Label, Other Text - This is meant to be a general category, but is
    # actually dictated by the current way in which the FTab and it's layout table do line formatting by
    # Alternative RAN File - November 2004 - Page 10
    # providing non-data rows rather than with formatting codes. This is currently being used like the
    # previous RAN file where it contains the table rows that do not have data.
    table_info.loc[
        (table_info["CM"] == "RL") & (table_info["VarNam2"] == ""), "type"
    ] = 2
    table_info.loc[table_info["type"] == 2, "data"] = table_info.apply(
        write_datatype_2,
        axis=1,
        args=(RGTNum, RGTKey),
    )

    # Data Type 3 - Data along with Label - This is meant to be a general category, but is actually
    # dictated by the current way in which the FTab and it's layout table do line formatting by providing
    # non-data rows rather than with formatting codes. This is currently being used like the previous RAN
    # file where it contains the table rows that do contain data
    table_info.loc[
        (table_info["CM"] == "RL") & (table_info["VarNam2"] != ""), "type"
    ] = 3
    table_info.loc[table_info["type"] == 3, "data"] = table_info.apply(
        write_datatype_3,
        axis=1,
        args=(
            df_data,
            RGTNum,
            RGTKey,
            first_year,
            last_year,
        ),
    )

    # Data Type 4 - Footnotes - This is meant to be a general category, but is actually dictated by the
    # current way in which the FTab and it's layout table do footnotes. There may be several records for
    # each footnote. For general use, they might be reattached into one string. The previous RAN file did
    # not include footnotes.
    table_info.loc[table_info["CM"] == "FN", "type"] = 4
    table_info.loc[table_info["type"] == 4, "data"] = table_info.apply(
        write_datatype_4,
        axis=1,
        args=(
            RGTNum,
            RGTKey,
        ),
    )

    for z in table_info[["data", "type", "VarNam2"]].to_dict("records"):
        if not isinstance(z["data"], np.ndarray):
            continue
        if z["type"] == 3:
            # Write TableRow_Location Header
            RDKey = z["VarNam2"]  # RGRKey
            RDPtr = write_table_row_location_header(file, RDPtr, RDKey, RGPtr)
        file.seek(RGPtr)
        z["data"].tofile(file)
        RGPtr += z["data"].nbytes

    return RDPtr, RGPtr


def write_region(
    file, RTPtr, RDPtr, RGPtr, df_data, table_info, RGTNum, first_year, last_year
):
    """
    Writes the data rows of different tables within a region to a file based on the formatting information provided in a DataFrame.

    Parameters
    ----------
    file : file object
        The file object to write the data to.
    RTPtr : int
        Byte pointer to Table Location Header starting from 500.
    RDPtr : int
        Byte pointer to DataRow Location Header starting from 8500.
    RGPtr : int
        Byte pointer to Data Section starting from 758500.
    df_data : pd.DataFrame
        The DataFrame containing the data to be written.
    table_info : pd.DataFrame
        The DataFrame containing the formatting information for each table.
    RGTNum : int
        Table number.

    Returns
    -------
    int
        Byte pointer to Table Location Header.
    int
        Byte pointer to DataRow Location Header.
    int
        Byte pointer to pointer to Data Section.
    int
        Updated table number.
    """
    # Remove blank table numbers
    table_numbers = list(filter(lambda x: x != "", table_info["TableNumber"].unique()))

    for table_num in table_numbers:
        # Check if data is available - not needed if all 150 tables have been generated
        if table_num in df_data.index.get_level_values("TableNumber").tolist():
            #  Get table info
            my_table_info = table_info.loc[table_info["TableNumber"] == table_num]

            # Get table data
            # Note: the 'all_row_csv' has been multi-indexed (TableNimber, RowNum, RegionNum)
            my_table_data = df_data.loc[(table_num, slice(None), slice(None)), :]

            # Actual table number (1-150)
            RGTAct = my_table_info.loc[my_table_info["CM"] == "RN", "TableNumber"].iloc[
                0
            ]
            RTTRow = my_table_info[my_table_info["CM"] == "RL"].shape[0]
            RTDRow = my_table_info[my_table_info["VarNam2"] != ""].shape[0]
            RTDLoc = RGPtr
            RTILoc = RDPtr

            for region_num in (
                my_table_data.index.get_level_values("RegionNum").unique().tolist()
            ):
                RGTReg = int(region_num)
                # Get region data
                region_data = my_table_data.loc[(table_num, slice(None), region_num), :]
                RGTKey = (
                    my_table_info.loc[my_table_info["CM"] == "RN", "Label"].iloc[0]
                    + "A"
                    + str(RGTReg).zfill(2)
                )
                RTKey = RGTKey

                RGTAct = my_table_info.loc[
                    my_table_info["CM"] == "RN", "TableNumber"
                ].iloc[0]

                # Write Table Location Header
                # {'RTKey': b'SUPA00', 'RTTRow': 59, 'RTDRow': 44, 'RTDLoc': 758501, 'RTILoc': 8501}
                RTPtr = write_table_location_header(
                    file,
                    RTPtr,
                    RDPtr,
                    RGPtr,
                    RTKey,
                    RTTRow,
                    RTDRow,
                    RTDLoc,
                    RTILoc,
                    my_table_info,
                )

                # Write Table Data
                RDPtr, RGPtr = write_table(
                    file,
                    RTPtr,
                    RDPtr,
                    RGPtr,
                    region_data,
                    my_table_info,
                    RGTNum,
                    RGTReg,
                    RGTKey,
                    RGTAct,
                    first_year,
                    last_year,
                )

                # Update total table number
                RGTNum += 1

    return RTPtr, RDPtr, RGPtr, RGTNum


def write_data(
    file, RTPtr, RDPtr, RGPtr, df_data, table_info, first_year, last_year
):  # , RGTNum):
    """
    Writes the data rows of different tables within a region to a file based on the formatting information provided in a DataFrame.

    Parameters
    ----------
    file : file object
        The file object to write the data to.
    RTPtr : int
        Byte pointer to Table Location Header starting from 500.
    RDPtr : int
        Byte pointer to DataRow Location Header starting from 8500.
    RGPtr : int
        Byte pointer to pointer to Data Section starting from 758500.
    df_data : pd.DataFrame
        The DataFrame containing the data to be written.
    table_info : pd.DataFrame
        The DataFrame containing the formatting information for each table.
    RGTNum : int
        Table number.

    Returns
    -------
    int
        Updated byte pointer to the start of the table within the file.
    int
        Updated byte pointer to the start of the data (row).
    int
        Updated byte pointer to the start of the data group.
    int
        Updated table number.
    """
    # Total table number specified at the beginning of the Table Location Header
    RTNum = 0

    # Sequential table number specified in each data type of the data section
    RGTNum = 1
    RTPtr0 = RTPtr

    # Table Location Header pointer - jump over the first 2 bytes (RTNum)
    RTPtr = RTPtr + 2

    # Populate national tables
    df_data_national = df_data.loc[df_data.index.get_level_values("RegionNum") == 0]
    RTPtr, RDPtr, RGPtr, RGTNum = write_region(
        file,
        RTPtr,
        RDPtr,
        RGPtr,
        df_data_national,
        table_info,
        RGTNum,
        first_year,
        last_year,
    )

    # Populate regional tables
    df_data_regional = df_data.loc[df_data.index.get_level_values("RegionNum") != 0]
    RTPtr, RDPtr, RGPtr, RGTNum = write_region(
        file,
        RTPtr,
        RDPtr,
        RGPtr,
        df_data_regional,
        table_info,
        RGTNum,
        first_year,
        last_year,
    )

    # Write RTNum to Table Location Header
    RTNum = RGTNum - 1
    RTNum_data = np.array([RTNum], dtype=np.dtype("i2"))

    file.seek(RTPtr0)
    RTNum_data.tofile(file)

    return RTNum


@log_execution(RAN_logger, message="make_ran")
def make_ran(
    df_data_file_path,
    table_info,
    RSVer,
    RSFile,
    RSScen,
    ScenDate,
    first_year,
    last_year,
    user,
):
    """
    Generates a RAN file based on the table data, table information, RSVer, RSFile, and RSScen.

    Parameters
    ----------
    df_data_file_path : str
        The file path to the 'all row csv' file containing the data for generating RAN.
    table_info : pandas.DataFrame
        Information about the tables.
    RSVer : str
        RSVer value for the scenario header.
    RSFile : str
        RSFile value for the scenario header.
    RSScen : str
        RSScen value for the scenario header.
    ScenDate : str
        The date for the output RAN file.
    first_year : int
        The first year to include in the RAN file.
    last_year : int
        The last year to include in the RAN file.

    """

    RAN_logger.info("\n============ make_ran ============")

    # Ouput file
    if user.outputdir == 'output':
        ran_file_path = os.path.join(os.getcwd(), "output", ScenDate + ".RAN")  #'test.ran')
    else:
        ran_file_path = os.path.join(user.outputdir, ScenDate + ".RAN")  #'test.ran')

    # Set the Main Header data
    RMVer = "001B"
    RMLen = 100
    RSLen = 400
    RTLen = 8000
    RDLen = 750000

    # Init Pointers inferred (byte)
    RMPtr = 0  # Python is zero-based
    RSPtr = RMPtr + RMLen  # pointer to Scenario Header starting from 100
    RTPtr = RSPtr + RSLen  # pointer to Table Location Header starting from 500
    RDPtr = RTPtr + RTLen  # pointer to DataRow Location Header starting from 8500
    RGPtr = RDPtr + RDLen  # pointer to Data Section starting from 758500

    # Set Scenario Header data
    RSFLen = len(RSFile)
    RSSLen = len(RSScen)

    # Load data
    df_data = pd.read_csv(df_data_file_path)
    df_data.set_index(["TableNumber", "RowNum", "RegionNum"], inplace=True)

    # Replace infinite values with 0
    df_data = df_data.replace([np.inf, -np.inf], np.nan)
    df_data = df_data.fillna(0)

    # Begin writing RAN file
    with open(ran_file_path, "wb") as file:

        # Write the Main Header
        write_main_header(file, RMPtr, RMVer, RMLen, RSLen, RTLen, RDLen)

        # Write the Scenaro Header
        write_scenario_header(file, RSPtr, RSVer, RSFLen, RSFile, RSSLen, RSScen)

        # Write Data Section which contains:
        # - Write Table Location Header
        # - Write TableRow Location Header
        write_data(
            file, RTPtr, RDPtr, RGPtr, df_data, table_info, first_year, last_year
        )


if __name__ == "__main__":

    print("Start running RW_make_ran. It may take one minute ...")
    print("For execution details, please see RAN_log")
    start = time.process_time()

    # Set Scenario Header data
    RSVer = "AA01"
    RSFile = "restart.npz"
    dirname = os.path.dirname(os.getcwd())
    RSScen = os.path.join(dirname, "restart.unf")
    ScenDate = f"ref2025.{os.path.basename(dirname)}"

    first_year = 1990
    last_year = 2050

    # Get table info from layin
    format_path = os.path.join(os.getcwd(), "input", "layin.xls")
    format_path_csv = os.path.join(os.getcwd(), "input", "layin.csv")
    citation_path = os.path.join(os.getcwd(), "input", "citation.txt")

    layin_ver = "csv"  # csv OR xls

    # Get table format: switch between layin.csv and layin.xls
    if layin_ver == "csv":
        table_info = get_table_format_csv(format_path_csv)
    else:
        table_info = get_table_format(format_path)

    # Update df_format to get three HD rows, and one RH row
    df_format = normalize_format(table_info, HD_num=3)

    # Convert 'level' column to integer
    df_format["Level"] = (
        pd.to_numeric(df_format["Level"], errors="coerce").astype(float).astype("Int64")
    )

    # Insert citations
    df_format = insert_citation(df_format, citation_path)

    # Get data df
    if user.outputdir == 'output':
        df_data_file_path = os.path.join(os.getcwd(), "output", "NEMSref2025.unif.api.csv")
    else:
        df_data_file_path = os.path.join(user.outputdir, "NEMSref2025.unif.api.csv")

    make_ran(
        df_data_file_path,
        table_info,
        RSVer,
        RSFile,
        RSScen,
        ScenDate,
        first_year,
        last_year,
        user ,
    )

    elapsed = time.process_time() - start
    print(f"Seconds to run RW_Make_ran: {elapsed: .2f}")
    print("Completed RW_make_ran!")
