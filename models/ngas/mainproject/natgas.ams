## ams_version=1.0

Model Main_NGTDM {
	Comment: {
		"Sections are commented to include which programmer is responsible for the code within that section.
		
		YDA:  Elena Dandurova 	YELENA.V.DANDUROVA@leidos.com
		KDL:  Katie Dyl		Kathryn.Dyl@eia.gov"
	}
	Procedure NEMS_Monitor {
		Body: {
			           EnterNEMSMonitor := CurrentToString("%c%y-%m-%d %H:%M:%S") + " I'm Alive! AIMMS entered NEMS_Monitor. Model Year, Cycle, or Iteration info not yet known. AIMMS has not yet read monitor.in.txt or GDS";
				   put ngStatusFile;
				   put EnterNEMSMonitor;
				   putclose;
			
			           ! the initial loaddata is required because this procedure is invoked from the command line.
			           ! Aimms doesn't load case files automatically, as specified in the project settings, when a procedure is invoked from 
			           ! the command line.   
			           !LoadData("restart"); 
			           MainInitialization;
			
			           Read_Runtime_Parameters;  ! read here in case "keepopen" setting needed by this procedure. currently not used.
			
			
			           ! the following allows the aimms project to be kept open (when keepopen=1) and to later Quit at direction of NEMS,
			           ! or to run and exit immediately. There is sometimes a delay with the Quit option due to error trapping, so NEMS is set up to wait for 
			           ! an action message of "Exited" written by the MainTermination procedure right before aimms exits.
			           CountSleep := 0;
			           ! count sleep/wake cycles while waiting for direction from nems via sAction in the message file, monitor.in.txt
			           while ( CountSleep <= 2000 ) do
			              if fileexists(sMessageInFile) then
			              ! read sAction, current model year, and current iteration from sMessageInFile
			                sAction:=" ";
			                read from file sMessageInFile in merge mode;
			
			                ReadMonitorInStatus := CurrentToString("%c%y-%m-%d %H:%M:%S") + " Reading monitor.in.txt. sAction is " + sAction; 
			                put ngStatusFile;
			                put ReadMonitorInStatus;
			                putclose;
			
			              else
			                put "the NEMS message file not found, CountSleep=",CountSleep," \n ";
			              endif;
			              if sAction = "MainExecution" then
			                sAction:="executing";    ! Action message to tell NEMS I'm executing
			                write sAction to file NEMSMessageOutFile in replace mode;  
			                ExecutingMonitorOutStatus := CurrentToString("%c%y-%m-%d %H:%M:%S") + " AIMMS sees MainExecution in monitor.in. Writing 'executing' to sAction";
			                put ngStatusFile;
			                put ExecutingMonitorOutStatus;
			                putclose;
			
			
			                dialogProgress(""); ! remove progress dialog
			                sStatusMessage := formatstring("Invoking MainExecution for %s",ncntrl_curcalyr('1')) + 
			                                  formatstring(", iteration %s",ncntrl_curitr('1')) +
			                                  formatstring(", reporting loop indicator=%s",ncntrl_ncrl('1'));
			                put sStatusMessage;
			
			                MiddleNEMSMonitor := CurrentToString("%c%y-%m-%d %H:%M:%S") + " I'm Alive! AIMMS in NEMS_Monitor and has read monitor.in.txt - " +
					formatstring("iteration %>02i, ",ncntrl_curitr(1)) +
					formatstring("%i, ",ncntrl_curcalyr(1));
					put ngStatusFile;
					put MiddleNEMSMonitor;
					putclose;
			
			                if ParquetReadSwitch = 1 then
			                	ReadGlobalDataFromNEMS_parquet;
			                else
			                ReadGlobalDataFromNEMS; ! read globaldatatoAIMMS_yyyy_ii.txt where yyyy is ncntrl_curcalyr(1) and ii is ncntrl_curitr(1)
			                endif;
			                !Initialize ModelYear
			ModelYear := StringToElement(Years_, FormatString("%n", NCNTRL_CURCALYR(1)));
			MonthInPeriod(tmon) := Element( ModelYearMonths_, Ord(tmon));
			                MainExecution;
			                sAction:=formatstring("Completed %s,",ncntrl_curcalyr('1')) + 
			                         formatstring("iteration %s ",ncntrl_curitr('1')) ;    ! Action message to tell NEMS I'v completed this year, iteration
			                write sAction to file NEMSMessageOutFile in replace mode;  
			
			                CompletedMonitorOutStatus := CurrentToString("%c%y-%m-%d %H:%M:%S") + " AIMMS completed MainExeuction. Writing 'Completed' to monitor.out";
			                put ngStatusFile;
					put CompletedMonitorOutStatus;
					putclose;
			
			                CountSleep:=0;   
			                sStatusMessage := "Monitoring NEMS message file("+sMessageInFile+") for "+formatstring("%s",CountSleep/2)+" seconds. Hit Ctrl+Shift+S to Stop this monitoring\n";
			                put sStatusMessage;
			                Delay(1);    ! give nems a chance to pick up status and create new monitor.in.txt file                
			              elseif sAction = "Quit" then ! NEMS says to exit aimms
			                CountSleep:=2000;
			              else
			                sStatusMessage := "Monitoring NEMS message file("+sMessageInFile+") for "+formatstring("%s",CountSleep)+" seconds. Hit Ctrl+Shift+S to Stop this monitoring\n";
			                Delay(.5);                  
			              endif;
			              dialogProgress(sStatusMessage,round(100*CountSleep/2000));
			              CountSleep += 1;
			
			           endwhile;
			           if CountSleep>=2001 then
			             put "Quit directive found in monitor.in.txt. Exiting AIMMS";
			           else
			             put "Wait time exceeded. Exiting Aimms";
			           endif;
			
			                ExitNEMSMonitor := CurrentToString("%c%y-%m-%d %H:%M:%S") +  " I'm Alive! AIMMS is preparing to exit NEMS_Monitor and begin Main_Termination  - "  + FormatString("Cycle %i, ", CYCLEINFO_CURIRUN(1)) +
					formatstring("iteration %>02i, ",ncntrl_curitr(1)) +
					formatstring("%i, ",ncntrl_curcalyr(1));
					put ngStatusFile;
					put ExitNEMSMonitor;
					putclose;
			
			           exitAimms; ! causes MainTermination to run and for aimms to exit. MainTermination sends message "Exited" back to nems.
		}
		Comment: {
			"For KEEPOPEN=1 option, This routines cause AIMMS to sleep and periodically wake to check a message input file from NEMS. If the file
			is found, AIMMS reads it and re-invokes mainexecution if indicated, or closes the project.  
			After invoking mainExecution, it writes an output message file indicating completion.
			This routine then continues the sleep-wait cycle."
		}
	}
	Procedure MainInitialization {
		Body: {
			! This is used to initialize first model year and initial horizon-calendar link to use in pages
			ModelYear := FirstModelYear;
			!Might need to remove these
			!FirstPeriodInPlanningInterval := 'period-001';
			MonthInPeriod(tmon) := Element( ModelYearMonths_, Ord(tmon));
			!Initialize regions and other sets; read and transfer historical data
			!HQPYear:=FirstHQPYear;
			
			read from file "input\\ngparquetswitch.txt" in merge mode;
			
			SetSolverOptions;
		}
		Comment: {
			"This procedure is used for MainExecution_Standalone.
			All NEMS restart variables are initialized with the startup case \"restart.data\".
			All data loading and initialization is done in either MainExecution (for integrated NEMS runs)or MaicExecution_Standalone."
		}
	}
	Procedure MainExecution {
		Body: {
			EnterMainExecution := CurrentToString("%c%y-%m-%d %H:%M:%S") + " I'm Alive! AIMMS entered MainExecution - " + FormatString("Cycle %i, ", CYCLEINFO_CURIRUN(1)) +
			formatstring("iteration %>02i, ",ncntrl_curitr(1)) +
			formatstring("%i, ",ncntrl_curcalyr(1));
			put ngStatusFile;
			put EnterMainExecution;
			putclose;
			
			!Read in first model year (user-defined)
			Read_FirstModelYear;
			!Initialize ModelYear
			ModelYear := StringToElement(Years_, FormatString("%n", NCNTRL_CURCALYR(1)));
			
			!Save updates to startup case "restart.data"
			SaveGDS("restart");
			
			!Save case with original restart file variables for off-line testing
			if (InitialRestartFile_Switch =1) then	
				if ( ncntrl_curcalyr(1)=Val(FirstModelYear) and ncntrl_ncrl(1)=1 ) then
					SaveGDS("restart_initial");
					InitialRestartFile_Switch := 0;
				endif;
			endif;
			
			
			!Initialize NGTDM data depending on year
			!This will need to be changed depending on year difference between first year NEMS calls NGTDM, LastHistoricalYear, and FirstModelYear
			if KEEPOPEN = 0 then
				if (ModelYear >= FirstModelYear) and (ncntrl_ncrl(1) = 1) then
					LoadData( "ngmm_fcrl");
				elseif (ModelYear >= FirstModelYear) and (ncntrl_ncrl(1) <> 1) then
					if ModelYear = FirstModelYear then
						FirstYearInitialization;
					else
						!Load NGMM identifiers from previous year
						!LoadData( FormatString("ngmm_only%e", ModelYear-1));
						LoadData( "ngmm_only");
					endif;
				endif;
			elseif ( ModelYear = FirstModelYear and ncntrl_curitr(1)=1 ) then
				FirstYearInitialization;
			endif;
			
			display ncntrl_curcalyr ;
			
			!Run NGTDM Model
			
			if (ModelYear >= FirstModelYear) and (ncntrl_ncrl(1) <> 1) then
				NGMM;
				Write_to_NEMS;		! Assign values to NEMS transfer parameters
			endif;
			
			!If the reporting switch in NEMS is on, save NGTDM-only variables to load upon AIMMS restart
			!For all other invocations, save the data into a year-iteration-specific data file for debugging.  User selects
			! menu "Data..Load Case...As Active.." and selects one of the "ngtdm_year_it.data" files.
			!if (ModelYear >= FirstModelYear and ncntrl_ncrl(1)=1 ) then
			
			 if (ModelYear >= FirstModelYear and ncntrl_ncrl(1)=1 ) then
			    	!Only run LNG export capacity expansion if it's the last NEMS iteration, we are determining builds in model, and facility will be fully built before last model year
			   	if (LNG_FixedExports_Switch = 0) and ((NEMSmap_XYear(NEMSmap_MNXYRS(ModelYear))  + LNG_YrsUntilBuild) < (LastModelYear-LNG_PhaseInYrs)) then 
			
					NEMS_Report_Loop;
					Write_to_NEMS_LNGExports;
			   	endif;
				if (ModelYear < LastModelYear) then
					PrepareDataForNextRoll;
			
			  		!SaveNGTDM( FormatString("ngmm_only%e", ModelYear));
			 		if  KEEPOPEN = 0 then SaveNGTDM( "ngmm_only"); endif;
			
			  	else
			  		!save complete case file
			  		Initialize_EMM;
			  		SaveAll( FormatString("ngmm%e_%i", ModelYear,ncntrl_curitr(1)));
			  		if ( SaveEachCycle_Switch) then	
						SaveAll( FormatString("cycle%i", CYCLEINFO_CURIRUN(1)));
			                endif;
			  	endif;
			  	!write STEO factors
				if ModelYear = LastSTEOPhaseOutYear then STEOFactors_Write; endif;
			endif;
			
			if (ModelYear >= FirstModelYear and ncntrl_fcrl(1)=1 ) then
				SaveNGTDM( "ngmm_fcrl");
			endif;
			
			
			!SaveAll( FormatString("ngmm%e_%i", ModelYear,ncntrl_curitr(1)));
			
			if ( SaveEachIteration_Switch=1) then	
				SaveAll( FormatString("ngmm%e_%i", ModelYear,ncntrl_curitr(1)));
			endif;
			            ! output the global variables (as previously set up in nggetvars.txt) to nems in a text file
			            if (ParquetWriteSwitch = 1) then
			            	SendGlobalDatatoNEMS_parquet;
			            else
			                SendGlobalDataToNEMS;
			            endif;
			
			ExitMainExecution := CurrentToString("%c%y-%m-%d %H:%M:%S") + " I'm Alive! AIMMS exiting MainExecution - " + FormatString("Cycle %i, ", CYCLEINFO_CURIRUN(1)) +
			formatstring("iteration %>02i, ",ncntrl_curitr(1)) +
			formatstring("%i, ",ncntrl_curcalyr(1));
			put ngStatusFile;
			put ExitMainExecution;
			putclose;
		}
		Comment: {
			"MainExecution is the procedure through which NEMS runs NGTDM.
			It should not be invoked when running NGTDM in AIMMS in \"standalone\" mode, including when analyzing NEMS results/during model development.
			To run NGTDM from AIMMS, run procedure \"MainExecution_Standalone.\""
		}
	}
	Procedure MainExecution_Standalone {
		Body: {
			ProfilerStart;
			empty Cleared_Identifiers_;
			Read_FirstModelYear;
			!LoadData("restart_initial");
			LoadData("restart");
			NCNTRL_CURIYR(1) := NEMSmap_MNUMYR(FirstModelYear);
			Read_Runtime_Parameters;
			AIMMS_Standalone_Switch :=1;
			CalibrationMode:=0;
			
			InitializeFirstModelYear;
			
			FirstYearInitialization;
			
			repeat
				NGMM;
				Write_to_NEMS;
				Write_to_NEMS_LNGExports;
				break when (LastMonthInPlanningInterval = LastModelMonth);
				PrepareDataForNextRoll;
				RollToNextYear;
				NCNTRL_CURIYR(1)+= 1;
			endrepeat;
			!write STEO factors
			STEOFactors_Write;
			!SaveAll( FormatString("ngmm%e_%i", ModelYear,ncntrl_curitr(1)));
			
			! Collect profiler information for line hits above 0.5 seconds.
			ProfilerCollectAllData(Results, GrossTimeThreshold: 0.5);
		}
		Comment: "This procedure serves as \"MainExecution\" when invoking NGTDM from/within AIMMS.";
	}
	Procedure MainExecution_NEMSSimulation {
		Body: {
			LoadData("restart_initial");
			ncntrl_curitr(1):=1;
			SaveGDS("restart");
			KEEPOPEN:=0;
			repeat
			
			empty Cleared_Identifiers_;
			LoadData("restart");
			!Initialize ModelYear
			
			ModelYear := StringToElement(Years_, FormatString("%n", NCNTRL_CURCALYR(1)));
			if ncntrl_curitr(1)=3 then
			  ncntrl_ncrl(1):=1;
			else
			  ncntrl_ncrl(1):=0;
			endif;
			if ncntrl_curitr(1)=2 then
			  ncntrl_fcrl(1):=1;
			else
			  ncntrl_fcrl(1):=0;
			endif;
			!write ModelYear to file "debugmodelyear.txt" in merge mode;
			!Save updates to startup case "restart.data"
			!SaveGDS("restart");
			
			!Save case with original restart file variables for off-line testing
			!if ( ncntrl_curcalyr(1)=Val(FirstModelYear) and ncntrl_ncrl(1)=1 ) then
			!	SaveGDS("restart_initial");
			!endif;
			!Read Run-time parameters
			Read_Runtime_Parameters;
			!Initialize NGTDM data depending on year
			!This will need to be changed depending on year difference between first year NEMS calls NGTDM, LastHistoricalYear, and FirstModelYear
			if KEEPOPEN = 0 then
				if ModelYear = FirstModelYear then
					FirstYearInitialization;
				elseif ModelYear > FirstModelYear then
					LoadData( FormatString("ngtdm_only%e", ModelYear-1));
				endif;
			elseif ( ModelYear = FirstModelYear and ncntrl_curitr(1)=1 ) then
				FirstYearInitialization;
			endif;
			
			display ncntrl_curcalyr ;
			
			!Run NGTDM Model
			!if (ModelYear >= FirstModelYear and ncntrl_ncrl(1) <> 1) then
			!	NGMM;
			!	Write_to_NEMS;		! Assign values to NEMS transfer parameters
			!elseif (ModelYear >= FirstModelYear and ncntrl_ncrl(1) = 1) then
			!	NEMS_Report_Loop;
			!	Write_to_NEMS;		! Assign values to NEMS transfer parameters
			!endif;
			if (ModelYear >= FirstModelYear) then
			   if (ncntrl_ncrl(1) <> 1) then
				NGMM;
				Write_to_NEMS;		! Assign values to NEMS transfer parameters
			   elseif (ncntrl_fcrl(1) = 1 and (LNG_FixedExports_Switch = 0) and ((NEMSmap_XYear(NEMSmap_MNXYRS(ModelYear)) + LNG_YrsUntilBuild) <= LastModelYear)) then
				NEMS_Report_Loop;
			   endif;
			!	NGMM;
			!	Write_to_NEMS;		! Assign values to NEMS transfer parameters
			endif;
			
			!If the reporting switch in NEMS is on, save NGTDM-only variables (by year) to load upon AIMMS restart
			!For all other invocations, save the data into a year-iteration-specific data file for debugging.  User selects
			! menu "Data..Load Case...As Active.." and selects one of the "ngtdm_year_it.data" files.
			
			if (ModelYear >= FirstModelYear and ncntrl_fcrl(1)=1 and ncntrl_ncrl(1)=0 ) then
				if (ModelYear < LastModelYear) then
					PrepareDataForNextRoll;
					NCNTRL_CURIYR(1)+= 1;
					NCNTRL_CURCALYR(1)+=1;
					ncntrl_curitr(1):=0;
			  		!SaveAll( FormatString("ngtdm%e", ModelYear));
			  		if  KEEPOPEN = 0 then
			  			SaveNGTDM( FormatString("ngtdm_only%e", ModelYear));
			  		endif;
				endif;
			!else
			  	!SaveAll( FormatString("ngtdm%e_%i", ModelYear,ncntrl_curitr(1)));
			endif;
			
			!SaveAll( FormatString("ngtdm%e_%i", ModelYear,ncntrl_curitr(1)));
			
			if (ModelYear = LastModelYear and ncntrl_fcrl(1)=1) then
			   !write STEO factors
			    STEOFactors_Write;
			    SaveAll( FormatString("ngtdm%e_%i", ModelYear,ncntrl_curitr(1)));
			endif;
			!if ( ncntrl_ncrl(1)=1 ) then
			!	PrepareDataForNextRoll;
			!  	!SaveAll( FormatString("ngtdm%e", ModelYear));
			!  	SaveNGTDM( FormatString("ngtdm_only%e", ModelYear));
			!!else
			!  	SaveAll( FormatString("ngtdm%e_%i", ModelYear,ncntrl_curitr(1)));
			!endif;
			ncntrl_curitr(1)+=1;
			SaveGDS("restart");
			endrepeat;
		}
	}
	Procedure Calibrate {
		Body: {
			empty Cleared_Identifiers_;
			LoadData("restart_initial");
			Read_Runtime_Parameters;
			read from file "data\\ngcalibration_params.txt" ; 
			AIMMS_Standalone_Switch :=1;
			CalibrationMode:=1;
			InitializeFirstModelYear;
			FirstYearInitialization;
			RunHQP;  !Run QP for historical years
		}
	}
	Section Global_Data_Structure {
		Section GDS_Parameters {
			Section NCNTRL_Declarations {
				DeclarationSection NCNTRL {
					Parameter NCNTRL_CURCALYR {
						IndexDomain: M1;
						Text: "Current Calendar Year for NEMS simulation, such as 2040";
						InitialData: 2015;
					}
					Parameter NCNTRL_CURIYR {
						IndexDomain: M1;
						Text: "Current year index for NEMS simulation where 1990=1";
						InitialData: 26;
					}
					Parameter NCNTRL_CURITR {
						IndexDomain: M1;
						Text: "Iteration number of NEMS gauss-seidel solution";
						InitialData: 1;
					}
					Parameter NCNTRL_FCRL {
						IndexDomain: M1;
						Text: "FINAL CONVERGENCE AND REPORTING LOOP SWITCH (1=ON)";
						InitialData: 0;
					}
					Parameter NCNTRL_NCRL {
						IndexDomain: M1;
						Text: "Reporting Loop Switch (1=ON)";
						InitialData: 0;
					}
				}
			}
			Section COMMREP_Declarations {
				DeclarationSection COMMREP {
					Parameter COMMREP_SurvFloorTotal {
						IndexDomain: (MNUMCR,M11,MNUMYR);
					}
					Parameter COMMREP_CMTotalFlspc {
						IndexDomain: (MNUMCR,CMnumBldg,MNUMYR);
					}
					Parameter COMMREP_DegreeDays {
						IndexDomain: (M2, MNUMCR, MNUMYR);
						Text: "Heating (M2=1) and cooling (M2=2) degree days";
					}
				}
			}
			Section CONVFACT_Declarations {
				DeclarationSection CONVFACT {
					Parameter CONVFACT_CFNGC {
						IndexDomain: (MNUMYR);
						Text: "Natural Gas - Consumption";
					}
					Parameter CONVFACT_CFNGCL {
						IndexDomain: (MNUMYR);
						Text: "Natural gas (synthetic) from coal";
					}
					Parameter CONVFACT_CFNGN {
						IndexDomain: (MNUMYR);
						Text: "Natural Gas - Nonutility consumption";
					}
					Parameter CONVFACT_CFNGU {
						IndexDomain: (MNUMYR);
						Text: "Natural Gas - Utility consumption";
					}
				}
			}
			Section INTOUT_Declarations {
				DeclarationSection INTOUT {
					Parameter INTOUT_IT_WOP {
						IndexDomain: (MNUMYR,M2);
						Text: "WORLD OIL PRICE                  (2--UNITS)";
					}
					Parameter INTOUT_Q_NON_US_DEMAND {
						IndexDomain: (MNCRUD,M1,S1,MNXYRS);
						Text: "Non-US crude demand by type";
					}
				}
			}
			Section LFMMOUT_Declarations {
				DeclarationSection LFMMOUT {
					Parameter LFMMOUT_LCFS_BaseLine {
						IndexDomain: (LCFS_C,MNXYRS);
						Text: "Baseline LCFS Carbon Itensity(1=Gasoline, 2 = Diesel)";
					}
					Parameter LFMMOUT_Q_CRUDE_IMPORTS {
						IndexDomain: (M10,MNCRUD,MNXYRS);
						Text: "Imported crude oil quantity (9=US Total)";
					}
				}
			}
			Section MACOUT_Declarations {
				DeclarationSection MACOUT {
					Parameter MACOUT_MC_JPGDP {
						IndexDomain: (MNUMY3);
						Text: "Chained price index-gross domestic product";
					}
					Parameter MACOUT_MC_RUC {
						IndexDomain: (MNUMYR);
						Text: "Civilian unemployment rate";
					}
					Parameter MACOUT_MC_NP {
						IndexDomain: (MNUMCR,MNUMYR);
						Text: "Total National Population";
					}
				}
			}
			Section MPBLK_Declarations {
				DeclarationSection MPBLK {
					Parameter MPBLK_PGFIN {
						IndexDomain: (MNUMCR,MNUMYR);
						Text: "Natural Gas, Core - Industrial";
					}
					Parameter MPBLK_PGIIN {
						IndexDomain: (MNUMCR,MNUMYR);
						Text: "Natural Gas, Noncore - Industrial";
					}
					Parameter MPBLK_PNGCM {
						IndexDomain: (MNUMCR,MNUMYR);
						Text: "Natural Gas - Commercial";
					}
					Parameter MPBLK_PNGRS {
						IndexDomain: (MNUMCR,MNUMYR);
						Text: "Natural Gas - Residential";
					}
					Parameter MPBLK_PNGEL {
						IndexDomain: (MNUMCR,MNUMYR);
						Text: "Natural Gas - Electric Power";
					}
					Parameter Copy_MPBLK_PNGEL {
						IndexDomain: (MNUMCR,MNUMYR);
						Text: "Natural Gas - Electric Power";
					}
					Parameter MPBLK_PNGIN {
						IndexDomain: (MNUMCR,MNUMYR);
						Text: "Natural Gas - Industrial";
					}
					Parameter MPBLK_PNGTR {
						IndexDomain: (MNUMCR,MNUMYR);
						Text: "Natural Gas - Transportation";
					}
				}
			}
			Section MXPBLK_Declarations {
				DeclarationSection MXPBLK {
					Parameter MXPBLK_XBRENT_PRICE {
						IndexDomain: MNXYRS;
					}
					Parameter MXPBLK_XSTART_PRICE {
						IndexDomain: (MNXYRS);
						Text: "World oil price as specified in memo";
						Comment: "Brent spot price";
					}
				}
			}
			Section MXQBLK_Declarations {
				DeclarationSection MXQBLK {
					Parameter MXQBLK_XOGCNPPRD {
						IndexDomain: (M2,MNXYRS);
						Text: "CANADIAN PRICE OF OIL & GAS";
					}
				}
			}
			Section NGRPT_Declarations {
				DeclarationSection NGRPT {
					Parameter NGRPT_NGCAPS {
						IndexDomain: (M12,M6,MNUMYR);
						Text: "NG CAPS ENTERING NG NODE (BY ARC)";
					}
					Parameter NGRPT_NGFLOWS {
						IndexDomain: (M12,M6,MNUMYR);
						Text: "NG FLOWS ENTERING NG NODE (BY ARC)";
					}
				}
			}
			Section NGTDMOUT_Declarations {
				DeclarationSection NGTDMOUT {
					Parameter NGTDMOUT_SPNGIN {
						IndexDomain: (MNUMCR,MNUMYR,M4);
						Text: "natural gas delivered price to industrial sector by HMM season";
						Comment: "natural gas delivered price to industrial sector by season";
					}
					Parameter NGTDMOUT_PGFTRFV {
						IndexDomain: (MNUMCR,MNUMYR);
						Text: "PRICE COMPRESSED NG TO FLEET VEHICLES";
					}
					Parameter NGTDMOUT_PGFTRPV {
						IndexDomain: (MNUMCR,MNUMYR);
						Text: "PRICE COMPRESSED NG TO PERSONAL VEHICLES";
					}
					Parameter NGTDMOUT_PGLTRFV {
						IndexDomain: (MNUMCR,MNUMYR);
						Text: "PRICE LIQUEFIED NG TO FLEET VEHICLES";
					}
					Parameter NGTDMOUT_PGLTRPV {
						IndexDomain: (MNUMCR,MNUMYR);
						Text: "PRICE LIQUEFIED NG TO PERSONAL VEHICLES";
					}
					Parameter NGTDMOUT_PGFTRRAIL {
						IndexDomain: (M4,MNUMCR,MNUMYR);
						Text: "PRICE COMPRESSED NG TO RAIL";
					}
					Parameter NGTDMOUT_PGLTRRAIL {
						IndexDomain: (M4,MNUMCR,MNUMYR);
						Text: "PRICE LIQUEFIED NG TO RAIL";
					}
					Parameter NGTDMOUT_PGLTRSHIP {
						IndexDomain: (M3,MNUMCR,MNUMYR);
						Text: "PRICE LIQUEFIED NG TO SHIP";
					}
					Parameter NGTDMOUT_PGFTRSHIP {
						IndexDomain: (M3,MNUMCR,MNUMYR);
						Text: "PRICE COMPRESSED NG TO SHIP";
					}
					Parameter NGTDMOUT_QGFTRFV {
						IndexDomain: (MNUMCR,MNUMYR);
						Text: "CONSUMPTION COMPRESSED NG BY FLEET VEHICLES";
					}
					Parameter NGTDMOUT_QGFTRPV {
						IndexDomain: (MNUMCR,MNUMYR);
						Text: "CONSUMPTION COMPRESSED NG BY PERSONAL VEHICLES";
					}
					Parameter NGTDMOUT_QGLTRFV {
						IndexDomain: (MNUMCR,MNUMYR);
						Text: "CONSUMPTION LIQUEFIED NG BY FLEET VEHICLES";
					}
					Parameter NGTDMOUT_QGLTRPV {
						IndexDomain: (MNUMCR,MNUMYR);
						Text: "CONSUMPTION LIQUEFIED NG BY PERSONAL VEHICLES";
					}
					Parameter NGTDMOUT_QGFTRRAIL {
						IndexDomain: (M4,MNUMCR,MNUMYR);
						Text: "CONSUMPTION COMPRESSED NG TO RAIL";
					}
					Parameter NGTDMOUT_QGLTRRAIL {
						IndexDomain: (M4,MNUMCR,MNUMYR);
						Text: "CONSUMPTION LIQUEFIED NG TO RAIL";
					}
					Parameter NGTDMOUT_QGLTRSHIP {
						IndexDomain: (M3,MNUMCR,MNUMYR);
						Text: "CONSUMPTION LIQUEFIED NG TO SHIP";
					}
					Parameter NGTDMOUT_QGFTRSHIP {
						IndexDomain: (M3,MNUMCR,MNUMYR);
						Text: "CONSUMPTION COMPRESSED NG TO SHIP";
					}
					Parameter NGTDMOUT_SPNGELGR {
						IndexDomain: (NNGEMM,MNUMYR,M3);
						Text: "Price for natural gas used in electricity by year for 3 seasons (no firm or interruptible)";
						Comment: {
							"!New as of 5/27/16 Variable still needs to be filled correctly; currently using qsblk.txt file in scedes.ngonly.txt"
						}
					}
					Parameter NGTDMOUT_PNGELGR {
						IndexDomain: (NNGEMM,MNUMYR);
						Text: "Price for natural gas used in electricity by year for 3 seasons annual";
						Comment: {
							"!New as of 5/27/16 Variable still needs to be filled correctly; currently using qsblk.txt file in scedes.ngonly.txt"
						}
					}
				}
			}
			Section NGTDMREP_Declarations {
				DeclarationSection NGTDMREP {
					Parameter NGTDMREP_LCFSRNGOS {
						IndexDomain: MNUMYR;
					}
					Parameter NGTDMREP_ACGPR_RESCOM {
						IndexDomain: (M12,MNUMYR);
						Text: "average residential/commercial citygate price";
					}
					Parameter NGTDMREP_ARESCOM {
						IndexDomain: (M12,MNUMYR);
						Text: "weights for ACGPR_RESCOM";
					}
					Parameter NGTDMREP_CNLNGIMP {
						IndexDomain: (MNUMYR);
						Text: "LNG imports into Canada";
					}
					Parameter NGTDMREP_NALNGEXP {
						IndexDomain: (LNGTER,MNUMYR);
						Text: "North American LNG exports by facility";
					}
					Parameter NGTDMREP_NGBAL {
						IndexDomain: (MNUMYR);
						Text: "accounted for portion of natural gas unaccounted f";
					}
					Parameter NGTDMREP_NGEXPVOL {
						IndexDomain: (M4,MNUMYR);
						Text: "Total Export Volumes (Bcf)";
						Comment: "1= Canada, 2= Mexico, 3=LNG, 4=Total";
					}
					Parameter NGTDMREP_NGEXPPRC {
						IndexDomain: (M4,MNUMYR);
						Text: "Average Export Price (87$/Mcf)";
						Comment: "1= Canada, 2= Mexico, 3=LNG, 4=Total";
					}
					Parameter NGTDMREP_NGIMPVOL {
						IndexDomain: (M4,MNUMYR);
						Text: "Total Import Volumes (Bcf)";
						Comment: "1= Canada, 2= Mexico, 3=LNG, 4=Total";
					}
					Parameter NGTDMREP_NGIMPPRC {
						IndexDomain: (M4,MNUMYR);
						Text: "Average Import Price (87$/Mcf)";
						Comment: "1= Canada, 2= Mexico, 3=LNG, 4=Total";
					}
					Parameter NGTDMREP_NGSCRV_ELAS {
						IndexDomain: (M5);
						Text: "NG supply curve slope (q change / p change)";
					}
					Parameter NGTDMREP_NGSCRV_MAX {
						IndexDomain: (MNUMYR);
						Text: "NG supply curve maximum quantity";
					}
					Parameter NGTDMREP_NGSCRV_MIN {
						IndexDomain: (MNUMYR);
						Text: "NG supply curve minimum quantity";
					}
					Parameter NGTDMREP_NGSCRV_P {
						IndexDomain: (MNUMYR);
						Text: "NG supply curve solution price";
					}
					Parameter NGTDMREP_NGSCRV_P0 {
						IndexDomain: (MNUMYR);
						Text: "NG supply curve base price";
					}
					Parameter NGTDMREP_NGSCRV_PER {
						IndexDomain: (M2);
						Text: "NG supply curve segment percent deviation";
					}
					Parameter NGTDMREP_NGSCRV_Q {
						IndexDomain: (MNUMYR);
						Text: "NG supply curve solution quantity";
					}
					Parameter NGTDMREP_NGSCRV_Q0 {
						IndexDomain: (MNUMYR);
						Text: "NG supply curve base quantity";
					}
					Parameter NGTDMREP_EL_MRKUP_BETA {
						IndexDomain: (M3);
						Text: "seasonal consumption coefficient for electric powe";
					}
					Parameter NGTDMREP_NGSPOT_EMM {
						IndexDomain: (NNGEMM,MNUMYR);
					}
					Parameter NGTDMREP_OGHHPRNG {
						IndexDomain: (MNUMYR);
						Text: "price of natural gas at Henry Hub";
					}
					Parameter NGTDMREP_OGPRCNG {
						IndexDomain: (OGDIST,MNUMYR);
					}
					Parameter NGTDMREP_OGPRDNG {
						IndexDomain: (MNUMOR,MNUMYR);
						Text: "DOMESTIC DRY NG PRODUCTION";
					}
					Parameter NGTDMREP_OGPRSUP {
						IndexDomain: (MNUMYR);
						Text: "TOTAL SUPPLEMENTAL GAS (SYN+OTH)";
					}
					Parameter NGTDMREP_OGSUPGAS {
						IndexDomain: (M2,MNUMCR,MNUMYR);
						Text: "supplemental natural gas supplies (1 from coal, 2";
					}
					Parameter NGTDMREP_OGWPRNG {
						IndexDomain: (MNUMOR,MNUMYR);
						Text: "NG WELLHEAD PRICE (87$/MCF)";
					}
					Parameter NGTDMREP_PINTLNG {
						IndexDomain: (M2,MNUMYR);
						Text: "Price of natural gas in Europe, Japan";
					}
					Parameter NGTDMREP_PTRANSNG {
						IndexDomain: (M2,LNGTER,MNUMYR);
						Text: "Transportation costs for natural gas";
					}
					Parameter NGTDMREP_PUSNG {
						IndexDomain: (LNGTER,MNUMYR);
						Text: "US price of natural gas for comparison to PINTLNG";
					}
					Parameter NGTDMREP_UDTAR {
						IndexDomain: (NNGEMM,MNUMYR);
						Text: "distributor tariff for electric power sector";
					}
					Parameter NGTDMREP_OGPRRNG {
						IndexDomain: MNUMYR;
						Comment: "Total annual RNG production";
					}
				}
			}
			Section OGSMOUT_Declarations {
				DeclarationSection OGSMOUT {
					Parameter OGSMOUT_OGADGPRD {
						IndexDomain: (OGDIST,OILTYP,MNUMYR);
						Text: "Associated-dissolved natural gas production";
					}
					Parameter OGSMOUT_OGCNPPRD {
						IndexDomain: (M2,MNUMYR);
						Text: "CANADIAN PRICE OF OIL & GAS";
					}
					Parameter OGSMOUT_OGENAGPRD {
						IndexDomain: (OGDIST,GASTYP,MNUMYR);
						Text: "Expected non-associated natural gas production";
					}
					Parameter OGSMOUT_OGPRCOAK {
						IndexDomain: (MNALAS,MNUMYR);
						Text: "Alaska production by region";
					}
					Parameter OGSMOUT_OGQNGEXP {
						IndexDomain: (MNUMBX,MNUMYR);
						Text: "NG EXPORTS  (BILL. CU FT)";
					}
					Parameter OGSMOUT_OGRNAGPRD {
						IndexDomain: (OGDIST,GASTYP,MNUMYR);
						Text: "Realized non-associated natural gas production";
					}
					Parameter OGSMOUT_OGSHALENG {
						IndexDomain: (MNUMYR);
						Text: "Natural gas produced by oil shale plants";
					}
					Parameter OGSMOUT_OGNGPLPRD {
						IndexDomain: (OGDIST,MNUMYR);
						Text: "Natural gas plant output by NGPL region";
					}
					Parameter OGSMOUT_CNADGPRD {
						IndexDomain: (M2,MNUMYR);
						Text: {
							"Associated-dissolved natural gas production for Canada; 1-east, 2-west"
						}
					}
					Parameter OGSMOUT_CNENAGPRD {
						IndexDomain: (M2,MNUMYR);
						Text: {
							"Expected non-associated natural gas production for Canada; 1-east, 2-west"
						}
					}
					Parameter OGSMOUT_CNRNAGPRD {
						IndexDomain: (M2,MNUMYR);
						Text: {
							"Realized non-associated natural gas production for Canada; 1-east, 2-west"
						}
					}
				}
			}
			Section QBLK_Declarations {
				DeclarationSection QBLK {
					Parameter QBLK_QGFIN {
						IndexDomain: (MNUMCR,MNUMYR);
						Text: "Natural Gas, Core - Industrial";
						dex::Document: Test;
					}
					Parameter QBLK_QGIIN {
						IndexDomain: (MNUMCR,MNUMYR);
						Text: "Natural Gas, Noncore - Industrial";
					}
					Parameter QBLK_QGPTR {
						IndexDomain: (MNUMCR,MNUMYR);
						Text: "Natural Gas - Pipeline";
					}
					Parameter QBLK_QLPIN {
						IndexDomain: (MNUMCR,MNUMYR);
						Text: "Natural Gas - Lease and Plant Fuel";
					}
					Parameter QBLK_QNGCM {
						IndexDomain: (MNUMCR,MNUMYR);
						Text: "Natural Gas, Core - Commercial";
					}
					Parameter QBLK_QNGEL {
						IndexDomain: (MNUMCR,MNUMYR);
						Text: "Natural Gas - Electric Power";
					}
					Parameter QBLK_QNGRS {
						IndexDomain: (MNUMCR,MNUMYR);
						Text: "Natural Gas, Core - Residential";
					}
					Parameter QBLK_QNGTR {
						IndexDomain: (MNUMCR,MNUMYR);
						Text: "Natural Gas - Transportation";
					}
					Parameter QBLK_QNGHM {
						IndexDomain: (MNUMCR,MNUMYR);
						Text: "Natural Gas - Hydrogen";
					}
				}
			}
			Section RESDREP_Declarations {
				DeclarationSection RESDREP {
					Parameter RESDREP_RSGASCUST {
						IndexDomain: (MNUMYR,MNUMC2);
						Text: "Proxy number of gas customers (households)";
					}
				}
			}
			Section STEOBLOCK_Declarations {
				DeclarationSection STEOBLOCK {
					Parameter STEOBLOCK_NGCCU_ENC {
						IndexDomain: MNUMYR;
						Text: "ng price comm, east north central, $/Mcf";
					}
					Parameter STEOBLOCK_NGCCU_ESC {
						IndexDomain: MNUMYR;
						Text: "ng price comm, east south central, $/Mcf";
					}
					Parameter STEOBLOCK_NGCCU_MAC {
						IndexDomain: MNUMYR;
						Text: "ng price comm, middle atlantic, $/Mcf";
					}
					Parameter STEOBLOCK_NGCCU_MTN {
						IndexDomain: MNUMYR;
						Text: "ng price comm, mountain, $/Mcf";
					}
					Parameter STEOBLOCK_NGCCU_NEC {
						IndexDomain: MNUMYR;
						Text: "ng price comm, new england, $/Mcf";
					}
					Parameter STEOBLOCK_NGCCU_PAC {
						IndexDomain: MNUMYR;
						Text: "ng price comm, pacific, $/Mcf";
					}
					Parameter STEOBLOCK_NGCCU_SAC {
						IndexDomain: MNUMYR;
						Text: "ng price comm, south atlantic, $/Mcf";
					}
					Parameter STEOBLOCK_NGCCU_WNC {
						IndexDomain: MNUMYR;
						Text: "ng price comm, west north central, $/Mcf";
					}
					Parameter STEOBLOCK_NGCCU_WSC {
						IndexDomain: MNUMYR;
						Text: "ng price comm, west south central, $/Mcf";
					}
					Parameter STEOBLOCK_NGCCUUS {
						IndexDomain: MNUMYR;
						Text: "ng price comm, $/Mcf";
					}
					Parameter STEOBLOCK_NGICU_ENC {
						IndexDomain: MNUMYR;
						Text: "ng price ind, east north central, $/Mcf";
					}
					Parameter STEOBLOCK_NGICU_ESC {
						IndexDomain: MNUMYR;
						Text: "ng price ind, east south central, $/Mcf";
					}
					Parameter STEOBLOCK_NGICU_MAC {
						IndexDomain: MNUMYR;
						Text: "ng price ind, middle atlantic, $/Mcf";
					}
					Parameter STEOBLOCK_NGICU_MTN {
						IndexDomain: MNUMYR;
						Text: "ng price ind, mountain, $/Mcf";
					}
					Parameter STEOBLOCK_NGICU_NEC {
						IndexDomain: MNUMYR;
						Text: "ng price ind, new england, $/Mcf";
					}
					Parameter STEOBLOCK_NGICU_PAC {
						IndexDomain: MNUMYR;
						Text: "ng price ind, pacific, $/Mcf";
					}
					Parameter STEOBLOCK_NGICU_SAC {
						IndexDomain: MNUMYR;
						Text: "ng price ind, south atlantic, $/Mcf";
					}
					Parameter STEOBLOCK_NGICU_WNC {
						IndexDomain: MNUMYR;
						Text: "ng price ind, west north central, $/Mcf";
					}
					Parameter STEOBLOCK_NGICU_WSC {
						IndexDomain: MNUMYR;
						Text: "ng price ind, west south central, $/Mcf";
					}
					Parameter STEOBLOCK_NGICUUS {
						IndexDomain: MNUMYR;
						Text: "ng price ind, $/Mcf";
					}
					Parameter STEOBLOCK_NGRCU_ENC {
						IndexDomain: MNUMYR;
						Text: "ng price res, east north central, $/Mcf";
					}
					Parameter STEOBLOCK_NGRCU_ESC {
						IndexDomain: MNUMYR;
						Text: "ng price res, east south central, $/Mcf";
					}
					Parameter STEOBLOCK_NGRCU_MAC {
						IndexDomain: MNUMYR;
						Text: "ng price res, middle atlantic, $/Mcf";
					}
					Parameter STEOBLOCK_NGRCU_MTN {
						IndexDomain: MNUMYR;
						Text: "ng price res, mountain, $/Mcf";
					}
					Parameter STEOBLOCK_NGRCU_NEC {
						IndexDomain: MNUMYR;
						Text: "ng price res, new england, $/Mcf";
					}
					Parameter STEOBLOCK_NGRCU_PAC {
						IndexDomain: MNUMYR;
						Text: "ng price res, pacific, $/Mcf";
					}
					Parameter STEOBLOCK_NGRCU_SAC {
						IndexDomain: MNUMYR;
						Text: "ng price res, south atlantic, $/Mcf";
					}
					Parameter STEOBLOCK_NGRCU_WNC {
						IndexDomain: MNUMYR;
						Text: "ng price res, west north central, $/Mcf";
					}
					Parameter STEOBLOCK_NGRCU_WSC {
						IndexDomain: MNUMYR;
						Text: "ng price res, west south central, $/Mcf";
					}
					Parameter STEOBLOCK_NGRCUUS {
						IndexDomain: MNUMYR;
						Text: "ng price res, $/Mcf";
					}
					Parameter STEOBLOCK_NGEUDUS {
						IndexDomain: MNUMYR;
						Text: "cost of ng to elec gen, $/MMbtu";
					}
					Parameter STEOBLOCK_NGHHUUS {
						IndexDomain: MNUMYR;
						Text: "henry hub spot price, $/MMbtu";
					}
					Parameter STEOBLOCK_NGSFPUS {
						IndexDomain: MNUMYR;
						Text: "supplemental fuels supply, Bcf/d";
					}
					Parameter STEOBLOCK_NGLPPUS {
						IndexDomain: MNUMYR;
						Text: "ng lease and plant fuel, Bcf/d";
					}
					Parameter STEOBLOCK_NGACPUS {
						IndexDomain: MNUMYR;
						Text: "ng pipeline & distribution, Bcf/d";
					}
					Parameter STEOBLOCK_NGTCPUS {
						IndexDomain: MNUMYR;
						Text: "ng consumption, Bcf/d";
					}
					Parameter STEOBLOCK_BALIT {
						IndexDomain: MNUMYR;
						Text: "ng balancing (cons-supply), Bcf/d";
					}
					Parameter STEOBLOCK_NGNWPUS {
						IndexDomain: MNUMYR;
						Text: "ng net withdrawals fr storage, Bcf/d";
					}
					Parameter STEOBLOCK_NGEXPUS_LNG {
						IndexDomain: MNUMYR;
						Text: "ng exports, liquefied, Bcf/d";
					}
					Parameter STEOBLOCK_NGEXPUS_PIPE {
						IndexDomain: MNUMYR;
						Text: "ng exports by pipeline, Bcf/d";
					}
					Parameter STEOBLOCK_NGEXPUS {
						IndexDomain: MNUMYR;
						Text: "ng exports, Bcf/d";
					}
					Parameter STEOBLOCK_NGIMPUS {
						IndexDomain: MNUMYR;
						Text: "ng imports, Bcf/d";
					}
					Parameter STEOBLOCK_NGIMPUS_LNG {
						IndexDomain: MNUMYR;
						Text: "ng imports, liquefied, Bcf/d";
					}
					Parameter STEOBLOCK_NGIMPUS_PIPE {
						IndexDomain: MNUMYR;
						Text: "ng imports, pipeline, Bcf/d";
					}
				}
			}
			Section UEFDOUT_Declarations {
				DeclarationSection UEFDOUT {
					Parameter UEFDOUT_SQNGELGR {
						IndexDomain: (NNGEMM,MNUMYR,M3);
						Text: "Natural gas consumption in the electricity sector by year, 3 seasons (no firm or interruptible distinction)";
						Comment: {
							"!Variable new as of 5/27/16 still needs to be filled correctly.  Currently using qsblk.txt in scedes.ngonly.txt file"
						}
					}
				}
			}
			Section QMORE_Declarations {
				DeclarationSection QMORE {
					Parameter QMORE_QNGLQ {
						IndexDomain: (MNUMCR,MNUMYR);
					}
					Parameter QMORE_QGTLRF {
						IndexDomain: (MNUMCR,MNUMYR);
						Text: "Natural gas not going to liquids";
					}
					Parameter QMORE_QGTLSN {
						IndexDomain: (MNUMCR,MNUMYR);
						Text: "All natural gas into GTL process";
					}
				}
			}
			Section CYCLEINFO_Declarations {
				DeclarationSection CYCLEINFO {
					Parameter CYCLEINFO_CURIRUN {
						IndexDomain: M1;
						Text: "Reporting Loop Switch (1=ON)";
						InitialData: 1;
					}
				}
			}
			Section UDATOUT_Declarations {
				DeclarationSection UDATOUT {
					Parameter UDATOUT_UGENPC {
						IndexDomain: (MNUMNR,MNUMYR);
						Text: "Total Pulv Coal generation by NERC";
					}
					Parameter UDATOUT_UGENSQ {
						IndexDomain: (MNUMNR,MNUMYR);
						Text: "Total Pulv Coal generation w/Seq by NERC";
					}
					Parameter UDATOUT_UGENIG {
						IndexDomain: (MNUMNR,MNUMYR);
						Text: "Total IGCC w/o seq coal generation by NERC";
					}
					Parameter UDATOUT_UGENIS {
						IndexDomain: (MNUMNR,MNUMYR);
						Text: "Total IGCC w/seq generation by NERC (coal)";
					}
					Parameter UDATOUT_UGENOS {
						IndexDomain: (MNUMNR,MNUMYR);
						Text: "Total Oil/Gas steam generation by NERC (oil/gas steam)";
					}
					Parameter UDATOUT_UGENCC {
						IndexDomain: (MNUMNR,MNUMYR);
						Text: "Total Conv. CC generation by NERC";
					}
					Parameter UDATOUT_UGENAC {
						IndexDomain: (MNUMNR,MNUMYR);
						Text: "Total Adv. CC w/o seq generation by NERC";
					}
					Parameter UDATOUT_UGENCS {
						IndexDomain: (MNUMNR,MNUMYR);
						Text: "Total Adv. CC w/seq generation by NERC";
					}
					Parameter UDATOUT_UGENCT {
						IndexDomain: (MNUMNR,MNUMYR);
						Text: "Total Conv. Turb. generation by NERC";
					}
					Parameter UDATOUT_UGENAT {
						IndexDomain: (MNUMNR,MNUMYR);
						Text: "Total Adv. Turb. generation by NERC";
					}
					Parameter UDATOUT_UGENNU {
						IndexDomain: (MNUMNR,MNUMYR);
						Text: "Total Nuclear generation by NERC";
					}
					Parameter UDATOUT_UGENPS {
						IndexDomain: (MNUMNR,MNUMYR);
						Text: "Total Pumped St. generation by NERC";
					}
					Parameter UDATOUT_UGENDS {
						IndexDomain: (MNUMNR,MNUMYR);
						Text: "Total Diurnal Storage generation by NERC (battery storage)";
					}
					Parameter UDATOUT_UGENFC {
						IndexDomain: (MNUMNR,MNUMYR);
						Text: "Total Fuel Cell generation by NERC";
					}
					Parameter UDATOUT_UGENRN {
						IndexDomain: (MNUMNR,MNUMYR);
						Text: "Total Renew.  generation by NERC";
					}
					Parameter UDATOUT_UGENDG {
						IndexDomain: (MNUMNR,MNUMYR);
						Text: "Total Dist. Gen. generation by NERC";
					}
				}
			}
		}
		DeclarationSection GDS_Sets {
			Set LCFS_C_ {
				Index: LCFS_C;
				Definition: {
					{1..2}
				}
			}
			Set GDSIdentifiers_ {
				SubsetOf: AllIdentifiers;
				Definition: {
					Global_Data_Structure * AllIdentifiers;
				}
			}
			Set MNUMCR_ {
				SubsetOf: Integers;
				Text: "Census Regions";
				Index: MNUMCR;
				Property: ElementsAreLabels;
				InitialData: {
					{1..0011}
				}
			}
			Set MNUMYR_ {
				SubsetOf: Integers;
				Text: "Years=1990-2050";
				Index: MNUMYR;
				Property: ElementsAreNumerical;
				InitialData: {
					{1..0061}
				}
			}
			Set M17_ {
				SubsetOf: Integers;
				Text: "Unnamed";
				Index: M17;
				Property: ElementsAreLabels;
				InitialData: {
					{1..0017}
				}
			}
			Set M1_ {
				SubsetOf: Integers;
				Index: M1, S1;
				Property: ElementsAreLabels;
				InitialData: {
					{1}
				}
			}
			Set M4_ {
				SubsetOf: Integers;
				Text: "Unnamed";
				Index: M4;
				Property: ElementsAreLabels;
				InitialData: {
					{1..0004}
				}
			}
			Set M2_ {
				SubsetOf: Integers;
				Text: "Unnamed";
				Index: M2, NUMCAN;
				Property: ElementsAreLabels;
				InitialData: {
					{1..0002}
				}
			}
			Set M14_ {
				SubsetOf: Integers;
				Text: "Unnamed";
				Index: M14;
				Property: ElementsAreLabels;
				InitialData: {
					{1..0014}
				}
			}
			Set MNUMY3_ {
				SubsetOf: Integers;
				Text: "MNUMYR + 1987-1989";
				Index: MNUMY3;
				Property: ElementsAreNumerical;
				InitialData: {
					{1..0064}
				}
			}
			Set MNUMOR_ {
				SubsetOf: Integers;
				Text: "Oil & Gas Regions";
				Index: MNUMOR;
				Property: ElementsAreLabels;
				InitialData: {
					{1..0013}
				}
			}
			Set MNXYRS_ {
				SubsetOf: Integers;
				Text: "Expectation Years";
				Index: MNXYRS;
				Property: ElementsAreNumerical;
				InitialData: {
					{1..0091}
				}
			}
			Set M11_ {
				SubsetOf: Integers;
				Text: "Unnamed";
				Index: M11;
				Property: ElementsAreLabels;
				InitialData: {
					{1..0011}
				}
			}
			Set M10_ {
				SubsetOf: Integers;
				Text: "Unnamed";
				Index: M10;
				Property: ElementsAreLabels;
				InitialData: {
					{1..0010}
				}
			}
			Set M12_ {
				SubsetOf: Integers;
				Text: "Unnamed";
				Index: M12;
				Property: ElementsAreLabels;
				InitialData: {
					{1..0012}
				}
			}
			Set M6_ {
				SubsetOf: Integers;
				Text: "Unnamed";
				Index: M6;
				Property: ElementsAreLabels;
				InitialData: {
					{1..0006}
				}
			}
			Set M7_ {
				SubsetOf: Integers;
				Text: "Unnamed";
				Index: M7;
				Property: ElementsAreLabels;
				InitialData: {
					{1..0007}
				}
			}
			Set M3_ {
				SubsetOf: Integers;
				Text: "Unnamed";
				Index: M3;
				Property: ElementsAreLabels;
				InitialData: {
					{1..0003}
				}
			}
			Set NNGEMM_ {
				SubsetOf: Integers;
				Text: "Natural gas - Electricity regions";
				Index: NNGEMM;
				Property: ElementsAreLabels;
				InitialData: {
					{1..0017}
				}
			}
			Set MNUMPR_ {
				SubsetOf: Integers;
				Text: "PADD Regions";
				Index: MNUMPR;
				Property: ElementsAreLabels;
				InitialData: {
					{1..0010}
				}
			}
			Set MNUMNR_ {
				Text: "NERC based EMM regions";
				Index: MNUMNR;
				Definition: {
					{1..28}
				}
			}
			Set LNGTER_ {
				SubsetOf: Integers;
				Text: "LNG terminals";
				Index: LNGTER;
				Property: ElementsAreLabels;
				InitialData: {
					{1..0011}
				}
			}
			Set M5_ {
				SubsetOf: Integers;
				Text: "Unnamed";
				Index: M5;
				Property: ElementsAreLabels;
				InitialData: {
					{1..0005}
				}
			}
			Set M24_ {
				SubsetOf: Integers;
				Text: "Unnamed";
				Index: M24;
				Property: ElementsAreLabels;
				InitialData: {
					{1..0024}
				}
			}
			Set MNUMBX_ {
				SubsetOf: Integers;
				Text: "NG Border Crossings";
				Index: MNUMBX;
				Property: ElementsAreLabels;
				InitialData: {
					{1..0026}
				}
			}
			Set OGDIST_ {
				SubsetOf: Integers;
				Text: "OGSM districts";
				Index: OGDIST;
				Property: ElementsAreLabels;
				InitialData: {
					{1..0084}
				}
			}
			Set OILTYP_ {
				SubsetOf: Integers;
				Text: "Crude oil production type";
				Index: OILTYP;
				Property: ElementsAreLabels;
				InitialData: {
					{1..0005}
				}
			}
			Set MNCRUD_ {
				SubsetOf: Integers;
				Text: "Crude type by API, sulfur";
				Index: MNCRUD;
				Property: ElementsAreLabels;
				InitialData: {
					{1..0011}
				}
			}
			Set GASTYP_ {
				SubsetOf: Integers;
				Text: "Natural gas production ty";
				Index: GASTYP;
				Property: ElementsAreLabels;
				InitialData: {
					{1..0005}
				}
			}
			Set NOGCAT_ {
				SubsetOf: Integers;
				Text: "Oil Catagories (Regions)";
				Index: NOGCAT;
				Property: ElementsAreLabels;
				InitialData: {
					{1..0012}
				}
			}
			Set M42_ {
				SubsetOf: Integers;
				Text: "Unnamed";
				Index: M42;
				Property: ElementsAreLabels;
				InitialData: {
					{1..0042}
				}
			}
			Set MNUMC2_ {
				SubsetOf: MNUMCR_;
				Text: "Census Regions minus 2";
				Index: MNUMC2;
				Property: ElementsAreLabels;
				InitialData: {
					{1..0009}
				}
			}
			Set CMnumBldg_ {
				SubsetOf: Integers;
				Text: "Commercial Building Types";
				Index: CMnumBldg;
				Property: ElementsAreLabels;
				InitialData: {
					{1..0012}
				}
			}
			Set MNL48A_ {
				SubsetOf: Integers;
				Text: "Lower 48 AD gas regions";
				Index: MNL48A;
				Property: ElementsAreLabels;
				Definition: {
					{1..010}
				}
			}
			Set MNL48N_ {
				SubsetOf: Integers;
				Text: "Lower 48 NA Gas regions";
				Index: MNL48N;
				Property: ElementsAreLabels;
				Definition: {
					{1..007}
				}
			}
			Set MNL48T_ {
				SubsetOf: Integers;
				Text: "Lower 48 Total NG regions";
				Index: MNL48T;
				Property: ElementsAreLabels;
				Definition: {
					{1..011}
				}
			}
			Set MNL48F_ {
				SubsetOf: Integers;
				Text: "Lower 48 Total NG Offshore Regions";
				Index: MNL48F;
				Property: ElementsAreLabels;
				Definition: {
					{1..003}
				}
			}
			Set MNALAS_ {
				SubsetOf: Integers;
				Text: "AK Regions";
				Index: MNALAS;
				Property: ElementsAreLabels;
				Definition: {
					{1..003}
				}
			}
		}
	}
	Section NEW {
		Procedure Initialize_Electric_Power_Prices {
			Body: {
				OES_HistoricalAnnualEndUseNNGEMMPrice(datayear, NNGEMM, season,el_sec) /= GDPPriceDeflator87(datayear);
				
				if (Electric_OES_Prices_Switch =1) then
					HistoricalAnnualEndUseNNGEMMPrice(datayear, NNGEMM, season):= 
						OES_HistoricalAnnualEndUseNNGEMMPrice(datayear, NNGEMM, season, ElectricSectorForPrice);
				
				else
					HistoricalAnnualEndUseNNGEMMPrice(datayear, NNGEMM, season):=sum((datamon,state) |map_month_year(datamon,datayear) and map_mon_season(datamon,season) and map_State_NNGEMM(state,NNGEMM),
				              HistoricalEndUsePrice(datamon, Sector_Electric, state)* HistoricalDemand(datamon, Sector_Electric, state))/$
				           sum((datamon,state) |map_month_year(datamon,datayear) and map_mon_season(datamon,season) and map_State_NNGEMM(state,NNGEMM), HistoricalDemand(datamon, Sector_Electric, state));
				endif;
				;
			}
		}
		Procedure Calculate_LNG_Import_Supply {
			Body: {
				!Determine last month for which EIA historical data exists and determine LastHistoricalDataYear by testing if LastHistoricalDataMonth is December
				LastHistoricalDataMonth := Last(datamon | Exists((state)|Supply(datamon,Supply_LNG,state)));
				if (MonthToYear(LastHistoricalDataMonth)=MonthToYear(LastHistoricalDataMonth-11)) then
					LastHistoricalDataYear := MonthToYear(LastHistoricalDataMonth);
				else
					LastHistoricalDataYear := MonthToYear(LastHistoricalDataMonth)-1;
				endif;
				!if LastHistoricalDataYear>=FirstModelYear then LastDataYearFlg_LNGImp(hdatayear):=1; endif;
				LastDataYearFlg_LNGImp(hdatayear):=1;
				! Do supply here to transfer  LNG supply type
				!Supply( (mon, Supply_LNG, state) | mon >LastHistoricalMonth ) := Supply(mon-12, Supply_LNG, state);
				
				AverageImportTruck(mn,state)  :=  sum((hdatamon,navgyr_lng) | map_Month_MonthinYear(hdatamon,mn)and hdatamon>=YearToMonth(LastHistoricalDataYear),
				                                                      HistoricalTRUCKImports(hdatamon-12*(Val(navgyr_lng)-1), state))/card(NumberOfYearsForAverage_LNG_);
				AverageLNGImport(mn,state)  :=  sum((hdatamon,navgyr_lng) | map_Month_MonthinYear(hdatamon,mn)and hdatamon>=YearToMonth(LastHistoricalDataYear),
				                                                      Supply(hdatamon-12*(Val(navgyr_lng)-1), Supply_LNG,state))/card(NumberOfYearsForAverage_LNG_);
				
				
				
				Supply( (xmon, Supply_LNG, state) | MonthToYear(xmon) >LastHistoricalDataYear):= 
					!Supply(mon-12, Supply_LNG, state);
					sum(mn|map_Month_MonthinYear(xmon,mn),AverageImportTruck(mn,state)+ AverageLNGImport(mn,state));
				AnnualSupply(year, Supply_LNG, s) := sum( mon | map_month_year(mon, year), Supply(mon, Supply_LNG, s) );
				!Map OGSM expected production to Supply for US supply regions for  NA and AD gas
				!Do historical years
			}
			Comment: "Set up average Supplemental Supply levels using historical data";
		}
		DeclarationSection LNG_Imports_Declarations {
			Parameter AverageImportTruck {
				IndexDomain: (mn,reg);
			}
			Parameter AverageLNGImport {
				IndexDomain: (mn,reg);
			}
		}
		DeclarationSection New_Identifiers {
			Parameter OES_HistoricalAnnualEndUseNNGEMMPrice {
				IndexDomain: (datayear,NNGEMM,season,el_sec);
			}
			Parameter Electric_OES_Prices_Switch {
				Range: binary;
				InitialData: 0;
			}
			Set Electric_Sector_ {
				Index: el_sec;
			}
			ElementParameter ElectricSectorForPrice {
				Range: Electric_Sector_;
			}
		}
	}
	Section Natural_Gas_Market_Module {
		Procedure FirstYearInitialization {
			Body: {
				InitializeLengthOfPlanningInterval;
				MovePlanningIntervalToFirstModelYear;
				empty LengthDominatesNotActive;
				empty HistLengthDominatesNotActive;
				
				Read_set_data;	                        !Reads all main sets used to create "NLP Structure"
				Historical_reads;                       !Read historical data
				TX_InitializeData;			!Initialize Texas data
				Historical_InitializeData;              !Pre-process historical data: convert to required units, assign missing data, etc.
				RNG_Initialize; 			! Initialize RNG production history
				
				!Initialize Preprocessing Routines
				Capacity_InitializeData;                !Initialize capacities
				Production_InitializeData;              ! Initialize production historical data for NA and AD gas for US regions using OGSM variables
				Initialize_IEO_Data;			!Initialze IEO 2017 data
				LNGExports_Initialize;			!Initialize LNG Export Data
				Import_Export_InitializeData;		!Calculate historical import and exports by border crossing and country
				AK_InitializeData;			!Read and initialize all "Alaska Subroutine" data
				EndUse_Consumption_InitializeData;	!Initializes all end-use consumption data using historical data
				Storage_InitializeData;                 ! Calculate historical average storage levels
				Flow_InitializeData;                    !Initialize flows
				RegionalFlowsCapacity_InitializeData;		!Initialize regional flows
				Check_FlowsTariffs;			!Assign generic tariff curve if there is capacity or planned capacity without one
				Tariffs_Initialize;                     !Adjust tariff curves to match calculated historical tariffs
				LeaseAndPlantFuel_InitializeData;       !Initialize lease and plant fuel; calculate historical plant fuel factors and lease fuel factors
				!Losses_InitializeData;                  !Calculate historical pipeline fuel, storage and distribution losses :MOVED to Flow_InitializeData
				Canada_InitializeData;			!Initialze Canadian data using historical data
				Mexico_InitializeData;			!Initialze Mexican data using historical data
				EndUsePrice_Initialize;                 !Fill in NEMS price arrays with historical prices
				BalancingItem_Initialize;               !Calculate average discrepancy and apply to forecast years
				BalancingItem_Canada;                   !Calculate average discrepancy for Canada and apply to forecast years; CN_W->CN_E hist flow is also calculated here
				STEOFactors_Initialize;                 !Initialize STEO factors
				!RNG_Production_Run;
				if STEOBM=1 and STEONG=1 then
				  STEOTargets_Set;                        !Set STEO targets prior to model run
				  if STSCALNG then
				    !read STEO factors
				!     read from file "data\\NGSTEOFactors.txt";
				     read from file "input\\ngsteofactin.txt" in merge mode;
				  endif;
				endif;
				!ForceError;
				Check_FlowsAndCapacities;		!Check if any historical flows or capacities are missing/not matching
				Write_to_NEMS_History;
			}
			Comment: {
				"Initialize regions and other sets; read and transfer historical data"
			}
		}
		Procedure NGMM {
			Body: {
				!Preprocessing procedures
				!LinkHorizonToCalendar; !Create timetables
				Production_Run; !Transfer OGSM expected production for US supply regions for NA and AD gas
				Alaska_Subroutine_Run;	!Determines AK production and consumption
				EndUse_Consumption_Run;	!Calculates end use consumption for Lower 48 by sector using historical shares
				Canada_Run;	!Calculates and transfers Canada data to Main Arrays
				Mexico_Run;	!Calculates and transfers Mexico data to Main Arrays
				Storage_Run; !Assignes average storage values
				PlantFuel_Run; ! calculate plant fuel
				Calculate_Losses_Run; ! Calculate storage and distribution losses
				LNGExportUtilization_Run;	!Calculate utilization of LNG export capacity
				DefineCapacities; !Adjusts current pipeline capacity by state by arc (capacity expansion)
				RNG_Production_Run;
				if (STEOBM=1 and STEONG=1) then
				! if STSCALNG=0 then
				  if (STSCALNG=0 or ModelYear < LastSTEOYear) then   !temp for aeo2018
				   if ModelYear <= LastSTEOPhaseOutYear then
				      STEOFactors_Run;  !Calculate STEO factors
				      STEOScaling_Run;  !Align to STEO
				      if ModelYear<=LastSTEOYear then
				!        STEOFactors_Iterate;
				!        STEOFactorsCNW_Iterate;
				        STEOFactors_IterateCombined;
				      endif;
				   endif;
				 else
				   SteoConvergenceFlag:=0;
				   STEOScaling_Run;  !Align to STEO using read-in factors
				 endif;
				
				endif;
				
				!Run QP to solve for optimum natural gas transmission and distribution :)
				QP_Run; !Solve the Quadratic Program
				
				!Post-processing procedures
				
				
				Production_Postprocess; !Fill production arrays with solution results
				!Only run LNG export capacity expansion if determining builds in model and facility will be fully built before last model year
				if ( ( AIMMS_Standalone_Switch =1) and (LNG_FixedExports_Switch = 0) and 
					((NEMSmap_XYear(NEMSmap_MNXYRS(ModelYear))  + LNG_YrsUntilBuild) < (LastModelYear-LNG_PhaseInYrs)))then 
					LNGExportsCapExpansion_Run;
				endif;
				LNGAnnualExports_PostProcess; !Calculate Annual LNG Exports (assuming Switch is on for endogenous)
				Import_Export_Run;
				Flow_PostProcess; !Assign monthly and annual flows
				LeaseAndPlantFuel_PostProcess; ! Calculate lease and plant fuel loss
				Pipefuel_Postprocess; !Calculate pipefuel loss for reports
				TX_PostProcess; ! Some post processing routines to reaggregate the TX regions for publication
				EndUsePrice;   ! Set citygate and enduse prices
				Storage_PostProcess; !Calculate storage numbers for reports
				RegionalFlowsCapacity_PostProcess;
				
				!Report processing procedures
				
				Production_Report; !Calculate production parameters for reports
				
				AddedCapacity_Report; ! Report for Capacity Additions overtime
				
				!SetWellheadPrices; !Set wellhead prices for next year
				
				Flow_report; !Calculate flow parameters for reports
				
				Totals_Report; !Calculate totals for the US for report page;
				Debug_Report_Calculations;
			}
			Comment: {
				"This procedure will be run in both MainExecution and MainExecution_Standalone.
				It contains all procedures and code that will be done each year/iteration within NGTDM.
				This takes the place of \"Roll Horizon Once\" procedure."
			}
		}
		Procedure Write_to_NEMS_History {
			Body: {
				!Write NEMS Variables to MPBLK Common Block
				
				!Import and Export Arrays
				!For M4, 1= Canada total, 2 = Mexico total, 3= LNG total, 4 = sum
				NGTDMREP_NGIMPVOL(1,NEMSmap_MNUMYR(histyr)) :=Imports_Canada(histyr);
				NGTDMREP_NGIMPVOL(2,NEMSmap_MNUMYR(histyr)) :=Imports_Mexico(histyr);
				NGTDMREP_NGIMPVOL(3,NEMSmap_MNUMYR(histyr)) := Imports_LNG(histyr);
				NGTDMREP_NGIMPVOL(4,NEMSmap_MNUMYR(histyr)) :=sum (M4| M4 < Card(M4), NGTDMREP_NGIMPVOL(M4,NEMSmap_MNUMYR(histyr)));
				
				NGTDMREP_NGIMPPRC(1,NEMSmap_MNUMYR(histyr)) :=ImportPrice_Canada(histyr);
				NGTDMREP_NGIMPPRC(2,NEMSmap_MNUMYR(histyr)) :=ImportPrice_Mexico(histyr);
				NGTDMREP_NGIMPPRC(3,NEMSmap_MNUMYR(histyr)) :=ImportPrice_LNG(histyr);
				NGTDMREP_NGIMPPRC(4,NEMSmap_MNUMYR(histyr)) :=sum(M4| M4 < Card(M4), NGTDMREP_NGIMPPRC(M4, NEMSmap_MNUMYR(histyr))*NGTDMREP_NGIMPVOL(M4,NEMSmap_MNUMYR(histyr))/$
				                                                  NGTDMREP_NGIMPVOL(4,NEMSmap_MNUMYR(histyr)));
				
				NGTDMREP_NGEXPVOL(1,NEMSmap_MNUMYR(histyr)) :=Exports_Canada(histyr);
				NGTDMREP_NGEXPVOL(2,NEMSmap_MNUMYR(histyr)) :=Exports_Mexico(histyr);
				NGTDMREP_NGEXPVOL(3,NEMSmap_MNUMYR(histyr)) :=Exports_LNG(histyr);
				NGTDMREP_NGEXPVOL(4,NEMSmap_MNUMYR(histyr)) := sum (M4| M4 < Card(M4), NGTDMREP_NGEXPVOL(M4,NEMSmap_MNUMYR(histyr)));
				
				NGTDMREP_NGEXPPRC(1,NEMSmap_MNUMYR(histyr)) :=ExportPrice_Canada(histyr);
				NGTDMREP_NGEXPPRC(2,NEMSmap_MNUMYR(histyr)) :=ExportPrice_Mexico(histyr);
				NGTDMREP_NGEXPPRC(3,NEMSmap_MNUMYR(histyr)) :=ExportPrice_LNG (histyr);
				NGTDMREP_NGEXPPRC(4,NEMSmap_MNUMYR(histyr)) :=sum(M4| M4 < Card(M4), NGTDMREP_NGEXPPRC(M4, NEMSmap_MNUMYR(histyr))*NGTDMREP_NGEXPVOL(M4,NEMSmap_MNUMYR(histyr))/$
				                                                  NGTDMREP_NGEXPVOL(4,NEMSmap_MNUMYR(histyr)));
				
				
				!Fill in end-use prices
				MPBLK_PNGRS(MNUMCR, NEMSmap_MNUMYR(histyr)):= sum(r_cen, Price_Enduse(histyr, Sector_Residential, r_cen, ResidentialOption)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				                                                 Convert_TBtu_Bcf_NonUtility(histyr);
				MPBLK_PNGRS(MNUMCR, NEMSmap_MNUMYR(histyr)):= sum(r_cen |NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR), Price_Enduse(histyr, Sector_Residential, r_cen, ResidentialOption) )/
				                                                 Convert_TBtu_Bcf_NonUtility(histyr);
				MPBLK_PNGCM(MNUMCR, NEMSmap_MNUMYR(histyr)):= sum(r_cen, Price_Enduse(histyr, Sector_Commercial, r_cen, CommercialOption)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				                                                 Convert_TBtu_Bcf_NonUtility(histyr);
				 !Fix for STEO years that aren't in model                                                
				MPBLK_PNGCM(MNUMCR, NEMSmap_MNUMYR(FirstSTEOYear-1)):=  sum(r_cen |NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR), STEOTargetEndUsePrice(FirstSTEOYear-1, Sector_Commercial, r_cen) )/
				                                                Convert_TBtu_Bcf_NonUtility(FirstSTEOYear-1);
				MPBLK_PNGRS(MNUMCR, NEMSmap_MNUMYR(FirstSTEOYear-1)) := sum(r_cen |NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR), STEOTargetEndUsePrice(FirstSTEOYear-1, Sector_Residential, r_cen) )/
				                                                Convert_TBtu_Bcf_NonUtility(FirstSTEOYear-1);
				
				
				
				
				MPBLK_PNGIN(MNUMCR, NEMSmap_MNUMYR(histyr)):= sum(r_cen, Price_Enduse(histyr, Sector_Industrial, r_cen, IndustrialOption)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				                                                 Convert_TBtu_Bcf_NonUtility(histyr);
				
				NGTDMOUT_SPNGELGR(NNGEMM, NEMSmap_MNUMYR(histyr), M3):=sum(season |NEMSmap_M3_season(M3,season), Price_EnduseElectric(histyr, NNGEMM, season, ElectricOption))/
				                                                  Convert_TBtu_Bcf_Utility(histyr);
				!NGTDMOUT_SPNGELGR((card(NNGEMM), NEMSmap_MNUMYR(histyr), M3)):=AK_Price_EndUse(histyr, Sector_Electric)/
				!                                                  Convert_TBtu_Bcf_Utility(histyr);    
				
				NGTDMOUT_SPNGIN(MNUMCR, NEMSmap_MNUMYR(histyr), hmmseason) := sum(r_cen, Price_EnduseSeasonalIndustrial(histyr, r_cen, hmmseason) * NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR)) /
											Convert_TBtu_Bcf_NonUtility(histyr);
				
				MPBLK_PNGEL(MNUMCR, NEMSmap_MNUMYR(histyr)):=sum((NNGEMM,season,M3) |(NEMSmap_NNGEMM_CD(NNGEMM, MNUMCR) and NEMSmap_M3_season(M3,season)),
				                                                NGTDMOUT_SPNGELGR(NNGEMM, NEMSmap_MNUMYR(histyr), M3)*Electric_NNGEMM_Season(histyr,NNGEMM,season))/$
				                                                sum((NNGEMM,season, M3)| (NEMSmap_NNGEMM_CD(NNGEMM, MNUMCR) and NEMSmap_M3_season(M3,season)), Electric_NNGEMM_Season(histyr,NNGEMM,season));
				
				Copy_MPBLK_PNGEL(MNUMCR, NEMSmap_MNUMYR(histyr)) := sum(reg  |NEMSmap_reg_MNUMCR(reg, MNUMCR),  HistoricalAnnualEndUsePrice(histyr, Sector_Electric, reg) * HistoricalAnnualDemand(histyr, Sector_Electric, reg)) /$
											sum(reg |  NEMSmap_reg_MNUMCR(reg, MNUMCR),  HistoricalAnnualDemand(histyr, Sector_Electric, reg));
				
				Copy_MPBLK_PNGEL(TotalUS_MNUMCR, NEMSmap_MNUMYR(histyr)) := sum(MNUMCR, Copy_MPBLK_PNGEL(MNUMCR, NEMSmap_MNUMYR(histyr)) * QBLK_QNGEL(MNUMCR, NEMSmap_MNUMYR(histyr))) /$
												QBLK_QNGEL(TotalUS_MNUMCR, NEMSmap_MNUMYR(histyr));
				
				
				NGTDMOUT_PGFTRFV(MNUMCR,NEMSmap_MNUMYR(histyr)) := sum(r_cen, Price_EndUseTransportation(histyr, Fuel_CNG, Vehicle_Fleet, r_cen, TransportationOption(Fuel_CNG))*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				                                                 Convert_TBtu_Bcf_NonUtility(histyr);
				NGTDMOUT_PGFTRPV(MNUMCR,NEMSmap_MNUMYR(histyr)) := sum(r_cen, Price_EndUseTransportation(histyr, Fuel_CNG, Vehicle_Personal, r_cen, TransportationOption(Fuel_CNG))*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				                                                 Convert_TBtu_Bcf_NonUtility(histyr);
				NGTDMOUT_PGLTRFV(MNUMCR,NEMSmap_MNUMYR(histyr)) := sum(r_cen, Price_EndUseTransportation(histyr, Fuel_LNG, Vehicle_Fleet, r_cen, TransportationOption(Fuel_LNG))*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				                                                 Convert_TBtu_Bcf_NonUtility(histyr);
				NGTDMOUT_PGLTRPV(MNUMCR,NEMSmap_MNUMYR(histyr)) := sum(r_cen, Price_EndUseTransportation(histyr, Fuel_LNG, Vehicle_Personal, r_cen, TransportationOption(Fuel_LNG))*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				                                                 Convert_TBtu_Bcf_NonUtility(histyr);
				NGTDMOUT_PGFTRRAIL(M4,MNUMCR,NEMSmap_MNUMYR(histyr)) := sum(r_cen, Price_EndUseTransportation(histyr, Fuel_CNG, Vehicle_Rail, r_cen, TransportationOption(Fuel_CNG))*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				                                                 Convert_TBtu_Bcf_NonUtility(histyr);
				NGTDMOUT_PGLTRRAIL(M4,MNUMCR,NEMSmap_MNUMYR(histyr)) := sum(r_cen, Price_EndUseTransportation(histyr, Fuel_LNG, Vehicle_Rail, r_cen, TransportationOption(Fuel_LNG))*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				                                                 Convert_TBtu_Bcf_NonUtility(histyr);
				NGTDMOUT_PGFTRSHIP(M3,MNUMCR,NEMSmap_MNUMYR(histyr)) := sum(r_cen, Price_EndUseTransportation(histyr, Fuel_CNG, Vehicle_Marine, r_cen, TransportationOption(Fuel_CNG))*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				                                                 Convert_TBtu_Bcf_NonUtility(histyr);
				NGTDMOUT_PGLTRSHIP(M3,MNUMCR,NEMSmap_MNUMYR(histyr)) := sum(r_cen, Price_EndUseTransportation(histyr, Fuel_LNG, Vehicle_Marine, r_cen, TransportationOption(Fuel_CNG))*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				                                                 Convert_TBtu_Bcf_NonUtility(histyr);
				
				MPBLK_PNGTR(MNUMCR, NEMSmap_MNUMYR(histyr)):=(sum((fuel,vehicle,r_cen), Price_EndUseTransportation(histyr, fuel, vehicle, r_cen, TransportationOption(fuel))
					*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR)*NEMS_AnnualConsByMode(histyr, fuel, vehicle, r_cen))/$
					sum((fuel,vehicle,r_cen), NEMS_AnnualConsByMode(histyr, fuel, vehicle, r_cen)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR)))/Convert_TBtu_Bcf_NonUtility(histyr);
				
				!Set the totals separately
				MPBLK_PNGRS(TotalUS_MNUMCR, NEMSmap_MNUMYR(histyr)):= sum(MNUMC2, MPBLK_PNGRS(MNUMC2, NEMSmap_MNUMYR(histyr))*QBLK_QNGRS(MNUMC2,NEMSmap_MNUMYR(histyr)))/$
				                                                  QBLK_QNGRS(TotalUS_MNUMCR, NEMSmap_MNUMYR(histyr));
				MPBLK_PNGCM(TotalUS_MNUMCR, NEMSmap_MNUMYR(histyr)):= sum(MNUMC2, MPBLK_PNGCM(MNUMC2, NEMSmap_MNUMYR(histyr))*QBLK_QNGCM(MNUMC2,NEMSmap_MNUMYR(histyr)))/$
				                                                  QBLK_QNGCM(TotalUS_MNUMCR, NEMSmap_MNUMYR(histyr));
				MPBLK_PNGIN(TotalUS_MNUMCR, NEMSmap_MNUMYR(histyr)):= sum(MNUMC2, MPBLK_PNGIN(MNUMC2, NEMSmap_MNUMYR(histyr))*
				                                                (QBLK_QGFIN(MNUMC2,NEMSmap_MNUMYR(histyr))+QBLK_QGIIN(MNUMC2,NEMSmap_MNUMYR(histyr))))/$
				                                                  (QBLK_QGFIN(TotalUS_MNUMCR,NEMSmap_MNUMYR(histyr))+QBLK_QGIIN(TotalUS_MNUMCR,NEMSmap_MNUMYR(histyr)));
				MPBLK_PNGEL(TotalUS_MNUMCR, NEMSmap_MNUMYR(histyr)):=  sum((NNGEMM,season,M3) |NEMSmap_M3_season(M3,season),  
											NGTDMOUT_SPNGELGR(NNGEMM, NEMSmap_MNUMYR(histyr), M3)*Electric_NNGEMM_Season(histyr,NNGEMM,season))/$
				                                                        sum((NNGEMM,season, M3)| NEMSmap_M3_season(M3,season), Electric_NNGEMM_Season(histyr,NNGEMM,season));                                             
				NGTDMOUT_PGFTRFV(TotalUS_MNUMCR,NEMSmap_MNUMYR(histyr)) := sum(MNUMC2, NGTDMOUT_PGFTRFV(MNUMC2, NEMSmap_MNUMYR(histyr))*NGTDMOUT_QGFTRFV(MNUMC2,NEMSmap_MNUMYR(histyr)))/$
				                                                 NGTDMOUT_QGFTRFV(TotalUS_MNUMCR,NEMSmap_MNUMYR(histyr));
				NGTDMOUT_PGFTRPV(TotalUS_MNUMCR,NEMSmap_MNUMYR(histyr)) := sum(MNUMC2, NGTDMOUT_PGFTRPV(MNUMC2, NEMSmap_MNUMYR(histyr))*NGTDMOUT_QGFTRPV(MNUMC2,NEMSmap_MNUMYR(histyr)))/$
				                                                 NGTDMOUT_QGFTRPV(TotalUS_MNUMCR,NEMSmap_MNUMYR(histyr));
				NGTDMOUT_PGLTRFV(TotalUS_MNUMCR,NEMSmap_MNUMYR(histyr)) := sum(MNUMC2, NGTDMOUT_PGLTRFV(MNUMC2, NEMSmap_MNUMYR(histyr))*NGTDMOUT_QGLTRFV(MNUMC2,NEMSmap_MNUMYR(histyr)))/$
				                                                 NGTDMOUT_QGLTRFV(TotalUS_MNUMCR,NEMSmap_MNUMYR(histyr));
				NGTDMOUT_PGLTRPV(TotalUS_MNUMCR,NEMSmap_MNUMYR(histyr)) := sum(MNUMC2, NGTDMOUT_PGLTRPV(MNUMC2, NEMSmap_MNUMYR(histyr))*NGTDMOUT_QGLTRPV(MNUMC2,NEMSmap_MNUMYR(histyr)))/$
				                                                 NGTDMOUT_QGLTRPV(TotalUS_MNUMCR,NEMSmap_MNUMYR(histyr));
				NGTDMOUT_PGFTRRAIL(M4,TotalUS_MNUMCR,NEMSmap_MNUMYR(histyr)) := sum(MNUMC2, NGTDMOUT_PGFTRRAIL(M4,MNUMC2, NEMSmap_MNUMYR(histyr))*NGTDMOUT_QGFTRRAIL(M4,MNUMC2,NEMSmap_MNUMYR(histyr)))/$
				                                                 NGTDMOUT_QGFTRRAIL(M4,TotalUS_MNUMCR,NEMSmap_MNUMYR(histyr));
				NGTDMOUT_PGLTRRAIL(M4,TotalUS_MNUMCR,NEMSmap_MNUMYR(histyr)) := sum(MNUMC2, NGTDMOUT_PGFTRRAIL(M4,MNUMC2, NEMSmap_MNUMYR(histyr))*NGTDMOUT_QGFTRRAIL(M4,MNUMC2,NEMSmap_MNUMYR(histyr)))/$
				                                                 NGTDMOUT_QGFTRRAIL(M4,TotalUS_MNUMCR,NEMSmap_MNUMYR(histyr));
				NGTDMOUT_PGFTRSHIP(M3,TotalUS_MNUMCR,NEMSmap_MNUMYR(histyr)) := sum(MNUMC2, NGTDMOUT_PGFTRSHIP(M3,MNUMC2, NEMSmap_MNUMYR(histyr))*NGTDMOUT_QGFTRSHIP(M3,MNUMC2,NEMSmap_MNUMYR(histyr)))/$
				                                                 NGTDMOUT_QGFTRSHIP(M3,TotalUS_MNUMCR,NEMSmap_MNUMYR(histyr));
				NGTDMOUT_PGLTRSHIP(M3,TotalUS_MNUMCR,NEMSmap_MNUMYR(histyr)) := sum(MNUMC2, NGTDMOUT_PGLTRSHIP(M3,MNUMC2, NEMSmap_MNUMYR(histyr))*NGTDMOUT_QGLTRSHIP(M3,MNUMC2,NEMSmap_MNUMYR(histyr)))/$
				                                                 NGTDMOUT_QGLTRSHIP(M3,TotalUS_MNUMCR,NEMSmap_MNUMYR(histyr));
				
					!Fill in national number as average if no consumption exists (i.e. do not send back a zero)
				for ((M4,histyr)|NGTDMOUT_PGFTRRAIL(M4,TotalUS_MNUMCR,NEMSmap_MNUMYR(histyr)) =0) do
					NGTDMOUT_PGFTRRAIL(M4,TotalUS_MNUMCR,NEMSmap_MNUMYR(histyr)) := sum(MNUMCR, NGTDMOUT_PGFTRRAIL(M4,MNUMCR,NEMSmap_MNUMYR(histyr)))/$
						count(MNUMCR|NGTDMOUT_PGFTRRAIL(M4,MNUMCR,NEMSmap_MNUMYR(histyr)));
				endfor;
				
				for ((M4,histyr)|NGTDMOUT_PGLTRRAIL(M4,TotalUS_MNUMCR,NEMSmap_MNUMYR(histyr)) =0) do
					NGTDMOUT_PGLTRRAIL(M4,TotalUS_MNUMCR,NEMSmap_MNUMYR(histyr)) := sum(MNUMCR, NGTDMOUT_PGLTRRAIL(M4,MNUMCR,NEMSmap_MNUMYR(histyr)))/$
						count(MNUMCR|NGTDMOUT_PGLTRRAIL(M4,MNUMCR,NEMSmap_MNUMYR(histyr)));
				endfor;	
				
				for ((M3,histyr)|NGTDMOUT_PGFTRSHIP(M3,TotalUS_MNUMCR,NEMSmap_MNUMYR(histyr)) =0) do
					NGTDMOUT_PGFTRSHIP(M3,TotalUS_MNUMCR,NEMSmap_MNUMYR(histyr)) := sum(MNUMCR, NGTDMOUT_PGFTRSHIP(M3,MNUMCR,NEMSmap_MNUMYR(histyr)))/$
						count(MNUMCR|NGTDMOUT_PGFTRSHIP(M3,MNUMCR,NEMSmap_MNUMYR(histyr)));
				endfor;
				
				for ((M3,histyr)|NGTDMOUT_PGLTRSHIP(M3,TotalUS_MNUMCR,NEMSmap_MNUMYR(histyr)) =0) do
					NGTDMOUT_PGLTRSHIP(M3,TotalUS_MNUMCR,NEMSmap_MNUMYR(histyr)) := sum(MNUMCR, NGTDMOUT_PGLTRSHIP(M3,MNUMCR,NEMSmap_MNUMYR(histyr)))/$
						count(MNUMCR|NGTDMOUT_PGLTRSHIP(M3,MNUMCR,NEMSmap_MNUMYR(histyr)));
				endfor;
				
				
				MPBLK_PNGTR(TotalUS_MNUMCR, NEMSmap_MNUMYR(histyr)):=sum(MNUMC2, MPBLK_PNGTR(MNUMC2, NEMSmap_MNUMYR(histyr))*QBLK_QNGTR(MNUMC2,NEMSmap_MNUMYR(histyr)))/$
				                                                  QBLK_QNGTR(TotalUS_MNUMCR, NEMSmap_MNUMYR(histyr));
				
				MPBLK_PGFIN(MNUMCR, NEMSmap_MNUMYR(histyr)):= MPBLK_PNGIN(MNUMCR, NEMSmap_MNUMYR(histyr));
				MPBLK_PGIIN(MNUMCR, NEMSmap_MNUMYR(histyr)):= MPBLK_PNGIN(MNUMCR, NEMSmap_MNUMYR(histyr));
				
					!Set Electric Pricing variables
				NGTDMREP_NGSPOT_EMM(NNGEMM, NEMSmap_MNUMYR(histyr)) := sum(season, PriceSpotAnnualElectric(histyr, NNGEMM, season)*Electric_NNGEMM_Season(histyr,NNGEMM,season))/$
				                                           sum(season, Electric_NNGEMM_Season(histyr,NNGEMM,season));
				
				NGTDMREP_UDTAR(NNGEMM, NEMSmap_MNUMYR(histyr)) := AnnualPrice_EnduseElectric(histyr,NNGEMM)  - NGTDMREP_NGSPOT_EMM(NNGEMM, NEMSmap_MNUMYR(histyr));
				
				NGTDMOUT_PNGELGR(NNGEMM, NEMSmap_MNUMYR(histyr)):=sum(M3, NGTDMOUT_SPNGELGR(NNGEMM, NEMSmap_MNUMYR(histyr), M3)*UEFDOUT_SQNGELGR(NNGEMM,NEMSmap_MNUMYR(histyr),M3))/$
				                                                sum(M3, UEFDOUT_SQNGELGR(NNGEMM,NEMSmap_MNUMYR(histyr),M3));
				
				!NGTDMOUT_PNGELGR(card(NNGEMM), NEMSmap_MNUMYR(histyr)):=AK_Price_EndUse(histyr, Sector_Electric)/Convert_TBtu_Bcf_Utility(histyr); 
				
				       !Set citygate price                                          
				NGTDMREP_ACGPR_RESCOM(M12, NEMSmap_MNUMYR(histyr)) := sum(r_cen|map_M12_CensusRegion(M12,r_cen) , PriceCitygateAnnualforMarkups(histyr, Sector_Residential,r_cen, Option1));
				
				!Capacity variables to fill
				for ((M12,M6)|Exists((r_flow,r_flow1)|NEMSmap_NGFLOWS_FlowRegions_M12_M6(r_flow,r_flow1,M12,M6))) do
					NGRPT_NGCAPS(M12,M6,NEMSmap_MNUMYR(histyr)) := sum((r_flow,r_flow1)|NEMSmap_NGFLOWS_FlowRegions_M12_M6(r_flow,r_flow1,M12,M6),
										CapRegional(histyr,r_flow,r_flow1));
				endfor;	
				
				!OldRegions
				!for ((M12,M6)|Exists((r_og,r_og1)|NEMSmap_NGFLOWS_OilGasRegions_M12_M6(r_og,r_og1,M12,M6))) do
				!	NGRPT_NGCAPS(M12,M6,NEMSmap_MNUMYR(histyr)) := sum((r_og,r_og1)|NEMSmap_NGFLOWS_OilGasRegions_M12_M6(r_og,r_og1,M12,M6),
				!						CapacityRegional(histyr,r_og,r_og1));
				!endfor;	
				
				!Flow variables to fill
				for ((M12,M6)|Exists((r_flow,r_flow1)|NEMSmap_NGFLOWS_FlowRegions_M12_M6(r_flow,r_flow1,M12,M6))) do
					NGRPT_NGFLOWS(M12,M6,NEMSmap_MNUMYR(histyr)) := sum((r_flow,r_flow1)|NEMSmap_NGFLOWS_FlowRegions_M12_M6(r_flow,r_flow1,M12,M6),
										FlowRegional(histyr,r_flow,r_flow1));
				endfor;						
				
				!Capacity variables to fill
				for ((M12,M6)|Exists((r_flow,r_flow1)|NEMSmap_NGFLOWS_FlowRegions_M12_M6(r_flow,r_flow1,M12,M6))) do
					NGRPT_NGCAPS(M12,M6,NEMSmap_MNUMYR(histyr)) := sum((r_flow,r_flow1)|NEMSmap_NGFLOWS_FlowRegions_M12_M6(r_flow,r_flow1,M12,M6),
										CapRegional(histyr,r_flow,r_flow1));
				endfor;	
				
				!OldRegions
				!for ((M12,M6)|Exists((r_og,r_og1)|NEMSmap_NGFLOWS_OilGasRegions_M12_M6(r_og,r_og1,M12,M6))) do
				!	NGRPT_NGFLOWS(M12,M6,NEMSmap_MNUMYR(histyr)) := sum((r_og,r_og1)|NEMSmap_NGFLOWS_OilGasRegions_M12_M6(r_og,r_og1,M12,M6),
				!						FlowsRegional(histyr,r_og,r_og1));
				!endfor;						
				
				!for ((M12,M6)|Exists(bx|NEMSmap_NGFLOWS_BX(bx,M12,M6))) do
				!	NGRPT_NGFLOWS(M12,M6,NEMSmap_MNUMYR(histyr)) := sum(bx|NEMSmap_NGFLOWS_BX(bx,M12,M6), AnnualImports(histyr,bx));
				!endfor;
				
				!for ((M12,M6)|Exists(bx|Correct_NGFLOWS(M12,M6,BX))) do
				!	NGRPT_NGFLOWS(M12,M6,NEMSmap_MNUMYR(histyr))  -= sum(bx|Correct_NGFLOWS(M12,M6,BX), AnnualImports(histyr,bx));
				!endfor;
				
				!LNG Exports and capacities
				NGTDMREP_NALNGEXP(LNGTER,NEMSmap_MNUMYR(histyr)) := sum(lngexp_l48 | NEMSmap_LNGTER_lngexp(lngter,lngexp_l48), AnnualLNGExports(histyr,lngexp_l48));
				NGTDMREP_NALNGEXP(10,NEMSmap_MNUMYR(histyr)) := AnnualLNGExports(histyr,CanadaWest);
				NGTDMREP_NALNGEXP(Card(LNGTER),NEMSmap_MNUMYR(histyr)) := AnnualLNGExports(histyr,AKState);
				NGTDMREP_NALNGEXP(Card(LNGTER),NEMSmap_MNUMYR(futyear)) := AnnualLNGExports(futyear,AKState);
				
				 !Natural Gas Production and Prices                                             
				
				!The Henry Hub prices ( 87$/MMBtu)
				NGTDMREP_OGHHPRNG(NEMSmap_MNUMYR(histyr)) := HenryHubPrice(histyr)/Convert_TBtu_Bcf(ModelYear);
				
				!Wellhead Price by OGSM district
				NGTDMREP_OGPRCNG(OGDIST, NEMSmap_MNUMYR(histyr)) := sum(s_ogsm | NEMSmap_OGDIST_SupplyNode(OGDIST, s_ogsm),  WellhdPrice(histyr, Supply_NA, s_ogsm));
						!Set wellhead price for ALASKA to fill variable by OGDIST
				NGTDMREP_OGPRCNG(OGDIST, NEMSmap_MNUMYR(histyr)) := $ sum(ak_s,  AK_Citygate(histyr)*NEMSmap_OGDIST_SupplyNode(OGDIST, ak_s));
				!NA production
				
				!NA + AD production by MNUMOR region
				!NGTDMREP_OGPRDNG(MNUMOR, NEMSmap_MNUMYR(histyr)) := sum(l48s | NEMSmap_SupplyNode_MNUMOR(l48s,MNUMOR), (AnnualSupply(histyr, Supply_AD, l48s)+
				                                                   !              AnnualSupply(histyr, Supply_NA, l48s)));
				!NGTDMREP_OGPRDNG('11',NEMSmap_MNUMYR(histyr)) := 0.00000001;
				!NGTDMREP_OGPRDNG('12',NEMSmap_MNUMYR(histyr)) := AK_Production(histyr,'AK_N') + AK_Production(histyr,'AK_ANGTS');
				!NGTDMREP_OGPRDNG('13',NEMSmap_MNUMYR(histyr)) := AK_Production(histyr,'AK_S');
				!NGTDMREP_OGPRDNG(TotalUS_MNUMOR, NEMSmap_MNUMYR(histyr)) := sum(MNUMOR| MNUMOR<TotalUS_MNUMOR, NGTDMREP_OGPRDNG(MNUMOR, NEMSmap_MNUMYR(histyr)));
				
				!!national total across all three categories (coal, oil, other) of supplemental fuel produced
				! temporarily adding RNG to supplemental.
				NGTDMREP_OGPRSUP(NEMSmap_MNUMYR(histyr)) := sum((sng,l48), AnnualSupply(histyr, sng, l48));
				
				! National RNG Production
				NGTDMREP_OGPRRNG(NEMSmap_MNUMYR(histyr)) := sum(l48, ActualProductionAnnual(histyr, Supply_RNG, l48));
				
				! Carbon offset by RNG via LCFS
				NGTDMREP_LCFSRNGOS(NEMSmap_MNUMYR(histyr)) := AnnualRNGCarbonOffset(histyr);
				
				!!SNG-coal
				NGTDMREP_OGSUPGAS(1,MNUMCR, NEMSmap_MNUMYR(histyr)) := sum((r_cen,l48) |  map_State_CensusRegion(l48, r_cen) and NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR),
				                                                                  ActualProductionAnnual(histyr, Supply_SNGcoal, l48));
				NGTDMREP_OGSUPGAS(1, TotalUS_MNUMCR, NEMSmap_MNUMYR(histyr)) := sum(l48, AnnualSupply(histyr, Supply_SNGcoal, l48));
				!!SNG-oil+other
				NGTDMREP_OGSUPGAS(2, MNUMCR, NEMSmap_MNUMYR(histyr)) := sum((sng,l48,r_cen) | sng in (SNG_-Supply_SNGcoal) and map_State_CensusRegion(l48, r_cen) and NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR),
				                                                        ActualProductionAnnual(histyr, sng, l48));
				NGTDMREP_OGSUPGAS(2, TotalUS_MNUMCR, NEMSmap_MNUMYR(histyr)) := sum((sng,l48) | sng in (SNG_-Supply_SNGcoal), AnnualSupply(histyr, sng, l48));
				
					!Wellhead prices by Oil and Gas Region
				NGTDMREP_OGWPRNG(MNUMOR, NEMSmap_MNUMYR(histyr)) := sum(l48s | NEMSmap_SupplyNode_MNUMOR(l48s,MNUMOR), WellhdPrice(histyr, Supply_NA, l48s)*(AnnualSupply(ModelYear, Supply_AD, l48s)+
				                                                                 AnnualSupply(ModelYear, Supply_NA, l48s)))/$
				                                                                  NGTDMREP_OGPRDNG(MNUMOR, NEMSmap_MNUMYR(histyr));
					!Fill in for Alaska
				NGTDMREP_OGWPRNG(NEMSmap_MNUMOR_AK(r_ak),NEMSmap_MNUMYR(histyr)) := AK_Citygate(histyr);
				NGTDMREP_OGWPRNG('11',NEMSmap_MNUMYR(histyr)) := AK_Citygate(histyr);	
				
					! Fill in if zero
				for ((MNUMOR,histyr)|NGTDMREP_OGWPRNG(MNUMOR, NEMSmap_MNUMYR(histyr)) =0) do
					NGTDMREP_OGWPRNG(MNUMOR, NEMSmap_MNUMYR(histyr)) := sum(l48s | NEMSmap_SupplyNode_MNUMOR(l48s,MNUMOR), WellhdPrice(histyr, Supply_NA, l48s))/$
												count(l48s | NEMSmap_SupplyNode_MNUMOR(l48s,MNUMOR));
				endfor;	
				
					!Average l48 price
				NGTDMREP_OGWPRNG(TotalUS_MNUMOR, NEMSmap_MNUMYR(histyr)) := sum(l48_MNUMOR, NGTDMREP_OGPRDNG(l48_MNUMOR, NEMSmap_MNUMYR(histyr))*NGTDMREP_OGWPRNG(l48_MNUMOR, NEMSmap_MNUMYR(histyr)))/$
				                                                                sum(l48_MNUMOR, NGTDMREP_OGPRDNG(l48_MNUMOR, NEMSmap_MNUMYR(histyr)));
				
				! World LNG Price history
				NGTDMREP_PINTLNG(M2,NEMSmap_MNUMYR(histyr)) := sum( d_lng, HistoricalLNGPrice(histyr,d_lng)*NEMSmap_M2_d_lng(M2,d_lng));
				
				!Write Consumption variables to common block
				
					!Fuel used for liquefaction
				QMORE_QNGLQ(MNUMCR,NEMSmap_MNUMYR(histyr)) := sum((lngexp,r_cen)|(map_State_CensusRegion(lngexp,r_cen) and NEMSmap_MNUMCR_CensusReg(r_cen,MNUMCR)),
				                    LNGFuelForLiquefaction(histyr,lngexp)) * Convert_TBtu_Bcf(histyr);
				QMORE_QNGLQ(TotalUS_MNUMCR, NEMSmap_MNUMYR(histyr)) := sum(MNUMC2, QMORE_QNGLQ(MNUMC2,NEMSmap_MNUMYR(histyr)));
				
				!QBLK_QLPIN
				QBLK_QLPIN(MNUMCR, NEMSmap_MNUMYR(histyr)) := sum((r_cen,state) |  map_State_CensusRegion(state, r_cen) and NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR),
				                                                LeaseAndPlantFuelAnnual(histyr,state)) * Convert_TBtu_Bcf(histyr);
				QBLK_QLPIN(TotalUS_MNUMCR, NEMSmap_MNUMYR(histyr)) := sum(MNUMC2, QBLK_QLPIN(MNUMC2,NEMSmap_MNUMYR(histyr)));
				
				!QBLK_QGPTR
				QBLK_QGPTR(MNUMCR, NEMSmap_MNUMYR(histyr)) := sum((r_cen,state) |  map_State_CensusRegion(state, r_cen) and NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR),
				                                                 PipeFuelLossAnnual(histyr, state)) * Convert_TBtu_Bcf(histyr);
				QBLK_QGPTR(TotalUS_MNUMCR, NEMSmap_MNUMYR(histyr)) := sum(MNUMC2, QBLK_QGPTR(MNUMC2,NEMSmap_MNUMYR(histyr)));
				!Total US Balancing item (used in table 107 of GraphNems???)
				NGTDMREP_NGBAL (NEMSmap_MNUMYR(histyr)) := TotalBalanceItem(histyr);
				
				
				
				
				!Supply Curve parameters to send to Electricity Model
				
				NGTDMREP_NGSCRV_Q0(NEMSmap_MNUMYR(histyr)):= sum (OGDIST|Exists(s_ogsm, NEMSmap_OGDIST_SupplyNode(OGDIST, s_ogsm)) , OGSMOUT_OGENAGPRD(OGDIST,card(GASTYP),NEMSmap_MNUMYR(histyr)));
				!		-sum ((OGDIST,r_ak)|NEMSmap_OGDIST_r_ak(OGDIST,r_ak) , OGSMOUT_OGENAGPRD(OGDIST,card(GASTYP),NEMSmap_MNUMYR(ModelYear)));
				NGTDMREP_NGSCRV_Q(NEMSmap_MNUMYR(histyr)):= sum (OGDIST|Exists(s_ogsm, NEMSmap_OGDIST_SupplyNode(OGDIST, s_ogsm)), OGSMOUT_OGRNAGPRD(OGDIST,card(GASTYP),NEMSmap_MNUMYR(histyr)));
				!		-sum ((OGDIST,r_ak)|NEMSmap_OGDIST_r_ak(OGDIST,r_ak) , OGSMOUT_OGRNAGPRD(OGDIST,card(GASTYP),NEMSmap_MNUMYR(ModelYear)));
				
				NGTDMREP_NGSCRV_P(NEMSmap_MNUMYR(histyr)):= sum (OGDIST|Exists(s_ogsm, NEMSmap_OGDIST_SupplyNode(OGDIST, s_ogsm)), 
						OGSMOUT_OGRNAGPRD(OGDIST,card(GASTYP),NEMSmap_MNUMYR(histyr))*NGTDMREP_OGPRCNG(OGDIST,NEMSmap_MNUMYR(histyr))) /$
						NGTDMREP_NGSCRV_Q(NEMSmap_MNUMYR(ModelYear));
				NGTDMREP_NGSCRV_P0(NEMSmap_MNUMYR(histyr)):= sum (OGDIST|Exists(s_ogsm, NEMSmap_OGDIST_SupplyNode(OGDIST, s_ogsm)), 
						OGSMOUT_OGENAGPRD(OGDIST,card(GASTYP),NEMSmap_MNUMYR(histyr))*NGTDMREP_OGPRCNG(OGDIST,NEMSmap_MNUMYR(histyr-1))*STEOWellhdPriceFactor(histyr)) /$
						NGTDMREP_NGSCRV_Q0(NEMSmap_MNUMYR(histyr));
				
				!NGTDMREP_NGSCRV_P(NEMSmap_MNUMYR(ModelYear)):= (sum (OGDIST, OGSMOUT_OGRNAGPRD(OGDIST,card(GASTYP),NEMSmap_MNUMYR(ModelYear))*NGTDMREP_OGPRCNG(OGDIST,NEMSmap_MNUMYR(ModelYear))) -
				!		sum ((OGDIST,r_ak)|NEMSmap_OGDIST_r_ak(OGDIST,r_ak) , OGSMOUT_OGRNAGPRD(OGDIST,card(GASTYP),NEMSmap_MNUMYR(ModelYear))*NGTDMREP_OGPRCNG(OGDIST,NEMSmap_MNUMYR(ModelYear)))) /$
				!		NGTDMREP_NGSCRV_Q(NEMSmap_MNUMYR(ModelYear));
				!NGTDMREP_NGSCRV_P0(NEMSmap_MNUMYR(ModelYear)):= ((sum (OGDIST, OGSMOUT_OGENAGPRD(OGDIST,card(GASTYP),NEMSmap_MNUMYR(ModelYear))*NGTDMREP_OGPRCNG(OGDIST,NEMSmap_MNUMYR(ModelYear-1))) -
				!		sum ((OGDIST,r_ak)|NEMSmap_OGDIST_r_ak(OGDIST,r_ak) , OGSMOUT_OGENAGPRD(OGDIST,card(GASTYP),NEMSmap_MNUMYR(ModelYear))*NGTDMREP_OGPRCNG(OGDIST,NEMSmap_MNUMYR(ModelYear-1)))) /$
				!		NGTDMREP_NGSCRV_Q0(NEMSmap_MNUMYR(ModelYear)))*STEOWellhdPriceFactor(ModelYear);
				!NGTDMREP_NGSCRV_P0(NEMSmap_MNUMYR(ModelYear)):= NGTDMREP_NGSCRV_P(NEMSmap_MNUMYR(ModelYear-1));
				
				
				NGTDMREP_NGSCRV_MAX (NEMSmap_MNUMYR(histyr)) :=  NGTDMREP_NGSCRV_Q0 (NEMSmap_MNUMYR(histyr))* (1 + Parameter_Supcrv(Supply_NA,last(step),last(n)));
				NGTDMREP_NGSCRV_MIN (NEMSmap_MNUMYR(histyr)) :=  NGTDMREP_NGSCRV_Q0 (NEMSmap_MNUMYR(histyr))* (1 + Parameter_Supcrv(Supply_NA,first(step),last(n)));
				
				NGTDMREP_NGSCRV_PER('1') := Parameter_Supcrv(Supply_NA,last(step),first(n));
				NGTDMREP_NGSCRV_PER('2') := Parameter_Supcrv(Supply_NA,last(step),nth(n,2));
				
				NGTDMREP_NGSCRV_ELAS('1') := Parameter_SupElasticity(Supply_NA,first(step),last(n));
				NGTDMREP_NGSCRV_ELAS('2') := Parameter_SupElasticity(Supply_NA,first(step),nth(n,2));
				NGTDMREP_NGSCRV_ELAS('3') := Parameter_SupElasticity(Supply_NA,first(step),first(n));
				NGTDMREP_NGSCRV_ELAS('4') := Parameter_SupElasticity(Supply_NA,last(step),nth(n,2));
				NGTDMREP_NGSCRV_ELAS('5') := Parameter_SupElasticity(Supply_NA,last(step),last(n));
				
				if ( ElectricOption=1) then
					if (Factor_EL = 0) then
						NGTDMREP_EL_MRKUP_BETA(M3) :=0;
					else
						NGTDMREP_EL_MRKUP_BETA(M3) :=0;
					endif;
				elseif ( ElectricOption=2) then
					NGTDMREP_EL_MRKUP_BETA(M3) :=0;
				elseif ( ElectricOption=3) then
					NGTDMREP_EL_MRKUP_BETA(M3) :=sum(season| NEMSmap_M3_season(M3,season),PAR1_EL(season, ElectricOption));
				endif;
			}
			Comment: {
				"All overwrites of NEMS variables is done in this procedure.
				This procedure is run in MainExecution after all processing (but before case saving)."
			}
		}
		Procedure Write_to_NEMS_LNGExports {
			Body: {
				NGTDMREP_NALNGEXP(LNGTER,NEMSmap_MNUMYR(futyear)) := sum(lngexp_l48 | NEMSmap_LNGTER_lngexp(lngter,lngexp_l48),LNG_ExportCapacity(futyear,lngexp_l48));
				NGTDMREP_NALNGEXP(10,NEMSmap_MNUMYR(futyear)) := LNG_ExportCapacity(futyear,CanadaWest);
				NGTDMREP_NALNGEXP(Card(LNGTER),NEMSmap_MNUMYR(futyear)) := LNG_ExportCapacity(futyear,AKState);
				
				!NGTDMREP_PTRANSNG !One of these should go !Currently divide by 2 because LA/TX and MD/GA are doubling up spots; change with lngter dimensions
				!NGTDMREP_PUSNG !One of these should go
				
				
				
				NGTDMREP_PTRANSNG(M2,LNGTER,NEMSmap_MNUMYR(ModelYear)):= sum((lngexp_l48,d_lng)|NEMSmap_LNGTER_lngexp(lngter,lngexp_l48) and NEMSmap_M2_d_lng(M2,d_lng),
				                                                          LNG_TransCost(lngexp_l48,d_lng));
				NGTDMREP_PTRANSNG(M2,Card(LNGTER),NEMSmap_MNUMYR(ModelYear)):= sum(d_lng, LNG_AKTransCost(d_lng)*NEMSmap_M2_d_lng(M2,d_lng));
				
				!NGTDMREP_PTRANSNG(M2,LNGTER,NEMSmap_MNUMYR(ModelYear)):= sum((lngexp_l48,d_lng)|NEMSmap_LNGTER_lngexp(lngter,lngexp_l48) and NEMSmap_M2_d_lng(M2,d_lng),
				 !                                                         USLNGTotalCost(ModelYear,lngexp_l48,d_lng))/2;
				!NGTDMREP_PTRANSNG(M2,Card(LNGTER),NEMSmap_MNUMYR(ModelYear)):= sum(d_lng, AKLNGTotalCost(ModelYear,d_lng)*NEMSmap_M2_d_lng(M2,d_lng));
				!NGTDMREP_PUSNG(LNGTER,NEMSmap_MNUMYR(ModelYear)) :=0;
			}
		}
		Procedure Write_to_NEMS {
			Body: {
				!Write NEMS Variables to MPBLK Common Block
				
				!Send Canada production (and prices? and LNG?) back to OGSM
				!TAKE CN_W OUT OF LNG_QP
				OGSMOUT_CNRNAGPRD(1, NEMSmap_MNUMYR(ModelYear)) :=  ActualProductionAnnual(ModelYear, Supply_NA, CanadaEast);
				OGSMOUT_CNRNAGPRD(2, NEMSmap_MNUMYR(ModelYear)) :=  ActualProductionAnnual(ModelYear, Supply_NA, CanadaWest);
				OGSMOUT_OGCNPPRD(1, NEMSmap_MNUMYR(ModelYear)) :=   WellhdPrice_Soln(ModelYear, Supply_NA,CanadaEast);
				OGSMOUT_OGCNPPRD(2, NEMSmap_MNUMYR(ModelYear)) :=  WellhdPrice_Soln(ModelYear, Supply_NA, CanadaWest);
				
				
				!Import and Export Arrays
				!For M4, 1= Canada total, 2 = Mexico total, 3= LNG total, 4 = sum
				NGTDMREP_NGIMPVOL(1,NEMSmap_MNUMYR(ModelYear)) :=Imports_Canada(ModelYear);
				NGTDMREP_NGIMPVOL(2,NEMSmap_MNUMYR(ModelYear)) :=Imports_Mexico(ModelYear);
				NGTDMREP_NGIMPVOL(3,NEMSmap_MNUMYR(ModelYear)) := sum (state, ActualProductionAnnual(ModelYear, Supply_LNG, state));
				NGTDMREP_NGIMPVOL(4,NEMSmap_MNUMYR(ModelYear)) :=sum (M4| M4 < Card(M4), NGTDMREP_NGIMPVOL(M4,NEMSmap_MNUMYR(ModelYear)));
				
				NGTDMREP_NGIMPPRC(1,NEMSmap_MNUMYR(ModelYear)) :=ImportPrice_Canada(ModelYear);
				NGTDMREP_NGIMPPRC(2,NEMSmap_MNUMYR(ModelYear)) :=ImportPrice_Mexico(ModelYear);
				NGTDMREP_NGIMPPRC(3,NEMSmap_MNUMYR(ModelYear)) :=ImportPrice_LNG(ModelYear);
				NGTDMREP_NGIMPPRC(4,NEMSmap_MNUMYR(ModelYear)) :=sum(M4| M4 < Card(M4), NGTDMREP_NGIMPPRC(M4, NEMSmap_MNUMYR(ModelYear))*NGTDMREP_NGIMPVOL(M4,NEMSmap_MNUMYR(ModelYear))/$
				                                                  NGTDMREP_NGIMPVOL(4,NEMSmap_MNUMYR(ModelYear)));
				
				NGTDMREP_NGEXPVOL(1,NEMSmap_MNUMYR(ModelYear)) :=Exports_Canada(ModelYear);
				NGTDMREP_NGEXPVOL(2,NEMSmap_MNUMYR(ModelYear)) :=Exports_Mexico(ModelYear);
				NGTDMREP_NGEXPVOL(3,NEMSmap_MNUMYR(ModelYear)) :=sum(lngexp_l48, AnnualLNGExports(ModelYear,lngexp_l48)) + AnnualLNGExports(ModelYear,AKState);
				NGTDMREP_NGEXPVOL(4,NEMSmap_MNUMYR(ModelYear)) := sum (M4| M4 < Card(M4), NGTDMREP_NGEXPVOL(M4,NEMSmap_MNUMYR(ModelYear)));
				
				NGTDMREP_NGEXPPRC(1,NEMSmap_MNUMYR(ModelYear)) :=ExportPrice_Canada(ModelYear);
				NGTDMREP_NGEXPPRC(2,NEMSmap_MNUMYR(ModelYear)) :=ExportPrice_Mexico(ModelYear);
				NGTDMREP_NGEXPPRC(3,NEMSmap_MNUMYR(ModelYear)) :=ExportPrice_LNG (ModelYear);
				NGTDMREP_NGEXPPRC(4,NEMSmap_MNUMYR(ModelYear)) :=sum(M4| M4 < Card(M4), NGTDMREP_NGEXPPRC(M4, NEMSmap_MNUMYR(ModelYear))*NGTDMREP_NGEXPVOL(M4,NEMSmap_MNUMYR(ModelYear))/$
				                                                  NGTDMREP_NGEXPVOL(4,NEMSmap_MNUMYR(ModelYear)));
				
				!Fill in citygate and end-use prices.
				
					!Citygate price
				NGTDMREP_ACGPR_RESCOM(M12, NEMSmap_MNUMYR(ModelYear)) := sum(r_cen|map_M12_CensusRegion(M12,r_cen) , PriceCitygateAnnualforMarkups(ModelYear, Sector_Residential,r_cen, Option1));
				
					!By census region
				MPBLK_PNGRS(MNUMCR, NEMSmap_MNUMYR(ModelYear)):= sum(r_cen, Price_Enduse(ModelYear, Sector_Residential, r_cen, ResidentialOption)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				                                                 Convert_TBtu_Bcf_NonUtility(ModelYear);
				MPBLK_PNGCM(MNUMCR, NEMSmap_MNUMYR(ModelYear)):= sum(r_cen, Price_Enduse(ModelYear, Sector_Commercial, r_cen, CommercialOption)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				                                                 Convert_TBtu_Bcf_NonUtility(ModelYear);
				MPBLK_PNGIN(MNUMCR, NEMSmap_MNUMYR(ModelYear)):= sum(r_cen, Price_Enduse(ModelYear, Sector_Industrial, r_cen, IndustrialOption)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				                                                 Convert_TBtu_Bcf_NonUtility(ModelYear);
				
				NGTDMOUT_SPNGELGR(NNGEMM, NEMSmap_MNUMYR(ModelYear), M3):=sum(season, Price_EnduseElectric(ModelYear, NNGEMM, season, ElectricOption)*NEMSmap_M3_season(M3,season))/
				                                                  Convert_TBtu_Bcf_Utility(ModelYear);
				NGTDMOUT_SPNGELGR((card(NNGEMM), NEMSmap_MNUMYR(ModelYear), M3)):=AK_Price_EndUse(ModelYear, Sector_Electric)/
				                                                  Convert_TBtu_Bcf_Utility(ModelYear);    
				
				NGTDMOUT_SPNGIN(MNUMCR, NEMSmap_MNUMYR(ModelYear), hmmseason) := sum(r_cen, Price_EnduseSeasonalIndustrial(ModelYear, r_cen, hmmseason) * NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR)) /
											Convert_TBtu_Bcf_NonUtility(ModelYear);
				
				MPBLK_PNGEL(MNUMCR, NEMSmap_MNUMYR(ModelYear)):=sum((NNGEMM,M3), NGTDMOUT_SPNGELGR(NNGEMM, NEMSmap_MNUMYR(ModelYear), M3)*UEFDOUT_SQNGELGR(NNGEMM,NEMSmap_MNUMYR(ModelYear),M3)*
				                                                NEMSmap_NNGEMM_CD(NNGEMM, MNUMCR))/$
				                                                sum((NNGEMM,M3), UEFDOUT_SQNGELGR(NNGEMM,NEMSmap_MNUMYR(ModelYear),M3)* NEMSmap_NNGEMM_CD(NNGEMM, MNUMCR));
				
				NGTDMOUT_PGFTRFV(MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(r_cen, Price_EndUseTransportation(ModelYear, Fuel_CNG, Vehicle_Fleet, r_cen, TransportationOption(Fuel_CNG))*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				                                                 Convert_TBtu_Bcf_NonUtility(ModelYear);
				NGTDMOUT_PGFTRPV(MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(r_cen, Price_EndUseTransportation(ModelYear, Fuel_CNG, Vehicle_Personal, r_cen, TransportationOption(Fuel_CNG))*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				                                                 Convert_TBtu_Bcf_NonUtility(ModelYear);
				NGTDMOUT_PGLTRFV(MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(r_cen, Price_EndUseTransportation(ModelYear, Fuel_LNG, Vehicle_Fleet, r_cen, TransportationOption(Fuel_LNG))*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				                                                 Convert_TBtu_Bcf_NonUtility(ModelYear);
				NGTDMOUT_PGLTRPV(MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(r_cen, Price_EndUseTransportation(ModelYear, Fuel_LNG, Vehicle_Personal, r_cen, TransportationOption(Fuel_LNG))*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				                                                 Convert_TBtu_Bcf_NonUtility(ModelYear);
				NGTDMOUT_PGFTRRAIL(M4,MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(r_cen, Price_EndUseTransportation(ModelYear, Fuel_CNG, Vehicle_Rail, r_cen, TransportationOption(Fuel_CNG))*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				                                                 Convert_TBtu_Bcf_NonUtility(ModelYear);
				NGTDMOUT_PGLTRRAIL(M4,MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(r_cen, Price_EndUseTransportation(ModelYear, Fuel_LNG, Vehicle_Rail, r_cen, TransportationOption(Fuel_LNG))*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				                                                 Convert_TBtu_Bcf_NonUtility(ModelYear);
				NGTDMOUT_PGFTRSHIP(M3,MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(r_cen, Price_EndUseTransportation(ModelYear, Fuel_CNG, Vehicle_Marine, r_cen, TransportationOption(Fuel_CNG))*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				                                                 Convert_TBtu_Bcf_NonUtility(ModelYear);
				NGTDMOUT_PGLTRSHIP(M3,MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(r_cen, Price_EndUseTransportation(ModelYear, Fuel_LNG, Vehicle_Marine, r_cen, TransportationOption(Fuel_LNG))*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				                                                 Convert_TBtu_Bcf_NonUtility(ModelYear);
				MPBLK_PNGTR(MNUMCR, NEMSmap_MNUMYR(ModelYear)):=(sum((fuel,vehicle,r_cen) | NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR),
				        Price_EndUseTransportation(ModelYear, fuel, vehicle, r_cen, TransportationOption(fuel))*NEMS_AnnualConsByMode(ModelYear, fuel, vehicle, r_cen))/$
					sum((fuel,vehicle,r_cen) | NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR), NEMS_AnnualConsByMode(ModelYear, fuel, vehicle, r_cen)))/Convert_TBtu_Bcf_NonUtility(ModelYear) ;
				
					!Set the totals separately
				MPBLK_PNGRS(TotalUS_MNUMCR, NEMSmap_MNUMYR(ModelYear)):= sum(MNUMC2, MPBLK_PNGRS(MNUMC2, NEMSmap_MNUMYR(ModelYear))*QBLK_QNGRS(MNUMC2,NEMSmap_MNUMYR(ModelYear)))/$
				                                                  QBLK_QNGRS(TotalUS_MNUMCR, NEMSmap_MNUMYR(ModelYear));
				MPBLK_PNGCM(TotalUS_MNUMCR, NEMSmap_MNUMYR(ModelYear)):= sum(MNUMC2, MPBLK_PNGCM(MNUMC2, NEMSmap_MNUMYR(ModelYear))*QBLK_QNGCM(MNUMC2,NEMSmap_MNUMYR(ModelYear)))/$
				                                                  QBLK_QNGCM(TotalUS_MNUMCR, NEMSmap_MNUMYR(ModelYear));
				MPBLK_PNGIN(TotalUS_MNUMCR, NEMSmap_MNUMYR(ModelYear)):= sum(MNUMC2, MPBLK_PNGIN(MNUMC2, NEMSmap_MNUMYR(ModelYear))*
				                                                (QBLK_QGFIN(MNUMC2,NEMSmap_MNUMYR(ModelYear))+QBLK_QGIIN(MNUMC2,NEMSmap_MNUMYR(ModelYear))))/$
				                                                  (QBLK_QGFIN(TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear))+QBLK_QGIIN(TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear)));
				MPBLK_PNGEL(TotalUS_MNUMCR, NEMSmap_MNUMYR(ModelYear)):=sum((NNGEMM,M3), NGTDMOUT_SPNGELGR(NNGEMM, NEMSmap_MNUMYR(ModelYear), M3)*UEFDOUT_SQNGELGR(NNGEMM,NEMSmap_MNUMYR(ModelYear),M3))/$
				                                                sum((NNGEMM,M3), UEFDOUT_SQNGELGR(NNGEMM,NEMSmap_MNUMYR(ModelYear),M3));
				NGTDMOUT_PGFTRFV(TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(MNUMC2, NGTDMOUT_PGFTRFV(MNUMC2, NEMSmap_MNUMYR(ModelYear))*NGTDMOUT_QGFTRFV(MNUMC2,NEMSmap_MNUMYR(ModelYear)))/$
				                                                 NGTDMOUT_QGFTRFV(TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear));
				NGTDMOUT_PGFTRPV(TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(MNUMC2, NGTDMOUT_PGFTRPV(MNUMC2, NEMSmap_MNUMYR(ModelYear))*NGTDMOUT_QGFTRPV(MNUMC2,NEMSmap_MNUMYR(ModelYear)))/$
				                                                 NGTDMOUT_QGFTRPV(TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear));
				NGTDMOUT_PGLTRFV(TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(MNUMC2, NGTDMOUT_PGLTRFV(MNUMC2, NEMSmap_MNUMYR(ModelYear))*NGTDMOUT_QGLTRFV(MNUMC2,NEMSmap_MNUMYR(ModelYear)))/$
				                                                 NGTDMOUT_QGLTRFV(TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear));
				NGTDMOUT_PGLTRPV(TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(MNUMC2, NGTDMOUT_PGLTRPV(MNUMC2, NEMSmap_MNUMYR(ModelYear))*NGTDMOUT_QGLTRPV(MNUMC2,NEMSmap_MNUMYR(ModelYear)))/$
				                                                 NGTDMOUT_QGLTRPV(TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear));
				NGTDMOUT_PGFTRRAIL(M4,TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(MNUMC2, NGTDMOUT_PGFTRRAIL(M4,MNUMC2, NEMSmap_MNUMYR(ModelYear))*NGTDMOUT_QGFTRRAIL(M4,MNUMC2,NEMSmap_MNUMYR(ModelYear)))/$
				                                                 NGTDMOUT_QGFTRRAIL(M4,TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear));
				NGTDMOUT_PGLTRRAIL(M4,TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(MNUMC2, NGTDMOUT_PGLTRRAIL(M4,MNUMC2, NEMSmap_MNUMYR(ModelYear))*NGTDMOUT_QGFTRRAIL(M4,MNUMC2,NEMSmap_MNUMYR(ModelYear)))/$
				                                                 NGTDMOUT_QGLTRRAIL(M4,TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear));
				NGTDMOUT_PGFTRSHIP(M3,TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(MNUMC2, NGTDMOUT_PGFTRSHIP(M3,MNUMC2, NEMSmap_MNUMYR(ModelYear))*NGTDMOUT_QGFTRSHIP(M3,MNUMC2,NEMSmap_MNUMYR(ModelYear)))/$
				                                                 NGTDMOUT_QGFTRSHIP(M3,TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear));
				NGTDMOUT_PGLTRSHIP(M3,TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(MNUMC2, NGTDMOUT_PGLTRSHIP(M3,MNUMC2, NEMSmap_MNUMYR(ModelYear))*NGTDMOUT_QGLTRSHIP(M3,MNUMC2,NEMSmap_MNUMYR(ModelYear)))/$
				                                                 NGTDMOUT_QGLTRSHIP(M3,TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear));
				
				
					!Fill in national number as average if no consumption exists (i.e. do not send back a zero)
				for (M4|NGTDMOUT_PGFTRRAIL(M4,TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear)) =0) do
					NGTDMOUT_PGFTRRAIL(M4,TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(MNUMCR, NGTDMOUT_PGFTRRAIL(M4,MNUMCR,NEMSmap_MNUMYR(ModelYear)))/$
						count(MNUMCR|NGTDMOUT_PGFTRRAIL(M4,MNUMCR,NEMSmap_MNUMYR(ModelYear)));
				endfor;
				
				for (M4|NGTDMOUT_PGLTRRAIL(M4,TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear)) =0) do
					NGTDMOUT_PGLTRRAIL(M4,TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(MNUMCR, NGTDMOUT_PGLTRRAIL(M4,MNUMCR,NEMSmap_MNUMYR(ModelYear)))/$
						count(MNUMCR|NGTDMOUT_PGLTRRAIL(M4,MNUMCR,NEMSmap_MNUMYR(ModelYear)));
				endfor;	
				
				for (M3|NGTDMOUT_PGFTRSHIP(M3,TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear)) =0) do
					NGTDMOUT_PGFTRSHIP(M3,TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(MNUMCR, NGTDMOUT_PGFTRSHIP(M3,MNUMCR,NEMSmap_MNUMYR(ModelYear)))/$
						count(MNUMCR|NGTDMOUT_PGFTRSHIP(M3,MNUMCR,NEMSmap_MNUMYR(ModelYear)));
				endfor;
				
				for (M3|NGTDMOUT_PGLTRSHIP(M3,TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear)) =0) do
					NGTDMOUT_PGLTRSHIP(M3,TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(MNUMCR, NGTDMOUT_PGLTRSHIP(M3,MNUMCR,NEMSmap_MNUMYR(ModelYear)))/$
						count(MNUMCR|NGTDMOUT_PGLTRSHIP(M3,MNUMCR,NEMSmap_MNUMYR(ModelYear)));
				endfor;
				
				MPBLK_PNGTR(TotalUS_MNUMCR, NEMSmap_MNUMYR(ModelYear)):=sum(MNUMC2, MPBLK_PNGTR(MNUMC2, NEMSmap_MNUMYR(ModelYear))*QBLK_QNGTR(MNUMC2,NEMSmap_MNUMYR(ModelYear)))/$
				                                                  QBLK_QNGTR(TotalUS_MNUMCR, NEMSmap_MNUMYR(ModelYear));
				
				MPBLK_PGFIN(MNUMCR, NEMSmap_MNUMYR(ModelYear)):= MPBLK_PNGIN(MNUMCR, NEMSmap_MNUMYR(ModelYear));
				MPBLK_PGIIN(MNUMCR, NEMSmap_MNUMYR(ModelYear)):= MPBLK_PNGIN(MNUMCR, NEMSmap_MNUMYR(ModelYear));
				
					!Set Electric Pricing variables
				NGTDMREP_NGSPOT_EMM(NNGEMM, NEMSmap_MNUMYR(ModelYear)) := sum(season, PriceSpotAnnualElectric(ModelYear, NNGEMM, season)*NEMS_Consumption_EMM(ModelYear,NNGEMM,season))/
				                                           sum(season, NEMS_Consumption_EMM(ModelYear,NNGEMM,season));
				
				NGTDMREP_UDTAR(NNGEMM, NEMSmap_MNUMYR(ModelYear)) := AnnualPrice_EnduseElectric(ModelYear,NNGEMM)  - NGTDMREP_NGSPOT_EMM(NNGEMM, NEMSmap_MNUMYR(ModelYear));
				
				NGTDMOUT_PNGELGR(NNGEMM, NEMSmap_MNUMYR(ModelYear)):=sum(M3, NGTDMOUT_SPNGELGR(NNGEMM, NEMSmap_MNUMYR(ModelYear), M3)*UEFDOUT_SQNGELGR(NNGEMM,NEMSmap_MNUMYR(ModelYear),M3))/$
				                                                sum(M3, UEFDOUT_SQNGELGR(NNGEMM,NEMSmap_MNUMYR(ModelYear),M3));
				
				NGTDMOUT_PNGELGR(card(NNGEMM), NEMSmap_MNUMYR(ModelYear)):=AK_Price_EndUse(ModelYear, Sector_Electric)/Convert_TBtu_Bcf_Utility(ModelYear); 
				
				!Fill NGMM report variables for GraphNEMS
					!Capacity variables to fill
				for ((M12,M6)|Exists((r_flow,r_flow1)|NEMSmap_NGFLOWS_FlowRegions_M12_M6(r_flow,r_flow1,M12,M6))) do
					NGRPT_NGCAPS(M12,M6,NEMSmap_MNUMYR(ModelYear)) := sum((r_flow,r_flow1)|NEMSmap_NGFLOWS_FlowRegions_M12_M6(r_flow,r_flow1,M12,M6),
										CapRegional(ModelYear,r_flow,r_flow1));
				endfor;		
				!Old Regions				
				!for ((M12,M6)|Exists((r_og,r_og1)|NEMSmap_NGFLOWS_OilGasRegions_M12_M6(r_og,r_og1,M12,M6))) do
				!	NGRPT_NGCAPS(M12,M6,NEMSmap_MNUMYR(ModelYear)) := sum((r_og,r_og1)|NEMSmap_NGFLOWS_OilGasRegions_M12_M6(r_og,r_og1,M12,M6),
				!						CapacityRegional(ModelYear,r_og,r_og1));
				!endfor;		
				!for ((M12,M6)|Exists(bx|NEMSmap_NGFLOWS_BX(bx,M12,M6))) do
				!	NGRPT_NGCAPS(M12,M6,NEMSmap_MNUMYR(ModelYear)) := sum(bx|NEMSmap_NGFLOWS_BX(bx,M12,M6), AnnualImports(ModelYear,bx));
				!endfor;
				
				!for ((M12,M6)|Exists(bx|Correct_NGFLOWS(M12,M6,BX))) do
				!	NGRPT_NGCAPS(M12,M6,NEMSmap_MNUMYR(ModelYear))  -= sum(bx|Correct_NGFLOWS(M12,M6,BX), AnnualImports(ModelYear,bx));
				!endfor;
					!Flow variables to fill
				for ((M12,M6)|Exists((r_flow,r_flow1)|NEMSmap_NGFLOWS_FlowRegions_M12_M6(r_flow,r_flow1,M12,M6))) do
					NGRPT_NGFLOWS(M12,M6,NEMSmap_MNUMYR(ModelYear)) := sum((r_flow,r_flow1)|NEMSmap_NGFLOWS_FlowRegions_M12_M6(r_flow,r_flow1,M12,M6),
										FlowRegional(ModelYear,r_flow,r_flow1));
				endfor;						
				
					!Capacity variables to fill
				for ((M12,M6)|Exists((r_flow,r_flow1)|NEMSmap_NGFLOWS_FlowRegions_M12_M6(r_flow,r_flow1,M12,M6))) do
					NGRPT_NGCAPS(M12,M6,NEMSmap_MNUMYR(ModelYear)) := sum((r_flow,r_flow1)|NEMSmap_NGFLOWS_FlowRegions_M12_M6(r_flow,r_flow1,M12,M6),
										CapRegional(ModelYear,r_flow,r_flow1));
				endfor;	
				
				!Old Regions
				!for ((M12,M6)|Exists((r_og,r_og1)|NEMSmap_NGFLOWS_OilGasRegions_M12_M6(r_og,r_og1,M12,M6))) do
				!	NGRPT_NGFLOWS(M12,M6,NEMSmap_MNUMYR(ModelYear)) := sum((r_og,r_og1)|NEMSmap_NGFLOWS_OilGasRegions_M12_M6(r_og,r_og1,M12,M6),
				!						FlowsRegional(ModelYear,r_og,r_og1));
				!endfor;						
				
				!for ((M12,M6)|Exists(bx|NEMSmap_NGFLOWS_BX(bx,M12,M6))) do
				!	NGRPT_NGFLOWS(M12,M6,NEMSmap_MNUMYR(ModelYear)) := sum(bx|NEMSmap_NGFLOWS_BX(bx,M12,M6), AnnualImports(ModelYear,bx));
				!endfor;
				
				!for ((M12,M6)|Exists(bx|Correct_NGFLOWS(M12,M6,BX))) do
				!	NGRPT_NGFLOWS(M12,M6,NEMSmap_MNUMYR(ModelYear))  -= sum(bx|Correct_NGFLOWS(M12,M6,BX), AnnualImports(ModelYear,bx));
				!endfor;
				
				!LNG Export Utilization for Model Year (LNG Capacities done in Write_to_NEMS_LNGExports)
				NGTDMREP_NALNGEXP(LNGTER,NEMSmap_MNUMYR(ModelYear)) := sum(lngexp_l48 | NEMSmap_LNGTER_lngexp(lngter,lngexp_l48), AnnualLNGExports(ModelYear,lngexp_l48));
				NGTDMREP_NALNGEXP(10,NEMSmap_MNUMYR(ModelYear)) := AnnualLNGExports(ModelYear,CanadaWest);
				NGTDMREP_NALNGEXP(Card(LNGTER),NEMSmap_MNUMYR(ModelYear)) := AnnualLNGExports(ModelYear,AKState);
				
				!Natural Gas Production and Prices
				
					!The Henry Hub prices ( 87$/MMBtu)
				!NGTDMREP_OGHHPRNG(NEMSmap_MNUMYR(ModelYear)) := (WellhdPrice(ModelYear, Supply_NA, HenryHubRegion)+GatheringCharge(HenryHubRegion))/Convert_TBtu_Bcf(ModelYear);
				NGTDMREP_OGHHPRNG(NEMSmap_MNUMYR(ModelYear)) := HenryHubPrice(ModelYear)/Convert_TBtu_Bcf(ModelYear);
				
					!Wellhead prices by OGDIST
				NGTDMREP_OGPRCNG(OGDIST, NEMSmap_MNUMYR(ModelYear)) := sum(s_ogsm | NEMSmap_OGDIST_SupplyNode(OGDIST, s_ogsm),  WellhdPrice_Soln(ModelYear, Supply_NA, s_ogsm));
						!Set wellhead price for ALASKA to fill variable by OGDIST
				NGTDMREP_OGPRCNG(OGDIST, NEMSmap_MNUMYR(ModelYear)) := $ sum(ak_s,  AK_Citygate(ModelYear)*NEMSmap_OGDIST_SupplyNode(OGDIST, ak_s));
				
					!NA production  - Assign realized production to OGSM
				CurrentMNUMYR := NEMSmap_MNUMYR(ModelYear);
				empty OGSMOUT_OGRNAGPRD(OGDIST, '5', CurrentMNUMYR);
				
				OGSMOUT_OGRNAGPRD(OGDIST, 5, NEMSmap_MNUMYR(ModelYear)) := sum(ussup | NEMSmap_OGDIST_SupplyNode(OGDIST, ussup), ActualProductionAnnual(ModelYear, Supply_NA, ussup)/
				                                                       (1 - LeaseFuelFactor(ussup)*STEOLeaseFuelFactor(ModelYear)));
				
					!NA + AD production by MNUMOR region
				empty NGTDMREP_OGPRDNG(MNUMOR, CurrentMNUMYR);
				NGTDMREP_OGPRDNG(MNUMOR, NEMSmap_MNUMYR(ModelYear)) := sum(l48s | NEMSmap_SupplyNode_MNUMOR(l48s,MNUMOR), (ActualProductionAnnual(ModelYear, Supply_AD, l48s)+
				                                                                 ActualProductionAnnual(ModelYear, Supply_NA, l48s))/ (1 - LeaseFuelFactor(l48s)*STEOLeaseFuelFactor(ModelYear)));
				NGTDMREP_OGPRDNG('11',CURIYR) := 0.0;
				NGTDMREP_OGPRDNG('12',CURIYR) := AK_Production(ModelYear,AKRegion_North);
				NGTDMREP_OGPRDNG('13',CURIYR) := AK_Production(ModelYear,AKRegion_South);
				NGTDMREP_OGPRDNG(TotalUS_MNUMOR, NEMSmap_MNUMYR(ModelYear)) := sum(MNUMOR| MNUMOR<TotalUS_MNUMOR, NGTDMREP_OGPRDNG(MNUMOR, NEMSmap_MNUMYR(ModelYear)));
				
				!national total across all three categories (coal, oil, other) of supplemental fuel produced
				NGTDMREP_OGPRSUP(NEMSmap_MNUMYR(ModelYear)) := sum((sng,l48), ActualProductionAnnual(ModelYear, sng, l48));
				
				! National RNG Production
				NGTDMREP_OGPRRNG(NEMSmap_MNUMYR(ModelYear)) := sum(l48s, ActualProductionAnnual(ModelYear, Supply_RNG, l48s));
				
				! Carbon offset by RNG via LCFS
				NGTDMREP_LCFSRNGOS(NEMSmap_MNUMYR(ModelYear)) := AnnualRNGCarbonOffset(ModelYear);
				
					!SNG-coal
				NGTDMREP_OGSUPGAS(1,MNUMCR, NEMSmap_MNUMYR(ModelYear)) := sum((r_cen,l48) |  map_State_CensusRegion(l48, r_cen) and NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR),
				                                                                  ActualProductionAnnual(ModelYear, Supply_SNGcoal, l48));
				
				NGTDMREP_OGSUPGAS(1, TotalUS_MNUMCR, NEMSmap_MNUMYR(ModelYear)) := sum(l48, ActualProductionAnnual(ModelYear, Supply_SNGcoal, l48));
				!SNG-oil+other
				NGTDMREP_OGSUPGAS(2, MNUMCR, NEMSmap_MNUMYR(ModelYear)) := sum((sng,l48,r_cen) | sng in (SNG_-Supply_SNGcoal) and map_State_CensusRegion(l48, r_cen) and NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR),
				                                                        ActualProductionAnnual(ModelYear, sng, l48));
				NGTDMREP_OGSUPGAS(2, TotalUS_MNUMCR, NEMSmap_MNUMYR(ModelYear)) := sum((sng,l48) | sng in (SNG_-Supply_SNGcoal), ActualProductionAnnual(ModelYear, sng, l48));
				NGTDMREP_OGSUPGAS(2, TotalUS_MNUMCR, CURIYR) := sum(MNUMC2, NGTDMREP_OGSUPGAS(2, MNUMC2, CURIYR));
				
					!Wellhead prices by Oil and Gas Region
				NGTDMREP_OGWPRNG(MNUMOR, NEMSmap_MNUMYR(ModelYear)) := sum(l48s | NEMSmap_SupplyNode_MNUMOR(l48s,MNUMOR), WellhdPrice_Soln(ModelYear, Supply_NA, l48s)*(ActualProductionAnnual(ModelYear, Supply_AD, l48s)+
				                                                                 ActualProductionAnnual(ModelYear, Supply_NA, l48s))/ (1 - LeaseFuelFactor(l48s)*STEOLeaseFuelFactor(ModelYear)))/$
				                                                                  NGTDMREP_OGPRDNG(MNUMOR, NEMSmap_MNUMYR(ModelYear));
					!Fill in for Alaska
				!if (AK_Production(ModelYear,'AK_ANGTS') > 0.01) then
				!	NGTDMREP_OGWPRNG(NEMSmap_MNUMOR_AK(r_ak),NEMSmap_MNUMYR(ModelYear)) := AK_ANGTS_Min_WHPrice;
				!	NGTDMREP_OGWPRNG(NEMSmap_MNUMOR_AK(AKRegion_South),NEMSmap_MNUMYR(ModelYear)) := AK_Citygate(ModelYear);
				!else
					NGTDMREP_OGWPRNG(NEMSmap_MNUMOR_AK(r_ak),NEMSmap_MNUMYR(ModelYear)) := AK_Citygate(ModelYear);	
				!endif;
				!NGTDMREP_OGWPRNG('11',NEMSmap_MNUMYR(ModelYear)) := AK_Citygate(ModelYear);
				
					! Fill in if zero
				for (MNUMOR|NGTDMREP_OGWPRNG(MNUMOR, NEMSmap_MNUMYR(ModelYear)) =0) do
					NGTDMREP_OGWPRNG(MNUMOR, NEMSmap_MNUMYR(ModelYear)) := sum(l48s | NEMSmap_SupplyNode_MNUMOR(l48s,MNUMOR), WellhdPrice_Soln(ModelYear, Supply_NA, l48s))/$
												count(l48s | NEMSmap_SupplyNode_MNUMOR(l48s,MNUMOR));
				endfor;	
				
					!Average l48 price
				NGTDMREP_OGWPRNG(TotalUS_MNUMOR, NEMSmap_MNUMYR(ModelYear)) := sum(l48_MNUMOR, NGTDMREP_OGPRDNG(l48_MNUMOR, NEMSmap_MNUMYR(ModelYear))*NGTDMREP_OGWPRNG(l48_MNUMOR, NEMSmap_MNUMYR(ModelYear)))/$
				                                                                sum(l48_MNUMOR, NGTDMREP_OGPRDNG(l48_MNUMOR, NEMSmap_MNUMYR(ModelYear)));
				
				NGTDMREP_PINTLNG(M2,NEMSmap_MNUMYR(ModelYear)) := sum( d_lng, WorldLNGPrice(ModelYear,d_lng)*NEMSmap_M2_d_lng(M2,d_lng));
				
				
				!Write Consumption variables to common block
				
					!Fuel used for liquefaction
				QMORE_QNGLQ(MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum((lngexp,r_cen)|(map_State_CensusRegion(lngexp,r_cen) and NEMSmap_MNUMCR_CensusReg(r_cen,MNUMCR)),
				                    LNGFuelForLiquefaction(ModelYear,lngexp)) * Convert_TBtu_Bcf(ModelYear);
				!              !Add Alaska
				QMORE_QNGLQ(TotalUS_MNUMCR, CURIYR) := sum(MNUMC2, QMORE_QNGLQ(MNUMC2,CURIYR));
				
					!Lease and Plant fuel
				QBLK_QLPIN(MNUMCR, NEMSmap_MNUMYR(ModelYear)) := sum((r_cen,state) |  map_State_CensusRegion(state, r_cen) and NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR),
				                                                LeaseAndPlantFuelAnnual(ModelYear,state)) * Convert_TBtu_Bcf(ModelYear);
				QBLK_QLPIN(TotalUS_MNUMCR, CURIYR) := sum(MNUMC2, QBLK_QLPIN(MNUMC2,CURIYR));
				
					!Pipeline fuel use
				QBLK_QGPTR(MNUMCR, NEMSmap_MNUMYR(ModelYear)) := sum((r_cen,state) |  map_State_CensusRegion(state, r_cen) and NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR),
				                                                 PipeFuelLossAnnual(ModelYear, state)) * Convert_TBtu_Bcf(ModelYear);
				        !Add fuel losses from CNG/LNG in transportation sector to pipeline fuel
				QBLK_QGPTR(MNUMCR, NEMSmap_MNUMYR(ModelYear)) +=   sum(r_cen|NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR), FuelLoss_CNG_LNG(ModelYear, r_cen));     
				
				QBLK_QGPTR(TotalUS_MNUMCR, CURIYR) := sum(MNUMC2, QBLK_QGPTR(MNUMC2,CURIYR));
				
					!Total US Balancing item (used in table 107 of GraphNems???)
				NGTDMREP_NGBAL (NEMSmap_MNUMYR(ModelYear)) := TotalBalanceItem(ModelYear);
				
				
				
				!Supply Curve parameters to send to Electricity Model
				
				NGTDMREP_NGSCRV_Q0(NEMSmap_MNUMYR(ModelYear)):= sum ((GASTYP,OGDIST)|(Exists(s_ogsm, NEMSmap_OGDIST_SupplyNode(OGDIST, s_ogsm)) and GASTYP < card(GASTYP)) , OGSMOUT_OGENAGPRD(OGDIST,GASTYP,NEMSmap_MNUMYR(ModelYear)));
				!		-sum ((OGDIST,r_ak)|NEMSmap_OGDIST_r_ak(OGDIST,r_ak) , OGSMOUT_OGENAGPRD(OGDIST,card(GASTYP),NEMSmap_MNUMYR(ModelYear)));
				NGTDMREP_NGSCRV_Q(NEMSmap_MNUMYR(ModelYear)):= sum (OGDIST|Exists(s_ogsm, NEMSmap_OGDIST_SupplyNode(OGDIST, s_ogsm)), OGSMOUT_OGRNAGPRD(OGDIST,card(GASTYP),NEMSmap_MNUMYR(ModelYear)));
				!		-sum ((OGDIST,r_ak)|NEMSmap_OGDIST_r_ak(OGDIST,r_ak) , OGSMOUT_OGRNAGPRD(OGDIST,card(GASTYP),NEMSmap_MNUMYR(ModelYear)));
				
				NGTDMREP_NGSCRV_P(NEMSmap_MNUMYR(ModelYear)):= sum (OGDIST|Exists(s_ogsm, NEMSmap_OGDIST_SupplyNode(OGDIST, s_ogsm)), 
						OGSMOUT_OGRNAGPRD(OGDIST,card(GASTYP),NEMSmap_MNUMYR(ModelYear))*NGTDMREP_OGPRCNG(OGDIST,NEMSmap_MNUMYR(ModelYear))) /$
						NGTDMREP_NGSCRV_Q(NEMSmap_MNUMYR(ModelYear));
				NGTDMREP_NGSCRV_P0(NEMSmap_MNUMYR(ModelYear)):= sum (OGDIST|Exists(s_ogsm, NEMSmap_OGDIST_SupplyNode(OGDIST, s_ogsm)), 
						sum(GASTYP|GASTYP < card(GASTYP)   , OGSMOUT_OGENAGPRD(OGDIST,GASTYP,NEMSmap_MNUMYR(ModelYear)))*NGTDMREP_OGPRCNG(OGDIST,NEMSmap_MNUMYR(ModelYear-1))*STEOWellhdPriceFactor(ModelYear)) /$
						NGTDMREP_NGSCRV_Q0(NEMSmap_MNUMYR(ModelYear));
				
				NGTDMREP_NGSCRV_MAX (NEMSmap_MNUMYR(ModelYear)) :=  NGTDMREP_NGSCRV_Q0 (NEMSmap_MNUMYR(ModelYear))* (1 + Parameter_Supcrv(Supply_NA,last(step),last(n)));
				NGTDMREP_NGSCRV_MIN (NEMSmap_MNUMYR(ModelYear)) :=  NGTDMREP_NGSCRV_Q0 (NEMSmap_MNUMYR(ModelYear))* (1 + Parameter_Supcrv(Supply_NA,first(step),last(n)));
				
				NGTDMREP_NGSCRV_PER('1') := Parameter_Supcrv(Supply_NA,last(step),first(n));
				NGTDMREP_NGSCRV_PER('2') := Parameter_Supcrv(Supply_NA,last(step),nth(n,2));
				
				NGTDMREP_NGSCRV_ELAS('1') := Parameter_SupElasticity(Supply_NA,first(step),last(n));
				NGTDMREP_NGSCRV_ELAS('2') := Parameter_SupElasticity(Supply_NA,first(step),nth(n,2));
				NGTDMREP_NGSCRV_ELAS('3') := Parameter_SupElasticity(Supply_NA,first(step),first(n));
				NGTDMREP_NGSCRV_ELAS('4') := Parameter_SupElasticity(Supply_NA,last(step),nth(n,2));
				NGTDMREP_NGSCRV_ELAS('5') := Parameter_SupElasticity(Supply_NA,last(step),last(n));
				
				if ( ElectricOption=1) then
					if (Factor_EL = 0) then
						NGTDMREP_EL_MRKUP_BETA(M3) :=0;
					else
						NGTDMREP_EL_MRKUP_BETA(M3) :=0;
					endif;
				elseif ( ElectricOption=2) then
					NGTDMREP_EL_MRKUP_BETA(M3) :=0;
				elseif ( ElectricOption=3) then
					NGTDMREP_EL_MRKUP_BETA(M3) :=sum(season| NEMSmap_M3_season(M3,season),PAR1_EL(season, ElectricOption));
				endif;
			}
			Comment: {
				"All overwrites of NEMS variables is done in this procedure.
				This procedure is run in MainExecution after all processing (but before case saving)."
			}
		}
	}
	Section NEMS_Interface {
		Section NEMS_Monitor_Section {
			DeclarationSection NEMS_Monitor_Identifiers {
				StringParameter ReadMonitorInStatus;
				StringParameter ExecutingMonitorOutStatus;
				StringParameter CompletedMonitorOutStatus;
				StringParameter EnterMainExecution;
				StringParameter EnterMainTermination;
				StringParameter EnterNEMSMonitor;
				StringParameter MiddleNEMSMonitor;
				StringParameter ExitNEMSMonitor;
				StringParameter ExitMainExecution;
				File ngStatusFile {
					Name: "ng_status.txt";
					Device: Disk;
					Mode: merge;
				}
				Parameter CountSleep;
			}
			DeclarationSection Transfer_Global_Data {
				StringParameter sDataYearFile;
				File GlobalDataToNEMS {
					Name: sDataYearFile;
					Device: Disk;
					Mode: replace;
				}
				File NEMSMessageInFile {
					Name: sMessageInFile;
					Device: Disk;
					Mode: replace;
				}
				File NEMSMessageOutFile {
					Name: sMessageOutFile;
					Device: Disk;
					Mode: replace;
				}
				StringParameter sMessageInFile {
					Definition: "monitor.in.txt";
				}
				StringParameter sMessageOutFile {
					Definition: "monitor.out.txt";
				}
				Set YearForGlobalVariables {
					SubsetOf: MNUMYR_;
					Text: "Used to specify years for which global data are sent back to NEMS. Keep the name globalyr in lower case";
					Index: globalyr;
				}
				StringParameter sAction;
				StringParameter sStatusMessage;
			}
			Procedure ReadGlobalDataFromNEMS {
				Body: {
					! reads global data from NEMS
					
					             sDataYearFile:="toAIMMS\\GlobalDataToAimms_"+formatstring("%i",ncntrl_curcalyr(1))+"_"+formatstring("%>02i",ncntrl_curitr(1))+".txt";
					             put formatstring("the global data transfer file name is %s\n", sDataYearFile);
					             if fileexists(sDataYearFile) then
					                   read from file sDataYearFile in merge mode;
					             else
					                put "the global data transfer file not found \n ";
					             endif;
				}
			}
			Procedure SendGlobalDataToNEMS {
				Body: {
					            !         send global data back to nems via a text file. The file is read by nems filer subroutine with funfmt=7
					
					                      sDataYearFile:="fromAIMMS\\GlobalDataToNEMS_"+formatstring("%i",ncntrl_curcalyr(1))+"_"+formatstring("%>02i",ncntrl_curitr(1))+".txt";
					            !         Note the "FILE" identifier GlobalDataToNEMS is linked to the string parameter sDataYearFile
					                      put GlobalDataToNEMS; ! opens the file (sDataYearFile) and sets stage for subsequent display and/or put statements
					                      if  ncntrl_curcalyr(1) <= Val(FirstModelYear) then
					                        YearForGlobalVariables:={1..61};
					                      else
					                        YearForGlobalVariables:=ncntrl_curiyr(1);
					                      endif;
					                      display {MPBLK_PGFIN(MNUMCR,globalyr)} where decimals:=22;
					                      display {MPBLK_PGIIN(MNUMCR,globalyr)} where decimals:=22;
					                      display {MPBLK_PNGCM(MNUMCR,globalyr)} where decimals:=22;
					                      display {MPBLK_PNGEL(MNUMCR,globalyr)} where decimals:=22;
					                      display {MPBLK_PNGIN(MNUMCR,globalyr)} where decimals:=22;
					                      display {MPBLK_PNGRS(MNUMCR,globalyr)} where decimals:=22;
					                      display {MPBLK_PNGTR(MNUMCR,globalyr)} where decimals:=22;
					                      display {NGRPT_NGCAPS(M12,M6,globalyr)} where decimals:=22;
					                      display {NGRPT_NGFLOWS(M12,M6,globalyr)} where decimals:=22;
					                      display {NGTDMOUT_PGFTRFV(MNUMCR,globalyr)} where decimals:=22;
					                      display {NGTDMOUT_PGLTRFV(MNUMCR,globalyr)} where decimals:=22;
					                      display {NGTDMOUT_PGFTRPV(MNUMCR,globalyr)} where decimals:=22;
					                      display {NGTDMOUT_PGLTRPV(MNUMCR,globalyr)} where decimals:=22;
					                      display {NGTDMOUT_PGFTRRAIL(M4,MNUMCR,globalyr)} where decimals:=22;
					                      display {NGTDMOUT_PGLTRRAIL(M4,MNUMCR,globalyr)} where decimals:=22;
					                      display {NGTDMOUT_PGFTRSHIP(M3,MNUMCR,globalyr)} where decimals:=22;
					                      display {NGTDMOUT_PGLTRSHIP(M3,MNUMCR,globalyr)} where decimals:=22;
					                      display {NGTDMOUT_SPNGELGR(NNGEMM,globalyr,M3)} where decimals:=22;
					                      display {NGTDMOUT_PNGELGR(NNGEMM,globalyr)} where decimals:=22;
					                      display {NGTDMOUT_SPNGIN(MNUMCR, globalyr, M4)} where decimals:=22;
					                      display {NGTDMREP_ACGPR_RESCOM(M12,globalyr)} where decimals:=22;
					                      display {NGTDMREP_CNLNGIMP(globalyr)} where decimals:=22;
					                      display {NGTDMREP_EL_MRKUP_BETA(M3)} where decimals:=22;
					!                     display {NGTDMREP_NALNGEXP(LNGTER,mnumyr)} where decimals:=22; ! send all years because includes future capacity
					                      display {NGTDMREP_NALNGEXP(LNGTER,globalyr)} where decimals:=22; ! for replication purposes, send only current year
					                      display {NGTDMREP_NGBAL(globalyr)} where decimals:=22;
					                      display {NGTDMREP_NGSCRV_ELAS(M5)} where decimals:=22;
					                      display {NGTDMREP_NGSCRV_MAX(globalyr)} where decimals:=22;
					                      display {NGTDMREP_NGSCRV_MIN(globalyr)} where decimals:=22;
					                      display {NGTDMREP_NGSCRV_P(globalyr)} where decimals:=22;
					                      display {NGTDMREP_NGSCRV_P0(globalyr)} where decimals:=22;
					                      display {NGTDMREP_NGSCRV_PER(M2)} where decimals:=22;
					                      display {NGTDMREP_NGSCRV_Q(globalyr)} where decimals:=22;
					                      display {NGTDMREP_NGSCRV_Q0(globalyr)} where decimals:=22;
					                      display {NGTDMREP_OGHHPRNG(globalyr)} where decimals:=22;
					                      display {NGTDMREP_OGPRDNG(MNUMOR,globalyr)} where decimals:=22;
					                      display {NGTDMREP_OGPRSUP(globalyr)} where decimals:=22;
					                      display {NGTDMREP_OGPRRNG(globalyr)} where decimals:=22;
					                      display {NGTDMREP_LCFSRNGOS(globalyr)} where decimals:=22;
					                      display {NGTDMREP_OGSUPGAS(M2,MNUMCR,globalyr)} where decimals:=22;
					                      display {NGTDMREP_OGWPRNG(MNUMOR,globalyr)} where decimals:=22;
					                      display {NGTDMREP_PINTLNG(M2,globalyr)} where decimals:=22;
					!                     display {NGTDMREP_PTRANSNG(M2,LNGTER,MNUMYR)} where decimals:=22; ! send all years to include future impacts on price
					                      display {NGTDMREP_PTRANSNG(M2,LNGTER,globalyr)} where decimals:=22; ! for replication purposes, send only current year
					                      display {NGTDMREP_PUSNG(LNGTER,globalyr)} where decimals:=22;
					                      display {NGTDMREP_UDTAR(NNGEMM,globalyr)} where decimals:=22;
					                      display {NGTDMREP_NGIMPVOL(M4,globalyr)} where decimals:=22;
					                      display {NGTDMREP_NGEXPVOL(M4,globalyr)} where decimals:=22;
					                      display {NGTDMREP_NGIMPPRC(M4,globalyr)} where decimals:=22;
					                      display {NGTDMREP_NGEXPPRC(M4,globalyr)} where decimals:=22;
					                      display {NGTDMREP_OGPRCNG(OGDIST,globalyr)} where decimals:=22;
					                      display {NGTDMREP_NGSPOT_EMM(NNGEMM,globalyr)} where decimals:=22;
					                      display {QMORE_QNGLQ(MNUMCR,globalyr)} where decimals:=22;
					                      display {OGSMOUT_OGCNPPRD(M2,globalyr)} where decimals:=22;
					                      display {OGSMOUT_OGRNAGPRD(OGDIST,GASTYP,globalyr)} where decimals:=22;
					                      display {OGSMOUT_CNRNAGPRD(M2,globalyr)} where decimals:=22;
					                      display {QBLK_QLPIN(MNUMCR,globalyr)} where decimals:=22;
					                      display {QBLK_QGPTR(MNUMCR,globalyr)} where decimals:=22;
					                      putclose;
				}
			}
		}
		Section NG_RUNVAL_Declarations {
			DeclarationSection NG_RUNVAL {
				Parameter KEEPOPEN {
					Range: binary;
				}
				Parameter WWOP;
				Parameter LNGGAMLV;
				StringParameter NGPUTVARSN;
				StringParameter NGGETVARSN;
				StringParameter NGMARKUPSN;
				StringParameter NGLNGEXPN;
				StringParameter NGMEXICON;
				StringParameter NGSPOTPRCN;
				StringParameter NGCANADAN;
				StringParameter NGSETMAPN;
				StringParameter NGSTEOFACTINN;
				StringParameter NGVARTARN;
				StringParameter NGCAPACITYN;
				StringParameter NGEIAN;
				StringParameter NGASSUMPTIONSN;
				StringParameter NGTEXASN;
				StringParameter NGTXCAPAN;
				Parameter LNGGAMCN;
			}
		}
		Section NEMS_Mapping_Parameters {
			DeclarationSection NEMS_Mapping_Parameters_Declaration {
				Parameter NEMSmap_MNUMYR_yr {
					IndexDomain: (MNUMYR, year);
					Definition: {
						if Val(year)-1989= MNUMYR then
						1
						endif;
					}
					Comment: "Map from GDS index MNUMYR to yr";
				}
				Parameter NEMSmap_MNXYRS_yr {
					IndexDomain: (MNXYRS,xyear);
					Range: binary;
					Definition: {
						if Val(xyear)-1989= MNXYRS then
						1
						endif;
					}
					Comment: "Map from GDS index MNUMYR to yr";
				}
				Parameter NEMSmap_MNUMY3_yr {
					IndexDomain: (MNUMY3,year);
					Definition: {
						if Val(year)-1986= MNUMY3 then
						1
						endif;
					}
					Comment: "Map from GDS index MNUMY3 to yr";
				}
				Parameter NEMSmap_M42_yr {
					IndexDomain: (M42, year);
					Definition: {
						if Val(year)-2008= M42 then
						1
						endif;
					}
					Comment: "Map from GDS index MNUMYR to yr";
				}
				Parameter NEMSmap_M2_Units {
					IndexDomain: (M2,units);
					Text: "Map from GDS index M2 to units";
					Range: binary;
				}
				Parameter NEMSmap_SecE_Core {
					IndexDomain: (ssec);
					Text: "maps NEMS restart variable for Interruptible Eletric Consumption to AIMMS";
					Range: binary;
				}
				Parameter NEMSmap_SecE_NonCore {
					IndexDomain: (ssec);
					Text: "maps NEMS restart variable for Firm Eletric Consumption to AIMMS";
					Range: binary;
				}
				Parameter NEMSmap_MNUMOR_AKreg {
					IndexDomain: (MNUMOR, r_ak);
					Text: "Map from GDS index MNUMOR to Alaska Region";
					Range: binary;
				}
				Parameter NEMSmap_SupplyNode_MNUMOR {
					IndexDomain: (s,MNUMOR);
					Text: "Map from GDS index MNUMOR to Supply Region";
					Range: binary;
				}
				Parameter NEMSmap_MNUMBX_BX {
					IndexDomain: (MNUMBX,BX);
					Text: "Map from GDS index MNUMBX to border crossing index BX";
					Range: binary;
					Comment: {
						"!In progress; need to know mapping relationships to finish defining"
					}
				}
				Parameter NEMSmap_LNGTER_lngexp {
					IndexDomain: (LNGTER,lngexp_qp);
					Text: "Map from GDS index LNGTER to something meaningful";
					Range: binary;
					Definition: {
						!DATA 	{(1,'NewEngland'):1,(2,MidAtlantic):1, (3,SAtlantic):1, (4,'FL'):1,(5,SAtlantic):1,(6,ESCentral):1,(7,WSCentral):1,
						!	(8,'CA'):1,(9,'CN_E'):1,(10,'CN_W'):1,(11,USA):1}
					}
					Comment: "Need help determining demand regions/how to map to new demand nodes in lieu of NGTDM census regions";
				}
				Parameter NEMSmap_MNUMCR_CensusReg {
					IndexDomain: (r_cen,MNUMCR);
					Range: binary;
				}
				ElementParameter NEMSmap_MNUMYR {
					IndexDomain: year;
					Range: MNUMYR_;
					Definition: Val(year)-1989;
				}
				ElementParameter NEMSmap_Year {
					IndexDomain: MNUMYR;
					Range: Years_;
					Definition: ElementCast(Years_,MNUMYR+1989);
				}
				ElementParameter NEMSmap_MNXYRS {
					IndexDomain: xyear;
					Range: MNXYRS_;
					Definition: Val(xyear)-1989;
				}
				ElementParameter NEMSmap_MNUMY3 {
					IndexDomain: year;
					Range: MNUMY3_;
					Definition: Val(year)-1986;
				}
				Parameter NEMSmap_OGDIST_SupplyNode {
					IndexDomain: (OGDIST,s);
					Text: "Map OGDIST to SupplyNode_ regions";
					Range: binary;
				}
				Parameter NEMSmap_reg_MNUMCR {
					IndexDomain: (reg,MNUMCR);
				}
				Parameter NEMSmap_M3_season {
					IndexDomain: (M3,season);
					Range: binary;
				}
				Parameter NEMSmap_state_NNGEMM {
					IndexDomain: (state,NNGEMM);
					Text: "binary mapping parameter from NEMS natural gas/electricity regions to states";
					Range: binary;
				}
				Parameter NEMSmap_NNGEMM_CD {
					IndexDomain: (NNGEMM,MNUMCR);
					Text: "binary mapping parameter from NEMS natural gas/electricity regions to states";
					Range: binary;
				}
				Parameter NEMSmap_MNCRUD_CrudeType {
					IndexDomain: (MNCRUD,crude);
					Range: binary;
				}
				ElementParameter NEMSmap_MNUMOR_AK {
					IndexDomain: r_ak;
					Range: MNUMOR_;
				}
				Parameter NEMSmap_OGDIST_r_ak {
					IndexDomain: (OGDIST,r_ak);
					Text: "Map OGDIST to AK regions";
					Range: binary;
				}
				Parameter NEMSmap_NGFLOWS_OilGasRegions_M12_M6 {
					IndexDomain: (r_og,r_og1,M12,M6);
					Text: "Map regional flows between Oil and Gas Regions to NGFLOWS NEMS variable";
					Range: binary;
				}
				Parameter NEMSmap_NGFLOWS_FlowRegions_M12_M6 {
					IndexDomain: (r_flow,r_flow1,M12,M6);
					Text: "Map regional flows between Oil and Gas Regions to NGFLOWS NEMS variable";
					Range: binary;
				}
				Parameter NEMSmap_NGFLOWS_BX {
					IndexDomain: (bx,M12,M6);
					Text: "Map regional flows at border crossings to NGFLOWS NEMS variable";
					Range: binary;
				}
				Parameter Correct_NGFLOWS {
					IndexDomain: (M12,M6, bx);
					Range: binary;
				}
				Parameter NEMSmap_r_og1_M12 {
					IndexDomain: (r_og1,M12);
					Range: binary;
				}
				Parameter map_M12_CensusRegion {
					IndexDomain: (M12,r_cen);
					Range: binary;
					Definition: {
						if ( ord(M12) =ord(r_cen)) then
							1
						else
							0
						endif;
					}
				}
			}
			DeclarationSection Unit_Conversion_Declaration {
				Parameter Convert_TBtu_Bcf {
					IndexDomain: year;
					Text: "TBtu/bcf";
					Definition: {
						!sum( MNUMYR | NEMSmap_MNUMYR_yr(MNUMYR,year), CONVFACT_CFNGC(MNUMYR) )
						CONVFACT_CFNGC(NEMSmap_MNUMYR(year))
					}
					Comment: {
						"1000 BTU Natural Gas per cubic foot (or trillion BTU per billion cubic feet); used for natural gas qty conversions"
					}
				}
				Parameter Convert_TBtu_Bcf_Utility {
					IndexDomain: year;
					Text: "Factor to convert natural gas consumption from utilities to Bcf";
					Definition: sum( MNUMYR | NEMSmap_MNUMYR_yr(MNUMYR,year), CONVFACT_CFNGU(MNUMYR) );
				}
				Parameter Convert_TBtu_Bcf_NonUtility {
					IndexDomain: year;
					Text: "Factor to convert natural gas consumption from nonutilities to Bcf";
					Definition: sum( MNUMYR | NEMSmap_MNUMYR_yr(MNUMYR,year), CONVFACT_CFNGN(MNUMYR) );
				}
			}
		}
		Section NEMS_Parameters_in_NGMM {
			DeclarationSection NEMS_Parameters_Declaration {
				Parameter WorldOilPrice {
					IndexDomain: (year,units);
					Text: "World Oil Price in both US dollars per barrel and US dollar per MMBtu";
					Definition: sum((M2,MNUMYR)|NEMSmap_M2_units(M2,units) and NEMSmap_MNUMYR_yr(MNUMYR,year), INTOUT_IT_WOP(MNUMYR, M2));
				}
				Parameter GDPPriceDeflator87 {
					IndexDomain: year;
					Definition: {
						sum(MNUMY3 | NEMSmap_MNUMY3_yr(MNUMY3, year), MACOUT_MC_JPGDP(MNUMY3))/MACOUT_MC_JPGDP(1)
						!MACOUT_MC_JPGDP(NEMSmap_MNUMY3(year))/MACOUT_MC_JPGDP(1)
					}
				}
				Parameter WHPrice_OGSM {
					IndexDomain: (MNUMOR,year);
					Text: "Well head price for natural gas (in USD/MMBtu) by Oil and Gas Supply Module region";
					Definition: sum(MNUMYR|NEMSmap_MNUMYR_yr(MNUMYR,year),NGTDMREP_OGWPRNG(MNUMOR,MNUMYR));
				}
				Parameter Unemployment {
					IndexDomain: year;
					Text: "Unemloyment projected by year for USA";
					Range: nonnegative;
					Definition: sum(MNUMYR|NEMSmap_MNUMYR_yr(MNUMYR,year),MACOUT_MC_RUC(MNUMYR));
				}
				Parameter Export_BorderXing {
					IndexDomain: (MNUMBX,year);
					Text: "Exports from USA by year using natural gas border crossing";
					Definition: sum(MNUMYR|NEMSmap_MNUMYR_yr(MNUMYR,year), OGSMOUT_OGQNGEXP(MNUMBX,MNUMYR));
				}
				Parameter Export_LNG_LNGTER {
					IndexDomain: (LNGTER,year);
					Text: "LNG Export by year, defined by LNG Export terminal";
					Definition: {
						sum(MNUMYR|NEMSmap_MNUMYR_yr(MNUMYR,year),NGTDMREP_NALNGEXP(LNGTER,MNUMYR));
						
						!Part of code to use once LNGTER mappings are determined
						!sum((LNGTER,MNUMYR)|NEMSmap_LNGTER_lngexp(LNGTER,r_cen)and NEMSmap_MNUMYR_yr(MNUMYR,yr),NGTDMREP_NALNGEXP(LNGTER,MNUMYR));
					}
				}
				Parameter Cons_Residential {
					IndexDomain: (r_cen, year);
					Definition: sum((MNUMCR,MNUMYR), QBLK_QNGRS(MNUMCR,MNUMYR)*NEMSmap_MNUMYR_yr(MNUMYR,year)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR))/$ Convert_TBtu_Bcf(year);
				}
				Parameter Cons_Commercial {
					IndexDomain: (r_cen, year);
					Definition: sum((MNUMCR,MNUMYR), QBLK_QNGCM(MNUMCR,MNUMYR)*NEMSmap_MNUMYR_yr(MNUMYR,year)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR))/$ Convert_TBtu_Bcf(year);
				}
				Parameter Cons_Industrial_Core {
					IndexDomain: (r_cen,year);
					Definition: sum((MNUMCR,MNUMYR), QBLK_QGFIN(MNUMCR,MNUMYR)*NEMSmap_MNUMYR_yr(MNUMYR,year)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR))/$ Convert_TBtu_Bcf(year);
				}
				Parameter Cons_Hydrogen {
					IndexDomain: (r_cen,year);
					Definition: sum((MNUMCR,MNUMYR), QBLK_QNGHM(MNUMCR,MNUMYR)*NEMSmap_MNUMYR_yr(MNUMYR,year)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR))/$ Convert_TBtu_Bcf(year);
				}
				Parameter Cons_GasToLiquids {
					IndexDomain: (r_cen,year);
					Definition: {
						!sum((MNUMCR,MNUMYR), (QMORE_QGTLSN(MNUMCR,MNUMYR))*NEMSmap_MNUMYR_yr(MNUMYR,year)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR))/$ Convert_TBtu_Bcf(year)
						
						sum((MNUMCR,MNUMYR), ((QMORE_QGTLSN(MNUMCR,MNUMYR))-QMORE_QGTLRF(MNUMCR,MNUMYR))*NEMSmap_MNUMYR_yr(MNUMYR,year)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR))/$ Convert_TBtu_Bcf(year)
					}
				}
				Parameter Cons_Electric_Season {
					IndexDomain: (NNGEMM,year,season);
					Definition: sum((MNUMYR,M3), UEFDOUT_SQNGELGR(NNGEMM,MNUMYR,M3)*NEMSmap_MNUMYR_yr(MNUMYR,year)*NEMSmap_M3_season(M3,season))/$ Convert_TBtu_Bcf_Utility(year);
				}
				Parameter Cons_Industrial_Noncore {
					IndexDomain: (r_cen, year);
					Definition: sum((MNUMCR,MNUMYR), QBLK_QGIIN(MNUMCR,MNUMYR)*NEMSmap_MNUMYR_yr(MNUMYR,year)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR))/$ Convert_TBtu_Bcf(year);
				}
				Parameter Cons_Transportation {
					IndexDomain: (r_cen,year);
					Definition: sum((MNUMCR,MNUMYR), QBLK_QNGTR(MNUMCR,MNUMYR)*NEMSmap_MNUMYR_yr(MNUMYR,year)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR))/$ Convert_TBtu_Bcf(year);
				}
				Parameter Households {
					IndexDomain: (year,r_cen);
					Definition: sum((MNUMYR,MNUMC2), RESDREP_RSGASCUST(MNUMYR,MNUMC2)*NEMSmap_MNUMYR_yr(MNUMYR,year)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMC2));
				}
				Parameter Floorspace {
					IndexDomain: (year,r_cen);
					Definition: sum((MNUMCR,MNUMYR), sum(M11, COMMREP_SurvFloorTotal(MNUMCR,M11,MNUMYR))*NEMSmap_MNUMYR_yr(MNUMYR,year)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR));
				}
				Parameter CDD {
					IndexDomain: (year,r_cen);
					Definition: sum((MNUMCR,MNUMYR), COMMREP_DegreeDays('2',MNUMCR,MNUMYR)*NEMSmap_MNUMYR_yr(MNUMYR,year)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR));
				}
				Parameter HDD {
					IndexDomain: (year,r_cen);
					Definition: sum((MNUMCR,MNUMYR), COMMREP_DegreeDays('1',MNUMCR,MNUMYR)*NEMSmap_MNUMYR_yr(MNUMYR,year)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR));
				}
				Parameter TotalPopulation {
					IndexDomain: (year,r_cen);
					Definition: sum((MNUMCR,MNUMYR), MACOUT_MC_NP(MNUMCR,MNUMYR)*NEMSmap_MNUMYR_yr(MNUMYR,year)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR));
				}
			}
		}
		Section NGMM_Switches {
			DeclarationSection Switch_Identifiers {
				Parameter LNG_FixedExports_Switch {
					Range: binary;
				}
				Parameter AIMMS_Standalone_Switch {
					Range: binary;
					InitialData: 0;
				}
				Parameter InitialRestartFile_Switch {
					InitialData: 1;
				}
				Parameter SaveEachIteration_Switch;
				Parameter SaveEachCycle_Switch {
					Range: binary;
				}
				Parameter Calibration_Option;
				Parameter OilSands_Switch {
					Range: binary;
					Comment: {
						"0= do not endogenously calculate oil sands consumption as it is already in data
						1= endogenously calculate oil sands consumption given bitumen production in Canada"
					}
				}
			}
		}
	}
	Section Data_Management {
		Procedure LoadData {
			Arguments: (CaseName);
			Body: {
				CaseFileLoad(
				url: FormatString("data\\cases\\%s.data",CaseName),0);	!Load case file "CaseName" and destroy previous runtime libraries
			}
			Comment: {
				"A value of \"0\" in the function \"CaseFileLoad\" indicates runtime libraries in existence before the data is loaded, but not referenced in the case file, are destroyed during the data load.
				A value of \"1\" keeps the existing runtime libraries."
			}
			StringParameter CaseName {
				Property: Input;
			}
		}
		Procedure SaveGDS {
			Arguments: (CaseName);
			Body: {
				CaseFileSave(
				url: FormatString("data\\cases\\%s.data",CaseName),
				contents: GDS_Identifiers_ );
			}
			StringParameter CaseName {
				Property: Input;
			}
		}
		Procedure SaveNGTDM {
			Arguments: (CaseName);
			Body: {
				CaseFileSave(
				url: FormatString("data\\cases\\%s.data",CaseName),
				contents: NGTDM_Identifiers_ );
			}
			StringParameter CaseName {
				Property: Input;
			}
		}
		Procedure SaveAll {
			Arguments: (CaseName);
			Body: {
				CaseFileSave(
				url: FormatString("data\\cases\\%s.data",CaseName),
				contents: SaveAll_Identifiers_ );
			}
			StringParameter CaseName {
				Property: Input;
			}
		}
		Procedure SaveCurrentGDS {
			Body: {
				!Save updates to startup case "restart.data"
				! to be used when you change Parameter Definitions in GDS Parameters and want to establish that new
				! structure for the next project opening or when called in NEMS.
				
				SaveGDS("restart");
			}
		}
		Procedure InitializeStandalone {
			Body: {
				!LoadData("restart_initial");
				InitializeFirstModelYear;
				FirstYearInitialization;
				
				!Initialize ModelYear
				!ModelYear := StringToElement(Years_, FormatString("%n", NCNTRL_CURCALYR(1)));
			}
		}
		Procedure Read_Runtime_Parameters {
			Body: {
				read from file "ng_runval.txt" ;
			}
		}
		Procedure Read_FirstModelYear {
			Body: {
				read from file "data\\nginitialize.txt" ;
			}
		}
		Procedure NEMS_Report_Loop {
			Body: {
				LNGExportsCapExpansion_Run;
			}
		}
		Procedure WriteWHPrc {
			Body: {
				tempwhprc(MNUMYR, OGDIST):=NGTDMREP_OGPRCNG(OGDIST, MNUMYR);
				write tempwhprc to file "whdprices_by_MNUMYR&OGDIST.txt" ;
				write NGTDMREP_OGPRCNG to file "whdprices_by_OGDIST.txt" ;
			}
			Parameter tempwhprc {
				IndexDomain: (MNUMYR,OGDIST);
			}
		}
		DeclarationSection Indentifier_Sets_Declaration {
			Set GDS_Identifiers_ {
				SubsetOf: AllIdentifiers;
				Definition: {
					Global_Data_Structure;
				}
			}
			Set NGTDM_Identifiers_ {
				SubsetOf: AllIdentifiers;
				Definition: {
					AllIdentifiers-Global_Data_Structure-Natural_Gas_Market_Module-Data_Management-'ModelYear';!-Time
				}
			}
			Set SaveAll_Identifiers_ {
				SubsetOf: AllIdentifiers;
				Definition: {
					AllIdentifiers-Data_Management;!-Time;
				}
			}
			Set Cleared_Identifiers_ {
				SubsetOf: AllIdentifiers;
				Definition: {
					AllIdentifiers-Global_Data_Structure-Data_Management-Natural_Gas_Market_Module-Time-Time_in_Case_File-NEMS_Interface-'ModelYear';
				}
			}
			Set STEOBM_Identifiers_ {
				SubsetOf: AllIdentifiers;
				Definition: {
					STEO_Iteration_Declarations;
				}
			}
		}
		DeclarationSection Multi_Use_Temporary_Identifiers {
			Parameter counter;
			Parameter counter2;
			Set ElementOrder_ {
				SubsetOf: Integers;
				Index: set_order;
				Definition: {
					{1..100}
				}
			}
		}
		DeclarationSection Hard_Coded_Time_Identifiers {
			StringParameter BeginDateOfCalendar {
				Definition: "1990-01-01";
			}
			StringParameter EndDateOfCalendar {
				Definition: "2080-12-31";
				Comment: {
					"Calendar must extend out beyond last model year
					NOTE: If the value this parameter changes RUN WriteNumberOfDaysToFile procedure (standalone)"
				}
			}
			ElementParameter FirstModelYear {
				Range: XYears_;
				InitialData: '2020';
				Comment: "Now read in in nginitialize.txt.  MUST CHANGE THERE.";
			}
			ElementParameter LastModelYear {
				Range: XYears_;
				Definition: '2050';
			}
			Parameter NumberOfPeriods {
				Range: {
					{1..inf}
				}
				Unit: year;
				InitialData: {
					!(LastModelYear-LastHistoricalYear)*12
					!432  !First Model Year = 2015
					!420  !First Model Year = 2016
					!408  !First Model Year = 2017
					396  !First Model Year = 2018
					
					!Note just something has to be here.  It will be recalculated as long as it matches what's in initial
					!data for first model year
				}
				Comment: "Number of periods is equal to first the number of model years (2050-2015+1) multiplied by number of months in year (12)";
			}
		}
	}
	Section NGMM_Dimensions {
		Section Regions_and_Other_Dimensions {
			Procedure Read_set_data {
				Body: {
					read from file "data\\ngdays.txt";
					read from file NGSETMAPN;
					read from file NGASSUMPTIONSN in merge mode;
					
					SupplyCurveParameters;
					
					!SupplyNode_ += States_+ Canada_ + Mexico_+ Texas_ + NewMexico_ + Louisiana_ + Alabama_ + Mississippi_ + StateOffshore_ + FederalOffshore_ + AKSupply_ + FedGOM_OGDIST_;
					map_StorageArcs(storage, h) := map_DemandArcs(h, storage);
					map_LNGExpArcs(h, lngexp_qp) := map_DemandArcs(h, lngexp_qp);
					
					!read from file "data\\MapNodes.txt";
					!read from file "data\\ngsetdat.txt" ;
					!read from file "data\\ngmapping.txt";
				}
			}
			DeclarationSection Main_Region_Declarations {
				Set RegionalIdentifiers_ {
					SubsetOf: AllSets;
					Definition: {
						Regions_and_Other_Dimensions * AllSets;
					}
				}
				Set Region_Census_ {
					Index: r_cen;
				}
				Set Regions_ {
					Index: reg, reg1;
					Comment: "Root set for all regions used in the model";
				}
				Set Hubs_ {
					SubsetOf: Regions_;
					Text: "Hubs";
					Index: h, h1, h2;
					Definition: DemandNode_ + BorderCrossings_;
					Comment: {
						"Regions representing transshipment nodes (hubs); includes Lower 48 states, Canada and Mexico border-crossing nodes, and Canada and Mexico nodes; subset of Regions_"
					}
				}
				Set QP_Hubs_ {
					SubsetOf: Regions_;
					Text: "Hubs";
					Index: qph, qph1, qph2;
					Definition: DemandNode_ + BorderCrossings_ - TexasState;
					Comment: {
						"Regions representing transshipment nodes (hubs); includes Lower 48 states, Canada and Mexico border-crossing nodes, and Canada and Mexico nodes; subset of Regions_"
					}
				}
				Set DemandNode_ {
					SubsetOf: Regions_;
					Index: d, storage;
					Definition: L_48_ + Canada_+ Mexico_ + TXRegion_;
				}
				Set QP_Demand_Node_ {
					SubsetOf: Regions_;
					Index: qpd, qpstorage;
					Definition: L_48_ + Canada_+ Mexico_ + TXRegion_-TexasState;
				}
				Set SupplyNode_ {
					SubsetOf: Regions_;
					Text: "Supply Region";
					Index: s;
					Definition: {
						!States_+ Canada_ + Mexico_+ Texas_ + NewMexico_ + Louisiana_ + Alabama_ + Mississippi_ + StateOffshore_ + FederalOffshore_ + AKSupply_ + GOMRegion
					}
					Comment: "Supply Regions, subset of Regions_";
				}
				Set BorderCrossings_ {
					SubsetOf: Regions_;
					Index: BX;
				}
				Set TXBorderCrossings_ {
					SubsetOf: BorderCrossings_;
					Index: tx_bx;
				}
			}
			DeclarationSection Supply_Related_Region_Declarations {
				Set USSupply_NoFedGOM_ {
					SubsetOf: SupplyNode_;
					Index: usnoGOM;
					Definition: States_+ Substates_ + Offshore_ + AKSupply_ + FedGOM_OGDIST_ - FederalGOM_- FedGOM_OGDIST_;
				}
				Set QPSupplyNode_ {
					SubsetOf: SupplyNode_;
					Index: qps;
					Definition: L_48_ + Substates_ + Offshore_ + Canada_ + Mexico_ -TexasState;
					Comment: "Supply Nodes used in the QP";
				}
				Set USSupply_ {
					SubsetOf: SupplyNode_;
					Index: ussup;
					Definition: {
						!SupplyNode_ - Canada_ - Mexico_
						States_+ Substates_ + Offshore_ + AKSupply_ + FedGOM_OGDIST_ + TXRegion_
					}
				}
				Set L48_Supply_ {
					SubsetOf: SupplyNode_;
					Index: l48s;
					Definition: QPSupplyNode_- Canada_ - Mexico_;
				}
				Set StateOffshore_ {
					SubsetOf: Regions_;
					Index: stoffshore;
				}
				Set FederalOffshore_ {
					SubsetOf: Regions_;
					Index: fedoffshore;
					Comment: "Federal offshore regions";
				}
				Set FederalGOM_ {
					SubsetOf: SupplyNode_;
					Index: fedGOMstate, fedGOMstate1;
					Comment: "Federal Gulf of Mexico Offshore States : used in the QP";
				}
				Set FedGOM_OGDIST_ {
					SubsetOf: Regions_;
					Index: gom_ogdist, gom_ogdist1;
					Comment: "Federal Gulf of Mexico OGSM Regions";
				}
				Set Offshore_ {
					SubsetOf: Regions_;
					Text: "Offshore regions";
					Index: offshore;
					Definition: StateOffshore_+FederalOffshore_;
					Comment: {
						"State and Federal Offshore regions; subset of SupplyNode_ and Regions_"
					}
				}
				Set Substates_ {
					SubsetOf: SupplyNode_;
					Text: "Substate";
					Index: substate;
					Definition: Texas_+ NewMexico_+ Louisiana_+ Alabama_+Mississippi_;
					Comment: "Union of all supply substates";
				}
				Set AKSupply_ {
					SubsetOf: Regions_;
					Index: ak_s;
				}
				ElementParameter ShaleGasRegion {
					Range: SupplyNode_;
				}
				Set L48MNUMOR_ {
					SubsetOf: MNUMOR_;
					Index: l48_MNUMOR;
					Definition: {
						{1..9}
					}
				}
				Set OGSMSupplyRegions_ {
					SubsetOf: SupplyNode_;
					Index: s_ogsm;
					Definition: {
						!QPSupplyNode_ - FederalGOM_ + FedGOM_OGDIST_
						{s|Exists(OGDIST,NEMSmap_OGDIST_SupplyNode(OGDIST,s))}-AKSupply_
					}
				}
			}
			DeclarationSection Hub_Related_Region_Declarations {
				Set USandBorder_ {
					SubsetOf: Hubs_;
					Index: usbx, usbx1;
					Definition: L_48_+ BorderCrossings_;
				}
				Set States_ {
					SubsetOf: Regions_;
					Index: state;
				}
				Set L_48_ {
					SubsetOf: Regions_;
					Index: l48, l48a;
					Definition: States_-AK_HI_;
				}
				Set BorderCrossingsCN_ {
					SubsetOf: BorderCrossings_;
					Index: bx_cn;
					Definition: BorderCrossings_-BorderCrossingsMX_;
				}
				Set BorderCrossingsMX_ {
					SubsetOf: BorderCrossings_;
					Index: bx_mx;
				}
				ElementParameter HenryHubRegion {
					Range: Regions_;
				}
			}
			DeclarationSection Individual_State_Regional_Declarations {
				Set AK_HI_ {
					SubsetOf: States_;
					Index: oth;
				}
				Set AK_ {
					SubsetOf: States_;
					Index: alaska;
				}
				Set Texas_ {
					SubsetOf: Regions_;
					Text: "Texas subregions";
					Index: tx;
					Comment: {
						"Texas subregions; subset of SupplyNode_ and Regions_"
					}
				}
				Set NewMexico_ {
					SubsetOf: Regions_;
					Text: "New Mexico subregions";
					Index: nm;
					Comment: {
						"New Mexico subregions; subset of SupplyNode_ and Regions_"
					}
				}
				Set Louisiana_ {
					SubsetOf: Regions_;
					Text: "Louisiana subregions";
					Index: la;
					Comment: {
						"Louisiana subregions; subset of SupplyNode_ and Regions_"
					}
				}
				Set Alabama_ {
					SubsetOf: Regions_;
					Text: "Alabama subregions";
					Index: al;
					Comment: {
						"Alabama subregions; subset of SupplyNode_ and Regions_"
					}
				}
				Set Mississippi_ {
					SubsetOf: Regions_;
					Text: "Mississippi subregions";
					Index: ms;
					Comment: {
						"Mississippi subregions; subset of SupplyNode_ and Regions_"
					}
				}
				ElementParameter TexasState {
					Range: Regions_;
				}
				ElementParameter CaliforniaState {
					Range: Regions_;
				}
				ElementParameter MinnesotaState {
					Range: Regions_;
				}
				ElementParameter MichiganState {
					Range: Regions_;
				}
				ElementParameter OhioState {
					Range: Regions_;
				}
				ElementParameter PennState {
					Range: Regions_;
				}
				ElementParameter HawaiiState {
					Range: Regions_;
				}
				ElementParameter AKState {
					Range: Regions_;
				}
			}
			DeclarationSection International_Region_Declarations {
				Set International_LNG {
					SubsetOf: Regions_;
					Index: ieo_lng;
					Comment: "Regions that international LNG is exogenously set for";
				}
				Set Mexico_ {
					SubsetOf: Regions_;
					Text: "Mexico";
					Index: mx, mx1;
					Comment: "Mexican subregions";
				}
				Set MexicoSouth {
					SubsetOf: Regions_;
					Index: MX_S;
				}
				Set Canada_ {
					SubsetOf: Regions_;
					Text: "Canada";
					Index: cn;
					Comment: "Canadian regions CN_E & CN_W";
				}
				Set INGMRegion_ {
					SubsetOf: Regions_;
					Index: r_ingm;
				}
				ElementParameter MexicoNorthEast {
					Range: Regions_;
				}
				ElementParameter CanadaEast {
					Range: Regions_;
				}
				ElementParameter CanadaWest {
					Range: Regions_;
				}
				Set InternationalRegions_ {
					SubsetOf: Regions_;
					Index: r_int;
					Definition: Canada_+Mexico_;
				}
				Set STEOImpExpRegions_ {
					SubsetOf: Regions_;
					Index: steocnmx;
					Definition: {
						!Canada_+ MexicoNorthEast
						!{CanadaEast, MexicoNorthEast}
						{ MexicoNorthEast}
					}
				}
			}
			DeclarationSection Census_Region_Declarations {
				ElementParameter TotalUS_MNUMCR {
					Range: MNUMCR_;
					Definition: last(MNUMCR_);
				}
				ElementParameter TotalUS_MNUMOR {
					Range: MNUMOR_;
					Definition: last(MNUMOR_);
				}
				ElementParameter CD_NewEngland {
					Range: Region_Census_;
				}
				ElementParameter CD_MidAtlantic {
					Range: Region_Census_;
				}
				ElementParameter CD_ENCentral {
					Range: Region_Census_;
				}
				ElementParameter CD_WNCentral {
					Range: Region_Census_;
				}
				ElementParameter CD_SAtlantic {
					Range: Region_Census_;
				}
				ElementParameter CD_ESCentral {
					Range: Region_Census_;
				}
				ElementParameter CD_WSCentral {
					Range: Region_Census_;
				}
				ElementParameter CD_Mountain {
					Range: Region_Census_;
				}
				ElementParameter CD_Pacific {
					Range: Region_Census_;
				}
			}
			DeclarationSection LNG_Region_Declarations {
				Set LNGDestination_ {
					Index: d_lng;
				}
				Set LNGTerminals_QP_ {
					SubsetOf: DemandNode_;
					Index: lngexp_qp;
					Definition: {
						!PossibleLNGTerminals_ *DemandNode_;
						
						!{lngexp|LNG_MaxExports(lngexp)}
					}
				}
				Set LNGTerminals_Lower48_ {
					SubsetOf: DemandNode_;
					Index: lngexp_l48;
					Definition: {
						LNGTerminals_QP_ !- CanadaWest
					}
				}
				Set PossibleLNGTerminals_ {
					SubsetOf: Regions_;
					Index: lngexp;
					Definition: {
						!LNGTerminals_QP_ + AKState;  Canada LNG Exports are Exogenous
						
						LNGTerminals_QP_ + AKState + CanadaWest;
					}
				}
			}
			DeclarationSection GOM_Region_Declarations {
				ElementParameter AlabamaGOM {
					Range: SupplyNode_;
				}
				ElementParameter GOMRegion {
					Range: Regions_;
				}
				ElementParameter EasternGOM {
					Range: Regions_;
				}
				ElementParameter WesternGOM {
					Range: Regions_;
				}
				ElementParameter CentralGOM {
					Range: Regions_;
				}
				ElementParameter TexasGOM {
					Range: SupplyNode_;
				}
				ElementParameter LouisianaGOM {
					Range: SupplyNode_;
				}
				ElementParameter MississippiGOM {
					Range: SupplyNode_;
				}
				ElementParameter GOMpriceRegion {
					IndexDomain: gom_ogdist;
					Range: Regions_;
					Comment: "Mapping of federal offshore GOM OGSM regions to federal offshore GOM states for the purpose of assigning wellhead price";
				}
			}
			DeclarationSection Alaska_Region_Declarations {
				ElementParameter AKRegion_South {
					Range: AKRegion_;
				}
				ElementParameter AKRegion_North {
					Range: AKRegion_;
				}
				Set AKRegion_ {
					Index: r_ak;
				}
			}
			DeclarationSection Supply_Type_Set_Declarations {
				Set SupplyType_ {
					Index: suptype;
				}
				Set NA_AD_ {
					SubsetOf: SupplyType_;
					Index: naadgas;
				}
				Set DomesticSupply_ {
					SubsetOf: SupplyType_;
					Index: domsuptype;
				}
				Set SNG_ {
					SubsetOf: SupplyType_;
					Index: sng;
				}
				Set VariableSupply_ {
					SubsetOf: SupplyType_;
					Index: varsup;
				}
				Set FixedSupply_ {
					SubsetOf: SupplyType_;
					Index: fixsup;
					Definition: SupplyType_ - VariableSupply_;
				}
				ElementParameter Supply_NA {
					Range: SupplyType_;
				}
				ElementParameter Supply_AD {
					Range: SupplyType_;
				}
				ElementParameter Supply_LNG {
					Range: SupplyType_;
				}
				ElementParameter Supply_SNGcoal {
					Range: SupplyType_;
				}
			}
			DeclarationSection Sector_Set_Declarations {
				Set SubSector_ {
					Index: ssec;
				}
				Parameter map_Sector_Subsector {
					IndexDomain: (sec,ssec);
					Range: binary;
				}
				Set Sector_ResCom_ {
					SubsetOf: Sector_;
					Index: rescom;
				}
				ElementParameter Sector_Residential {
					Range: Sector_;
				}
				Set Sector_ {
					Index: sec;
				}
				ElementParameter Sector_Commercial {
					Range: Sector_;
				}
				ElementParameter Sector_Industrial {
					Range: Sector_;
				}
				ElementParameter Sector_Electric {
					Range: Sector_;
				}
				ElementParameter Sector_Transportation {
					Range: Sector_;
				}
			}
			DeclarationSection Case_Related_Declarations {
				Set NEMScase_ {
					Index: NEMScase;
				}
				ElementParameter ReferenceCase {
					Range: NEMScase_;
				}
				ElementParameter HighWOPCase {
					Range: NEMScase_;
				}
				ElementParameter LowWOPCase {
					Range: NEMScase_;
				}
			}
			DeclarationSection Other_Dimension_Declarations {
				Set HMMSeason_ {
					SubsetOf: Integers;
					Index: hmmseason;
				}
				Set Supply_Curve_Step_ {
					Index: step, x_step;
				}
				ElementParameter FirstStep {
					Range: Supply_Curve_Step_;
					Definition: first(step);
				}
				Parameter X_supcrvstep {
					IndexDomain: (step,x_step);
					Range: binary;
				}
				Set Tariff_Curve_Step_ {
					SubsetOf: Supply_Curve_Step_;
					Index: tstep;
				}
				Set CrudeType_ {
					Index: crude;
				}
				Set Units_ {
					Index: units;
				}
				Set Season_ {
					Index: season;
				}
			}
		}
		Section Time {
			Comment: "YDA";
			DeclarationSection Period_Declarations {
				Parameter NumberOfPeriodsInPlanningInterval {
					Range: {
						{1..inf}
					}
					InitialData: 12;
				}
				Horizon MonthlyHorizon_ {
					Index: tmon;
					CurrentPeriod: FirstPeriodInPlanningInterval;
					IntervalLength: NumberOfPeriodsInPlanningInterval;
					Definition: {
						{'past01'..'past12'} + ElementRange( 1,NumberOfPeriods, prefix: "period-")
					}
				}
				Parameter NumberOfMonthsInPeriod {
					IndexDomain: tmon;
					Property: NoSave;
					Definition: 1;
				}
				Parameter NumberOfYearsInPeriod {
					IndexDomain: tmon;
					Property: NoSave;
					Definition: 1;
				}
			}
			DeclarationSection Period_Declarations_for_Capacity_Expansion {
				Parameter CapExpNumberOfPeriodsInPlanningInterval {
					Range: {
						{1..inf}
					}
					InitialData: 2;
				}
				Horizon CapExpHorizon_ {
					Index: tcapexp;
					CurrentPeriod: CapExpFirstPeriodInPlanningInterval;
					IntervalLength: CapExpNumberOfPeriodsInPlanningInterval;
					Definition: {
						{'past1'..'past2'} + ElementRange( 1,CapExpNumberOfPeriods, prefix: "p-")
					}
				}
				Parameter CapExpNumberOfMonthsInPeriod {
					IndexDomain: tcapexp;
					Definition: 1;
				}
				Parameter CapExpNumberOfPeriods {
					Unit: year;
					InitialData: 80;
					Comment: "Number of periods is equal to first the number of model years (2050-2015+1) multiplied by number of months in year (12)";
				}
			}
			DeclarationSection Period_Declarations_for_History {
				Parameter NumberOfHistoricalPeriods {
					Range: {
						{0..inf}
					}
					Unit: year;
					InitialData: 12;
				}
				Horizon MonthlyHorizonHistorical_ {
					Index: htmon;
					CurrentPeriod: FirstPeriodInHistPlanningInterval;
					IntervalLength: NumberOfPeriodsInPlanningInterval;
					Definition: ElementRange( 1,NumberOfHistoricalPeriods, prefix: "period-");
				}
				ElementParameter FirstPeriodInHistPlanningInterval {
					Range: MonthlyHorizonHistorical_;
					InitialData: 'period-01';
				}
				ElementParameter MonthInHistPeriod {
					IndexDomain: htmon;
					Range: Months_;
				}
				ElementParameter YearInHistPeriod {
					IndexDomain: htmon;
					Range: Years_;
					Definition: {
						!MonthToYear(MonthInPeriod(tmon))
					}
				}
				Parameter NumberOfMonthsInHistPeriod {
					IndexDomain: htmon;
					Definition: 1;
				}
			}
			DeclarationSection Calendar_Declarations {
				Set Months_ {
					SubsetOf: XMonths_;
					Index: mon, function_mon;
					Definition: {
						{FirstHistoricalMonth..YearToMonth(LastModelYear)+11}
					}
				}
				Calendar XMonths_ {
					Index: xmon;
					Unit: month;
					BeginDate: BeginDateOfCalendar;
					EndDate: EndDateOfCalendar;
					TimeslotFormat: "%sAm|AllMonths|, %c%y";
				}
				Set CapacityExpansionMonths_ {
					SubsetOf: Months_;
					Definition: {
						{mon | TimeslotCharacteristic(mon,'month')=1 or TimeslotCharacteristic(mon,'month')=8  }
					}
					Comment: "Define capacity expansion months as January and August";
				}
				Set InactiveMonths {
					SubsetOf: Months_;
					Property: NoSave;
					Definition: Months_-ActiveMonths;
				}
				Set ActiveMonths {
					SubsetOf: Months_;
					Definition: Months_;
				}
				Set Januaries_ {
					SubsetOf: Months_;
					Definition: {
						{mon | TimeslotCharacteristic(mon,'month')=1}
					}
				}
				Set InactiveMonthsCapExp {
					SubsetOf: Months_;
					Definition: Months_- CapacityExpansionMonths_;
				}
				Set Years_ {
					SubsetOf: XYears_;
					Index: year;
					OrderBy: xyear;
					Definition: {
						{FirstHistoricalYear..LastModelYear}
					}
				}
				Calendar XYears_ {
					Index: xyear;
					Unit: year;
					BeginDate: BeginDateOfCalendar;
					EndDate: EndDateOfCalendar;
					TimeslotFormat: "%c%y";
				}
				ElementParameter MonthToYear {
					IndexDomain: xmon;
					Range: XYears_;
					Property: NoSave;
					Definition: first(xyear | TimeSlotCharacteristic(xyear, 'year') = TimeSlotCharacteristic(xmon, 'year') );
				}
				ElementParameter YearToMonth {
					IndexDomain: xyear;
					Range: XMonths_;
					Definition: first(xmon | TimeSlotCharacteristic(xmon, 'year') = TimeSlotCharacteristic(xyear, 'year') );
				}
				ElementParameter LastYearInCalendar {
					Range: XYears_;
					Definition: last(XYears_);
				}
				ElementParameter LastMonthInCalendar {
					Range: XMonths_;
					Definition: last(Months_);
				}
				Set InactiveYears {
					SubsetOf: Years_;
				}
				Set ForecastYears {
					SubsetOf: Years_;
					Index: fyear;
					Definition: Years_-HistoricalYears_;
				}
				Parameter map_month_year {
					IndexDomain: (mon,year)|MonthToYear(mon)=year;
					Range: binary;
					Property: NoSave;
					Definition: 1;
				}
				Parameter map_month_year_adj {
					IndexDomain: (mon,year)|MonthToYear(mon)=year;
					Range: binary;
					Property: NoSave;
					Definition: 1;
				}
				Set Days_ {
					SubsetOf: XDays_;
					Index: days;
					Definition: {
						{MonthToDay(FirstHistoricalMonth)..MonthToDay(LastModelMonth)+30}
					}
				}
				Calendar XDays_ {
					Index: xdays;
					Unit: day;
					BeginDate: BeginDateOfCalendar;
					EndDate: EndDateOfCalendar;
					TimeslotFormat: "%sd %sAm|AllMonths|, %c%y";
				}
				Set DaysInMonth_ {
					IndexDomain: xmon;
					SubsetOf: XDays_;
					Property: NoSave;
					Definition: {
						{xdays | TimeSlotCharacteristic(xdays, 'year') = TimeSlotCharacteristic(xmon, 'year')
						        and
						        TimeSlotCharacteristic(xmon, 'month') = TimeSlotCharacteristic(xdays, 'month')}
					}
				}
				ElementParameter DayToMonth {
					IndexDomain: xdays;
					Range: XMonths_;
					Definition: {
						first(xmon | TimeSlotCharacteristic(xmon, 'year') = TimeSlotCharacteristic(xdays, 'year')
						            and
						            TimeSlotCharacteristic(xmon, 'month') = TimeSlotCharacteristic(xdays, 'month') )
					}
				}
				ElementParameter MonthToDay {
					IndexDomain: xmon;
					Range: XDays_;
					Definition: {
						first(xdays | TimeSlotCharacteristic(xmon, 'year') = TimeSlotCharacteristic(xdays, 'year')
						            and
						            TimeSlotCharacteristic(xmon, 'month') = TimeSlotCharacteristic(xdays, 'month') )
					}
				}
				ElementParameter DayToYear {
					IndexDomain: xdays;
					Range: XYears_;
					Definition: first(xyear | TimeSlotCharacteristic(xyear, 'year') = TimeSlotCharacteristic(xdays, 'year'));
				}
			}
			DeclarationSection NGMM_Time_Declarations {
				ElementParameter CurrentMNUMYR {
					Range: MNXYRS_;
				}
				ElementParameter LastHistoricalMonth {
					Range: XMonths_;
					Property: NoSave;
					Definition: LastHistoricalYear1stMonth + 11;
					Comment: "Define the last month in the Last Historical Year";
				}
				ElementParameter LastHistoricalYear1stMonth {
					Range: XMonths_;
					Property: NoSave;
					Definition: YearToMonth(LastHistoricalYear);
					Comment: "First month in the Last Historical Year";
				}
				ElementParameter FirstHistoricalMonth {
					Range: XMonths_;
					Property: NoSave;
					Definition: first(xmon);
				}
				Set HistoricalYearMonths_ {
					SubsetOf: Months_;
					Index: histmon;
					Property: NoSave;
					Definition: {
						{FirstHistoricalMonth..LastHistoricalMonth}
					}
				}
				Set HistoricalQPYearMonths_ {
					SubsetOf: Months_;
					Index: hqpmon;
					Property: NoSave;
					Definition: {
						{ YearToMonth(HQPYear) .. YearToMonth(HQPYear)+11 }
					}
				}
				Set LastHistoricalYearMonths_ {
					SubsetOf: Months_;
					Index: lhisyr;
					Property: NoSave;
					Definition: {
						{LastHistoricalYear1stMonth..LastHistoricalMonth}
					}
					Comment: "Month-Years in the Last Historical Year";
				}
				Set ModelYearMonths_ {
					SubsetOf: Months_;
					Index: modelyrmn;
					Property: NoSave;
					Definition: {
						{ YearToMonth(ModelYear) .. YearToMonth(ModelYear)+11 }
					}
					Comment: "Months in ModelYear";
				}
				Set LaggedModelYearMonths_ {
					SubsetOf: Months_;
					Index: lagyrmn;
					Property: NoSave;
					Definition: {
						{ YearToMonth(ModelYear-1) .. YearToMonth(ModelYear)+11 }
					}
					Comment: "Months in ModelYear-1 plus ModelYear";
				}
				Set LaggedHistModelYearMonths_ {
					SubsetOf: Months_;
					Index: laghistyrmn;
					Property: NoSave;
					Definition: {
						{ YearToMonth(FirstHistoricalYear) .. YearToMonth(ModelYear)+11 }
					}
					Comment: "Months in all years up to ModelYear";
				}
				Set FutureYears_ {
					SubsetOf: XYears_;
					Index: futyear;
					Property: NoSave;
					OrderBy: xyear;
					Definition: {
						{ElementCast(XYears_,ModelYear+1)..LastModelYear}
					}
				}
				Set ActualDataMonths_ {
					SubsetOf: XMonths_;
					Index: hdatamon;
					Property: NoSave;
					Definition: {
						{ YearToMonth(FirstHistoricalYear) .. YearToMonth(LastHistoricalDataYear)+11 }
					}
					Comment: "Months in all years up to ModelYear";
				}
				Set ActualDataYears_ {
					SubsetOf: XYears_;
					Index: hdatayear;
					Property: NoSave;
					OrderBy: xyear;
					Definition: {
						{FirstHistoricalYear..LastHistoricalDataYear}
					}
				}
				Set FirstModelYearMonths_ {
					SubsetOf: Months_;
					Index: firstmonyr;
					Property: NoSave;
					Definition: {
						{ YearToMonth(FirstModelYear) .. YearToMonth(FirstModelYear)+11 }
					}
					Comment: "Months in ModelYear";
				}
				Set HistoricalYears_ {
					SubsetOf: XYears_;
					Index: histyr;
					Property: NoSave;
					OrderBy: xyear;
					Definition: {
						{FirstHistoricalYear..LastHistoricalYear}
					}
					Comment: "Define the set of historical years";
				}
				ElementParameter LastHistoricalYear {
					Range: XYears_;
					Property: NoSave;
					Definition: FirstModelYear-1;
				}
				ElementParameter FirstHistoricalYear {
					Range: XYears_;
					Property: NoSave;
					Definition: first(xyear);
				}
				ElementParameter LastDataYear {
					Range: XYears_;
				}
				ElementParameter LastDataMonth {
					Range: XMonths_;
					Property: NoSave;
					Definition: YearToMonth(LastDataYear)+11;
					Comment: "First month in the Last Historical Year";
				}
				Set HistoricalDataYears_ {
					SubsetOf: XYears_;
					Index: datayear;
					Property: NoSave;
					OrderBy: xyear;
					Definition: {
						{FirstHistoricalYear..LastDataYear}
					}
					Comment: "Define the set of historical years";
				}
				Set HistoricalDataMonths_ {
					SubsetOf: XMonths_;
					Index: datamon;
					Property: NoSave;
					Definition: {
						{FirstHistoricalMonth..LastDataMonth}
					}
				}
				ElementParameter ModelYear {
					Range: Years_;
				}
				ElementParameter FirstModelMonth {
					Range: XMonths_;
					Property: NoSave;
					Definition: YearToMonth(FirstModelYear);
				}
				ElementParameter LastModelMonth {
					Range: XMonths_;
					Property: NoSave;
					Definition: YearToMonth(LastModelYear)+11;
				}
				ElementParameter CURIYR {
					Range: MNUMYR_;
					Property: NoSave;
					Definition: NCNTRL_CURIYR(1);
				}
				ElementParameter LastHistoricalDataYear {
					Range: XYears_;
				}
				ElementParameter LastHistoricalDataMonth {
					Range: XMonths_;
				}
				ElementParameter LNGLastHistoricalYear {
					Range: Years_;
				}
				Set MonthinYear_ {
					SubsetOf: Integers;
					Text: "Months Jan-Dec";
					Index: mn;
					Property: NoSave;
					Definition: {
						{01..012}
					}
				}
				ElementParameter FirstHQPYear {
					Range: XYears_;
					InitialData: '2014';
				}
				ElementParameter LastHQPYear {
					Range: XYears_;
					InitialData: '2014';
				}
				ElementParameter HQPYear {
					Range: Years_;
				}
				Set HQPYearMonths_ {
					SubsetOf: Months_;
					Index: hqpyrmn;
					Property: NoSave;
					Definition: {
						{ YearToMonth(HQPYear) .. YearToMonth(HQPYear)+11 }
					}
					Comment: "Months in ModelYear";
				}
				ElementParameter LastFutureYear {
					Range: XYears_;
				}
				ElementParameter MexCapYear {
					Range: XYears_;
				}
			}
			Procedure WriteNumberOfDaysToFile {
				Body: {
					write NumberOfDaysInMonth to file "data\\ngdays.txt" ;
					write NumberOfDaysInYear to file "data\\ngdays.txt" in merge mode;
				}
				Comment: {
					"This is a standalone procedure used to write out the number of days in each month and year to ngdays.txt
					This procedure should be run when EndDateOfCalendar changes. Prior to running uncomment the definitions of NumberOfDaysInMonth and NumberOfDaysInYear"
				}
			}
		}
		Section Time_in_Case_File {
			DeclarationSection Period_Case_File_Declarations {
				ElementParameter FirstPeriodInPlanningInterval {
					Range: MonthlyHorizon_;
					InitialData: {
						!first(tmon | tmon in MonthlyHorizon_.planning)
						'period-001'
					}
				}
				ElementParameter FirstPeriodInYear {
					Range: MonthlyHorizon_;
				}
				Set PeriodsInYear {
					IndexDomain: year;
					SubsetOf: MonthlyHorizon_;
				}
				ElementParameter CapExpFirstPeriodInPlanningInterval {
					Range: CapExpHorizon_;
					InitialData: 'p-01';
				}
				ElementParameter CapExpMonthInPeriod {
					IndexDomain: (tcapexp);
					Range: Months_;
				}
				ElementParameter CapExpYearInPeriod {
					IndexDomain: (tcapexp);
					Range: Years_;
				}
			}
			DeclarationSection Calendar_Case_File_Declarations {
				ElementParameter MonthsInHMMSeason {
					IndexDomain: mon;
					Range: HMMSeason_;
					Property: NoSave;
					Definition: {
						if (TimeslotCharacteristic(mon,'month') <= 3 or TimeslotCharacteristic(mon,'month') =12) then
						'4'
						elseif (4 <= TimeslotCharacteristic(mon,'month') <= 5) then
						'1'
						elseif (6 <= TimeslotCharacteristic(mon,'month') <= 9) then
						'2'
						elseif (10 <= TimeslotCharacteristic(mon,'month') <= 11) then
						'3'
						endif;
					}
				}
				ElementParameter MonthsInSeason {
					IndexDomain: mon;
					Range: Season_;
					Property: NoSave;
					Definition: {
						if (TimeslotCharacteristic(mon,'month') <= 3 or TimeslotCharacteristic(mon,'month') =12) then
						'peak'
						elseif (6 <= TimeslotCharacteristic(mon,'month') <= 9) then
						'offpeak'
						else
						'shoulder'
						endif;
					}
				}
				Parameter NumberOfDaysInMonth {
					IndexDomain: xmon;
					Range: integer;
					Definition: {
						!count(xdays| xmon = DayToMonth(xdays))
						!!sum(days, map_day_month(days, mon))
					}
				}
				ElementParameter MonthInPeriod {
					IndexDomain: tmon;
					Range: Months_;
				}
				Parameter NumberOfDaysInYear {
					IndexDomain: xyear;
					Range: integer;
					Definition: {
						!count(xdays| xyear = DayToYear(xdays))
						!!sum(days, map_day_month(days, mon))
					}
				}
				ElementParameter YearInPeriod {
					IndexDomain: tmon;
					Range: Years_;
					Definition: {
						!MonthToYear(MonthInPeriod(tmon))
					}
				}
			}
			DeclarationSection NGMM_Time_Case_File_Declarations {
				Parameter map_hmmseason_mn {
					IndexDomain: (hmmseason,mn);
					Range: binary;
				}
				Parameter map_season_mn {
					IndexDomain: (season,mn);
					Range: binary;
				}
				ElementParameter NoBuildYear {
					Range: XYears_;
				}
			}
			DeclarationSection Number_Of_Years_for_Average_Declarations {
				Set NumberOfYearsForAverage_Demand_ {
					Index: navgyr_dmd;
				}
				Set NumberOfYearsForAverage_Storage_ {
					Index: navgyr_storage;
				}
				Set NumberOfYearsForAverage_Plantfuel_ {
					Index: navgyr_plant;
				}
				Set NumberOfYearsForAverage_Leasefuel_ {
					Index: navgyr_lease;
				}
				Set NumberOfYearsForAverage_GOMprod_ {
					Index: navgyr_gomprod;
				}
				Set NumberOfYearsForAverage_Discrepancy_ {
					Index: navgyr_discr;
				}
				Set NumberOfYearsForAverage_Discrepancy_CN_ {
					Index: navgyr_discr_cn;
				}
				Set NumberOfYearsForAverage_SNG_ {
					Index: navgyr_sng;
				}
				Set NumberOfYearsForAverage_LNG_ {
					Index: navgyr_lng;
				}
				Set NumberOfYearsForAverage_Trans_ {
					Index: navgyr_trans;
				}
			}
		}
		Section Units_and_Quantities {
			Comment: "YDA";
			DeclarationSection Quantity_Declarations {
				Quantity SI_Time_Duration {
					BaseUnit: month;
					Conversions: {
						year->month : #-># * 12,
						day->month : #-># * 0.03287671233,
						s->month : #-># / 2628000
					}
					Comment: {
						"Expresses the value for the duration of periods.
						
						The unit s has been added automatically because it is a required unit for DataExchange."
					}
				}
			}
		}
	}
	Section Mapping_Section {
		DeclarationSection Seasonal_Mapping_Declarations {
			Parameter map_mon_hmmseason {
				IndexDomain: (mon,hmmseason) | (MonthsInHMMSeason(mon)=hmmseason);
				Range: binary;
				Definition: 1;
			}
			Parameter map_Month_MonthinYear {
				IndexDomain: (xmon,mn)|TimeslotCharacteristic(xmon,'month')=mn;
				Range: binary;
				Definition: 1;
			}
			Parameter map_MonthinYear_ModelYearMonth {
				IndexDomain: (mn,modelyrmn)|TimeslotCharacteristic(modelyrmn,'month')=mn;
				Range: binary;
				Definition: 1;
			}
			Parameter map_mon_season {
				IndexDomain: (mon,season)|(MonthsInSeason(mon)=season);
				Range: binary;
				Definition: 1;
			}
			Parameter map_citygate_seasonmon {
				IndexDomain: (mon,season);
				Definition: sum(mn | map_Month_MonthinYear(mon,mn), map_citygate_season(mn, season));
			}
			Parameter map_citygate_season {
				IndexDomain: (mn,season);
			}
			Parameter map_capexp_season {
				IndexDomain: (mn,season);
			}
		}
		DeclarationSection Regional_Mapping_Declarations {
			Parameter map_Supply {
				IndexDomain: (s,suptype);
				Text: "maps Supply types to Supply regions";
				Range: binary;
			}
			Parameter map_HubArcs {
				IndexDomain: (h,h1);
				Text: "define existing links between regions";
				Range: binary;
			}
			Parameter map_SupplyArcs {
				IndexDomain: (s,h);
				Text: "define existing links between regions";
				Range: binary;
			}
			Parameter map_StorageArcs {
				IndexDomain: (storage,qph);
				Text: "define existing links between regions";
				Range: binary;
			}
			Parameter map_DemandArcs {
				IndexDomain: (qph,qpd);
				Text: "define existing links between regions";
				Range: binary;
			}
			Parameter map_LNGExpArcs {
				IndexDomain: (h,lngexp_qp);
				Text: "define existing links between regions";
				Range: binary;
			}
			Parameter map_Mexico {
				IndexDomain: (mx,mx1);
				Range: binary;
			}
			Parameter map_State_CensusRegion {
				IndexDomain: (state,r_cen);
			}
			Parameter map_State_NNGEMM {
				IndexDomain: (state,NNGEMM);
				Range: binary;
			}
			Parameter map_substate_state {
				IndexDomain: (substate,state);
			}
			Parameter map_hubs_borderXings {
				IndexDomain: (h,bx);
				Range: binary;
			}
			Parameter map_supply_lngexp {
				IndexDomain: (s,lngexp);
			}
			Parameter map_GOMregions {
				IndexDomain: (gom_ogdist,fedGOMstate);
				Comment: "Mapping of federal offshore GOM OGSM regions to federal offshore GOM states";
			}
			Parameter map_l48Arcs {
				IndexDomain: (h,h1);
			}
		}
	}
	Section QP_Structure {
		Procedure SetSolverOptions {
			Body: {
				option 'Cplex 22.1'.qp_method := 'barrier';
				option 'Cplex 22.1'.barrier_crossover_algorithm  := 'dual_crossover';
			}
		}
		Section Supply_Curve_Setup {
			DeclarationSection Supply_Curve_Definitions {
				Set SupCrv_Option_ {
					Index: supcrv_opt;
					Definition: {
						{1..4}
					}
				}
				Set SubCrvStep_ {
					SubsetOf: Supply_Curve_Step_;
					Index: substep;
				}
				Parameter map_SupCrvOption {
					IndexDomain: (s,suptype);
				}
				Set crv_num_ {
					Index: sc_n;
					Definition: {
						{1..5}
					}
				}
				Set supnum_ {
					Index: n;
					Definition: {
						{1..3}
					}
					Comment: "generic counter for processing supply curve steps";
				}
				ElementParameter SupCrv_Step1 {
					Range: Supply_Curve_Step_;
					Definition: Element(Supply_Curve_Step_,1);
					Comment: "First step on the supply curve";
				}
				ElementParameter SupCrv_Step2 {
					Range: Supply_Curve_Step_;
					Definition: Element(Supply_Curve_Step_,2);
					Comment: "First step on the supply curve";
				}
				ElementParameter SupCrv_Step3 {
					Range: Supply_Curve_Step_;
					Definition: Element(Supply_Curve_Step_,3);
					Comment: "First step on the supply curve";
				}
				ElementParameter SupCrv_Step4 {
					Range: Supply_Curve_Step_;
					Definition: Element(Supply_Curve_Step_,4);
					Comment: "First step on the supply curve";
				}
				ElementParameter SupCrv_Step5 {
					Range: Supply_Curve_Step_;
					Definition: Element(Supply_Curve_Step_,5);
					Comment: "First step on the supply curve";
				}
				ElementParameter SupCrv_Step6 {
					Range: Supply_Curve_Step_;
					Definition: Element(Supply_Curve_Step_,6);
					Comment: "First step on the supply curve";
				}
				ElementParameter Crv_OPT1 {
					Range: SupCrv_Option_;
					Definition: nth(supcrv_opt,1);
				}
				ElementParameter N1 {
					Range: supnum_;
					Definition: nth(n,1);
				}
				ElementParameter N2 {
					Range: supnum_;
					Definition: nth(n,2);
				}
				ElementParameter N3 {
					Range: supnum_;
					Definition: nth(n,3);
				}
				ElementParameter SC_N1 {
					Range: crv_num_;
					Definition: nth(sc_n,1);
				}
				ElementParameter SC_N2 {
					Range: crv_num_;
					Definition: nth(sc_n,2);
				}
				ElementParameter SC_N3 {
					Range: crv_num_;
					Definition: nth(sc_n,3);
				}
				ElementParameter SC_N4 {
					Range: crv_num_;
					Definition: nth(sc_n,4);
				}
				ElementParameter SC_N5 {
					Range: crv_num_;
					Definition: nth(sc_n,5);
				}
				Parameter SupCrv_Param {
					IndexDomain: (supcrv_opt,step);
				}
				Parameter SupElas_Param {
					IndexDomain: (supcrv_opt,step);
				}
				Parameter Param_SupCrv {
					IndexDomain: (supcrv_opt,sc_n);
				}
				Parameter Param_SupElas {
					IndexDomain: (supcrv_opt,sc_n);
				}
				Parameter ParameterSupCrv {
					IndexDomain: (supcrv_opt,step,n);
				}
				Parameter ParameterSupElasticity {
					IndexDomain: (supcrv_opt,step,n);
				}
				Parameter SupCrvParameter {
					IndexDomain: (suptype,step);
					Definition: prod( n, (1+Parameter_SupCrv(suptype, step, n)));
				}
				Parameter SupCrvPriceElasticity {
					IndexDomain: (suptype,step);
					Definition: prod( n, (1 + Parameter_PrcElasticity(suptype, step, n) /$ Parameter_SupElasticity(suptype,step,n)));
				}
				Parameter Parameter_SupCrv {
					IndexDomain: (suptype,step,n);
				}
				Parameter Parameter_SupElasticity {
					IndexDomain: (suptype,step,n);
				}
				Parameter Parameter_PrcElasticity {
					IndexDomain: (suptype,step,n);
				}
			}
			Procedure SupplyCurveParameters {
				Body: {
					ParameterSupElasticity(supcrv_opt, step, n):=1;
					Param_SupCrv(supcrv_opt, SC_N4):=Param_SupElas(supcrv_opt, SC_N1); !minQ (at P1=0) determined based on the step1 elasticity
					
					SubCrvStep_:={SupCrv_Step1,SupCrv_Step2,SupCrv_Step3};
					ParameterSupCrv(supcrv_opt, substep, N1):= - Param_SupCrv(supcrv_opt, SC_N1);
					SubCrvStep_:={SupCrv_Step4,SupCrv_Step5,SupCrv_Step6};
					ParameterSupCrv(supcrv_opt, substep, N1):= Param_SupCrv(supcrv_opt, SC_N1);
					ParameterSupElasticity(supcrv_opt, step, N1):= Param_SupElas(supcrv_opt, SC_N3);
					
					SubCrvStep_:={SupCrv_Step1,SupCrv_Step2};
					ParameterSupCrv(supcrv_opt, substep, N2):= - Param_SupCrv(supcrv_opt, SC_N2);
					ParameterSupElasticity(supcrv_opt, substep, N2):= Param_SupElas(supcrv_opt, SC_N2);
					SubCrvStep_:={SupCrv_Step5,SupCrv_Step6};
					ParameterSupCrv(supcrv_opt, substep, N2):= Param_SupCrv(supcrv_opt, SC_N2);
					ParameterSupElasticity(supcrv_opt, substep, N2):= Param_SupElas(supcrv_opt, SC_N4);
					
					ParameterSupCrv(supcrv_opt, SupCrv_Step1, N3):= -Param_SupCrv(supcrv_opt, SC_N4);
					ParameterSupElasticity(supcrv_opt, SupCrv_Step1, N3):= Param_SupElas(supcrv_opt, SC_N1);
					
					ParameterSupCrv(supcrv_opt, SupCrv_Step6, N3):= Param_SupCrv(supcrv_opt, SC_N3);
					ParameterSupElasticity(supcrv_opt, SupCrv_Step6, N3):= Param_SupElas(supcrv_opt, SC_N5);
					
					SupCrv_Param(supcrv_opt, step):= prod( n, (1+ParameterSupCrv(supcrv_opt, step, n)));
					SupElas_Param(supcrv_opt, step):= prod( n, (1 + ParameterSupCrv(supcrv_opt, step, n) /$ ParameterSupElasticity(supcrv_opt,step,n)));
					
					
					!Define parameters for fixed supply (option 1)
					SupElas_Param(Crv_OPT1, step):=0;
					SupCrv_Param(Crv_OPT1, step):=0;
					SupCrv_Param(Crv_OPT1, SupCrv_Step6):=1;
				}
			}
			Procedure SupplyCurveBasePoints {
				Body: {
					Param_SupCrv(supcrv_opt, SC_N4):=Param_SupElas(supcrv_opt, SC_N1); !minQ (at P1=0) determined based on the step1 elasticity
					
					Qbase(tmon,suptype,qps,SupCrv_Step3) := QP_Supply(tmon,suptype,qps) * (1- Param_SupCrv(Element(SupCrv_Option_,map_SupCrvOption(qps, suptype)), SC_N1));
					Pbase(tmon,suptype,qps,SupCrv_Step3) := QP_SupplyPrice(tmon,suptype,qps) * (1- Param_SupCrv(Element(SupCrv_Option_,map_SupCrvOption(qps, suptype)), SC_N1)/ $
					                                                                               Param_SupElas(Element(SupCrv_Option_,map_SupCrvOption(qps, suptype)), SC_N3));
					Qbase(tmon,suptype,qps,SupCrv_Step4) := QP_Supply(tmon,suptype,qps) * (1+ Param_SupCrv(Element(SupCrv_Option_,map_SupCrvOption(qps, suptype)), SC_N1));
					Pbase(tmon,suptype,qps,SupCrv_Step4) := QP_SupplyPrice(tmon,suptype,qps) * (1+ Param_SupCrv(Element(SupCrv_Option_,map_SupCrvOption(qps, suptype)), SC_N1)/ $
					                                                                               Param_SupElas(Element(SupCrv_Option_,map_SupCrvOption(qps, suptype)), SC_N3));
					Qbase(tmon,suptype,qps,SupCrv_Step2) := Qbase(tmon,suptype,qps,SupCrv_Step3) * (1- Param_SupCrv(Element(SupCrv_Option_,map_SupCrvOption(qps, suptype)), SC_N2));
					Pbase(tmon,suptype,qps,SupCrv_Step2) := Pbase(tmon,suptype,qps,SupCrv_Step3) * (1- Param_SupCrv(Element(SupCrv_Option_,map_SupCrvOption(qps, suptype)), SC_N2)/ $
					                                                                               Param_SupElas(Element(SupCrv_Option_,map_SupCrvOption(qps, suptype)), SC_N2));
					Qbase(tmon,suptype,qps,SupCrv_Step5) := Qbase(tmon,suptype,qps,SupCrv_Step4) * (1+ Param_SupCrv(Element(SupCrv_Option_,map_SupCrvOption(qps, suptype)), SC_N2));
					Pbase(tmon,suptype,qps,SupCrv_Step5) := Pbase(tmon,suptype,qps,SupCrv_Step4) * (1+ Param_SupCrv(Element(SupCrv_Option_,map_SupCrvOption(qps, suptype)), SC_N2)/ $
					                                                                               Param_SupElas(Element(SupCrv_Option_,map_SupCrvOption(qps, suptype)), SC_N4));
					
					Qbase(tmon,suptype,qps,SupCrv_Step1) := Qbase(tmon,suptype,qps,SupCrv_Step2) * (1- Param_SupCrv(Element(SupCrv_Option_,map_SupCrvOption(qps, suptype)), SC_N4));
					Pbase(tmon,suptype,qps,SupCrv_Step1) := Pbase(tmon,suptype,qps,SupCrv_Step2) * (1- Param_SupCrv(Element(SupCrv_Option_,map_SupCrvOption(qps, suptype)), SC_N4)/ $
					                                                                               Param_SupElas(Element(SupCrv_Option_,map_SupCrvOption(qps, suptype)), SC_N1));
					Qbase(tmon,suptype,qps,SupCrv_Step6) := Qbase(tmon,suptype,qps,SupCrv_Step5) * (1+ Param_SupCrv(Element(SupCrv_Option_,map_SupCrvOption(qps, suptype)), SC_N3));
					Pbase(tmon,suptype,qps,SupCrv_Step6) := Pbase(tmon,suptype,qps,SupCrv_Step5) * (1+ Param_SupCrv(Element(SupCrv_Option_,map_SupCrvOption(qps, suptype)), SC_N3)/ $
					                                                                               Param_SupElas(Element(SupCrv_Option_,map_SupCrvOption(qps, suptype)), SC_N5));
					
					Qbase((tmon,suptype,qps,SupCrv_Step6) | map_SupCrvOption(qps, suptype)=1) := QP_Supply(tmon,suptype,qps);
				}
				Comment: {
					"Alternative way of calculating the base points for supply curves.
					Test showed that this takes more time, so not used - may be removed"
				}
			}
		}
		DeclarationSection Supply_Curve_Declarations {
			Parameter Qbase {
				IndexDomain: (tmon,suptype,s,step);
			}
			Parameter QbaseMin {
				IndexDomain: (tmon,suptype,s);
				Comment: "Minimum production";
			}
			Parameter QbaseMax {
				IndexDomain: (tmon,suptype,s);
				Comment: "Minimum production";
			}
			ElementParameter SupCrv_MaxStep {
				Range: Supply_Curve_Step_;
				Definition: Element(Supply_Curve_Step_,5);
				Comment: "Maximum step on the supply curve";
			}
			Parameter Q_UpperBound {
				IndexDomain: (tmon,suptype,s,step);
				Range: nonnegative;
				Definition: {
					!if step = 'step1' then
					!  Qbase(step,suptype,s,tmon)*(1-PCTLP(suptype,s))
					!elseif step = 'step2' then
					!   (Qbase(step,suptype,s,tmon)-Qbase('step1',suptype,s,tmon))*(1-PCTLP(suptype,s))
					!elseif step = 'step3' then
					!   (Qbase('step4',suptype,s,tmon)-Qbase('step2',suptype,s,tmon))*(1-PCTLP(suptype,s))
					!elseif step = 'step4' then
					!   (Qbase('step5',suptype,s,tmon)-Qbase(step,suptype,s,tmon))*(1-PCTLP(suptype,s))
					!elseif step = 'step5' then
					!   Inf
					!endif
				}
			}
			Parameter Q_LowerBound {
				IndexDomain: (tmon,suptype,s,step);
				Range: nonnegative;
			}
			Parameter Pbase {
				IndexDomain: (tmon,suptype,s,step);
			}
		}
		DeclarationSection Tariff_Curve_Declarations {
			ElementParameter PTCrv_MaxStep {
				Range: Supply_Curve_Step_;
				Comment: "Maximum step on the pipeline tariff curve";
			}
			Parameter PipelineTariff {
				IndexDomain: (tmon,qph,qph1,step);
			}
			Parameter PipelineTariffReport {
				IndexDomain: (tmon,qph,qph1,step);
			}
			Parameter PipeTariffCurveQty {
				IndexDomain: (tmon,qph,qph1,step);
			}
			Parameter PipeTarCrvQty_UpBound {
				IndexDomain: (tmon,qph,qph1,step);
			}
			Parameter TarCrvQtyTot_UB {
				IndexDomain: (tmon,qph,qph1,step);
			}
			Parameter TarCrvQtyTot_LB {
				IndexDomain: (tmon,qph,qph1,step);
			}
			Parameter Fixed_Arc_Fee {
				IndexDomain: (tmon,reg,reg1);
				Text: "represents gathering charges, storage fees, fixed tariffs";
				Definition: 0;
			}
			Parameter QP_GatheringCharge {
				IndexDomain: (tmon,s);
				Text: "Gathering Charge";
				Comment: "represents gathering charges, storage fees, fixed tariffs";
			}
			Parameter QP_StorageFee {
				IndexDomain: (tmon,storage,qph);
				Text: "storage fee";
				InitialData: 0.1;
				Comment: "represents storage fees by arc in Planning Period";
			}
			Parameter Parameter_TariffCurvePrice {
				IndexDomain: (qph,qph1,step);
			}
			Parameter Parameter_CapacityUtilization {
				IndexDomain: (qph,qph1,step);
			}
			Parameter PriceStepAdj {
				Definition: 1.05;
			}
			Parameter Slope_TariffCurve {
				IndexDomain: (tmon,qph,qph1,step);
			}
			Parameter ConvexityCheck_TariffCurve {
				IndexDomain: (tmon,qph,qph1);
				Range: binary;
			}
			Parameter Slope_Check {
				IndexDomain: (tmon,qph,qph1,step);
			}
		}
		DeclarationSection LNG_Export_Curve_Declarations {
			ElementParameter LNGExpCrv_MaxStep {
				Range: Supply_Curve_Step_;
				Definition: Element(Supply_Curve_Step_,1);
				Comment: "Maximum step on the LNG export curve";
			}
			ElementParameter LNG_FirstStep {
				Range: Supply_Curve_Step_;
				Definition: first(step);
			}
			ElementParameter LNG_SecondStep {
				Range: Supply_Curve_Step_;
				Definition: Nth(step,2);
			}
			ElementParameter LNG_LastStep {
				Range: Supply_Curve_Step_;
				Definition: {
					!Nth(step,3)
					LNGExpCrv_MaxStep+1
				}
			}
			Parameter LNGExportPrc {
				IndexDomain: (tmon,lngexp_qp,step);
			}
			Parameter LNGExportQty {
				IndexDomain: (tmon,lngexp_qp,step);
			}
			Parameter LNGExport_UpBound {
				IndexDomain: (tmon,lngexp_qp,step);
			}
			Parameter LNGExport_LoBound {
				IndexDomain: (tmon,lngexp_qp,step);
			}
			Parameter Parameter_LNGExpQty {
				IndexDomain: step;
			}
			Parameter Parameter_LNGExpPrc {
				IndexDomain: step;
			}
		}
		DeclarationSection QP_Parameters {
			Parameter QP_SlackVar_Value {
				Comment: "Read in via ngassumptions.txt";
			}
			Parameter QP_Consumption {
				IndexDomain: (tmon,qpd);
			}
			Parameter QP_Discrepancy {
				IndexDomain: (tmon,qpd);
			}
			Parameter QP_Discrepancy_Supply {
				IndexDomain: (tmon,reg);
			}
			Parameter QP_Discrepancy_Demand {
				IndexDomain: (tmon,reg);
			}
			Parameter QP_PipefuelLossFactor {
				IndexDomain: h;
			}
			Parameter QP_Storage_Withdrawals {
				IndexDomain: (tmon,qpstorage);
				Definition: {
					!NetStorage(storage, mon)
				}
			}
			Parameter QP_Storage_Injections {
				IndexDomain: (tmon,qpstorage);
				Definition: {
					!NetStorage(storage, mon)
				}
			}
			Parameter QP_Supply {
				IndexDomain: (tmon,suptype,s);
			}
			Parameter QP_SupplyPrice {
				IndexDomain: (tmon,suptype,s);
			}
			Parameter QP_SupplyPriceSolution {
				IndexDomain: (mon,suptype,s);
			}
			Parameter QP_PipelineTariff {
				IndexDomain: (tmon,h,h1);
			}
			Parameter QP_Capacity {
				IndexDomain: (tmon,qph,qph1);
			}
			Parameter QP_LNGExportCapacity {
				IndexDomain: (tmon,lngexp_qp);
			}
			Parameter QP_LNGExportPrice {
				IndexDomain: (tmon,lngexp_qp);
			}
			Parameter QP_StorageLoss {
				IndexDomain: (tmon,qpstorage);
			}
			Parameter QP_DistributionLoss {
				IndexDomain: (tmon,qpd);
			}
			Parameter QP_IntrastatePipeFuelLoss {
				IndexDomain: (tmon,qpd);
			}
			Parameter QP_PlantFuel {
				IndexDomain: (tmon,qpd);
			}
			Parameter QPFLG_NegativeDemand {
				IndexDomain: (tmon,qpd);
			}
		}
		DeclarationSection QP_Variables_and_Constraints {
			Set TestConstraints {
				SubsetOf: AllConstraints;
				Definition: Data {SupplyMassBalance, TestHubBalance, DemandMassBalance};
			}
			Set MyConstraints {
				SubsetOf: AllConstraints;
				Definition: {
					Data {SupplyMassBalance,
					SupplyAccounting,
					HubBalance,
					TariffCurveQtyBalance,
					DemandMassBalance,
					StorageInjBalance,
					StorageWthBalance,
					LNGExportBalance,
					HubBalance_BXtoUS,
					HubBalance_UStoBX,
					!TariffCurveQtyTotal,
					OBJ_ALL_TX
					!DemandMassBalance_IMPEXP
					!SupplyMassBalance_IMPEXP
					}
				}
			}
			Set MyVariables {
				SubsetOf: AllVariables;
				Definition: {
					Data { QSupplyStep,
					       QProduction,
					       QLNGexp,
					       QTariffCurve,
					       FlowSupplyToHub,
					       FlowHubToHub,
					       FlowHubToDemand,
					       FlowHubToLNGExport,
					       FlowStorageToHub,
					       FlowHubToStorage,
					       SLackVar,
					       QTariffCurveTotal,
					       !OBJnew
					       OBJ_ALL_TX
					       }
				}
			}
			Set STEOConstraints {
				SubsetOf: AllConstraints;
				Definition: {
					Data {SupplyMassBalance,
					SupplyAccounting,
					HubBalance,
					TariffCurveQtyBalance,
					DemandMassBalance,
					StorageInjBalance,
					StorageWthBalance,
					LNGExportBalance,
					HubBalance_BXtoUS,
					HubBalance_UStoBX,
					!TariffCurveQtyTotal,
					OBJ_ALL_TX
					!DemandMassBalance_IMPEXPSTEO,
					!SupplyMassBalance_IMPEXPSTEO,
					!STEOCNExports,
					!STEOMXExports !,
					!STEOMXImports
					!STEOExports
					!STEOCNImports
					}
				}
			}
			Set STEOVariables {
				SubsetOf: AllVariables;
				Definition: {
					Data { QSupplyStep,
					       QProduction,
					       QLNGexp,
					       QTariffCurve,
					       FlowSupplyToHub,
					       FlowHubToHub,
					       FlowHubToDemand,
					       FlowHubToLNGExport,
					       FlowStorageToHub,
					       FlowHubToStorage,
					   !    STEODemandAdj,
					       SLackVar,
					       QTariffCurveTotal,
					       !OBJnew
					       OBJ_ALL_TX
					              }
				}
			}
			Set TestVariables {
				SubsetOf: AllVariables;
				Definition: Data { QSupplyStep, FlowSupplyToHub, FlowHubToHub, FlowHubToDemand, SLackVar};
			}
			Variable QSupplyStep {
				IndexDomain: (tmon,suptype,qps,step)| map_Supply(qps, suptype);
				Range: [Q_LowerBound(tmon, suptype, qps, step), Q_UpperBound(tmon, suptype, qps, step)];
			}
			Variable QProduction {
				IndexDomain: (tmon,suptype,qps)| QP_Supply(tmon,suptype,qps) and map_Supply(qps,suptype);
				Range: nonnegative;
				Property: ReducedCost;
				Comment: "Sums up production over all the steps of supply curve";
			}
			Variable QLNGexp {
				IndexDomain: (tmon,lngexp_qp,step)| QP_LNGExportCapacity(tmon,lngexp_qp);
				Range: [LNGExport_LoBound(tmon, lngexp_qp, step), LNGExport_UpBound(tmon, lngexp_qp, step)];
			}
			Variable QTariffCurve {
				IndexDomain: (tmon,qph,qph1,step)| QP_Capacity(tmon,qph,qph1);
				Range: [0, PipeTarCrvQty_UpBound(tmon, qph, qph1, step)];
			}
			Variable QTariffCurveTotal {
				IndexDomain: (tmon,qph,qph1,step)| QP_Capacity(tmon,qph,qph1) and step <= PTCrv_MaxStep;
				Range: free;
				Property: Inline;
				Definition: sum(x_step | x_step<=step, QTariffCurve(tmon,qph,qph1,x_step));
			}
			Variable FlowHubToHub {
				IndexDomain: (tmon,qph,qph1)| QP_Capacity(tmon,qph,qph1);
				Range: [0, QP_Capacity(tmon, qph, qph1)];
			}
			Variable FlowSupplyToHub {
				IndexDomain: (tmon,qps,qph) | map_SupplyArcs(qps, qph);
				Range: nonnegative;
			}
			Variable FlowHubToDemand {
				IndexDomain: (tmon,qph,qpd);
				Range: nonnegative;
			}
			Variable FlowHubToLNGExport {
				IndexDomain: (tmon,qph,lngexp_qp) | QP_LNGExportCapacity(tmon,lngexp_qp);
				Range: nonnegative;
			}
			Variable FlowStorageToHub {
				IndexDomain: (tmon,storage,qph);
				Range: nonnegative;
			}
			Variable FlowHubToStorage {
				IndexDomain: (tmon,qph,qpstorage);
				Range: nonnegative;
			}
			Variable VarSTEOLeaseFuelFactor {
				IndexDomain: year;
				Range: free;
			}
			Variable OBJ {
				Text: "Objective Function";
				Range: free;
				Definition: {
					sum(tmon,
					!Area under the Supply curve
					 - sum((suptype,qps,step) | map_Supply(qps,suptype) and step <= SupCrv_MaxStep, (Pbase(tmon,suptype,qps,step)*QSupplyStep(tmon,suptype,qps,step) +
					       0.5* sqr(QSupplyStep(tmon,suptype,qps,step)) * (Pbase(tmon,suptype,qps,step+1)-Pbase(tmon,suptype,qps,step))/ (Qbase(tmon,suptype,qps,step+1)-Qbase(tmon,suptype,qps,step))))
					- sum(qps, 10^9* SLackVar(tmon,qps))
					!Area under the Pipeline Tariff curve
					!-sum((h,h1,step)| QP_Capacity(tmon,h,h1) and step <= PTCrv_MaxStep, PipelineTariff(tmon,h,h1,step) * QTariffCurve(tmon,h,h1,step) +
					-sum((h,h1,step)| map_HubArcs(h,h1) and step <= PTCrv_MaxStep, PipelineTariff(tmon,h,h1,step) * QTariffCurve(tmon,h,h1,step) +
					     0.5 * sqr( QTariffCurve(tmon,h,h1,step) ) *
					     (PipelineTariff(tmon,h,h1,step+1) - PipelineTariff(tmon,h,h1,step) )/ (PipeTariffCurveQty(tmon,h,h1,step+1) - PipeTariffCurveQty(tmon,h,h1,step) ) )
					
					 !Fixed  Fees
					 - sum((h,h1) | QP_Capacity(tmon,h,h1), Fixed_Arc_Fee(tmon,h,h1) * FlowHubToHub(tmon,h,h1))
					
					  !Gathering Charges
					 - sum((qps,h) | map_SupplyArcs(qps, h), QP_GatheringCharge(tmon,qps) * FlowSupplyToHub(tmon, qps, h))
					
					 !Storage Fees
					 - sum((storage,h) | map_StorageArcs(storage,h), QP_StorageFee(tmon,storage,h) * FlowStorageToHub(tmon,storage,h))
					
					 !Area under the LNG Export Curve
					+ sum((lngexp_qp,step) | step <= LNGExpCrv_MaxStep, LNGExportPrc(tmon,lngexp_qp,step) * QLNGexp(tmon,lngexp_qp,step) +
					       0.5* sqr(QLNGexp(tmon,lngexp_qp,step)) * (LNGExportPrc(tmon,lngexp_qp,step+1)-LNGExportPrc(tmon,lngexp_qp,step)) / $ (LNGExportQty(tmon, lngexp_qp, step+1)-LNGExportQty(tmon,lngexp_qp,step))) )
				}
				Comment: "consumer plus producer surplus minus variable transport costs";
			}
			Variable OBJnew {
				Text: "Objective Function";
				Range: free;
				Definition: {
					sum(tmon,
					!Area under the Supply curve
					 - sum((suptype,qps,step) | map_Supply(qps,suptype) and step <= SupCrv_MaxStep, (Pbase(tmon,suptype,qps,step)*QSupplyStep(tmon,suptype,qps,step) +
					       0.5* sqr(QSupplyStep(tmon,suptype,qps,step)) * (Pbase(tmon,suptype,qps,step+1)-Pbase(tmon,suptype,qps,step))/ (Qbase(tmon,suptype,qps,step+1)-Qbase(tmon,suptype,qps,step))))
					- sum(qps, 10^9* SLackVar(tmon,qps))   !penalty for using slack supply
					
					! Pipeline Tariff curve
					-sum((h,h1)| map_HubArcs(h,h1), PipelineTariff(tmon,h,h1,FirstStep) * sum(step | step<=PTCrv_MaxStep, QTariffCurve(tmon,h,h1,step)) +
					     sum(step | step <= PTCrv_MaxStep-1, (PipelineTariff(tmon,h,h1,step+1)-PipelineTariff(tmon,h,h1,FirstStep) )* QTariffCurve(tmon,h,h1,step+1)) +
					     sum(step | step <= PTCrv_MaxStep,  QTariffCurve(tmon,h,h1,step) * sum(x_step | x_step<=step, QTariffCurve(tmon,h,h1,x_step)) *
					     (PipelineTariff(tmon,h,h1,step+1) - PipelineTariff(tmon,h,h1,step) )/ (PipeTariffCurveQty(tmon,h,h1,step+1) - PipeTariffCurveQty(tmon,h,h1,step) ) ))
					
					
					 !Fixed  Fees
					 - sum((h,h1) | QP_Capacity(tmon,h,h1), Fixed_Arc_Fee(tmon,h,h1) * FlowHubToHub(tmon,h,h1))
					
					  !Gathering Charges
					 - sum((qps,h) | map_SupplyArcs(qps, h), QP_GatheringCharge(tmon,qps) * FlowSupplyToHub(tmon, qps, h))
					
					 !Storage Fees
					 - sum((storage,h) | map_StorageArcs(storage,h), QP_StorageFee(tmon,storage,h) * FlowStorageToHub(tmon,storage,h))
					
					 !Area under the LNG Export Curve
					+ sum((lngexp_qp,step) | step <= LNGExpCrv_MaxStep, LNGExportPrc(tmon,lngexp_qp,step) * QLNGexp(tmon,lngexp_qp,step) +
					       0.5* sqr(QLNGexp(tmon,lngexp_qp,step)) * (LNGExportPrc(tmon,lngexp_qp,step+1)-LNGExportPrc(tmon,lngexp_qp,step)) / $ (LNGExportQty(tmon, lngexp_qp, step+1)-LNGExportQty(tmon,lngexp_qp,step))) )
				}
				Comment: "consumer plus producer surplus minus variable transport costs";
			}
			Variable OBJ_ALL {
				Text: "Objective Function";
				Range: free;
				Definition: {
					sum(tmon,
					!Area under the Supply curve
					 - sum((suptype,qps,step) | map_Supply(qps,suptype) and step <= SupCrv_MaxStep, (Pbase(tmon,suptype,qps,step)*QSupplyStep(tmon,suptype,qps,step) +
					       0.5* sqr(QSupplyStep(tmon,suptype,qps,step)) * (Pbase(tmon,suptype,qps,step+1)-Pbase(tmon,suptype,qps,step))/ (Qbase(tmon,suptype,qps,step+1)-Qbase(tmon,suptype,qps,step))))
					- sum(qps, QP_SlackVar_Value * SLackVar(tmon,qps))
					
					! Pipeline Tariff curve
					-sum((h,h1,step)| map_HubArcs(h,h1)and step <= PTCrv_MaxStep, (Slope_TariffCurve(tmon, h, h1, step)* QTariffCurve(tmon,h,h1,step)+ PipelineTariff(tmon,h,h1,step))*QTariffCurve(tmon,h,h1,step)*0.5
					        +0.5*(Slope_TariffCurve(tmon, h, h1, step)* QTariffCurve(tmon,h,h1,step)*PipeTariffCurveQty(tmon,h,h1,step)))
					!For the last term the idea is that QTariffCurve(step) is >0 only if QTariffCurve(step-1)=Upper Bound, therefore can be replaced by the Upper Bound (PipeTariffCurveQty(step))
					!0.5 term is added to be consistent with the rest of OF so that shadow price = actual value
					
					
					 !Fixed  Fees
					 - sum((h,h1) | QP_Capacity(tmon,h,h1), Fixed_Arc_Fee(tmon,h,h1) * FlowHubToHub(tmon,h,h1))
					
					  !Gathering Charges
					 - sum((qps,h) | map_SupplyArcs(qps, h), QP_GatheringCharge(tmon,qps) * FlowSupplyToHub(tmon, qps, h))
					
					 !Storage Fees
					 - sum((storage,h) | map_StorageArcs(storage,h), QP_StorageFee(tmon,storage,h) * FlowStorageToHub(tmon,storage,h))
					
					 !Area under the LNG Export Curve
					+ sum((lngexp_qp,step) | step <= LNGExpCrv_MaxStep, LNGExportPrc(tmon,lngexp_qp,step) * QLNGexp(tmon,lngexp_qp,step) +
					       0.5* sqr(QLNGexp(tmon,lngexp_qp,step)) * (LNGExportPrc(tmon,lngexp_qp,step+1)-LNGExportPrc(tmon,lngexp_qp,step)) / $ (LNGExportQty(tmon, lngexp_qp, step+1)-LNGExportQty(tmon,lngexp_qp,step))) )
				}
				Comment: {
					"consumer plus producer surplus minus variable transport costs
					YDA: Price times quantity for tariffs (a bit tricky with different segments)"
				}
			}
			Variable OBJ_Steo {
				Text: "Objective Function";
				Range: free;
				Definition: {
					sum(tmon,
					!Area under the Supply curve
					 - sum((suptype,qps,step) | map_Supply(qps,suptype) and step <= SupCrv_MaxStep, (Pbase(tmon,suptype,qps,step)*QSupplyStep(tmon,suptype,qps,step) +
					       0.5* sqr(QSupplyStep(tmon,suptype,qps,step)) * (Pbase(tmon,suptype,qps,step+1)-Pbase(tmon,suptype,qps,step))/ (Qbase(tmon,suptype,qps,step+1)-Qbase(tmon,suptype,qps,step))))
					- sum(qps, 10^9* SLackVar(tmon,qps))  !penalty for slack supply
					- sum(steocnmx, 10^6*STEODemandAdj(tmon, steocnmx))  !cost for demand adjustment for MX 
					! Pipeline Tariff curve
					-sum((h,h1)| map_HubArcs(h,h1), PipelineTariff(tmon,h,h1,FirstStep) * sum(step | step<=PTCrv_MaxStep, QTariffCurve(tmon,h,h1,step)) +
					     sum(step | step <= PTCrv_MaxStep-1, (PipelineTariff(tmon,h,h1,step+1)-PipelineTariff(tmon,h,h1,FirstStep) )* QTariffCurve(tmon,h,h1,step+1)) +
					     sum(step | step <= PTCrv_MaxStep,  QTariffCurve(tmon,h,h1,step) * sum(x_step | x_step<=step, QTariffCurve(tmon,h,h1,x_step)) *
					     (PipelineTariff(tmon,h,h1,step+1) - PipelineTariff(tmon,h,h1,step) )/ (PipeTariffCurveQty(tmon,h,h1,step+1) - PipeTariffCurveQty(tmon,h,h1,step) ) ))
					
					 !Fixed  Fees
					 - sum((h,h1) | QP_Capacity(tmon,h,h1), Fixed_Arc_Fee(tmon,h,h1) * FlowHubToHub(tmon,h,h1))
					
					  !Gathering Charges
					 - sum((qps,h) | map_SupplyArcs(qps, h), QP_GatheringCharge(tmon,qps) * FlowSupplyToHub(tmon, qps, h))
					
					 !Storage Fees
					 - sum((storage,h) | map_StorageArcs(storage,h), QP_StorageFee(tmon,storage,h) * FlowStorageToHub(tmon,storage,h))
					
					 !Area under the LNG Export Curve
					+ sum((lngexp_qp,step) | step <= LNGExpCrv_MaxStep, LNGExportPrc(tmon,lngexp_qp,step) * QLNGexp(tmon,lngexp_qp,step) +
					       0.5* sqr(QLNGexp(tmon,lngexp_qp,step)) * (LNGExportPrc(tmon,lngexp_qp,step+1)-LNGExportPrc(tmon,lngexp_qp,step)) / $ (LNGExportQty(tmon, lngexp_qp, step+1)-LNGExportQty(tmon,lngexp_qp,step))) )
				}
				Comment: "consumer plus producer surplus minus variable transport costs";
			}
			Variable OBJ_ALL_TX {
				Text: "Objective Function";
				Range: free;
				Definition: {
					sum(tmon,
					!Area under the Supply curve
					 - sum((suptype,qps,step) | map_Supply(qps,suptype) and step <= SupCrv_MaxStep, (Pbase(tmon,suptype,qps,step)*QSupplyStep(tmon,suptype,qps,step) +
					       0.5* sqr(QSupplyStep(tmon,suptype,qps,step)) * (Pbase(tmon,suptype,qps,step+1)-Pbase(tmon,suptype,qps,step))/ (Qbase(tmon,suptype,qps,step+1)-Qbase(tmon,suptype,qps,step))))
					- sum(qps, QP_SlackVar_Value * SLackVar(tmon,qps))
					
					! Pipeline Tariff curve
					-sum((qph,qph1,step)| map_HubArcs(qph,qph1)and step <= PTCrv_MaxStep, (Slope_TariffCurve(tmon, qph, qph1, step)* QTariffCurve(tmon,qph,qph1,step)+ PipelineTariff(tmon,qph,qph1,step))*QTariffCurve(tmon,qph,qph1,step)*0.5
					        +0.5*(Slope_TariffCurve(tmon, qph, qph1, step)* QTariffCurve(tmon,qph,qph1,step)*PipeTariffCurveQty(tmon,qph,qph1,step)))
					!For the last term the idea is that QTariffCurve(step) is >0 only if QTariffCurve(step-1)=Upper Bound, therefore can be replaced by the Upper Bound (PipeTariffCurveQty(step))
					!0.5 term is added to be consistent with the rest of OF so that shadow price = actual value
					
					
					 !Fixed  Fees
					 - sum((qph,qph1) | QP_Capacity(tmon,qph,qph1), Fixed_Arc_Fee(tmon,qph,qph1) * FlowHubToHub(tmon,qph,qph1))
					
					  !Gathering Charges
					 - sum((qps,qph) | map_SupplyArcs(qps, qph), QP_GatheringCharge(tmon,qps) * FlowSupplyToHub(tmon, qps, qph))
					
					 !Storage Fees
					 - sum((qpstorage,qph) | map_StorageArcs(qpstorage,qph), QP_StorageFee(tmon,qpstorage,qph) * FlowStorageToHub(tmon,qpstorage,qph))
					
					 !Area under the LNG Export Curve
					+ sum((lngexp_qp,step) | step <= LNGExpCrv_MaxStep, LNGExportPrc(tmon,lngexp_qp,step) * QLNGexp(tmon,lngexp_qp,step) +
					       0.5* sqr(QLNGexp(tmon,lngexp_qp,step)) * (LNGExportPrc(tmon,lngexp_qp,step+1)-LNGExportPrc(tmon,lngexp_qp,step)) / $ (LNGExportQty(tmon, lngexp_qp, step+1)-LNGExportQty(tmon,lngexp_qp,step))) )
				}
				Comment: {
					"consumer plus producer surplus minus variable transport costs
					YDA: Price times quantity for tariffs (a bit tricky with different segments)
					Test version of the OBJ to try and get TX working in the QP"
				}
			}
			Variable OBJprc {
				Text: "Objective Function";
				Range: free;
				Definition: {
					sum(tmon,
					!Area under the Supply curve
					 - sum((suptype,qps,step) | map_Supply(qps,suptype) and step <= SupCrv_MaxStep, (QSupplyStep(tmon,suptype,qps,step)+ Qbase(tmon,suptype,qps,step))*( Pbase(tmon,suptype,qps,step)+
					       QSupplyStep(tmon,suptype,qps,step) * (Pbase(tmon,suptype,qps,step+1)-Pbase(tmon,suptype,qps,step))/ (Qbase(tmon,suptype,qps,step+1)-Qbase(tmon,suptype,qps,step))))
					- sum(qps, 10^9* SLackVar(tmon,qps))
					!Area under the Pipeline Tariff curve
					-sum((h,h1,step)| QP_Capacity(tmon,h,h1) and step <= PTCrv_MaxStep,  (QTariffCurve(tmon,h,h1,step)+ PipeTariffCurveQty(tmon,h,h1,step) )*( PipelineTariff(tmon,h,h1,step)+
					      QTariffCurve(tmon,h,h1,step) *
					     (PipelineTariff(tmon,h,h1,step+1) - PipelineTariff(tmon,h,h1,step) )/ (PipeTariffCurveQty(tmon,h,h1,step+1) - PipeTariffCurveQty(tmon,h,h1,step) ) ))
					
					 !Fixed  Fees
					 - sum((h,h1) | QP_Capacity(tmon,h,h1), Fixed_Arc_Fee(tmon,h,h1) * FlowHubToHub(tmon,h,h1))
					
					  !Gathering Charges
					 - sum((qps,h) | map_SupplyArcs(qps, h), QP_GatheringCharge(tmon,qps) * FlowSupplyToHub(tmon, qps, h))
					
					 !Storage Fees
					 - sum((storage,h) | map_StorageArcs(storage,h), QP_StorageFee(tmon,storage,h) * FlowStorageToHub(tmon,storage,h))
					
					 !Area under the LNG Export Curve
					+ sum((lngexp_qp,step) | step <= LNGExpCrv_MaxStep,  (QLNGexp(tmon,lngexp_qp,step) + LNGExportQty(tmon,lngexp_qp,step))*(LNGExportPrc(tmon,lngexp_qp,step)+
					       QLNGexp(tmon,lngexp_qp,step) * (LNGExportPrc(tmon,lngexp_qp,step+1)-LNGExportPrc(tmon,lngexp_qp,step)) / $ (LNGExportQty(tmon, lngexp_qp, step+1)-LNGExportQty(tmon,lngexp_qp,step))) ))
				}
				Comment: "consumer plus producer surplus minus variable transport costs";
			}
			Variable OBJBAK {
				Text: "Objective Function";
				Range: free;
				Definition: {
					sum(tmon,
					!Area under the Supply curve
					 - sum((suptype,qps,step) | map_Supply(qps,suptype) and step <= SupCrv_MaxStep, (Pbase(tmon,suptype,qps,step)*QSupplyStep(tmon,suptype,qps,step) +
					       0.5* sqr(QSupplyStep(tmon,suptype,qps,step)) * (Pbase(tmon,suptype,qps,step+1)-Pbase(tmon,suptype,qps,step))/ (Qbase(tmon,suptype,qps,step+1)-Qbase(tmon,suptype,qps,step))))
					- sum(qps, 10^9* SLackVar(tmon,qps))
					!Area under the Pipeline Tariff curve
					-sum((h,h1,step)| QP_Capacity(tmon,h,h1) and step <= PTCrv_MaxStep, PipelineTariff(tmon,h,h1,step) * QTariffCurve(tmon,h,h1,step) +
					     0.5 * sqr( QTariffCurve(tmon,h,h1,step) ) *
					     (PipelineTariff(tmon,h,h1,step+1) - PipelineTariff(tmon,h,h1,step) )/ (PipeTariffCurveQty(tmon,h,h1,step+1) - PipeTariffCurveQty(tmon,h,h1,step) ) )
					
					 !Fixed  Fees
					 - sum((h,h1) | QP_Capacity(tmon,h,h1), Fixed_Arc_Fee(tmon,h,h1) * FlowHubToHub(tmon,h,h1))
					
					  !Gathering Charges
					 - sum((qps,h) | map_SupplyArcs(qps, h), QP_GatheringCharge(tmon,qps) * FlowSupplyToHub(tmon, qps, h))
					
					 !Storage Fees
					 - sum((storage,h) | map_StorageArcs(storage,h), QP_StorageFee(tmon,storage,h) * FlowStorageToHub(tmon,storage,h))
					
					 !Area under the LNG Export Curve
					+ sum((lngexp_qp,step) | step <= LNGExpCrv_MaxStep, LNGExportPrc(tmon,lngexp_qp,step) * QLNGexp(tmon,lngexp_qp,step) +
					       0.5* sqr(QLNGexp(tmon,lngexp_qp,step)) * (LNGExportPrc(tmon,lngexp_qp,step+1)-LNGExportPrc(tmon,lngexp_qp,step)) / $ (LNGExportQty(tmon, lngexp_qp, step+1)-LNGExportQty(tmon,lngexp_qp,step))) )
				}
				Comment: "consumer plus producer surplus minus variable transport costs";
			}
			Variable TestOBJ {
				Text: "consumer plus producer surplus minus variable transport costs";
				Range: free;
				Definition: {
					sum(tmon,
					!Area under the Supply curve
					  sum((step,suptype,s) | map_Supply(s,suptype) and step <= SupCrv_MaxStep, Pbase(tmon,suptype,s,step)*QSupplyStep(tmon,suptype,s,step) +
					       0.5* sqr(QSupplyStep(tmon,suptype,s,step)) * (Pbase(tmon,suptype,s,step+1)-Pbase(tmon,suptype,s,step))/ (Qbase(tmon,suptype,s,step+1)-Qbase(tmon,suptype,s,step)))
					+ sum(s, 20* SLackVar(tmon,s))
					!
					)
				}
			}
			Variable SLackVar {
				IndexDomain: {
					(tmon,qps) !| sum(suptype, QP_Supply(tmon,suptype,s))
				}
				Range: nonnegative;
				Comment: "Artificial Slack Varialble to add extra supply to avoid infeasibility";
			}
			Variable STEODemandAdj {
				IndexDomain: (tmon,steocnmx);
				Range: free;
			}
			Constraint SupplyMassBalance {
				IndexDomain: {
					(tmon,qps) !| qps in (QPSupplyNode_-STEOImpExpRegions_)
				}
				Property: ShadowPrice;
				Definition: {
					!sum((step,suptype) | map_Supply(s,suptype), (QSupplyStep(tmon,suptype,s,step)+ QbaseMin(tmon,suptype,s))+ SLackVar(tmon,s) = sum(h | map_SupplyArcs(s,h), FlowSupplyToHub(tmon,s,h) )
					sum(suptype | map_Supply(qps,suptype) , QProduction(tmon,suptype,qps)+ SLackVar(tmon,qps)) = sum(qph | map_SupplyArcs(qps,qph), FlowSupplyToHub(tmon,qps,qph) )
					!sum(suptype | map_Supply(qps,suptype), QProduction(tmon,suptype,qps))+ SLackVar(tmon,qps)+ QP_Discrepancy_Supply(tmon, qps) = sum(h | map_SupplyArcs(qps,h), FlowSupplyToHub(tmon,qps,h) )
					!sum(suptype | map_Supply(qps,suptype) and QP_Supply(tmon,suptype,qps), QProduction(tmon,suptype,qps)+ SLackVar(tmon,qps)) = sum(h | map_SupplyArcs(qps,h), FlowSupplyToHub(tmon,qps,h) )
				}
			}
			Constraint SupplyAccounting {
				IndexDomain: (tmon,suptype,qps);
				Property: ShadowPrice;
				Definition: QProduction(tmon,suptype,qps) = Sum(step | step <= SupCrv_MaxStep, QSupplyStep(tmon,suptype,qps,step))+ QbaseMin(tmon,suptype,qps);
				Comment: "Sums up production over all the steps of supply curve";
			}
			Constraint DemandMassBalance {
				IndexDomain: {
					(tmon,qpd)  !| d in (DemandNode_-STEOImpExpRegions_)
				}
				Definition: {
					sum(qph | map_DemandArcs(qph,qpd), FlowHubToDemand(tmon,qph,qpd)  ) = QP_Consumption(tmon,qpd) + QP_DistributionLoss(tmon,qpd) + QP_StorageLoss(tmon,qpd) + QP_IntrastatePipeFuelLoss(tmon,qpd)+
					                                                                                            QP_PlantFuel(tmon,qpd) - QP_Discrepancy(tmon,qpd) !QP_Discrepancy_Demand(tmon,d) !
				}
			}
			Constraint HubBalance {
				IndexDomain: (tmon,qph) |qph in (Hubs_-BorderCrossings_);
				Property: ShadowPrice;
				Definition: {
					sum(qpstorage | map_StorageArcs(qpstorage,qph), FlowStorageToHub(tmon,qpstorage,qph)) +
					sum(qps | map_SupplyArcs(qps,qph), FlowSupplyToHub(tmon,qps,qph)) +
					sum(qph1 | map_HubArcs(qph1, qph), FlowHubToHub(tmon,qph1,qph) *
					(1- (PipeFuelLossFactorOUT(qph1, qph) +PipeFuelLossFactorIN(qph1, qph)-PipeFuelLossFactorOUT(qph1, qph) *PipeFuelLossFactorIN(qph1, qph))*STEOPipeFuelFactor(YearInPeriod(tmon)))) =
					sum(qph2 | map_HubArcs(qph, qph2), FlowHubToHub(tmon,qph,qph2) ) + sum(qpd | map_DemandArcs(qph,qpd), FlowHubToDemand(tmon,qph,qpd) )
					+ sum(lngexp_qp | map_LNGExpArcs(qph,lngexp_qp), FlowHubToLNGExport(tmon,qph,lngexp_qp) ) +
					sum(qpstorage | map_StorageArcs(qpstorage,qph), FlowHubToStorage(tmon,qph, qpstorage))
				}
			}
			Constraint HubBalance_BXtoUS {
				IndexDomain: (tmon,BX);
				Property: ShadowPrice;
				Definition: {
					sum(r_int | map_HubArcs(r_int,BX) and map_hubs_borderXings(r_int,BX), FlowHubToHub(tmon,r_int,BX) *
					(1- (PipeFuelLossFactorOUT(r_int, BX) +PipeFuelLossFactorIN(r_int, BX)-PipeFuelLossFactorOUT(r_int, BX) *PipeFuelLossFactorIN(r_int, BX))*STEOPipeFuelFactor(YearInPeriod(tmon)))) =
					sum(l48 | map_HubArcs(BX,l48) and map_hubs_borderXings(l48,bx), FlowHubToHub(tmon,BX,l48) )
				}
			}
			Constraint HubBalance_UStoBX {
				IndexDomain: (tmon,BX);
				Property: ShadowPrice;
				Definition: {
					sum(l48 | map_HubArcs(l48,BX) and map_hubs_borderXings(l48,BX), FlowHubToHub(tmon,l48,BX) *
					(1- (PipeFuelLossFactorOUT(l48, BX) +PipeFuelLossFactorIN(l48, BX)-PipeFuelLossFactorOUT(l48, BX) *PipeFuelLossFactorIN(l48, BX))*STEOPipeFuelFactor(YearInPeriod(tmon)))) =
					sum(r_int | map_HubArcs(BX,r_int) and map_hubs_borderXings(r_int,bx), FlowHubToHub(tmon,BX,r_int) )
				}
			}
			Constraint TestHubBalance {
				IndexDomain: (tmon,h);
				Definition: {
					!sum(storage | map_StorageArcs(storage,h), FlowStorageToHub(tmon,storage,h)) +
					sum(s | map_SupplyArcs(s,h), FlowSupplyToHub(tmon,s,h)) +
					sum(h1 | QP_Capacity(tmon,h1,h), FlowHubToHub(tmon,h1,h) *(1-QP_PipefuelLossFactor(h))) =
					sum(h2 | QP_Capacity(tmon,h,h2), FlowHubToHub(tmon,h,h2) ) + sum(d | map_DemandArcs(h,d), FlowHubToDemand(tmon,h,d) )
					!+ sum(lngexp | map_LNGExpArcs(h,lngexp), FlowHubToLNGExport(h,lngexp,tmon) ) +
					!sum(storage | map_StorageArcs(storage,h), FlowHubToStorage(h, storage, tmon))
				}
			}
			Constraint StorageWthBalance {
				IndexDomain: (tmon,qpstorage);
				Definition: sum(qph | map_StorageArcs(qpstorage,qph), FlowStorageToHub(tmon,qpstorage,qph) )= QP_Storage_Withdrawals(tmon,qpstorage);
			}
			Constraint StorageInjBalance {
				IndexDomain: (tmon,qpstorage);
				Definition: sum(qph | map_StorageArcs(qpstorage,qph), FlowHubToStorage(tmon,qph,qpstorage))= QP_Storage_Injections(tmon,qpstorage);
			}
			Constraint LNGExportBalance {
				IndexDomain: (tmon,lngexp_qp)| QP_LNGExportCapacity(tmon,lngexp_qp);
				Definition: Sum(step |step <= LNGExpCrv_MaxStep , QLNGexp(tmon,lngexp_qp,step))= sum(qph | map_LNGExpArcs(qph,lngexp_qp), FlowHubToLNGExport(tmon,qph,lngexp_qp) );
			}
			Constraint TariffCurveQtyBalance {
				IndexDomain: (tmon,qph,qph1) | QP_Capacity(tmon,qph,qph1);
				Property: ShadowPrice;
				Definition: {
					
					FlowHubToHub(tmon,qph,qph1) = Sum(step | step <= PTCrv_MaxStep , QTariffCurve(tmon,qph,qph1,step))
				}
			}
			Constraint TariffCurveQtyTotal {
				IndexDomain: (tmon,h,h1,step) | QP_Capacity(tmon,h,h1) and step <= PTCrv_MaxStep;
				Property: ShadowPrice;
				Definition: PipeTariffCurveQty(tmon,h,h1,step)<=QTariffCurveTotal(tmon, h, h1, step)<=PipeTariffCurveQty(tmon,h,h1,step+1);
			}
			MathematicalProgram MaxConsumerProducerSurplus {
				Objective: OBJ_ALL_TX;
				Direction: maximize;
				Constraints: MyConstraints;
				Variables: MyVariables;
				Type: Automatic;
			}
			MathematicalProgram STEOQP {
				Objective: OBJ_ALL_TX;
				Direction: maximize;
				Constraints: STEOConstraints;
				Variables: STEOVariables;
				Type: Automatic;
			}
			MathematicalProgram TestQP {
				Objective: TestOBJ;
				Direction: minimize;
				Constraints: TestConstraints;
				Variables: TestVariables;
				Type: Automatic;
			}
		}
		Procedure CurveDefinitions {
			Body: {
				!Define supply curve steps
				!Qbase(tmon,suptype,qps,step) := QP_Supply(tmon,suptype,qps) *  SupCrvParameter(suptype,step);
				!Pbase(tmon,suptype,qps,step) := QP_SupplyPrice(tmon,suptype,qps) * SupCrvPriceElasticity(suptype,step);
				Qbase(tmon,suptype,qps,step) := QP_Supply(tmon,suptype,qps) *  SupCrv_Param(Element(SupCrv_Option_,map_SupCrvOption(qps, suptype)), step);
				Pbase(tmon,suptype,qps,step) := QP_SupplyPrice(tmon,suptype,qps) * SupElas_Param(Element(SupCrv_Option_,map_SupCrvOption(qps, suptype)), step);
				!Define minimum production
				!QbaseMin(tmon,suptype,qps) := Qbase(tmon,suptype,qps,SupCrv_Firststep);
				!QbaseMin(tmon,Supply_NA,qps) := Qbase(tmon,Supply_NA,qps,SupCrv_Firststep);
				QbaseMin((tmon,Supply_NA,qps) | map_Supply(qps, Supply_NA) ):= Qbase(tmon,Supply_NA,qps,SupCrv_Step1);
				QbaseMax(tmon,suptype,qps) := Qbase(tmon,suptype,qps,SupCrv_Maxstep+1);
				
				! Set upper bound for the supply curve steps
				Q_UpperBound( (tmon,suptype,qps,step) | step <= SupCrv_MaxStep) := ( Qbase(tmon,suptype,qps,step+1) - Qbase(tmon,suptype,qps,step) ) ;
				! Set lower bound for the supply curve steps for variable supply
				Q_LowerBound( (tmon, varsup, qps, step) | step <= SupCrv_MaxStep) := 0;
				! Set lower bound for the supply curve steps for fixed supply
				Q_LowerBound( (tmon, fixsup, qps, step) | step <= SupCrv_MaxStep and map_Supply(qps, fixsup)) := Q_UpperBound(tmon, fixsup, qps, step);
				
				!Define Pipeline Tariff Curve steps
				PipeTariffCurveQty(tmon,qph,qph1,step) := QP_Capacity(tmon,qph,qph1) * Parameter_CapacityUtilization(qph, qph1,step);
				!PipeTariffCurveQty((tmon,h,h1,step) | map_HubArcs(h, h1)) := QP_Capacity(tmon,h,h1) * Parameter_CapacityUtilization(h, h1,step);
				PipelineTariff(tmon,qph,qph1,step) :=  Parameter_TariffCurvePrice(qph, qph1,step);
				!PipelineTariff((tmon,h,h1,step) | map_HubArcs(h, h1)) :=  Parameter_TariffCurvePrice(h, h1,step);
				
				PipeTarCrvQty_UpBound( (tmon,qph,qph1,step) | step <= PTCrv_MaxStep) := PipeTariffCurveQty(tmon,qph,qph1,step+1) - PipeTariffCurveQty(tmon,qph,qph1,step);
				!PipeTarCrvQty_UpBound( (tmon,h,h1,step) | step <= PTCrv_MaxStep and map_HubArcs(h, h1)) := PipeTariffCurveQty(tmon,h,h1,step+1) - PipeTariffCurveQty(tmon,h,h1,step);
				!Upper and lower bound on total tariff curve quantity on each step
				TarCrvQtyTot_UB((tmon, qph, qph1, step) | step <= PTCrv_MaxStep) := PipeTariffCurveQty(tmon,qph,qph1,step+1);
				TarCrvQtyTot_LB((tmon, qph, qph1, step) | step <= PTCrv_MaxStep) := PipeTariffCurveQty(tmon,qph,qph1,step);
				
				!CapacityMaxBuild(tmon, h, h1) := PipeTariffCurveQty(FirstPeriodInPlanningInterval, h, h1, PTCrv_MaxStep+1);
				CapacityMaxBuild((tmon, qph, qph1) | map_HubArcs(qph, qph1)) := PipeTariffCurveQty(FirstPeriodInPlanningInterval, qph, qph1, PTCrv_MaxStep+1);
				
				!Compute the slopes of the tariff curve segments
				Slope_TariffCurve( (tmon,qph,qph1,step) | QP_Capacity(tmon, qph, qph1)and step <= PTCrv_MaxStep) := 
				    (PipelineTariff(tmon,qph,qph1,step+1) - PipelineTariff(tmon,qph,qph1,step) )/ (PipeTariffCurveQty(tmon,qph,qph1,step+1) - PipeTariffCurveQty(tmon,qph,qph1,step) );
				Slope_Check( (tmon, qph, qph1, step) | QP_Capacity(tmon, qph, qph1)and step <= PTCrv_MaxStep-1) := Slope_TariffCurve(tmon, qph, qph1, step+1) - Slope_TariffCurve(tmon, qph, qph1, step);
				ConvexityCheck_TariffCurve(tmon, qph, qph1) :=
				    if Slope_Check(tmon, qph, qph1, SupCrv_Step1)<0 or Slope_Check(tmon, qph, qph1, SupCrv_Step2)<0 or Slope_Check(tmon, qph, qph1, SupCrv_Step3)<0 then
				       1
				    endif;
				
				!define LNG Export Curve steps
				
				if (LNG_FixedExports_Switch = 0) then
					LNGExportQty(tmon,lngexp_qp,LNG_FirstStep) := 0;
				!	LNGExportQty(tmon,lngexp,LNG_SecondStep) :=QP_LNGExportCapacity(tmon,lngexp)*0.98;
					LNGExportQty(tmon,lngexp_qp,LNG_LastStep) :=QP_LNGExportCapacity(tmon,lngexp_qp);
					LNGExportPrc(tmon,lngexp_qp,LNG_FirstStep) :=  LNGMaxPrice(YearInPeriod(tmon),lngexp_qp);
				!	LNGExportPrc(tmon,lngexp,LNG_SecondStep) :=  LNGMinPrice(YearInPeriod(tmon),lngexp)*1.1;
					LNGExportPrc(tmon,lngexp_qp,LNG_LastStep) := LNGMinPrice(YearInPeriod(tmon),lngexp_qp);
					!CN_W is always fixed
					!LNGExportQty(tmon,CanadaWest,step) := QP_LNGExportCapacity(tmon,CanadaWest) * Parameter_LNGExpQty(step);
					!LNGExportPrc(tmon,CanadaWest,step):= QP_LNGExportPrice(tmon,CanadaWest)* Parameter_LNGExpPrc(step);
				else
					LNGExportQty(tmon,lngexp_qp,step) := QP_LNGExportCapacity(tmon,lngexp_qp) * Parameter_LNGExpQty(step);
					LNGExportPrc(tmon,lngexp_qp,step):= QP_LNGExportPrice(tmon,lngexp_qp)* Parameter_LNGExpPrc(step);
				endif;
				
				LNGExport_UpBound( (tmon,lngexp_qp,step) | step <= LNGExpCrv_MaxStep ) := LNGExportQty(tmon, lngexp_qp, step+1) - LNGExportQty(tmon,lngexp_qp,step);
				LNGExport_LoBound( (tmon,lngexp_qp,step) | step <= LNGExpCrv_MaxStep ) :=
				            if LNG_FixedExports_Switch then LNGExport_UpBound(tmon,lngexp_qp,step)
				            else 0
				            endif;
				!LNGExport_LoBound( (tmon,CanadaWest,step) | step <= LNGExpCrv_MaxStep ) := LNGExport_UpBound(tmon,CanadaWest,step);
			}
		}
		Procedure TransferDataIntoQPparameters {
			Body: {
				LinkHorizonToCalendar; !Create timetable
				!Define maximum step on the tariff curve
				PTCrv_MaxStep := Element(Supply_Curve_Step_,3);
				
				!Transfer data into QP Parameters
				
				!TotalConsumption( (mon,l48)  ) :=  sum(sec, Cons_State_Mon(mon, sec, l48)); !End Use Consumption Subroutine **moved to End Use Consumption Run... delete once verified it works
				QP_Consumption(tmon,qpd) := 	TotalConsumption(MonthInPeriod(tmon), qpd);
				!QP_Consumption(tmon,Mexico_NE) -= sum(mn|map_MonthinYear_ModelYearMonth(mn,MonthInPeriod(tmon)),Cons_share_MonYr_MX(Sector_Electric,Mexico_NE,mn)*STEOMXExpAnnualFactor(ModelYear));
				QP_Consumption(tmon,Mexico_NE) -= sum(mn|map_MonthinYear_ModelYearMonth(mn,MonthInPeriod(tmon)),Cons_share_MonYr_MX(Sector_Electric,Mexico_NE,mn)*STEOMXExportFactor(ModelYear));
				!QP_Consumption(tmon,l48) := 	sum(sec, Cons_State_Mon(MonthInPeriod(tmon), sec, l48));	!End Use Consumption Subroutine
				
				! Apply Canada Export phaseout factor
				if ModelYear > LastSTEOYear then
					QP_Consumption(tmon, cn) *= STEOCNExportFactor(ModelYear);
				endif;
				
				! Add LNG exports to Mexico region for consumption
				QP_Consumption(tmon,Mexico_NE) += IEO_LNGExport_Monthly(MonthInPeriod(tmon), Mexico_NE);
				QP_Consumption(tmon,Mexico_SS) += IEO_LNGExport_Monthly(MonthInPeriod(tmon), Mexico_SS);
				
				QP_Discrepancy(tmon,qpd) := BalanceItem(MonthInPeriod(tmon), qpd);
				!This code replaces the line above in the attempt to avoid infeasibilities caused by negative "demand" when discrepancy for a state is larger than consumption in that state
				!QP_Discrepancy_Demand((tmon,d) | BalanceItem(MonthInPeriod(tmon), d)<=0) := BalanceItem(MonthInPeriod(tmon), d);
				!QP_Discrepancy_Supply((tmon,s) | BalanceItem(MonthInPeriod(tmon), s)>=0) := BalanceItem(MonthInPeriod(tmon), s);
				!
				QP_Storage_Withdrawals(tmon,qpstorage) := StorageWithdrawals(MonthInPeriod(tmon), qpstorage);
				QP_Storage_Injections(tmon,qpstorage) := StorageInjections(MonthInPeriod(tmon), qpstorage);
				
				QP_Supply(tmon,suptype,qps) := Supply(MonthInPeriod(tmon), suptype, qps) ;
				QP_Supply(tmon,Supply_NA,CanadaWest) *= STEOPipelineImportFactor(ModelYear);
				!QP_Supply((tmon,suptype,qps) | QP_Supply(tmon,suptype,qps)<=1 ) := 0;
				!Subtract lease fuel
				QP_Supply(tmon,naadgas, qps) *= (1 - LeaseFuelFactor(qps)*STEOLeaseFuelFactor(ModelYear));
				
				! Split Texas RNG supply into supply districts and then zero out Texas RNG supply
				QP_Supply(tmon, Supply_RNG, tx) := Supply(MonthInPeriod(tmon),Supply_RNG,TexasState)/card(Texas_);
				QP_Supply(tmon, Supply_RNG, TexasState) := 0;
				
				!QP_Supply(tmon, sng, tx) := Supply(MonthInPeriod(tmon),sng,TexasState)/card(Texas_);
				
				QP_SupplyPrice((tmon,suptype,qps)|map_Supply(qps, suptype)) :=
				!   if (ModelYear=FirstModelYear and WellhdPrice(ModelYear, suptype, qps)) then  
				   if LastDataYearFlg_WHPrice(ModelYear) then
				   	WellhdPrice(ModelYear, suptype, qps)*STEOWellhdPriceFactor(ModelYear)	
				   else WellhdPrice(ModelYear-1, suptype, qps) *STEOWellhdPriceFactor(ModelYear)
				   endif;
				
				!QP_SupplyPrice((tmon,suptype,qps)|map_Supply(qps, suptype)) :=
				!   if ModelYear=FirstModelYear then  WellhdPrice(ModelYear, suptype, qps) *STEOWellhdPriceFactor(ModelYear)
				!   else WellhdPrice(ModelYear-1, suptype, qps) *STEOWellhdPriceFactor(ModelYear)
				!   endif;
				!QP_SupplyPrice(tmon,suptype,l48s) *= STEOWellhdPriceFactor(ModelYear);
				!QP_SupplyPrice(tmon,suptype,qps) := WellhdPrice(ModelYear-1, suptype, qps)* STEOWellhdPriceFactor(ModelYear);
				!if ModelYear=FirstModelYear then QP_SupplyPrice(tmon,suptype,qps) := WellhdPrice(ModelYear, suptype, qps)* STEOWellhdPriceFactor(ModelYear) endif;
				QP_GatheringCharge(tmon,qps) := GatheringCharge(qps)+GatherCharge_Add(qps);
				
				QP_Capacity((tmon,qph,qph1)|map_HubArcs(qph, qph1)) := CurrentPipeCapacity(MonthInPeriod(tmon), qph, qph1);
				Parameter_CapacityUtilization((qph, qph1, step)|map_HubArcs(qph, qph1)) := VariableTariffCurve(qph, qph1, Qtype, step);
				Parameter_TariffCurvePrice((qph, qph1, step)|map_HubArcs(qph, qph1)) := VariableTariffCurve(qph, qph1, Ptype, step);
				
				QP_LNGExportCapacity(tmon,lngexp_qp) := LNGExports(MonthInPeriod(tmon), lngexp_qp)*(1+ Pct_Liquifaction_Fuel);
				QP_LNGExportPrice(tmon,lngexp_qp) := USLNGExportPrice(YearInPeriod(tmon),lngexp_qp);
				
				! storage losses
				QP_StorageLoss(tmon,qpstorage) := StorageLosses(MonthInPeriod(tmon), qpstorage);
				! distribution losses
				!**********Add Canada and Mexico later **************
				QP_DistributionLoss(tmon,l48) := DistributionLosses(MonthInPeriod(tmon), l48) ;
				!intrastate pipefuel loss
				QP_IntrastatePipeFuelLoss(tmon,l48) := IntrastatePipeFuelLosses(MonthInPeriod(tmon), l48) ;
				
				!plant fuel
				QP_PlantFuel(tmon,l48) := PlantFuel(MonthInPeriod(tmon), l48) ;
				
				!Assign supply curve parameters for fixed and variable supply
				Parameter_SupCrv(fixsup,step, n)  := Parameter_SupCrv(Supply_AD,step, n);
				Parameter_SupElasticity(fixsup,step, n)  := Parameter_SupElasticity(Supply_AD,step, n);
				Parameter_PrcElasticity(fixsup,step, n)  := Parameter_PrcElasticity(Supply_AD,step, n);
				Parameter_SupCrv(varsup,step, n)  := Parameter_SupCrv(Supply_NA,step, n);
				Parameter_SupElasticity(varsup,step, n)  := Parameter_SupElasticity(Supply_NA,step, n);
				Parameter_PrcElasticity(varsup,step, n)  := Parameter_PrcElasticity(Supply_NA,step, n);
				
				!Handle possible negative demand error (usually occurs when discrepancy > consumption)
				!Set a flag indicating that the demand mass balance constraint RHS <0
				QPFLG_NegativeDemand((tmon, qpd) | (QP_Consumption(tmon,qpd) + QP_DistributionLoss(tmon,qpd) + QP_StorageLoss(tmon,qpd) + QP_IntrastatePipeFuelLoss(tmon,qpd)+
							QP_PlantFuel(tmon,qpd) - QP_Discrepancy(tmon,qpd)) < 0) :=1;
				!Replace negative demand with 0
				QP_Consumption((tmon,qpd) | QPFLG_NegativeDemand(tmon, qpd) ) := 0;
				QP_DistributionLoss((tmon,qpd) | QPFLG_NegativeDemand(tmon, qpd) ) := 0;
				QP_StorageLoss((tmon,qpd) | QPFLG_NegativeDemand(tmon, qpd) ) := 0;
				QP_IntrastatePipeFuelLoss((tmon,qpd) | QPFLG_NegativeDemand(tmon, qpd) ) := 0;
				QP_PlantFuel((tmon,qpd) | QPFLG_NegativeDemand(tmon,qpd) ) := 0;
				QP_Discrepancy((tmon,qpd) | QPFLG_NegativeDemand(tmon, qpd) ) := 0;
				if sum((tmon,qpd), QPFLG_NegativeDemand(tmon, qpd)) then
				   write QPFLG_NegativeDemand((tmon, qpd) | QPFLG_NegativeDemand(tmon, qpd)) to file "NGATTENTION.txt" in merge mode;
				   RAISE WARNING "RHS of DemandMassBalance constraint is negative in " +ModelYear+"; Resetting RHS to 0. See NGATTENTION.txt for details." CODE 'NegativeRHS';
				endif;
			}
			Comment: "Transfer data for Planning Period into QP parameters";
		}
	}
	Section Historical_Data_Processing {
		Procedure Historical_reads {
			Body: {
				Currentdate:=CurrentToString("%Am|AllMonths| %sd, %c%y");
				write Currentdate to file "NGATTENTION.txt";
				write Currentdate to file "NGPRICES.txt";
				
				!Read in capacity files created in NGMM offline/not as part of model
				!MUST be read before ngcanada.txt so that capacities can be overwritten
				read from file NGCAPACITYN in merge mode;
				
				!Read in bulk files automated and updated via python
				read from file NGEIAN in merge mode;
					!read from file "data\\BalanceItem.txt" ;
					!read from file "data\\Flows.txt" in merge mode;		!comment out again once updated ng_eia with correct flows is done
					!read from file "data\\Imports_Exports.txt" ;
					!read from file "data\\PipeLeaseAndPlant.txt" ;
					!read from file "data\\Prices.txt" in merge mode;
					!read from file "data\\USConsumption.txt" in merge mode;
					!read from file "data\\USStorage.txt";
					!read from file "data\\USSupplemental&LNG_Supply.txt" in merge mode;
				
				!Read in Canada data; data from python as well as AIMMS offline processing, history
				read from file NGCANADAN in merge mode;
					!read from file "data\\CAConsumption.txt" in merge mode;
					!read from file "data\\CAStorage.txt" in merge mode;
					!read from file "data\\ngcanada.txt" in merge mode;
					!read from file "data\\CapacitiesNEB.txt" in merge mode;
				
				
				
				
				!Read in miscellaneous data files
				read from file NGSPOTPRCN in merge mode;
				read from file NGMEXICON in merge mode;
				read from file NGLNGEXPN ;
				read from file "ngsteo.txt" ;
				read from file NGMARKUPSN in merge mode;
				
				read from file NGVARTARN ;
				
				if not CalibrationMode then !(switch set by the model)
				   if Calibration_Option=1 then  !(switch set in ngassumptions.txt)
				      read from file "data\\NGVarTarCurve.txt" in merge mode;
				      read from file "data\\NGPipelineFuelFactors.txt";
				   elseif Calibration_Option=2 then
				      read from file "data\\NGPipelineFuelFactors.txt";
				   endif;
				endif;
				
				
				!
			}
			Comment: {
				"Read historical data from text data files; Convert to the model units; Fill in missing data for the last year"
			}
		}
		Procedure Historical_InitializeData {
			Body: {
				HistoricalDemand(datamon,sec,state | state in TXRegion_) := HistoricalDemand(datamon,sec,TexasState) * TexasConsShares(state | state in TXRegion_ ,sec);
				
				!For Annual Demand, do not overwrite transportation sector with monthly data (does not exist)
				HistoricalAnnualDemand((datayear, sec, reg)|not HistoricalAnnualDemand(datayear, sec, reg)):= sum(datamon |  map_month_year(datamon,datayear), HistoricalDemand(datamon, sec, reg));
				HistoricalElectricDemand(datayear, NNGEMM, season) := sum((datamon,state) | (map_month_year(datamon,datayear) and map_mon_season(datamon,season)) and  map_State_NNGEMM(state,NNGEMM),
				                                                   HistoricalDemand(datamon,Sector_Electric,state));
				
				
				!Convert prices to 87$/mcf
				HistoricalAnnualWellhdPrice(datayear, s) /= GDPPriceDeflator87(datayear);
				HistoricalAnnualSpotPrice(datayear, s) *=  Convert_TBtu_Bcf(datayear)/ GDPPriceDeflator87(datayear);
				HistoricalSpotPrice(datamon, s) *= Convert_TBtu_Bcf(MonthToYear(datamon)) / GDPPriceDeflator87(MonthToYear(datamon));
				HistoricalSubstateSpotPricecDifferential(datayear, s) *=  Convert_TBtu_Bcf(datayear)/ GDPPriceDeflator87(datayear);
				
				HistoricalExportsPrice(datamon, bx) /= GDPPriceDeflator87(MonthToYear(datamon));
				HistoricalImportsPrice(datamon, bx )/= GDPPriceDeflator87(MonthToYear(datamon));
				
				!Assign pre-2011 import prices/volumes
				HistoricalImportsPrice(datamon | datamon <= 'December, 2010', 'TX_E-MX_NE') := HistoricalImportsPrice(datamon | datamon <= 'December, 2010', 'TX-MX_NE');
				HistoricalImports(datamon | datamon <= 'December, 2010', 'TX_E-MX_NE') := HistoricalImports(datamon | datamon <= 'December, 2010', 'TX-MX_NE');
				
				HistoricalLNGExportsPrice(datamon, reg )/= GDPPriceDeflator87(MonthToYear(datamon));
				HistoricalCNGImportsPrice(datamon, reg) /= GDPPriceDeflator87(MonthToYear(datamon));
				
				HistoricalCitygatePrice(datamon, state) /=  GDPPriceDeflator87(MonthToYear(datamon));
				HistoricalEndUsePrice(datamon, sec, state) /= GDPPriceDeflator87(MonthToYear(datamon));
				
				!Assign historical Texas enduse prices to the TX regional prices.
				HistoricalEndUsePrice(datamon, sec, r_tx) := HistoricalEndUsePrice(datamon, sec, TexasState);
				HistoricalAnnualEndUsePrice(datayear, sec, r_tx) := HistoricalAnnualEndUsePrice(datayear, sec, TexasState);
				
				HistoricalAnnualEndUsePrice(datayear, sec, state)/= GDPPriceDeflator87(datayear);
				HistoricalAnnualEndUsePrice((datayear, sec, state) | sec in (Sector_-Sector_Transportation)) := sum(datamon |  map_month_year(datamon,datayear), HistoricalEndUsePrice(datamon, sec, state)*
				             HistoricalDemand(datamon, sec, state))/$ HistoricalAnnualDemand(datayear, sec, state);
				HistoricalAnnualEndUseCDPrice(datayear, sec, r_cen):= sum(state, HistoricalAnnualEndUsePrice(datayear, sec, state)* HistoricalAnnualDemand(datayear, sec, state)*map_State_CensusRegion(state, r_cen))/$
				           sum(state, HistoricalAnnualDemand(datayear, sec, state)*map_State_CensusRegion(state, r_cen));
				HistoricalAnnualCitygatePrice(datayear,state) := sum(datamon|map_month_year(datamon,datayear), (HistoricalCitygatePrice(datamon,state)*
				     (HistoricalDemand(datamon, Sector_Residential, state) + HistoricalDemand(datamon, Sector_Commercial, state)))/$
				     (HistoricalAnnualDemand(datayear, Sector_Residential, state) + HistoricalAnnualDemand(datayear, Sector_Commercial, state)));
				HistoricalResComDemand(datamon, state)  := HistoricalDemand(datamon, Sector_Residential, state) + HistoricalDemand(datamon, Sector_Commercial, state);
				
				
				
				Initialize_Electric_Power_Prices;
				!HistoricalAnnualEndUseNNGEMMPrice(datayear, NNGEMM, season):=sum((datamon,state) |map_month_year(datamon,datayear) and map_mon_season(datamon,season) and map_State_NNGEMM(state,NNGEMM),
				!              HistoricalEndUsePrice(datamon, Sector_Electric, state)* HistoricalDemand(datamon, Sector_Electric, state))/$
				 !          sum((datamon,state) |map_month_year(datamon,datayear) and map_mon_season(datamon,season) and map_State_NNGEMM(state,NNGEMM), HistoricalDemand(datamon, Sector_Electric, state));
				!HistoricalAnnualEndUseNNGEMMPrice( (datayear, NNGEMM, season) | HistoricalAnnualEndUseNNGEMMPrice(datayear, NNGEMM, season)=0) := HistoricalAnnualEndUseNNGEMMPrice(datayear-1, NNGEMM, season);
				!HistoricalAnnualEndUseNNGEMMPrice(datayear, NNGEMM, season) /= GDPPriceDeflator87(datayear);
				
				!Set wellhead price in substates
				HistoricalAnnualWellhdPrice(datayear, substate) := sum(l48 | map_SupplyArcs(substate, l48), HistoricalAnnualWellhdPrice(datayear, l48) );
				
				
				!Calculate annual spot price by calculating straight average of monthly spot price
				HistoricalAnnualSpotPrice(datayear, reg) := $ sum(datamon | map_month_year(datamon,datayear), HistoricalSpotPrice(datamon, reg))/12;
				
				
				! AEO2025 ADJUSTMENT THAT OMITS SOME OUTLIER PRICES IN SPOT PRICE HISTORY THAT THROW OFF NEAR-TERM RESULTS.
				! Manually setting to calculated prices outside of AIMMS
				HistoricalAnnualSpotPrice('2023', 'CO') := 1.11988;
				HistoricalAnnualSpotPrice('2023', 'UT') := 1.50946;
				HistoricalAnnualSpotPrice('2023', 'WY') := 1.15922;
				
				!HistoricalAnnualSpotPrice('2023', 'CO') := $ sum(datamon | datamon <> 'January 2023' or datamon <> 'February 2023', HistoricalSpotPrice(datamon, 'CO'))/10;
				!HistoricalAnnualSpotPrice('2023', 'UT') := $ sum(datamon | datamon <> 'January 2023' or datamon <> 'February 2023', HistoricalSpotPrice(datamon, 'UT'))/10;
				!HistoricalAnnualSpotPrice('2023', 'WY') := $ sum(datamon | datamon <> 'January 2023' or datamon <> 'February 2023', HistoricalSpotPrice(datamon, 'WY'))/10;
				
				
				!Set annual spot price for Canada and Mexico by calculating straight average of monthly spot price
				!HistoricalAnnualSpotPrice(datayear, cn) := sum(datamon | map_month_year(datamon,datayear), HistoricalSpotPrice(datamon, cn))/12;
				!Spot price in Mexico is set equal to spot price at border-crossing for now
				!HistoricalAnnualSpotPrice(datayear, mx) := sum(datamon | map_month_year(datamon,datayear), HistoricalSpotPrice(datamon, mx))/12;
				!Set annual spot price for substates and offshore regions
				HistoricalAnnualSpotPrice((datayear, offshore)|HistoricalAnnualSpotPrice(datayear, offshore)=0) := sum(l48 | map_SupplyArcs(offshore, l48), HistoricalAnnualSpotPrice(datayear, l48));
				HistoricalAnnualSpotPrice((datayear, substate)|HistoricalAnnualSpotPrice(datayear, substate)=0) := sum(l48 | map_SupplyArcs(substate, l48), HistoricalAnnualSpotPrice(datayear, l48));
				!Adjust the annual spot prices using the substate differentials
				HistoricalAnnualSpotPrice((datayear, l48s)|HistoricalSubstateSpotPricecDifferential(datayear, l48s)) += HistoricalSubstateSpotPricecDifferential(datayear, l48s);
				
				
				!Set missing wellhead prices (2009-2014) by subtracting gathering charges from spot prices
				HistoricalAnnualWellhdPrice((datayear, s) | HistoricalAnnualSpotPrice(datayear, s)) := HistoricalAnnualSpotPrice(datayear, s) - GatheringCharge(s);
				!Adjust offshore prices
				HistoricalAnnualWellhdPrice(datayear, offshore) := sum(l48 | map_SupplyArcs(offshore, l48),HistoricalAnnualWellhdPrice(datayear, l48))- HistOffshorePriceAdjustment(datayear, offshore);
				!Set GOM offshore w/h price by ogdist regions
				HistoricalAnnualWellhdPrice(datayear, gom_ogdist) := HistoricalAnnualWellhdPrice(datayear, GOMpriceRegion(gom_ogdist));
				!Set AK wellhead price = AK citygate
				HistoricalAnnualWellhdPrice(datayear, ak_s) := HistoricalAnnualCitygatePrice(datayear,AKState);
				!Assign NGA price by CD
				!Alaska is not included since it's only 0.4% of industrial consumption
				HistoricalIndustrialPrice_NGA(datayear, r_cen):= sum(l48, HistoricalAnnualEndUsePrice(datayear, Sector_Industrial, l48)* HistoricalAnnualDemand(datayear, Sector_Industrial, l48)*
				          map_State_CensusRegion(l48, r_cen))/$ sum(l48, HistoricalAnnualDemand(datayear, Sector_Industrial, l48)*map_State_CensusRegion(l48, r_cen));
				
				!Aggregate wellhead price to CDs using industrial consumption
				HistoricalWellheadPrice_Industrial(datayear, r_cen) := sum(l48, HistoricalAnnualWellhdPrice(datayear, l48)*HistoricalAnnualDemand(datayear, Sector_Industrial, l48)*map_State_CensusRegion(l48, r_cen))/$
				           sum(l48, HistoricalAnnualDemand(datayear, Sector_Industrial, l48)*map_State_CensusRegion(l48, r_cen));
				!Estimate historical industrial prices for each year and Census Division that are consistent with prices published
				!  in the Manufacturing Energy Consumption Survey (MECS)
				HistoricalIndustrialPrice_MESC(datayear, r_cen) := PAR1_MESC_IND + PAR2_MESC_IND * HistoricalWellheadPrice_Industrial(datayear, r_cen) +
				      PAR3_MESC_IND * HistoricalIndustrialPrice_NGA(datayear, r_cen);
				!Assign MESC price to historical enduse price array for IND sec
				HistoricalAnnualEndUseCDPrice(datayear, Sector_Industrial, r_cen) := HistoricalIndustrialPrice_MESC(datayear, r_cen);
				
				!Determine last month for which EIA historical data exists and determine LastHistoricalDataYear by testing if LastHistoricalDataMonth is December (Spot Price)
				LastHistoricalDataMonth := Last(datamon | Exists((l48)|HistoricalSpotPrice(datamon, l48)));
				if (MonthToYear(LastHistoricalDataMonth)=MonthToYear(LastHistoricalDataMonth-11)) then
					LastHistoricalDataYear := MonthToYear(LastHistoricalDataMonth);
				else
					LastHistoricalDataYear := MonthToYear(LastHistoricalDataMonth)-1;
				endif;
				!if LastHistoricalDataYear>=FirstModelYear then LastDataYearFlg_SpotPrc(hdatayear):=1; endif;
				LastDataYearFlg_SpotPrc(hdatayear):=1;
				!Convert variable tariffs to 87$/mcf
				!Currently conversion is done in the input file
				!VariableTariffCurve(h, h1, Ptype, step) *=  Convert_TBtu_Bcf(TariffYearDollar)/ GDPPriceDeflator87(TariffYearDollar);
				
				
				!Correct historical data by separating out liquefaction fuel used for LNG exports from pipeline fuel
				!If EIA/OES data improves in future, ammend this; currently, it's all together
				Historical_LiquefactionFuel;
				
				!Calculate historical Tran fuel
				HistoricalAnnualStorageLoss(histyr, l48) := sum(histmon |map_month_year(histmon,histyr), HistoricalStorageInjections(histmon, l48)+HistoricalStorageWithdrawals(histmon, l48))* StorageLossFactor(l48);
				HistoricalAnnualDistributionLoss(histyr, l48) := (HistoricalAnnualDemand(histyr, Sector_Residential, l48) + HistoricalAnnualDemand(histyr, Sector_Commercial, l48)) * DistributionLossFactor(l48);
				!HistoricalAnnualIntrastateFuel(histyr, l48):=sum((naadgas, qps) | map_SupplyArcs(qps, l48), HistoricalSupply(histmon, naadgas, qps)*IntrastatePipeFuelFactor(qps, naadgas));
				
				
				!Assign regional TX Pipeline fuel in TX based on historical consumption
				HistoricalAnnualPipeFuel(histyr, r_tx) := (sum(rescom, HistoricalAnnualDemand(histyr, rescom, r_tx)) /$ sum(rescom, HistoricalAnnualDemand(histyr, rescom, TexasState))) * 
					HistoricalAnnualPipeFuel(histyr, TexasState);
				
				HistoricalAnnualTranFuel(histyr, l48):= HistoricalAnnualPipeFuel(histyr, l48) - HistoricalAnnualStorageLoss(histyr, l48) - HistoricalAnnualDistributionLoss(histyr, l48);
				
				 !Assign border-crossing flow on the CN and MX arcs
				 !Imports
				 HistoricalFlowAnnual((r_int, bx, datayear)|map_hubs_borderXings(r_int,bx)) := sum(l48 | map_hubs_borderXings(l48,bx),HistoricalFlowAnnual(bx, l48, datayear));
				 !Exports
				 HistoricalFlowAnnual((bx, r_int, datayear)|map_hubs_borderXings(r_int,bx)) := sum(l48 | map_hubs_borderXings(l48,bx),HistoricalFlowAnnual(l48, bx, datayear)*
				                                    (1-PipeFuelLossFactorIN(l48, bx))*(1-PipeFuelLossFactorOUT(l48, bx)));
				!Mexico capacity: assign all historical year = availble year data
				LastHistoricalDataYear := Last(datayear | Exists((h,h1)|HistoricalCapacity(h, h1, datayear)));
				if LastHistoricalDataYear>=FirstModelYear then LastDataYearFlg_Capacity(hdatayear):=1; endif;
				HistoricalCapacity((mx, mx1, hdatayear)|hdatayear<=MexCapYear ):=HistoricalCapacity(mx, mx1, MexCapYear);
			}
		}
		Procedure Historical_LiquefactionFuel {
			Body: {
				!Estimate historical liquefaction fuel using assumed percentage of LNG export volume
				HistoricalAnnualLiquefactionFuel(datayear,reg) := 
					sum(datamon|map_month_year(datamon,datayear), HistoricalLNGExports(datamon,reg)) * Pct_Liquifaction_Fuel;
				
				!Subtract liquefaction fuel from historical pipeline fuel use volumes
				HistoricalAnnualPipeFuel(datayear,reg)-= HistoricalAnnualLiquefactionFuel(datayear,reg);
			}
		}
		DeclarationSection Historical_Declaration {
			StringParameter Currentdate;
			Parameter HistoricalCapacity {
				IndexDomain: (h, h1, datayear);
			}
			Parameter HistoricalFlowAnnual {
				IndexDomain: (reg,reg1,datayear);
			}
			Parameter HistoricalFlowNetAnnual {
				IndexDomain: (reg,reg1,year);
				Definition: HistoricalFlowAnnual(reg,reg1,year)-HistoricalFlowAnnual(reg1,reg,year);
			}
			Parameter HistoricalFlowModel {
				IndexDomain: (reg,reg1,datayear);
			}
			Parameter HistoricalFlow {
				IndexDomain: (datamon,h,h1);
			}
			Parameter HistoricalCNFlowThru {
				IndexDomain: (datayear,BX);
			}
			Parameter tempelprc {
				IndexDomain: (datayear,NNGEMM,season);
			}
			Parameter LastDataYearFlg_Capacity {
				IndexDomain: year;
				Text: "flag to indicate that data exists for model years";
				Range: binary;
			}
		}
		DeclarationSection Historical_Demand_Declaration {
			Parameter HistoricalDemand {
				IndexDomain: (datamon,sec,reg);
			}
			Parameter HistoricalResComDemand {
				IndexDomain: (datamon,reg);
			}
			Parameter HistoricalAnnualDemand {
				IndexDomain: (datayear,sec,reg);
			}
			Parameter HistoricalElectricDemand {
				IndexDomain: (datayear,NNGEMM,season);
			}
		}
		DeclarationSection Historical_Supply_Declaration {
			Parameter HistoricalSupply {
				IndexDomain: (datamon,suptype,reg);
			}
			Parameter HistoricalAnnualSupply {
				IndexDomain: (datayear,suptype,reg);
			}
		}
		DeclarationSection Historical_Balancing_Item_Declaration {
			Parameter HistoricalBalanceItem {
				IndexDomain: (datayear,reg);
			}
			Parameter HistoricalBalanceItem_Calc {
				IndexDomain: (datayear,reg);
			}
			Parameter HistoricalBalanceItem_Diff {
				IndexDomain: (datayear,l48);
			}
			Parameter HistoricalNationalBalanceItemMonthly {
				IndexDomain: datamon;
			}
			Parameter BalanceItem_SumOverStates {
				IndexDomain: datayear;
				Comment: "Move later to Local declaration";
			}
			Parameter BalanceItem_SumOverMonths {
				IndexDomain: datayear;
				Comment: "Move later to Local declaration";
			}
		}
		DeclarationSection Historical_Lease_and_Plant_Declaration {
			Parameter HistoricalLeaseFuelFactor {
				IndexDomain: (datayear,reg);
			}
			Parameter HistoricalPlantFuelFactor {
				IndexDomain: (datayear,reg);
			}
			Parameter HistoricalAnnualPlantFuel {
				IndexDomain: (datayear,reg);
			}
			Parameter HistoricalAnnualLeaseFuel {
				IndexDomain: (datayear,reg);
			}
		}
		DeclarationSection Historical_Pipe_Fuel_Declaration {
			Parameter HistoricalPipeFuelLossFactor {
				IndexDomain: (reg,reg1);
			}
			Parameter HistoricalAnnualPipeFuel {
				IndexDomain: (datayear,reg);
			}
			Parameter HistoricalAnnualLiquefactionFuel {
				IndexDomain: (datayear,reg);
			}
			Parameter HistoricalAnnualDistributionLoss {
				IndexDomain: (datayear,reg);
			}
			Parameter HistoricalAnnualStorageLoss {
				IndexDomain: (datayear,reg);
			}
			Parameter HistoricalAnnualIntrastateFuel {
				IndexDomain: (datayear,reg);
			}
			Parameter HistoricalAnnualTranFuel {
				IndexDomain: (datayear,reg);
			}
			Parameter Ploss {
				IndexDomain: (histyr,h);
			}
			Parameter HisPipeFuelLossFactorIN {
				IndexDomain: (datayear,reg,reg1);
			}
			Parameter HisPipeFuelLossFactorOUT {
				IndexDomain: (datayear,reg,reg1);
			}
		}
		DeclarationSection Historical_Price_Declaration {
			Parameter HistoricalAnnualWellhdPrice {
				IndexDomain: (datayear,reg);
			}
			Parameter HistoricalAnnualSpotPrice {
				IndexDomain: (datayear,reg);
			}
			Parameter HistoricalSubstateSpotPricecDifferential {
				IndexDomain: (datayear,reg);
			}
			Parameter HistoricalSpotPrice {
				IndexDomain: (datamon,reg);
			}
			Parameter HistOffshorePriceAdjustment {
				IndexDomain: (datayear,offshore);
			}
			Parameter HistoricalCitygatePrice {
				IndexDomain: (datamon,reg);
			}
			Parameter HistoricalEndUsePrice {
				IndexDomain: (datamon,sec,reg);
			}
			Parameter HistoricalAnnualCitygatePrice {
				IndexDomain: (datayear,reg);
			}
			Parameter HistoricalIndustrialPrice_MESC {
				IndexDomain: (datayear,r_cen);
				Comment: "historical MECS equivalent industrial price by Census Division (87$/Mcf)";
			}
			Parameter HistoricalIndustrialPrice_NGA {
				IndexDomain: (datayear,r_cen);
				Comment: "historical industrial price from NGA from Python program aggregated in the code by Census Division (87$/Mcf)";
			}
			Parameter HistoricalWellheadPrice_Industrial {
				IndexDomain: (datayear,r_cen);
				Comment: "historical annual wellhead price aggregated  by Census Division using industrial consumption as weights (87$/Mcf)";
			}
			Parameter HistoricalAnnualSpotPrice2 {
				IndexDomain: (datayear,reg);
			}
			Parameter HistoricalAnnualEndUsePrice {
				IndexDomain: (datayear,sec,reg);
			}
			Parameter HistoricalAnnualEndUseCDPrice {
				IndexDomain: (datayear,sec,r_cen);
			}
			Parameter HistoricalAnnualCitygateCDPrice {
				IndexDomain: (datayear,r_cen);
			}
			Parameter HistoricalAnnualEndUseNNGEMMPrice {
				IndexDomain: (datayear,NNGEMM,season);
			}
			Parameter HistoricalGatheringCharge {
				IndexDomain: (reg);
				InitialData: .15;
			}
		}
		DeclarationSection Historical_Import_Export_Declaration {
			Parameter HistoricalExports {
				IndexDomain: (datamon,bx);
			}
			Parameter HistoricalImports {
				IndexDomain: (datamon,bx);
			}
			Parameter HistoricalExportsPrice {
				IndexDomain: (datamon,bx);
			}
			Parameter HistoricalImportsPrice {
				IndexDomain: (datamon,bx);
			}
			Parameter HistoricalLNGExports {
				IndexDomain: (datamon,reg);
			}
			Parameter HistoricalLNGExportsPrice {
				IndexDomain: (datamon,reg);
			}
			Parameter HistoricalLNGImportsPrice {
				IndexDomain: (datamon,reg);
			}
			Parameter HistoricalTRUCKExports {
				IndexDomain: (datamon,reg);
			}
			Parameter HistoricalLNGBYTRUCKExportsPrice {
				IndexDomain: (datamon,reg);
			}
			Parameter HistoricalCNGExportsPrice {
				IndexDomain: (datamon,reg);
			}
			Parameter HistoricalTRUCKImports {
				IndexDomain: (datamon,reg);
			}
			Parameter HistoricalLNGBYTRUCKImportsPrice {
				IndexDomain: (datamon,reg);
			}
			Parameter HistoricalCNGImportsPrice {
				IndexDomain: (datamon,reg);
			}
		}
		DeclarationSection Historical_Storage_Declaration {
			Parameter HistoricalStorageInjections {
				IndexDomain: (datamon,storage);
			}
			Parameter HistoricalStorageWithdrawals {
				IndexDomain: (datamon,storage);
			}
		}
		DeclarationSection Historical_Tariff_Curve_Declaration {
			Parameter HistoricalCapacityUtil {
				IndexDomain: (datayear,reg,reg1);
			}
			Parameter HistoricalTariff {
				IndexDomain: (histyr,h,h1);
			}
			Parameter HistoricalFlowIn {
				IndexDomain: (datayear,reg);
			}
			Parameter HistoricalFlowOut {
				IndexDomain: (datayear,reg);
			}
			Parameter HTariffCurveUtil {
				IndexDomain: (datayear,reg,reg1,step);
			}
			Parameter HTariffCurvePrc {
				IndexDomain: (datayear,reg,reg1,step);
			}
			Parameter HistoricalTariffAdj {
				IndexDomain: (datayear,reg,reg1);
			}
		}
	}
	Section History_Calibration {
		DeclarationSection Historical_Supply_Curve_Declarations {
			Parameter HQbase {
				IndexDomain: (htmon,suptype,s,step);
			}
			Parameter HQbaseMin {
				IndexDomain: (htmon,suptype,s);
				Comment: "Minimum production";
			}
			Parameter HQbaseMax {
				IndexDomain: (htmon,suptype,s);
				Comment: "Minimum production";
			}
			ElementParameter HSupCrv_MaxStep {
				Range: Supply_Curve_Step_;
				Definition: Element(Supply_Curve_Step_,5);
				Comment: "Maximum step on the supply curve";
			}
			ElementParameter HSupCrv_FirstStep {
				Range: Supply_Curve_Step_;
				Definition: Element(Supply_Curve_Step_,1);
				Comment: "First step on the supply curve";
			}
			Parameter HQ_UpperBound {
				IndexDomain: (htmon,suptype,s,step);
				Range: nonnegative;
			}
			Parameter HQ_LowerBound {
				IndexDomain: (htmon,suptype,s,step);
				Range: nonnegative;
			}
			Parameter HPbase {
				IndexDomain: (htmon,suptype,s,step);
			}
			Parameter HSupCrvElasticity {
				IndexDomain: (suptype,step);
			}
			Parameter HSupCrvParameter {
				IndexDomain: (suptype,step);
				Definition: prod( n, (1+HParameter_SupCrv(suptype, step, n)));
			}
			Parameter HSupCrvPriceElasticity {
				IndexDomain: (suptype,step);
				Definition: prod( n, (1 + HParameter_PrcElasticity(suptype, step, n) /$ HParameter_SupElasticity(suptype,step,n)));
			}
		}
		DeclarationSection Historical_Tariff_Curve_Declarations {
			ElementParameter HPTCrv_MaxStep {
				Range: Supply_Curve_Step_;
				Definition: Element(Supply_Curve_Step_,3);
				Comment: "Maximum step on the pipeline tariff curve";
			}
			Parameter HPipelineTariff {
				IndexDomain: (htmon,h,h1,step);
			}
			Parameter HPipelineTariffReport {
				IndexDomain: (htmon,h,h1,step);
			}
			Parameter HPipeTariffCurveQty {
				IndexDomain: (htmon,h,h1,step);
			}
			Parameter HPipeTarCrvQty_UpBound {
				IndexDomain: (htmon,h,h1,step);
			}
			Parameter HFixed_Arc_Fee {
				IndexDomain: (htmon,reg,reg1);
				Text: "represents gathering charges, storage fees, fixed tariffs";
				Definition: 0;
			}
			Parameter HQP_GatheringCharge {
				IndexDomain: (htmon,s);
				Text: "Gathering Charge";
				Comment: "represents gathering charges, storage fees, fixed tariffs";
			}
			Parameter HQP_StorageFee {
				IndexDomain: (htmon,storage,h);
				Text: "storage fee";
				InitialData: 0.1;
				Comment: "represents storage fees by arc in Planning Period";
			}
			Parameter HParameter_TariffCurvePrice {
				IndexDomain: (h,h1,step);
			}
			Parameter HParameter_CapacityUtilization {
				IndexDomain: (h,h1,step);
			}
			Parameter HPriceStepAdj {
				Definition: 1.05;
			}
		}
		DeclarationSection Historical_LNG_Export_Curve_Declarations {
			ElementParameter HLNGExpCrv_MaxStep {
				Range: Supply_Curve_Step_;
				Definition: Element(Supply_Curve_Step_,2);
				Comment: "Maximum step on the LNG export curve";
			}
			Parameter HLNGExportPrc {
				IndexDomain: (htmon,lngexp_qp,step);
			}
			Parameter HLNGExportQty {
				IndexDomain: (htmon,lngexp_qp,step);
			}
			Parameter HLNGExport_UpBound {
				IndexDomain: (htmon,lngexp_qp,step);
			}
			Parameter HParameter_LNGExpQty {
				IndexDomain: step;
			}
			Parameter HParameter_LNGExpPrc {
				IndexDomain: step;
			}
		}
		DeclarationSection Historical_QP_Parameters {
			Parameter HQP_SlackVar_Value {
				Comment: "Read in via ngassumptions.txt";
			}
			Parameter HQP_Consumption {
				IndexDomain: (htmon,d);
			}
			Parameter HQP_Discrepancy {
				IndexDomain: (htmon,d);
			}
			Parameter HQP_Storage_Withdrawals {
				IndexDomain: (htmon,qpstorage);
			}
			Parameter HQP_Storage_Injections {
				IndexDomain: (htmon,storage);
			}
			Parameter HQP_Supply {
				IndexDomain: (htmon,suptype,s);
			}
			Parameter HQP_SupplyPrice {
				IndexDomain: (htmon,suptype,s);
			}
			Parameter HQP_SupplyPriceSolution {
				IndexDomain: (histmon,suptype,s);
			}
			Parameter HQP_PipelineTariff {
				IndexDomain: (htmon,h,h1);
			}
			Parameter HQP_Capacity {
				IndexDomain: (htmon,h,h1);
			}
			Parameter HQP_LNGExportCapacity {
				IndexDomain: (htmon,lngexp_qp);
			}
			Parameter HQP_LNGExportPrice {
				IndexDomain: (htmon,lngexp_qp);
				Definition: 3;
			}
			Parameter HQP_StorageLoss {
				IndexDomain: (htmon,storage);
			}
			Parameter HQP_DistributionLoss {
				IndexDomain: (htmon,d);
			}
			Parameter HQP_PlantFuel {
				IndexDomain: (htmon,d);
			}
			Parameter HParameter_SupCrv {
				IndexDomain: (suptype,step,n);
			}
			Parameter HParameter_SupElasticity {
				IndexDomain: (suptype,step,n);
			}
			Parameter HParameter_PrcElasticity {
				IndexDomain: (suptype,step,n);
			}
			Parameter HQPFLG_NegativeDemand {
				IndexDomain: (htmon,d);
			}
			Parameter HSlope;
		}
		DeclarationSection Historical_QP_Variables_and_Constraints {
			Set HQPConstraints {
				SubsetOf: AllConstraints;
				Definition: {
					Data {hSupplyMassBalance,
					hSupplyAccounting,
					hHubBalance,
					hTariffCurveQtyBalance,
					hDemandMassBalance,
					hStorageInjBalance,
					hStorageWthBalance,
					hLNGExportBalance,
					hHubBalance_BXtoUS,
					hHubBalance_UStoBX
					}
				}
			}
			Set HQPVariables {
				SubsetOf: AllVariables;
				Definition: {
					Data {hQSupplyStep,
					hQProduction,
					hQLNGexp,
					hQTariffCurve,
					hFlowHubToHub,
					hFlowHubToDemand,
					hFlowHubToLNGExport,
					hFlowHubToStorage,
					hFlowSupplyToHub,
					hFlowStorageToHub,
					hSLackVar,
					hOBJ}
				}
			}
			Set HQPVariables1 {
				SubsetOf: AllVariables;
				Definition: {
					Data {hQSupplyStep,
					hQProduction,
					hQLNGexp,
					hQTariffCurve,
					hFlowHubToHub,
					hFlowHubToDemand,
					hFlowHubToLNGExport,
					hFlowHubToStorage,
					hFlowSupplyToHub,
					hFlowStorageToHub,
					hSLackVar,
					hFlowDelta,
					hOBJ1}
				}
			}
			Variable hQSupplyStep {
				IndexDomain: (htmon,suptype,qps,step) | map_Supply(qps, suptype);
				Range: [HQ_LowerBound(htmon, suptype, qps, step), HQ_UpperBound(htmon, suptype, qps, step)];
			}
			Variable hQProduction {
				IndexDomain: (htmon,suptype,qps)| HQP_Supply(htmon,suptype,qps) and map_Supply(qps,suptype);
				Range: nonnegative;
				Property: ReducedCost;
				Comment: "Sums up production over all the steps of supply curve";
			}
			Variable hQLNGexp {
				IndexDomain: (htmon,lngexp_qp,step)| HQP_LNGExportCapacity(htmon,lngexp_qp);
				Range: [HLNGExport_UpBound(htmon, lngexp_qp, step), HLNGExport_UpBound(htmon, lngexp_qp, step)];
			}
			Variable hQTariffCurve {
				IndexDomain: (htmon,h,h1,step)| HQP_Capacity(htmon,h,h1);
				Range: [0, HPipeTarCrvQty_UpBound(htmon, h, h1, step)];
			}
			Variable hFlowHubToHub {
				IndexDomain: (htmon,h,h1)| HQP_Capacity(htmon,h,h1);
				Range: [0, HQP_Capacity(htmon, h, h1)];
			}
			Variable hFlowSupplyToHub {
				IndexDomain: (htmon,qps,h)| map_SupplyArcs(qps, h);
				Range: nonnegative;
			}
			Variable hFlowHubToDemand {
				IndexDomain: (htmon,h,d);
				Range: nonnegative;
			}
			Variable hFlowHubToLNGExport {
				IndexDomain: (htmon,h,lngexp_qp)| HQP_LNGExportCapacity(htmon,lngexp_qp);
				Range: nonnegative;
			}
			Variable hFlowStorageToHub {
				IndexDomain: (htmon,storage,h);
				Range: nonnegative;
			}
			Variable hFlowHubToStorage {
				IndexDomain: (htmon,h,storage);
				Range: nonnegative;
			}
			Variable hOBJ {
				Text: "Objective Function for hist QP";
				Range: free;
				Definition: {
					sum(htmon,
					!Area under the Supply curve
					 - sum((suptype,qps,step) | map_Supply(qps,suptype) and step <= HSupCrv_MaxStep, (HPbase(htmon,suptype,qps,step)*hQSupplyStep(htmon,suptype,qps,step) +
					       0.5* sqr(hQSupplyStep(htmon,suptype,qps,step)) * (HPbase(htmon,suptype,qps,step+1)-HPbase(htmon,suptype,qps,step))/ (HQbase(htmon,suptype,qps,step+1)-HQbase(htmon,suptype,qps,step))))
					- sum(qps, HQP_SlackVar_Value* hSLackVar(htmon,qps))
					!Area under the Pipeline Tariff curve
					-sum((qph,qph1,step)| HQP_Capacity(htmon,qph,qph1) and step <= HPTCrv_MaxStep, HPipelineTariff(htmon,qph,qph1,step) * hQTariffCurve(htmon,qph,qph1,step) +
					     0.5 * sqr( hQTariffCurve(htmon,qph,qph1,step) ) *
					     (HPipelineTariff(htmon,qph,qph1,step+1) - HPipelineTariff(htmon,qph,qph1,step) )/ (HPipeTariffCurveQty(htmon,qph,qph1,step+1) - HPipeTariffCurveQty(htmon,qph,qph1,step) ) )
					
					 !Fixed  Fees
					 !- sum((h,h1) | HQP_Capacity(htmon,h,h1), HFixed_Arc_Fee(htmon,h,h1) * hFlowHubToHub(htmon,h,h1))
					
					  !Gathering Charges
					 - sum((qps,qph) | map_SupplyArcs(qps, qph), HQP_GatheringCharge(htmon,qps) * hFlowSupplyToHub(htmon, qps, qph))
					
					 !Storage Fees
					 - sum((qpstorage,qph) | map_StorageArcs(qpstorage,qph), HQP_StorageFee(htmon,qpstorage,qph) * hFlowStorageToHub(htmon,qpstorage,qph))
					
					 !Area under the LNG Export Curve
					+ sum((lngexp_qp,step) | step <= HLNGExpCrv_MaxStep, HLNGExportPrc(htmon,lngexp_qp,step) * hQLNGexp(htmon,lngexp_qp,step) +
					       0.5* sqr(hQLNGexp(htmon,lngexp_qp,step)) * (HLNGExportPrc(htmon,lngexp_qp,step+1)-HLNGExportPrc(htmon,lngexp_qp,step)) / $ (HLNGExportQty(htmon, lngexp_qp, step+1)-HLNGExportQty(htmon,lngexp_qp,step)))
					  )
				}
				Comment: "consumer plus producer surplus minus variable transport costs";
			}
			Variable hOBJ1 {
				Text: "Objective Function for hist QP";
				Range: free;
				Definition: {
					sum(htmon,
					!Area under the Supply curve
					 - sum((suptype,qps,step) | map_Supply(qps,suptype) and step <= HSupCrv_MaxStep, (HPbase(htmon,suptype,qps,step)*hQSupplyStep(htmon,suptype,qps,step) +
					       0.5* sqr(hQSupplyStep(htmon,suptype,qps,step)) * (HPbase(htmon,suptype,qps,step+1)-HPbase(htmon,suptype,qps,step))/ (HQbase(htmon,suptype,qps,step+1)-HQbase(htmon,suptype,qps,step))))
					- sum(qps, 10^9* hSLackVar(htmon,qps))
					!Area under the Pipeline Tariff curve
					-sum((h,h1,step)| HQP_Capacity(htmon,h,h1) and step <= HPTCrv_MaxStep, HPipelineTariff(htmon,h,h1,step) * hQTariffCurve(htmon,h,h1,step) +
					     0.5 * sqr( hQTariffCurve(htmon,h,h1,step) ) *
					     (HPipelineTariff(htmon,h,h1,step+1) - HPipelineTariff(htmon,h,h1,step) )/ (HPipeTariffCurveQty(htmon,h,h1,step+1) - HPipeTariffCurveQty(htmon,h,h1,step) ) )
					
					!Cost factors for calibration
					-sum((usbx, usbx1) | map_HubArcs(usbx, usbx1), 0.5*HSlope*sqr(hFlowDelta(usbx, usbx1)))
					 !Fixed  Fees
					 !- sum((h,h1) | HQP_Capacity(htmon,h,h1), HFixed_Arc_Fee(htmon,h,h1) * hFlowHubToHub(htmon,h,h1))
					
					  !Gathering Charges
					 - sum((qps,h) | map_SupplyArcs(qps, h), HQP_GatheringCharge(htmon,qps) * hFlowSupplyToHub(htmon, qps, h))
					
					 !Storage Fees
					 - sum((storage,h) | map_StorageArcs(storage,h), HQP_StorageFee(htmon,storage,h) * hFlowStorageToHub(htmon,storage,h))
					
					 !Area under the LNG Export Curve
					+ sum((lngexp_qp,step) | step <= HLNGExpCrv_MaxStep, HLNGExportPrc(htmon,lngexp_qp,step) * hQLNGexp(htmon,lngexp_qp,step) +
					       0.5* sqr(hQLNGexp(htmon,lngexp_qp,step)) * (HLNGExportPrc(htmon,lngexp_qp,step+1)-HLNGExportPrc(htmon,lngexp_qp,step)) / $ (HLNGExportQty(htmon, lngexp_qp, step+1)-HLNGExportQty(htmon,lngexp_qp,step)))
					  )
				}
				Comment: "Objective function with cost factors for calibration";
			}
			Variable hSLackVar {
				IndexDomain: {
					(htmon,qps) !| sum(suptype, HQP_Supply(htmon,suptype,qps))
				}
				Range: nonnegative;
				Comment: "Artificial Slack Varialble to add extra supply to avoid infeasibility";
			}
			Variable hFlowDelta {
				IndexDomain: (usbx, usbx1) | map_HubArcs(usbx, usbx1);
				Range: free;
				Property: Inline;
				Definition: sum(htmon,hFlowHubToHub(htmon,usbx, usbx1))-FlowsAnnual(HQPYear, usbx, usbx1);
			}
			Constraint hSupplyMassBalance {
				IndexDomain: (htmon,qps);
				Property: ShadowPrice;
				Definition: {
					!sum(suptype | map_Supply(qps,suptype), hQProduction(htmon,suptype,qps))+ hSLackVar(htmon,qps) = sum(h | map_SupplyArcs(qps,h), hFlowSupplyToHub(htmon,qps,h) )
					sum(suptype | map_Supply(qps,suptype) , hQProduction(htmon,suptype,qps)+ hSLackVar(htmon,qps)) = sum(h | map_SupplyArcs(qps,h), hFlowSupplyToHub(htmon,qps,h) )
				}
			}
			Constraint hSupplyAccounting {
				IndexDomain: (htmon,suptype,qps);
				Property: ShadowPrice;
				Definition: hQProduction(htmon,suptype,qps) = Sum(step | step <= HSupCrv_MaxStep, hQSupplyStep(htmon,suptype,qps,step))+ HQbaseMin(htmon,suptype,qps);
				Comment: "Sums up production over all the steps of supply curve";
			}
			Constraint hDemandMassBalance {
				IndexDomain: (htmon,d);
				Definition: {
					sum(h | map_DemandArcs(h,d), hFlowHubToDemand(htmon,h,d)  ) = HQP_Consumption(htmon,d) + HQP_DistributionLoss(htmon,d) + HQP_StorageLoss(htmon,d) +
					                                                                                            HQP_PlantFuel(htmon,d) - HQP_Discrepancy(htmon,d) !QP_Discrepancy_Demand(tmon,d) !
				}
			}
			Constraint hHubBalance {
				IndexDomain: (htmon,h) |h in (Hubs_-BorderCrossings_);
				Property: ShadowPrice;
				Definition: {
					sum(storage | map_StorageArcs(storage,h), hFlowStorageToHub(htmon,storage,h)) +
					sum(qps | map_SupplyArcs(qps,h), hFlowSupplyToHub(htmon,qps,h)) +
					sum(h1 | map_HubArcs(h1, h), hFlowHubToHub(htmon,h1,h) 
					* (1- (PipeFuelLossFactorOUT(h1, h) +PipeFuelLossFactorIN(h1, h)-PipeFuelLossFactorOUT(h1, h) *PipeFuelLossFactorIN(h1, h)))
					) =
					sum(h2 | map_HubArcs(h, h2), hFlowHubToHub(htmon,h,h2) ) + sum(d | map_DemandArcs(h,d), hFlowHubToDemand(htmon,h,d) )
					+ sum(lngexp_qp | map_LNGExpArcs(h,lngexp_qp), hFlowHubToLNGExport(htmon,h,lngexp_qp) ) 
					+ sum(storage | map_StorageArcs(storage,h), hFlowHubToStorage(htmon,h, storage))
				}
			}
			Constraint hHubBalance_BXtoUS {
				IndexDomain: (htmon,BX);
				Property: ShadowPrice;
				Definition: {
					sum(r_int | map_HubArcs(r_int,BX) and map_hubs_borderXings(r_int,BX), hFlowHubToHub(htmon,r_int,BX) *
					(1- PipeFuelLossFactorOUT(r_int, BX))*(1-PipeFuelLossFactorIN(r_int, BX))) =
					sum(l48 | map_HubArcs(BX,l48) and map_hubs_borderXings(l48,bx), hFlowHubToHub(htmon,BX,l48) )
				}
			}
			Constraint hHubBalance_UStoBX {
				IndexDomain: (htmon,BX);
				Property: ShadowPrice;
				Definition: {
					sum(l48 | map_HubArcs(l48,BX) and map_hubs_borderXings(l48,BX), hFlowHubToHub(htmon,l48,BX) *
					(1- PipeFuelLossFactorOUT(l48, BX))*(1-PipeFuelLossFactorIN(l48, BX))) =
					sum(r_int | map_HubArcs(BX,r_int) and map_hubs_borderXings(r_int,bx), hFlowHubToHub(htmon,BX,r_int) )
				}
			}
			Constraint hStorageWthBalance {
				IndexDomain: (htmon,qpstorage);
				Definition: sum(qph | map_StorageArcs(qpstorage,qph), hFlowStorageToHub(htmon,qpstorage,qph) )= HQP_Storage_Withdrawals(htmon,qpstorage);
			}
			Constraint hStorageInjBalance {
				IndexDomain: (htmon,qpstorage);
				Definition: sum(qph | map_StorageArcs(qpstorage,qph), hFlowHubToStorage(htmon,qph,qpstorage))= HQP_Storage_Injections(htmon,qpstorage);
			}
			Constraint hLNGExportBalance {
				IndexDomain: (htmon,lngexp_qp)| HQP_LNGExportCapacity(htmon,lngexp_qp);
				Definition: Sum(step |step <= LNGExpCrv_MaxStep , hQLNGexp(htmon,lngexp_qp,step))= sum(h | map_LNGExpArcs(h,lngexp_qp), hFlowHubToLNGExport(htmon,h,lngexp_qp) );
			}
			Constraint hTariffCurveQtyBalance {
				IndexDomain: (htmon,h,h1)| HQP_Capacity(htmon,h,h1);
				Property: ShadowPrice;
				Definition: {
					
					hFlowHubToHub(htmon,h,h1) = Sum(step | step <= HPTCrv_MaxStep , hQTariffCurve(htmon,h,h1,step))
				}
			}
			MathematicalProgram HistoricalQP {
				Objective: hOBJ;
				Direction: maximize;
				Constraints: HQPConstraints;
				Variables: HQPVariables;
				Type: Automatic;
			}
			MathematicalProgram HistCalibrQP {
				Objective: hOBJ1;
				Direction: maximize;
				Constraints: HQPConstraints;
				Variables: HQPVariables1;
				Type: Automatic;
			}
		}
		DeclarationSection Calibration_Sets_and_Parameters {
			Set CalibIterations_ {
				SubsetOf: Integers;
				Index: caliter;
				Property: ElementsAreLabels;
				Definition: {
					{1..350}
				}
			}
			Parameter Calibration_Switch;
			Parameter CalibrationMode {
				InitialData: 0;
			}
			ElementParameter MaxCalibIter {
				Range: CalibIterations_;
			}
			ElementParameter CurCalibIter {
				Range: CalibIterations_;
			}
			Parameter ConvTolerCalib;
			Parameter ScaleCalib;
			Parameter VarTarAdj {
				IndexDomain: (reg,reg1);
			}
			Parameter AFlowTemp {
				IndexDomain: (reg,reg1,caliter);
			}
			Parameter TarAdjTemp {
				IndexDomain: (reg,reg1,caliter);
			}
			Parameter TariffTemp {
				IndexDomain: (reg,reg1,step,caliter);
			}
			Parameter Tariff_HistAnnual {
				IndexDomain: (histyr,h,h1);
			}
			Parameter PriceSpot_HistSoln {
				IndexDomain: (histyr,h);
			}
			Parameter delta_chk {
				IndexDomain: (reg,reg1);
			}
			Parameter deltaflg {
				IndexDomain: (reg,reg1);
			}
			Parameter deltaflag;
			Parameter tmp {
				IndexDomain: caliter;
			}
			Parameter tmp1;
			Parameter Switch_BX;
			Parameter FlowBinding_Monthly {
				IndexDomain: (mon,h,h1);
			}
		}
		Procedure HCurveDefinitions {
			Body: {
				!Define supply curve steps
				HQbase(htmon,suptype,s,step) := HQP_Supply(htmon,suptype,s) *  HSupCrvParameter(suptype,step);
				HPbase(htmon,suptype,s,step) := HQP_SupplyPrice(htmon,suptype,s) * HSupCrvPriceElasticity(suptype,step);
				!Define minimum production
				HQbaseMin(htmon,suptype,qps) := HQbase(htmon,suptype,qps,HSupCrv_Firststep);
				HQbaseMax(htmon,suptype,s) := HQbase(htmon,suptype,s,HSupCrv_Maxstep+1);
				
				! Set upper bound for the supply curve steps
				HQ_UpperBound( (htmon,suptype,s,step) | step <= HSupCrv_MaxStep) := ( HQbase(htmon,suptype,s,step+1) - HQbase(htmon,suptype,s,step) ) ;
				! Set lower bound for the supply curve steps for variable supply
				HQ_LowerBound( (htmon, varsup, s, step) | step <= HSupCrv_MaxStep) := 0;
				! Set lower bound for the supply curve steps for fixed supply
				HQ_LowerBound( (htmon, fixsup, s, step) | step <= HSupCrv_MaxStep) := HQ_UpperBound(htmon, fixsup, s, step);
				
				!Define Pipeline Tariff Curve steps
				HPipeTariffCurveQty(htmon,h,h1,step) := HQP_Capacity(htmon,h,h1) * HParameter_CapacityUtilization(h, h1,step);
				HPipelineTariff(htmon,h,h1,step) :=  HParameter_TariffCurvePrice(h, h1,step);
				HPipelineTariffReport((htmon,h,h1,step) | step <= HPTCrv_MaxStep) :=  HParameter_TariffCurvePrice(h, h1,step+1);
				
				HPipeTarCrvQty_UpBound( (htmon,h,h1,step) | step <= HPTCrv_MaxStep) := HPipeTariffCurveQty(htmon,h,h1,step+1) - HPipeTariffCurveQty(htmon,h,h1,step);
				
				
				!define LNG Export Curve steps
				HLNGExportQty(htmon,lngexp_qp,step) := HQP_LNGExportCapacity(htmon,lngexp_qp) * HParameter_LNGExpQty(step);
				HLNGExportPrc(htmon,lngexp_qp,step) := HQP_LNGExportPrice(htmon,lngexp_qp) * HParameter_LNGExpPrc(step);
				
				HLNGExport_UpBound( (htmon,lngexp_qp,step) | step <= HLNGExpCrv_MaxStep ) := HLNGExportQty(htmon, lngexp_qp, step+1) - HLNGExportQty(htmon,lngexp_qp,step);
			}
		}
		Procedure TransferDataIntoHQPparameters {
			Body: {
				LinkHistHorizonToCalendar; !create time table
				!Define maximum step on the tariff curve
				!HPTCrv_MaxStep := Element(Supply_Curve_Step_,3);
				
				!Transfer data into QP Parameters
				
				!TotalConsumption( (mon,l48)  ) :=  sum(sec, Cons_State_Mon(mon, sec, l48)); !End Use Consumption Subroutine **moved to End Use Consumption Run... delete once verified it works
				HQP_Consumption(htmon,d) := 	TotalConsumption(MonthInHistPeriod(htmon), d);
				!QP_Consumption(tmon,l48) := 	sum(sec, Cons_State_Mon(MonthInPeriod(tmon), sec, l48));	!End Use Consumption Subroutine
				
				HQP_Discrepancy(htmon,d) := BalanceItem(MonthInHistPeriod(htmon), d);
				!This code replaces the line above in the attempt to avoid infeasibilities caused by negative "demand" when discrepancy for a state is larger than consumption in that state
				!QP_Discrepancy_Demand((tmon,d) | BalanceItem(MonthInPeriod(tmon), d)<=0) := BalanceItem(MonthInPeriod(tmon), d);
				!QP_Discrepancy_Supply((tmon,s) | BalanceItem(MonthInPeriod(tmon), s)>=0) := BalanceItem(MonthInPeriod(tmon), s);
				!
				HQP_Storage_Withdrawals(htmon,storage) := StorageWithdrawals(MonthInHistPeriod(htmon), storage);
				HQP_Storage_Injections(htmon,storage) := StorageInjections(MonthInHistPeriod(htmon), storage);
				
				HQP_Supply(htmon,suptype,s) := Supply(MonthInHistPeriod(htmon), suptype, s) ;
				!Subtract lease fuel
				HQP_Supply(htmon,naadgas, s) *= (1 - HistoricalLeaseFuelFactor(YearInHistPeriod(htmon), s));
				HQP_SupplyPrice(htmon,suptype,s) := WellhdPrice(YearInHistPeriod(htmon), suptype, s);
				
				HQP_GatheringCharge(htmon,s) := GatheringCharge(s);
				HQP_Capacity(htmon,h,h1) := Capacity(MonthInHistPeriod(htmon), h, h1);
				HParameter_CapacityUtilization(h, h1, step) := VariableTariffCurve(h, h1, Qtype, step);
				HParameter_TariffCurvePrice(h, h1, step) := HTariffCurvePrc(HQPYear, h, h1, step);
				!QP_PipelineTariff(tmon,h,h1) := 1;
				HQP_LNGExportCapacity(htmon,lngexp_qp) := LNGExports(MonthInHistPeriod(htmon), lngexp_qp);
				
				! storage losses
				HQP_StorageLoss(htmon,storage) := StorageLosses(MonthInHistPeriod(htmon), storage);
				! distribution losses
				!**********Add Canada and Mexico later **************
				HQP_DistributionLoss(htmon,l48) := DistributionLosses(MonthInHistPeriod(htmon), l48) ;
				
				!plant fuel
				HQP_PlantFuel(htmon,l48) := PlantFuel(MonthInHistPeriod(htmon), l48) ;
				
				!pipeline fuel factors
				PipeFuelLossFactorIN(h, h1) := mean(datayear | datayear >= FirstHQPYear and datayear <= LastHQPYear, HisPipeFuelLossFactorIN(datayear, h, h1));
				PipeFuelLossFactorOUT(h, h1):= mean(datayear | datayear >= FirstHQPYear and datayear <= LastHQPYear, HisPipeFuelLossFactorOUT(datayear, h, h1));
				
				!Assign supply curve parameters for fixed and variable supply
				HParameter_SupCrv(suptype, step, n) := Parameter_SupCrv(suptype, step, n);
				HParameter_SupElasticity(suptype, step, n)  := Parameter_SupElasticity(suptype, step, n);
				HParameter_PrcElasticity(suptype, step, n) := Parameter_PrcElasticity(suptype, step, n);
				HParameter_LNGExpQty(step):=Parameter_LNGExpQty(step);
				HParameter_LNGExpPrc(step):=Parameter_LNGExpPrc(step);
				HParameter_SupCrv(fixsup,step, n)  := Parameter_SupCrv(Supply_AD,step, n);
				HParameter_SupElasticity(fixsup,step, n)  := Parameter_SupElasticity(Supply_AD,step, n);
				HParameter_PrcElasticity(fixsup,step, n)  := Parameter_PrcElasticity(Supply_AD,step, n);
				HParameter_SupCrv(varsup,step, n)  := Parameter_SupCrv(Supply_NA,step, n);
				HParameter_SupElasticity(varsup,step, n)  := Parameter_SupElasticity(Supply_NA,step, n);
				HParameter_PrcElasticity(varsup,step, n)  := Parameter_PrcElasticity(Supply_NA,step, n);
				
				!Handle possible negative demand error (usually occurs when discrepancy > consumption)
				!Set a flag indicating that the demand mass balance constraint RHS <0
				HQPFLG_NegativeDemand((htmon, d) | (HQP_Consumption(htmon,d) + HQP_DistributionLoss(htmon,d) + HQP_StorageLoss(htmon,d) + 
							HQP_PlantFuel(htmon,d) - HQP_Discrepancy(htmon,d)) < 0) :=1;
				!Replace negative demand with 0
				HQP_Consumption((htmon,d) | HQPFLG_NegativeDemand(htmon, d) ) := 0;
				HQP_DistributionLoss((htmon,d) | HQPFLG_NegativeDemand(htmon, d) ) := 0;
				HQP_StorageLoss((htmon,d) | HQPFLG_NegativeDemand(htmon, d) ) := 0;
				HQP_PlantFuel((htmon,d) | HQPFLG_NegativeDemand(htmon, d) ) := 0;
				HQP_Discrepancy((htmon,d) | HQPFLG_NegativeDemand(htmon, d) ) := 0;
				if sum((htmon,d), HQPFLG_NegativeDemand(htmon, d)) then
				   write HQPFLG_NegativeDemand((htmon, d) | HQPFLG_NegativeDemand(htmon, d)) to file "NGATTENTION.txt" in merge mode;
				   RAISE WARNING "RHS of DemandMassBalance constraint is negative in " +HQPYear+"; Resetting RHS to 0. See NGATTENTION.txt for details." CODE 'NegativeRHS';
				endif;
			}
			Comment: "Transfer data for Planning Period into QP parameters";
		}
		Procedure SolveHistoricalQP {
			Body: {
				
				TransferDataIntoHQPparameters;
				HCurveDefinitions;
				solve HistoricalQP ;
				
				!Display error message when QP is not optimal during standalone execution
				QPErrorString := FormatString("Historical QP is not optimal in year %e", HQPYear);
				halt with QPErrorString
				when (HistoricalQP.ProgramStatus <> 'Optimal');
			}
		}
		Procedure SolveCalibQP {
			Body: {
				
				TransferDataIntoHQPparameters;
				HCurveDefinitions;
				solve HistCalibrQP ;
				
				!Display error message when QP is not optimal during standalone execution
				QPErrorString := FormatString("Historical QP is not optimal in year %e", HQPYear);
				halt with QPErrorString
				when (HistCalibrQP.ProgramStatus <> 'Optimal');
			}
		}
		Procedure Hist_PostProcess {
			Body: {
				FlowsAnnualHistSolution(HQPYear, h, h1)  := sum(htmon, hFlowHubToHub(htmon,h,h1));
				  FlowsMonthly(MonthInHistPeriod(htmon), h, h1)  := hFlowHubToHub(htmon,h,h1);
				  FlowDifference(HQPYear, h, h1):=FlowsAnnual(HQPYear, h, h1)-FlowsAnnualHistSolution(HQPYear, h, h1);
				  delta_chk((h, h1) |map_HubArcs(h, h1)):= FlowsAnnual(HQPYear, h, h1)/$ FlowsAnnualHistSolution(HQPYear, h, h1);
				  delta_chk((h, h1) | map_HubArcs(h, h1) and FlowsAnnual(HQPYear, h, h1)<=2 and abs(FlowDifference(HQPYear, h, h1))<=2):= 1;
				  Tariff_Soln((MonthInHistPeriod(htmon), h, h1) | hFlowHubToHub(htmon,h,h1))  := hTariffCurveQtyBalance.ShadowPrice(htmon,h,h1);
				  TariffAnnual(HQPYear, h, h1):= sum(hqpyrmn,Tariff_Soln(hqpyrmn, h, h1)*FlowsMonthly(hqpyrmn, h, h1))/$ FlowsAnnualHistSolution(HQPYear, h, h1);
				  NodePrice_Soln(MonthInHistPeriod(htmon), l48) := -hHubBalance.ShadowPrice(htmon, l48); 
				  PriceSpot_HistSoln(HQPYear,l48) := sum((hqpyrmn,sec), NodePrice_Soln(hqpyrmn,l48)* Cons_State_Mon(hqpyrmn,sec, l48))/
				     sum(sec,Cons_State_Yr(HQPYear, sec, l48));
				  NodePriceAnnual(HQPYear, h) := sum(hqpyrmn, NodePrice_Soln(hqpyrmn, h))/card(HQPYearMonths_);
				
				   ActualProductionMonthly((MonthInHistPeriod(htmon), suptype, qps)|map_Supply(qps, suptype)) := hQProduction(htmon,suptype,qps); !sum(step, QSupplyStep(tmon,suptype,s,step)); !net of lease fuel
				   ActualProductionAnnual(HQPYear, suptype, qps) := sum(hqpyrmn, ActualProductionMonthly(hqpyrmn, suptype, qps));
				   MonthlyProductionForReport(hqpyrmn, suptype, d) := sum( qps | map_SupplyArcs(qps, d), ActualProductionMonthly(hqpyrmn, suptype, qps));
				   QP_SupplyPriceSolution(MonthInHistPeriod(htmon),suptype, qps)  := hSupplyAccounting.ShadowPrice(htmon,suptype,qps);
				   WellhdPrice_Soln((HQPYear, suptype, qps) | map_Supply(qps, suptype) and ActualProductionAnnual(HQPYear, suptype, qps)):=  $ sum(hqpyrmn, QP_SupplyPriceSolution(hqpyrmn,suptype, qps)*
				           ActualProductionMonthly(hqpyrmn, suptype, qps))/ $ ActualProductionAnnual(HQPYear, suptype, qps);
				   NetDemand(hqpyrmn, d) := TotalConsumption(hqpyrmn, d) + StorageInjections(hqpyrmn, d) + QTotalLNGExports(hqpyrmn, d) -
				        sum(suptype, MonthlyProductionForReport(hqpyrmn, suptype, d)) - StorageWithdrawals(hqpyrmn, d) - BalanceItem(hqpyrmn, d) -
				        LeaseFuel(hqpyrmn, d);
				
				   NetDemandAnnual(HQPYear, d) := sum(hqpyrmn, NetDemand(hqpyrmn, d));
				
				   FlowBinding( (HQPYear,h,h1) | map_HubArcs(h, h1) and (CapacityAnnual(HQPYear,h,h1)- FlowsAnnualHistSolution(HQPYear, h, h1))< 0.01) := FlowsAnnualHistSolution(HQPYear, h, h1);
				FlowBinding_Monthly( (hqpyrmn,h,h1) | map_HubArcs(h, h1) and (Capacity(hqpyrmn,h,h1)- FlowsMonthly(hqpyrmn,h,h1))< 0.01) := FlowsMonthly(hqpyrmn,h,h1);
			}
		}
		Procedure Pipefuel_HistPostprocess {
			Body: {
				TranFuelLosses(h) := sum(h1, FlowsAnnualHistSolution(HQPYear, h, h1) * PipeFuelLossFactorOUT(h, h1))
				                              + sum(h1, FlowsAnnualHistSolution(HQPYear, h1, h) * (1 - PipeFuelLossFactorOUT(h1, h))* PipeFuelLossFactorIN(h1, h));
				PipeFuelLossAnnual(HQPYear, h) := TranFuelLosses(h) + StorageLossesAnnual(HQPYear, h) + DistributionLossesAnnual(HQPYear,h) + IntrastatePipeFuelLossesAnnual(HQPYear,h);
			}
			Parameter TranFuelLosses {
				IndexDomain: reg;
			}
		}
		Procedure RunHQP {
			Body: {
				HQPYear:=FirstHQPYear;
				Calibration_Switch:=DialogAsk("Choose calibration method:", "Iterative approach","Cost factors","Pipeline fuel factors Only");
				repeat
				!PipefuelFactors_Initialize;
				map_HubArcs((qph, qph1) | CapacityAnnual(HQPYear, qph, qph1)) := 1;
				map_l48Arcs((usbx, usbx1) | map_HubArcs(usbx, usbx1)):=1; 
				SolveHistoricalQP;
				Flow_HistPostProcess;
				BalancingItem_HistPostProcess;
				!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				!  CALIBRATE                        !
				!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				if Calibration_Switch=1 then    !Iterative approach
				VarTarAdj(qph, qph1):=0;
				CurCalibIter:=1;
				
				repeat
				delta_chk(reg, reg1):=0;
				deltaflg(reg, reg1):=0;
				SolveHistoricalQP;
				AFlowTemp(qph, qph1, CurCalibIter):=sum(htmon,hFlowHubToHub(htmon,qph,qph1));
				AFlowTemp((qph, qph1, CurCalibIter) | not FlowsAnnual(HQPYear, qph, qph1) and AFlowTemp(qph, qph1, CurCalibIter)<1):=0;
				TarAdjTemp(qph, qph1, CurCalibIter):=VarTarAdj(qph, qph1);
				TariffTemp(qph, qph1, step, CurCalibIter):=HTariffCurvePrc(HQPYear, qph, qph1, step);
				Switch_BX:=1;
				if Switch_BX=1 then
				!**********************************************
				!With arcs to and from border-crossings
				delta_chk((usbx, usbx1) |map_HubArcs(usbx, usbx1)):= FlowsAnnual(HQPYear, usbx, usbx1)/$ AFlowTemp(usbx, usbx1, CurCalibIter);
				FlowDifference(HQPYear, qph, qph1):=FlowsAnnual(HQPYear, qph, qph1)-AFlowTemp(qph, qph1, CurCalibIter);
				delta_chk((usbx, usbx1) | map_HubArcs(usbx, usbx1) and FlowsAnnual(HQPYear, usbx, usbx1)<=10 and abs(FlowDifference(HQPYear, usbx, usbx1))<=10):= 1;
				deltaflg((usbx, usbx1) | (1-ConvTolerCalib)<=delta_chk(usbx, usbx1)<=(1+ConvTolerCalib)):=1;
				tmp(CurCalibIter):=sum((usbx, usbx1), deltaflg(usbx, usbx1) );
				tmp1:=count((usbx, usbx1),CapacityAnnual(HQPYear, usbx, usbx1) );
				deltaflag:= sum((usbx, usbx1), deltaflg(usbx, usbx1) )/ count((usbx, usbx1),CapacityAnnual(HQPYear, usbx, usbx1) );
				
				break when deltaflag=1 or CurCalibIter=MaxCalibIter;
				VarTarAdj((usbx, usbx1) | map_HubArcs(usbx, usbx1)):= ( 1-(FlowsAnnual(HQPYear, usbx, usbx1)/$ AFlowTemp(usbx, usbx1, CurCalibIter)) )*ScaleCalib;
				VarTarAdj((usbx, usbx1) | map_HubArcs(usbx, usbx1) and not AFlowTemp(usbx, usbx1, CurCalibIter)):= -ScaleCalib;
				
				HTariffCurvePrc((HQPYear, usbx, usbx1, step) | map_HubArcs(usbx, usbx1) and step<=HPTCrv_MaxStep+1)+=VarTarAdj(usbx, usbx1);
				
				!make tariffs on both sides of border-crossing nodes equal 
				HTariffCurvePrc((HQPYear, r_int, bx, step) |map_hubs_borderXings(r_int,bx)):= sum(l48 | map_hubs_borderXings(l48,bx), HTariffCurvePrc(HQPYear, bx, l48, step));
				HTariffCurvePrc((HQPYear, bx, r_int, step) |map_hubs_borderXings(r_int,bx)):= sum(l48 | map_hubs_borderXings(l48,bx), HTariffCurvePrc(HQPYear, l48, bx, step));
				elseif Switch_BX=2 then
				!*******************************************************
				!With NO arcs to and from border-crossings
				delta_chk((l48, l48a) |map_HubArcs(l48, l48a)):= FlowsAnnual(HQPYear, l48, l48a)/$ AFlowTemp(l48, l48a, CurCalibIter);
				FlowDifference(HQPYear, qph, qph1):=FlowsAnnual(HQPYear, qph, qph1)-AFlowTemp(qph, qph1, CurCalibIter);
				delta_chk((l48, l48a) | map_HubArcs(l48, l48a) and FlowsAnnual(HQPYear, l48, l48a)<=10 and abs(FlowDifference(HQPYear, l48, l48a))<=10):= 1;
				deltaflg((l48, l48a) | (1-ConvTolerCalib)<=delta_chk(l48, l48a)<=(1+ConvTolerCalib)):=1;
				deltaflag:= sum((l48, l48a), deltaflg(l48, l48a) )/ count((l48, l48a),CapacityAnnual(HQPYear, l48, l48a) );
				tmp(CurCalibIter):=sum((l48, l48a), deltaflg(l48, l48a) );
				tmp1:=count((l48, l48a),CapacityAnnual(HQPYear, l48, l48a) );
				break when deltaflag=1 or CurCalibIter=MaxCalibIter;
				VarTarAdj((l48, l48a) | map_HubArcs(l48, l48a)):= ( 1-FlowsAnnual(HQPYear, l48, l48a)/$ AFlowTemp(l48, l48a, CurCalibIter) )*ScaleCalib;
				VarTarAdj((l48, l48a) | FlowsAnnual(HQPYear, l48, l48a) and not AFlowTemp(l48, l48a, CurCalibIter)):= -ScaleCalib;
				
				HTariffCurvePrc((HQPYear, l48, l48a, step) | map_HubArcs(l48, l48a) and step<=HPTCrv_MaxStep+1)+=VarTarAdj(l48, l48a);
				!***************************************************************
				endif;
				
				CurCalibIter+=1;
				endrepeat;
				
				elseif Calibration_Switch=2 then  !Cost factors approach
				  SolveCalibQP;
				  FlowsAnnualHistSolution(HQPYear, qph, qph1)  := sum(htmon, hFlowHubToHub(htmon,qph,qph1));
				  FlowDifference(HQPYear, qph, qph1):=FlowsAnnual(HQPYear, qph, qph1)-FlowsAnnualHistSolution(HQPYear, qph, qph1);
				  delta_chk((qph, qph1) |map_HubArcs(qph, qph1)):= FlowsAnnual(HQPYear, qph, qph1)/$ FlowsAnnualHistSolution(HQPYear, qph, qph1);
				  delta_chk((qph, qph1) | map_HubArcs(qph, qph1) and FlowsAnnual(HQPYear, qph, qph1)<=2 and abs(FlowDifference(HQPYear, qph, qph1))<=2):= 1;
				  Tariff_Soln((MonthInHistPeriod(htmon), qph, qph1) | hQP_Capacity(htmon,qph,qph1))  := hTariffCurveQtyBalance.ShadowPrice(htmon,qph,qph1);
				  Tariff_HistAnnual(HQPYear, qph, qph1):= sum(htmon,hTariffCurveQtyBalance.ShadowPrice(htmon,qph,qph1))/12;
				  Calculate_Hist_Tariff_Adj(HQPYear, qph,qph1, Tariff_HistAnnual(histyr, qph, qph1),FlowsAnnualHistSolution(histyr, qph, qph1));
				
				elseif Calibration_Switch=3 then  !Calibrate pipeline fuel factors only
				  SolveCalibQP;
				
				endif;
				Hist_PostProcess;   
				Pipefuel_HistPostprocess;
				break when (HQPYear=LastHQPYear);
				
				HQPYear+=1;
				FirstPeriodInHistPlanningInterval += 12;
				endrepeat;
				Save_PipelineFuelFactors_and_Tariffs;
			}
		}
		Procedure Save_PipelineFuelFactors_and_Tariffs {
			Body: {
				!write PipeFuelLossFactorIN to file "data\\NGPipelineFuelFactors.txt" ;
				!write PipeFuelLossFactorOUT to file "data\\NGPipelineFuelFactors.txt" in merge mode;
				put NGPipelineFuelFactors;
				display{PipeFuelLossFactorIN,PipeFuelLossFactorOUT};
				!display{PipeFuelLossFactorOUT};
				putclose NGPipelineFuelFactors;
				
				VariableTariffCurve(h, h1, Ptype, step):= HTariffCurvePrc(HQPYear, h, h1, step);
				
				!write VariableTariffCurve to file "data\\NGVarTarCurve.txt" ;
				put NGVarTarCurve;
				display{VariableTariffCurve};
				putclose NGVarTarCurve;
			}
		}
		DeclarationSection Output_Declaration {
			File NGPipelineFuelFactors {
				Name: "data//NGPipelineFuelFactors.txt";
				Device: Disk;
				Mode: replace;
			}
			File NGVarTarCurve {
				Name: "data\\NGVarTarCurve.txt";
				Device: Disk;
				Mode: replace;
			}
		}
	}
	Section Alaska_Section {
		Procedure AK_InitializeData {
			Body: {
				!AK LNG Exports are initialized in Import Export initialization procedure:  AnnualLNGExports(datayear,AKState)
				!AK fuel used for liquefaction set in LNG export initialization procedure:
					!LNGFuelForLiquefaction(datayear, lngexp) := HistoricalAnnualLiquefactionFuel(datayear, lngexp);
				
				!Once Annual citygate prices are read in, replace this assignment with HistoricalAnnualCitygatePrice
				!AK_Citygate(histyr) := WHPrice_OGSM(12,histyr);
				AK_Citygate(datayear) := HistoricalAnnualCitygatePrice(datayear,AKState);
				
				AK_Cons_EndUse(datayear,sec) :=  HistoricalAnnualDemand(datayear,sec,AKState);
				!AK_Discrepancy(datayear) := HistoricalBalanceItem(histyr, AKState);
				AK_LeasePlant(datayear,AKRegion_North) := HistoricalAnnualLeaseFuel(datayear,AKState) + HistoricalAnnualPlantFuel(datayear,AKState);
				AK_Pipeline(datayear,AKRegion_South) := HistoricalAnnualPipeFuel(datayear,AKState);
				
				!now assigned by OGSM
				!AK_Production(datayear,AKRegion_North) := AK_LeasePlant(datayear,AKRegion_North);
				!AK_Production(datayear,AKRegion_South) :=  sum( (ogdist,r_ak)|NEMSmap_OGDIST_r_ak(ogdist,r_ak) ,
				!				OGSMOUT_OGADGPRD(ogdist, card(oiltyp), NEMSmap_MNUMYR(datayear)) + OGSMOUT_OGRNAGPRD(ogdist, card(gastyp), NEMSmap_MNUMYR(datayear)))- AK_Production(datayear,AKRegion_North);
			}
			Comment: {
				"All data reads for Alaska subroutine.
				All historical data is set.
				Temporarily, this file also contains all the reads for NEMS Transfer and Mapping, Lagged Terms, and Debugging Reports."
			}
		}
		Procedure Alaska_Subroutine_Run {
			Body: {
				!yda: moved from definition and added a year dimension
				AK_LNG_Exports(ModelYear) := LNG_ExportCapacity(ModelYear,AKState);
				
				!Assign Alaska citygate price
				AK_Citygate(ModelYear) :=EXP(x_AK_Citygate1)*WorldOilPrice(ModelYear,'USD_bbl')^x_AK_Citygate2;
				
				!Alaska enduse price
				AK_Price_EndUse(ModelYear, sec):= AK_Citygate(ModelYear)+PriceMarkup(sec);
				
				!Assign South Alaska Consumption
				AK_Cons_EndUse(ModelYear,Sector_Residential):=	(x_AK_Cons_Residential1*Population(ModelYear)
									+x_AK_Cons_Residential2*Unemployment(ModelYear)
									+x_AK_Cons_Residential3*AK_Citygate(ModelYear));
				AK_Cons_EndUse(ModelYear,Sector_Commercial):=	(x_AK_Cons_Commercial1*Population(ModelYear))
									+(x_AK_Cons_Commercial2*Unemployment(ModelYear))
									+(x_AK_Cons_Commercial3*(AK_Cons_EndUse(ModelYear-1,Sector_Commercial)-(x_AK_Cons_Commercial1*Population(ModelYear-1))-(x_AK_Cons_Commercial2*Unemployment(ModelYear-1))));
				AK_Cons_EndUse(ModelYear,Sector_Industrial):=	AK_Cons_Industrial;
				AK_Cons_EndUse(ModelYear,Sector_Electric):=	sum(season, Cons_Electric_season(card(NNGEMM),ModelYear,season));
				
				!Assign Alaska Pipeline Fuel
				!AK_Pipeline( ModelYear,AKRegion_South)	:= 	sum(sec,AK_Cons_EndUse(ModelYear,sec))  * AK_PIP_Percent(AKRegion_South);
				AK_Pipeline( ModelYear,AKRegion_North)	:= AK_LNG_Exports(ModelYear)*(1+Pct_Liquifaction_Fuel)*AK_PIP_Percent(AKRegion_North);
				
				!Assign Alaska Lease & Plant Fuel
				AK_LeasePlant(ModelYear,AKRegion_North) := 	x_AK_N_LAP1 + (x_AK_N_LAP2 * AK_Prod_Crude_Total(ModelYear))
									+ (x_AK_N_LAP3 *AK_LeasePlant(ModelYear-1,AKRegion_North));
				
				AK_LeasePlant_LNG(ModelYear) := ((AK_LNG_Exports(ModelYear)*(1+Pct_Liquifaction_Fuel))+ AK_Pipeline( ModelYear,AKRegion_North))*(AK_LSE_Percent(AKRegion_North)+AK_PLT_Percent(AKRegion_North));
				
				
				
				
				!Assign AK balancing item
				AK_Discrepancy(ModelYear) := sum(modelyrmn, BalanceItem(modelyrmn,AKState));
				
				!Assign Alaska Production
				!North AK production equals lease and plant fuel used in oil operations plus any LNG volumes (including liqefaction fuel and LAP)
				AK_Production(ModelYear,AKRegion_North):=	AK_LeasePlant(ModelYear,AKRegion_North) + AK_LeasePlant_LNG(ModelYear)+ AK_Pipeline(ModelYear,AKRegion_North)
										+ (AK_LNG_Exports(ModelYear)*(1+Pct_Liquifaction_Fuel));
				!	((AK_LNG_Exports(ModelYear)*(1+Pct_Liquifaction_Fuel))/(1-AK_PLT_Percent(AKRegion_North)-AK_PIP_Percent(AKRegion_North) - AK_LSE_Percent(AKRegion_North)));
				
				!South AK production equals consumption plus pipeline fuel
				AK_Production(ModelYear,AKRegion_South):=	(sum(sec,AK_Cons_EndUse(ModelYear,sec))/(1-AK_PIP_Percent(AKRegion_South)))  + AK_Discrepancy(ModelYear);
			}
		}
		Section AK_Production_and_Consumption {
			DeclarationSection AK_Production_and_Consumption_Declaration {
				Parameter Population {
					IndexDomain: year;
				}
				Parameter AK_Cons_EndUse {
					IndexDomain: (year,sec);
				}
				Parameter AK_Production {
					IndexDomain: (year,r_ak);
				}
				Parameter AK_Cons_Industrial;
				Parameter AK_LNG_Exports {
					IndexDomain: (year);
					Text: "LNG exports from AK to Pacific basin, units are Bcf";
					Definition: {
						!yda: moved definition to Alaska_Subroutine_Run and added a year dimension
						!Export_LNG_LNGTER('11',ModelYear)	!This should change once border crossing mappings are finalized
					}
				}
				Parameter AK_Discrepancy {
					IndexDomain: year;
				}
			}
			DeclarationSection AK_Consumption_Coefficient_Declaration {
				Parameter x_AK_Cons_Commercial1;
				Parameter x_AK_Cons_Commercial2;
				Parameter x_AK_Cons_Commercial3;
				Parameter x_AK_Cons_Residential1;
				Parameter x_AK_Cons_Residential2;
				Parameter x_AK_Cons_Residential3;
			}
		}
		Section AK_LAP_and_PIP {
			DeclarationSection AK_LAP_Coefficient_Declaration {
				Parameter x_AK_N_LAP1;
				Parameter x_AK_N_LAP2;
				Parameter x_AK_N_LAP3;
			}
			DeclarationSection AK_LAP_and_PIP_Declaration {
				Parameter AK_Prod_Crude_Total {
					IndexDomain: year;
					Definition: sum(MNUMYR, sum(M3,OGSMOUT_OGPRCOAK(M3, MNUMYR))*NEMSmap_MNUMYR_yr(MNUMYR,year));
				}
				Parameter AK_LeasePlant {
					IndexDomain: (year,r_ak);
				}
				Parameter AK_LeasePlant_LNG {
					IndexDomain: (year);
				}
				Parameter AK_Pipeline {
					IndexDomain: (year,r_ak);
				}
				Parameter AK_PLT_Percent {
					IndexDomain: (r_ak);
				}
				Parameter AK_PIP_Percent {
					IndexDomain: r_ak;
				}
				Parameter AK_LSE_Percent {
					IndexDomain: r_ak;
				}
			}
		}
		Section AK_Prices_Calculations {
			DeclarationSection Equation_Coefficient_Declaration {
				Parameter x_AK_Citygate1 {
					Property: Integer8;
				}
				Parameter x_AK_Citygate2 {
					Property: Integer8;
				}
			}
			DeclarationSection AK_Price_Declaration {
				Parameter AK_Citygate {
					IndexDomain: year;
					Range: nonnegative;
					Definition: {
						!EXP(x_AK_Citygate1)*WorldOilPrice(year,'USD_bbl')^x_AK_Citygate2
					}
					Comment: {
						"This parameter is set when running the \"Alaska_Subroutine_Run\" procedure.
						It also serves as the Alaska wellhead price variable and is set to NEMS through variable NGTDMREP_OGWPRNG(MNUMOR,MNUMYR)."
					}
				}
				Parameter PriceMarkup {
					IndexDomain: (sec);
				}
				Parameter AK_Price_EndUse {
					IndexDomain: (year,sec);
					Definition: {
						!yda: moved to Alaska_Subroutine_Run so that all the years do not get overridden by current ModelYear
						!AK_Citygate(ModelYear)+PriceMarkup(sec)
					}
				}
			}
		}
	}
	Section Texas_Section {
		Procedure TX_InitializeData {
			Body: {
				read from file NGTEXASN in merge mode;
				read from file NGTXCAPAN in merge mode;
				
				! Assign sub-regional historical residential, commercial, industrial, electric, and transportation consumption
				
				! Monthly
				!Cons_State_Mon(datamon,sec, state | state in TXRegion_)  := HistoricalDemand(datamon,sec,TexasState) * TexasConsShares(state | state in TXRegion_ ,sec);
				
				!Yearly
			}
		}
		Procedure TX_PostProcess {
			Body: {
				Cons_State_Mon(modelyrmn, Sector_Residential, TexasState) := sum(l48 | l48 in TXRegion_, Cons_State_Mon(modelyrmn, Sector_Residential, l48));
				Cons_State_Mon(modelyrmn, Sector_Commercial, TexasState) := sum(l48 | l48 in TXRegion_, Cons_State_Mon(modelyrmn, Sector_Commercial, l48));
				Cons_State_Mon(modelyrmn, Sector_Industrial, TexasState) := sum(l48 | l48 in TXRegion_, Cons_State_Mon(modelyrmn, Sector_Industrial, l48));
				Cons_State_Mon(modelyrmn, Sector_Electric, TexasState) := sum(l48 | l48 in TXRegion_, Cons_State_Mon(modelyrmn, Sector_Electric, l48));
			}
		}
		Section TX_Variables {
			DeclarationSection Texas_Import_and_Export_Declarations {
				Parameter HistoricalExports_TX {
					IndexDomain: (datamon,BX);
				}
			}
			DeclarationSection Texas_Region_Declarations {
				ElementParameter TXRegion_West {
					Range: TXRegion_;
					Comment: "Also Region 1";
				}
				ElementParameter TXRegion_North {
					Range: TXRegion_;
					Comment: "Also Region 2";
				}
				ElementParameter TXRegion_East {
					Range: TXRegion_;
					Comment: "Also Region 3";
				}
				Set TXRegion_ {
					SubsetOf: Regions_;
					Index: r_tx;
				}
				Parameter tx_regions {
					IndexDomain: r_tx;
				}
			}
			DeclarationSection Texas_Consumption_Declarations {
				Parameter TexasConsShares {
					IndexDomain: (state,sec);
				}
			}
			DeclarationSection Texas_Storage_Declarations {
				Parameter TexasStorageShares {
					IndexDomain: storage;
				}
			}
		}
	}
	Section Balancing_Item_Section {
		DeclarationSection Balance_Item_Declaration {
			Parameter BalanceItem {
				IndexDomain: (mon,reg);
				Comment: "BalanceItem = Demand - Supply (i.e., Supply + BalanceItem = Demand)";
			}
			Parameter AverageBalanceItem {
				IndexDomain: (mn,reg);
			}
			Parameter TotalBalanceItem {
				IndexDomain: year;
			}
		}
		Procedure BalancingItem_Initialize {
			Body: {
				!!Calculate annual balancing item for each state
				HistoricalBalanceItem_Calc(datayear, l48) := sum(datamon |map_month_year(datamon,datayear), TotalConsumption(datamon,l48) + LNGExports(datamon, l48) +
				         StorageInjections(datamon,l48) - StorageWithdrawals(datamon,l48) - sum((suptype,l48s)|map_SupplyArcs(l48s, l48) , Supply(datamon, suptype, l48s))) +
				 !        StorageLosses(datamon,l48) + DistributionLosses(datamon, l48) +IntrastatePipeFuelLosses(datamon, l48)) +
				         sum(h , HistoricalFlowAnnual(l48, h, datayear | h <> TexasState and l48 <> TexasState)) - sum(h, HistoricalFlowAnnual(h, l48, datayear | h <> TexasState and l48 <> TexasState))+
				         HistoricalAnnualPipeFuel(datayear,l48)+ LeaseAndPlantFuelAnnual(datayear,l48) + LNGFuelForLiquefaction(datayear, l48);
				HistoricalBalanceItem_Diff(datayear,l48) := HistoricalBalanceItem_Calc(datayear, l48) - HistoricalBalanceItem(datayear, l48);
				
				!Test to split TX balancing item
				HistoricalBalanceItem_Calc(datayear, l48 | l48 in TXRegion_) := HistoricalBalanceItem(datayear, TexasState)/3;
				
				
				BalanceItem(histmon,l48) := HistoricalBalanceItem_Calc(MonthToYear(histmon),l48) * NumberOfDaysInMonth(histmon)/ NumberOfDaysInYear(MonthToYear(histmon));
				!APPROACH 1 (simple): assume no seasonality and that the balancing item is constant across the year in each state.
				!BalanceItem(histmon,state) := HistoricalBalanceItem(MonthToYear(histmon),state) * NumberOfDaysInMonth(histmon)/ NumberOfDaysInYear(MonthToYear(histmon));
				BalanceItem(histmon,AKState) := HistoricalBalanceItem(MonthToYear(histmon),AKState) * NumberOfDaysInMonth(histmon)/ NumberOfDaysInYear(MonthToYear(histmon));
				!APPROACH 2 (more exact):
				!Calculate the sum across states of the annual numbers
				!BalanceItem_SumOverStates(histyr) := sum(state, HistoricalBalanceItem(histyr, state));
				!!Calculate the sum of the national monthly numbers in each year
				!BalanceItem_SumOverMonths(histyr) := sum(histmon | map_month_year(histmon, histyr), HistoricalNationalBalanceItemMonthly(histmon));
				!!Adjust the national monthly numbers so the sum of the monthly numbers in each year (SumOverMonths) total to the sum across states of the annual numbers (SumOverStates).
				!HistoricalNationalBalanceItemMonthly(histmon) += (BalanceItem_SumOverStates(MonthToYear(histmon)) - BalanceItem_SumOverMonths(MonthToYear(histmon))) /12;
				!
				!!Set an estimate of the balancing item in each state and month:
				!BalanceItem(histmon,state) := (TotalUSConsumptionAnnual(MonthToYear(histmon))
				!                            * (HistoricalNationalBalanceItemMonthly(histmon)*Card(MonthinYear_) + HistoricalBalanceItem(MonthToYear(histmon), state)*Card(States_) -
				!                             BalanceItem_SumOverStates(MonthToYear(histmon)) )
				!                            + (HistoricalNationalBalanceItemMonthly(histmon) * HistoricalBalanceItem(MonthToYear(histmon), state) * Card(MonthinYear_) * Card(States_)))
				!                            / ((TotalUSConsumptionAnnual(MonthToYear(histmon)) + BalanceItem_SumOverStates(MonthToYear(histmon))) * Card(MonthinYear_) * Card(States_));
				
				!For BOTH Approaches:
				! Calculate average discrepancy for last NumberOfYearsForAverage_Discrepancy_ (10) historical years
				!AverageBalanceItem(mn,state)  :=  sum((mon,navgyr_discr) | map_Month_MonthinYear(mon,mn) and LastHistoricalMonth+1<=mon<=LastHistoricalMonth+12,
				!                                                      BalanceItem(mon-12*Val(navgyr_discr), state))/ Card(NumberOfYearsForAverage_Discrepancy_);
				AverageBalanceItem(mn,state)  :=  sum((laghistyrmn,navgyr_discr) | map_Month_MonthinYear(laghistyrmn,mn) and laghistyrmn>=FirstModelMonth,
				                                                      BalanceItem(laghistyrmn-12*Val(navgyr_discr), state))/ Card(NumberOfYearsForAverage_Discrepancy_);
				
				BalanceItem ((mon,state) | mon>= FirstModelMonth) := sum(mn | map_Month_MonthinYear(mon,mn), AverageBalanceItem(mn,state)) ;
				
				!Calculate total balancing item to send to NEMS
				TotalBalanceItem(year) := sum((mon,state)|map_month_year(mon,year), BalanceItem(mon,state));
			}
			Comment: {
				"Calculate the balancing item by month and state. Historical data are provided in the API annually by state and nationally by month.
				BalanceItem = Demand - Supply"
			}
			DeclarationSection Balancing_Item_Declaration;
		}
		Procedure BalancingItem_Canada {
			Body: {
				!Supply and Demand are calculated in Canada_InitializeData
				
				!Calculate total Canada annual balancing item
				!HistoricalBalanceItem(histyr, CanadaWest) := sum((histmon,cn) |map_month_year(histmon,histyr), TotalConsumption(histmon,cn) + LNGExports(histmon, cn) +
				!         StorageInjections(histmon,cn) - StorageWithdrawals(histmon,cn) - sum(suptype, Supply(histmon, suptype, cn)) ) +
				!         sum((cn,BX) |map_hubs_borderXings(cn,BX), HistoricalFlowAnnual(cn, BX, histyr)) - sum((BX,cn) |map_hubs_borderXings(cn,BX), HistoricalFlowAnnual(BX, cn, histyr));
				!
				!Calculate Canada annual balancing item
				HistoricalBalanceItem(histyr, cn) := sum(histmon |map_month_year(histmon,histyr), TotalConsumption(histmon,cn) + LNGExports(histmon, cn) +
				         StorageInjections(histmon,cn) - StorageWithdrawals(histmon,cn) - sum(suptype, Supply(histmon, suptype, cn)) ) +
				         sum(h , HistoricalFlowAnnual(cn, h, histyr)) - sum(h , HistoricalFlowAnnual(h, cn, histyr));
				!Split in two for East and West
				!HistoricalBalanceItem(histyr, CanadaWest) /= 2;
				!HistoricalBalanceItem(histyr, CanadaEast) := HistoricalBalanceItem(histyr, CanadaWest);
				
				BalanceItem(histmon,cn) := HistoricalBalanceItem(MonthToYear(histmon),cn) * NumberOfDaysInMonth(histmon)/ NumberOfDaysInYear(MonthToYear(histmon));
				
				!AverageBalanceItem(mn,cn)  :=  sum((mon,navgyr_discr) | map_Month_MonthinYear(mon,mn) and LastHistoricalMonth+1<=mon<=LastHistoricalMonth+12,
				 !        BalanceItem(mon-12*Val(navgyr_discr), cn))/ Card(NumberOfYearsForAverage_Discrepancy_);
				AverageBalanceItem(mn,cn)  :=  sum((mon,navgyr_discr_cn) | map_Month_MonthinYear(mon,mn) and LastHistoricalMonth+1<=mon<=LastHistoricalMonth+12,
				        BalanceItem(mon-12*Val(navgyr_discr_cn), cn))/ Card(NumberOfYearsForAverage_Discrepancy_CN_);
				
				
				BalanceItem ((mon,cn) | mon>= FirstModelMonth) := sum(mn | map_Month_MonthinYear(mon,mn), AverageBalanceItem(mn,cn)) ;
				
				!Calculate CN_W -> CN_E flow
				!HistoricalFlowAnnual(CanadaWest, CanadaEast, histyr):= sum(histmon | map_month_year(histmon,histyr), sum(suptype, Supply(histmon, suptype, CanadaWest)) +
				!        StorageWithdrawals(histmon,CanadaWest) - TotalConsumption(histmon,CanadaWest) - LNGExports(histmon, CanadaWest) - StorageInjections(histmon,CanadaWest)) +
				!        sum(BX |map_hubs_borderXings(CanadaWest,BX), HistoricalFlowAnnual(BX, CanadaWest, histyr)) + HistoricalBalanceItem(histyr, CanadaWest) -
				!        sum(BX |map_hubs_borderXings(CanadaWest,BX), HistoricalFlowAnnual(CanadaWest, BX, histyr));
				
				!FlowsAnnual(histyr, CanadaWest, CanadaEast) := HistoricalFlowAnnual(CanadaWest, CanadaEast, histyr);
			}
			Comment: {
				"BalanceItem = Demand - Supply
				Calculate Balancing Item for total Canada and split in two; Flow CN_W to CN_E will be calculated as well"
			}
			DeclarationSection Local_Declarations;
		}
		Procedure BalancingItem_Mexico {
			Body: {
				!Calculate total Mexico annual balancing item
				HistoricalBalanceItem(histyr, MexicoNorthEast) := sum((histmon,mx) |map_month_year(histmon,histyr), TotalConsumption(histmon,mx) + LNGExports(histmon, mx) +
				         StorageInjections(histmon,mx) - StorageWithdrawals(histmon,mx) - sum(suptype, Supply(histmon, suptype, mx)) ) +
				         sum((mx,BX) |map_hubs_borderXings(mx,BX), HistoricalFlowAnnual(mx, BX, histyr)) - sum((BX,mx) |map_hubs_borderXings(mx,BX), HistoricalFlowAnnual(BX, mx, histyr));
				!Split in two for East and West
				HistoricalBalanceItem(histyr, MexicoNorthEast) /= card(Mexico_);
				HistoricalBalanceItem(histyr, mx) := HistoricalBalanceItem(histyr, MexicoNorthEast);
				
				BalanceItem(histmon,mx) := HistoricalBalanceItem(MonthToYear(histmon),mx) * NumberOfDaysInMonth(histmon)/ NumberOfDaysInYear(MonthToYear(histmon));
				
				!AverageBalanceItem(mn,mx)  :=  sum((mon,navgyr_discr) | map_Month_MonthinYear(mon,mn) and LastHistoricalMonth+1<=mon<=LastHistoricalMonth+12,
				!         BalanceItem(mon-12*Val(navgyr_discr), mx))/ Card(NumberOfYearsForAverage_Discrepancy_);
				!
				!BalanceItem ((mon,mx) | mon>= FirstModelMonth) := sum(mn | map_Month_MonthinYear(mon,mn), AverageBalanceItem(mn,mx)) ;
			}
			Comment: {
				"BalanceItem = Demand - Supply
				Calculate Balancing Item for total Canada and split in two; Flow CN_W to CN_E will be calculated as well"
			}
		}
		Procedure BalancingItem_HistPostProcess {
			Body: {
				!!Calculate annual balancing item for each state
				HistoricalBalanceItem_Calc(HQPYear, l48) := sum(hqpyrmn , TotalConsumption(hqpyrmn,l48) + LNGExports(hqpyrmn, l48) +
				         StorageInjections(hqpyrmn,l48) - StorageWithdrawals(hqpyrmn,l48) - sum((suptype,l48s)|map_SupplyArcs(l48s, l48) , Supply(hqpyrmn, suptype, l48s))) +
				 !        StorageLosses(datamon,l48) + DistributionLosses(datamon, l48) +IntrastatePipeFuelLosses(datamon, l48)) +
				!         sum(h , HistoricalFlowModel(l48, h, datayear)) - sum(h, HistoricalFlowModel(h, l48, datayear))+
				         sum(h , FlowsAnnual(HQPYear, l48, h)) - sum(h, FlowsAnnual(HQPYear, h, l48 ))+
				         HistoricalAnnualPipeFuel(HQPYear,l48)+ LeaseAndPlantFuelAnnual(HQPYear,l48); !+ HistoricalAnnualPlantFuel(datayear, l48) + HistoricalAnnualLeaseFuel(datayear, l48);!
				HistoricalBalanceItem_Diff(HQPYear,l48) := HistoricalBalanceItem_Calc(HQPYear, l48) - HistoricalBalanceItem(HQPYear, l48);
				BalanceItem(hqpyrmn,l48) := HistoricalBalanceItem_Calc(MonthToYear(hqpyrmn),l48) * NumberOfDaysInMonth(hqpyrmn)/ NumberOfDaysInYear(MonthToYear(hqpyrmn));
				BalanceItem(hqpyrmn,AKState) := HistoricalBalanceItem(MonthToYear(hqpyrmn),AKState) * NumberOfDaysInMonth(hqpyrmn)/ NumberOfDaysInYear(MonthToYear(hqpyrmn));
			}
		}
	}
	Section Capacity_and_Capacity_Expansion_Section {
		DeclarationSection Capacity_Declarations {
			Parameter PipeCapacity {
				IndexDomain: (mon,h,h1);
			}
			Parameter Capacity {
				IndexDomain: (mon,h,h1);
				Text: "Capacity by arc in bcf (monthly)";
				Comment: "capacity by arc in bcf per month";
			}
			Parameter CurrentPipeCapacity {
				IndexDomain: (mon,qph,qph1);
			}
			Parameter CapacityAddition {
				IndexDomain: (h,h1);
			}
			Parameter CapacityAdditionsMonthly {
				IndexDomain: (mon,h,h1);
			}
			Parameter CapacityMaxBuild {
				IndexDomain: (tmon,qph,qph1);
			}
			Parameter PlannedCapacity {
				IndexDomain: (h,h1,year);
			}
			Parameter PlannedCapacityAdditions {
				IndexDomain: (mon,h,h1);
			}
			Parameter CapacityAnnual {
				IndexDomain: (year,h,h1);
			}
			Parameter CapacityAdditionAnnual {
				IndexDomain: (year,h,h1);
			}
			Parameter CapacityAdditionUnplanned_Annual {
				IndexDomain: (year,h,h1);
			}
			Parameter CapacityDaily_EOY {
				IndexDomain: (year,h,h1);
			}
		}
		DeclarationSection Capacity_Expansion_Declarations {
			Parameter ConsumptionForCapExp {
				IndexDomain: (mon,sec,qpd);
			}
			Parameter WeatherFactor1 {
				IndexDomain: (mn,sec,reg);
			}
			Parameter WeatherFactor2 {
				IndexDomain: (mn,sec);
			}
		}
		Section Cap_Exp_QP_Structure {
			DeclarationSection Cap_Exp_Supply_Curve_Declarations {
				Parameter CE_Qbase {
					IndexDomain: (tcapexp,suptype,s,step);
				}
				Parameter CE_QbaseMin {
					IndexDomain: (tcapexp,suptype,s);
					Comment: "Minimum production";
				}
				Parameter CE_Q_UpperBound {
					IndexDomain: (tcapexp,suptype,s,step);
					Range: nonnegative;
				}
				Parameter CE_Q_LowerBound {
					IndexDomain: (tcapexp,suptype,s,step);
					Range: nonnegative;
				}
				Parameter CE_Pbase {
					IndexDomain: (tcapexp,suptype,s,step);
				}
			}
			DeclarationSection Cap_Exp_Tariff_Curve_Declarations {
				Parameter CE_PipelineTariff {
					IndexDomain: (tcapexp,qph,qph1,step);
				}
				ElementParameter CE_PTCrv_MaxStep {
					Range: Supply_Curve_Step_;
					Comment: "Maximum step on the pipeline tariff curve";
				}
				Parameter CE_PipeTariffCurveQty {
					IndexDomain: (tcapexp,qph,qph1,step);
				}
				Parameter CE_PipeTarCrvQty_UpBound {
					IndexDomain: (tcapexp,h,h1,step);
				}
				Parameter CE_Slope_TariffCurve {
					IndexDomain: (tcapexp,qph,qph1,step);
				}
				Parameter CE_Fixed_Arc_Fee {
					IndexDomain: (tcapexp,reg,reg1);
					Text: "represents storage fees, fixed tariffs";
					Definition: 0;
				}
				Parameter CE_GatheringCharge {
					IndexDomain: (tcapexp,s);
					Text: "Gathering Charge";
					Comment: "represents gathering charges, storage fees, fixed tariffs";
				}
				Parameter CE_StorageFee {
					IndexDomain: (tcapexp,storage,h);
					Text: "storage fee";
					InitialData: 0.1;
					Comment: "represents storage fees by arc in Planning Period";
				}
			}
			DeclarationSection Cap_Exp_LNG_Export_Curve_Declarations {
				Parameter CE_LNGExportPrc {
					IndexDomain: (tcapexp,lngexp_qp,step);
				}
				Parameter CE_LNGExportQty {
					IndexDomain: (tcapexp,lngexp_qp,step);
				}
				Parameter CE_LNGExport_UpBound {
					IndexDomain: (tcapexp,lngexp_qp,step);
				}
				Parameter CE_LNGExport_LoBound {
					IndexDomain: (tcapexp,lngexp_qp,step);
				}
			}
			DeclarationSection CAp_Exp_Capacity_Declarations {
				Parameter CE_CapacityMaxBuild {
					IndexDomain: (tcapexp,h,h1);
				}
			}
			DeclarationSection CE_Parameters {
				Parameter CE_SlackVar_Value {
					Comment: "Read in ngassumptions.txt";
				}
				Parameter CE_Consumption {
					IndexDomain: (tcapexp,qpd);
				}
				Parameter CE_Discrepancy {
					IndexDomain: (tcapexp,qpd);
				}
				Parameter CE_Discrepancy_Supply {
					IndexDomain: (tcapexp,reg);
				}
				Parameter CE_Discrepancy_Demand {
					IndexDomain: (tcapexp,reg);
				}
				Parameter CE_Storage_Withdrawals {
					IndexDomain: (tcapexp,qpstorage);
					Definition: {
						!NetStorage(storage, mon)
					}
				}
				Parameter CE_Storage_Injections {
					IndexDomain: (tcapexp,qpstorage);
					Definition: {
						!NetStorage(storage, mon)
					}
				}
				Parameter CE_Supply {
					IndexDomain: (tcapexp,suptype,s);
				}
				Parameter CE_SupplyPrice {
					IndexDomain: (tcapexp,suptype,s);
				}
				Parameter CE_VarPipelineTariff {
					IndexDomain: (tcapexp,h,h1);
				}
				Parameter CE_Capacity {
					IndexDomain: (tcapexp,qph,qph1);
				}
				Parameter CE_LNGExportCapacity {
					IndexDomain: (tcapexp,lngexp_qp);
				}
				Parameter CE_LNGExportPrice {
					IndexDomain: (tcapexp,lngexp_qp);
				}
				Parameter CE_StorageLoss {
					IndexDomain: (tcapexp,qpstorage);
				}
				Parameter CE_DistributionLoss {
					IndexDomain: (tcapexp,qpd);
				}
				Parameter CE_IntrastatePipeFuelLoss {
					IndexDomain: (tcapexp,qpd);
				}
				Parameter CE_PlantFuel {
					IndexDomain: (tcapexp,qpd);
				}
				Parameter CEFLG_NegativeDemand {
					IndexDomain: (tcapexp,qpd);
				}
			}
			DeclarationSection Cap_Exp_QP_Variables_and_Constraints {
				Set CE_Constraints {
					SubsetOf: AllConstraints;
					Definition: {
						Data {CE_SupplyMassBalance,
						CE_SupplyAccounting,
						CE_HubBalance,
						CE_HubBalance_UStoBX,
						CE_HubBalance_BXtoUS,
						CE_DemandMassBalance,
						CE_StorageInjBalance,
						CE_StorageWthBalance,
						CE_LNGExportBalance,
						CE_TariffCurveQtyBalance
						!CE_TariffCurveQtyTotal
						!CE_OBJ
						}
					}
				}
				Set CE_Variables {
					SubsetOf: AllVariables;
					Definition: {
						Data {CE_QSupplyStep,
						CE_QProduction,
						CE_QLNGexp,
						CE_QTariffCurve,
						CE_FlowHubToHub,
						CE_FlowHubToDemand,
						CE_FlowHubToLNGExport,
						CE_FlowHubToStorage,
						CE_FlowSupplyToHub,
						CE_FlowStorageToHub,
						CE_SLackVar,
						CE_QTariffCurveTotal,
						!CE_OBJnew
						CE_OBJ_ALL
						}
					}
				}
				Variable CE_QSupplyStep {
					IndexDomain: (tcapexp,suptype,qps,step)| map_Supply(qps, suptype);
					Range: [CE_Q_LowerBound(tcapexp, suptype, qps, step), CE_Q_UpperBound(tcapexp, suptype, qps, step)];
				}
				Variable CE_QProduction {
					IndexDomain: (tcapexp,suptype,qps)| CE_Supply(tcapexp,suptype,qps) and map_Supply(qps,suptype);
					Range: nonnegative;
					Property: ReducedCost;
					Comment: "Sums up production over all the steps of supply curve";
				}
				Variable CE_QLNGexp {
					IndexDomain: (tcapexp,lngexp_qp,step)| CE_LNGExportCapacity(tcapexp,lngexp_qp);
					Range: [CE_LNGExport_LoBound(tcapexp, lngexp_qp, step), CE_LNGExport_UpBound(tcapexp, lngexp_qp, step)];
				}
				Variable CE_QTariffCurve {
					IndexDomain: (tcapexp,qph,qph1,step)| CE_Capacity(tcapexp, qph, qph1);
					Range: [0, CE_PipeTarCrvQty_UpBound(tcapexp, qph, qph1, step)];
				}
				Variable CE_QTariffCurveTotal {
					IndexDomain: (tcapexp,qph,qph1,step)| CE_Capacity(tcapexp, qph, qph1) and step <= CE_PTCrv_MaxStep;
					Range: free;
					Definition: sum(x_step | x_step<=step, CE_QTariffCurve(tcapexp,qph,qph1,x_step));
				}
				Variable CE_FlowHubToHub {
					IndexDomain: (tcapexp,qph,qph1) | CE_Capacity(tcapexp,qph,qph1);
					Range: [0, CE_CapacityMaxBuild(tcapexp, qph, qph1)];
				}
				Variable CE_FlowSupplyToHub {
					IndexDomain: (tcapexp,qps,qph)| map_SupplyArcs(qps, qph);
					Range: nonnegative;
				}
				Variable CE_FlowHubToDemand {
					IndexDomain: (tcapexp,qph,qpd);
					Range: nonnegative;
				}
				Variable CE_FlowHubToLNGExport {
					IndexDomain: (tcapexp,qph,lngexp_qp)| CE_LNGExportCapacity(tcapexp,lngexp_qp);
					Range: nonnegative;
				}
				Variable CE_FlowStorageToHub {
					IndexDomain: (tcapexp,storage,qph);
					Range: nonnegative;
				}
				Variable CE_FlowHubToStorage {
					IndexDomain: (tcapexp,qph,qpstorage);
					Range: nonnegative;
				}
				Variable CE_OBJ {
					Text: "Objective Function";
					Range: free;
					Definition: {
						sum(tcapexp,
						!Area under the Supply curve
						 - sum((suptype,qps,step) | map_Supply(qps,suptype) and step <= SupCrv_MaxStep, (CE_Pbase(tcapexp,suptype,qps,step)*CE_QSupplyStep(tcapexp,suptype,qps,step) +
						       0.5* sqr(CE_QSupplyStep(tcapexp,suptype,qps,step)) * (CE_Pbase(tcapexp,suptype,qps,step+1)-CE_Pbase(tcapexp,suptype,qps,step))/ (CE_Qbase(tcapexp,suptype,qps,step+1)-
						       CE_Qbase(tcapexp,suptype,qps,step))))
						- sum(qps, CE_SlackVar_Value* CE_SLackVar(tcapexp,qps))
						!Area under the Pipeline Tariff curve
						-sum((h,h1,step)| CE_Capacity(tcapexp,h,h1) and step <= CE_PTCrv_MaxStep, CE_PipelineTariff(tcapexp,h,h1,step) * CE_QTariffCurve(tcapexp,h,h1,step) +
						     0.5 * sqr( CE_QTariffCurve(tcapexp,h,h1,step) ) *
						     (CE_PipelineTariff(tcapexp,h,h1,step+1) - CE_PipelineTariff(tcapexp,h,h1,step) )/ (CE_PipeTariffCurveQty(tcapexp,h,h1,step+1) - CE_PipeTariffCurveQty(tcapexp,h,h1,step) ) )
						
						 !Fixed  Fees
						 - sum((h,h1) | CE_Capacity(tcapexp,h,h1), CE_Fixed_Arc_Fee(tcapexp,h,h1) * CE_FlowHubToHub(tcapexp,h,h1))
						
						  !Gathering Charges
						 - sum((qps,h) | map_SupplyArcs(qps, h), CE_GatheringCharge(tcapexp,qps) * CE_FlowSupplyToHub(tcapexp,qps,h))
						
						 !Storage Fees
						 - sum((storage,h) | map_StorageArcs(storage,h), CE_StorageFee(tcapexp,storage,h) * CE_FlowStorageToHub(tcapexp,storage,h))
						
						 !Area under the LNG Export Curve
						+ sum((lngexp_qp,step) | step <= LNGExpCrv_MaxStep, CE_LNGExportPrc(tcapexp,lngexp_qp,step) * CE_QLNGexp(tcapexp,lngexp_qp,step) +
						       0.5* sqr(CE_QLNGexp(tcapexp,lngexp_qp,step)) * (CE_LNGExportPrc(tcapexp,lngexp_qp,step+1)-CE_LNGExportPrc(tcapexp,lngexp_qp,step)) / $ (CE_LNGExportQty(tcapexp,lngexp_qp,step+1)-CE_LNGExportQty(tcapexp,lngexp_qp,step))) )
					}
					Comment: "consumer plus producer surplus minus variable transport costs";
				}
				Variable CE_OBJnew {
					Text: "Objective Function";
					Range: free;
					Definition: {
						sum(tcapexp,
						!Area under the Supply curve
						 - sum((suptype,qps,step) | map_Supply(qps,suptype) and step <= SupCrv_MaxStep, (CE_Pbase(tcapexp,suptype,qps,step)*CE_QSupplyStep(tcapexp,suptype,qps,step) +
						       0.5* sqr(CE_QSupplyStep(tcapexp,suptype,qps,step)) * (CE_Pbase(tcapexp,suptype,qps,step+1)-CE_Pbase(tcapexp,suptype,qps,step))/ (CE_Qbase(tcapexp,suptype,qps,step+1)-
						       CE_Qbase(tcapexp,suptype,qps,step))))
						- sum(qps, 10^12* CE_SLackVar(tcapexp,qps))
						
						! Pipeline Tariff curve
						-sum((h,h1)| CE_Capacity(tcapexp,h,h1), CE_PipelineTariff(tcapexp,h,h1,FirstStep) * sum(step | step<=CE_PTCrv_MaxStep, CE_QTariffCurve(tcapexp,h,h1,step)) +
						     sum(step | step <= CE_PTCrv_MaxStep-1, (CE_PipelineTariff(tcapexp,h,h1,step+1)-CE_PipelineTariff(tcapexp,h,h1,FirstStep) )* CE_QTariffCurve(tcapexp,h,h1,step+1)) +
						     sum(step | step <= CE_PTCrv_MaxStep,  CE_QTariffCurve(tcapexp,h,h1,step) * sum(x_step | x_step<=step, CE_QTariffCurve(tcapexp,h,h1,x_step)) *
						     (CE_PipelineTariff(tcapexp,h,h1,step+1) - CE_PipelineTariff(tcapexp,h,h1,step) )/ (CE_PipeTariffCurveQty(tcapexp,h,h1,step+1) - CE_PipeTariffCurveQty(tcapexp,h,h1,step) ) ))
						
						! Pipeline Tariff curve
						!-sum((h,h1)| map_HubArcs(h,h1), (sum(step | step<=CE_PTCrv_MaxStep, CE_QTariffCurve(tcapexp,h,h1,step)) * 
						!	(sum(step | step<=CE_PTCrv_MaxStep, (CE_QTariffCurve(tcapexp,h,h1,step) *
						!     ((CE_PipelineTariff(tcapexp,h,h1,step+1) - CE_PipelineTariff(tcapexp,h,h1,step))/(CE_PipeTariffCurveQty(tcapexp,h,h1,step+1) - CE_PipeTariffCurveQty(tcapexp,h,h1,step))))
						!     -CE_PipelineTariff(tcapexp,h,h1,step))+ CE_PipelineTariff(tcapexp,h,h1,first(step)))))
						
						
						 !Fixed  Fees
						 - sum((h,h1) | CE_Capacity(tcapexp,h,h1), CE_Fixed_Arc_Fee(tcapexp,h,h1) * CE_FlowHubToHub(tcapexp,h,h1))
						
						  !Gathering Charges
						 - sum((qps,h) | map_SupplyArcs(qps, h), CE_GatheringCharge(tcapexp,qps) * CE_FlowSupplyToHub(tcapexp,qps,h))
						
						 !Storage Fees
						 - sum((storage,h) | map_StorageArcs(storage,h), CE_StorageFee(tcapexp,storage,h) * CE_FlowStorageToHub(tcapexp,storage,h))
						
						 !Area under the LNG Export Curve
						+ sum((lngexp_qp,step) | step <= LNGExpCrv_MaxStep, CE_LNGExportPrc(tcapexp,lngexp_qp,step) * CE_QLNGexp(tcapexp,lngexp_qp,step) +
						       0.5* sqr(CE_QLNGexp(tcapexp,lngexp_qp,step)) * (CE_LNGExportPrc(tcapexp,lngexp_qp,step+1)-CE_LNGExportPrc(tcapexp,lngexp_qp,step)) / $ (CE_LNGExportQty(tcapexp,lngexp_qp,step+1)-CE_LNGExportQty(tcapexp,lngexp_qp,step))) )
					}
					Comment: "consumer plus producer surplus minus variable transport costs";
				}
				Variable CE_OBJ_ALL {
					Text: "Objective Function";
					Range: free;
					Definition: {
						sum(tcapexp,
						!Area under the Supply curve
						 - sum((suptype,qps,step) | map_Supply(qps,suptype) and step <= SupCrv_MaxStep, (CE_Pbase(tcapexp,suptype,qps,step)*CE_QSupplyStep(tcapexp,suptype,qps,step) +
						       0.5* sqr(CE_QSupplyStep(tcapexp,suptype,qps,step)) * (CE_Pbase(tcapexp,suptype,qps,step+1)-CE_Pbase(tcapexp,suptype,qps,step))/ (CE_Qbase(tcapexp,suptype,qps,step+1)-
						       CE_Qbase(tcapexp,suptype,qps,step))))
						- sum(qps, 10^12* CE_SLackVar(tcapexp,qps))
						! Pipeline Tariff curve
						-sum((qph,qph1,step)| CE_Capacity(tcapexp,qph,qph1) and step <= CE_PTCrv_MaxStep, 
						(CE_Slope_TariffCurve(tcapexp, qph, qph1, step)* CE_QTariffCurve(tcapexp,qph,qph1,step)+ CE_PipelineTariff(tcapexp,qph,qph1,step))*CE_QTariffCurve(tcapexp,qph,qph1,step)*0.5+
						        (0.5*CE_Slope_TariffCurve(tcapexp, qph, qph1, step)* CE_QTariffCurve(tcapexp,qph,qph1,step) * CE_PipeTariffCurveQty(tcapexp,qph,qph1,step)))
						
						
						 !Fixed  Fees
						 - sum((qph,qph1) | CE_Capacity(tcapexp,qph,qph1), CE_Fixed_Arc_Fee(tcapexp,qph,qph1) * CE_FlowHubToHub(tcapexp,qph,qph1))
						
						  !Gathering Charges
						 - sum((qps,qph) | map_SupplyArcs(qps, qph), CE_GatheringCharge(tcapexp,qps) * CE_FlowSupplyToHub(tcapexp,qps,qph))
						
						 !Storage Fees
						 - sum((qpstorage,qph) | map_StorageArcs(qpstorage,qph), CE_StorageFee(tcapexp,qpstorage,qph) * CE_FlowStorageToHub(tcapexp,qpstorage,qph))
						
						 !Area under the LNG Export Curve
						+ sum((lngexp_qp,step) | step <= LNGExpCrv_MaxStep, CE_LNGExportPrc(tcapexp,lngexp_qp,step) * CE_QLNGexp(tcapexp,lngexp_qp,step) +
						       0.5* sqr(CE_QLNGexp(tcapexp,lngexp_qp,step)) * (CE_LNGExportPrc(tcapexp,lngexp_qp,step+1)-CE_LNGExportPrc(tcapexp,lngexp_qp,step)) / $ (CE_LNGExportQty(tcapexp,lngexp_qp,step+1)-CE_LNGExportQty(tcapexp,lngexp_qp,step))) )
					}
					Comment: "consumer plus producer surplus minus variable transport costs";
				}
				Variable CE_SLackVar {
					IndexDomain: {
						(tcapexp,qps) !| sum(suptype, CE_Supply(tcapexp,suptype,s))
					}
					Range: nonnegative;
					Comment: "Artificial Slack Varialble to add extra supply to avoid infeasibility";
				}
				Constraint CE_SupplyMassBalance {
					IndexDomain: (tcapexp,qps);
					Property: ShadowPrice;
					Definition: {
						!sum((step,suptype) | map_Supply(s,suptype), (QSupplyStep(tmon,suptype,s,step)+ QbaseMin(tmon,suptype,s))+ SLackVar(tmon,s) = sum(h | map_SupplyArcs(s,h), FlowSupplyToHub(tmon,s,h) )
						sum(suptype | map_Supply(qps,suptype), CE_QProduction(tcapexp,suptype,qps))+ CE_SLackVar(tcapexp,qps) = sum(qph | map_SupplyArcs(qps,qph), CE_FlowSupplyToHub(tcapexp,qps,qph) )
						!sum(suptype | map_Supply(qps,suptype), CE_QProduction(tcapexp,suptype,qps))+ CE_SLackVar(tcapexp,qps)+ CE_Discrepancy_Supply(tcapexp, qps) = sum(h | map_SupplyArcs(qps,h), CE_FlowSupplyToHub(tcapexp,qps,h) )
					}
				}
				Constraint CE_SupplyAccounting {
					IndexDomain: (tcapexp,suptype,qps);
					Property: ShadowPrice;
					Definition: CE_QProduction(tcapexp,suptype,qps) = Sum(step | step <= SupCrv_MaxStep, CE_QSupplyStep(tcapexp,suptype,qps,step))+ CE_QbaseMin(tcapexp,suptype,qps);
					Comment: "Sums up production over all the steps of supply curve";
				}
				Constraint CE_DemandMassBalance {
					IndexDomain: (tcapexp,qpd);
					Definition: {
						sum(qph | map_DemandArcs(qph,qpd), CE_FlowHubToDemand(tcapexp,qph,qpd)  ) = CE_Consumption(tcapexp,qpd) + CE_DistributionLoss(tcapexp,qpd) + CE_StorageLoss(tcapexp,qpd) +
						                                                                                            CE_PlantFuel(tcapexp,qpd) - CE_Discrepancy(tcapexp,qpd) !CE_Discrepancy_Demand(tcapexp,d)
					}
				}
				Constraint CE_HubBalance {
					IndexDomain: (tcapexp,qph) |qph in (Hubs_-BorderCrossings_);
					Property: ShadowPrice;
					Definition: {
						sum(qpstorage | map_StorageArcs(qpstorage,qph), CE_FlowStorageToHub(tcapexp,qpstorage,qph)) +
						sum(s | map_SupplyArcs(s,qph), CE_FlowSupplyToHub(tcapexp,s,qph)) +
						sum(qph1 | CE_Capacity(tcapexp,qph1, qph), CE_FlowHubToHub(tcapexp,qph1,qph) *(1-PipeFuelLossFactorOUT(qph1, qph)) *(1-PipeFuelLossFactorIN(qph1, qph))) =
						sum(qph2 | CE_Capacity(tcapexp, qph, qph2), CE_FlowHubToHub(tcapexp,qph,qph2) ) + sum(qpd | map_DemandArcs(qph,qpd), CE_FlowHubToDemand(tcapexp,qph,qpd) )
						+ sum(lngexp_qp | map_LNGExpArcs(qph,lngexp_qp), CE_FlowHubToLNGExport(tcapexp,qph,lngexp_qp) ) +
						sum(qpstorage | map_StorageArcs(qpstorage,qph), CE_FlowHubToStorage(tcapexp,qph,qpstorage))
					}
				}
				Constraint CE_HubBalance_BXtoUS {
					IndexDomain: (tcapexp,BX);
					Property: ShadowPrice;
					Definition: {
						sum(r_int | CE_Capacity(tcapexp,r_int, BX) and map_hubs_borderXings(r_int,bx), CE_FlowHubToHub(tcapexp,r_int,BX) *
						       (1-PipeFuelLossFactorOUT(r_int, BX)) *(1-PipeFuelLossFactorIN(r_int, BX))) =
						sum(l48 | CE_Capacity(tcapexp, BX, l48) and map_hubs_borderXings(l48,BX), CE_FlowHubToHub(tcapexp,BX,l48) )
					}
				}
				Constraint CE_HubBalance_UStoBX {
					IndexDomain: (tcapexp,BX);
					Property: ShadowPrice;
					Definition: {
						sum(l48 | CE_Capacity(tcapexp,l48, BX) and map_hubs_borderXings(l48,BX), CE_FlowHubToHub(tcapexp,l48,BX) *(1-PipeFuelLossFactorOUT(l48, BX)) *(1-PipeFuelLossFactorIN(l48, BX))) =
						sum(r_int | CE_Capacity(tcapexp, BX, r_int) and map_hubs_borderXings(r_int,bx), CE_FlowHubToHub(tcapexp,BX,r_int) )
					}
				}
				Constraint CE_StorageWthBalance {
					IndexDomain: (tcapexp,qpstorage);
					Definition: sum(qph | map_StorageArcs(qpstorage,qph), CE_FlowStorageToHub(tcapexp,qpstorage,qph) )= CE_Storage_Withdrawals(tcapexp,qpstorage);
				}
				Constraint CE_StorageInjBalance {
					IndexDomain: (tcapexp,qpstorage);
					Definition: sum(qph | map_StorageArcs(qpstorage,qph), CE_FlowHubToStorage(tcapexp,qph,qpstorage))= CE_Storage_Injections(tcapexp,qpstorage);
				}
				Constraint CE_LNGExportBalance {
					IndexDomain: (tcapexp,lngexp_qp)| CE_LNGExportCapacity(tcapexp,lngexp_qp);
					Definition: Sum(step |step <= LNGExpCrv_MaxStep , CE_QLNGexp(tcapexp,lngexp_qp,step))= sum(qph | map_LNGExpArcs(qph,lngexp_qp), CE_FlowHubToLNGExport(tcapexp,qph,lngexp_qp) );
				}
				Constraint CE_TariffCurveQtyBalance {
					IndexDomain: (tcapexp,qph,qph1)  | CE_Capacity(tcapexp, qph, qph1);
					Definition: Sum(step | step <= CE_PTCrv_MaxStep , CE_QTariffCurve(tcapexp,qph,qph1,step)) = CE_FlowHubToHub(tcapexp,qph,qph1);
				}
				Constraint CE_TariffCurveQtyTotal {
					IndexDomain: (tcapexp,qph,qph1,step)| CE_Capacity(tcapexp, qph, qph1) and step <= CE_PTCrv_MaxStep;
					Property: ShadowPrice;
					Definition: CE_PipeTariffCurveQty( tcapexp,qph,qph1,step) <= CE_QTariffCurveTotal(tcapexp, qph, qph1, step)<= CE_PipeTariffCurveQty( tcapexp,qph,qph1,step+1);
				}
				MathematicalProgram CapacityExpansionQP {
					Objective: CE_OBJ_ALL;
					Direction: maximize;
					Constraints: CE_Constraints;
					Variables: CE_Variables;
					Type: QP;
				}
			}
		}
		Procedure Capacity_InitializeData {
			Body: {
				!Convert capacity from mmcf/day to bcf/month
				Capacity(datamon,h, h1) := $ HistoricalCapacity(h, h1, MonthToYear(datamon)) * NumberOfDaysInMonth(datamon) / 1000;
				
				Capacity( (mon,h, h1) | mon >LastHistoricalMonth and not Capacity(mon,h,h1) ) := Capacity(mon-12,h,h1);
				
				!Capacity( (mon,h, h1) | mon >LastHistoricalMonth ) :=
				!         if Capacity(mon,h,h1) then Capacity(mon,h,h1)
				!         else Capacity(mon-12,h,h1)
				!         endif;
				!for ((h,h1)|PlannedCapacity(h, h1, year)) do
				!	PlannedCapacityAdditions(mon,h,h1)
				
				!Capacity(mon,h, h1) :=$ PlannedCapacity(h, h1, MonthToYear(mon)) * NumberOfDaysInMonth(mon) / 1000;	!Capacity currently under construction
				!Define planned capacity additions
				!Make capcity additions come on in November of first year in service
				!PlannedCapacityAdditions(mon+10,h,h1) :=$  PlannedCapacity(h, h1, MonthToYear(mon)) * NumberOfDaysInMonth(mon) / 1000;	!Capacity currently under construction/planned
				PlannedCapacityAdditions((mon,h,h1) | TimeslotCharacteristic(mon,'month')>=11) :=$  PlannedCapacity(h, h1, MonthToYear(mon)) * NumberOfDaysInMonth(mon) / 1000;	!Capacity currently under construction/planned 
				
				!PlannedCapacityAdditions( (mon,h, h1)| mon >LastHistoricalMonth and (Capacity(mon,h, h1) - Capacity(mon-12,h,h1)) ) := max(0,Capacity(mon,h, h1) - Capacity(mon-12,h,h1));
				PipeCapacity((datamon,h, h1 ) | LastDataYearFlg_Capacity(MonthToYear(datamon))) := Capacity(datamon,h, h1)+ PlannedCapacityAdditions(datamon, h, h1) ;
				!CapacityAnnual(datayear, h, h1) := HistoricalCapacity(h, h1, datayear) * NumberOfDaysInYear(datayear) / 1000;
				CapacityAnnual((datayear, h, h1)|LastDataYearFlg_Capacity(datayear)):= sum(datamon | map_month_year(datamon,datayear),PipeCapacity(datamon,h, h1 ));
				!Determine daily capacity at the end of year (December) to use as a lag term when needed
				CapacityDaily_EOY((datayear, h, h1)|LastDataYearFlg_Capacity(datayear)):= sum(datamon | TimeslotCharacteristic(datamon,'month')=12 and map_month_year(datamon,datayear), 
				                  PipeCapacity(datamon,h, h1 )*1000/ NumberOfDaysInMonth(datamon));
				!Capacity((histmon,mx, mx1) | CapacityAnnual(FirstModelYear, mx, mx1) and not CapacityAnnual(FirstModelYear-1, mx, mx1)):= HistoricalCapacity(mx, mx1, FirstModelYear) * NumberOfDaysInMonth(histmon) / 1000;
				!CapacityAnnual((histyr,mx, mx1) | CapacityAnnual(FirstModelYear, mx, mx1) and not CapacityAnnual(FirstModelYear-1, mx, mx1)) := CapacityAnnual(FirstModelYear, mx, mx1);
				!map_HubArcs((h, h1) | CapacityAnnual(ModelYear, h, h1)) := 1;
				
				!Define capacity expansion weather factors for all months
				WeatherFactor1((mn, sec, l48) | map_capexp_season(mn, 'peak')) :=  WeatherFactor1(element(MonthinYear_,1), sec, l48);
				WeatherFactor1((mn, sec, l48) | map_capexp_season(mn, 'offpeak')) :=  WeatherFactor1(element(MonthinYear_,8), sec, l48);
				WeatherFactor2((mn, sec) | map_capexp_season(mn, 'peak')) :=  WeatherFactor2(element(MonthinYear_,1), sec);
				WeatherFactor2((mn, sec) | map_capexp_season(mn, 'offpeak')) :=  WeatherFactor2(element(MonthinYear_,8), sec);
			}
		}
		Procedure DefineCapacities {
			Body: {
				if LastDataYearFlg_Capacity(ModelYear) then
				!if ModelYear = FirstModelYear then
				!     CurrentPipeCapacity( (mon,h, h1) |YearToMonth(ModelYear)<=mon<=YearToMonth(ModelYear)+11) := Capacity(mon,h,h1);
				!     CurrentPipeCapacity(modelyrmn,h, h1)  :=  Capacity(modelyrmn,h,h1)+ PlannedCapacityAdditions(modelyrmn,h, h1 )+ PlannedCapacityAdditions(modelyrmn-12,h, h1 );
				     CurrentPipeCapacity(modelyrmn,h, h1)  := PipeCapacity(modelyrmn,h, h1);
				else
				!Last year's capacity plus planned capacity additions
				!     	CurrentPipeCapacity( (mon,h, h1) |YearToMonth(ModelYear)<=mon<=YearToMonth(ModelYear)+11) :=
				!        	PipeCapacity(mon-12,h,h1) + PlannedCapacityAdditions(mon,h, h1 );
				!     	CurrentPipeCapacity((lagyrmn,h, h1) | lagyrmn>= YearToMonth(ModelYear)) :=
				!        	PipeCapacity(lagyrmn-12,h,h1) + PlannedCapacityAdditions(lagyrmn,h, h1 );
				     	CurrentPipeCapacity(modelyrmn,h, h1) := CapacityDaily_EOY(ModelYear-1, h, h1)* NumberOfDaysInMonth(modelyrmn) / 1000 +
				        	 PlannedCapacityAdditions(modelyrmn,h, h1 );
				
				endif;
				!Call capacity expansion submodule to determine capacity additions
				if ModelYear >= NoBuildYear then
				!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				!Temp check for tariff curve
				!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				!PipeCapacity(modelyrmn,h, h1 ) := CurrentPipeCapacity(modelyrmn,h, h1 );  !
				!CapacityAnnual(ModelYear, h, h1) := sum(modelyrmn, PipeCapacity(modelyrmn,h, h1));
				!map_HubArcs((h, h1) | CapacityAnnual(ModelYear, h, h1)) := 1;
				!NoVarTariffCurveFlg((MonthInPeriod(tmon),h,h1,step) | map_HubArcs(h, h1) and step <= PTCrv_MaxStep and
				!                                            (PipeTariffCurveQty(tmon,h,h1,step+1) - PipeTariffCurveQty(tmon,h,h1,step) )<=0):=1;
				!if sum((modelyrmn, h, h1, step), NoVarTariffCurveFlg(modelyrmn, h, h1, step)) then
				!   write NoVarTariffCurveFlg((modelyrmn, h, h1, step) | NoVarTariffCurveFlg(modelyrmn, h, h1, step)) to file "NGATTENTION.txt" in merge mode;
				!   RAISE WARNING " Variable Tariff Curve data are missing in "+ModelYear+"; See NGATTENTION.txt for details." CODE 'NoVarTarCurve';
				!endif;
				!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				CapacityExpansionRun; !Run Capacity Expansion QP for two months
				!CapacityExpansion_Run; !Run Capacity Expansion QP for all months
				!Add capacity
				CurrentPipeCapacity(modelyrmn,h, h1) += CapacityAdditionsMonthly(modelyrmn,h, h1) ;
				endif;
				
				PipeCapacity(modelyrmn,h, h1 ) := CurrentPipeCapacity(modelyrmn,h, h1 );  !
				CapacityAnnual(ModelYear, h, h1) := sum(modelyrmn, PipeCapacity(modelyrmn,h, h1));
				CapacityAdditionAnnual(ModelYear, h, h1) := CapacityAnnual(ModelYear, h, h1) -CapacityAnnual(ModelYear-1, h, h1);
				CapacityAdditionUnplanned_Annual(ModelYear, h, h1) := sum(modelyrmn, CapacityAdditionsMonthly(modelyrmn,h, h1));
				!Determine daily capacity at the end of year (December) to use as a lag term 
				CapacityDaily_EOY(ModelYear, h, h1):= PipeCapacity(YearToMonth(ModelYear)+11,h, h1 )*1000/ NumberOfDaysInMonth(YearToMonth(ModelYear)+11);
				map_HubArcs((h, h1) | CapacityAnnual(ModelYear, h, h1)) := 1;
			}
		}
		Procedure DefineConsumptionForCapExp {
			Body: {
				!read from file "data\\weather_factor.txt" ;
				
				!Increase US consumpiton
				ConsumptionForCapExp(modelyrmn, sec, l48) := sum(mn | map_Month_MonthinYear(modelyrmn,mn), Cons_State_Mon(modelyrmn, sec, l48) * WeatherFactor1(mn, sec, l48) * WeatherFactor2(mn, sec) );
			}
		}
		Procedure CurveDefinitionsForCapExp {
			Body: {
				!Define supply curve steps
				!CE_Qbase(tcapexp,suptype,qps,step) := CE_Supply(tcapexp,suptype,qps) *  SupCrvParameter(suptype,step);
				!CE_Pbase(tcapexp,suptype,qps,step) := CE_SupplyPrice(tcapexp,suptype,qps) * SupCrvPriceElasticity(suptype,step);
				CE_Qbase(tcapexp,suptype,qps,step) := CE_Supply(tcapexp,suptype,qps) *  SupCrv_Param(Element(SupCrv_Option_,map_SupCrvOption(qps, suptype)), step);
				CE_Pbase(tcapexp,suptype,qps,step) := CE_SupplyPrice(tcapexp,suptype,qps) * SupElas_Param(Element(SupCrv_Option_,map_SupCrvOption(qps, suptype)), step);
				
				!Define minimum production
				CE_QbaseMin(tcapexp,suptype,s) := CE_Qbase(tcapexp,suptype,s,SupCrv_Step1);
				
				! Set upper bound for the supply curve steps
				CE_Q_UpperBound( (tcapexp,suptype,s,step) | step <= SupCrv_MaxStep) := ( CE_Qbase(tcapexp,suptype,s,step+1) - CE_Qbase(tcapexp,suptype,s,step) ) ;
				! Set lower bound for the supply curve steps for variable supply
				CE_Q_LowerBound( (tcapexp, varsup, s, step) | step <= SupCrv_MaxStep) := 0;
				! Set lower bound for the supply curve steps for fixed supply
				CE_Q_LowerBound( (tcapexp, fixsup, s, step) | step <= SupCrv_MaxStep) := CE_Q_UpperBound(tcapexp, fixsup, s, step);
				
				!Define Pipeline Tariff Curve steps
				CE_PipeTariffCurveQty(tcapexp,h,h1,step) := CE_Capacity(tcapexp,h,h1) * Parameter_CapacityUtilization(h,h1,step);
				CE_PipeTariffCurveQty((tcapexp,h,h1,CE_PTCrv_MaxStep+1) | CE_Capacity(tcapexp,h,h1)<30):= CE_Capacity(tcapexp,h,h1)*2;
				CE_PipeTariffCurveQty((tcapexp,h,h1,CE_PTCrv_MaxStep+1) | 0<CE_Capacity(tcapexp,h,h1)<50 and CE_Capacity(tcapexp,h1,h)>CE_Capacity(tcapexp,h,h1)  ):= CE_Capacity(tcapexp,h1,h);
				
				CE_PipelineTariff(tcapexp,h,h1,step) :=  Parameter_TariffCurvePrice(h,h1,step);
				
				CE_PipeTarCrvQty_UpBound( (tcapexp,h,h1,step) | step <= CE_PTCrv_MaxStep) := CE_PipeTariffCurveQty( tcapexp,h,h1,step+1) - CE_PipeTariffCurveQty(tcapexp,h,h1,step);
				
				CE_CapacityMaxBuild(tcapexp, h, h1) := CE_PipeTariffCurveQty(CapExpFirstPeriodInPlanningInterval, h, h1, CE_PTCrv_MaxStep+1);
				
				!Compute the slopes of the tariff curve segments
				CE_Slope_TariffCurve( (tcapexp,h,h1,step) | CE_Capacity(tcapexp, h, h1)and step <= CE_PTCrv_MaxStep) := 
				    (CE_PipelineTariff(tcapexp,h,h1,step+1) - CE_PipelineTariff(tcapexp,h,h1,step) )/ (CE_PipeTariffCurveQty(tcapexp,h,h1,step+1) - CE_PipeTariffCurveQty(tcapexp,h,h1,step) );
				
				!define LNG Export Curve steps
				
				if (LNG_FixedExports_Switch = 0) then
					CE_LNGExportQty(tcapexp,lngexp_qp,LNG_FirstStep) := 0;
				!	CE_LNGExportQty(tcapexp,lngexp,LNG_SecondStep) :=CE_LNGExportCapacity(tcapexp,lngexp)*0.98;
					CE_LNGExportQty(tcapexp,lngexp_qp,LNG_LastStep) :=CE_LNGExportCapacity(tcapexp,lngexp_qp);
					CE_LNGExportPrc(tcapexp,lngexp_qp,LNG_FirstStep) :=  LNGMaxPrice(CapExpYearInPeriod(tcapexp),lngexp_qp);
				!	CE_LNGExportPrc(tcapexp,lngexp,LNG_SecondStep) :=  LNGMinPrice(CapExpYearInPeriod(tcapexp),lngexp)*1.1;
					CE_LNGExportPrc(tcapexp,lngexp_qp,LNG_LastStep) := LNGMinPrice(CapExpYearInPeriod(tcapexp),lngexp_qp);
					!CN_W is always fixed
					!CE_LNGExportQty(tcapexp,lngexp_qp,step) := CE_LNGExportCapacity(tcapexp,lngexp_qp) * Parameter_LNGExpQty(step);
					!CE_LNGExportPrc(tcapexp,lngexp_qp,step) := CE_LNGExportPrice(tcapexp,lngexp_qp) * Parameter_LNGExpPrc(step);
				else
					CE_LNGExportQty(tcapexp,lngexp_qp,step) := CE_LNGExportCapacity(tcapexp,lngexp_qp) * Parameter_LNGExpQty(step);
					CE_LNGExportPrc(tcapexp,lngexp_qp,step) := CE_LNGExportPrice(tcapexp,lngexp_qp) * Parameter_LNGExpPrc(step);
				endif;
				
				CE_LNGExport_UpBound( (tcapexp,lngexp_qp,step) | step <= LNGExpCrv_MaxStep ) := CE_LNGExportQty(tcapexp,lngexp_qp,step+1) - CE_LNGExportQty(tcapexp,lngexp_qp,step);
				CE_LNGExport_LoBound( (tcapexp,lngexp_qp,step) | step <= LNGExpCrv_MaxStep ) :=
				            if LNG_FixedExports_Switch then CE_LNGExport_UpBound(tcapexp,lngexp_qp,step)
				            else 0
				            endif;
				!CE_LNGExport_LoBound( (tcapexp,CanadaWest,step) | step <= LNGExpCrv_MaxStep ) := CE_LNGExport_UpBound(tcapexp,CanadaWest,step);
			}
		}
		Procedure TransferDataIntoQPparameters_ForCapExp {
			Body: {
				LinkHorizonToCalendarForCapExp; !Create timetable
				!Define maximum step on the tariff curve
				CE_PTCrv_MaxStep := Element(Supply_Curve_Step_,4);
				
				!Transfer data into QP Parameters
				
				!TotalConsumption( (mon,l48)  ) :=  sum(sec, Cons_State_Mon(mon, sec, l48)); !End Use Consumption Subroutine **moved to End Use Consumption Run... delete once verified it works
				CE_Consumption(tcapexp,qpd) := 	TotalConsumption(CapExpMonthInPeriod(tcapexp), qpd);
				!Increased consumption for capasity expansion submodel
				CE_Consumption(tcapexp,l48) := 	sum(sec, ConsumptionForCapExp(CapExpMonthInPeriod(tcapexp), sec, l48));
				!QP_Consumption(tmon,l48) := 	sum(sec, Cons_State_Mon(MonthInPeriod(tmon), sec, l48));	!End Use Consumption Subroutine
				
				! Add LNG exports to Mexico region for consumption
				CE_Consumption(tcapexp,Mexico_NE) += IEO_LNGExport_Monthly(CapExpMonthInPeriod(tcapexp), Mexico_NE);
				CE_Consumption(tcapexp,Mexico_SS) += IEO_LNGExport_Monthly(CapExpMonthInPeriod(tcapexp), Mexico_SS);
				
				CE_Discrepancy(tcapexp,qpd) := BalanceItem(CapExpMonthInPeriod(tcapexp), qpd);
				!CE_Discrepancy_Demand((tcapexp,d) | BalanceItem(CapExpMonthInPeriod(tcapexp), d)<=0) := BalanceItem(CapExpMonthInPeriod(tcapexp), d);
				!CE_Discrepancy_Supply((tcapexp,s) | BalanceItem(CapExpMonthInPeriod(tcapexp), s)>=0) := BalanceItem(CapExpMonthInPeriod(tcapexp), s);
				CE_Storage_Withdrawals(tcapexp,qpstorage) := StorageWithdrawals(CapExpMonthInPeriod(tcapexp), qpstorage);
				CE_Storage_Injections(tcapexp,qpstorage) := StorageInjections(CapExpMonthInPeriod(tcapexp), qpstorage);
				
				CE_Supply(tcapexp,suptype,qps) := Supply(CapExpMonthInPeriod(tcapexp), suptype, qps) ;
				!Subtract lease fuel
				CE_Supply(tcapexp, naadgas, qps) *= (1 - LeaseFuelFactor(qps));
				CE_SupplyPrice(tcapexp,suptype,qps) := WellhdPrice(CapExpYearInPeriod(tcapexp)-1, suptype, qps);
				 if LastDataYearFlg_WHPrice(ModelYear) then CE_SupplyPrice(tcapexp,suptype,qps) := WellhdPrice(CapExpYearInPeriod(tcapexp), suptype, qps); endif;
				CE_GatheringCharge(tcapexp,s) := GatheringCharge(s);
				CE_Capacity(tcapexp,qph,qph1) := CurrentPipeCapacity(CapExpMonthInPeriod(tcapexp), qph, qph1);
				Parameter_CapacityUtilization(qph,qph1,step) := VariableTariffCurve(qph, qph1, Qtype, step);
				Parameter_TariffCurvePrice(qph,qph1,step) := VariableTariffCurve(qph, qph1, Ptype, step);
				!QP_PipelineTariff(tmon,h,h1) := 1;
				!CE_LNGExportCapacity(tcapexp,lngexp) := LNGExports(CapExpMonthInPeriod(tcapexp), lngexp);
				CE_LNGExportCapacity(tcapexp,lngexp_qp) := LNGExports(CapExpMonthInPeriod(tcapexp), lngexp_qp)*(1+ Pct_Liquifaction_Fuel);
				CE_LNGExportPrice(tcapexp,lngexp_qp) := USLNGExportPrice(CapExpYearInPeriod(tcapexp),lngexp_qp);
				
				! storage losses
				CE_StorageLoss(tcapexp,qpstorage) := StorageLosses(CapExpMonthInPeriod(tcapexp), qpstorage);
				! distribution losses
				!**********Add Canada and Mexico later **************
				CE_DistributionLoss(tcapexp,l48) := DistributionLosses(CapExpMonthInPeriod(tcapexp), l48) ;
				!intrastate pipefuel loss
				CE_IntrastatePipeFuelLoss(tcapexp,l48) := IntrastatePipeFuelLosses(CapExpMonthInPeriod(tcapexp), l48) ;
				
				!plant fuel
				CE_PlantFuel(tcapexp,l48) := PlantFuel(CapExpMonthInPeriod(tcapexp), l48) ;
				!CE_PlantFuel(tcapexp,mx) := PlantFuel(CapExpMonthInPeriod(tcapexp), mx) ;
				
				!this can be done once here
				!Assign supply curve parameters for fixed and variable supply
				Parameter_SupCrv(fixsup,step, n)  := Parameter_SupCrv(Supply_AD,step, n);
				Parameter_SupElasticity(fixsup,step, n)  := Parameter_SupElasticity(Supply_AD,step, n);
				Parameter_PrcElasticity(fixsup,step, n)  := Parameter_PrcElasticity(Supply_AD,step, n);
				Parameter_SupCrv(varsup,step, n)  := Parameter_SupCrv(Supply_NA,step, n);
				Parameter_SupElasticity(varsup,step, n)  := Parameter_SupElasticity(Supply_NA,step, n);
				Parameter_PrcElasticity(varsup,step, n)  := Parameter_PrcElasticity(Supply_NA,step, n);
				
				!Handle possible negative demand error (usually occurs when discrepancy > consumption)
				!Set a flag indicating that the demand mass balance constraint RHS <0
				CEFLG_NegativeDemand((tcapexp, qpd) | (CE_Consumption(tcapexp,qpd) + CE_DistributionLoss(tcapexp,qpd) + CE_StorageLoss(tcapexp,qpd) + CE_IntrastatePipeFuelLoss(tcapexp,qpd)+
							CE_PlantFuel(tcapexp,qpd) - CE_Discrepancy(tcapexp,qpd)) < 0) :=1;
				!Replace negative demand with 0
				CE_Consumption((tcapexp,qpd) | CEFLG_NegativeDemand(tcapexp, qpd) ) := 0;
				CE_DistributionLoss((tcapexp,qpd) | CEFLG_NegativeDemand(tcapexp, qpd) ) := 0;
				CE_StorageLoss((tcapexp,qpd) | CEFLG_NegativeDemand(tcapexp, qpd) ) := 0;
				CE_IntrastatePipeFuelLoss((tcapexp,qpd) | CEFLG_NegativeDemand(tcapexp, qpd) ) := 0;
				CE_PlantFuel((tcapexp,qpd) | CEFLG_NegativeDemand(tcapexp, qpd) ) := 0;
				CE_Discrepancy((tcapexp,qpd) | CEFLG_NegativeDemand(tcapexp, qpd) ) := 0;
				if sum((tcapexp,qpd), CEFLG_NegativeDemand(tcapexp, qpd)) then
				   write CEFLG_NegativeDemand((tcapexp, qpd) | CEFLG_NegativeDemand(tcapexp, qpd)) to file "NGATTENTION.txt" in merge mode;
				   RAISE WARNING "RHS of DemandMassBalance constraint is negative in " +ModelYear+"; Resetting RHS to 0. See NGATTENTION.txt for details." CODE 'NegativeRHS';
				endif;
			}
			Comment: "Transfer data for Planning Period into QP parameters";
		}
		Procedure CapacityExpansionRun {
			Body: {
				DefineConsumptionForCapExp; !Define parameters that are used in Capacity Expansion Submodel
				TransferDataIntoQPparameters_ForCapExp; !Transfer from main array to QP array for Capacity Expansion Submodel
				CurveDefinitionsForCapExp;  !Define supply curves, variable pipeline tariff curve, LNG export curves
				solve CapacityExpansionQP;! in merge mode; !Solve the Quadratic Program for Capacity Expansion
				CapExpQPStatusNotOptimal;
				DetermineCapacityAdditionsForCapExp; !Extract Capacity Additions from the QP solution
			}
		}
		Procedure DetermineCapacityAdditionsForCapExp {
			Body: {
				
				CE_QTariffCurve((tcapexp, h, h1, step) | CE_QTariffCurve(tcapexp, h, h1, step)<0.05) := 0;
				!Define Max build allowed
				CapacityAddition(h, h1) := MAX(tcapexp, CE_QTariffCurve(tcapexp,h,h1,CE_PTCrv_MaxStep));
				!CapacityAddition((h, h1) | CapacityAddition(h, h1)<=0.05 ) := 0;
				CapacityAdditionsMonthly(modelyrmn, h, h1) := CapacityAddition(h, h1);
			}
		}
	}
	Section Canada_Subroutine {
		Procedure Canada_Run {
			Body: {
				!use NEB Canada's Energy Future 2016 projected production for placeholder Canadian supply data
				
				!Old variables... may need to assess LNG side of things later....
				!AnnualSupply (ModelYear, Supply_NA, CanadaWest)  := ProjectedProduction(ModelYear,CanadaWest)+ (LNG_ExportCapacity(ModelYear, CanadaWest)*(1+Pct_Liquifaction_Fuel));
				!AnnualSupply (ModelYear, Supply_NAfixed, CanadaEast)  := ProjectedProduction(ModelYear,CanadaEast)+ (LNG_ExportCapacity(ModelYear, CanadaEast)*(1+Pct_Liquifaction_Fuel));
				
				AnnualSupply (ModelYear, Supply_NA, CanadaEast)  := OGSMOUT_CNENAGPRD(first(M2), NEMSmap_MNUMYR(ModelYear));
				AnnualSupply (ModelYear, Supply_NA, CanadaWest)  := OGSMOUT_CNENAGPRD(last(M2), NEMSmap_MNUMYR(ModelYear));
				AnnualSupply (ModelYear, Supply_AD, CanadaEast)  := OGSMOUT_CNADGPRD(first(M2), NEMSmap_MNUMYR(ModelYear));
				AnnualSupply (ModelYear, Supply_AD, CanadaWest)  := OGSMOUT_CNADGPRD(last(M2), NEMSmap_MNUMYR(ModelYear));
				
				if  (AnnualSupply (ModelYear, Supply_NA, CanadaWest) =0) then 
					AnnualSupply (ModelYear, Supply_NA, CanadaWest)  := ProjectedProduction(ModelYear,CanadaWest);
					AnnualSupply (ModelYear, Supply_AD, CanadaEast)  := ProjectedProduction(ModelYear,CanadaEast);
				endif;
				
				
				
				!Use INGM consumption and split into monthly shares
				!Old version; check INGM_CN_Consumption with Cons_CAN_Yr to see differences
				!Cons_CAN_yr(ModelYear,sec,cn) :=INGM_CN_Consumption(ModelYear,sec,cn);
				!Cons_CAN_mon(modelyrmn,sec,cn) := sum(mn|map_MonthinYear_ModelYearMonth(mn,modelyrmn),Cons_CAN_share_MonYr(sec,cn,mn)*Cons_CAN_Yr(ModelYear,sec,cn));
				
				Cons_CN_Yr(ModelYear,sec,cn):= IEO_CN_Consumption(ModelYear,sec)* Cons_share_Canada_cn(sec,cn);
				
				!Calculate oil sands consumption and apply to Canada West industrial demand
				if (OilSands_Switch=1) then
					Canada_OilSands;
				else
					AnnualSupply (ModelYear, Supply_AD, CanadaWest) += OilSandsProduction_Fixed;
				
				endif;
				
				Cons_CN_Mon(modelyrmn,sec,cn) := sum(mn|map_MonthinYear_ModelYearMonth(mn,modelyrmn),Cons_CN_Yr(ModelYear,sec,cn)*Cons_CN_share_MonYr(sec,cn,mn));
				
				
				
				
				!Fill in Main Arrays
				
				!Convert Annual Qty to Monthly using number of days in each month
				Supply(modelyrmn, suptype, cn)  := AnnualSupply(MonthToYear(modelyrmn), suptype, cn) * NumberOfDaysInMonth(modelyrmn)/ NumberOfDaysInYear(MonthToYear(modelyrmn));
				Supply(modelyrmn, suptype, cn)  := AnnualSupply(MonthToYear(modelyrmn), suptype, cn) * NumberOfDaysInMonth(modelyrmn)/ NumberOfDaysInYear(MonthToYear(modelyrmn));
				
				TotalConsumption(modelyrmn,cn) :=  sum(sec, Cons_CN_Mon(modelyrmn, sec, cn));
				AnnualTotalConsumption(ModelYear,cn):=sum(modelyrmn,TotalConsumption(modelyrmn,cn));
				
				!Aggregations for report writing purposes
				TotalConsumptionCN(ModelYear,cn) := AnnualTotalConsumption(ModelYear,cn);
				TotalAnnualConsumptionCN(ModelYear) := sum(cn,TotalConsumptionCN(ModelYear,cn));
			}
		}
		Procedure Canada_InitializeData {
			Body: {
				!Fill in Supply variables
				
				!Fill and calculate Supply from OGSM variables in restart file
				AnnualSupply (histyr, Supply_NA, CanadaEast)  := OGSMOUT_CNENAGPRD(first(M2), NEMSmap_MNUMYR(histyr));
				AnnualSupply (histyr, Supply_NA, CanadaWest)  := OGSMOUT_CNENAGPRD(last(M2), NEMSmap_MNUMYR(histyr));
				AnnualSupply (histyr, Supply_AD, CanadaEast)  := OGSMOUT_CNADGPRD(first(M2), NEMSmap_MNUMYR(histyr));
				AnnualSupply (histyr, Supply_AD, CanadaWest)  := OGSMOUT_CNADGPRD(last(M2), NEMSmap_MNUMYR(histyr));
				!Assign LNG imports from historical data read
				AnnualSupply (histyr, Supply_LNG, cn)  := sum(histmon|map_month_year(histmon,histyr),HistoricalSupply(histmon, Supply_LNG, cn));
				
				Supply(histmon, Supply_LNG, cn):= HistoricalSupply(histmon, Supply_LNG, cn);
				!Straight shares for monthly supply (used in Balancing Item calculation in BalancingItem_Canada)
				Supply(histmon, naadgas, cn) := sum(histyr | map_month_year(histmon,histyr),AnnualSupply (histyr, naadgas, cn)/12); 
				
				
				!Fill in consumption parameters for historical years.
				
				Cons_CN_Mon(mon,sec,cn):=	HistoricalDemand(mon, sec, cn) ;
				Cons_CN_Yr(year,sec,cn):= 	sum(mon|map_month_year(mon,year), Cons_CN_Mon(mon,sec,cn));
				
				
				!Determine last month for which StatsCanada historical data exists and determine LastHistoricalDataYear by testing if LastHistoricalDataMonth is December
				LastHistoricalDataMonth := Last(mon | Exists((sec,cn)|Cons_CN_Mon(mon,sec,cn)));
				if (MonthToYear(LastHistoricalDataMonth)=MonthToYear(LastHistoricalDataMonth-11)) then
					LastHistoricalDataYear := MonthToYear(LastHistoricalDataMonth);
				else
					LastHistoricalDataYear := MonthToYear(LastHistoricalDataMonth)-1;
				endif;
				
				
				Cons_CN_share_MonYr(sec,cn,mn) := 		sum((mon,navgyr_dmd)|map_Month_MonthinYear(mon,mn)and YearToMonth(LastHistoricalDataYear)<=mon<=YearToMonth(LastHistoricalDataYear)+11,
											Cons_CN_Mon(mon-12*(Val(navgyr_dmd)-1),sec,cn))/$ sum(navgyr_dmd ,Cons_CN_Yr(LastHistoricalDataYear-Val(navgyr_dmd)+1,sec,cn));
				
				!Transfer data to Main Array
				TotalConsumption(datamon, cn) := sum(sec, Cons_CN_Mon(datamon, sec, cn)) ;
				TotalSectorConsumptionCN(datayear,sec) := sum(cn, Cons_CN_Yr(datayear, sec, cn)) ;
				
				Cons_share_Canada_cn(sec,cn) := sum(navgyr_dmd, Cons_CN_Yr(LastHistoricalDataYear-Val(navgyr_dmd)+1,sec,cn)/$ TotalSectorConsumptionCN(LastHistoricalDataYear-Val(navgyr_dmd)+1,sec))
											/Card(NumberOfYearsForAverage_Demand_);
				Cons_share_Canada_cn(Sector_Transportation,cn) :=0.5;
				
				!Calculate historical Canada total annual consumption
				TotalConsumptionCN(datayear,cn) := sum(mon|map_month_year(mon,datayear), TotalConsumption(mon,cn));
				TotalAnnualConsumptionCN(datayear) :=sum(cn,TotalConsumptionCN(datayear,cn));
			}
		}
		Procedure Canada_OilSands {
			Body: {
				if (ModelYear = FirstModelYear) then
					WorldOilDemand(histyr,crude) :=	sum( MNCRUD| NEMSmap_MNCRUD_CrudeType(MNCRUD,crude),
									INTOUT_Q_NON_US_DEMAND(MNCRUD,'1','1',NEMSmap_MNXYRS(histyr)) + LFMMOUT_Q_CRUDE_IMPORTS('10',MNCRUD,NEMSmap_MNXYRS(histyr)));
				
					LFMM_Bitumen(histyr,crude) := BitumenFraction(crude) * WorldOilDemand(histyr,crude);
				
					LFMM_TotalBitumen(histyr) := sum(crude,LFMM_Bitumen(histyr,crude));
					for (histyr|LFMM_TotalBitumen(histyr)) do
						OilSandsConsumption(histyr):=  sum(crude, ConsumptionFraction(crude) *IEO_CN_Bitumen(histyr,ReferenceCase) * (LFMM_Bitumen(histyr,crude)/LFMM_TotalBitumen(histyr))); 
						!OilSandsProduction(histyr) :=  sum(crude, ProductionFraction(crude) *IEO_CN_Bitumen(histyr,ReferenceCase) * (LFMM_Bitumen(histyr,crude)/LFMM_TotalBitumen(histyr))); 
					endfor;
				endif;
				
				WorldOilDemand(ModelYear,crude) :=	sum( MNCRUD| NEMSmap_MNCRUD_CrudeType(MNCRUD,crude),
									INTOUT_Q_NON_US_DEMAND(MNCRUD,'1','1',NEMSmap_MNXYRS(ModelYear)) + LFMMOUT_Q_CRUDE_IMPORTS('10',MNCRUD,NEMSmap_MNXYRS(ModelYear)));
				LFMM_Bitumen(ModelYear,crude) := BitumenFraction(crude) * WorldOilDemand(ModelYear,crude);
				
				LFMM_TotalBitumen(ModelYear) := sum(crude,LFMM_Bitumen(ModelYear,crude));
				
				if (WWOP = 1) then
					OilSandsConsumption(ModelYear):=  sum(crude, ConsumptionFraction(crude) *IEO_CN_Bitumen(ModelYear,LowWOPCase) * 
									(LFMM_Bitumen(ModelYear,crude)/LFMM_TotalBitumen(ModelYear)))-OilSandsConsumption(IEO_LastHistoricalYear) ; 
					OilSandsProduction(ModelYear) :=  sum(crude, ProductionFraction(crude) *IEO_CN_Bitumen(ModelYear,LowWOPCase) * 
									(LFMM_Bitumen(ModelYear,crude)/LFMM_TotalBitumen(ModelYear)))-OilSandsProduction(IEO_LastHistoricalYear) ; ; 
				
				elseif (WWOP = 3) then
					OilSandsConsumption(ModelYear):=  sum(crude, ConsumptionFraction(crude) *IEO_CN_Bitumen(ModelYear,HighWOPCase) * 
									(LFMM_Bitumen(ModelYear,crude)/LFMM_TotalBitumen(ModelYear)))-OilSandsConsumption(IEO_LastHistoricalYear) ; ; 
					OilSandsProduction(ModelYear) :=  sum(crude, ProductionFraction(crude) *IEO_CN_Bitumen(ModelYear,HighWOPCase) * 
									(LFMM_Bitumen(ModelYear,crude)/LFMM_TotalBitumen(ModelYear)))-OilSandsProduction(IEO_LastHistoricalYear) ; ; 
				
				else
					OilSandsConsumption(ModelYear):=  sum(crude, ConsumptionFraction(crude) *IEO_CN_Bitumen(ModelYear,ReferenceCase) * 
									(LFMM_Bitumen(ModelYear,crude)/LFMM_TotalBitumen(ModelYear)))-OilSandsConsumption(IEO_LastHistoricalYear) ; ; 
					OilSandsProduction(ModelYear) :=  sum(crude, ProductionFraction(crude) *IEO_CN_Bitumen(ModelYear,ReferenceCase) * 
									(LFMM_Bitumen(ModelYear,crude)/LFMM_TotalBitumen(ModelYear)))-OilSandsProduction(IEO_LastHistoricalYear) ; ; 
				endif;
				
				!OilSandsConsumption(ModelYear):=	sum(crude, ConsumptionFraction(crude) * Bitumen(ModelYear,crude));
				!OilSandsProduction(ModelYear) :=	sum(crude, ProductionFraction(crude)* Bitumen(ModelYear,crude));
				
				Cons_CN_Yr(ModelYear,Sector_Industrial,CanadaWest) += OilSandsConsumption(ModelYear); !- OilSandsProduction(ModelYear);
			}
			Comment: "For data sources and calculations, see Excel file \"AER_consumption_natgas_oilsands\" in  \\\\Fs-f3\\oea\\PNGBA\\_NGMT\\AEO-IEO shared folder";
		}
		DeclarationSection Canada_Consumption_Identifiers {
			Parameter Cons_CN_Mon {
				IndexDomain: (mon,sec,cn);
			}
			Parameter Cons_CN_Yr {
				IndexDomain: (year,sec, cn);
			}
			Parameter INGM_CN_Consumption {
				IndexDomain: (year,sec,cn);
			}
			Parameter Cons_CN_share_MonYr {
				IndexDomain: (sec, cn, mn);
			}
			Parameter Cons_CN_MonYr {
				IndexDomain: (mn,year,sec,cn);
			}
			Parameter TotalConsumptionCN {
				IndexDomain: (year,cn);
			}
			Parameter TotalAnnualConsumptionCN {
				IndexDomain: year;
			}
			Parameter Cons_share_Canada_cn {
				IndexDomain: (sec, cn);
			}
			Parameter Cons_share_Mexico_mx {
				IndexDomain: (sec, mx);
			}
			Parameter TotalSectorConsumptionMX {
				IndexDomain: (year,sec);
			}
			Parameter TotalSectorConsumptionCN {
				IndexDomain: (year,sec);
			}
		}
		DeclarationSection Canada_Oil_Sands_Identifiers {
			Parameter WorldOilDemand {
				IndexDomain: (year, crude);
			}
			Parameter BitumenFraction {
				IndexDomain: crude;
			}
			Parameter ProductionFraction {
				IndexDomain: crude;
			}
			Parameter ConsumptionFraction {
				IndexDomain: crude;
			}
			Parameter LFMM_Bitumen {
				IndexDomain: (year,crude);
			}
			Parameter OilSandsConsumption {
				IndexDomain: year;
			}
			Parameter OilSandsProduction {
				IndexDomain: year;
			}
			Parameter OilSandsProduction_Fixed;
			Parameter LFMM_TotalBitumen {
				IndexDomain: year;
			}
		}
		DeclarationSection Canada_Production_Identifiers {
			Parameter ProjectedProduction {
				IndexDomain: (year,cn);
			}
		}
	}
	Section End_Use_Consumption_Section {
		Procedure EndUse_Consumption_InitializeData {
			Body: {
				
				
				Cons_State_Mon(datamon,sec,state):=	HistoricalDemand(datamon, sec, state) ;
				
				!Fill Texas History using historical shares
				Cons_State_Mon(datamon,sec, state | state in TXRegion_)  := HistoricalDemand(datamon,sec,TexasState) * TexasConsShares(state | state in TXRegion_ ,sec);
				
				!Split TX historical transportation consumption based on ResCom demand by TX region
				Cons_State_Mon(datamon, Sector_Transportation, r_tx) := Cons_State_Mon(datamon, Sector_Transportation, TexasState) * 
					((Cons_State_Mon(datamon, Sector_Residential, r_tx) + Cons_State_Mon(datamon, Sector_Commercial, r_tx))/$
					(Cons_State_Mon(datamon,Sector_Residential,TexasState)+Cons_State_Mon(datamon,Sector_Commercial,TexasState)));
				
				Cons_State_Yr(datayear,sec,state ):= 	sum(datamon|map_month_year(datamon,datayear), Cons_State_Mon(datamon,sec,state));
				
				TotalConsumption(datamon, d) := sum(sec, HistoricalDemand(datamon, sec, d | d <> TexasState)) ;
				!Fill in consumption parameters for historical years.  For QP, AK and HI are not demand regions.
				
				!Define Element Parameter MonthsInSeason(mon) yda:moved to definition
				!MonthsInSeason(mon) := 												'shoulder';
				!MonthsInSeason(mon|TimeslotCharacteristic(mon,'month') <= 3 or TimeslotCharacteristic(mon,'month') =12) := 	'peak';
				!MonthsInSeason(mon|6 <= TimeslotCharacteristic(mon,'month') <= 9) := 						'offpeak';
				
				!Fill in consumption arrays by NEMS regionality; while present in census division, NNGEMM regions will be used for electricity
					!AK is subtracted from the Pacific census region.
					!For electric, HI is not included and AK is separated already.  No additional corrections needed.
				Cons_Census_Yr(datayear,sec,r_cen) := 		sum(l48, Cons_State_Yr(datayear,sec,l48)*map_State_CensusRegion(l48,r_cen));
				Electric_State_Season(datayear,l48,season) := 	sum(datamon|(map_month_year(datamon,datayear) and map_mon_season(datamon,season)),Cons_State_Mon(datamon,Sector_Electric,l48));
				Electric_NNGEMM_Season(datayear,NNGEMM,season) := 	sum(l48, Electric_State_Season(datayear,l48,season)*map_State_NNGEMM(l48,NNGEMM));
				
				!Determine last month for which EIA historical data exists and determine LastHistoricalDataYear by testing if LastHistoricalDataMonth is December
				LastHistoricalDataMonth := Last(datamon | Exists((sec,l48)|Cons_State_Mon(datamon,sec,l48)));
				if (MonthToYear(LastHistoricalDataMonth)=MonthToYear(LastHistoricalDataMonth-11)) then
					LastHistoricalDataYear := MonthToYear(LastHistoricalDataMonth);
				else
					LastHistoricalDataYear := MonthToYear(LastHistoricalDataMonth)-1;
				endif;
				
				!Derive state shares of census region consumption using historical data
				Cons_share_StateCen(sec,l48,r_cen) := 		sum(navgyr_dmd, Cons_State_Yr(LastHistoricalDataYear-Val(navgyr_dmd)+1,sec,l48)/$ Cons_Census_Yr(LastHistoricalDataYear-Val(navgyr_dmd)+1,sec,r_cen))
											/Card(NumberOfYearsForAverage_Demand_);
				
				Cons_share_MonYr(sec,l48,mn) := 		sum((hdatamon,navgyr_dmd)|map_Month_MonthinYear(hdatamon,mn)and hdatamon>=YearToMonth(LastHistoricalDataYear),
											Cons_State_mon(hdatamon-12*(Val(navgyr_dmd)-1),sec,l48))/$ sum(navgyr_dmd ,Cons_State_Yr(LastHistoricalDataYear-Val(navgyr_dmd)+1,sec,l48));
				
				Cons_share_StateNNGEMM(l48,NNGEMM,season) := 	sum(navgyr_dmd, Electric_State_Season(LastHistoricalDataYear-Val(navgyr_dmd)+1,l48,season)
											/$ Electric_NNGEMM_Season(LastHistoricalDataYear-Val(navgyr_dmd)+1,NNGEMM,season))/Card(NumberOfYearsForAverage_Demand_);
				
				Cons_share_MonSeason(l48,mn,season) :=		sum((hdatamon,navgyr_dmd)|map_Month_MonthinYear(hdatamon,mn)and hdatamon>=YearToMonth(LastHistoricalDataYear),
											Cons_State_mon(hdatamon-12*(Val(navgyr_dmd)-1),'Electric',l48))/$ sum(navgyr_dmd, Electric_State_Season(LastHistoricalDataYear-Val(navgyr_dmd)+1,l48,season));
				
				!Fill in consumption arrays derived from NEMS data in historical years
				NEMS_Consumption((year,Sector_Residential,r_cen)|year <= LastHistoricalDataYear) :=		Cons_Residential(r_cen, year);
				NEMS_Consumption((year,Sector_Commercial,r_cen)|year <= LastHistoricalDataYear) :=		Cons_Commercial(r_cen, year);
				NEMS_Consumption((year,Sector_Industrial,r_cen)|year <= LastHistoricalDataYear) :=		Cons_Industrial_Core(r_cen, year)+Cons_Industrial_Noncore(r_cen,year);
				NEMS_Consumption((year,Sector_Transportation,r_cen)|year <= LastHistoricalDataYear) :=	Cons_Transportation(r_cen, year);
				NEMS_Consumption_EMM((year,NNGEMM,season)|year <= LastHistoricalDataYear) := 		Cons_Electric_Season(NNGEMM,year,season);
				
				NEMS_Consumption_noAK(datayear,sec,r_cen) := 	NEMS_Consumption(datayear,sec,r_cen);
				NEMS_Consumption_noAK(datayear,sec,CD_Pacific)-=	AK_Cons_EndUse(datayear,sec);
				
				!Fill an identifier that allows for graphing data for all months in a given year- see report page End Use Consumption by Month
				Cons_State_MonYr(mn,datayear,sec,l48) := 	sum(datamon|(map_Month_MonthinYear(datamon,mn) and map_month_year(datamon,datayear)), Cons_State_Mon(datamon,sec,l48));
				
				!Calculate historical national total annual consumption
				TotalUSConsumptionAnnual(histyr):= sum((histmon, sec, state) | map_month_year(histmon, histyr), HistoricalDemand(histmon, sec, state | state <> TexasState));
				AnnualTotalConsumption(histyr,AKState) := sum(sec, AK_Cons_EndUse(histyr,sec));
			}
			Comment: {
				"Initializes end-use consumption variables for as many complete years of historical data.
				Use historical data to calculate state shares (by region) and monthly shares (by year or by season for electricity data).
				Transfer over all historical consumption from NEMS variables to be used for model years.  NEMS data was transfered from global data structure and converted to Bcf in the section \"NEMS Mapping.\"
				NEMS data is not going to be used for historical years, but assigned for completeness/potential use."
			}
		}
		Procedure EndUse_Consumption_Run {
			Body: {
				!Transfer NEMS variables for consumption for Model Year only (update)
				NEMS_Consumption(ModelYear,Sector_Residential,r_cen) :=	Cons_Residential(r_cen, ModelYear);
				NEMS_Consumption(ModelYear,Sector_Commercial,r_cen) :=	Cons_Commercial(r_cen, ModelYear);
				NEMS_Consumption(ModelYear,Sector_Industrial,r_cen) :=	Cons_Industrial_Core(r_cen, ModelYear)
					+ Cons_Industrial_Noncore(r_cen,ModelYear)  + Cons_GasToLiquids(r_cen,ModelYear);
				NEMS_Consumption(ModelYear,Sector_Transportation,r_cen) :=	Cons_Transportation(r_cen, ModelYear);
				NEMS_Consumption_EMM(ModelYear,NNGEMM,season) := 	Cons_Electric_Season(NNGEMM,ModelYear,season);
				
				!Correct NEMS arrays by subtracting AK from Pacific Region
				NEMS_Consumption_noAK(ModelYear,sec,r_cen) := 		NEMS_Consumption(ModelYear,sec,r_cen);
				NEMS_Consumption_noAK(ModelYear,sec,CD_Pacific)	-=	AK_Cons_EndUse(ModelYear,sec);
				
				!Assign transportation array by mode
				EndUse_Trans_UpdateConsumption;
				
				!Add natural gas used in CNG/LNG manufacturing to transportation consumption for QP
				FuelLoss_CNG_LNG(ModelYear, r_cen) :=  sum((fuel, vehicle), 
					Trans_PctFuelLoss(fuel, vehicle)* NEMS_AnnualConsByMode(ModelYear,fuel,vehicle,r_cen));
				NEMS_Consumption_noAK(ModelYear,Sector_Transportation,r_cen) += FuelLoss_CNG_LNG(ModelYear, r_cen);	
				
				!Fill in arrays using NEMS variables and historical shares for all sectors but electric
				!Cons_State_Yr(ModelYear,sec,l48) :=	sum(r_cen|map_State_CensusRegion(l48,r_cen), Cons_share_StateCen(sec,l48,r_cen)*NEMS_Consumption(ModelYear,sec,r_cen));
				Cons_State_Yr(ModelYear,sec,l48) :=	sum(r_cen|map_State_CensusRegion(l48,r_cen), Cons_share_StateCen(sec,l48,r_cen)*NEMS_Consumption_noAK(ModelYear,sec,r_cen));
				Cons_State_Mon(modelyrmn,sec,l48) := 	sum(mn|map_MonthinYear_ModelYearMonth(mn,modelyrmn),Cons_share_MonYr(sec,l48,mn)*Cons_State_Yr(ModelYear,sec,l48));
				!Cons_Census_Yr(ModelYear,sec,r_cen) := 	sum(l48|map_State_CensusRegion(l48,r_cen), Cons_State_Yr(ModelYear,sec,l48));
				!Fill in arrays using NEMS variables and historical shares for electric sector
				Electric_State_Season(ModelYear,l48,season) := 	sum(NNGEMM|map_State_NNGEMM(l48,NNGEMM),Cons_share_StateNNGEMM(l48,NNGEMM,season)*NEMS_Consumption_EMM(ModelYear,NNGEMM,season));
				Cons_State_Yr(ModelYear,Sector_Electric,l48) :=	sum(season, Electric_State_Season(ModelYear,l48,season));
				Cons_State_Mon(modelyrmn,Sector_Electric,l48) := 	sum((season, mn)|map_MonthinYear_ModelYearMonth(mn,modelyrmn), Cons_share_MonSeason(l48,mn,season)*Electric_State_Season(ModelYear,l48,season));
				Cons_State_Yr(ModelYear,sec,AKState) := AK_Cons_EndUse(ModelYear,sec);
				
				!Check that mappings are correct
				Check_mapping(ModelYear,l48)  := Cons_State_Yr(ModelYear,Sector_Electric,l48)-sum(modelyrmn,Cons_State_Mon(modelyrmn,Sector_Electric,l48));
				
				!Fill in additional parameter for report purposes
				Cons_State_MonYr(mn,ModelYear,sec,l48) := sum(modelyrmn|DisplayedMonthInYear(modelyrmn)=mn, Cons_State_Mon(modelyrmn,sec,l48));
				
				!Transfer lower 48 consumption to Total Consumption array for model year
				TotalConsumption( (modelyrmn,l48)  ) :=  sum(sec, Cons_State_Mon(modelyrmn, sec, l48)); !End Use Consumption Subroutine
				AnnualTotalConsumption(ModelYear,l48) := sum(sec, Cons_State_Yr(ModelYear, sec, l48));
				AnnualTotalConsumption(ModelYear,AKState) := sum(sec, AK_Cons_EndUse(ModelYear,sec)); !needed for STEO benchmarking
			}
			Comment: {
				"Run in NGTDM each model year.
				Uses NEMS data from demand modules and historical shares to calculate consumption by sector, state (lower 48), and month."
			}
		}
		Procedure EndUse_Trans_UpdateConsumption {
			Body: {
				!Fill in AIMMS Consumption Identifier for this Model Year
				NEMS_AnnualConsByMode(NEMSmap_Year(CURIYR),Fuel_CNG,Vehicle_Fleet,r_cen):=
					sum(MNUMCR, NGTDMOUT_QGFTRFV(MNUMCR,CURIYR)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) * Convert_TBtu_Bcf_NonUtility(NEMSmap_Year(CURIYR)));
				NEMS_AnnualConsByMode(NEMSmap_Year(CURIYR),Fuel_CNG,Vehicle_Personal,r_cen):=
					sum(MNUMCR, NGTDMOUT_QGFTRPV(MNUMCR,CURIYR)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) * Convert_TBtu_Bcf_NonUtility(NEMSmap_Year(CURIYR)));
				NEMS_AnnualConsByMode(NEMSmap_Year(CURIYR),Fuel_LNG,Vehicle_Fleet,r_cen):=
					sum(MNUMCR, NGTDMOUT_QGLTRFV(MNUMCR,CURIYR)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) * Convert_TBtu_Bcf_NonUtility(NEMSmap_Year(CURIYR)));
				NEMS_AnnualConsByMode(NEMSmap_Year(CURIYR),Fuel_LNG,Vehicle_Personal,r_cen):=
					sum(MNUMCR, NGTDMOUT_QGLTRPV(MNUMCR,CURIYR)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) * Convert_TBtu_Bcf_NonUtility(NEMSmap_Year(CURIYR)));
				NEMS_AnnualConsByMode(NEMSmap_Year(CURIYR),Fuel_LNG,Vehicle_Rail,r_cen):=
					sum((MNUMCR,M4), NGTDMOUT_QGLTRRAIL(M4,MNUMCR,CURIYR)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) * Convert_TBtu_Bcf_NonUtility(NEMSmap_Year(CURIYR)));
				NEMS_AnnualConsByMode(NEMSmap_Year(CURIYR),Fuel_LNG,Vehicle_Marine,r_cen):=
					sum((MNUMCR,M3), NGTDMOUT_QGLTRSHIP(M3,MNUMCR,CURIYR)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) * Convert_TBtu_Bcf_NonUtility(NEMSmap_Year(CURIYR)));
				NEMS_AnnualConsByMode(NEMSmap_Year(CURIYR),Fuel_CNG,Vehicle_Rail,r_cen):=
					sum((MNUMCR,M4), NGTDMOUT_QGFTRRAIL(M4,MNUMCR,CURIYR)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) * Convert_TBtu_Bcf_NonUtility(NEMSmap_Year(CURIYR)));
				NEMS_AnnualConsByMode(NEMSmap_Year(CURIYR),Fuel_CNG,Vehicle_Marine,r_cen):=
					sum((MNUMCR,M3), NGTDMOUT_QGFTRSHIP(M3,MNUMCR,CURIYR)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) * Convert_TBtu_Bcf_NonUtility(NEMSmap_Year(CURIYR)));
			}
		}
		DeclarationSection Consumption_Declaration {
			Parameter TotalConsumption {
				IndexDomain: (mon,reg);
				Text: "Total Consumption by month and region";
			}
			Parameter AnnualTotalConsumption {
				IndexDomain: (year,reg);
			}
			Parameter Cons_State_Mon {
				IndexDomain: (mon,sec,state);
				Text: "Consumption (Bcf) by state , sector, and month";
			}
			Parameter Cons_State_Yr {
				IndexDomain: (year,sec,state);
				Text: "Consumption (Bcf) by state , sector, and year";
			}
			Parameter NEMS_Consumption {
				IndexDomain: (year,sec, r_cen);
				Text: "Consumption (Bcf) from NEMS global data by sector, census region, and year";
				Comment: {
					"! Ignore any data present for the electric sector"
				}
			}
			Parameter FuelLoss_CNG_LNG {
				IndexDomain: (year,r_cen);
				Text: "Fuel used/lost in converting natural gas to CNG or LNG";
				Comment: {
					"! Ignore any data present for the electric sector"
				}
			}
			Parameter NEMS_Consumption_noAK {
				IndexDomain: (year,sec,r_cen);
				Text: "Consumption (Bcf) from NEMS global data by sector, census region, and year corrected to remove AK constribution";
				Comment: {
					"!Ignore any data for electric sector"
				}
			}
			Parameter Cons_Census_Yr {
				IndexDomain: (year,sec,r_cen);
			}
			Parameter Cons_share_StateCen {
				IndexDomain: (sec,l48,r_cen)|map_State_CensusRegion(l48,r_cen);
			}
			Parameter Cons_share_MonYr {
				IndexDomain: (sec,l48,mn);
			}
			Parameter Check_mapping {
				IndexDomain: (year,l48);
			}
			Parameter Cons_State_MonYr {
				IndexDomain: (mn,year,sec,l48);
			}
		}
		DeclarationSection Electricity_Consumption_Declaration {
			Parameter Electric_NNGEMM_Season {
				IndexDomain: (year,NNGEMM,season);
			}
			Parameter NEMS_Consumption_EMM {
				IndexDomain: (year,NNGEMM,season);
			}
			Parameter Electric_State_Season {
				IndexDomain: (year,l48,season);
			}
			Parameter Cons_share_StateNNGEMM {
				IndexDomain: (l48,NNGEMM,season)|map_State_NNGEMM(l48,NNGEMM);
			}
			Parameter Cons_share_MonSeason {
				IndexDomain: (l48,mn,season)|map_season_mn(season,mn);
			}
			Parameter Cons_Electric_Month {
				IndexDomain: (mon,NNGEMM);
			}
		}
	}
	Section EndUse_Prices_Section {
		DeclarationSection General_Declaration {
			Parameter TXPriceAdjustmentFactor {
				IndexDomain: (datamon, state);
			}
			Set MarkupEquationOption_ {
				SubsetOf: Integers;
				Index: opt;
				Definition: {
					{1..4}
				}
			}
			ElementParameter ResidentialOption {
				Range: MarkupEquationOption_;
			}
			ElementParameter SectorOption {
				IndexDomain: sec;
				Range: MarkupEquationOption_;
			}
			ElementParameter CommercialOption {
				Range: MarkupEquationOption_;
			}
			ElementParameter IndustrialOption {
				Range: MarkupEquationOption_;
			}
			ElementParameter ElectricOption {
				Range: MarkupEquationOption_;
			}
			ElementParameter TransportationOption {
				IndexDomain: fuel;
				Range: MarkupEquationOption_;
			}
			ElementParameter Option1 {
				Text: "Option 1";
				Range: MarkupEquationOption_;
				Definition: first(opt);
			}
			ElementParameter Option2 {
				Text: "Option 2";
				Range: MarkupEquationOption_;
				Definition: element(MarkupEquationOption_,2);
			}
			ElementParameter Option3 {
				Text: "Option 3";
				Range: MarkupEquationOption_;
				Definition: element(MarkupEquationOption_,3);
			}
			ElementParameter Option4 {
				Text: "Option 4";
				Range: MarkupEquationOption_;
				Definition: element(MarkupEquationOption_,4);
			}
			Parameter Markups_Enduse {
				IndexDomain: (year,sec,r_cen,opt);
			}
			Parameter Markups_EnduseElectric {
				IndexDomain: (year,NNGEMM,season,opt);
			}
			Parameter Price_Enduse {
				IndexDomain: (year,sec,r_cen,opt);
			}
			Parameter Price_EnduseSeasonalIndustrial {
				IndexDomain: (year,r_cen,hmmseason);
			}
			Parameter Price_EnduseElectric {
				IndexDomain: (year,NNGEMM,season,opt);
			}
			Parameter AveragePrice_EnduseElectric {
				IndexDomain: year;
			}
			Parameter Price_EndUseTransportation {
				IndexDomain: (year,fuel,vehicle,r_cen,opt);
			}
			Parameter Error_PriceCheck;
		}
		Section Citygate_Prices {
			DeclarationSection CityGate_Prices_Declaration {
				Parameter PriceSpotSeasonalCensus {
					IndexDomain: (year,r_cen,hmmseason);
				}
				Parameter PriceCityGateSeasonalForMarkups {
					IndexDomain: (year,sec,r_cen,hmmseason);
				}
				Parameter PriceCityGateMonthlyForMarkups {
					IndexDomain: (mon,sec,r_cen);
				}
				Parameter PriceSpotAnnualSeasonalIndustrial {
					IndexDomain: (year,r_cen,hmmseason);
				}
				Parameter PriceSpotMonthlyCensus {
					IndexDomain: (mon,r_cen);
				}
				Parameter Price_Citygate {
					IndexDomain: (mon,state);
				}
				Parameter Price_Spot {
					IndexDomain: (mon,reg);
				}
				Parameter PriceSpot_Add {
					IndexDomain: (reg);
				}
				Parameter PriceCitygateAnnualState {
					IndexDomain: (year,state);
				}
				Parameter PriceCitygateAnnualforMarkups {
					IndexDomain: (year,sec,r_cen,opt);
					Comment: {
						"For residential and commercial sectors: this is an average annual Census Division citygate price weighted on res+com consumption
						For industrial sector: this is an average annual Census Division industrial spot price
						For industrial sector Option3: an average annual Census Division citygate price weighted on res+com consumption"
					}
				}
				Parameter PriceSpotAnnualState {
					IndexDomain: (year,state);
				}
				Parameter PriceSpotAnnualCD {
					IndexDomain: (year,r_cen);
				}
				Parameter PriceSpotAnnualElectric {
					IndexDomain: (year,NNGEMM,season);
				}
				Parameter PriceSpotAnnualIndustrial {
					IndexDomain: (year,r_cen);
				}
				Set ADJ_flag_ {
					Index: adjflg;
				}
				ElementParameter ADJ_flag {
					IndexDomain: state;
					Range: ADJ_flag_;
				}
				Parameter DifferenceCitygateSpotCD {
					IndexDomain: (year,r_cen);
				}
			}
			DeclarationSection Citygate_Coefficient_Declaration {
				Parameter x_SpotPrice_peak {
					IndexDomain: state;
				}
				Parameter x_SpotPrice_offpeak {
					IndexDomain: state;
				}
				Parameter x_SpotPrice_year {
					IndexDomain: state;
				}
				Parameter x_Qratio_peak {
					IndexDomain: state;
				}
				Parameter x_Qratio_offpeak {
					IndexDomain: state;
				}
				Parameter x_Qratio_year {
					IndexDomain: state;
				}
				Parameter C_peak {
					IndexDomain: state;
				}
				Parameter C_offpeak {
					IndexDomain: state;
				}
				Parameter C_year {
					IndexDomain: state;
				}
			}
		}
		DeclarationSection Residential_Prices_Declaration {
			Parameter DIV_RES {
				IndexDomain: (r_cen,opt);
			}
			Parameter PAR1_RES {
				IndexDomain: opt;
			}
			Parameter PAR1_RES_CD {
				IndexDomain: (r_cen,opt);
			}
			Parameter PAR2_RES {
				IndexDomain: opt;
			}
			Parameter PAR2_RES_CD {
				IndexDomain: (r_cen,opt);
			}
			Parameter PAR3_RES {
				IndexDomain: opt;
			}
			Parameter PAR3_RES_CD {
				IndexDomain: (r_cen,opt);
			}
		}
		DeclarationSection Commercial_Prices_Declaration {
			Parameter DIV_COM {
				IndexDomain: (r_cen,opt);
			}
			Parameter PAR1_COM {
				IndexDomain: opt;
			}
			Parameter PAR1_COM_CD {
				IndexDomain: (r_cen,opt);
			}
			Parameter PAR2_COM {
				IndexDomain: opt;
			}
			Parameter PAR2_COM_CD {
				IndexDomain: (r_cen,opt);
			}
			Parameter PAR3_COM {
				IndexDomain: opt;
			}
			Parameter PAR3_COM_CD {
				IndexDomain: (r_cen,opt);
			}
		}
		DeclarationSection Electric_Prices_Declaration {
			Parameter DIV_EL {
				IndexDomain: (NNGEMM,season,opt);
			}
			Parameter PAR1_EL {
				IndexDomain: (season,opt);
			}
			Parameter PAR2_EL {
				IndexDomain: (season,opt);
			}
			Set Year_EL_ {
				SubsetOf: Years_;
				Index: yr_el;
			}
			Parameter Factor_EL;
			Parameter AverageMarkupElectric {
				IndexDomain: (NNGEMM,season);
			}
			Parameter QOTHER {
				IndexDomain: (year,NNGEMM,season);
			}
			Parameter ConsumptionGrowthFactor {
				IndexDomain: (year,NNGEMM,season);
			}
			Parameter AnnualPrice_EnduseElectric {
				IndexDomain: (year, NNGEMM);
			}
		}
		DeclarationSection Industrial_Prices_Declaration {
			Parameter PAR1_MESC_IND {
				Comment: "Parameter used in the estimating equation for historical industrial prices for each year and Census Division that are consistent with prices published in the Manufacturing Energy Consumption Survey (MECS)";
			}
			Parameter PAR2_MESC_IND {
				Comment: "Parameter used in the estimating equation for historical industrial prices for each year and Census Division that are consistent with prices published in the Manufacturing Energy Consumption Survey (MECS)";
			}
			Parameter PAR3_MESC_IND {
				Comment: "Parameter used in the estimating equation for historical industrial prices for each year and Census Division that are consistent with prices published in the Manufacturing Energy Consumption Survey (MECS)";
			}
			Parameter DIV_IND {
				IndexDomain: (r_cen,opt);
			}
			Parameter PAR1_IND {
				IndexDomain: opt;
			}
			Parameter PAR2_IND {
				IndexDomain: opt;
			}
			Parameter AverageMarkupIND {
				IndexDomain: r_cen;
			}
			Set Year_IND_ {
				SubsetOf: Years_;
				Index: yr_ind;
			}
		}
		Section Transportation_End_Use_Prices {
			Procedure EndUsePrice_TransCost_Initialize {
				Body: {
					!Create historical array of Citygate prices by CD (annual) for setting historical data arrays for transportation sector
					!HistoricalAnnualCitygateCDPrice(datayear,r_cen) := sum(l48| map_State_CensusRegion(l48, r_cen),HistoricalAnnualCitygatePrice(datayear,l48) *
					!   			(HistoricalAnnualDemand(datayear, Sector_Residential, l48) + HistoricalAnnualDemand(datayear,Sector_Commercial,l48)))/$
					!     			(NEMS_Consumption(datayear,Sector_Residential,r_cen)+NEMS_Consumption(datayear,Sector_Commercial,r_cen));
					
					!Convert units for all reads into 1987$ (already in Mcf)
					HistoricalAnnualPriceEERE(year,fuel,r_cen) /= GDPPriceDeflator87(year);
					HistoricalAnnualRoadPriceEERE(year,fuel,vehicle,r_cen)/= GDPPriceDeflator87(year);
					
					
					!Extend current federal tax rate through all model years
					Tax_Federal((year,fuel)|year >= FirstModelYear) := Tax_Federal(Trans_TaxYrDollars,fuel);
					Tax_Federal(year,fuel)/= GDPPriceDeflator87(year);
					
					!Convert units for all reads into 1987$/Mcf and Mcf
					Trans_DailyCapacity(fuel,vehicle)*= Conv_dge_Mcf(fuel);
					Trans_Capex(fuel,vehicle)/= GDPPriceDeflator87(LNG_CostsYrDollars);
					Trans_Opex(fuel,vehicle):= Trans_Opex(fuel,vehicle)/(Conv_dge_Mcf(fuel) * GDPPriceDeflator87(LNG_CostsYrDollars));
					
					Trans_PctCapexPerYr(fuel,vehicle) := 	(Trans_WACC(fuel,vehicle) * ((1 + Trans_WACC(fuel,vehicle))^Trans_YrsRecover(fuel,vehicle)))/$
										(((1 + Trans_WACC(fuel,vehicle))^Trans_YrsRecover(fuel,vehicle))-1);
					Trans_CapexPerMcf(fuel,vehicle) := 	((Trans_Capex(fuel,vehicle)*10^6)/$(Trans_DailyCapacity(fuel,vehicle)*NumberOfDaysInYear(Trans_CostsYrDollars)*(Trans_Utilization(fuel,vehicle))))*
										Trans_PctCapexPerYr(fuel,vehicle);
					Trans_CostMarkup(fuel,vehicle) :=	Trans_CapexPerMcf(fuel,vehicle) + Trans_Opex(fuel,vehicle);
					
					
					!Add Cost of LNG liquefaction to PctFuelLoss variable
					Trans_PctFuelLoss(Fuel_LNG, vehicle)+= Pct_Liquifaction_Fuel;
					
					!Fill in arrays for CNG rail and ships using CNG and LNG asssumptions for private/personal vehicles; fill in better later?
					Trans_CostMarkup(Fuel_CNG,Vehicle_Rail) :=Trans_CostMarkup(Fuel_CNG,Vehicle_Fleet);
					Trans_CostMarkup(fuel,Vehicle_Marine) :=Trans_CostMarkup(fuel,Vehicle_Fleet);
					
					
					!Calculate historical tariffs by subtracting EERE prices (without taxes) from Citygate Price
					!Once LNG prices are in for EERE, change Fuel_CNG to fuel
					Difference_EERE_Citygate(year,fuel,vehicle_r,r_cen) :=
						HistoricalAnnualRoadPriceEERE(year,fuel,vehicle_r,r_cen)-Trans_CostMarkup(fuel,vehicle_r) -PriceCitygateAnnualforMarkups(year,Sector_Transportation, r_cen, Option1);
					Trans_Tariff(fuel,vehicle_r,r_cen) :=	sum(navgyr_trans, Difference_EERE_Citygate(LastHistoricalYear-Val(navgyr_trans)+1,fuel,vehicle_r,r_cen)/Card(NumberOfYearsForAverage_Trans_));
					
					
					!Add taxes back to EERE data
					!Might want to change data input later?
					HistoricalAnnualPriceEERE_Tax(year,fuel,r_cen) := HistoricalAnnualPriceEERE(year,fuel,r_cen)+ Tax_Federal(year,fuel) + (Tax_State(fuel, r_cen)/GDPPriceDeflator87(Trans_TaxYrDollars));
					HistoricalAnnualRoadPriceEERE_Tax(year,fuel,vehicle,r_cen) :=  HistoricalAnnualRoadPriceEERE(year,fuel,vehicle,r_cen)+Tax_Federal(year,fuel) + (Tax_State(fuel, r_cen)/GDPPriceDeflator87(Trans_TaxYrDollars));
				}
			}
			Procedure EndUsePrice_TransNEMS_Initialize {
				Body: {
					
					NEMS_Price_Trans(NEMSmap_Year(MNUMYR),r_cen) :=	sum(MNUMCR, MPBLK_PNGTR(MNUMCR,MNUMYR)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) * Convert_TBtu_Bcf_NonUtility(NEMSmap_Year(MNUMYR)));
					
					!Fill in AIMMS Price Identifier using all NEMS individual Indentifiers
					NEMS_AnnualPriceByMode(NEMSmap_Year(MNUMYR),Fuel_CNG,Vehicle_Fleet,r_cen):=
						sum(MNUMCR, NGTDMOUT_PGFTRFV(MNUMCR,MNUMYR)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) * Convert_TBtu_Bcf_NonUtility(NEMSmap_Year(MNUMYR)));
					NEMS_AnnualPriceByMode(NEMSmap_Year(MNUMYR),Fuel_CNG,Vehicle_Personal,r_cen):=
						sum(MNUMCR, NGTDMOUT_PGFTRPV(MNUMCR,MNUMYR)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) * Convert_TBtu_Bcf_NonUtility(NEMSmap_Year(MNUMYR)));
					NEMS_AnnualPriceByMode(NEMSmap_Year(MNUMYR),Fuel_LNG,Vehicle_Fleet,r_cen):=
						sum(MNUMCR, NGTDMOUT_PGLTRFV(MNUMCR,MNUMYR)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) * Convert_TBtu_Bcf_NonUtility(NEMSmap_Year(MNUMYR)));
					NEMS_AnnualPriceByMode(NEMSmap_Year(MNUMYR),Fuel_LNG,Vehicle_Personal,r_cen):=
						sum(MNUMCR, NGTDMOUT_PGLTRPV(MNUMCR,MNUMYR)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) * Convert_TBtu_Bcf_NonUtility(NEMSmap_Year(MNUMYR)));
					NEMS_AnnualPriceByMode(NEMSmap_Year(MNUMYR),Fuel_CNG,Vehicle_Rail,r_cen):=
						sum(MNUMCR, NGTDMOUT_PGFTRRAIL('1',MNUMCR,MNUMYR)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) * Convert_TBtu_Bcf_NonUtility(NEMSmap_Year(MNUMYR)));
					NEMS_AnnualPriceByMode(NEMSmap_Year(MNUMYR),Fuel_LNG,Vehicle_Rail,r_cen):=
						sum(MNUMCR, NGTDMOUT_PGLTRRAIL('1',MNUMCR,MNUMYR)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) * Convert_TBtu_Bcf_NonUtility(NEMSmap_Year(MNUMYR)));
					NEMS_AnnualPriceByMode(NEMSmap_Year(MNUMYR),Fuel_CNG,Vehicle_Marine,r_cen):=
						sum(MNUMCR, NGTDMOUT_PGFTRSHIP('1',MNUMCR,MNUMYR)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) * Convert_TBtu_Bcf_NonUtility(NEMSmap_Year(MNUMYR)));
					NEMS_AnnualPriceByMode(NEMSmap_Year(MNUMYR),Fuel_LNG,Vehicle_Marine,r_cen):=
						sum(MNUMCR, NGTDMOUT_PGLTRSHIP('1',MNUMCR,MNUMYR)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) * Convert_TBtu_Bcf_NonUtility(NEMSmap_Year(MNUMYR)));
					
					
					!Fill in AIMMS Consumption Identifier using all NEMS individual Indentifiers
					NEMS_AnnualConsByMode(NEMSmap_Year(MNUMYR),Fuel_CNG,Vehicle_Fleet,r_cen):=
						sum(MNUMCR, NGTDMOUT_QGFTRFV(MNUMCR,MNUMYR)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) * Convert_TBtu_Bcf_NonUtility(NEMSmap_Year(MNUMYR)));
					NEMS_AnnualConsByMode(NEMSmap_Year(MNUMYR),Fuel_CNG,Vehicle_Personal,r_cen):=
						sum(MNUMCR, NGTDMOUT_QGFTRPV(MNUMCR,MNUMYR)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) * Convert_TBtu_Bcf_NonUtility(NEMSmap_Year(MNUMYR)));
					NEMS_AnnualConsByMode(NEMSmap_Year(MNUMYR),Fuel_LNG,Vehicle_Fleet,r_cen):=
						sum(MNUMCR, NGTDMOUT_QGLTRFV(MNUMCR,MNUMYR)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) * Convert_TBtu_Bcf_NonUtility(NEMSmap_Year(MNUMYR)));
					NEMS_AnnualConsByMode(NEMSmap_Year(MNUMYR),Fuel_LNG,Vehicle_Personal,r_cen):=
						sum(MNUMCR, NGTDMOUT_QGLTRPV(MNUMCR,MNUMYR)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) * Convert_TBtu_Bcf_NonUtility(NEMSmap_Year(MNUMYR)));
					NEMS_AnnualConsByMode(NEMSmap_Year(MNUMYR),Fuel_LNG,Vehicle_Rail,r_cen):=
						sum(MNUMCR, NGTDMOUT_QGLTRRAIL('1',MNUMCR,MNUMYR)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) * Convert_TBtu_Bcf_NonUtility(NEMSmap_Year(MNUMYR)));
					NEMS_AnnualConsByMode(NEMSmap_Year(MNUMYR),Fuel_LNG,Vehicle_Marine,r_cen):=
						sum(MNUMCR, NGTDMOUT_QGLTRSHIP('1',MNUMCR,MNUMYR)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) * Convert_TBtu_Bcf_NonUtility(NEMSmap_Year(MNUMYR)));
					NEMS_AnnualConsByMode(NEMSmap_Year(MNUMYR),Fuel_CNG,Vehicle_Rail,r_cen):=
						sum(MNUMCR, NGTDMOUT_QGFTRRAIL('1',MNUMCR,MNUMYR)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) * Convert_TBtu_Bcf_NonUtility(NEMSmap_Year(MNUMYR)));
					NEMS_AnnualConsByMode(NEMSmap_Year(MNUMYR),Fuel_CNG,Vehicle_Marine,r_cen):=
						sum(MNUMCR, NGTDMOUT_QGFTRSHIP('1',MNUMCR,MNUMYR)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) * Convert_TBtu_Bcf_NonUtility(NEMSmap_Year(MNUMYR)));
				}
			}
			Procedure EndUsePrice_Trans_InitializePrices {
				Body: {
					!For all CNG road vehicles, use EERE data
					
					EERE_FirstDataYear_CNG := first(datayear|exists(r_cen|HistoricalAnnualPriceEERE(datayear,Fuel_CNG,r_cen)));
					EERE_FirstDataYear_CNG_Vehicle:= first(datayear|exists((vehicle,r_cen)|HistoricalAnnualRoadPriceEERE(datayear,Fuel_CNG,vehicle,r_cen)));
					
					
					Price_EndUseTransportation((datayear,Fuel_CNG,vehicle_r,r_cen,opt)|datayear < EERE_FirstDataYear_CNG ) :=
							Trans_CostMarkup(Fuel_CNG,vehicle_r) + Tax_Federal(datayear,Fuel_CNG) + (Tax_State(Fuel_CNG, r_cen)/GDPPriceDeflator87(datayear))
							+ (1+Trans_PctFuelLoss(Fuel_CNG,vehicle_r))* PriceCitygateAnnualforMarkups(datayear,Sector_Transportation, r_cen, opt);
					Price_EndUseTransportation((datayear,Fuel_CNG,vehicle_r,r_cen,opt)|(EERE_FirstDataYear_CNG <= datayear and datayear < EERE_FirstDataYear_CNG_Vehicle) )  :=
							HistoricalAnnualPriceEERE_Tax(datayear,Fuel_CNG,r_cen);
					Price_EndUseTransportation((datayear,Fuel_CNG,vehicle_r,r_cen,opt)| EERE_FirstDataYear_CNG_Vehicle <= datayear)  :=
							HistoricalAnnualRoadPriceEERE_Tax(datayear,Fuel_CNG,vehicle_r,r_cen);
					
					!Option 1 Cost analysis markups-Marking up off of Citygate
					!For LNG road vehicles- fleet and personal
					Price_EndUseTransportation(datayear,Fuel_LNG,vehicle_r,r_cen,Option1)  :=
						Trans_CostMarkup(Fuel_LNG,vehicle_r) + Tax_Federal(datayear,Fuel_LNG) + (Tax_State(Fuel_LNG, r_cen)/GDPPriceDeflator87(datayear))
						+ (1+Trans_PctFuelLoss(Fuel_LNG,vehicle_r))* PriceCitygateAnnualforMarkups(datayear,Sector_Transportation, r_cen, Option1);
					
					!For rail- DO NOT INCLUDE ANY TAXES
					Price_EndUseTransportation(datayear,fuel,Vehicle_Rail,r_cen,Option1)  :=
						Trans_CostMarkup(fuel,Vehicle_Rail)
						+ (1+Trans_PctFuelLoss(fuel,Vehicle_Rail))* PriceCitygateAnnualforMarkups(datayear,Sector_Transportation, r_cen, Option1);
					
					!For marine- DO NOT INCLUDE ANY STATE TAXES- Federal included
					Price_EndUseTransportation(datayear,fuel,Vehicle_Marine,r_cen,Option1)  :=
						Trans_CostMarkup(fuel,Vehicle_Marine) + Tax_Federal(datayear,fuel)
						+ (1+Trans_PctFuelLoss(fuel,Vehicle_Marine))* PriceCitygateAnnualforMarkups(datayear,Sector_Transportation, r_cen, Option1);
					
					
					!Option 2 Cost analysis markups-Marking up off of ELECTRIC
					!For road vehicles- fleet and personal
					Price_EndUseTransportation(datayear,Fuel_LNG,vehicle_r,r_cen,Option2)  :=
						Trans_CostMarkup(Fuel_LNG,vehicle_r) + Tax_Federal(datayear,Fuel_LNG) + (Tax_State(Fuel_LNG, r_cen)/GDPPriceDeflator87(datayear))
						+ (1+Trans_PctFuelLoss(Fuel_LNG,vehicle_r))* AveragePrice_EnduseElectric(datayear);
					
					!For rail- DO NOT INCLUDE ANY TAXES
					Price_EndUseTransportation(datayear,fuel,Vehicle_Rail,r_cen,Option2)  :=
						Trans_CostMarkup(fuel,Vehicle_Rail)
						+ (1+Trans_PctFuelLoss(fuel,Vehicle_Rail))* AveragePrice_EnduseElectric(datayear);
					
					!For marine- DO NOT INCLUDE ANY STATE TAXES- Federal included
					Price_EndUseTransportation(datayear,fuel,Vehicle_Marine,r_cen,Option2):=
						Trans_CostMarkup(fuel,Vehicle_Marine) + Tax_Federal(datayear,fuel)
						+ (1+Trans_PctFuelLoss(fuel,Vehicle_Marine))* AveragePrice_EnduseElectric(datayear);
					
					
					
					!Option 3 Cost analysis markups-Marking up off of Industrial
					!For road vehicles- fleet and personal
					Price_EndUseTransportation(datayear,Fuel_LNG,vehicle_r,r_cen,Option3)  :=
						Trans_CostMarkup(Fuel_LNG,vehicle_r) + Tax_Federal(datayear,Fuel_LNG) + (Tax_State(Fuel_LNG, r_cen)/GDPPriceDeflator87(datayear))
						+ (1+Trans_PctFuelLoss(Fuel_LNG,vehicle_r))* Price_Enduse(datayear, Sector_Industrial, r_cen, IndustrialOption);
					
					!For rail- DO NOT INCLUDE ANY TAXES
					Price_EndUseTransportation(datayear,fuel,Vehicle_Rail,r_cen,Option3)  :=
						Trans_CostMarkup(fuel,Vehicle_Rail)
						+ (1+Trans_PctFuelLoss(fuel,Vehicle_Rail))* Price_Enduse(datayear, Sector_Industrial, r_cen, IndustrialOption);
					
					!For marine- DO NOT INCLUDE ANY STATE TAXES- Federal included
					Price_EndUseTransportation(datayear,fuel,Vehicle_Marine,r_cen,Option3)  :=
						Trans_CostMarkup(fuel,Vehicle_Marine) + Tax_Federal(datayear,fuel)
						+ (1+Trans_PctFuelLoss(fuel,Vehicle_Marine))* Price_Enduse(datayear, Sector_Industrial, r_cen, IndustrialOption);
					
					!Option 4 Cost analysis markups-Marking up using EERE derived tariff
					!Not Used here as this is setting history.  Keep it here just in case things change....
					!Note:  Things changed!  Since Option 4 is used for LNG, gotta put it in to set history...
					
					
					!Option 4 Cost analysis markups-Marking up using EERE derived tariff
					!For rail and marine, just assign Option 3
					
					!For road vehicles- fleet and personal
					!Price_EndUseTransportation(datayear,fuel,vehicle_r,r_cen,Option4)  :=
					!	Trans_CostMarkup(fuel,vehicle_r) +Trans_Tariff(fuel,vehicle_r,r_cen)+ Tax_Federal(datayear,fuel) + (Tax_State(fuel, r_cen)/GDPPriceDeflator87(datayear))
					!	+ (1+Trans_PctFuelLoss(fuel,vehicle_r))* PriceCitygateAnnualforMarkups(datayear,Sector_Transportation,r_cen,Option1);
					
					!For rail- DO NOT INCLUDE ANY TAXES
					!Price_EndUseTransportation(datayear,fuel,Vehicle_Rail,r_cen,Option4)  := Price_EndUseTransportation(datayear,fuel,Vehicle_Rail,r_cen,Option3);
					
					
					!For marine- DO NOT INCLUDE ANY STATE TAXES- Federal included
					!Price_EndUseTransportation(datayear,fuel,Vehicle_Marine,r_cen,Option4)  :=Price_EndUseTransportation(datayear,fuel,Vehicle_Marine,r_cen,Option3);
					
					
					!Option 1 Eviews Estimation
					!Markups_Enduse(ModelYear,Sector_Transportation,r_cen,Option1) := (DIV_TRANS(r_cen) + LAG_TRANS * (Markups_Enduse(ModelYear-1,Sector_Transportation,r_cen,Option1)))
					!	+  Tax_Federal(LastHistoricalYear,Fuel_CNG) + Tax_State(Fuel_CNG, r_cen);
				}
			}
			DeclarationSection Transportation_Set_Declarations {
				Set TransFuel_ {
					Index: fuel;
				}
				Set VehicleType_ {
					Index: vehicle;
				}
				Set VehicleRoad_ {
					SubsetOf: VehicleType_;
					Index: vehicle_r;
				}
				ElementParameter Fuel_CNG {
					Range: TransFuel_;
				}
				ElementParameter Fuel_LNG {
					Range: TransFuel_;
				}
				ElementParameter Vehicle_Personal {
					Range: VehicleType_;
				}
				ElementParameter Vehicle_Fleet {
					Range: VehicleType_;
				}
				ElementParameter Vehicle_Rail {
					Range: VehicleType_;
				}
				ElementParameter Vehicle_Marine {
					Range: VehicleType_;
				}
			}
			DeclarationSection Transportation_Prices_Declaration {
				Parameter Conv_dge_Mcf {
					IndexDomain: fuel;
				}
				ElementParameter Trans_CostsYrDollars {
					Range: Years_;
				}
				ElementParameter Trans_TaxYrDollars {
					Range: XYears_;
				}
				ElementParameter EERE_FirstDataYear_CNG {
					Range: XYears_;
				}
				ElementParameter EERE_FirstDataYear_CNG_Vehicle {
					Range: XYears_;
				}
				Parameter Tax_Federal {
					IndexDomain: (year,fuel);
				}
				Parameter Trans_DailyCapacity {
					IndexDomain: (fuel,vehicle);
				}
				Parameter Trans_Utilization {
					IndexDomain: (fuel,vehicle);
				}
				Parameter Trans_Capex {
					IndexDomain: (fuel,vehicle);
				}
				Parameter Trans_Opex {
					IndexDomain: (fuel,vehicle);
				}
				Parameter Trans_YrsRecover {
					IndexDomain: (fuel,vehicle);
				}
				Parameter Trans_WACC {
					IndexDomain: (fuel,vehicle);
				}
				Parameter Trans_PctFuelLoss {
					IndexDomain: (fuel,vehicle);
				}
				Parameter Tax_State {
					IndexDomain: (fuel,r_cen);
				}
				Parameter DIV_TRANS {
					IndexDomain: r_cen;
				}
				Parameter HistoricalAnnualPriceEERE {
					IndexDomain: (year,fuel,r_cen);
				}
				Parameter HistoricalAnnualPriceEERE_Tax {
					IndexDomain: (year,fuel,r_cen);
				}
				Parameter HistoricalAnnualRoadPriceEERE {
					IndexDomain: (year,fuel,vehicle,r_cen);
				}
				Parameter HistoricalAnnualRoadPriceEERE_Tax {
					IndexDomain: (year,fuel,vehicle,r_cen);
				}
				Parameter LAG_TRANS;
				Parameter Trans_CapexPerMcf {
					IndexDomain: (fuel,vehicle);
				}
				Parameter Trans_PctCapexPerYr {
					IndexDomain: (fuel,vehicle);
				}
				Parameter Trans_CostMarkup {
					IndexDomain: (fuel,vehicle);
				}
				Parameter Difference_EERE_Citygate {
					IndexDomain: (year,fuel,vehicle_r,r_cen);
				}
				Parameter Trans_Tariff {
					IndexDomain: (fuel,vehicle,r_cen);
				}
			}
			DeclarationSection NEMS_Prices_Declaration {
				Parameter NEMS_Price_Trans {
					IndexDomain: (year,r_cen);
				}
				Parameter NEMS_AnnualPriceByMode {
					IndexDomain: (year,fuel,vehicle,r_cen);
				}
				Parameter NEMS_AnnualConsByMode {
					IndexDomain: (year,fuel,vehicle,r_cen);
				}
			}
		}
		Procedure CityGatePrice {
			Body: {
				
				Price_Spot(MonthInPeriod(tmon), d) := -HubBalance.ShadowPrice(tmon, d)+PriceSpot_Add(d);
				Price_Citygate( (modelyrmn,l48) | ADJ_flag(l48)='annual') := C_year(l48) + x_SpotPrice_year(l48)*Price_Spot(modelyrmn,l48)
				                        + x_Qratio_year(l48)/(Cons_State_Mon(modelyrmn, Sector_Residential, l48) + Cons_State_Mon(modelyrmn, Sector_Commercial, l48));
				
				Price_Citygate( (modelyrmn,l48) | ADJ_flag(l48)='season' and map_citygate_seasonmon(modelyrmn,'peak')):=
				C_peak(l48) + x_SpotPrice_peak(l48)*Price_Spot(modelyrmn,l48) + x_Qratio_peak(l48)/(Cons_State_Mon(modelyrmn, Sector_Residential, l48) + Cons_State_Mon(modelyrmn, Sector_Commercial, l48));
				Price_Citygate( (modelyrmn,l48) | ADJ_flag(l48)='season' and map_citygate_seasonmon(modelyrmn,'offpeak')) :=
				C_offpeak(l48) + x_SpotPrice_offpeak(l48)*Price_Spot(modelyrmn,l48) + x_Qratio_offpeak(l48)/(Cons_State_Mon(modelyrmn, Sector_Residential, l48) + Cons_State_Mon(modelyrmn, Sector_Commercial, l48));
				
				Price_Citygate( (modelyrmn,l48) | ADJ_flag(l48)='adjust' and map_citygate_seasonmon(modelyrmn,'offpeak')) :=
				C_offpeak(l48) + x_SpotPrice_offpeak(l48)*Price_Spot(modelyrmn,l48) + x_Qratio_offpeak(l48)/(Cons_State_Mon(modelyrmn, Sector_Residential, l48) + Cons_State_Mon(modelyrmn, Sector_Commercial, l48));
				
				!Overwrite citygate price with spot price if citygate < spot price, and create an entry in NGATTENTION.txt file
				write Price_Citygate( (modelyrmn, l48) | Price_Citygate(modelyrmn, l48)<Price_Spot(modelyrmn, l48)) to file "NGPRICES.txt" in merge mode;
				write Price_Spot( (modelyrmn, l48) | Price_Citygate(modelyrmn, l48)<Price_Spot(modelyrmn, l48)) to file "NGPRICES.txt" in merge mode;
				Price_Citygate( (modelyrmn, l48) | Price_Citygate(modelyrmn, l48)<Price_Spot(modelyrmn, l48)):= Price_Spot(modelyrmn, l48);
				
				!Special handiling for peak months for specific states
				Price_Citygate( (element(ModelYearMonths_,11),l48) | ADJ_flag(l48)='adjust' ) := Price_Citygate(element(ModelYearMonths_,10),l48) ;
				Price_Citygate( (element(ModelYearMonths_,12),l48) | ADJ_flag(l48)='adjust' ) := Price_Citygate(element(ModelYearMonths_,10),l48) ;
				Price_Citygate( (mon,l48) | ADJ_flag(l48)='adjust' and mon=element(ModelYearMonths_,1) ) := (Price_Citygate(mon-3,l48)+ Price_Citygate(mon+2,l48))/2;
				Price_Citygate( (mon,l48) | ADJ_flag(l48)='adjust' and mon=element(ModelYearMonths_,2) ) := (Price_Citygate(mon-4,l48)+ Price_Citygate(mon+1,l48))/2;
				
				!NEWNEWNEW Annual State Spot Prices
				PriceSpotAnnualState(ModelYear,l48) := sum((modelyrmn,sec), Price_Spot(modelyrmn,l48)* Cons_State_Mon(modelyrmn,sec, l48))/$
				     sum(sec,Cons_State_Yr(ModelYear, sec, l48));
				
				! Weighted average monthly spot price by Census Region 
				PriceSpotMonthlyCensus(modelyrmn, r_cen) := sum(l48 | map_State_CensusRegion(l48, r_cen), Price_Spot(modelyrmn, l48)*(sum(sec, Cons_State_Mon(modelyrmn, sec, l48)))) /$ 
					sum((l48,sec) | map_State_CensusRegion(l48, r_cen), Cons_State_Mon(modelyrmn, sec, l48)) ;
				
				
				PriceSpotSeasonalCensus(ModelYear, r_cen, hmmseason) := sum((l48,modelyrmn) | map_State_CensusRegion(l48, r_cen) and map_mon_hmmseason(modelyrmn, hmmseason), Price_Spot(modelyrmn, l48)*(sum(sec, Cons_State_Mon(modelyrmn, sec, l48)))) /$ 
					sum((l48,modelyrmn, sec) | map_State_CensusRegion(l48, r_cen) and map_mon_hmmseason(modelyrmn, hmmseason), Cons_State_Mon(modelyrmn, sec, l48)) ;
				
				! Monthly Industrial price for markup, option 1.
				PriceCityGateMonthlyForMarkups(modelyrmn, Sector_Industrial, r_cen) := PriceSpotMonthlyCensus(modelyrmn, r_cen);
				PriceCityGateSeasonalForMarkups(ModelYear, Sector_Industrial, r_cen, hmmseason) := PriceSpotSeasonalCensus(ModelYear, r_cen, hmmseason);
				
				!Annual State Citygate price
				PriceCitygateAnnualState(ModelYear,l48) := sum(modelyrmn, Price_Citygate(modelyrmn,l48)*
				     (Cons_State_Mon(modelyrmn, Sector_Residential, l48) + Cons_State_Mon(modelyrmn, Sector_Commercial, l48)))/$
				     (Cons_State_Yr(ModelYear, Sector_Residential, l48) + Cons_State_Yr(ModelYear, Sector_Commercial, l48));
				!AK Citygate price
				PriceCitygateAnnualState(ModelYear,AKState) := AK_Citygate(ModelYear);
				!Average annual Census Division citygate price for Res and Com sectors
				PriceCitygateAnnualforMarkups(ModelYear,rescom,r_cen,opt) := sum(state | map_State_CensusRegion(state, r_cen), PriceCitygateAnnualState(ModelYear,state)*
				     (Cons_State_Yr(ModelYear, Sector_Residential, state) + Cons_State_Yr(ModelYear, Sector_Commercial, state)))/
				     (NEMS_Consumption(ModelYear,Sector_Residential,r_cen)+NEMS_Consumption(ModelYear,Sector_Commercial,r_cen));
				PriceCitygateAnnualforMarkups(ModelYear,Sector_Transportation,r_cen,opt) := sum(state | map_State_CensusRegion(state, r_cen), PriceCitygateAnnualState(ModelYear,state)*
				     (Cons_State_Yr(ModelYear, Sector_Residential, state) + Cons_State_Yr(ModelYear, Sector_Commercial, state)))/
				     (NEMS_Consumption(ModelYear,Sector_Residential,r_cen)+NEMS_Consumption(ModelYear,Sector_Commercial,r_cen));
				
				
				
				!Average annual Census Division industrial spot price
				PriceCitygateAnnualforMarkups(ModelYear,Sector_Industrial,r_cen,Option1) := sum((modelyrmn,l48) | map_State_CensusRegion(l48, r_cen), Price_Spot(modelyrmn,l48)*Cons_State_Mon(modelyrmn, Sector_Industrial, l48) )/$
				     NEMS_Consumption(ModelYear,Sector_Industrial,r_cen);
				
				!PriceCityGateMonthlyForMarkups(modelyrmn, Sector_Industrial, r_cen) := sum((l48) | map_State_CensusRegion(l48, r_cen), Price_Spot(modelyrmn, l48)* Cons_State_Mon(modelyrmn, Sector_Industrial, l48)) /$
				!	sum(l48 | map_State_CensusRegion(l48, r_cen), Cons_State_Mon(modelyrmn, Sector_Industrial, l48));
				
				
				     PriceCitygateAnnualforMarkups(ModelYear,Sector_Industrial,r_cen,Option2) := PriceCitygateAnnualforMarkups(ModelYear,Sector_Industrial,r_cen,Option1);
				PriceCitygateAnnualforMarkups(ModelYear,Sector_Industrial,r_cen,Option3) :=  PriceCitygateAnnualforMarkups(ModelYear,Sector_Residential,r_cen,Option1);
				
				!PriceCityGateMonthlyForMarkups
				
				PriceSpotAnnualIndustrial(ModelYear, r_cen):= PriceCitygateAnnualforMarkups(ModelYear,Sector_Industrial,r_cen,Option2);
				
				!Average annual Census Division  spot price
				PriceSpotAnnualCD(ModelYear,r_cen) := sum((modelyrmn,l48) | map_State_CensusRegion(l48, r_cen), Price_Spot(modelyrmn,l48)*TotalConsumption(modelyrmn, l48) )/$
				     sum((modelyrmn,l48) | map_State_CensusRegion(l48, r_cen), TotalConsumption(modelyrmn, l48) );
				DifferenceCitygateSpotCD(ModelYear,r_cen) := PriceCitygateAnnualforMarkups(ModelYear,Sector_Residential,r_cen,Option1) - PriceSpotAnnualCD(ModelYear,r_cen);
				
				!Average annual NNGEMM electric spot price
				PriceSpotAnnualElectric(ModelYear, NNGEMM, season) := sum((modelyrmn,l48)| map_mon_season(modelyrmn,season) and map_State_NNGEMM(l48,NNGEMM),
				     Price_Spot(modelyrmn,l48)*Cons_State_Mon(modelyrmn, Sector_Electric, l48) )/$ NEMS_Consumption_EMM(ModelYear,NNGEMM,season);
				
				!PriceSpotAnnualSeasonalIndustrial(year, r_cen, hmmseason) := sum((modelyrmn,l48)| map_mon_hmmseason(modelyrmn,hmmseason) and map_State_CensusRegion(l48,r_cen),
				!     Price_Spot(modelyrmn,l48)*Cons_State_Mon(modelyrmn, Sector_Industrial, l48) )/$ NEMS_Consumption(ModelYear,r_cen,Sector_Industrial);
			}
			Comment: "General equation is citygate(state,month) = inter(state) + [pspot(state) * SpotPrice(state,month)] + [pQ(state)/(QRS+QCM)]";
		}
		Procedure EndUsePrice {
			Body: {
				CityGatePrice;
				EndUseMarkups_Residential;
				EndUseMarkups_Commercial;
				EndUseMarkups_Industrial;
				EndUsePrice_Electric;
				
				!Calculate end-use price for all sectors (except electric) and options; Transportation done after STEO
				Price_Enduse(ModelYear, sec, r_cen, opt):= Markups_Enduse(ModelYear, sec, r_cen, opt) + PriceCitygateAnnualforMarkups(ModelYear, sec, r_cen, opt);
				Price_EnduseSeasonalIndustrial(ModelYear, r_cen, hmmseason) := Markups_Enduse(ModelYear, Sector_Industrial, r_cen, Option1) + PriceCityGateSeasonalForMarkups(ModelYear, Sector_Industrial, r_cen, hmmseason);
				
				
				!Set STEO factors
				if (STEOBM=1 and STEONG=1) then
				   !if STSCALNG=0 then
				   if (STSCALNG=0 or ModelYear < LastSTEOYear) then   !temp for aeo2018
				      if ModelYear <= LastSTEOPhaseOutYear then
				         STEO_EndusePrices;
				      endif;
				   endif;
				endif;
				!Apply STEO benchmarking Factor
				Price_Enduse(ModelYear, sec, r_cen, opt)*= STEOEndUsePriceFactor(ModelYear, sec, r_cen);
				Price_EnduseElectric(ModelYear, NNGEMM, season, ElectricOption) *= STEOElectricPriceFactor(ModelYear);
				AveragePrice_EnduseElectric(ModelYear) *= STEOElectricPriceFactor(ModelYear);
				
				!Calculate Transportation End Use Prices
				EndUsePrice_Transportation;
				
				!!Fill in NEMS arrays
				!MPBLK_PNGRS(MNUMCR, NEMSmap_MNUMYR(ModelYear)):= sum(r_cen, Price_Enduse(ModelYear, Sector_Residential, r_cen, ResidentialOption)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				!                                                 Convert_TBtu_Bcf_NonUtility(ModelYear);
				!MPBLK_PNGCM(MNUMCR, NEMSmap_MNUMYR(ModelYear)):= sum(r_cen, Price_Enduse(ModelYear, Sector_Commercial, r_cen, CommercialOption)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				!                                                 Convert_TBtu_Bcf_NonUtility(ModelYear);
				!MPBLK_PNGIN(MNUMCR, NEMSmap_MNUMYR(ModelYear)):= sum(r_cen, Price_Enduse(ModelYear, Sector_Industrial, r_cen, IndustrialOption)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				!                                                 Convert_TBtu_Bcf_NonUtility(ModelYear);
				!
				!NGTDMOUT_SPNGELGR(NNGEMM, NEMSmap_MNUMYR(ModelYear), M3):=sum(season, Price_EnduseElectric(ModelYear, NNGEMM, season, ElectricOption)*NEMSmap_M3_season(M3,season))/
				!                                                  Convert_TBtu_Bcf_Utility(ModelYear);
				!
				!MPBLK_PNGEL(MNUMCR, NEMSmap_MNUMYR(ModelYear)):=sum((NNGEMM,M3), NGTDMOUT_SPNGELGR(NNGEMM, NEMSmap_MNUMYR(ModelYear), M3)*UEFDOUT_SQNGELGR(NNGEMM,NEMSmap_MNUMYR(ModelYear),M3)*
				!                                                NEMSmap_NNGEMM_CD(NNGEMM, MNUMCR))/$
				!                                                sum((NNGEMM,M3), UEFDOUT_SQNGELGR(NNGEMM,NEMSmap_MNUMYR(ModelYear),M3)* NEMSmap_NNGEMM_CD(NNGEMM, MNUMCR));
				!
				!
				!NGTDMOUT_PGFTRFV(MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(r_cen, Price_EndUseTransportation(ModelYear, Fuel_CNG, Vehicle_Fleet, r_cen, TransportationOption(Fuel_CNG))*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				!                                                 Convert_TBtu_Bcf_NonUtility(ModelYear);
				!NGTDMOUT_PGFTRPV(MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(r_cen, Price_EndUseTransportation(ModelYear, Fuel_CNG, Vehicle_Personal, r_cen, TransportationOption(Fuel_CNG))*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				!                                                 Convert_TBtu_Bcf_NonUtility(ModelYear);
				!NGTDMOUT_PGLTRFV(MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(r_cen, Price_EndUseTransportation(ModelYear, Fuel_LNG, Vehicle_Fleet, r_cen, TransportationOption(Fuel_LNG))*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				!                                                 Convert_TBtu_Bcf_NonUtility(ModelYear);
				!NGTDMOUT_PGLTRPV(MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(r_cen, Price_EndUseTransportation(ModelYear, Fuel_LNG, Vehicle_Personal, r_cen, TransportationOption(Fuel_LNG))*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				!                                                 Convert_TBtu_Bcf_NonUtility(ModelYear);
				!NGTDMOUT_PGFTRRAIL(M4,MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(r_cen, Price_EndUseTransportation(ModelYear, Fuel_CNG, Vehicle_Rail, r_cen, TransportationOption(Fuel_CNG))*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				!                                                 Convert_TBtu_Bcf_NonUtility(ModelYear);
				!NGTDMOUT_PGLTRRAIL(M4,MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(r_cen, Price_EndUseTransportation(ModelYear, Fuel_LNG, Vehicle_Rail, r_cen, TransportationOption(Fuel_LNG))*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				!                                                 Convert_TBtu_Bcf_NonUtility(ModelYear);
				!NGTDMOUT_PGFTRSHIP(M3,MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(r_cen, Price_EndUseTransportation(ModelYear, Fuel_CNG, Vehicle_Marine, r_cen, TransportationOption(Fuel_CNG))*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				!                                                 Convert_TBtu_Bcf_NonUtility(ModelYear);
				!NGTDMOUT_PGLTRSHIP(M3,MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(r_cen, Price_EndUseTransportation(ModelYear, Fuel_LNG, Vehicle_Marine, r_cen, TransportationOption(Fuel_CNG))*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR) )/
				!                                                 Convert_TBtu_Bcf_NonUtility(ModelYear);
				!MPBLK_PNGTR(MNUMCR, NEMSmap_MNUMYR(ModelYear)):=sum((fuel,vehicle,r_cen), Price_EndUseTransportation(ModelYear, fuel, vehicle, r_cen, TransportationOption(fuel))
				!	*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR)*NEMS_AnnualConsByMode(ModelYear, fuel, vehicle, r_cen))/$
				!	sum((fuel,vehicle,r_cen), NEMS_AnnualConsByMode(ModelYear, fuel, vehicle, r_cen)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR));
				!
				!
				!
				!
				!!Set the totals separately
				!MPBLK_PNGRS(TotalUS_MNUMCR, NEMSmap_MNUMYR(ModelYear)):= sum(MNUMC2, MPBLK_PNGRS(MNUMC2, NEMSmap_MNUMYR(ModelYear))*QBLK_QGFRS(MNUMC2,NEMSmap_MNUMYR(ModelYear)))/$
				!                                                  QBLK_QGFRS(TotalUS_MNUMCR, NEMSmap_MNUMYR(ModelYear));
				!MPBLK_PNGCM(TotalUS_MNUMCR, NEMSmap_MNUMYR(ModelYear)):= sum(MNUMC2, MPBLK_PNGCM(MNUMC2, NEMSmap_MNUMYR(ModelYear))*QBLK_QGFCM(MNUMC2,NEMSmap_MNUMYR(ModelYear)))/$
				!                                                  QBLK_QGFCM(TotalUS_MNUMCR, NEMSmap_MNUMYR(ModelYear));
				!MPBLK_PNGIN(TotalUS_MNUMCR, NEMSmap_MNUMYR(ModelYear)):= sum(MNUMC2, MPBLK_PNGIN(MNUMC2, NEMSmap_MNUMYR(ModelYear))*
				!                                                (QBLK_QGFIN(MNUMC2,NEMSmap_MNUMYR(ModelYear))+QBLK_QGIIN(MNUMC2,NEMSmap_MNUMYR(ModelYear))))/$
				!                                                  (QBLK_QGFIN(TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear))+QBLK_QGIIN(TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear)));
				!MPBLK_PNGEL(TotalUS_MNUMCR, NEMSmap_MNUMYR(ModelYear)):=sum((NNGEMM,M3), NGTDMOUT_SPNGELGR(NNGEMM, NEMSmap_MNUMYR(ModelYear), M3)*UEFDOUT_SQNGELGR(NNGEMM,NEMSmap_MNUMYR(ModelYear),M3))/$
				!                                                sum((NNGEMM,M3), UEFDOUT_SQNGELGR(NNGEMM,NEMSmap_MNUMYR(ModelYear),M3));
				!NGTDMOUT_PGFTRFV(TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(MNUMC2, NGTDMOUT_PGFTRFV(MNUMC2, NEMSmap_MNUMYR(ModelYear))*NGTDMOUT_QGFTRFV(MNUMC2,NEMSmap_MNUMYR(ModelYear)))/$
				!                                                 NGTDMOUT_QGFTRFV(TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear));
				!NGTDMOUT_PGFTRPV(TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(MNUMC2, NGTDMOUT_PGFTRPV(MNUMC2, NEMSmap_MNUMYR(ModelYear))*NGTDMOUT_QGFTRPV(MNUMC2,NEMSmap_MNUMYR(ModelYear)))/$
				!                                                 NGTDMOUT_QGFTRPV(TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear));
				!NGTDMOUT_PGLTRFV(TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(MNUMC2, NGTDMOUT_PGLTRFV(MNUMC2, NEMSmap_MNUMYR(ModelYear))*NGTDMOUT_QGLTRFV(MNUMC2,NEMSmap_MNUMYR(ModelYear)))/$
				!                                                 NGTDMOUT_QGLTRFV(TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear));
				!NGTDMOUT_PGLTRPV(TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(MNUMC2, NGTDMOUT_PGLTRPV(MNUMC2, NEMSmap_MNUMYR(ModelYear))*NGTDMOUT_QGLTRPV(MNUMC2,NEMSmap_MNUMYR(ModelYear)))/$
				!                                                 NGTDMOUT_QGLTRPV(TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear));
				!NGTDMOUT_PGFTRRAIL(M4,TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(MNUMC2, NGTDMOUT_PGFTRRAIL(M4,MNUMC2, NEMSmap_MNUMYR(ModelYear))*NGTDMOUT_QGFTRRAIL(M4,MNUMC2,NEMSmap_MNUMYR(ModelYear)))/$
				!                                                 NGTDMOUT_QGFTRRAIL(M4,TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear));
				!NGTDMOUT_PGLTRRAIL(M4,TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(MNUMC2, NGTDMOUT_PGFTRRAIL(M4,MNUMC2, NEMSmap_MNUMYR(ModelYear))*NGTDMOUT_QGFTRRAIL(M4,MNUMC2,NEMSmap_MNUMYR(ModelYear)))/$
				!                                                 NGTDMOUT_QGFTRRAIL(M4,TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear));
				!NGTDMOUT_PGFTRSHIP(M3,TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(MNUMC2, NGTDMOUT_PGFTRSHIP(M3,MNUMC2, NEMSmap_MNUMYR(ModelYear))*NGTDMOUT_QGFTRSHIP(M3,MNUMC2,NEMSmap_MNUMYR(ModelYear)))/$
				!                                                 NGTDMOUT_QGFTRSHIP(M3,TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear));
				!NGTDMOUT_PGLTRSHIP(M3,TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear)) := sum(MNUMC2, NGTDMOUT_PGLTRSHIP(M3,MNUMC2, NEMSmap_MNUMYR(ModelYear))*NGTDMOUT_QGLTRSHIP(M3,MNUMC2,NEMSmap_MNUMYR(ModelYear)))/$
				!                                                 NGTDMOUT_QGLTRSHIP(M3,TotalUS_MNUMCR,NEMSmap_MNUMYR(ModelYear));
				!
				!MPBLK_PNGTR(TotalUS_MNUMCR, NEMSmap_MNUMYR(ModelYear)):=sum(MNUMC2, MPBLK_PNGTR(MNUMC2, NEMSmap_MNUMYR(ModelYear))*QBLK_QGFTR(MNUMC2,NEMSmap_MNUMYR(ModelYear)))/$
				!                                                  QBLK_QGFTR(TotalUS_MNUMCR, NEMSmap_MNUMYR(ModelYear));
				!
				!MPBLK_PGFIN(MNUMCR, NEMSmap_MNUMYR(ModelYear)):= MPBLK_PNGIN(MNUMCR, NEMSmap_MNUMYR(ModelYear));
				!MPBLK_PGIIN(MNUMCR, NEMSmap_MNUMYR(ModelYear)):= MPBLK_PNGIN(MNUMCR, NEMSmap_MNUMYR(ModelYear));
				!
			}
		}
		Procedure EndUsePrice_Initialize {
			Body: {
				!Assign historical values to price arrays
				Price_Spot(datamon,state) := HistoricalSpotPrice(datamon,state);
				!NEWNEWNEW
				PriceSpotAnnualState(datayear,l48) := sum((datamon,sec)| map_month_year(datamon,datayear), Price_Spot(datamon,l48)*
				     Cons_State_Mon(datamon,sec, l48))/$
				     sum(sec,Cons_State_Yr(datayear, sec, l48));
				Price_Citygate(datamon,state) := HistoricalCitygatePrice(datamon,state);
				
				!Set regional TX citygate prices.
				!OPTION 1:
				!Use the TX citygate price as a base, adjusted by the ratio of the regional spot price to TX spot price.
				! Limiting change to +- 50% though since Waha price can be very strange at times
				!TXPriceAdjustmentFactor(datamon, r_tx) :=  Price_Spot(datamon, r_tx) /$ Price_Spot(datamon, TexasState);
				!TXPriceAdjustmentFactor(datamon, r_tx | TXPriceAdjustmentFactor(datamon, r_tx)>1.25 ) := 1.25;
				!TXPriceAdjustmentFactor(datamon, r_tx | TXPriceAdjustmentFactor(datamon, r_tx)<0.8 and TXPriceAdjustmentFactor(datamon, r_tx) <> 0 ) := 0.8;
				!Price_Citygate(datamon, r_tx) := TXPRiceAdjustmentFactor(datamon, r_tx) * Price_Citygate(datamon, TexasState);
				
				! OPTION 2:
				! Simply set the TX citygate price to the regional TX citygate prices
				Price_Citygate(datamon, r_tx) := Price_Citygate(datamon, TexasState);
				
				PriceCitygateAnnualState(datayear,l48) := sum(datamon| map_month_year(datamon,datayear), Price_Citygate(datamon,l48)*
				     (Cons_State_Mon(datamon, Sector_Residential, l48) + Cons_State_Mon(datamon, Sector_Commercial, l48)))/$
				     (Cons_State_Yr(datayear, Sector_Residential, l48) + Cons_State_Yr(datayear, Sector_Commercial, l48));
				
				
				!Average annual Census Division citygate price for Res and Com sectors
				!(AK is included in citygate price calculation for Pacific region)
				PriceCitygateAnnualforMarkups(datayear,rescom,r_cen,Option1) := sum((datamon,state) | map_month_year(datamon,datayear) and map_State_CensusRegion(state, r_cen), Price_Citygate(datamon,state)*
				     (HistoricalDemand(datamon, Sector_Residential, state) + HistoricalDemand(datamon, Sector_Commercial, state)))/$
				     sum((datamon,state) |map_month_year(datamon,datayear) and map_State_CensusRegion(state, r_cen),
				     (HistoricalDemand(datamon, Sector_Residential, state) + HistoricalDemand(datamon, Sector_Commercial, state)));
				PriceCitygateAnnualforMarkups(datayear,rescom,r_cen,opt):=PriceCitygateAnnualforMarkups(datayear,rescom,r_cen,Option1);
				PriceCitygateAnnualforMarkups(datayear,Sector_Transportation,r_cen,opt) :=PriceCitygateAnnualforMarkups(datayear,Sector_Commercial,r_cen,opt);
				
				!Average annual Census Division industrial spot price
				!(AK is not included in Pacific spot price because there is no data for AK spot prc)
				PriceCitygateAnnualforMarkups(datayear,Sector_Industrial,r_cen,Option2) := sum((datamon,l48) | map_month_year(datamon,datayear) * map_State_CensusRegion(l48, r_cen),
				      Price_Spot(datamon,l48)*HistoricalDemand(datamon, Sector_Industrial, l48) )/$
				     sum(l48 | map_State_CensusRegion(l48, r_cen), HistoricalAnnualDemand(datayear,Sector_Industrial,l48) );
				PriceCitygateAnnualforMarkups(datayear,Sector_Industrial,r_cen,Option1) := PriceCitygateAnnualforMarkups(datayear,Sector_Industrial,r_cen,Option2);
				PriceCitygateAnnualforMarkups(datayear,Sector_Industrial,r_cen,Option3) :=  PriceCitygateAnnualforMarkups(datayear,Sector_Residential,r_cen,Option1);
				
				!Average annual NNGEMM electric spot price
				!PriceSpotAnnualElectric(datayear, NNGEMM, season) := sum((datamon,l48),
				!     Price_Spot(datamon,l48)*HistoricalDemand(datamon, Sector_Electric, l48)*map_month_year(datamon,datayear) * map_mon_season(datamon,season) * map_l48_NNGEMM(l48,NNGEMM) )/$
				!     sum((datamon,l48), HistoricalDemand(datamon, Sector_Electric, l48)*map_month_year(datamon,datayear) * map_mon_season(datamon,season) * map_l48_NNGEMM(l48,NNGEMM));
				PriceSpotAnnualElectric(datayear, NNGEMM, season) := sum((datamon,l48) | map_month_year(datamon,datayear) and map_mon_season(datamon,season) and map_State_NNGEMM(l48,NNGEMM),
				     Price_Spot(datamon,l48)*HistoricalDemand(datamon, Sector_Electric, l48) )/$
				     sum((datamon,l48)  | map_month_year(datamon,datayear) and map_mon_season(datamon,season) and map_State_NNGEMM(l48,NNGEMM), HistoricalDemand(datamon, Sector_Electric, l48));
				
				
				
				!Average annual Census Division  spot price
				PriceSpotAnnualCD(datayear,r_cen) := sum((datamon,l48), Price_Spot(datamon,l48)*TotalConsumption(datamon, l48)* map_month_year(datamon,datayear) * map_State_CensusRegion(l48, r_cen) )/$
				     sum((datamon,l48), TotalConsumption(datamon, l48)* map_month_year(datamon,datayear) * map_State_CensusRegion(l48, r_cen) );
				
				
				!Calculate historcal markup
				Markups_Enduse(datayear,sec,r_cen,opt) := HistoricalAnnualEndUseCDPrice(datayear, sec, r_cen)-PriceCitygateAnnualforMarkups(datayear,sec,r_cen,opt);
				!Calculate historcal electric markup
				
				Markups_EnduseElectric(datayear, NNGEMM, season, opt):= HistoricalAnnualEndUseNNGEMMPrice(datayear, NNGEMM, season)-PriceSpotAnnualElectric(datayear, NNGEMM, season);
				!Calculate average fixed industrial markup
				AverageMarkupIND(r_cen):= sum(yr_ind, Markups_Enduse(yr_ind, Sector_Industrial, r_cen, Option1))/card(Year_IND_);
				!Calculate average fixed electric markup
				AverageMarkupElectric(NNGEMM, season):= sum(yr_el, Markups_EnduseElectric(yr_el,  NNGEMM, season, Option1))/card(Year_EL_);
				
				
				
				!Fill in end use price array
				Price_Enduse(datayear, sec, r_cen, opt) := HistoricalAnnualEndUseCDPrice(datayear, sec, r_cen);
				Price_EnduseElectric(datayear, NNGEMM, season, opt) := HistoricalAnnualEndUseNNGEMMPrice(datayear, NNGEMM, season);
				AnnualPrice_EnduseElectric(datayear,NNGEMM) := sum (season, Price_EnduseElectric(datayear, NNGEMM, season, ElectricOption)*HistoricalElectricDemand(datayear,NNGEMM,season))/$
				                                           sum(season,HistoricalElectricDemand(datayear,NNGEMM,season));
				AveragePrice_EnduseElectric(datayear) := sum((NNGEMM,season), Price_EnduseElectric(datayear, NNGEMM, season, ElectricOption)*HistoricalElectricDemand(datayear,NNGEMM,season))/$
				                                           sum((NNGEMM,season), HistoricalElectricDemand(datayear,NNGEMM,season));
				
				
				
				!Calculate flat transportation sector markups and fill in Transportation NEMS arrays
				EndUsePrice_TransCost_Initialize;
				EndUsePrice_TransNEMS_Initialize;
				EndUsePrice_Trans_InitializePrices;
				
				!Moved to Write_to_NEMS_History
				!!Initialize NEMS Arrays
				!EndUsePrice_NEMS_Initialize;
				
				!!!NEW NEW NEW
				PriceSpotAnnualIndustrial(datayear, r_cen):= sum((datamon,l48) | map_State_CensusRegion(l48, r_cen) and map_month_year(datamon,datayear), 
				     Price_Spot(datamon,l48)*HistoricalDemand(datamon, Sector_Industrial, l48))/$ 
				     sum(l48 | map_State_CensusRegion(l48, r_cen), HistoricalAnnualDemand(datayear,Sector_Industrial,l48) );
				DifferenceCitygateSpotCD(datayear,r_cen) := PriceCitygateAnnualforMarkups(datayear,Sector_Residential,r_cen,Option1) - PriceSpotAnnualCD(datayear,r_cen);
				
				SectorOption(Sector_Commercial):=CommercialOption;
				SectorOption(Sector_Residential):=ResidentialOption;
				SectorOption(Sector_Industrial):=IndustrialOption;
				SectorOption(Sector_Electric):=ElectricOption;
			}
		}
		Procedure EndUseMarkups_Residential {
			Body: {
				!Option 1
				!Markups_Enduse(ModelYear,Sector_Residential,r_cen,Option1) := exp(DIV_RES(r_cen, Option1))*
				 !      ((NEMS_Consumption(ModelYear,Sector_Residential,r_cen)/Households(ModelYear, r_cen))^PAR1_RES(Option1) )*
				!       (Markups_Enduse(ModelYear-1,Sector_Residential,r_cen,Option1)^PAR2_RES(Option1))*
				!       exp(DIV_RES(r_cen, Option1)* (-PAR2_RES(Option1)))*
				!       ((NEMS_Consumption(ModelYear-1,Sector_Residential,r_cen)/Households(ModelYear-1, r_cen))^(PAR1_RES(Option1)*(-PAR2_RES(Option1)) ));
				Markups_Enduse(ModelYear,Sector_Residential,r_cen,Option1) := DIV_RES(r_cen, Option1) + 
					PAR1_RES_CD(r_cen, Option1)*(NEMS_Consumption(ModelYear,Sector_Residential,r_cen)/Households(ModelYear, r_cen))+
					PAR2_RES_CD(r_cen, Option1)*(NEMS_Consumption(ModelYear,Sector_Residential,r_cen)/HDD(ModelYear, r_cen))
					;
				
				
				!Option 2
				Markups_Enduse(ModelYear,Sector_Residential,r_cen,Option2) := DIV_RES(r_cen, Option2) + PAR1_RES(Option2)*(NEMS_Consumption(ModelYear,Sector_Residential,r_cen)/Households(ModelYear, r_cen))+
				      PAR2_RES(Option2)*(Markups_Enduse(ModelYear-1,Sector_Residential,r_cen,Option2) - DIV_RES(r_cen, Option2) -
				      PAR1_RES(Option2)*(NEMS_Consumption(ModelYear-1,Sector_Residential,r_cen)/Households(ModelYear-1, r_cen)));
				!Option 3
				Markups_Enduse(ModelYear,Sector_Residential,r_cen,Option3) := exp(DIV_RES(r_cen, Option3))*
				       ((NEMS_Consumption(ModelYear,Sector_Residential,r_cen)/Households(ModelYear, r_cen))^PAR1_RES(Option3) )*
				       (NEMS_Consumption(ModelYear,Sector_Residential,r_cen)^PAR2_RES(Option3))*
				       (Markups_Enduse(ModelYear-1,Sector_Residential,r_cen,Option3)^PAR3_RES(Option3))*
				       exp(DIV_RES(r_cen, Option3)* (-PAR3_RES(Option3)))*
				       ((NEMS_Consumption(ModelYear-1,Sector_Residential,r_cen)/Households(ModelYear-1, r_cen))^(PAR1_RES(Option3)*(-PAR3_RES(Option3)) ))*
				       (NEMS_Consumption(ModelYear-1,Sector_Residential,r_cen)^(PAR2_RES(Option3)*(-PAR3_RES(Option3)) ));
				!Option 4
				Markups_Enduse(ModelYear,Sector_Residential,r_cen,Option4) := DIV_RES(r_cen, Option4) + PAR1_RES(Option4)*(NEMS_Consumption(ModelYear,Sector_Residential,r_cen)/Households(ModelYear, r_cen))+
				         PAR2_RES(Option4)*Households(ModelYear, r_cen);
			}
		}
		Procedure EndUseMarkups_Commercial {
			Body: {
				!Option 1
				!Markups_Enduse(ModelYear,Sector_Commercial,r_cen,Option1) := exp(DIV_COM(r_cen, Option1))*
				 !      ((NEMS_Consumption(ModelYear,Sector_Commercial,r_cen)/Floorspace(ModelYear, r_cen))^PAR1_COM(Option1) )*
				  !     (Floorspace(ModelYear, r_cen)^PAR2_COM(Option1))*
				 !      (Markups_Enduse(ModelYear-1,Sector_Commercial,r_cen,Option1)^PAR3_COM(Option1))*
				  !     exp(DIV_COM(r_cen, Option1)* (-PAR3_COM(Option1)))*
				 !      ((NEMS_Consumption(ModelYear-1,Sector_Commercial,r_cen)/Floorspace(ModelYear-1, r_cen))^(PAR1_COM(Option1)*(-PAR3_COM(Option1)) ))*
				 !      (Floorspace(ModelYear-1, r_cen)^(PAR2_COM(Option1)* (-PAR3_COM(Option1))));
				Markups_Enduse(ModelYear,Sector_Commercial,r_cen,Option1) := DIV_COM(r_cen, Option1) + 
					PAR1_COM_CD(r_cen,Option1)*(NEMS_Consumption(ModelYear,Sector_Commercial,r_cen)/Floorspace(ModelYear, r_cen))+
				       PAR2_COM_CD(r_cen,Option1)*NEMS_Consumption(ModelYear,Sector_Commercial,r_cen);
				
				!Option 2 (temporarily commenting out to avoid negative numbers causing issues)
				!Markups_Enduse(ModelYear,Sector_Commercial,r_cen,Option2) := exp(DIV_COM(r_cen, Option2))*
				!       ((NEMS_Consumption(ModelYear,Sector_Commercial,r_cen)/Floorspace(ModelYear, r_cen))^PAR1_COM(Option2) )*
				!       (NEMS_Consumption(ModelYear,Sector_Commercial,r_cen)^PAR2_COM(Option2))*
				!       (Markups_Enduse(ModelYear-1,Sector_Commercial,r_cen,Option2)^PAR3_COM(Option2))*
				!       exp(DIV_COM(r_cen, Option2)* (-PAR3_COM(Option2)))*
				!       ((NEMS_Consumption(ModelYear-1,Sector_Commercial,r_cen)/Floorspace(ModelYear-1, r_cen))^(PAR1_COM(Option2)*(-PAR3_COM(Option2)) ))*
				!       (NEMS_Consumption(ModelYear-1,Sector_Commercial,r_cen)^(PAR2_COM(Option2)* (-PAR3_COM(Option2))));
				!Option 3
				Markups_Enduse(ModelYear,Sector_Commercial,r_cen,Option3) := DIV_COM(r_cen, Option3) + PAR1_COM(Option3)*(NEMS_Consumption(ModelYear,Sector_Commercial,r_cen)/Floorspace(ModelYear, r_cen))+
				       PAR2_COM(Option3)*Floorspace(ModelYear, r_cen) + PAR3_COM(Option3)*
				       (Markups_Enduse(ModelYear-1,Sector_Commercial,r_cen,Option3) - DIV_COM(r_cen, Option3) - PAR1_COM(Option3)*(NEMS_Consumption(ModelYear-1,Sector_Commercial,r_cen)/Floorspace(ModelYear-1, r_cen)) -
				        PAR2_COM(Option3)*Floorspace(ModelYear-1, r_cen));
				
				!Option 4
				Markups_Enduse(ModelYear,Sector_Commercial,r_cen,Option4) := DIV_COM(r_cen, Option4) + PAR1_COM(Option4)*(NEMS_Consumption(ModelYear,Sector_Commercial,r_cen)/Floorspace(ModelYear, r_cen))+
				       PAR2_COM(Option4)*NEMS_Consumption(ModelYear,Sector_Commercial,r_cen) + PAR3_COM(Option4) * (Markups_Enduse(ModelYear-1,Sector_Commercial,r_cen,Option4) - DIV_COM(r_cen, Option4) -
				       PAR1_COM(Option4)*(NEMS_Consumption(ModelYear-1,Sector_Commercial,r_cen)/Floorspace(ModelYear-1, r_cen)) - PAR2_COM(Option4)*NEMS_Consumption(ModelYear-1,Sector_Commercial,r_cen));
			}
			Comment: {
				"markup(r,t) = DIV(r) + PAR1*(consumption(r,t)/floorspace(r,t)) + PAR2 *consumption(r,t) +
				!            PAR3 * [DIV(r) + PAR1*(consumption(r,t-1)/floorspace(r,t-1)) + PAR2 * consumption(r,t-1) ]"
			}
		}
		Procedure EndUseMarkups_Industrial {
			Body: {
				!option 1
				Markups_Enduse(ModelYear, Sector_Industrial, r_cen, Option1):= AverageMarkupIND(r_cen);
				
				!option 2
				Markups_Enduse(ModelYear, Sector_Industrial, r_cen, Option2):= DIV_IND(r_cen, Option2) + PAR1_IND(Option2)* NEMS_Consumption(ModelYear,Sector_Industrial,r_cen) +
				         PAR2_IND(Option2)*( Markups_Enduse(ModelYear-1, Sector_Industrial, r_cen, Option2) - DIV_IND(r_cen, Option2) - PAR1_IND(Option2)* NEMS_Consumption(ModelYear-1,Sector_Industrial,r_cen) );
				!option 3
				Markups_Enduse(ModelYear, Sector_Industrial, r_cen, Option3):= DIV_IND(r_cen, Option3) + PAR1_IND(Option3)* NEMS_Consumption(ModelYear,Sector_Industrial,r_cen) +
				         PAR2_IND(Option3)*( Markups_Enduse(ModelYear-1, Sector_Industrial, r_cen, Option3) - DIV_IND(r_cen, Option3) - PAR1_IND(Option3)* NEMS_Consumption(ModelYear-1,Sector_Industrial,r_cen) );
			}
		}
		Procedure EndUsePrice_Transportation {
			Body: {
				!Now done in EndUse_Consumption_Run
				!Update Consumption values for assigning NEMS prices later
				!EndUsePrice_Trans_UpdateConsumption;
				
				!Option 1 Cost analysis markups-Marking up off of Citygate
				!For road vehicles- fleet and personal
				Price_EndUseTransportation(ModelYear,fuel,vehicle_r,r_cen,Option1)  :=
					Trans_CostMarkup(fuel,vehicle_r) + Tax_Federal(ModelYear,fuel) + (Tax_State(fuel, r_cen)/GDPPriceDeflator87(ModelYear))
					+ (1+Trans_PctFuelLoss(fuel,vehicle_r))* PriceCitygateAnnualforMarkups(ModelYear,Sector_Transportation,r_cen,Option1);
				
				!For rail- DO NOT INCLUDE ANY TAXES
				Price_EndUseTransportation(ModelYear,fuel,Vehicle_Rail,r_cen,Option1)  :=
					Trans_CostMarkup(fuel,Vehicle_Rail)
					+ (1+Trans_PctFuelLoss(fuel,Vehicle_Rail))* PriceCitygateAnnualforMarkups(ModelYear,Sector_Transportation,r_cen,Option1);
				
				!For marine- DO NOT INCLUDE ANY STATE TAXES- Federal included
				Price_EndUseTransportation(ModelYear,fuel,Vehicle_Marine,r_cen,Option1)  :=
					Trans_CostMarkup(fuel,Vehicle_Marine) + Tax_Federal(ModelYear,fuel)
					+ (1+Trans_PctFuelLoss(fuel,Vehicle_Marine))* PriceCitygateAnnualforMarkups(ModelYear,Sector_Transportation,r_cen,Option1);
				
				
				!Option 2 Cost analysis markups-Marking up off of ELECTRIC
				!For road vehicles- fleet and personal
				Price_EndUseTransportation(ModelYear,fuel,vehicle_r,r_cen,Option2)  :=
					Trans_CostMarkup(fuel,vehicle_r) + Tax_Federal(ModelYear,fuel) + (Tax_State(fuel, r_cen)/GDPPriceDeflator87(ModelYear))
					+ (1+Trans_PctFuelLoss(fuel,vehicle_r))* AveragePrice_EnduseElectric(ModelYear);
				
				!Formerly AveragePrice_EnduseElectric; keep here in case there are issues
				!	(sum((NNGEMM,M3), NGTDMOUT_SPNGELGR(NNGEMM, NEMSmap_MNUMYR(ModelYear), M3)*UEFDOUT_SQNGELGR(NNGEMM,NEMSmap_MNUMYR(ModelYear),M3))/$
				!                                               sum((NNGEMM,M3), UEFDOUT_SQNGELGR(NNGEMM,NEMSmap_MNUMYR(ModelYear),M3)));
				
				!For rail- DO NOT INCLUDE ANY TAXES
				Price_EndUseTransportation(ModelYear,fuel,Vehicle_Rail,r_cen,Option2)  :=
					Trans_CostMarkup(fuel,Vehicle_Rail)
					+ (1+Trans_PctFuelLoss(fuel,Vehicle_Rail))* AveragePrice_EnduseElectric(ModelYear);
				
				!For marine- DO NOT INCLUDE ANY STATE TAXES- Federal included
				Price_EndUseTransportation(ModelYear,fuel,Vehicle_Marine,r_cen,Option2):=
					Trans_CostMarkup(fuel,Vehicle_Marine) + Tax_Federal(ModelYear,fuel)
					+ (1+Trans_PctFuelLoss(fuel,Vehicle_Marine))* AveragePrice_EnduseElectric(ModelYear);
				
				
				
				!Option 3 Cost analysis markups-Marking up off of Industrial
				!For road vehicles- fleet and personal
				Price_EndUseTransportation(ModelYear,fuel,vehicle_r,r_cen,Option3)  :=
					Trans_CostMarkup(fuel,vehicle_r) + Tax_Federal(ModelYear,fuel) + (Tax_State(fuel, r_cen)/GDPPriceDeflator87(ModelYear))
					+ (1+Trans_PctFuelLoss(fuel,vehicle_r))* Price_Enduse(ModelYear, Sector_Industrial, r_cen, IndustrialOption);
				
				!For rail- DO NOT INCLUDE ANY TAXES
				Price_EndUseTransportation(ModelYear,fuel,Vehicle_Rail,r_cen,Option3)  :=
					Trans_CostMarkup(fuel,Vehicle_Rail)
					+ (1+Trans_PctFuelLoss(fuel,Vehicle_Rail))* Price_Enduse(ModelYear, Sector_Industrial, r_cen, IndustrialOption);
				
				!For marine- DO NOT INCLUDE ANY STATE TAXES- Federal included
				Price_EndUseTransportation(ModelYear,fuel,Vehicle_Marine,r_cen,Option3)  :=
					Trans_CostMarkup(fuel,Vehicle_Marine) + Tax_Federal(ModelYear,fuel)
					+ (1+Trans_PctFuelLoss(fuel,Vehicle_Marine))* Price_Enduse(ModelYear, Sector_Industrial, r_cen, IndustrialOption);
				
				!Option 4 Cost analysis markups-Marking up using EERE derived tariff
				!For rail and marine, just assign Option 3
				
				!For road vehicles- fleet and personal
				Price_EndUseTransportation(ModelYear,fuel,vehicle_r,r_cen,Option4)  :=
					Trans_CostMarkup(fuel,vehicle_r) +Trans_Tariff(fuel,vehicle_r,r_cen)+ Tax_Federal(ModelYear,fuel) + (Tax_State(fuel, r_cen)/GDPPriceDeflator87(ModelYear))
					+ (1+Trans_PctFuelLoss(fuel,vehicle_r))* PriceCitygateAnnualforMarkups(ModelYear,Sector_Transportation,r_cen,Option1);
				
				!For rail- DO NOT INCLUDE ANY TAXES
				Price_EndUseTransportation(ModelYear,fuel,Vehicle_Rail,r_cen,Option4)  := Price_EndUseTransportation(ModelYear,fuel,Vehicle_Rail,r_cen,Option3);
				
				
				!For marine- DO NOT INCLUDE ANY STATE TAXES- Federal included
				Price_EndUseTransportation(ModelYear,fuel,Vehicle_Marine,r_cen,Option4)  :=Price_EndUseTransportation(ModelYear,fuel,Vehicle_Marine,r_cen,Option3);
				
				
				
				
				
				!Option 1 Eviews Estimation
				!Markups_Enduse(ModelYear,Sector_Transportation,r_cen,Option1) := (DIV_TRANS(r_cen) + LAG_TRANS * (Markups_Enduse(ModelYear-1,Sector_Transportation,r_cen,Option1)))
				!	+  Tax_Federal(LastHistoricalYear,Fuel_CNG) + Tax_State(Fuel_CNG, r_cen);
			}
			Comment: {
				"!Does not include fuel lost.  This will be done in EndUsePrice"
			}
		}
		Procedure EndUsePrice_Electric {
			Body: {
				!option 1
				 !Consumption of all sectors but electric by NNGEMM regions and 3 seasons
				QOTHER(ModelYear,NNGEMM,season):=sum((modelyrmn,sec,state), Cons_State_Mon(modelyrmn,sec,state)*map_mon_season(modelyrmn,season)*map_State_NNGEMM(state,NNGEMM))
					- NEMS_Consumption_EMM(ModelYear,NNGEMM,season);
				!QOTHER(ModelYear,NNGEMM,season):=sum((modelyrmn,sec,state), Cons_State_Mon(modelyrmn,sec,state)*map_mon_season(modelyrmn,season)*map_State_NNGEMM(state,NNGEMM));
				if ModelYear = FirstModelYear then
				  Markups_EnduseElectric((ModelYear, NNGEMM, season, Option1) | NNGEMM<>'17'):= AverageMarkupElectric(NNGEMM, season);
				else
				  ConsumptionGrowthFactor( (ModelYear,NNGEMM,season) | NNGEMM<>'17') := (1+ (NEMS_Consumption_EMM(ModelYear,NNGEMM,season)-NEMS_Consumption_EMM(ModelYear-1,NNGEMM,season))/$
				              NEMS_Consumption_EMM(ModelYear,NNGEMM,season))/(1+ (QOTHER(ModelYear,NNGEMM,season)-QOTHER(ModelYear-1,NNGEMM,season))/QOTHER(ModelYear-1,NNGEMM,season));
				   !Overwrite consumption growth factor if it is <0.5 or >2, and create an entry in NGATTENTION.txt file
				   ConsumptionGrowthFactor(ModelYear,NNGEMM,season) := min(ConsumptionGrowthFactor(ModelYear,NNGEMM,season),2);
				   ConsumptionGrowthFactor(ModelYear,NNGEMM,season) := max(ConsumptionGrowthFactor(ModelYear,NNGEMM,season), 0.5);
				!   write ConsumptionGrowthFactor( (ModelYear,NNGEMM,season) | ConsumptionGrowthFactor(ModelYear,NNGEMM,season)=0.5 or ConsumptionGrowthFactor(ModelYear,NNGEMM,season)=2 ) to file "NGATTENTION.txt" in merge mode;
				
				!   Markups_EnduseElectric(ModelYear, NNGEMM, season, Option1):= (Markups_EnduseElectric(ModelYear-1, NNGEMM, season, Option1) + PriceSpotAnnualElectric(ModelYear, NNGEMM, season))*
				!       ( (1+ (NEMS_Consumption_EMM(ModelYear,NNGEMM,season)-NEMS_Consumption_EMM(ModelYear-1,NNGEMM,season))/NEMS_Consumption_EMM(ModelYear,NNGEMM,season))/
				!       (1+ (QOTHER(ModelYear,NNGEMM,season)-QOTHER(ModelYear-1,NNGEMM,season))/QOTHER(ModelYear,NNGEMM,season)) )^Factor_EL - PriceSpotAnnualElectric(ModelYear, NNGEMM, season);
				   Markups_EnduseElectric((ModelYear, NNGEMM, season, Option1) | NNGEMM<>'17'):= (Markups_EnduseElectric(ModelYear-1, NNGEMM, season, Option1) + PriceSpotAnnualElectric(ModelYear, NNGEMM, season))*
				      ConsumptionGrowthFactor(ModelYear, NNGEMM, season)^Factor_EL - PriceSpotAnnualElectric(ModelYear, NNGEMM, season);
				endif;
				Price_EnduseElectric(ModelYear, NNGEMM, season, Option1):= Markups_EnduseElectric(ModelYear, NNGEMM, season, Option1) + PriceSpotAnnualElectric(ModelYear, NNGEMM, season);
				!option 2
				Price_EnduseElectric(ModelYear, NNGEMM, season, Option2):= DIV_EL(NNGEMM, season, Option2) + PAR1_EL(season, Option2) * PriceSpotAnnualElectric(ModelYear, NNGEMM, season);
				!option 3
				Price_EnduseElectric(ModelYear, NNGEMM, season, Option3):= DIV_EL(NNGEMM, season, Option3) + PAR1_EL(season, Option3) * PriceSpotAnnualElectric(ModelYear, NNGEMM, season) +
				        PAR2_EL(season, Option3) * NEMS_Consumption_EMM(ModelYear,NNGEMM,season);
				
				if (Exists((NNGEMM,season)|Price_EnduseElectric(ModelYear, NNGEMM, season, ElectricOption) >= Error_PriceCheck)) then
					!write Price_EnduseElectric((ModelYear, NNGEMM, season, ElectricOption)|Price_EnduseElectric(ModelYear, NNGEMM, season, ElectricOption) >= Error_PriceCheck )  to file "NGATTENTION.txt" in merge mode;
					!RAISE WARNING " Electric End Use price is over Price cap; See NGATTENTION.txt for details." CODE 'ElPriceChk';
					for ((NNGEMM,season)|Price_EnduseElectric(ModelYear, NNGEMM, season, ElectricOption) >= Error_PriceCheck) do
						Price_EnduseElectric(ModelYear, NNGEMM, season, ElectricOption):=Error_PriceCheck;
					endfor;
				endif;
				
				
				
				!Alaska
				Price_EnduseElectric(ModelYear, '17', season, opt):= AK_Price_EndUse(ModelYear, Sector_Electric);
				AnnualPrice_EnduseElectric(ModelYear,NNGEMM) := sum (season, Price_EnduseElectric(ModelYear, NNGEMM, season, ElectricOption)*NEMS_Consumption_EMM(ModelYear,NNGEMM,season))/
				                                           sum(season, NEMS_Consumption_EMM(ModelYear,NNGEMM,season));
				AveragePrice_EnduseElectric(ModelYear) := sum((NNGEMM,season), Price_EnduseElectric(ModelYear, NNGEMM, season, ElectricOption)*NEMS_Consumption_EMM(ModelYear,NNGEMM,season))/
				                                           sum((NNGEMM,season), NEMS_Consumption_EMM(ModelYear,NNGEMM,season));
			}
			Comment: "price(r,s,t) = DIV(r,s) + PAR1(s)*spot price(r,s,t) + PAR2(s)*consumption(r,s,t)";
			DeclarationSection Local_Declaration;
		}
	}
	Section Flows_Section {
		DeclarationSection Flow_Declarations {
			Parameter FlowsAnnual {
				IndexDomain: (year,h,h1);
			}
			Parameter FlowsAnnualNet {
				IndexDomain: (year,h,h1);
				Definition: FlowsAnnual(year,h,h1)-FlowsAnnual(year,h1,h);
			}
			Parameter FlowsAnnualHistSolution {
				IndexDomain: (datayear,h,h1);
			}
			Parameter FlowsMonthly {
				IndexDomain: (mon,h,h1);
			}
			Parameter FlowsAdjust {
				IndexDomain: (h,h1);
				Range: binary;
			}
			Parameter FlowsZeroOut {
				IndexDomain: (h,h1);
			}
			Parameter FlowsPrimary {
				IndexDomain: (histyr, h,h1);
				Comment: "Flag to indicate primary flow";
			}
			Parameter FlowsSecondary {
				IndexDomain: (histyr, h,h1);
				Comment: "Flag to indicate primary flow";
			}
			Parameter FlagBidirectionalFlows {
				IndexDomain: (h,h1);
			}
			Parameter FlagBidirectionalFlows_Secondary {
				IndexDomain: (h,h1);
			}
			Parameter FlagArcsToResetTariff {
				IndexDomain: (h,h1);
			}
			Parameter LastDataYearFlg_Flow {
				IndexDomain: year;
			}
		}
		DeclarationSection Flow_PostProcessing_Identifiers {
			Parameter FlowsRegional {
				IndexDomain: (year,r_og, r_og1);
			}
			Parameter FlowRegional {
				IndexDomain: (year,r_flow, r_flow1);
			}
			Parameter HistoricalFlowsRegional {
				IndexDomain: (year,r_og,r_og1);
			}
			Parameter HistoricalFlowRegional {
				IndexDomain: (year,r_flow,r_flow1);
			}
			Parameter HistoricalCapacityRegional {
				IndexDomain: (year,r_og,r_og1);
			}
			Parameter HistoricalCapRegional {
				IndexDomain: (year,r_flow,r_flow1);
			}
			Parameter NEMSmap_MNUMOR_L_48 {
				IndexDomain: (MNUMOR,l48);
				Range: binary;
			}
			Parameter NEMSmap_MNUMOR_Region_OilGas {
				IndexDomain: (MNUMOR,r_og);
				Range: binary;
			}
			Set Region_OilGas_ {
				Index: r_og, r_og1;
			}
			Set Region_Flow_ {
				Index: r_flow, r_flow1;
			}
			Parameter map_hub_Region_OilGas {
				IndexDomain: (h,r_og);
				Range: binary;
			}
			Parameter map_hub_Region_Flow {
				IndexDomain: (h,r_flow);
				Range: binary;
			}
			ElementParameter Calibrate_FlowDifferenceColor {
				IndexDomain: (h,h1);
				Range: AllColors;
			}
		}
		DeclarationSection Capacity_PostProcessing_Declarations {
			Parameter CapacityAddRegional {
				IndexDomain: (year,r_og,r_og1);
			}
			Parameter CapAddRegional {
				IndexDomain: (year,r_flow,r_flow1);
			}
			Parameter CapacityRegional {
				IndexDomain: (year,r_og,r_og1);
			}
			Parameter CapRegional {
				IndexDomain: (year,r_flow,r_flow1);
			}
		}
		Procedure Flow_InitializeData {
			Body: {
				LastHistoricalDataYear := Last(datayear | Exists((l48,l48a) | HistoricalFlowAnnual(l48,l48a,datayear)));
				LastDataYearFlg_Flow(hdatayear):=1;
				!Make adjustments to historical flows
				HistoricalFlowAnnual((h1, h, hdatayear)|FlowsAdjust(h,h1)) += HistoricalFlowAnnual(h, h1, hdatayear);
				HistoricalFlowAnnual((h, h1, hdatayear)|FlowsAdjust(h,h1)) :=0;
				HistoricalFlowAnnual((h, h1, hdatayear) | FlowsZeroOut(h, h1)) :=0;
				HistoricalFlowModel(h, h1, hdatayear):=HistoricalFlowAnnual(h, h1, hdatayear);
				HistoricalFlowIn(hdatayear, h) := sum(h1 | CapacityAnnual(hdatayear, h1, h), HistoricalFlowModel(h1, h, hdatayear));
				HistoricalFlowOut(hdatayear, h) := sum(h1 | CapacityAnnual(hdatayear, h, h1), HistoricalFlowModel(h, h1, hdatayear));
				
				!Should we do the flow adjustments before calculating the pipeline fuel factors or after?
				Losses_InitializeData;                  !Calculate historical pipeline fuel, storage and distribution losses
				PipefuelFactors_Initialize;             !Calculate pipeline fuel factors based on historical pipeline fuel losses and flows
				
				!FlowsAnnual(histyr, h, h1) := HistoricalFlowAnnual(h, h1, histyr);
				!Adjust historical flows for the QP
				FlowsAnnual((hdatayear, h, h1)  | CapacityAnnual(hdatayear, h, h1)):= HistoricalFlowAnnual(h, h1, hdatayear)*(1 + Ploss(hdatayear, h)/(1 - Ploss(hdatayear, h)));
				
				NodeFlowInAnnual(hdatayear, h) := sum(h1 | CapacityAnnual(hdatayear, h1, h), FlowsAnnual(hdatayear, h1, h));
				NodeFlowOutAnnual(hdatayear, h) := sum(h1 | CapacityAnnual(hdatayear, h, h1), FlowsAnnual(hdatayear, h, h1));
				
				FlowsPrimary((hdatayear, h, h1) | CapacityAnnual(hdatayear, h, h1) and FlowsAnnual(hdatayear, h, h1)>FlowsAnnual(hdatayear, h1, h)) :=1;
				FlowsSecondary((hdatayear, h, h1) | CapacityAnnual(hdatayear, h, h1) and FlowsAnnual(hdatayear, h1, h) and not FlowsPrimary(hdatayear, h, h1)) := 1;
			}
		}
		Procedure RegionalFlowsCapacity_InitializeData {
			Body: {
				!Calculate historical regional flows and capacities
				HistoricalFlowRegional(histyr, r_flow, r_flow1) :=	sum((h,h1)|	map_hub_Region_Flow(h,r_flow) and map_hub_Region_Flow(h1,r_flow1) and r_flow<>r_flow1 , 
											HistoricalFlowAnnual(h,h1,histyr));
				FlowRegional(histyr, r_flow, r_flow1) := HistoricalFlowRegional(histyr, r_flow, r_flow1);
				
				!HistoricalCapRegional(histyr, r_flow, r_flow1) :=	
				!	sum((h,h1)|	map_hub_Region_Flow(h,r_flow) and map_hub_Region_Flow(h1,r_flow1) and r_flow<>r_flow1 , HistoricalCapacity(h,h1,histyr));
				!Fix to have capacity in Bcf/yr not mmcf/d; Capacity_initialize must be first
				HistoricalCapRegional(histyr, r_flow, r_flow1) :=	
					sum((h,h1)|	map_hub_Region_Flow(h,r_flow) and map_hub_Region_Flow(h1,r_flow1) and r_flow<>r_flow1 , CapacityAnnual(histyr,h,h1));
				
				CapRegional(histyr, r_flow, r_flow1) :=	 HistoricalCapRegional(histyr, r_flow, r_flow1);
				
				
				!Old Regions
				!HistoricalFlowsRegional(histyr, r_og, r_og1) :=	sum((h,h1)|	map_hub_Region_OilGas(h,r_og) and map_hub_Region_OilGas(h1,r_og1) and r_og<>r_og1 , HistoricalFlowAnnual(h,h1,histyr));
				!FlowsRegional(histyr, r_og, r_og1) := HistoricalFlowsRegional(histyr, r_og, r_og1);
				
				!HistoricalCapacityRegional(histyr, r_og, r_og1) :=	
				!	sum((h,h1)|	map_hub_Region_OilGas(h,r_og) and map_hub_Region_OilGas(h1,r_og1) and r_og<>r_og1 , HistoricalCapacity(h,h1,histyr));
				!CapacityRegional(histyr, r_og, r_og1) :=	 HistoricalCapacityRegional(histyr, r_og, r_og1);
			}
			Comment: {
				"Initializing and processing historical flows and capacities, aggregating to regional totals.
				Regions are defined in ngsetmap.txt."
			}
		}
		Procedure Flow_HistPostProcess {
			Body: {
				FlowsMonthly(MonthInHistPeriod(htmon), h, h1)  := hFlowHubToHub(htmon,h,h1);
				FlowsAnnualHistSolution(HQPYear, h, h1)  := sum(htmon, hFlowHubToHub(htmon,h,h1));
				
				FlagBidirectionalFlows(h, h1):=0;
				FlagBidirectionalFlows_Secondary(h, h1):=0;
				
				FlagBidirectionalFlows((h, h1) | FlowsAnnualHistSolution(HQPYear, h, h1) and FlowsAnnualHistSolution(HQPYear, h1, h) ):=1;
				
				!if model does not solve for flows going both directions, set the target secondary flow to zero and the target primary flow to the net flow value  
				FlagArcsToResetTariff((h, h1)  | FlowsSecondary(HQPYear, h1, h) and not FlagBidirectionalFlows(h, h1)):= 1;       
				FlowsAnnual((HQPYear, h, h1)  | FlagArcsToResetTariff(h, h1)):= FlowsAnnual(HQPYear, h, h1) - FlowsAnnual(HQPYear, h1, h);
				FlowsAnnual((HQPYear, h, h1)  | FlagArcsToResetTariff(h1, h)):= 0;
				
				!Reset the primary/secondary arc flags
				FlowsPrimary((HQPYear, h, h1) | CapacityAnnual(HQPYear, h, h1) and FlowsAnnual(HQPYear, h, h1)>FlowsAnnual(HQPYear, h1, h)) :=1;
				FlowsSecondary((HQPYear, h, h1) | CapacityAnnual(HQPYear, h, h1) and FlowsAnnual(HQPYear, h1, h) and not FlowsPrimary(HQPYear, h, h1)) := 1;
				!Reset the tariff curve on the primary arcs based on the utilization implied by the net flow
				Calculate_Hist_Tariff_Adj(HQPYear, h,h1, HistoricalTariff(histyr, h, h1),FlowsAnnual(histyr, h, h1));
			}
		}
		Procedure Flow_PostProcess {
			Body: {
				FlowsMonthly((MonthInPeriod(tmon), h, h1) | map_HubArcs(h, h1)) := FlowHubToHub(tmon,h,h1);
				FlowsAnnual((ModelYear, h, h1) | map_HubArcs(h, h1))  := sum(modelyrmn, FlowsMonthly(modelyrmn, h, h1));
				!FlowsMonthly((MonthInPeriod(tmon), h, h1) | QP_Capacity(tmon, h, h1)) := FlowHubToHub(tmon,h,h1);
				!FlowsAnnual((ModelYear, h, h1) | map_HubArcs(h, h1))  := sum(modelyrmn, FlowsMonthly(modelyrmn, h, h1));
				!
			}
		}
		Procedure RegionalFlowsCapacity_PostProcess {
			Body: {
				!Assign flows to new regions based on Natural Gas Storage Regions/NGA regions
				FlowRegional(ModelYear, r_flow, r_flow1) :=	sum((h,h1)|	map_hub_Region_flow(h,r_flow) and map_hub_Region_flow(h1,r_flow1)and r_flow<>r_flow1 , FlowsAnnual(ModelYear,h,h1));
				
				CapAddRegional(ModelYear, r_flow, r_flow1) :=	sum((h,h1)|	map_hub_Region_flow(h,r_flow) and map_hub_Region_flow(h1,r_flow1)and r_flow<>r_flow1 , CapacityAdditionAnnual(ModelYear,h,h1));
				CapRegional(ModelYear, r_flow, r_flow1) :=	sum((h,h1)|	map_hub_Region_flow(h,r_flow) and map_hub_Region_flow(h1,r_flow1)and r_flow<>r_flow1 , CapacityAnnual(ModelYear,h,h1));
				
				!Old Regions
				!FlowsRegional(ModelYear, r_og, r_og1) :=	sum((h,h1)|	map_hub_Region_OilGas(h,r_og) and map_hub_Region_OilGas(h1,r_og1)and r_og<>r_og1 , FlowsAnnual(ModelYear,h,h1));
				
				!CapacityAddRegional(ModelYear, r_og, r_og1) :=	sum((h,h1)|	map_hub_Region_OilGas(h,r_og) and map_hub_Region_OilGas(h1,r_og1)and r_og<>r_og1 , CapacityAdditionAnnual(ModelYear,h,h1));
				!CapacityRegional(ModelYear, r_og, r_og1) :=	sum((h,h1)|	map_hub_Region_OilGas(h,r_og) and map_hub_Region_OilGas(h1,r_og1)and r_og<>r_og1 , CapacityAnnual(ModelYear,h,h1));
			}
			Comment: {
				"Procedure that assigns flows and capacities to regions that are defined in ngsetmap.txt.  Occurs every year in projection.
				This is published but only used for reporting purposes."
			}
		}
	}
	Section Imports_Exports_Section {
		Procedure Import_Export_InitializeData {
			Body: {
				!Assign historical import and export volumes to report identifiers
				Imports(datamon,BX) :=HistoricalImports(datamon,BX);
				AnnualImports(datayear,BX) :=sum(datamon|map_month_year(datamon,datayear), HistoricalImports(datamon,bx));
				Imports_Canada(datayear):=sum((cn,BX)|map_hubs_borderXings(cn,bx),AnnualImports(datayear,BX));
				Imports_Mexico(datayear):=sum((mx,BX)|map_hubs_borderXings(mx,BX),AnnualImports(datayear,BX));
				
				Exports(histmon,BX) :=HistoricalExports(histmon,BX);
				AnnualExports(datayear,BX) := sum(datamon|map_month_year(datamon,datayear), HistoricalExports(datamon,bx));
				
				! Point of Exit data for the TX subregions only goes back to 2011.
				! Export history prior to 2011 will be based on the export shares TX_W/TX_E had in 2011.
				! Need to eventually change in order to avoid all of the hardcoding.
				AnnualExports(datayear | datayear <= '2011', tx_bx) := TX_ExportShares(tx_bx) * AnnualExports(datayear | datayear <= '2011', 'TX-MX_NE');
				
				Exports_Canada(datayear):= sum((cn,BX)|map_hubs_borderXings(cn,BX),AnnualExports(datayear,BX));
				Exports_Mexico(datayear):= sum((mx,BX)|map_hubs_borderXings(mx,BX),AnnualExports(datayear,BX));
				
				!Add to Historical_InitializeData
				!May want to do this?  Dunno
				
				!Set annual Import/Export Prices
				AnnualImportPrice((datayear,BX)|AnnualImports(datayear,BX)) := sum(datamon|map_month_year(datamon,datayear), HistoricalImportsPrice(datamon,BX)* HistoricalImports(datamon,BX)/AnnualImports(datayear,BX));
				AnnualExportPrice((datayear,BX)|AnnualExports(datayear,BX)) := sum(datamon|map_month_year(datamon,datayear), HistoricalExportsPrice(datamon,BX)* HistoricalExports(datamon,BX)/AnnualExports(datayear,BX));
				
				ImportPrice_Canada(datayear) := sum(bx_cn, AnnualImportPrice(datayear,bx_cn)* AnnualImports(datayear,bx_cn)/$Imports_Canada(datayear)) ;
				ExportPrice_Canada(datayear) :=sum(bx_cn, AnnualExportPrice(datayear,bx_cn)* AnnualExports(datayear,bx_cn)/$Exports_Canada(datayear)) ;
				
				ExportPrice_Mexico(datayear) :=sum(bx_mx, AnnualExportPrice(datayear,bx_mx)* AnnualExports(datayear,bx_mx)/$Exports_Mexico(datayear)) ;
				ImportPrice_Mexico(datayear) :=sum(bx_mx, AnnualImportPrice(datayear,bx_mx)* AnnualImports(datayear,bx_mx)/$Imports_Mexico(datayear)) ;
				
				
				!Set annual Import/Export Prices for LNG
				
				!Transfer TX LNG Export history to TX_E
				HistoricalLNGExports(datamon, TXRegion_East) := HistoricalLNGExports(datamon, TexasState);
				
				AnnualLNGExports(datayear,lngexp_l48) := sum(datamon|map_month_year(datamon,datayear), HistoricalLNGExports(datamon,lngexp_l48));
				AnnualLNGExports(datayear,AKState) := sum(datamon|map_month_year(datamon,datayear), HistoricalLNGExports(datamon,AKState));
				Exports_LNG(datayear) := sum(lngexp_l48, AnnualLNGExports(datayear,lngexp_l48)) + AnnualLNGExports(datayear,AKState);
				
				AnnualLNGExportPrice((datayear,lngexp)|AnnualLNGExports(datayear,lngexp)) := sum(datamon|map_month_year(datamon,datayear), 
													HistoricalLNGExportsPrice(datamon,lngexp)* HistoricalLNGExports(datamon,lngexp)/AnnualLNGExports(datayear,lngexp));
				ExportPrice_LNG(datayear) := sum(lngexp, AnnualLNGExportPrice(datayear,lngexp)* AnnualLNGExports(datayear,lngexp)/$Exports_LNG(datayear));
				
				!Calculate LNG Import Prices
				AnnualLNGImports(datayear,ussup) :=sum(datamon|map_month_year(datamon,datayear), HistoricalSupply(datamon,Supply_LNG, ussup));
				Imports_LNG(datayear) :=sum (ussup, AnnualLNGImports(datayear,ussup));
				AnnualLNGImportPrice((datayear,ussup)|AnnualLNGImports(datayear, ussup)) :=  sum(datamon|map_month_year(datamon,datayear), 
													HistoricalCNGImportsPrice(datamon,ussup)* HistoricalSupply(datamon,Supply_LNG, ussup)/AnnualLNGImports(datayear,ussup));
				
				ImportPrice_LNG(datayear) := sum(ussup, AnnualLNGImportPrice(datayear,ussup)* AnnualLNGImports(datayear,ussup)/$Imports_LNG(datayear)) ;
			}
		}
		Procedure Import_Export_Run {
			Body: {
				!Assign import and export volumes to report identifiers each model year
				Imports(MonthInPeriod(tmon),BX) := sum(r_int|map_hubs_borderXings(r_int,bx),FlowHubToHub(tmon,r_int,bx));
				AnnualImports(ModelYear,BX) :=sum(modelyrmn, Imports(modelyrmn,bx));
				!Imports_Canada(ModelYear):=sum((cn,BX)|map_hubs_borderXings(cn,bx),AnnualImports(ModelYear,BX));
				!Imports_Mexico(ModelYear):=sum((mx,BX)|map_hubs_borderXings(mx,BX),AnnualImports(ModelYear,BX));
				Imports_Canada(ModelYear):=sum(bx_cn, AnnualImports(ModelYear,bx_cn));
				Imports_Mexico(ModelYear):=sum(bx_mx, AnnualImports(ModelYear,bx_mx));
				
				Exports(MonthInPeriod(tmon),BX) := sum(r_int | map_hubs_borderXings(r_int, BX),FlowHubToHub(tmon,bx,r_int));
				AnnualExports(ModelYear,BX) := sum(modelyrmn, Exports(modelyrmn,bx));
				!Exports_Canada(ModelYear):= sum((cn,BX)|map_hubs_borderXings(cn,BX),AnnualExports(ModelYear,BX));
				!Exports_Mexico(ModelYear):= sum((mx,BX)|map_hubs_borderXings(mx,BX),AnnualExports(ModelYear,BX));
				Exports_Canada(ModelYear):= sum(bx_cn, AnnualExports(ModelYear,bx_cn));
				Exports_Mexico(ModelYear):= sum(bx_mx, AnnualExports(ModelYear,bx_mx));
				
				NetImports_Canada(ModelYear):= Imports_Canada(ModelYear)-Exports_Canada(ModelYear);
				
				Exports_LNG(ModelYear) :=sum(lngexp_l48, AnnualLNGExports(ModelYear,lngexp_l48)) + AnnualLNGExports(ModelYear,AKState);
				
				!Postprocess Canada imports and exports to align with the STEO numbers
				if ModelYear<=LastSTEOYear then STEO_ImportExportPostprocess; endif;
				
				
				Price_Spot_Import(MonthInPeriod(tmon), BX) := -HubBalance_BXtoUS.ShadowPrice(tmon, BX);
				Price_Spot_Export(MonthInPeriod(tmon), BX) := -HubBalance_UStoBX.ShadowPrice(tmon, BX);
				
				!Set annual Import/Export Prices
				AnnualImportPrice((ModelYear,BX)|AnnualImports(ModelYear,BX)) := sum(modelyrmn, Price_Spot_Import(modelyrmn, BX)* Imports(modelyrmn, BX)/AnnualImports(ModelYear,BX));
				AnnualExportPrice((ModelYear,BX)|AnnualExports(ModelYear,BX)) := sum(modelyrmn, Price_Spot_Export(modelyrmn, BX)* Exports(modelyrmn, BX)/AnnualExports(ModelYear,BX));
				
				ImportPrice_Canada(ModelYear) := sum(bx_cn, AnnualImportPrice(ModelYear,bx_cn)* AnnualImports(ModelYear,bx_cn)/$Imports_Canada(ModelYear)) ;
				ExportPrice_Canada(ModelYear) :=sum(bx_cn, AnnualExportPrice(ModelYear,bx_cn)* AnnualExports(ModelYear,bx_cn)/$Exports_Canada(ModelYear)) ;
				
				ExportPrice_Mexico(ModelYear) :=sum(bx_mx, AnnualExportPrice(ModelYear,bx_mx)* AnnualExports(ModelYear,bx_mx)/$Exports_Mexico(ModelYear)) ;
				ImportPrice_Mexico(ModelYear) :=sum(bx_mx, AnnualImportPrice(ModelYear,bx_mx)* AnnualImports(ModelYear,bx_mx)/$Imports_Mexico(ModelYear)) ;
				
				Calculate_LNG_Prices;
			}
		}
		Procedure Calculate_LNG_Prices {
			Body: {
				!Price_Spot_LNGExport(MonthInPeriod(tmon), lngexp_qp) := -LNGExportBalance.ShadowPrice(tmon, lngexp_qp);
				!AnnualLNGExportPrice((ModelYear,lngexp_qp)|AnnualLNGExports(ModelYear,lngexp_qp)) := sum(modelyrmn, Price_Spot_LNGExport(modelyrmn, lngexp_qp)* MonthlyLNGExports(modelyrmn, lngexp_qp)/AnnualExports(ModelYear,lngexp_qp));
				
				!if (LNG_FixedExports_Switch = 1) then
				!	USLNGExportPrice_toDest(ModelYear,lngexp_qp,d_lng) := (USLNGExportPrice(ModelYear,lngexp_qp)-LNG_Liquefaction(lngexp_qp)) +LNG_TransCost(lngexp_qp,d_lng);
					AnnualLNGExportPrice((ModelYear,lngexp_qp)|AnnualLNGExports(ModelYear,lngexp_qp)) := USLNGExportPrice_toDest(ModelYear,lngexp_qp,'Asia');
				!else
				!	AnnualLNGExportPrice((ModelYear,lngexp_qp)|AnnualLNGExports(ModelYear,lngexp_qp)) := USLNGTotalCost(ModelYear,lngexp_qp,ArgMax(d_lng,LNG_USDiscount(lngexp_qp,d_lng)));
				!endif;
				
				ExportPrice_LNG(ModelYear) :=sum(lngexp_l48, AnnualLNGExportPrice(ModelYear,lngexp_l48)* AnnualLNGExports(ModelYear,lngexp_l48)/$TotalLNGExportsAnnual(ModelYear)) ;
				
				!Calculate LNG Import Prices
				AnnualLNGImportPrice((ModelYear,ussup)|ActualProductionAnnual(ModelYear, Supply_LNG, ussup)) := WellhdPrice_Soln(ModelYear, Supply_LNG, ussup);
				Imports_LNG(ModelYear) :=sum (ussup, ActualProductionAnnual(ModelYear, Supply_LNG, ussup));
				ImportPrice_LNG(ModelYear) := sum(ussup, AnnualLNGImportPrice(ModelYear,ussup)* ActualProductionAnnual(ModelYear, Supply_LNG, ussup)/$Imports_LNG(ModelYear)) ;
			}
		}
		DeclarationSection Imports_Exports_Declaration {
			Parameter TX_ExportShares {
				IndexDomain: tx_bx;
			}
			ElementParameter TXTradeFirstYear {
				Range: Years_;
			}
			Parameter Imports {
				IndexDomain: (mon,bx);
			}
			Parameter Exports {
				IndexDomain: (mon,bx);
			}
			Parameter AnnualImports {
				IndexDomain: (year,bx);
			}
			Parameter AnnualExports {
				IndexDomain: (year,bx);
			}
			Parameter Imports_Canada {
				IndexDomain: year;
			}
			Parameter Exports_Canada {
				IndexDomain: year;
			}
			Parameter Exports_Mexico {
				IndexDomain: year;
			}
			Parameter Imports_Mexico {
				IndexDomain: year;
			}
			Parameter NetImports_Canada {
				IndexDomain: year;
			}
			Set ImportExport_ {
				SubsetOf: AllIdentifiers;
				Index: trade;
				Definition: data { Imports_Canada, Exports_Canada, Exports_Mexico, Imports_Mexico };
			}
			Parameter Exports_LNG {
				IndexDomain: year;
			}
		}
		DeclarationSection Import_Export_Prices_Declaration {
			Parameter AnnualImportPrice {
				IndexDomain: (year,BX);
			}
			Parameter AnnualExportPrice {
				IndexDomain: (year,BX);
			}
			Parameter Price_Spot_Import {
				IndexDomain: (mon,BX);
			}
			Parameter Price_Spot_Export {
				IndexDomain: (mon,BX);
			}
			Parameter ImportPrice_Canada {
				IndexDomain: year;
			}
			Parameter ImportPrice_Mexico {
				IndexDomain: year;
			}
			Parameter ExportPrice_Canada {
				IndexDomain: year;
			}
			Parameter ExportPrice_Mexico {
				IndexDomain: year;
			}
			Parameter AnnualLNGExportPrice {
				IndexDomain: (year,lngexp);
			}
			Parameter ExportPrice_LNG {
				IndexDomain: year;
			}
			Parameter AnnualLNGImportPrice {
				IndexDomain: (year,s);
			}
			Parameter AnnualLNGImports {
				IndexDomain: (year,s);
			}
			Parameter Imports_LNG {
				IndexDomain: year;
			}
			Parameter ImportPrice_LNG {
				IndexDomain: year;
			}
		}
	}
	Section International_Data_Section {
		Procedure Initialize_IEO_Data {
			Body: {
				IEO_MX_Production(year,suptype,mx) *=  NumberOfDaysInYear(year);
				IEO_LNGExport_Monthly(mon, ieo_lng) := IEO_LNGExport(monthToYear(mon), ieo_lng) * NumberOfDaysInMonth(mon);
				IEO_LNGexport(year,ieo_lng) *=  NumberOfDaysInYear(year);
				
				!IEO_LNGExport_Monthly(mon, ieo_lng) := IEO_LNGExport(monthToYear(mon), ieo_lng) * NumberOfDaysInMonth(mon);
				
				! The IEO MX/CN data is read in as quads, but needs to be converted to Bcf/yr
				! Multiply by by conversion factor (currently 0.00096432) to get into cubic feet, and then divide by 1000000000 to get into Bcf
				IEO_CN_Consumption(year,sec) :=  (IEO_CN_Consumption(year,sec) * btu_to_cuft_factor) * 1000000;
				IEO_MX_Consumption(year,sec) :=  (IEO_MX_Consumption(year,sec) * btu_to_cuft_factor) * 1000000;
			}
		}
		DeclarationSection OtherIdentifiers {
			Parameter btu_to_cuft_factor {
				Comment: {
					"! Conversion factor to convert one BTU to one cubic foot"
				}
			}
			ElementParameter DisplayedCanadaRegion {
				Range: Canada_;
			}
		}
		Section IEO_Updates {
			DeclarationSection IEO2017_Declarations {
				Parameter IEO_MX_Production {
					IndexDomain: (year,suptype,mx);
				}
				ElementParameter IEO_LastHistoricalYear {
					Range: Years_;
				}
				Parameter IEO_LNGexport {
					IndexDomain: (year,ieo_lng);
				}
				Parameter IEO_LNGexport_Monthly {
					IndexDomain: (mon,ieo_lng);
				}
				Parameter IEO_CN_Consumption {
					IndexDomain: (year, sec);
				}
				Parameter IEO_CN_Bitumen {
					IndexDomain: (year, NEMScase);
				}
				Parameter IEO_MX_Consumption {
					IndexDomain: (year, sec);
				}
			}
			Procedure Run_IEO_Set {
				Body: {
					Cons_MX_Yr(ModelYear,sec,mx):= IEO_MX_Consumption(ModelYear,sec)* Cons_share_Mexico_mx(sec,mx);
					Cons_MX_mon(modelyrmn,sec,mx) := sum(mn|map_MonthinYear_ModelYearMonth(mn,modelyrmn),Cons_MX_Yr(ModelYear,sec,mx)*Cons_share_MonYr_MX(sec,mx,mn)); 
					
					Cons_CN_Yr(ModelYear,sec,cn):= IEO_CN_Consumption(ModelYear,sec)* Cons_share_Canada_cn(sec,cn);
					Cons_CN_Mon(modelyrmn,sec,cn) := sum(mn|map_MonthinYear_ModelYearMonth(mn,modelyrmn),Cons_CN_Yr(ModelYear,sec,cn)*Cons_CN_share_MonYr(sec,cn,mn));
				}
			}
		}
		Section Excel_Input_Data_Linkages {
			DeclarationSection Excel_Declarations {
				StringParameter WorkbookName;
			}
		}
	}
	Section Lease_and_Plant_Fuel_Section {
		DeclarationSection LeaseAndPlantFuel_Declarations {
			Parameter TexasProductionShare {
				IndexDomain: (datayear, reg) | reg in TXRegion_;
			}
			Parameter LeaseFuelAnnual {
				IndexDomain: (year,reg);
			}
			Parameter LeaseFuel {
				IndexDomain: (mon,reg);
			}
			Parameter PlantFuelAnnual {
				IndexDomain: (year,reg);
			}
			Parameter PlantFuel {
				IndexDomain: (mon,reg);
			}
			Parameter LeaseAndPlantFuelAnnual {
				IndexDomain: (year,reg);
			}
			Parameter LeaseFuelFactor {
				IndexDomain: s;
			}
			Parameter PlantFuelFactor {
				IndexDomain: d;
			}
			Parameter NationalPlantFuelFactor {
				IndexDomain: datayear;
			}
			Parameter PercentOfProductionMovedForPlantFuel {
				IndexDomain: (reg,reg1);
			}
			Parameter NGPLprocessedInState {
				IndexDomain: (year,reg);
			}
			Parameter NGPLfromOGSM {
				IndexDomain: (year,reg);
			}
			Parameter AverageLeaseFuelFactor {
				IndexDomain: (reg);
			}
		}
		Procedure LeaseAndPlantFuel_InitializeData {
			Body: {
				! Split Texas Plant based on Texas Production share
				TexasProductionShare(datayear, reg) := TotalProductionAnnual_forLeaseFuel(datayear, reg) /$ sum(r_tx, TotalProductionAnnual_forLeaseFuel(datayear, r_tx));
				HistoricalAnnualPlantFuel(hdatayear, r_tx) :=  TexasProductionShare(hdatayear, r_tx) * HistoricalAnnualPlantFuel(hdatayear, TexasState);
				
				!Calculate the historical monthly Plant Fuel for each state
				PlantFuel(datamon,l48) := HistoricalAnnualPlantFuel(MonthToYear(datamon),l48)* NumberOfDaysInMonth(datamon)/ NumberOfDaysInYear(MonthToYear(datamon));
				
				Calculate_PlantFuelFactor;
				
				LeaseFuelAnnual(datayear,state) := HistoricalAnnualLeaseFuel(datayear, state);
				
				!calculate Lease fuel for Gulf of Mexico states
				 HistoricalGOMLeaseFuel(datayear, fedGOMstate)   := HistoricalLeaseFuelFactor(datayear, fedGOMstate)*sum(naadgas, AnnualSupply(datayear, naadgas, fedGOMstate));
				 LeaseFuelAnnual(datayear,l48) += sum(fedGOMstate | map_SupplyArcs(fedGOMstate, l48), HistoricalGOMLeaseFuel(datayear, fedGOMstate));
				
				PlantFuelAnnual(datayear,state) := HistoricalAnnualPlantFuel(datayear, state);
				LeaseAndPlantFuelAnnual(datayear,state) := LeaseFuelAnnual(datayear, state) + PlantFuelAnnual(datayear, state);
			}
			DeclarationSection Hist_LP_Fuel_Declaration {
				Parameter HistoricalGOMLeaseFuel {
					IndexDomain: (datayear,fedGOMstate);
				}
			}
		}
		Procedure Calculate_LeaseFuelFactor {
			Body: {
				!Determine last year for which historical data exists
				LastHistoricalDataYear := Last(datayear | Exists((l48)|HistoricalAnnualLeaseFuel(datayear, l48)));
				
				! Split Texas Plant and Lease Fuel based on Texas Production share
				TexasProductionShare(datayear, reg) := TotalProductionAnnual_forLeaseFuel(datayear, reg) /$ sum(r_tx, TotalProductionAnnual_forLeaseFuel(datayear, r_tx));
				
				! Split Texas LeaseFuel based on TexasProductionShares
				HistoricalAnnualLeaseFuel(hdatayear, r_tx) :=  TexasProductionShare(hdatayear, r_tx) * HistoricalAnnualLeaseFuel(hdatayear, TexasState);
				
				HistoricalLeaseFuelFactor(hdatayear, l48) := HistoricalAnnualLeaseFuel(hdatayear, l48) / $ TotalProductionAnnual_forLeaseFuel(hdatayear, l48);
				
				!If lease fuel > production assume lease fuel factor =0
				HistoricalLeaseFuelFactor((hdatayear, l48) | HistoricalLeaseFuelFactor(hdatayear, l48)>=1) :=0;
				!Calculate average historical lease fuel factor
				AverageLeaseFuelFactor(l48)  :=  sum(navgyr_lease,HistoricalLeaseFuelFactor(LastHistoricalDataYear+1-Val(navgyr_lease), l48))/ Card(NumberOfYearsForAverage_Leasefuel_);
				
				LeaseFuelFactor(usnoGOM) := sum(l48 | map_SupplyArcs(usnoGOM, l48), AverageLeaseFuelFactor(l48));
				
				!Calculate lease factor for GOM
				HistoricalLeaseFuelFactor(hdatayear, GOMRegion) := HistoricalAnnualLeaseFuel(hdatayear, GOMRegion) / $ TotalProductionAnnual_forLeaseFuel(hdatayear, GOMRegion);
				HistoricalLeaseFuelFactor(hdatayear, fedGOMstate) := HistoricalLeaseFuelFactor(hdatayear, GOMRegion);
				!Calculate average historical lease fuel factor
				AverageLeaseFuelFactor(GOMRegion)  :=  sum(navgyr_lease,HistoricalLeaseFuelFactor(LastHistoricalDataYear+1-Val(navgyr_lease), GOMRegion))/ Card(NumberOfYearsForAverage_Leasefuel_);
				LeaseFuelFactor(fedGOMstate) := AverageLeaseFuelFactor(GOMRegion);
				
				!If no lease fuel or too much set equal to Texas; later change to national average
				LeaseFuelFactor(ussup | LeaseFuelFactor(ussup)>0.5 ) := LeaseFuelFactor(TXRegion_East) ;
			}
			Comment: "called by Production_InitializeData";
			DeclarationSection LeaseFuel_Declaration;
		}
		Procedure Calculate_PlantFuelFactor {
			Body: {
				!Transfer OGSM varialbe OGSMOUT_OGNGPLPRD to NGPLfromOGSM
				NGPLfromOGSM(datayear, ussup)  := sum(OGDIST | NEMSmap_OGDIST_SupplyNode(OGDIST, ussup), OGSMOUT_OGNGPLPRD(OGDIST, NEMSmap_MNUMYR(datayear))* NumberOfDaysInYear(datayear) );
				! Add all the substates to get the state production
				NGPLfromOGSM(datayear, state) +=  sum(substate | map_SupplyArcs(substate, state), NGPLfromOGSM(datayear, substate));
				!Calculate natural gas plant liquids (NGPL) processed in each state by using the historical share of NGPLs in each state that is processed in that state versus in the neighboring states
				! These shares include offshore regions
				NGPLprocessedInState(datayear, l48) := sum(ussup, NGPLfromOGSM(datayear, ussup) * PercentOfProductionMovedForPlantFuel(ussup,l48));
				!Calculate historical plant fuel factor
				HistoricalPlantFuelFactor(datayear,l48) := HistoricalAnnualPlantFuel(datayear,l48)/ $ NGPLprocessedInState(datayear, l48);
				NationalPlantFuelFactor(datayear):=sum(l48, HistoricalAnnualPlantFuel(datayear,l48))/$ sum(l48, NGPLprocessedInState(datayear, l48));
				!Determine last year for which historical data exists
				LastHistoricalDataYear := Last(datayear | Exists((l48)|HistoricalAnnualPlantFuel(datayear,l48)));
				!Calculate average historical lease fuel factor
				PlantFuelFactor(l48)  :=  sum(navgyr_plant,HistoricalPlantFuelFactor(LastHistoricalDataYear-Val(navgyr_plant)+1, l48))/ Card(NumberOfYearsForAverage_Plantfuel_);
				!Set the forecast factor in states with no factor to the national average factor in the last historical year
				
				PlantFuelFactor((l48) | not PlantFuelFactor(l48)) := NationalPlantFuelFactor(LastHistoricalDataYear);
				!Limit the factor to a maximum of 1.7 and a minimum of 0.005
				PlantFuelFactor(l48) := Min(1.7, PlantFuelFactor(l48));
				PlantFuelFactor(l48) := Max(0.005, PlantFuelFactor(l48));
				!Temporarily set OH = PA factor; change when more data available
				PlantFuelFactor(OhioState):=PlantFuelFactor(PennState);
			}
			Comment: "called by LeaseAndPlantFuel_InitializeData";
		}
		Procedure PlantFuel_Run {
			Body: {
				!Transfer OGSM varialbe OGSMOUT_OGNGPLPRD to NGPLfromOGSM
				NGPLfromOGSM(ModelYear, ussup)  := sum(OGDIST | NEMSmap_OGDIST_SupplyNode(OGDIST, ussup), OGSMOUT_OGNGPLPRD(OGDIST, NEMSmap_MNUMYR(ModelYear))* NumberOfDaysInYear(ModelYear));
				! Add all the substates to get the state production
				!YDA: Do Alaska separately
				NGPLfromOGSM(ModelYear, state) += sum(substate | map_SupplyArcs(substate, state), NGPLfromOGSM(ModelYear, substate));
				!Calculate natural gas plant liquids (NGPL) processed in each state
				NGPLprocessedInState(ModelYear, l48) := sum(ussup, NGPLfromOGSM(ModelYear, ussup) * PercentOfProductionMovedForPlantFuel(ussup,l48));
				!Calculate the monthly Plant Fuel for each state
				PlantFuel(modelyrmn,l48) := PlantFuelFactor(l48) * NGPLprocessedInState(MonthToYear(modelyrmn), l48)* NumberOfDaysInMonth(modelyrmn)/ NumberOfDaysInYear(MonthToYear(modelyrmn));
			}
		}
		Procedure LeaseAndPlantFuel_PostProcess {
			Body: {
				LeaseFuelBySupplyRegion(modelyrmn,qps) := sum(naadgas, ActualProductionMonthly(modelyrmn, naadgas, qps)) * LeaseFuelFactor(qps)*STEOLeaseFuelFactor(ModelYear) /
				                                          (1 - LeaseFuelFactor(qps)*STEOLeaseFuelFactor(ModelYear));
				LeaseFuel(modelyrmn,l48) := sum(l48s | map_SupplyArcs(l48s, l48), LeaseFuelBySupplyRegion(modelyrmn,l48s));
				LeaseFuelAnnual(ModelYear, l48) := sum(modelyrmn, LeaseFuel(modelyrmn,l48));
				PlantFuelAnnual(ModelYear, l48) := sum(modelyrmn, PlantFuel(modelyrmn,l48));
				LeaseAndPlantFuelAnnual(ModelYear, l48) := LeaseFuelAnnual(ModelYear, l48) + PlantFuelAnnual(ModelYear, l48);
				TotalLeaseFuelAnnual(ModelYear) := sum((modelyrmn,l48), LeaseFuel(modelyrmn,l48));
				LeaseAndPlantFuelAnnual(ModelYear,AKState) := sum(r_ak, AK_LeasePlant( ModelYear,r_ak))+ AK_LeasePlant_LNG(ModelYear);
				!Sum up to census divisions
				!!!!!!!NOTE: AK is not in the mapping -- re-do mapping or add AK separately !!!!!!
				!LeaseandPlantCDAnnual(ModelYear,r_cen) := sum(l48 | map_State_CensusRegion(l48, r_cen), LeaseAndPlantFuelAnnual(ModelYear, l48));
				!LeaseandPlantCDAnnual(ModelYear,CD_Pacific) += sum(r_ak, AK_LeasePlant( ModelYear,r_ak));
				!TotalLeaseAndPlantAnnual(ModelYear) := sum(r_cen, LeaseandPlantCDAnnual(ModelYear, r_cen));
				
				!Fill the NEMS array
				!Moved to Write_to_NEMS
				!QBLK_QLPIN(MNUMCR, NEMSmap_MNUMYR(ModelYear)) := sum(r_cen, LeaseandPlantCDAnnual(ModelYear, r_cen)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR)) * Convert_TBtu_Bcf(ModelYear);
				!QBLK_QLPIN(MNUMCR, NEMSmap_MNUMYR(ModelYear)) := sum((r_cen,state) |  map_State_CensusRegion(state, r_cen) and NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR),
				!                                                LeaseAndPlantFuelAnnual(ModelYear,state)) * Convert_TBtu_Bcf(ModelYear);
				!QBLK_QLPIN(TotalUS_MNUMCR, NEMSmap_MNUMYR(ModelYear)) := TotalLeaseAndPlantAnnual(ModelYear)* Convert_TBtu_Bcf(ModelYear);
				!
			}
			DeclarationSection LP_Fuel_Declaration {
				Parameter LeaseFuelBySupplyRegion {
					IndexDomain: (mon,s);
				}
				Parameter TotalLeaseAndPlantAnnual {
					IndexDomain: year;
				}
				Parameter LeaseandPlantCDAnnual {
					IndexDomain: (year,r_cen);
				}
			}
		}
	}
	Section Mexico_Subroutine {
		Procedure Mexico_InitializeData {
			Body: {
				!!SUPPLY
				
				!Determine last month for which PEMEX historical data exists and determine LastHistoricalDataYear by testing if LastHistoricalDataMonth is December
				LastHistoricalDataMonth := Last(datamon | Exists((suptype,mx)|HistoricalProductionPemex(datamon,suptype,mx)));
				if (MonthToYear(LastHistoricalDataMonth)=MonthToYear(LastHistoricalDataMonth-11)) then
					LastHistoricalDataYear := MonthToYear(LastHistoricalDataMonth);
				else
					LastHistoricalDataYear := MonthToYear(LastHistoricalDataMonth)-1;
				endif;
				
				!Transfer data to Main Array
				Supply(hdatamon,naadgas,mx) := HistoricalProductionPemex(hdatamon,naadgas,mx);
				Supply(hdatamon, Supply_LNG, mx)  := HistoricalAnnualSupply(MonthToYear(hdatamon), Supply_LNG, mx) * NumberOfDaysInMonth(hdatamon)/ NumberOfDaysInYear(MonthToYear(hdatamon));
				AnnualSupply(hdatayear,suptype,mx) := sum(hdatamon|map_month_year(hdatamon,hdatayear), Supply(hdatamon,suptype,mx));
				TotalProduction(hdatamon, mx) := sum(suptype , Supply(hdatamon,suptype,mx));
				
				!Calculate historical Mexico total annual consumption
				HistoricalAnnualSupplyMX(datayear,mx) := sum(mon|map_month_year(mon,datayear), TotalProduction(mon, mx));
				HistoricalTotalAnnualSupplyMX(datayear) :=sum(mx,HistoricalAnnualSupplyMX(datayear,mx));
				TotalAnnualProductionMX(hdatayear) := sum(mx, HistoricalAnnualSupplyMX(hdatayear, mx));
				
				!!CONSUMPTION  
				
				!Determine last month for which SENER historical data exists and determine LastHistoricalDataYear by testing if LastHistoricalDataMonth is December
				LastHistoricalDataMonth := Last(mon | Exists((mx_sec,mx)|HistoricalConsumptionSENER(mon,mx_sec,mx)));
				if (MonthToYear(LastHistoricalDataMonth)=MonthToYear(LastHistoricalDataMonth-11)) then
					LastHistoricalDataYear := MonthToYear(LastHistoricalDataMonth);
				else
					LastHistoricalDataYear := MonthToYear(LastHistoricalDataMonth)-1;
				endif;
				
				!Preprocess historical data from SENER to get totals to use in creating shares
				!HistoricalConsumptionSENER(mon,mx_sec,mx) *= NumberOfDaysInMonth(mon);
				Cons_MX_mon(hdatamon,sec,mx) := sum(mx_sec|map_MXsector_sector(mx_sec,sec),
									HistoricalConsumptionSENER(hdatamon,mx_sec,mx)* NumberOfDaysInMonth(hdatamon));
				Cons_MX_Yr(hdatayear,sec,mx):= 	sum(hdatamon|map_month_year(hdatamon,hdatayear), Cons_MX_Mon(hdatamon,sec,mx));
				
				TotalConsumption(hdatamon, mx) := sum(sec, Cons_MX_mon(hdatamon, sec, mx));
				TotalSectorConsumptionMX(hdatayear,sec) := sum(mx, Cons_MX_YR(hdatayear, sec, mx)) ;
				
				HistoricalAnnualConsumptionSENER(hdatayear,mx) := sum(hdatamon|map_month_year(hdatamon,hdatayear), TotalConsumption(hdatamon, mx));
				HistoricalTotalAnnualConsumptionSENER(hdatayear) :=sum(mx,HistoricalAnnualConsumptionSENER(hdatayear,mx));
				
				Cons_share_MonYr_MX(sec,mx,mn) := 		sum((hdatamon,navgyr_dmd)|map_Month_MonthinYear(hdatamon,mn)and YearToMonth(LastHistoricalDataYear)<=hdatamon<=YearToMonth(LastHistoricalDataYear)+11,
											Cons_MX_mon(hdatamon-12*(Val(navgyr_dmd)-1),sec,mx))/$ sum(navgyr_dmd ,Cons_MX_Yr(LastHistoricalDataYear-Val(navgyr_dmd)+1,sec,mx));
				
				Cons_share_Mexico_mx(sec,mx) := sum(navgyr_dmd, Cons_MX_Yr(LastHistoricalDataYear-Val(navgyr_dmd)+1,sec,mx)/$ TotalSectorConsumptionMX(LastHistoricalDataYear-Val(navgyr_dmd)+1,sec))
											/Card(NumberOfYearsForAverage_Demand_);
				
				TotalConsumptionMX(hdatayear,mx) := sum(hdatamon|map_month_year(hdatamon,hdatayear), TotalConsumption(hdatamon,mx));
				TotalAnnualConsumptionMX(hdatayear) := sum(mx,TotalConsumptionMX(hdatayear,mx));
			}
		}
		Procedure Mexico_Run {
			Body: {
				!Fill in Annual Supply Main Array
				!IEO Production replaced by estimations (based off IEO production, actually...)... LNG still read in
				!AnnualSupply (ModelYear, suptype, mx)  := IEO_MX_Production(ModelYear,suptype,mx);
				AnnualSupply (ModelYear, Supply_LNG, mx)  := IEO_MX_Production(ModelYear,Supply_LNG,mx);
				!AnnualSupply (ModelYear, Supply_AD, Mexico_SS)  := 
				!	(x_MX_AD_Prod1*AnnualSupply (ModelYear-1, Supply_AD, Mexico_SS))+
				!	(x_MX_AD_WOP2*WorldOilPrice(ModelYear-2, 'USD_MMBtu'))+
				!	x_MX_AD_C;
				
				Calculate_MX_Oil_Industrial;
				! changing less than or equal to first shale year to avoid having the alternate equation kicking in during the last year
				! when that is not the intention.
				if (ModelYear <= MX_FirstShaleYear) then
					AnnualSupply (ModelYear, Supply_NA, Mexico_NE)  := 
						(x_MX_NA_Prod1_1*AnnualSupply (ModelYear-1, Supply_NA, Mexico_NE))+
						(x_MX_NA_Prod2_1*AnnualSupply (ModelYear-2, Supply_NA, Mexico_NE))+
						(x_MX_NA_HH1_1*HenryHubPrice(ModelYear-1));
				else
					AnnualSupply (ModelYear, Supply_NA, Mexico_NE)  := 
						(x_MX_NA_Prod1_2*AnnualSupply (ModelYear-1, Supply_NA, Mexico_NE))+
						(x_MX_NA_HH1_2*HenryHubPrice(ModelYear-1));
				endif;
				!Convert Annual Qty to Monthly using number of days in each month
				Supply(modelyrmn, suptype, mx)  := AnnualSupply(MonthToYear(modelyrmn), suptype, mx) * NumberOfDaysInMonth(modelyrmn)/ NumberOfDaysInYear(MonthToYear(modelyrmn));
				
				Cons_MX_Yr(ModelYear,sec,mx):= IEO_MX_Consumption(ModelYear,sec)* Cons_share_Mexico_mx(sec,mx);
				Cons_MX_mon(modelyrmn,sec,mx) := sum(mn|map_MonthinYear_ModelYearMonth(mn,modelyrmn),Cons_MX_Yr(ModelYear,sec,mx)*Cons_share_MonYr_MX(sec,mx,mn)); Cons_MX_Yr(ModelYear,sec,mx):= IEO_MX_Consumption(ModelYear,sec)* Cons_share_Mexico_mx(sec,mx);
				
				
				!Fill in Main Arrays
				TotalConsumption(modelyrmn,mx) :=  sum(sec, Cons_MX_Mon(modelyrmn, sec, mx));
				AnnualTotalConsumption(ModelYear,mx):=sum(modelyrmn,TotalConsumption(modelyrmn,mx));
				!PlantFuel(modelyrmn,mx) := INGM_MX_PlantFuel(MonthToYear(modelyrmn),mx)* (NumberOfDaysInMonth(modelyrmn)/ NumberOfDaysInYear(MonthToYear(modelyrmn)));
				
				!Aggregations for report writing purposes
				TotalAnnualProductionMX(ModelYear) := sum((suptype,mx),IEO_MX_Production(ModelYear,suptype,mx));
				TotalConsumptionMX(ModelYear,mx) := sum(sec, Cons_MX_Yr(ModelYear,sec,mx));
				TotalAnnualConsumptionMX(ModelYear) := sum(mx,TotalConsumptionMX(ModelYear,mx));
			}
		}
		DeclarationSection MX_Production_Declarations {
			Parameter TotalProduction_IEO {
				IndexDomain: (year,mx);
			}
			Parameter HistoricalAnnualSupplyMX {
				IndexDomain: (year,mx);
			}
			Parameter TotalAnnualProductionMX {
				IndexDomain: year;
			}
			Parameter HistoricalTotalAnnualSupplyMX {
				IndexDomain: (year);
			}
			Parameter x_MX_AD_WOP2;
			Parameter x_MX_AD_Prod1;
			Parameter x_MX_AD_C;
			Parameter x_MX_NA_HH1_1;
			Parameter x_MX_NA_Prod1_1;
			Parameter x_MX_NA_HH1_2;
			Parameter x_MX_NA_Prod1_2;
			ElementParameter MX_FirstShaleYear {
				Range: Years_;
			}
		}
		DeclarationSection MX_Consumption_Declaration {
			Parameter mx_ieo_industrial_switch {
				Comment: "Switch to determine whether or not to use IEO industrial projections (IEO_MX_Consumption) for Mexico";
			}
			Set MX_Sector_ {
				Index: mx_sec;
			}
			Parameter map_MXsector_sector {
				IndexDomain: (mx_sec, sec);
				Range: binary;
			}
			Parameter Cons_MX_mon {
				IndexDomain: (mon,sec,mx);
			}
			Parameter HistoricalConsumptionSENER {
				IndexDomain: (mon,mx_sec,mx);
			}
			Parameter INGM_MX_Consumption {
				IndexDomain: (year,sec,mx);
			}
			Parameter HistoricalAnnualConsumptionSENER {
				IndexDomain: (year, mx);
			}
			Parameter HistoricalTotalAnnualConsumptionSENER {
				IndexDomain: year;
			}
			Parameter Cons_share_MonYr_MX {
				IndexDomain: (sec,mx,mn);
			}
			Parameter Cons_MX_yr {
				IndexDomain: (year,sec,mx);
			}
			Parameter TotalConsumptionMX {
				IndexDomain: (year,mx);
			}
			Parameter TotalAnnualConsumptionMX {
				IndexDomain: year;
			}
		}
		Section Mexico_Placeholder {
			Procedure AEO2017_Mexico_Run {
				Body: {
					!Fill in Annual Supply Main Array
					!Empty out prior data and assign NGTDM/AEO2017 values; all production in MX_SS
					!AnnualSupply (ModelYear, suptype, mx)  := 0;  !yda: empties out 2015 to 2018 as well and therefore no production is MX in those years
					AnnualSupply (ModelYear, Supply_NA, Mexico_SS)  := AEO2017_MX_Production(ModelYear);
					if (ModelYear > LastSTEOYear) then
						AnnualSupply (ModelYear, suptype, mx)  := 0;
						AnnualSupply (ModelYear, Supply_NA, Mexico_SS)  := AEO2017_MX_Production(ModelYear) - AnnualSupply(LastSTEOYear, Supply_NA, Mexico_SS) + ActualProductionAnnual(LastSTEOYear, Supply_NA, Mexico_SS);
					endif;
					!AnnualSupply (ModelYear, Supply_NA, Mexico_SS)  := AEO2017_MX_Production(ModelYear);
					AnnualSupply (ModelYear, Supply_LNG, mx)  := AEO2017_MX_LNG(ModelYear,mx);
					
					!Convert Annual Qty to Monthly using number of days in each month
					Supply(modelyrmn, suptype, mx)  := AnnualSupply(MonthToYear(modelyrmn), suptype, mx) * NumberOfDaysInMonth(modelyrmn)/ NumberOfDaysInYear(MonthToYear(modelyrmn));
					
					!Use INGM consumption and split into monthly shares
					!Cons_MX_yr_AEO2017(ModelYear,mx) :=sum(sec, INGM_MX_Consumption(ModelYear,sec,mx) + INGM_Consumption_Correction(sec,mx));
					Cons_MX_yr_AEO2017(ModelYear,Mexico_NE) :=0;
					Cons_MX_yr_AEO2017(ModelYear,Mexico_NE) := AEO2017_MX_Consumption(ModelYear) - sum(mx, Cons_MX_yr_AEO2017(ModelYear,mx));
					Cons_MX_mon_AEO2017(modelyrmn,mx) := sum(mn|map_MonthinYear_ModelYearMonth(mn,modelyrmn),Cons_share_MonYr_MX(Sector_Electric,mx,mn)*Cons_MX_yr_AEO2017(ModelYear,mx));
					
					!Fill in Main Arrays
					TotalConsumption(modelyrmn,mx) := 0;
					TotalConsumption(modelyrmn,mx) :=  Cons_MX_mon_AEO2017(modelyrmn,mx);
					AnnualTotalConsumption(ModelYear,mx):=sum(modelyrmn,TotalConsumption(modelyrmn,mx));
				}
			}
			DeclarationSection Mexico_Placeholder_Declarations {
				Parameter AEO2017_MX_Production {
					IndexDomain: year;
				}
				Parameter AEO2017_MX_Consumption {
					IndexDomain: year;
				}
				Parameter AEO2017_MX_LNG {
					IndexDomain: (year,mx);
				}
				Parameter AEO2017_MX_HHPrice {
					IndexDomain: year;
				}
				Parameter Cons_MX_yr_AEO2017 {
					IndexDomain: (year,mx);
				}
				Parameter Cons_MX_mon_AEO2017 {
					IndexDomain: (mon,mx);
				}
				ElementParameter Mexico_SS {
					Range: Mexico_;
				}
				ElementParameter Mexico_NE {
					Range: Mexico_;
				}
				ElementParameter Mexico_NW {
					Range: Mexico_;
				}
			}
		}
		Section MX_Production_New {
			Procedure Calculate_MX_Oil_Industrial {
				Body: {
					!Calculate oil production
					!MX_Oil_Production(ModelYear) := x_MX_Oil_WOP2_1 * exp(x_MX_Oil_Prod1_1 * WorldOilPrice(ModelYear,'USD_MMBtu'));
					
					if (ModelYear >= MX_OilRecoveryYear) then
						MX_Oil_Production(ModelYear)  := 
							(x_MX_Oil_Prod1_2 * MX_Oil_Production(ModelYear-1)) + (x_MX_Oil_WOP2_2 * WorldOilPrice(ModelYear-2,'USD_MMBtu'));
					!else
					!	MX_Oil_Production(ModelYear)  := 
					!		(x_MX_Oil_Prod1_1 * MX_Oil_Production(ModelYear-1)) + (x_MX_Oil_WOP_1 * WorldOilPrice(ModelYear,'USD_MMBtu'));
					
					endif;
					
					
					AnnualSupply (ModelYear, Supply_AD, Mexico_SS)  := 
						(x_MX_AD_Prod1*AnnualSupply (ModelYear-1, Supply_AD, Mexico_SS))+
						(x_MX_AD_WOP1*WorldOilPrice(ModelYear-1, 'USD_MMBtu'))+
						(x_MX_AD_WOP2*WorldOilPrice(ModelYear-2, 'USD_MMBtu'))+
						 x_MX_AD_OilProd1* MX_Oil_Production(ModelYear-1) +
						 x_MX_AD_OilProd2* MX_Oil_Production(ModelYear-2) ;
					
					Cons_MX_PEMEX(LastHistoricalYear) :=  sum((lhisyr,mx), HistoricalConsumptionSENER(lhisyr,MX_Sector_PEMEX ,mx)*NumberOfDaysInMonth(lhisyr)); 
					Cons_MX_Industrial(LastHistoricalYear) :=  sum((lhisyr,mx), HistoricalConsumptionSENER(lhisyr,MX_Sector_Industrial ,mx)*NumberOfDaysInMonth(lhisyr)); 
					
					Cons_MX_PEMEX(ModelYear) :=  (x_MX_Cons_PEMEX_1* Cons_MX_PEMEX(ModelYear-1))+
						(x_MX_Cons_PEMEX_Oil * MX_Oil_Production(ModelYear));
					
					Cons_MX_Industrial(ModelYear) :=  (x_MX_Cons_Industrial_1* Cons_MX_Industrial(ModelYear-1))+
						(x_MX_Cons_Industrial_HH * HenryHubPrice(ModelYear-1)) + c_MX_Cons_Industrial;
					
					if (mx_ieo_industrial_switch = 0) then
						IEO_MX_Consumption(ModelYear,Sector_Industrial) := Cons_MX_PEMEX(ModelYear) + Cons_MX_Industrial(ModelYear);
					endif;
				}
			}
			DeclarationSection Oil_Declarations {
				Parameter x_MX_AD_OilProd2;
				Parameter x_MX_AD_OilProd1;
				Parameter MX_Oil_Production {
					IndexDomain: year;
				}
				Parameter x_MX_NA_Prod2_1;
				Parameter x_MX_Oil_WOP_1;
				ElementParameter MX_Sector_PEMEX {
					Range: MX_Sector_;
				}
				ElementParameter MX_Sector_Industrial {
					Range: MX_Sector_;
				}
				ElementParameter MX_OilRecoveryYear {
					Range: Years_;
				}
				Parameter x_MX_Oil_WOP2_2;
				Parameter x_MX_Oil_WOP;
				Parameter x_MX_Oil_Prod1_1;
				Parameter x_MX_Oil_Prod1_2;
				Parameter x_MX_AD_WOP1;
				Parameter x_MX_AD_OilProd;
				Parameter x_MX_Cons_PEMEX_1;
				Parameter x_MX_Cons_Industrial_1;
				Parameter c_MX_Cons_Industrial;
				Parameter x_MX_Cons_Industrial_HH;
				Parameter x_MX_Cons_PEMEX_Oil;
				Parameter Cons_MX_PEMEX {
					IndexDomain: year;
				}
				Parameter Cons_MX_Industrial {
					IndexDomain: year;
				}
			}
		}
	}
	Section LNG_Exports_Section {
		Comment: {
			"1.  add LNGExports_Initialize to First Year Initialization
			2.  Transfer LNGExports setting from Transfer Data to Main Arrays to LNGExports_Initialization
			3.  Moved LNG input data to LNGExports input file from ngassumptions.
			4.  Remember to move NEMSmap_Xyear
			5.  Add below to NGMM after set wellhead prices
			if (LNG_FixedExports_Switch = 0) then
				LNGExport_Run;
			endif;
			6.  Adds to Write to NEMS
			NGTDMREP_PINTLNG(M2,NEMSmap_MNUMYR(ModelYear)) := sum( d_lng, WorldLNGPrice(ModelYear,d_lng)*NEMSmap_M2_d_lng(M2,d_lng));
			7.  updates to lngexports.txt file
			8.  In Main Array, change LNG exports and annual LNG exports to be by region to accommodate AK
			9.  QP_LNG Export Price
				remove definition of \"3\"
				Add statement to TransferDataIntoQPparameters
				QP_LNGExportPrice(tmon,lngexp) := USLNGExportPrice(YearInPeriod(tmon),lngexp);"
		}
		Procedure LNGExportsCapExpansion_Run {
			Body: {
				AddedLNGTrains :=0;
				
				repeat
					Calculate_WorldLNGPrices;
					Calculate_USLNGExportPrices;
					Calculate_AKLNGExportPrices;
					AddLNGEportCapacity;
					break when (not LNG_AddedCapacity or AddedLNGTrains = LNG_MaxTrainsYr);
				endrepeat;
				
				!Put these in Write_To_NEMS eventually
				
				
				!ALL MOVED TO WRITE TO NEMS PROCEDURE
				
				!This will technically be set in LNG_Utilization procedure
				!NGTDMREP_NALNGEXP(LNGTER,NEMSmap_MNUMYR(ModelYear)) := sum(lngexp, AnnualLNGExports(ModelYear,lngexp)*NEMSmap_LNGTER_lngexp(lngter,lngexp));
				!NGTDMREP_NALNGEXP(Card(LNGTER),NEMSmap_MNUMYR(ModelYear)) := AnnualLNGExports(ModelYear,AKRegion);
				!OGQNGEXP must be set too to border points?
				
				!NGTDMREP_PINTLNG(M2,NEMSmap_MNUMYR(ModelYear)) := sum( d_lng, WorldLNGPrice(ModelYear,d_lng)*NEMSmap_M2_d_lng(M2,d_lng)); already there for KDL- check
				!NGTDMREP_NALNGEXP((LNGTER,NEMSmap_MNUMYR(year))|ModelYear < year) := sum(lngexp,LNG_ExportCapacity(year,lngexp)*NEMSmap_LNGTER_lngexp(lngter,lngexp));
				!NGTDMREP_NALNGEXP((LNGTER,NEMSmap_MNUMYR(year))|ModelYear < year) := LNG_ExportCapacity(year,AKRegion);
				!Currently divide by 2 because LA/TX and MD/GA are doubling up spots; change with lngter dimensions
				!NGTDMREP_PTRANSNG(M2,LNGTER,NEMSmap_MNUMYR(ModelYear)):= sum((lngexp,d_lng), USLNGTotalCost(ModelYear,lngexp,d_lng)*NEMSmap_LNGTER_lngexp(lngter,lngexp)*NEMSmap_M2_d_lng(M2,d_lng))/2;
				!NGTDMREP_PTRANSNG(M2,LNGTER,NEMSmap_MNUMYR(ModelYear)):= sum(d_lng, AKLNGTotalCost(ModelYear,AKRegion,d_lng)*NEMSmap_M2_d_lng(M2,d_lng));
				!NGTDMREP_PUSNG(LNGTER,NEMSmap_MNUMYR(ModelYear)) :=0;
			}
		}
		Procedure LNGExports_Initialize {
			Body: {
				
				
				if (LNG_FixedExports_Switch = 1) then
					Set_Exogenous_LNGExports;
				else
					Initialize_LNGDemand;
					Initialize_LNGParameters;
				endif;
				
				Initialize_LNGTransCost;
				
				!Assign Canadian LNG Exports
				!LNG_ExportCapacity(year, cn) := sum(r_ingm| map_INGM_CN(r_ingm,cn), INGM_LNGexport(year,r_ingm));
				!Ignore Eastern Canada?
				LNG_ExportCapacity(year, CanadaWest) := IEO_LNGexport(year,CanadaWest);
				
				!Reset AK LNG exports; history will be read in in Import Export initialization procedure
				LNG_ExportCapacity(year, AKState) := 0;
				
				
				
				!Add Western Canada volumes to world flexible LNG volumes
				LNG_WorldFlex(year) += LNG_ExportCapacity(year, CanadaWest);
				for (xyear| xyear> LastModelYear) do
					LNG_WorldFlex(xyear) += LNG_ExportCapacity(LastModelYear, CanadaWest);
				endfor;
				
				!Add Northwest Mexico volumes to world flexible LNG volumes
				LNG_WorldFlex(year) += LNG_ExportCapacity(year, Mexico_NW);
				for (xyear| xyear> LastModelYear) do
					LNG_WorldFlex(xyear) += LNG_ExportCapacity(LastModelYear, Mexico_NW);
				endfor;
				
				!Add Southsouthwest Mexico volumes to world flexible LNG volumes
				LNG_WorldFlex(year) += LNG_ExportCapacity(year, Mexico_NE);
				for (xyear| xyear> LastModelYear) do
					LNG_WorldFlex(xyear) += LNG_ExportCapacity(LastModelYear, Mexico_NE);
				endfor;
				
				!Calculate LNG export capacity based on projects under construction
				!Transfer LNG Exports to Main Array
				Initialize_LNGCapacity;
				!LNGExports((mon, lngexp_qp) ) := LNG_ExportCapacity(MonthToYear(mon), lngexp_qp) * NumberOfDaysInMonth(mon)/ NumberOfDaysInYear(MonthToYear(mon));
				
				!Set fuel used for liquefaction in history
				LNGFuelForLiquefaction(datayear, lngexp) := HistoricalAnnualLiquefactionFuel(datayear, lngexp);
				! Transfer TX historical liquefaction to TX_E region
				LNGFuelForLiquefaction(datayear, TXRegion_East) := HistoricalAnnualLiquefactionFuel(datayear,TexasState);
			}
		}
		Section LNG_Export_Capacity_Setup {
			Property: NoSave;
			Procedure Initialize_LNGCapacity {
				Body: {
					!Assign baseload capacity to all months, starting with in-service date
					LNG_ExpCapMon((mon,lngproj,train)| mon>= LNG_InServiceDate(lngproj,train)) := LNG_BaseloadCapacity(lngproj,train);
					
					!Adjust baseload capacity to allow for ramp-up time
					for (lngproj,train)|LNG_BaseloadCapacity(lngproj,train) do
						counter :=1;
						while counter <= Val(last(ramp_mon|LNG_RampUpUtilization(train,ramp_mon))) do
							LNG_ExpCapMon(LNG_InServiceDate(lngproj,train)+counter-1,lngproj,train) *= LNG_RampUpUtilization(train,counter);
							counter +=1;
						endwhile;
					endfor;
					
					!Convert capacities from bcf/d to Bcf and aggregate to state level
					LNGExports(mon,lngexp_qp) := sum((lngproj,train)|map_lngproj_lngexp(lngproj,lngexp_qp) , LNG_ExpCapMon(mon,lngproj,train))
									* NumberOfDaysInMonth(mon)*LNG_Utilization(mon);
					
					!Sum to annual total and adjust for effective utilization of baseload capacity
					LNG_ExportCapacity(year,lngexp_qp):= sum(mon|map_month_year(mon,year),LNGExports(mon,lngexp_qp));
				}
			}
			DeclarationSection LNG_Export_Capacity_Setup_Declarations {
				Set LNG_Projects_ {
					Index: lngproj;
				}
				Set LNG_Train_ {
					SubsetOf: Integers;
					Index: train;
				}
				Set LNG_NumberOfMonthsRampUp_ {
					SubsetOf: Integers;
					Index: ramp_mon;
				}
				ElementParameter LNG_InServiceDate {
					IndexDomain: (lngproj,train);
					Range: Months_;
				}
				Parameter LNG_BaseloadCapacity {
					IndexDomain: (lngproj,train);
				}
				Parameter map_lngproj_lngexp {
					IndexDomain: (lngproj,lngexp);
					Range: binary;
				}
				Parameter LNG_RampUpUtilization {
					IndexDomain: (train,ramp_mon);
				}
				Parameter LNG_ExpCapMon {
					IndexDomain: (mon,lngproj,train);
				}
				Parameter LNGExports2 {
					IndexDomain: (mon,lngexp_qp);
				}
				Parameter LNG_ExportCapacity2 {
					IndexDomain: (year,lngexp);
				}
				Parameter LNG_Utilization {
					IndexDomain: mon;
				}
			}
		}
		Procedure Initialize_LNGDemand {
			Body: {
				LNG_Demand('Europe',xyear) := Cons_EuropeOECD(xyear);
				LNG_Demand('Asia',xyear) := Cons_Japan(xyear)  + Cons_SKorea(xyear)  + Cons_China(xyear)  -Prod_China(xyear) ;
			}
			Comment: {
				"Assign consumption volumes from IEO/WEPS/INGM to the LNG demand paramter.
				For Asia, sum the consumption of the 3 largest LNG consumers and subtract their production (only China)."
			}
		}
		Procedure Initialize_LNGParameters {
			Body: {
				!Only run once if AIMMS is kept open; otherwise, always run when called
				!Initialize data from last cycle
				if (KEEPOPEN=0 or NCNTRL_CURITR('1')=1 or AIMMS_Standalone_Switch=1) then
					LastCycle_LNGExports(year, lngexp_qp) := sum(LNGTER,NGTDMREP_NALNGEXP(LNGTER,NEMSmap_MNUMYR(year))*NEMSmap_LNGTER_lngexp(lngter,lngexp_qp));
					LastCycle_Production(year) := NGTDMREP_OGPRDNG(TotalUS_MNUMOR, NEMSmap_MNUMYR(year));
					LastCycle_USLNGSupplyPrice(year,lngexp_qp) :=sum((OGDIST,s)|NEMSmap_OGDIST_SupplyNode(OGDIST,s), NGTDMREP_OGPRCNG(OGDIST,NEMSmap_MNUMYR(year))*map_supply_lngexp(s,lngexp_qp));
				endif;
				
				!Initialize LNG export capacity based on history, assumptions
				AnnualLNGExports(year,lngexp_qp) := LNG_ExportCapacity(year,lngexp_qp);
				AnnualLNGExports(futyear,AKState) := 0.00;
				
				!Convert LNG price into 1987$/Mcf
				HistoricalLNGPrice(year,d_lng)*=  Convert_TBtu_Bcf(year)/ GDPPriceDeflator87(year);
				
				
				!Initialize price variables
				LastCycle_USLNGSupplyPrice((xyear,lngexp_qp)|xyear>LastModelYear) :=LastCycle_USLNGSupplyPrice(LastModelYear,lngexp_qp);
				LNG_ConvergenceFactor(LastHistoricalYear,lngexp_qp) := 1;
				USLNGSupplyPrice(histyr,lngexp_qp) := LastCycle_USLNGSupplyPrice(histyr,lngexp_qp);
				
				NEMS_WOP_Memo(NEMSmap_XYear(MNXYRS)) :=MXPBLK_XBRENT_PRICE(MNXYRS);
				
				WeightedAveExpectedWOP(year) := sum((look_yrs,xyear)|xyear=year, (Card(NumberOfYearsForLookAhead_LNG_)-Val(look_yrs)+1)*NEMS_WOP_Memo(xyear+Val(look_yrs)-1))/$
								sum(look_yrs,Card(NumberOfYearsForLookAhead_LNG_)-Val(look_yrs)+1);
				
				WOP_CurveStep(year) := last(step_wop|(WeightedAveExpectedWOP(year)> LNG_step_OilPrice(step_wop)));
				
				
				EpFlexLNG_OilPriceAdj(year) := LNG_ExpFlexLNG_adj(WOP_CurveStep(year))+
								(((WeightedAveExpectedWOP(year)-LNG_step_OilPrice(WOP_CurveStep(year)))*(LNG_ExpFlexLNG_adj(WOP_CurveStep(year)+1)-LNG_ExpFlexLNG_adj(WOP_CurveStep(year))))/
								(LNG_step_OilPrice(WOP_CurveStep(year)+1)-LNG_step_OilPrice(WOP_CurveStep(year))));
				
				LNG_ExpFlexLNGYr(year,d_lng) :=LNG_ExpFlexLNG(d_lng) + EpFlexLNG_OilPriceAdj(year);
			}
		}
		Procedure Initialize_LNGTransCost {
			Body: {
				LNG_Liquefaction(lngexp_qp)*= Convert_TBtu_Bcf(LNG_CostsYrDollars)/ GDPPriceDeflator87(LNG_CostsYrDollars);
				LNG_Regasification(lngexp_qp)*= Convert_TBtu_Bcf(LNG_CostsYrDollars)/ GDPPriceDeflator87(LNG_CostsYrDollars);
				LNG_ShippingCost(lngexp_qp,d_lng)*= Convert_TBtu_Bcf(LNG_CostsYrDollars)/ GDPPriceDeflator87(LNG_CostsYrDollars);
				LNG_SunkCost(lngexp_qp)*= Convert_TBtu_Bcf(LNG_CostsYrDollars)/ GDPPriceDeflator87(LNG_CostsYrDollars);
				
				
				LNG_TransCost(lngexp_qp,d_lng) := (LNG_Liquefaction(lngexp_qp)+ LNG_Regasification(lngexp_qp) + LNG_ShippingCost(lngexp_qp,d_lng));
			}
			Comment: "Calcualte transportation costs (not including fuel percentages).  Convert to 87$.";
		}
		DeclarationSection LNG_Exports_Declarations {
			Parameter LNGExports {
				IndexDomain: (mon,lngexp_qp);
			}
			ElementParameter LNG_FirstBuildYear {
				Range: Years_;
			}
			Parameter AnnualLNGExports {
				IndexDomain: (year,lngexp);
			}
			Parameter HistoricalLNGPrice {
				IndexDomain: (year,d_lng);
			}
			Parameter LNGPrice {
				IndexDomain: (year,d_lng);
			}
			Parameter Pct_Liquifaction_Fuel;
			Parameter LNG_ExportCapacity {
				IndexDomain: (year,lngexp);
			}
			Parameter Convert_barrel_MMBtu;
			Parameter USInitialLNGExports {
				IndexDomain: (year,lngexp);
				Comment: {
					"!Same as DOMEXP variable in NGTDM code"
				}
			}
			Parameter LastCycle_LNGExports {
				IndexDomain: (year,lngexp);
			}
		}
		DeclarationSection LNG_Demand_Declarations {
			Parameter Cons_EuropeOECD {
				IndexDomain: xyear;
			}
			Parameter Cons_Japan {
				IndexDomain: xyear;
			}
			Parameter Cons_SKorea {
				IndexDomain: xyear;
			}
			Parameter Cons_China {
				IndexDomain: xyear;
			}
			Parameter Prod_China {
				IndexDomain: xyear;
			}
			Parameter LNG_Demand {
				IndexDomain: (d_lng,xyear);
			}
		}
		DeclarationSection LNG_Transportation_Cost_Declarations {
			ElementParameter LNG_CostsYrDollars {
				Range: Years_;
			}
			Parameter LNG_Liquefaction {
				IndexDomain: (lngexp);
			}
			Parameter LNG_SunkCost {
				IndexDomain: (lngexp);
			}
			Parameter LNG_Regasification {
				IndexDomain: (lngexp);
			}
			Parameter LNG_ShippingCost {
				IndexDomain: (lngexp,d_lng);
			}
			Parameter LNG_PctLossShipping {
				IndexDomain: (lngexp,d_lng);
			}
			Parameter LNG_TransCost {
				IndexDomain: (lngexp,d_lng);
			}
		}
		DeclarationSection LNG_Oil_Price_Declarations {
			Parameter NEMS_WOP_Memo {
				IndexDomain: xyear;
			}
			ElementParameter NEMSmap_XYear {
				IndexDomain: MNXYRS;
				Range: XYears_;
				Definition: ElementCast(XYears_,MNXYRS+1989);
			}
			Parameter WeightedAveExpectedWOP {
				IndexDomain: year;
			}
			Set NumberOfYearsForLookAhead_LNG_ {
				Index: look_yrs;
			}
			Parameter EpFlexLNG_OilPriceAdj {
				IndexDomain: year;
			}
			ElementParameter WOP_CurveStep {
				IndexDomain: year;
				Range: LNG_OilPriceSteps_;
			}
		}
		DeclarationSection LNG_Flex_Ratio_Declarations {
			Parameter LNG_WorldFlex {
				IndexDomain: xyear;
			}
			Parameter LNG_USFlex {
				IndexDomain: xyear;
			}
			Parameter LNG_PctFlex {
				IndexDomain: d_lng;
			}
			Parameter LNG_ExpFlexLNG {
				IndexDomain: d_lng;
			}
			Parameter LNG_ExpFlexLNG_adj {
				IndexDomain: step_wop;
			}
		}
		Procedure Calculate_WorldLNGPrices {
			Body: {
				LNG_USFlex(year) := 	sum(ussup,LNG_ExportCapacity(year,ussup));
				LNG_USFlex(xyear|LastModelYear < xyear) := 	LNG_USFlex(LastModelYear);
				
				ModelYearRatio_FlexLNG(ModelYear,d_lng) :=((LNG_WorldFlex(ModelYear)+((LNG_USFlex(ModelYear)+LNG_Increment)*LNG_PctFlex(d_lng)))/
								LNG_Demand(d_lng,ModelYear))/
								((LNG_WorldFlex(LastHistoricalYear)+(LNG_USFlex(LastHistoricalYear)*LNG_PctFlex(d_lng)))/
								LNG_Demand(d_lng,LastHistoricalYear));
				
				WorldLNGPrice(ModelYear,d_lng) :=((NEMS_WOP_Memo(ElementCast(XYears_,ModelYear))/Convert_barrel_MMBtu)^LNG_ExpOil(d_lng))*
									(ModelYearRatio_FlexLNG(ModelYear,d_lng)^(LNG_ExpFlexLNGYr(ModelYear,d_lng)));
				
				
				Ratio_FlexLNG(look_yrs,d_lng) :=((LNG_WorldFlex(ElementCast(XYears_,ModelYear)+Val(look_yrs))+((LNG_USFlex(ElementCast(XYears_,ModelYear)+Val(look_yrs))+LNG_Increment)*LNG_PctFlex(d_lng)))/
								LNG_Demand(d_lng,ElementCast(XYears_,ModelYear)+Val(look_yrs)))/
								((LNG_WorldFlex(ElementCast(XYears_,LastHistoricalYear))+(LNG_USFlex(ElementCast(XYears_,LastHistoricalYear))*LNG_PctFlex(d_lng)))/
								LNG_Demand(d_lng,ElementCast(XYears_,LastHistoricalYear)));
				
				LNG_LookAheadPrice(look_yrs,d_lng) :=	Power((NEMS_WOP_Memo(ElementCast(XYears_,ModelYear)+Val(look_yrs))/Convert_barrel_MMBtu),LNG_ExpOil(d_lng))*
									Power(Ratio_FlexLNG(look_yrs,d_lng),(LNG_ExpFlexLNGYr(ElementCast(XYears_,ModelYear),d_lng)));
				
				WorldFutureLNGPrice(ModelYear,d_lng) := sum(look_yrs,LNG_LookAheadPrice(look_yrs,d_lng)/Power((1+LNG_DCFDiscountRate),Val(look_yrs)));
			}
		}
		Procedure Calculate_USLNGExportPrices {
			Body: {
				FutureYear(look_yrs) := ElementCast(XYears_,ModelYear)+Val(look_yrs);
				LastFutureYear := FutureYear(last(look_yrs));
				
				!When adding into NEMS, may need to add convergence code/gamma/changes to USLNGExportPrice
				!In old version; new below
				!USLNGSupplyPrice_Adj(lngexp_qp) := sum(s,WellhdPrice(ModelYear, Supply_NA, s)*map_supply_lngexp(s,lngexp_qp))-LastCycle_USLNGSupplyPrice(ModelYear,lngexp_qp);
				
				!LNG_USLookAheadPrice(look_yrs,lngexp_qp,d_lng) := ((LastCycle_USLNGSupplyPrice(FutureYear(look_yrs),lngexp_qp)+ USLNGSupplyPrice_Adj(lngexp_qp) )*(1+LNG_PctFuelCharge(lngexp_qp)))+
				!                                                  LNG_TransCost(lngexp_qp,d_lng);
				
				!Calculate factors for supply price adjustments to aid in convergence
				!LNG_Gamma_Adj := LNGGAMCN + LNGGAMLV * (sum(ussup, ActualProductionAnnual(ModelYear, Supply_NA, ussup)) / sum(ussup, AnnualSupply (ModelYear, Supply_NA, ussup)));
				LNG_Gamma_Adj := x_LNG_Gamma1 + x_LNG_Gamma2 * (sum(ussup, ActualProductionAnnual(ModelYear, Supply_NA, ussup)) / sum(ussup, AnnualSupply (ModelYear, Supply_NA, ussup)));
				
				!LNG_ConvergenceFactor((year,lngexp_qp)|year>=ModelYear and year <= LastFutureYear) := 
				!	((LastCycle_Production(year) + LNG_ExportCapacity(year,lngexp_qp) - LastCycle_LNGExports(year,lngexp_qp))/LastCycle_Production(year)) ^ LNG_Gamma_Adj;
				
				!LNG_ConvergenceFactor((year,lngexp_qp)|year > LastFutureYear) := 
				!	((LastCycle_Production(year) + LNG_ExportCapacity(year,lngexp_qp) + LNG_Increment - LastCycle_LNGExports(year,lngexp_qp))/ LastCycle_Production(year)) ^ LNG_Gamma_Adj;
				
				LNG_ConvergenceFactor((year,lngexp_qp)|year>=ModelYear) := 
					((LastCycle_Production(year) + LNG_ExportCapacity(year,lngexp_qp) + LNG_Increment - LastCycle_LNGExports(year,lngexp_qp))/LastCycle_Production(year)) ^ LNG_Gamma_Adj;
				
				
				USLNGSupplyPrice(ModelYear, lngexp_qp) := sum(s,WellhdPrice_Soln(ModelYear, Supply_NA, s)*map_supply_lngexp(s,lngexp_qp)) ; 
				USLNGSupplyPrice((year, lngexp_qp)| year>ModelYear) := LastCycle_USLNGSupplyPrice(year,lngexp_qp)* LNG_ConvergenceFactor(year,lngexp_qp) * 
											(USLNGSupplyPrice(ModelYear-1,lngexp_qp)/(LastCycle_USLNGSupplyPrice(ModelYear-1,lngexp_qp)*LNG_ConvergenceFactor(ModelYear-1,lngexp_qp)));
				
				!NEW NEW NEW
				!USLNGSupplyPrice((xyear,lngexp_qp)|xyear>LastModelYear) := USLNGSupplyPrice(LastModelYear, lngexp_qp);
				LNG_GrowthRate(lngexp_qp) := (USLNGSupplyPrice(LastModelYear, lngexp_qp)-USLNGSupplyPrice(LNG_GrowthRateYr, lngexp_qp))/(USLNGSupplyPrice(LNG_GrowthRateYr, lngexp_qp)*(Val(LastModelYear)-Val(LNG_GrowthRateYr)));
				USLNGSupplyPrice((xyear,lngexp_qp)|xyear>LastModelYear) := USLNGSupplyPrice(xyear-1, lngexp_qp)*(1+LNG_GrowthRate(lngexp_qp));
				
				
				LNG_USLookAheadPrice(look_yrs,lngexp_qp,d_lng) := ((USLNGSupplyPrice(FutureYear(look_yrs),lngexp_qp) )*(1+LNG_PctFuelCharge(lngexp_qp)))+
				                                                   LNG_TransCost(lngexp_qp,d_lng);
				
				LNG_USDiscount(lngexp_qp,d_lng) := sum(look_yrs, (LNG_LookAheadPrice(look_yrs,d_lng)-LNG_USLookAheadPrice(look_yrs,lngexp_qp,d_lng))/Power((1+LNG_DCFDiscountRate),Val(look_yrs)));
				
				USLNGTotalCost(ModelYear,lngexp_qp,d_lng):= sum(look_yrs,LNG_USLookAheadPrice(look_yrs,lngexp_qp,d_lng)/Power((1+LNG_DCFDiscountRate),Val(look_yrs)));
				LNG_USDiscount_yr(ModelYear,lngexp_qp,d_lng) :=LNG_USDiscount(lngexp_qp,d_lng);
				
				!HAVE TO CHANGE THE SUPPLY PRICE THING TO GO WITH RESTART FILE OTHERWISE BAAAAAAD BAAADDDD BAAADDDD
			}
		}
		Procedure Calculate_AKLNGExportPrices {
			Body: {
				!AK_ANGTS_Min_WHPrice
				LNG_AKTransCost(d_lng) := (LNG_AKLiquefaction + LNG_AKRegasification + LNG_AKShippingCost(d_lng));
				LNG_AKTransCost(d_lng)*= Convert_TBtu_Bcf(LNG_CostsYrDollars)/ GDPPriceDeflator87(LNG_CostsYrDollars);
				
				LNG_AKLookAheadPrice(look_yrs,d_lng) := (AK_ANGTS_Min_WHPrice*(1+LNG_AKPctFuelCharge))+LNG_AKTransCost(d_lng);
				
				LNG_AKDiscount(d_lng) := sum(look_yrs, (LNG_LookAheadPrice(look_yrs,d_lng)-LNG_AKLookAheadPrice(look_yrs,d_lng))/Power((1+LNG_DCFDiscountRate),Val(look_yrs)));
				
				AKLNGTotalCost(ModelYear,d_lng):= sum(look_yrs,LNG_AKLookAheadPrice(look_yrs,d_lng)/Power((1+LNG_DCFDiscountRate),Val(look_yrs)));
			}
		}
		Procedure AddLNGEportCapacity {
			Body: {
				!Empty element parameter
				empty LNG_AddedCapacity;
				
				!Determine optimal destination for each LNG export terminal
				LNG_BestDestination(lngexp_qp) := ArgMax(d_lng,LNG_USDiscount(lngexp_qp,d_lng));
				
				! LNG Export Capacity added to region/state with highest discount for world
				LNG_AddedCapacity:= ArgMax(lngexp_qp|	(((Val(ModelYear) + LNG_YrsUntilBuild )>= LNG_FirstYear(lngexp_qp))
									and ((LNG_ExportCapacity(LastModelYear,lngexp_qp)+LNG_Increment)<= LNG_MaxExports(lngexp_qp))
									and (Exists(d_lng|LNG_USDiscount(lngexp_qp,d_lng)>0))),
									!ArgMax(d_lng,LNG_USDiscount(lngexp_qp,d_lng)));
									LNG_USDiscount(lngexp_qp,LNG_BestDestination(lngexp_qp))); !When fiixable, use this
				
				! Check against AK; AK capacity added if cheaper
				if (((Val(ModelYear) + LNG_YrsUntilBuild )>= LNG_AKFirstYear)
					and ((LNG_ExportCapacity(LastModelYear,AKState)+LNG_Increment)<= LNG_AKMaxExports)
					and Exists(d_lng|LNG_AKDiscount(d_lng)>LNG_USDiscount(LNG_AddedCapacity,d_lng))) then
					LNG_AddedCapacity := AKState;
				endif;
				
				!Count Added LNG Train to yearly total (max equals LNG_MaxTrainsYr)
				if (LNG_AddedCapacity) then
					AddedLNGTrains+=1;
					LNG_TrainsPerYr(ModelYear) := AddedLNGTrains ;
				
					if (LNG_USDiscount(LNG_AddedCapacity,LNG_BestDestination(LNG_AddedCapacity)) < LNG_RiskThreshold) then
						AddedLNGTrains := LNG_MaxTrainsYr;
					endif;
				
				endif;
				
				!Add LNG Export capacity to existing capacity for future years
				!if in Lower 48, add capacity over 2 years as stipulated by input parameters
				!if in AK, add 4 trains (AK Train Total) over 4 years
				counter :=0;
				if (LNG_AddedCapacity in LNGTerminals_QP_) then
					while (counter <LNG_PhaseInYrs) do
					LNG_ExportCapacity((NEMSmap_Year(NEMSmap_MNUMYR(ModelYear)+ LNG_YrsUntilBuild+counter),LNG_AddedCapacity)|(NEMSmap_Year(NEMSmap_MNUMYR(ModelYear) + LNG_YrsUntilBuild+counter)<=LastModelYear))+=
						(((counter+1)*LNG_Increment)/ LNG_PhaseInYrs);
					counter += 1;
					!LNG_ExportCapacity((NEMSmap_Year(NEMSmap_MNUMYR(ModelYear) + LNG_YrsUntilBuild+1),LNG_AddedCapacity)|(NEMSmap_Year(NEMSmap_MNUMYR(ModelYear) + LNG_YrsUntilBuild+1)<=LastModelYear))=
					!	(LNG_PctCapacityYr2*LNG_Increment);
					endwhile;
					while (NEMSmap_XYear(NEMSmap_MNXYRS(ModelYear) + LNG_YrsUntilBuild+counter) <= LastYearInCalendar) do
						LNG_ExportCapacity(NEMSmap_XYear(NEMSmap_MNXYRS(ModelYear) + LNG_YrsUntilBuild+counter),LNG_AddedCapacity)+=LNG_Increment;
					counter +=1;
					endwhile;
				elseif (LNG_AddedCapacity = AKState) then
					while (counter < LNG_AKTrainTotal) do
					LNG_ExportCapacity((NEMSmap_Year(NEMSmap_MNUMYR(ModelYear) + LNG_YrsUntilBuild+counter),LNG_AddedCapacity)|(NEMSmap_Year(NEMSmap_MNUMYR(ModelYear) + LNG_YrsUntilBuild)<=LastModelYear)) +=
						(LNG_Increment*counter);
					counter +=1;
					endwhile;
					while (NEMSmap_XYear(NEMSmap_MNXYRS(ModelYear) + LNG_YrsUntilBuild+counter) <= LastYearInCalendar) do
						LNG_ExportCapacity(NEMSmap_XYear(NEMSmap_MNXYRS(ModelYear) + LNG_YrsUntilBuild+counter),LNG_AddedCapacity)+=(LNG_Increment* LNG_AKTrainTotal);
					counter +=1;
					endwhile;
					!LNG_ExportCapacity((NEMSmap_Year(NEMSmap_MNUMYR(ModelYear) + LNG_YrsUntilBuild+1),LNG_AddedCapacity)|(NEMSmap_Year(NEMSmap_MNUMYR(ModelYear) + LNG_YrsUntilBuild+1)<=LastModelYear))+=
					!	(2*LNG_Increment);
					!LNG_ExportCapacity((NEMSmap_Year(NEMSmap_MNUMYR(ModelYear) + LNG_YrsUntilBuild+2),LNG_AddedCapacity)|(NEMSmap_Year(NEMSmap_MNUMYR(ModelYear) + LNG_YrsUntilBuild+2)<=LastModelYear))+=
					!	+LNG_Increment;
					AddedLNGTrains := LNG_MaxTrainsYr;
				endif;
			}
		}
		Procedure LNGExportUtilization_Run {
			Body: {
				
				!if ( not ncntrl_ncrl(1) ) then
					!Only put this in if necessary; may only be able to if loading a case with this value
					!LastIteration_USLNGExportPrice(year,lngexp1) :=USLNGExportPrice(year,lngexp1);
					USLNGExportPrice(ModelYear,lngexp_qp) := sum(s,WellhdPrice(ModelYear-1, Supply_NA, s)*map_supply_lngexp(s,lngexp_qp))*(1+LNG_PctFuelCharge(lngexp_qp))+LNG_Liquefaction(lngexp_qp)-
					                          LNG_SunkCost(lngexp_qp);
					USLNGExportPrice_toDest(ModelYear,lngexp_qp,d_lng) := (USLNGExportPrice(ModelYear,lngexp_qp)-LNG_Liquefaction(lngexp_qp)) +LNG_TransCost(lngexp_qp,d_lng);
				
				
				if (LNG_FixedExports_Switch = 0) then
					LNG_USFlex(year) := 	sum(ussup,LNG_ExportCapacity(year,ussup));
				
					ModelYearRatio_FlexLNG(ModelYear,d_lng) :=((LNG_WorldFlex(ModelYear)+((LNG_USFlex(ModelYear))*LNG_PctFlex(d_lng)))/
								LNG_Demand(d_lng,ModelYear))/
								((LNG_WorldFlex(LastHistoricalYear)+(LNG_USFlex(LastHistoricalYear)*LNG_PctFlex(d_lng)))/
								LNG_Demand(d_lng,LastHistoricalYear));
				
					WorldLNGPrice(ModelYear,d_lng) :=((NEMS_WOP_Memo(ElementCast(XYears_,ModelYear))/Convert_barrel_MMBtu)^LNG_ExpOil(d_lng))*
									(ModelYearRatio_FlexLNG(ModelYear,d_lng)^(LNG_ExpFlexLNGYr(ModelYear,d_lng)));
				
					!Set Prices for LNG Export Curve
					!LNGMaxPrice Will set the first step (where exports will be zero if the price is higher)
					!LNGMinPrice will set the second step where exports will equal the capacity built if the price is lower or equal
					LNGMaxPrice(ModelYear,lngexp_qp) := Max(d_lng,(((1/LNG_LowPriceRatio)* WorldLNGPrice(ModelYear,d_lng))-(LNG_TransCost(lngexp_qp,d_lng)-LNG_SunkCost(lngexp_qp)))/
					                                    (1+LNG_PctFuelCharge(lngexp_qp)));
					LNGMinPrice(ModelYear,lngexp_qp) := Max(d_lng,(((1/LNG_HighPriceRatio)* WorldLNGPrice(ModelYear,d_lng))-(LNG_TransCost(lngexp_qp,d_lng)-LNG_SunkCost(lngexp_qp)))/
					                                    (1+LNG_PctFuelCharge(lngexp_qp)));
				
				
				!Old Utilization Routine; may have to come back to it
					!Ratio_WorldtoUS(ModelYear,lngexp1,d_lng) := WorldLNGPrice(ModelYear,d_lng)/USLNGExportPrice_toDest(ModelYear,lngexp1,d_lng);
				
					!FIX THIS FIX THIS
					!for lngexp1 do
					!	SolvedLNGDestination :=ArgMax(d_lng,Ratio_WorldtoUS(ModelYear,lngexp1,d_lng));
					!	if(Ratio_WorldtoUS(ModelYear,lngexp1,SolvedLNGDestination) <= LNG_LowPriceRatio ) then
					!		AnnualLNGExports(ModelYear,lngexp1) := 0;
					!	elseif(Ratio_WorldtoUS(ModelYear,lngexp1,SolvedLNGDestination) <=  LNG_HighPriceRatio) then
					!		AnnualLNGExports(ModelYear,lngexp1) := LNG_ExportCapacity(ModelYear,lngexp1) *
					!					((Ratio_WorldtoUS(ModelYear,lngexp1,SolvedLNGDestination)-LNG_LowPriceRatio)/(LNG_HighPriceRatio-LNG_LowPriceRatio));
					!	else
					!		AnnualLNGExports(ModelYear,lngexp1) := LNG_ExportCapacity(ModelYear,lngexp1)
					!	endif;
					!endfor;
				!AnnualLNGExports(ModelYear,lngexp1) := LNG_ExportCapacity(ModelYear,lngexp1);
				!LNGExports(modelyrmn,lngexp_qp) :=LNG_ExportCapacity(MonthToYear(modelyrmn), lngexp_qp) * NumberOfDaysInMonth(modelyrmn)/ NumberOfDaysInYear(MonthToYear(modelyrmn));
				
				!endif;
				endif;
				
				if ModelYear >= LNG_FirstBuildYear then
					LNGExports(modelyrmn,lngexp_qp) :=LNG_ExportCapacity(MonthToYear(modelyrmn), lngexp_qp) * NumberOfDaysInMonth(modelyrmn)/ NumberOfDaysInYear(MonthToYear(modelyrmn));
				endif;
			}
		}
		DeclarationSection LNG_Export_World_Price_Declarations {
			Parameter LNG_ExpOil {
				IndexDomain: d_lng;
			}
			Set LNG_OilPriceSteps_ {
				Index: step_wop;
			}
			Parameter LNG_step_OilPrice {
				IndexDomain: step_wop;
			}
			Parameter LNG_ExpFlexLNGYr {
				IndexDomain: (year,d_lng);
			}
			Parameter Ratio_FlexLNG {
				IndexDomain: (look_yrs,d_lng);
			}
			Parameter LNG_LookAheadPrice {
				IndexDomain: (look_yrs,d_lng);
			}
			Parameter WorldLNGPrice {
				IndexDomain: (year,d_lng);
			}
			Parameter WorldFutureLNGPrice {
				IndexDomain: (year,d_lng);
			}
			Parameter ModelYearRatio_FlexLNG {
				IndexDomain: (year,d_lng);
			}
			Parameter NEMSmap_M2_d_lng {
				IndexDomain: (M2,d_lng);
				Range: binary;
			}
		}
		DeclarationSection LNG_Export_US_Price_Declarations {
			ElementParameter FutureYear {
				IndexDomain: look_yrs;
				Range: XYears_;
			}
			Parameter LNG_PctFuelCharge {
				IndexDomain: (lngexp);
			}
			Parameter USLNGSupplyPrice {
				IndexDomain: (xyear,lngexp);
			}
			Parameter LNG_USLookAheadPrice {
				IndexDomain: (look_yrs,lngexp,d_lng);
			}
			Parameter LNG_USDiscount {
				IndexDomain: (lngexp,d_lng);
			}
			Parameter LNG_USDiscount_yr {
				IndexDomain: (year,lngexp,d_lng);
			}
			Parameter USLNGTotalCost {
				IndexDomain: (year,lngexp,d_lng);
			}
			Parameter LastCycle_USLNGSupplyPrice {
				IndexDomain: (xyear,lngexp);
			}
			Parameter USLNGSupplyPrice_Adj {
				IndexDomain: (lngexp);
			}
			Parameter LastCycle_Production {
				IndexDomain: xyear;
			}
		}
		DeclarationSection LNG_Export_Capacity_Expansion_Declarations {
			Parameter LNG_MaxExports {
				IndexDomain: (lngexp);
			}
			Parameter LNG_FirstYear {
				IndexDomain: (lngexp);
			}
			Parameter LNG_Increment;
			Parameter LNG_DCFDiscountRate;
			Parameter LNG_YrsUntilBuild;
			Parameter LNG_PctCapacityYr1;
			Parameter LNG_PctCapacityYr2;
			Parameter LNG_PhaseInYrs;
			Parameter LNG_MaxTrainsYr;
			Parameter LNG_PeakExports {
				IndexDomain: (lngexp);
			}
			ElementParameter LNG_AddedCapacity {
				Range: PossibleLNGTerminals_;
			}
			Parameter AddedLNGTrains;
			Parameter LNG_TrainsPerYr {
				IndexDomain: year;
			}
			Parameter LNG_RiskThreshold;
			Parameter LNG_GrowthRate {
				IndexDomain: lngexp_qp;
			}
			ElementParameter LNG_BestDestination {
				IndexDomain: lngexp_qp;
				Range: LNGDestination_;
			}
			ElementParameter LNG_GrowthRateYr {
				Range: XYears_;
			}
		}
		DeclarationSection LNG_AK_Export_Declarations {
			Parameter LNG_AKLiquefaction;
			Parameter AK_ANGTS_Min_WHPrice;
			Parameter LNG_AKMaxExports;
			Parameter LNG_AKPeakExports;
			Parameter LNG_AKFirstYear;
			Parameter LNG_AKPctFuelCharge;
			Parameter LNG_AKSunkCost;
			Parameter LNG_AKRegasification;
			Parameter LNG_AKShippingCost {
				IndexDomain: (d_lng);
			}
			Parameter LNG_AKPctLossShipping {
				IndexDomain: (d_lng);
			}
			Parameter LNG_AKTransCost {
				IndexDomain: (d_lng);
			}
			Parameter LNG_AKLookAheadPrice {
				IndexDomain: (look_yrs,d_lng);
			}
			Parameter LNG_AKDiscount {
				IndexDomain: (d_lng);
			}
			Parameter AKLNGTotalCost {
				IndexDomain: (year,d_lng);
			}
			Parameter LNG_AKTrainTotal;
			Parameter LNG_AKExportCapacity {
				IndexDomain: (year);
			}
		}
		DeclarationSection LNG_Export_Utilization_Declarations {
			Parameter LNG_HighPriceRatio;
			ElementParameter SolvedLNGDestination {
				Range: LNGDestination_;
			}
			Parameter LNG_LowPriceRatio;
			Parameter LastIteration_USLNGExportPrice {
				IndexDomain: (year,lngexp);
			}
			Parameter USLNGExportPrice_toDest {
				IndexDomain: (year,lngexp,d_lng);
			}
			Parameter USLNGExportPrice {
				IndexDomain: (year,lngexp);
			}
			Parameter Ratio_WorldtoUS {
				IndexDomain: (year,lngexp,d_lng);
			}
			Parameter LNGMaxPrice {
				IndexDomain: (year,lngexp);
			}
			Parameter LNGMinPrice {
				IndexDomain: (year,lngexp);
			}
		}
		DeclarationSection LNG_Export_Convergence_Declarations {
			Parameter x_LNG_Gamma1;
			Parameter x_LNG_Gamma2;
			Parameter LNG_Gamma_Adj;
			Parameter LNG_ConvergenceFactor {
				IndexDomain: (year,lngexp_qp);
			}
		}
		Section LNG_Export_PostProcessing {
			Procedure LNGAnnualExports_PostProcess {
				Body: {
					QTotalLNGExports(MonthInPeriod(tmon),lngexp_qp) := Sum(step | step <= LNGExpCrv_MaxStep, QLNGexp(tmon,lngexp_qp,step));
					AnnualLNGExports(ModelYear,lngexp_qp) := sum(modelyrmn,QTotalLNGExports(modelyrmn,lngexp_qp)/(1+Pct_Liquifaction_Fuel));
					!Add Alaska and Western Canada
					AnnualLNGExports(ModelYear,CanadaWest) := LNG_ExportCapacity(ModelYear,CanadaWest);
					AnnualLNGExports(ModelYear,AKState) := AK_LNG_Exports(ModelYear);
					LNGFuelForLiquefaction(ModelYear,lngexp) :=AnnualLNGExports(ModelYear,lngexp) *Pct_Liquifaction_Fuel ;
					TotalLNGExportsAnnual(ModelYear) := sum(lngexp_l48, AnnualLNGExports(ModelYear, lngexp_l48));
					
					!Sum up to census divisions
					!LNGLQfuelCDAnnual(ModelYear,r_cen) := sum(l48 | map_State_CensusRegion(l48, r_cen), LNGFuelForLiquefaction(ModelYear, l48) );
					!LNGLQfuelCDAnnual(ModelYear,CD_Pacific) += AK_LNG_Exports(ModelYear) * Pct_Liquifaction_Fuel; ! Correct
					!TotalLNGLQAnnual(ModelYear) := sum(r_cen, LNGLQfuelCDAnnual(ModelYear, r_cen));
					!
				}
			}
			DeclarationSection LNG_Export_PostProcessing_Identifiers {
				Parameter QTotalLNGExports {
					IndexDomain: (mon,lngexp_qp);
				}
				Parameter LNGFuelForLiquefaction {
					IndexDomain: (year,lngexp);
				}
				Parameter LNGLQfuelCDAnnual {
					IndexDomain: (year,r_cen);
				}
				Parameter TotalLNGLQAnnual {
					IndexDomain: year;
				}
			}
		}
		Section Exogenous_LNG_Export_Cases {
			DeclarationSection Exogenous_LNG_Export_Data_Declarations {
				Parameter ExogenousAnnualLNGExports {
					IndexDomain: (year,lngexp);
				}
				StringParameter ExogenousLNGExportCase;
				Set LNG_Export_Case_Identifiers {
					SubsetOf: AllIdentifiers;
					Index: lng_case;
					Definition: {
						Exogenous_LNG_Export_Cases;
					}
				}
				Parameter ExogenousAnnualLNGExports2016 {
					IndexDomain: (year,lngexp);
				}
				Parameter ExogenousAnnualLNGExports_orig20 {
					IndexDomain: (year,lngexp);
				}
				Parameter ExogenousAnnualLNGExports_orig30 {
					IndexDomain: (year,lngexp);
				}
				Parameter ExogenousAnnualLNGExports_orig30_TX {
					IndexDomain: (year,lngexp);
				}
				Parameter ExogenousAnnualLNGExports_orig30_LA {
					IndexDomain: (year,lngexp);
				}
				Parameter ExogenousAnnualLNGExports_orig40 {
					IndexDomain: (year,lngexp);
				}
				Parameter ExogenousAnnualLNGExports_30B {
					IndexDomain: (year,lngexp);
				}
				Parameter ExogenousAnnualLNGExports_35B {
					IndexDomain: (year,lngexp);
				}
				Parameter ExogenousAnnualLNGExports_40B {
					IndexDomain: (year,lngexp);
				}
			}
			Procedure Set_Exogenous_LNGExports {
				Body: {
					if (ExogenousLNGExportCase = "orig20") then
						LNG_ExportCapacity(year,lngexp_qp) :=ExogenousAnnualLNGExports_orig20(year,lngexp_qp);
					elseif  (ExogenousLNGExportCase = "orig30") then
						LNG_ExportCapacity(year,lngexp_qp) :=ExogenousAnnualLNGExports_orig30(year,lngexp_qp);
					elseif  (ExogenousLNGExportCase = "orig40") then
						LNG_ExportCapacity(year,lngexp_qp) :=ExogenousAnnualLNGExports_orig40(year,lngexp_qp);
					elseif  (ExogenousLNGExportCase = "30B") then
						LNG_ExportCapacity(year,lngexp_qp) :=ExogenousAnnualLNGExports_30B(year,lngexp_qp);
					elseif  (ExogenousLNGExportCase = "35B") then
						LNG_ExportCapacity(year,lngexp_qp) :=ExogenousAnnualLNGExports_35B(year,lngexp_qp);	
					elseif  (ExogenousLNGExportCase = "40B") then
						LNG_ExportCapacity(year,lngexp_qp) :=ExogenousAnnualLNGExports_40B(year,lngexp_qp);	
					else
						LNG_ExportCapacity(year,lngexp_qp) :=ExogenousAnnualLNGExports(year,lngexp_qp);	
					endif;	
					
					USLNGExportPrice(year,lngexp_qp) := 3;
					
					!NGTDMREP_NALNGEXP(LNGTER,MNUMYR) :=LNG_ExportCapacity(year,lngexp)
					!OGSMOUT_OGQNGEXP(MNUMBX,MNUMYR)
				}
			}
		}
	}
	Section Pipefuel_Storage_and_Distribution_Losses_Section {
		DeclarationSection Losses_Declarations {
			Parameter PipeFuelLossFactorOUT {
				IndexDomain: (reg,reg1);
			}
			Parameter PipeFuelLossFactorIN {
				IndexDomain: (reg,reg1);
			}
			Parameter PipeFuelLoss {
				IndexDomain: (mon,h);
			}
			Parameter PipeFuelLossAnnual {
				IndexDomain: (year,reg);
			}
			Parameter IntrastatePipeFuelFactor {
				IndexDomain: (reg,suptype);
				InitialData: 0;
			}
			Parameter IntrastatePipeFuelLosses {
				IndexDomain: (mon,reg);
			}
			Parameter IntrastatePipeFuelLossesAnnual {
				IndexDomain: (year,d);
			}
			Parameter StorageLossFactor {
				IndexDomain: reg;
			}
			Parameter DistributionLossFactor {
				IndexDomain: reg;
			}
			Parameter DistributionLosses {
				IndexDomain: (mon,reg);
			}
			Parameter StorageLosses {
				IndexDomain: (mon,reg);
			}
			Parameter DistributionLossesAnnual {
				IndexDomain: (year,d);
			}
			Parameter StorageLossesAnnual {
				IndexDomain: (year,d);
			}
		}
		Procedure PipefuelFactors_Initialize {
			Body: {
				
				TranFuelLosses(datayear, l48):= PipeFuelLossAnnual(datayear, l48) - StorageLossesAnnual(datayear, l48) - DistributionLossesAnnual(datayear,l48) - IntrastatePipeFuelLossesAnnual(datayear,l48);
				TranFuelLosses((datayear, l48) |TranFuelLosses(datayear, l48)<0):=0;
				Intersum(datayear, l48) := HistoricalFlowIn(datayear, l48) + HistoricalFlowOut(datayear, l48) + TranFuelLosses(datayear, l48);
				Ploss((datayear, l48) | HistoricalFlowIn(datayear, l48)) := (Intersum(datayear, l48) - sqrt( sqr(Intersum(datayear, l48)) - 4* HistoricalFlowIn(datayear, l48)* TranFuelLosses(datayear, l48))) /
											(2*HistoricalFlowIn(datayear, l48));
				Ploss((datayear, l48) | not HistoricalFlowIn(datayear, l48)) := TranFuelLosses(datayear, l48)/$ Intersum(datayear, l48);
				
				HisPipeFuelLossFactorIN((datayear, h, l48) | HistoricalFlowModel(h, l48, datayear)) := Ploss(datayear, l48); !incude border-crossing arcs?
				HisPipeFuelLossFactorOUT((datayear, l48, h) | HistoricalFlowModel(l48, h, datayear)) := Ploss(datayear, l48);
				
				!Set pipeline fuel factors = last historical year values
				!Calibration_Option is defined in ngassumptions.txt
				if (CalibrationMode=0 and Calibration_Option=0) then 
				  !pipeline fuel factors
				PipeFuelLossFactorIN(h, h1):=HisPipeFuelLossFactorIN(LastHistoricalYear, h, h1);
				PipeFuelLossFactorOUT(h, h1):=HisPipeFuelLossFactorOUT(LastHistoricalYear, h, h1);
				endif;
			}
			Parameter TranFuelLosses {
				IndexDomain: (datayear,reg);
			}
			Parameter Intersum {
				IndexDomain: (datayear,reg);
			}
		}
		Procedure Losses_InitializeData {
			Body: {
				!Calculate storage losses
				StorageLosses(datamon, storage) := (StorageWithdrawals(datamon, storage) + StorageInjections(datamon, storage)) * StorageLossFactor(storage);
				StorageLossesAnnual(datayear, l48) := HistoricalAnnualStorageLoss(datayear, l48);
				!Calculate distribution losses
				!**********Do Canada and Mexico separately **************
				DistributionLosses(datamon, l48) := sum(rescom, (Cons_State_Mon(datamon, rescom, l48) + Cons_State_Mon(datamon, rescom, l48)))
				                                    * DistributionLossFactor(l48);
				DistributionLossesAnnual(datayear,l48) := HistoricalAnnualDistributionLoss(datayear, l48);
				IntrastatePipeFuelLosses(datamon, l48) := sum((naadgas, qps) | map_SupplyArcs(qps, l48), ActualProductionMonthly(datamon, naadgas, qps)*IntrastatePipeFuelFactor(qps, naadgas));
				HistoricalAnnualIntrastateFuel(datayear, l48):=  sum(datamon |map_month_year(datamon,datayear), IntrastatePipeFuelLosses(datamon, l48));
				IntrastatePipeFuelLossesAnnual(datayear,l48) := HistoricalAnnualIntrastateFuel(datayear, l48);
				!TranFuelLosses(histyr, h) := sum(h1, FlowsAnnual(histyr, h, h1) * PipeFuelLossFactorOUT(h, h1))
				!                              + sum(h1, FlowsAnnual(histyr, h1, h) * (1 - PipeFuelLossFactorOUT(h1, h))* PipeFuelLossFactorIN(h1, h));
				!
				!PipeFuelLossAnnual(histyr, d) := TranFuelLosses(histyr, d) + sum( histmon | map_month_year(histmon, histyr), (DistributionLosses(histmon, d) +
				!                  StorageLosses(histmon, d)+ IntrastatePipeFuelLosses(histmon, d)));
				PipeFuelLossAnnual(datayear, d) := HistoricalAnnualPipeFuel(datayear, d);
				!Add Alaska
				PipeFuelLossAnnual(datayear, AKState) := sum(r_ak, AK_Pipeline(datayear,r_ak));
				
				!Deal with Texas
			}
			DeclarationSection pipefuel_history_Declaration {
				Parameter TranFuelLosses {
					IndexDomain: (histyr,reg);
				}
				Parameter Intersum {
					IndexDomain: (histyr,reg);
				}
				Parameter PipeFuelLossCDAnnual {
					IndexDomain: (year,r_cen);
				}
				Parameter TotalPipeFuelLossAnnual {
					IndexDomain: (histyr);
				}
			}
		}
		Procedure Calculate_Losses_Run {
			Body: {
				!Calculate storage losses
				StorageLosses(modelyrmn, storage) := (StorageWithdrawals(modelyrmn, storage) + StorageInjections(modelyrmn, storage)) * StorageLossFactor(storage);
				StorageLossesAnnual(ModelYear,l48)  := sum(modelyrmn, StorageLosses(modelyrmn, l48));
				!Calculate distribution losses
				!**********Do Canada and Mexico separately **************
				DistributionLosses(modelyrmn, l48) := (Cons_State_Mon(modelyrmn, 'Residential', l48) + Cons_State_Mon(modelyrmn, 'Commercial', l48))
				                                    * DistributionLossFactor(l48);
				DistributionLossesAnnual(ModelYear,l48)  := sum(modelyrmn, DistributionLosses(modelyrmn, l48));
				!Calculate intrastate pipe fuel losses
				IntrastatePipeFuelLosses((lagyrmn, h) | lagyrmn>=YearToMonth(ModelYear)) :=sum((naadgas, qps) | map_SupplyArcs(qps, h), ActualProductionMonthly(lagyrmn-12, naadgas, qps)*
				           IntrastatePipeFuelFactor(qps, naadgas));
				IntrastatePipeFuelLossesAnnual(ModelYear,l48)  := sum(modelyrmn, IntrastatePipeFuelLosses(modelyrmn, l48));
			}
		}
		Procedure Pipefuel_Postprocess {
			Body: {
				TranFuelLosses(modelyrmn, h) := (sum(h1, FlowsMonthly(modelyrmn, h, h1) * PipeFuelLossFactorOUT(h, h1))
				                              + sum(h1, FlowsMonthly(modelyrmn, h1, h) * (1 - PipeFuelLossFactorOUT(h1, h))* PipeFuelLossFactorIN(h1, h)))*STEOPipeFuelFactor(ModelYear);
				TotalTranFuelAnnual(ModelYear) :=sum((modelyrmn,l48), TranFuelLosses(modelyrmn, l48));
				PipeFuelLoss(modelyrmn, h) :=  TranFuelLosses(modelyrmn, h) + DistributionLosses(modelyrmn, h) + StorageLosses(modelyrmn, h) + IntrastatePipeFuelLosses(modelyrmn, h);
				
				
				
				PipeFuelLossAnnual(ModelYear, h) := sum(modelyrmn , PipeFuelLoss(modelyrmn, h));
				
				!Split out Texas fuel losses in history
				! Based on consumption for now until I can figure something to do with flows...
				PipeFuelLossAnnual(histyr| histyr in HistoricalYears_, r_tx) := (sum(rescom, HistoricalAnnualDemand(histyr, rescom, r_tx)) /$ sum(rescom, HistoricalAnnualDemand(histyr, rescom, TexasState))) * 
					PipeFuelLossAnnual(histyr, TexasState);
				
				!Add Alaska
				PipeFuelLossAnnual(ModelYear, AKState) := sum(r_ak, AK_Pipeline(ModelYear,r_ak));
				!PipeFuelLossCDAnnual(ModelYear, r_cen) := sum((modelyrmn,l48) | map_State_CensusRegion(l48, r_cen), PipeFuelLoss(modelyrmn, l48));
				!TotalPipeFuelLossAnnual(ModelYear) := sum(r_cen, PipeFuelLossCDAnnual(ModelYear, r_cen));
				!Moved to Write_to_NEMS
				!!Fill the NEMS array
				!!Need to add Alaska pipe fuel??
				!!Not sure this is the best way - re-visit
				!QBLK_QGPTR(MNUMCR, NEMSmap_MNUMYR(ModelYear)) := sum(r_cen, PipeFuelLossCDAnnual(ModelYear, r_cen)*NEMSmap_MNUMCR_CensusReg(r_cen, MNUMCR)) * Convert_TBtu_Bcf(ModelYear);
				!
				!QBLK_QGPTR(TotalUS_MNUMCR, NEMSmap_MNUMYR(ModelYear)) := TotalPipeFuelLossAnnual(ModelYear)* Convert_TBtu_Bcf(ModelYear);
				!
			}
			DeclarationSection pipefuel_Declaration {
				Parameter TranFuelLosses {
					IndexDomain: (mon,reg);
				}
				Parameter PipeFuelLossCDAnnual {
					IndexDomain: (year,r_cen);
				}
				Parameter TotalPipeFuelLossAnnual {
					IndexDomain: (year);
				}
			}
		}
	}
	Section Production__and_WH_Price_Section {
		DeclarationSection Production_Declarations {
			Parameter TotalProduction {
				IndexDomain: (mon,reg);
				Text: "Total Production by month and region";
			}
			Parameter Supply {
				IndexDomain: (mon,suptype,s);
			}
			Parameter AnnualSupply {
				IndexDomain: (year,suptype,s);
				Text: "Annual Expected Production";
			}
			Parameter AverageSupplementalSupply {
				IndexDomain: (mn,sng,l48);
			}
			Parameter AverageSupplementalSupplyAnnual {
				IndexDomain: (sng,l48);
			}
			Parameter TotalProductionAnnual_forLeaseFuel {
				IndexDomain: (year,reg);
			}
			Parameter ActualProductionMonthly {
				IndexDomain: (mon,suptype,reg);
			}
			Parameter ActualProductionAnnual {
				IndexDomain: (year,suptype,s);
				Text: "Annual Actual Production";
			}
			Parameter LastDataYearFlg_SupProd {
				IndexDomain: year;
				Text: "flag to indicate that data exists for first model year";
				Range: binary;
			}
			Parameter LastDataYearFlg_LNGImp {
				IndexDomain: year;
				Text: "flag to indicate that data exists for first model year";
				Range: binary;
			}
		}
		DeclarationSection GOM_Related_Declarations {
			Parameter GOM_OGDIST2StateShare {
				IndexDomain: (gom_ogdist,fedGOMstate);
			}
			Parameter GOM_State2OGDISTShare {
				IndexDomain: (gom_ogdist,fedGOMstate);
			}
			Parameter HistGOM_OGDIST2StateShare {
				IndexDomain: (datayear,gom_ogdist,fedGOMstate);
			}
			Parameter HistGOM_State2OGDISTShare {
				IndexDomain: (datayear,gom_ogdist,fedGOMstate);
			}
			Parameter ImpliedStateGOMproduction {
				IndexDomain: (datayear,fedGOMstate);
			}
			Parameter ImpliedGOMproduction {
				IndexDomain: (year,gom_ogdist,fedGOMstate);
			}
			Parameter ImpliedGOMleasefuel {
				IndexDomain: (datayear,fedGOMstate);
			}
			Parameter HistGOMProdDifference {
				IndexDomain: datayear;
			}
		}
		DeclarationSection Wellhead_Price_Declarations {
			Parameter WellhdPrice {
				IndexDomain: (year,suptype,s);
			}
			Parameter WellhdPrice_Soln {
				IndexDomain: (year,suptype,s);
			}
			Parameter GatheringCharge {
				IndexDomain: s;
			}
			Parameter GatherCharge_Add {
				IndexDomain: s;
			}
			Parameter LastDataYearFlg_WHPrice {
				IndexDomain: year;
				Text: "flag to indicate that data exists for first model year";
				Range: binary;
			}
		}
		Procedure Production_InitializeData {
			Body: {
				LastHistoricalDataYear := Last(datayear | Exists(l48s | HistoricalAnnualWellhdPrice(datayear, l48s)));
				!if LastHistoricalDataYear>=FirstModelYear then LastDataYearFlg_WHPrice(hdatayear):=1; endif;
				LastDataYearFlg_WHPrice(hdatayear):=1;
				WellhdPrice(hdatayear, suptype, s) := HistoricalAnnualWellhdPrice(hdatayear, s);
				HenryHubPrice(hdatayear):= (WellhdPrice(hdatayear, Supply_NA, HenryHubRegion)+GatheringCharge(HenryHubRegion));
				
				Supply(datamon, suptype, s) := HistoricalSupply(datamon, suptype, s);
				!Determine last month for which EIA historical data exists and determine LastHistoricalDataYear by testing if LastHistoricalDataMonth is December
				!LastHistoricalDataMonth := Last(datamon | Exists((state)|Supply(datamon,Supply_LNG,state)));
				!if (MonthToYear(LastHistoricalDataMonth)=MonthToYear(LastHistoricalDataMonth-11)) then
				!	LastHistoricalDataYear := MonthToYear(LastHistoricalDataMonth);
				!else
				!	LastHistoricalDataYear := MonthToYear(LastHistoricalDataMonth)-1;
				!endif;
				!if LastHistoricalDataYear>=FirstModelYear then LastDataYearFlg_LNGImp(hdatayear):=1; endif;
				!LastDataYearFlg_LNGImp(hdatayear):=1;
				! Do supply here to transfer  LNG supply type
				!Supply( (mon, Supply_LNG, state) | mon >LastHistoricalMonth ) := Supply(mon-12, Supply_LNG, state);
				!Supply( (mon, Supply_LNG, state) | mon >last(ActualDataMonths_) ) := Supply(mon-12, Supply_LNG, state);
				!AnnualSupply(year, Supply_LNG, s) := sum( mon | map_month_year(mon, year), Supply(mon, Supply_LNG, s) );
				!Map OGSM expected production to Supply for US supply regions for  NA and AD gas
				Calculate_LNG_Import_Supply;
				
				
				
				!Do historical years
				AnnualSupply(datayear, Supply_AD, ussup)  := sum(OGDIST | NEMSmap_OGDIST_SupplyNode(OGDIST, ussup), OGSMOUT_OGADGPRD(OGDIST, 5, NEMSmap_MNUMYR(datayear)));
				!Add OGSMOUT_OGSHALENG to AD gas Shale gas region (Wyoming)
				AnnualSupply(datayear, Supply_AD, ShaleGasRegion)  += OGSMOUT_OGSHALENG(NEMSmap_MNUMYR(datayear));
				!Missing historical data for NA gas in OGSMOUT_OGENAGPRD
				AnnualSupply (datayear, Supply_NA, ussup)  := sum(OGDIST | NEMSmap_OGDIST_SupplyNode(OGDIST, ussup), OGSMOUT_OGENAGPRD(OGDIST, 5, NEMSmap_MNUMYR(datayear)));
				!Calculate state shares for GOM production
				Calculate_GOMProductionShares;
				!Allocate actual historical produstion to GOM states
				AnnualSupply (datayear, naadgas, fedGOMstate)  := sum(gom_ogdist | map_GOMregions(gom_ogdist, fedGOMstate), HistGOM_OGDIST2StateShare(datayear, gom_ogdist, fedGOMstate) *
				                                                AnnualSupply (datayear, naadgas, gom_ogdist));
				
				!Calculcate total NA and AD gas production by state
				TotalProductionAnnual_forLeaseFuel(datayear, l48) :=  sum((naadgas, usnoGOM) | map_SupplyArcs(usnoGOM, l48) , AnnualSupply(datayear, naadgas, usnoGOM));
				!Sum up Federal Gulf of Mexico NA and AD gas production
				TotalProductionAnnual_forLeaseFuel(datayear, GOMRegion) :=  sum((naadgas, gom_ogdist) , AnnualSupply(datayear, naadgas, gom_ogdist));
				
				
				Calculate_LeaseFuelFactor; !Calculate lease fuel factor
				
				!Transfer SUPPLEMENTAL SUPPLY
				AnnualSupply(datayear, sng, l48) := HistoricalAnnualSupply(datayear, sng, l48);
				
				! Divide TX sng accross three sub-regions and zero out TX
				AnnualSupply(datayear, sng, r_tx) := HistoricalAnnualSupply(datayear, sng, TexasState)/card(r_tx);
				AnnualSupply(datayear, sng, TexasState) := 0;
				
				!Add Hawaii supplemental supply to California
				AnnualSupply(datayear, sng, CaliforniaState) += HistoricalAnnualSupply(datayear, sng, HawaiiState);
				
				!Convert Annual Qty to Monthly using number of days in each month for domestic supply types
				Supply(datamon, domsuptype, ussup)  := AnnualSupply(MonthToYear(datamon), domsuptype, ussup) * NumberOfDaysInMonth(datamon)/ NumberOfDaysInYear(MonthToYear(datamon));
				
				Calculate_SupplementalSupply; !Set up average supplemental supply
				
				ActualProductionMonthly(histmon, naadgas, qps) := Supply(histmon, naadgas, qps)* (1 - LeaseFuelFactor(qps)); !net of lease fuel
				ActualProductionAnnual(histyr, naadgas, qps) := AnnualSupply(histyr, naadgas, qps)* (1 - LeaseFuelFactor(qps)); !net of lease fuel
				ActualProductionMonthly((histmon, suptype, qps)| not suptype in NA_AD_) := Supply(histmon, suptype, qps);
				ActualProductionAnnual((histyr, suptype, qps)| not suptype in NA_AD_) := AnnualSupply(histyr, suptype, qps);
				
				TotalProduction(histmon, h) := sum((suptype, qps) | map_SupplyArcs(qps, h), ActualProductionMonthly(histmon, suptype, qps));
				MonthlyProductionForReport(histmon, suptype, h) := sum( qps | map_SupplyArcs(qps, h), ActualProductionMonthly(histmon, suptype, qps));
			}
			Comment: {
				"Initialize production data; copy historical values for NA and AD gas from OGSM variables
				calculate supplemental supply for forecast years
				calculate lease fuel factor"
			}
		}
		Procedure Production_Run {
			Body: {
				!Map OGSM expected production to Supply for US supply regions for NA and AD gas in ModelYear
				!Map OGSM expected production to Supply for US supply regions for NA and AD gas in ModelYear
				AnnualSupply (ModelYear, Supply_AD, ussup)  := sum((OGDIST,OILTYP) | NEMSmap_OGDIST_SupplyNode(OGDIST, ussup) and OILTYP <=4, OGSMOUT_OGADGPRD(OGDIST, OILTYP, NEMSmap_MNUMYR(ModelYear)));
				AnnualSupply (ModelYear, Supply_NA, ussup)  := sum((OGDIST,GASTYP) | NEMSmap_OGDIST_SupplyNode(OGDIST, ussup) and GASTYP <=4, OGSMOUT_OGENAGPRD(OGDIST, GASTYP, NEMSmap_MNUMYR(ModelYear)));
				!Add OGSMOUT_OGSHALENG to AD gas shale gas region (Wyoming): change the region in the ngsetdat.txt input file if needed
				AnnualSupply(ModelYear, Supply_AD, ShaleGasRegion)  += OGSMOUT_OGSHALENG(NEMSmap_MNUMYR(ModelYear));
				
				!Split GOM production
				AnnualSupply (ModelYear, naadgas, fedGOMstate) := sum(gom_ogdist | map_GOMregions(gom_ogdist, fedGOMstate), GOM_OGDIST2StateShare(gom_ogdist, fedGOMstate) *
										 AnnualSupply (ModelYear, naadgas, gom_ogdist));
				!Calculate shares to aggregate state levels back to ogdist   
				ImpliedGOMproduction(ModelYear, gom_ogdist, fedGOMstate):=  GOM_OGDIST2StateShare(gom_ogdist, fedGOMstate) * AnnualSupply (ModelYear, Supply_NA, gom_ogdist);                                  
				GOM_State2OGDISTShare((gom_ogdist, fedGOMstate) | map_GOMregions(gom_ogdist, fedGOMstate)):= ImpliedGOMproduction(ModelYear, gom_ogdist, fedGOMstate)/$
						 AnnualSupply(ModelYear, Supply_NA, fedGOMstate);
				!Normalize the shares
				GOM_State2OGDISTShare((gom_ogdist, fedGOMstate) | map_GOMregions(gom_ogdist, fedGOMstate))/=sum(gom_ogdist1  | map_GOMregions(gom_ogdist1, fedGOMstate),
					GOM_State2OGDISTShare(gom_ogdist1, fedGOMstate));
				!Set supplemental supply
				if (not LastDataYearFlg_SupProd(ModelYear)) then
					AnnualSupply(ModelYear, sng, l48) := AverageSupplementalSupplyAnnual(sng, l48);
				endif;
				
				!Convert Annual Qty to Monthly using number of days in each month
				Supply(modelyrmn, naadgas, ussup)  := AnnualSupply(MonthToYear(modelyrmn), naadgas, ussup) * NumberOfDaysInMonth(modelyrmn)/ NumberOfDaysInYear(MonthToYear(modelyrmn));
				!Supply(modelyrmn, domsuptype, ussup)  := AnnualSupply(MonthToYear(modelyrmn), domsuptype, ussup) * NumberOfDaysInMonth(modelyrmn)/ NumberOfDaysInYear(MonthToYear(modelyrmn));
				
				
				!Set supplemental supply -filled in pre-processing Production_InitializeData
				!Supply(modelyrmn, sng, l48)  := sum(mn | map_Month_MonthinYear(modelyrmn,mn), AverageSupplementalSupply(mn,sng,l48)) ;
				Supply(modelyrmn, sng, l48)  := AnnualSupply(ModelYear, sng, l48) * NumberOfDaysInMonth(modelyrmn)/ NumberOfDaysInYear(MonthToYear(modelyrmn));
				
				!Set LNG Imports = previous year's values
				!if ModelYear=FirstModelYear then
				!	Supply(modelyrmn, Supply_LNG, s) := HistoricalSupply(modelyrmn, Supply_LNG, s);
				!else
				!	Supply( (lagyrmn, Supply_LNG, state) | lagyrmn >=YearToMonth(ModelYear) ) := Supply(lagyrmn-12, Supply_LNG, state);
				!endif;
				!AnnualSupply(ModelYear, Supply_LNG, s) := sum( modelyrmn, Supply(modelyrmn, Supply_LNG, s) );
			}
			Comment: {
				"Map OGSM expected production to Supply for US supply regions; split GOM production
				Assign supplemental supply"
			}
		}
		Procedure SetWellheadPrices {
			Body: {
				QP_SupplyPriceSolution((MonthInPeriod(tmon),suptype, qps) | map_Supply(qps, suptype)):= QP_SupplyPrice(tmon,suptype,qps);
				
				QP_SupplyPriceSolution((MonthInPeriod(tmon),suptype, qps) | SupplyAccounting.ShadowPrice(tmon,suptype,qps)> 0.7) := SupplyAccounting.ShadowPrice(tmon,suptype,qps);
				!QP_SupplyPriceSolution((MonthInPeriod(tmon),suptype, qps) | map_Supply(qps, suptype)) := SupplyAccounting.ShadowPrice(tmon,suptype,qps);
				!write SupplyAccounting.ShadowPrice((tmon,suptype,qps) | SupplyAccounting.ShadowPrice(tmon,suptype,qps)< 0.9) to file "NGATTENTION.txt" in merge mode;
				!Do weighted average to calculate annual price
				
				WellhdPrice_Soln((ModelYear, suptype, qps) | map_Supply(qps, suptype) and ActualProductionAnnual(ModelYear, suptype, qps)):=  $ sum(modelyrmn, QP_SupplyPriceSolution(modelyrmn,suptype, qps)*
				           ActualProductionMonthly(modelyrmn, suptype, qps))/ $ ActualProductionAnnual(ModelYear, suptype, qps);
				WellhdPrice_Soln((ModelYear, suptype, qps) | not WellhdPrice_Soln(ModelYear, suptype, qps)) := WellhdPrice(ModelYear-1, suptype, qps);           
				!WellhdPrice((ModelYear, naadgas, qps) | map_Supply(qps, naadgas)):= WHPrcCalc_annual(ModelYear, qps);
				
				HenryHubPrice(ModelYear):= (WellhdPrice_Soln(ModelYear, Supply_NA, HenryHubRegion)+GatheringCharge(HenryHubRegion));
				!Assign wellhead prices by OGDIST GOM regions
				WellhdPrice_Soln(ModelYear, suptype, gom_ogdist) := WellhdPrice_Soln(ModelYear, suptype, GOMpriceRegion(gom_ogdist));
				
				!Set wellhead price for next year's PNODE
				!if (ModelYear=FirstModelYear and WellhdPrice(ModelYear, Supply_NA, qps)) then  
				   !	WellhdPrice(ModelYear, suptype, qps) := 
				  ! else 
				       WellhdPrice((ModelYear, suptype, qps) | not LastDataYearFlg_WHPrice(ModelYear)) := WellhdPrice_Soln(ModelYear, suptype, qps);
				 !  endif;
			}
		}
		Procedure Calculate_GOMProductionShares {
			Body: {
				!Determine last year for which historical data exists
				LastHistoricalDataYear := Last(datayear | Exists((fedGOMstate)|HistoricalFlowAnnual(GOMRegion, fedGOMstate, datayear)));
				TotalGOMflow(hdatayear):=sum(fedGOMstate, HistoricalFlowAnnual(GOMRegion, fedGOMstate, hdatayear));
				!Allocate lease fuel using the historical flow shares
				ImpliedGOMleasefuel(hdatayear, fedGOMstate):=HistoricalAnnualLeaseFuel(hdatayear, GOMRegion) * HistoricalFlowAnnual(GOMRegion, fedGOMstate, hdatayear) /$ TotalGOMflow(hdatayear);
				!Calculate implied production by state= flow+lease fuel
				ImpliedStateGOMproduction(hdatayear, fedGOMstate):=HistoricalFlowAnnual(GOMRegion, fedGOMstate, hdatayear)+ImpliedGOMleasefuel(hdatayear, fedGOMstate);
				HistGOMProdDifference(hdatayear):=sum((naadgas,gom_ogdist), AnnualSupply(hdatayear, naadgas, gom_ogdist))- sum(fedGOMstate,ImpliedStateGOMproduction(hdatayear, fedGOMstate));
				!Set Texas production share from the West and Central
				ImpliedGOMproduction((hdatayear, WesternGOM, TexasGOM) | sum(naadgas, AnnualSupply(hdatayear, naadgas, WesternGOM)) >= ImpliedStateGOMproduction(hdatayear, TexasGOM)):=
					ImpliedStateGOMproduction(hdatayear, TexasGOM);
				ImpliedGOMproduction((hdatayear, WesternGOM, TexasGOM) | sum(naadgas, AnnualSupply(hdatayear, naadgas, WesternGOM)) <= ImpliedStateGOMproduction(hdatayear, TexasGOM)):=
					sum(naadgas, AnnualSupply(hdatayear, naadgas, WesternGOM));
				ImpliedGOMproduction(hdatayear, CentralGOM, TexasGOM) := ImpliedStateGOMproduction(hdatayear, TexasGOM)-ImpliedGOMproduction(hdatayear, WesternGOM, TexasGOM);
				!Set LA production from the West and  from the Central
				ImpliedGOMproduction(hdatayear, WesternGOM, LouisianaGOM) := sum(naadgas, AnnualSupply(hdatayear, naadgas, WesternGOM)) - ImpliedGOMproduction(hdatayear, WesternGOM, TexasGOM);
				ImpliedGOMproduction(hdatayear, CentralGOM, LouisianaGOM) := ImpliedStateGOMproduction(hdatayear, LouisianaGOM)-ImpliedGOMproduction(hdatayear, WesternGOM, LouisianaGOM);
				!Set AL production from the East and from the Central
				ImpliedGOMproduction(hdatayear, EasternGOM, AlabamaGOM) := sum(naadgas, AnnualSupply(hdatayear, naadgas, EasternGOM));
				ImpliedGOMproduction(hdatayear, CentralGOM, AlabamaGOM) := ImpliedStateGOMproduction(hdatayear, AlabamaGOM)-ImpliedGOMproduction(hdatayear, EasternGOM, AlabamaGOM);
				!Set MS production from the Central
				ImpliedGOMproduction(hdatayear, CentralGOM, MississippiGOM) := ImpliedStateGOMproduction(hdatayear, MississippiGOM);
				!Calculate implied shares
				HistGOM_OGDIST2StateShare((hdatayear, gom_ogdist, fedGOMstate) | map_GOMregions(gom_ogdist, fedGOMstate)):= ImpliedGOMproduction(hdatayear, gom_ogdist, fedGOMstate)/$
						sum(naadgas, AnnualSupply(hdatayear, naadgas, gom_ogdist));
				!Set implied share of AL from the East =1
				HistGOM_OGDIST2StateShare(hdatayear, EasternGOM, AlabamaGOM):= 1;
				!Normalize the shares
				HistGOM_OGDIST2StateShare((hdatayear, gom_ogdist, fedGOMstate) | map_GOMregions(gom_ogdist, fedGOMstate))/=sum(fedGOMstate1  | map_GOMregions(gom_ogdist, fedGOMstate1),
					HistGOM_OGDIST2StateShare(hdatayear, gom_ogdist, fedGOMstate1));
				!Average shares for forecast
				GOM_OGDIST2StateShare(gom_ogdist, fedGOMstate):=sum(navgyr_gomprod,HistGOM_OGDIST2StateShare(LastHistoricalDataYear+1-Val(navgyr_gomprod), gom_ogdist, fedGOMstate))/
						Card(NumberOfYearsForAverage_GOMprod_);
			}
			Parameter TotalGOMflow {
				IndexDomain: (datayear);
			}
		}
		Procedure Calculate_SupplementalSupply {
			Body: {
				!Calculate Average Supplemental Supply for last NumberOfYearsForAverage_SNG_ (5) historical years
				!Determine last year for which historical data exists
				LastHistoricalDataYear := Last(datayear | Exists((sng,l48)|AnnualSupply(datayear, sng, l48)));
				!if LastHistoricalDataYear>=FirstModelYear then LastDataYearFlg_SupProd(hdatayear):=1; endif;
				LastDataYearFlg_SupProd(hdatayear):=1;
				
				AverageSupplementalSupplyAnnual(sng, l48):=sum(navgyr_sng, AnnualSupply(LastHistoricalDataYear+1-Val(navgyr_sng), sng, l48))/ Card(NumberOfYearsForAverage_SNG_);
				!AnnualSupply( (year, sng, l48) | year >LastHistoricalDataYear ) := AverageSupplementalSupplyAnnual(sng, l48);
				!Supply((mon, sng, l48) | mon >last(ActualDataMonths_) ) := AverageSupplementalSupplyAnnual(sng, l48) * NumberOfDaysInMonth(mon)/ NumberOfDaysInYear(MonthToYear(mon));
			}
			Comment: "Set up average Supplemental Supply levels using historical data";
		}
		Procedure Production_Postprocess {
			Body: {
				ActualProductionMonthly((MonthInPeriod(tmon), suptype, qps)|map_Supply(qps, suptype)) := QProduction(tmon,suptype,qps); !sum(step, QSupplyStep(tmon,suptype,s,step)); !net of lease fuel
				ActualProductionAnnual(ModelYear, suptype, qps) := sum(modelyrmn, ActualProductionMonthly(modelyrmn, suptype, qps));
				!Aggregate GOM production by OGDIST regions
				ActualProductionAnnual(ModelYear, Supply_NA, gom_ogdist) := sum(fedGOMstate | map_GOMregions(gom_ogdist, fedGOMstate), GOM_State2OGDISTShare(gom_ogdist, fedGOMstate) *
											ActualProductionAnnual(ModelYear, Supply_NA, fedGOMstate));
				ActualProductionAnnual(ModelYear, Supply_AD, gom_ogdist) := AnnualSupply (ModelYear, Supply_AD, gom_ogdist);							
				TotalProduction(modelyrmn, d) := sum((suptype, qps) | map_SupplyArcs(qps, d), ActualProductionMonthly(modelyrmn, suptype, qps));
				
				SetWellheadPrices; !Set wellhead prices for next year
			}
		}
	}
	Section STEO_Benchmarking {
		DeclarationSection STEO_BM_Time_Declarations {
			Set STEOYears_ {
				SubsetOf: Years_;
				Index: steoyr;
				Definition: {
					{FirstSTEOYear..LastSTEOYear}
				}
			}
			Set STEOPhaseOutYears_ {
				SubsetOf: Years_;
				Index: steophaseoutyr;
				Definition: {
					{FirstSTEOPhaseOutYear..LastSTEOPhaseOutYear}
				}
			}
			Set TotalSteoYears_ {
				SubsetOf: Years_;
				Index: totsteoyr;
				Definition: STEOYears_+STEOPhaseOutYears_;
			}
			ElementParameter FirstSTEOYear {
				Range: Years_;
				Definition: LastHistoricalYear + 1;
			}
			ElementParameter LastSTEOYear {
				Range: Years_;
				Definition: FirstSTEOYear+NumberOfSTEOYears-1;
			}
			ElementParameter FirstSTEOPhaseOutYear {
				Range: Years_;
				Definition: LastSTEOYear + 1;
			}
			ElementParameter LastSTEOPhaseOutYear {
				Range: Years_;
				Definition: FirstSTEOPhaseOutYear+NumberOfSTEOPhaseOutYears-1;
			}
			Parameter NumberOfSTEOYears {
				Range: integer;
			}
			Parameter NumberOfSTEOPhaseOutYears {
				Range: integer;
			}
			Set STEOYearMonths_ {
				SubsetOf: Months_;
				Index: steoyrmn;
				Definition: {
					{ YearToMonth(FirstSTEOYear) .. YearToMonth(LastSTEOYear)+11 }
				}
			}
			Set STEOPhaseOutYearMonths_ {
				SubsetOf: Months_;
				Index: steophaseoutyrmn;
				Definition: {
					{ YearToMonth(FirstSTEOPhaseOutYear) .. YearToMonth(LastSTEOPhaseOutYear)+11 }
				}
			}
		}
		DeclarationSection STEO_BM_Declarations {
			Parameter NGCCU_ENC {
				IndexDomain: year;
				Text: "ng price comm, east north central, $/Mcf";
			}
			Parameter NGCCU_ESC {
				IndexDomain: year;
				Text: "ng price comm, east south central, $/Mcf";
			}
			Parameter NGCCU_MAC {
				IndexDomain: year;
				Text: "ng price comm, middle atlantic, $/Mcf";
			}
			Parameter NGCCU_MTN {
				IndexDomain: year;
				Text: "ng price comm, mountain, $/Mcf";
			}
			Parameter NGCCU_NEC {
				IndexDomain: year;
				Text: "ng price comm, new england, $/Mcf";
			}
			Parameter NGCCU_PAC {
				IndexDomain: year;
				Text: "ng price comm, pacific, $/Mcf";
			}
			Parameter NGCCU_SAC {
				IndexDomain: year;
				Text: "ng price comm, south atlantic, $/Mcf";
			}
			Parameter NGCCU_WNC {
				IndexDomain: year;
				Text: "ng price comm, west north central, $/Mcf";
			}
			Parameter NGCCU_WSC {
				IndexDomain: year;
				Text: "ng price comm, west south central, $/Mcf";
			}
			Parameter NGCCUUS {
				IndexDomain: year;
				Text: "ng price comm, $/Mcf";
			}
			Parameter NGICU_ENC {
				IndexDomain: year;
				Text: "ng price ind, east north central, $/Mcf";
			}
			Parameter NGICU_ESC {
				IndexDomain: year;
				Text: "ng price ind, east south central, $/Mcf";
			}
			Parameter NGICU_MAC {
				IndexDomain: year;
				Text: "ng price ind, middle atlantic, $/Mcf";
			}
			Parameter NGICU_MTN {
				IndexDomain: year;
				Text: "ng price ind, mountain, $/Mcf";
			}
			Parameter NGICU_NEC {
				IndexDomain: year;
				Text: "ng price ind, new england, $/Mcf";
			}
			Parameter NGICU_PAC {
				IndexDomain: year;
				Text: "ng price ind, pacific, $/Mcf";
			}
			Parameter NGICU_SAC {
				IndexDomain: year;
				Text: "ng price ind, south atlantic, $/Mcf";
			}
			Parameter NGICU_WNC {
				IndexDomain: year;
				Text: "ng price ind, west north central, $/Mcf";
			}
			Parameter NGICU_WSC {
				IndexDomain: year;
				Text: "ng price ind, west south central, $/Mcf";
			}
			Parameter NGICUUS {
				IndexDomain: year;
				Text: "ng price ind, $/Mcf";
			}
			Parameter NGRCU_ENC {
				IndexDomain: year;
				Text: "ng price res, east north central, $/Mcf";
			}
			Parameter NGRCU_ESC {
				IndexDomain: year;
				Text: "ng price res, east south central, $/Mcf";
			}
			Parameter NGRCU_MAC {
				IndexDomain: year;
				Text: "ng price res, middle atlantic, $/Mcf";
			}
			Parameter NGRCU_MTN {
				IndexDomain: year;
				Text: "ng price res, mountain, $/Mcf";
			}
			Parameter NGRCU_NEC {
				IndexDomain: year;
				Text: "ng price res, new england, $/Mcf";
			}
			Parameter NGRCU_PAC {
				IndexDomain: year;
				Text: "ng price res, pacific, $/Mcf";
			}
			Parameter NGRCU_SAC {
				IndexDomain: year;
				Text: "ng price res, south atlantic, $/Mcf";
			}
			Parameter NGRCU_WNC {
				IndexDomain: year;
				Text: "ng price res, west north central, $/Mcf";
			}
			Parameter NGRCU_WSC {
				IndexDomain: year;
				Text: "ng price res, west south central, $/Mcf";
			}
			Parameter NGRCUUS {
				IndexDomain: year;
				Text: "ng price res, $/Mcf";
			}
			Parameter NGEUDUS {
				IndexDomain: year;
				Text: "cost of ng to elec gen, $/MMbtu";
			}
			Parameter NGHHUUS {
				IndexDomain: year;
				Text: "henry hub spot price, $/MMbtu";
			}
			Parameter NGSFPUS {
				IndexDomain: year;
				Text: "supplemental fuels supply, Bcf/d";
			}
			Parameter NGLPPUS {
				IndexDomain: year;
				Text: "ng lease and plant fuel, Bcf/d";
			}
			Parameter NGACPUS {
				IndexDomain: year;
				Text: "ng pipeline & distribution, Bcf/d";
			}
			Parameter NGTCPUS {
				IndexDomain: year;
				Text: "ng consumption, Bcf/d";
			}
			Parameter BALIT {
				IndexDomain: year;
				Text: "ng balancing (cons-supply), Bcf/d";
			}
			Parameter NGNWPUS {
				IndexDomain: year;
				Text: "ng net withdrawals fr storage, Bcf/d";
			}
			Parameter NGEXPUS_LNG {
				IndexDomain: year;
				Text: "ng exports, liquefied, Bcf/d";
			}
			Parameter NGEXPUS_PIPE {
				IndexDomain: year;
				Text: "ng exports by pipeline, Bcf/d";
			}
			Parameter NGEXPUS {
				IndexDomain: year;
				Text: "ng exports, Bcf/d";
			}
			Parameter NGIMPUS {
				IndexDomain: year;
				Text: "ng imports, Bcf/d";
			}
			Parameter NGIMPUS_LNG {
				IndexDomain: year;
				Text: "ng imports, liquefied, Bcf/d";
			}
			Parameter NGIMPUS_PIPE {
				IndexDomain: year;
				Text: "ng imports, pipeline, Bcf/d";
			}
		}
		DeclarationSection STEO_BM_Options_Declaration {
			Parameter STEOScaleNG {
				Range: binary;
			}
			Parameter STEONGIND {
				Text: "steo benchmarking switch for overwriting industrial price 1=on, 0=off";
				Range: binary;
				Comment: "steo benchmarking switch for overwriting industrial price 1=on, 0=off";
			}
			Parameter STEOBM {
				Text: "global steo benchmarking switch 1=on, 2=off";
				Range: integer;
				Comment: "global steo benchmarking switch 1=on, 2=off";
			}
			Parameter STEONG {
				Text: "local steo benchmarking switch 1=on, 2=off";
				Range: integer;
			}
			Parameter STSCALNG {
				Text: "set to 1 if reading steo factors, set to 0 otherwise";
				Range: binary;
			}
			Parameter OGTECH {
				Range: integer;
			}
			Parameter OGTECADJ {
				Range: integer;
			}
			Parameter SteoConvergenceFlag {
				Range: binary;
			}
			Parameter steotestflg {
				Range: binary;
			}
		}
		DeclarationSection STEO_Scaling_Factors {
			Parameter STEOFactor0 {
				Range: binary;
				Definition: 1;
			}
			Parameter STEOStorageWithdrawalFactor {
				IndexDomain: year;
			}
			Parameter STEOStorageInjectionFactor {
				IndexDomain: year;
			}
			Parameter STEOBalancingItemFactor {
				IndexDomain: year;
			}
			Parameter STEOSupplementalSupplyFactor {
				IndexDomain: year;
			}
			Parameter STEOLNGExportsFactor {
				IndexDomain: year;
			}
			Parameter STEOLNGImportsFactor {
				IndexDomain: year;
			}
			Parameter STEOLeaseFuelFactor {
				IndexDomain: year;
			}
			Parameter STEOPipeFuelFactor {
				IndexDomain: year;
			}
			Parameter STEOWellhdPriceFactor {
				IndexDomain: year;
			}
			Parameter STEOEndUsePriceFactor {
				IndexDomain: (year,sec,r_cen);
			}
			Parameter STEOElectricPriceFactor {
				IndexDomain: year;
			}
			Parameter STEOPipelineExportFactor {
				IndexDomain: (mon,steocnmx);
			}
			Parameter STEOPipelineImportFactor {
				IndexDomain: year;
			}
			Parameter STEOCNExportFactor {
				IndexDomain: year;
			}
			Parameter STEOImpExpAnnualFactor {
				IndexDomain: (year,steocnmx);
			}
			Parameter STEOMXExpAnnualFactor {
				IndexDomain: (year);
			}
			Parameter STEOMXExportFactor {
				IndexDomain: year;
				Definition: {
					!data { 2015 : 109.764,  2016 : 626.942,  2017 : 531.856 }
				}
			}
		}
		DeclarationSection STEO_Iteration_Declarations {
			Parameter STEOSolnWellhdPrice {
				IndexDomain: (steoyr,suptype,qps,isteo);
			}
			Parameter STEOWHPrcCalc_annual {
				IndexDomain: (steoyr,qps,isteo);
			}
			Parameter STEOTempLeaseFuelFactor {
				IndexDomain: (year,isteo);
			}
			Parameter STEOTempPipeFuelFactor {
				IndexDomain: (year,isteo);
			}
			Parameter STEOTempWellhdPriceFactor {
				IndexDomain: (year,isteo);
			}
			Parameter STEOTempPipelineImportFactor {
				IndexDomain: (year,isteo);
			}
			Parameter STEOTempPipelineExportFactor {
				IndexDomain: (year,isteo);
			}
			Parameter TempFactorBracket {
				IndexDomain: (year,isteo);
			}
			Parameter TempBracketPoint1 {
				IndexDomain: (year,isteo);
			}
			Parameter TempBracketPoint2 {
				IndexDomain: (year,isteo);
			}
			Parameter TempLease {
				IndexDomain: (year,isteo);
			}
			Parameter TempPipe {
				IndexDomain: (year,isteo);
			}
			Parameter TempHHPrice {
				IndexDomain: (year,isteo);
			}
			Parameter TempProductionCNW {
				IndexDomain: (year,isteo);
			}
			Parameter TempQNodeCNW {
				IndexDomain: (year,isteo);
			}
			Parameter TempWHPriceCNW {
				IndexDomain: (year,isteo);
			}
			Parameter TempCNW_CNE_Flow {
				IndexDomain: (year,isteo);
			}
			Parameter TempCNImports {
				IndexDomain: (year,isteo);
			}
			Parameter TempCNNetImports {
				IndexDomain: (year,isteo);
			}
			Parameter TempCNWimports {
				IndexDomain: (year,isteo);
			}
			Parameter TempCNEimports {
				IndexDomain: (year,isteo);
			}
			Parameter TempCNExports {
				IndexDomain: (year,isteo);
			}
			Parameter TempMXExports {
				IndexDomain: (year,isteo);
			}
			Parameter TempMXCons {
				IndexDomain: (year,isteo);
			}
		}
		DeclarationSection Other_STEO_Declarations {
			Parameter STEOPipelineImportPhaseOutFlag {
				Range: binary;
			}
			Parameter STEOMXExportsPhaseOutFlag {
				Range: binary;
			}
			Parameter STEOCANExportsPhaseOutFlag {
				Range: binary;
			}
			Set STEOIterations_ {
				Index: isteo;
				Definition: {
					{1..100}
				}
			}
			ElementParameter SteoIter {
				Range: STEOIterations_;
			}
			ElementParameter MaxSteoIter {
				Range: STEOIterations_;
			}
			Parameter STEOTargetNetWithdrawals {
				IndexDomain: year;
			}
			Parameter STEOTargetBalancingItem {
				IndexDomain: year;
			}
			Parameter STEOTargetSupplementalSupply {
				IndexDomain: year;
			}
			Parameter STEOTargetLNGExports {
				IndexDomain: year;
			}
			Parameter STEOTargetLNGImports {
				IndexDomain: year;
			}
			Parameter STEOTargetLeaseFuel {
				IndexDomain: year;
			}
			Parameter STEOTargetPipeFuel {
				IndexDomain: year;
			}
			Parameter STEOTargetHenryHubPrice {
				IndexDomain: year;
			}
			Parameter STEOTargetEndUsePrice {
				IndexDomain: (year,sec,r_cen);
			}
			Parameter STEOTargetElectricPrice {
				IndexDomain: year;
			}
			Parameter STEOTargetPipelineExports {
				IndexDomain: (year,steocnmx);
			}
			Parameter STEOTargetCNExports {
				IndexDomain: year;
			}
			Parameter STEOTargetCNImports {
				IndexDomain: year;
			}
			Parameter STEOTargetCNNetImports {
				IndexDomain: year;
			}
			Parameter STEOTargetMXNetImports {
				IndexDomain: year;
			}
			Parameter STEOTargetMXExports {
				IndexDomain: year;
			}
			Parameter ProductionCNW {
				IndexDomain: year;
			}
			Parameter ConsumptionMX_NE {
				IndexDomain: mon;
			}
			Parameter STEOTargetMXImports {
				IndexDomain: year;
			}
			Parameter STEOTargetFlowOutCNW {
				IndexDomain: year;
			}
			Parameter STEOTargetCNWProduction {
				IndexDomain: year;
			}
			Parameter STEOCNExportPercent {
				IndexDomain: year;
			}
			Parameter STEOCNImportPercent {
				IndexDomain: year;
			}
			Parameter Exports_CanadaNew {
				IndexDomain: year;
			}
			Parameter Imports_CanadaNew {
				IndexDomain: year;
			}
			Parameter DIFF1 {
				IndexDomain: year;
			}
			Parameter Temp1 {
				IndexDomain: year;
			}
			Parameter Temp2 {
				IndexDomain: year;
			}
			Parameter temp3 {
				IndexDomain: year;
			}
			Parameter temp4 {
				IndexDomain: year;
			}
			Parameter delta_Lease;
			Parameter delta_Pipe;
			Parameter delta_HH;
			Parameter delta_Imports;
			Parameter delta_MxExports;
			Parameter tempimpexp {
				IndexDomain: (mn,steocnmx);
			}
		}
		Procedure STEOFactors_Initialize {
			Body: {
				empty STEOBM_Identifiers_;
				!Initialize STEO Factors
				!STORAGE
				STEOStorageWithdrawalFactor(year) := STEOFactor0;
				STEOStorageInjectionFactor(year) := STEOFactor0;
				!BALANCING ITEM
				STEOBalancingItemFactor(year) := STEOFactor0;
				!SUPPLEMENTAl SUPPLY
				STEOSupplementalSupplyFactor(year) := STEOFactor0;
				!LNG EXPORTS
				!STEOLNGExportsFactor(year) := STEOFactor0;
				STEOLNGExportsFactor(year) := 0;
				!LNG IMPORTS
				STEOLNGImportsFactor(year) := STEOFactor0;
				!LEASE AND PLANT FUEL
				STEOLeaseFuelFactor(year) := STEOFactor0;
				SteoIter:='1';
				STEOTempLeaseFuelFactor(year,SteoIter) := STEOFactor0;
				!PIPELINE FUEL
				STEOPipeFuelFactor(year) := STEOFactor0;
				STEOTempPipeFuelFactor(year,SteoIter) := STEOFactor0;
				!WELLHEAD PRICES
				STEOWellhdPriceFactor(year):=STEOFactor0;
				STEOTempWellhdPriceFactor(year,SteoIter) := STEOFactor0;
				!ENDUSE PRICES
				STEOEndUsePriceFactor(year, sec, r_cen) := STEOFactor0;
				STEOElectricPriceFactor(year) := STEOFactor0;
				!PIPELINE IMPORTS/EXPORTS
				STEOPipelineExportFactor(mon, steocnmx) := 0;
				STEOPipelineImportFactor(year)  := STEOFactor0;
				STEOCNExportFactor(year) := STEOFactor0;
				STEOMXExpAnnualFactor(year) := 0;
				STEOMXExportFactor(year) := 0;
				STEOTempPipelineExportFactor(year, SteoIter):=0;
				!**************************************************************
				SteoConvergenceFlag := 0;
			}
			Comment: "Initialize STEO factors to 1";
		}
		Procedure STEOTargets_Set {
			Body: {
				!STORAGE
				!Assign target net withdrawals
				!STEOTargetNetWithdrawals(steoyr) := NGNWPUS(steoyr)*NumberOfDaysInYear(steoyr);
				STEOTargetNetWithdrawals(steoyr) := NGNWPUS(steoyr)*1000;
				
				!************************************************************************************************
				!BALANCING ITEM
				
				!Note: Balancing item STEO scaling factors are calculated in STEOFactors_Run each steo model year since NEMS consumption is updated/transfered every model year
				!***************************************************************************************************
				!SUPPLEMENTAl SUPPLY
				
				!STEOTargetSupplementalSupply(steoyr) := NGSFPUS(steoyr)*NumberOfDaysInYear(steoyr);
				STEOTargetSupplementalSupply(steoyr) := NGSFPUS(steoyr)*1000;
				
				!**************************************************************************************************
				!LNG EXPORTS
				
				!Note: moved to STEOFactors_Run since started evaluating LNG exports every year
				
				!**************************************************************************************************
				!Fill in non-model steo years
				STEOTargetEndUsePrice(FirstSTEOYear-1, Sector_Commercial, CD_NewEngland) := NGCCU_NEC(FirstSTEOYear-1);
				STEOTargetEndUsePrice(FirstSTEOYear-1, Sector_Commercial, CD_ENCentral) := NGCCU_ENC(FirstSTEOYear-1);
				STEOTargetEndUsePrice(FirstSTEOYear-1, Sector_Commercial, CD_WNCentral) := NGCCU_WNC(FirstSTEOYear-1);
				STEOTargetEndUsePrice(FirstSTEOYear-1, Sector_Commercial, CD_ESCentral) := NGCCU_ESC(FirstSTEOYear-1);
				STEOTargetEndUsePrice(FirstSTEOYear-1, Sector_Commercial, CD_WSCentral) := NGCCU_WSC(FirstSTEOYear-1);
				STEOTargetEndUsePrice(FirstSTEOYear-1, Sector_Commercial, CD_MidAtlantic) := NGCCU_MAC(FirstSTEOYear-1);
				STEOTargetEndUsePrice(FirstSTEOYear-1, Sector_Commercial, CD_SAtlantic) := NGCCU_SAC(FirstSTEOYear-1);
				STEOTargetEndUsePrice(FirstSTEOYear-1, Sector_Commercial, CD_Mountain) := NGCCU_MTN(FirstSTEOYear-1);
				STEOTargetEndUsePrice(FirstSTEOYear-1, Sector_Commercial, CD_Pacific) := NGCCU_PAC(FirstSTEOYear-1);
				
				STEOTargetEndUsePrice(FirstSTEOYear-1, Sector_Residential, CD_NewEngland) := NGRCU_NEC(FirstSTEOYear-1);
				STEOTargetEndUsePrice(FirstSTEOYear-1, Sector_Residential, CD_ENCentral) := NGRCU_ENC(FirstSTEOYear-1);
				STEOTargetEndUsePrice(FirstSTEOYear-1, Sector_Residential, CD_WNCentral) := NGRCU_WNC(FirstSTEOYear-1);
				STEOTargetEndUsePrice(FirstSTEOYear-1, Sector_Residential, CD_ESCentral) := NGRCU_ESC(FirstSTEOYear-1);
				STEOTargetEndUsePrice(FirstSTEOYear-1, Sector_Residential, CD_WSCentral) := NGRCU_WSC(FirstSTEOYear-1);
				STEOTargetEndUsePrice(FirstSTEOYear-1, Sector_Residential, CD_MidAtlantic) := NGRCU_MAC(FirstSTEOYear-1);
				STEOTargetEndUsePrice(FirstSTEOYear-1, Sector_Residential, CD_SAtlantic) := NGRCU_SAC(FirstSTEOYear-1);
				STEOTargetEndUsePrice(FirstSTEOYear-1, Sector_Residential, CD_Mountain) := NGRCU_MTN(FirstSTEOYear-1);
				STEOTargetEndUsePrice(FirstSTEOYear-1, Sector_Residential, CD_Pacific) := NGRCU_PAC(FirstSTEOYear-1);
				
				
				
				
				!End-Use Prices
				STEOTargetEndUsePrice(steoyr, Sector_Commercial, CD_NewEngland) := NGCCU_NEC(steoyr);
				STEOTargetEndUsePrice(steoyr, Sector_Commercial, CD_ENCentral) := NGCCU_ENC(steoyr);
				STEOTargetEndUsePrice(steoyr, Sector_Commercial, CD_WNCentral) := NGCCU_WNC(steoyr);
				STEOTargetEndUsePrice(steoyr, Sector_Commercial, CD_ESCentral) := NGCCU_ESC(steoyr);
				STEOTargetEndUsePrice(steoyr, Sector_Commercial, CD_WSCentral) := NGCCU_WSC(steoyr);
				STEOTargetEndUsePrice(steoyr, Sector_Commercial, CD_MidAtlantic) := NGCCU_MAC(steoyr);
				STEOTargetEndUsePrice(steoyr, Sector_Commercial, CD_SAtlantic) := NGCCU_SAC(steoyr);
				STEOTargetEndUsePrice(steoyr, Sector_Commercial, CD_Mountain) := NGCCU_MTN(steoyr);
				STEOTargetEndUsePrice(steoyr, Sector_Commercial, CD_Pacific) := NGCCU_PAC(steoyr);
				
				STEOTargetEndUsePrice(steoyr, Sector_Residential, CD_NewEngland) := NGRCU_NEC(steoyr);
				STEOTargetEndUsePrice(steoyr, Sector_Residential, CD_ENCentral) := NGRCU_ENC(steoyr);
				STEOTargetEndUsePrice(steoyr, Sector_Residential, CD_WNCentral) := NGRCU_WNC(steoyr);
				STEOTargetEndUsePrice(steoyr, Sector_Residential, CD_ESCentral) := NGRCU_ESC(steoyr);
				STEOTargetEndUsePrice(steoyr, Sector_Residential, CD_WSCentral) := NGRCU_WSC(steoyr);
				STEOTargetEndUsePrice(steoyr, Sector_Residential, CD_MidAtlantic) := NGRCU_MAC(steoyr);
				STEOTargetEndUsePrice(steoyr, Sector_Residential, CD_SAtlantic) := NGRCU_SAC(steoyr);
				STEOTargetEndUsePrice(steoyr, Sector_Residential, CD_Mountain) := NGRCU_MTN(steoyr);
				STEOTargetEndUsePrice(steoyr, Sector_Residential, CD_Pacific) := NGRCU_PAC(steoyr);
				
				STEOTargetEndUsePrice(steoyr, Sector_Industrial, CD_NewEngland) := NGICU_NEC(steoyr);
				STEOTargetEndUsePrice(steoyr, Sector_Industrial, CD_ENCentral) := NGICU_ENC(steoyr);
				STEOTargetEndUsePrice(steoyr, Sector_Industrial, CD_WNCentral) := NGICU_WNC(steoyr);
				STEOTargetEndUsePrice(steoyr, Sector_Industrial, CD_ESCentral) := NGICU_ESC(steoyr);
				STEOTargetEndUsePrice(steoyr, Sector_Industrial, CD_WSCentral) := NGICU_WSC(steoyr);
				STEOTargetEndUsePrice(steoyr, Sector_Industrial, CD_MidAtlantic) := NGICU_MAC(steoyr);
				STEOTargetEndUsePrice(steoyr, Sector_Industrial, CD_SAtlantic) := NGICU_SAC(steoyr);
				STEOTargetEndUsePrice(steoyr, Sector_Industrial, CD_Mountain) := NGICU_MTN(steoyr);
				STEOTargetEndUsePrice(steoyr, Sector_Industrial, CD_Pacific) := NGICU_PAC(steoyr);
				
				STEOTargetElectricPrice(steoyr) := NGEUDUS(steoyr)*Convert_TBtu_Bcf(steoyr);
				!**************************************************************************************************
				!PIPELINE IMPORTS FROM CANADA
				STEOTargetCNImports(steoyr) := NGIMPUS_PIPE(steoyr)*1000* STEOCNImportPercent(steoyr);
				STEOTargetMXImports(steoyr) := NGIMPUS_PIPE(steoyr)*1000 - STEOTargetCNImports(steoyr);
				!PIPELINE EXPORTS TO CANADA
				STEOTargetCNExports(steoyr) := NGEXPUS_PIPE(steoyr)*1000* STEOCNExportPercent(steoyr);
				!PIPELINE EXPORTS TO MEXICO
				STEOTargetMXExports(steoyr) := NGEXPUS_PIPE(steoyr)*1000 - STEOTargetCNExports(steoyr);
				STEOTargetPipelineExports(steoyr,MexicoNorthEast) := STEOTargetMXExports(steoyr);
				!STEOTargetPipelineExports(steoyr,CanadaEast) := STEOTargetCNExports(steoyr);
				STEOTargetCNNetImports(steoyr) := STEOTargetCNImports(steoyr) - STEOTargetCNExports(steoyr);
				STEOTargetMXNetImports(steoyr) := STEOTargetMXImports(steoyr) - STEOTargetMXExports(steoyr);
			}
			Comment: "Set up adjusted STEO target values and STEO factors that are known in advance and DO NOT change every model year depending on the results";
			DeclarationSection Other_Declarations {
				Parameter DIFF {
					IndexDomain: steoyr;
				}
			}
		}
		Procedure STEOFactors_Run {
			Body: {
				if ModelYear<=LastSTEOYear then
				 !STEO years
				
				  !STORAGE
				  DIFF := sum((modelyrmn, l48), StorageWithdrawals(modelyrmn, l48) - StorageInjections(modelyrmn, l48))- STEOTargetNetWithdrawals(ModelYear);
				  STEOStorageWithdrawalFactor(ModelYear) :=  (sum((modelyrmn, l48), StorageWithdrawals(modelyrmn, l48)) - DIFF/2) /
				                                     sum((modelyrmn, l48), StorageWithdrawals(modelyrmn, l48));
				  STEOStorageInjectionFactor(ModelYear) :=  (sum((modelyrmn, l48), StorageInjections(modelyrmn, l48)) +  DIFF/2) /
				                                     sum((modelyrmn, l48), StorageInjections(modelyrmn, l48));
				 !***************************************************************************************************
				
				 !BALANCING ITEM
				 Temp1(ModelYear):=(NGTCPUS(ModelYear) - NGLPPUS(ModelYear) - NGACPUS(ModelYear))*1000;
				 temp2(ModelYear):=sum(state,AnnualTotalConsumption(ModelYear,state)) ;
				 temp3(ModelYear):=BALIT(ModelYear) *1000;
				 temp4(ModelYear) := (NGTCPUS(ModelYear) - NGLPPUS(ModelYear) - NGACPUS(ModelYear))*1000 - sum(state,AnnualTotalConsumption(ModelYear,state)) ;
				 !temp4(ModelYear) := (NGTCPUS(ModelYear) )*1000 - sum(state,AnnualTotalConsumption(ModelYear,state)) ;
				  !DIFF1(ModelYear) := (NGTCPUS(ModelYear) - NGLPPUS(ModelYear) - NGACPUS(ModelYear))*NumberOfDaysInYear(ModelYear) - sum(state,AnnualTotalConsumption(ModelYear,state)) ;
				  !DIFF1(ModelYear) := (NGTCPUS(ModelYear) - NGLPPUS(ModelYear) - NGACPUS(ModelYear))*1000 - sum(state,AnnualTotalConsumption(ModelYear,state)) ;
				  !Temp, until AK discrepancy is available
				  DIFF1(ModelYear) := (NGTCPUS(ModelYear) - NGLPPUS(ModelYear) - NGACPUS(ModelYear))*1000 - sum(state,AnnualTotalConsumption(ModelYear,state)) ;
				  !STEOTargetBalancingItem(ModelYear):= BALIT(ModelYear) *NumberOfDaysInYear(ModelYear) - AK_Discrepancy(ModelYear) + DIFF1(ModelYear);
				  !STEOTargetBalancingItem(ModelYear):= BALIT(ModelYear) *1000 - AK_Discrepancy(ModelYear) + DIFF1(ModelYear);
				  STEOTargetBalancingItem(ModelYear):= BALIT(ModelYear) *1000 - sum(modelyrmn, BalanceItem(modelyrmn,AKState)) + DIFF1(ModelYear);
				  STEOBalancingItemFactor(ModelYear) := STEOTargetBalancingItem(ModelYear)/sum((modelyrmn,l48), BalanceItem(modelyrmn,l48));
				  !***************************************************************************************************
				  !SUPPLEMENTAl SUPPLY
				  STEOSupplementalSupplyFactor(ModelYear) := STEOTargetSupplementalSupply(ModelYear)/sum((sng,qps) , AnnualSupply(ModelYear, sng, qps));
				  !**************************************************************************************************
				  !LNG EXPORTS
				  STEOTargetLNGExports(ModelYear) := NGEXPUS_LNG(ModelYear)*1000-AK_LNG_Exports(ModelYear);
				  STEOLNGExportsFactor(ModelYear) := STEOTargetLNGExports(ModelYear) - sum((modelyrmn,lngexp_l48), LNGExports(modelyrmn,lngexp_l48));
				  !*************************************************************************************
				
				  !LNG IMPORTS
				  !STEOTargetLNGImports(ModelYear) := NGIMPUS_LNG(ModelYear) *NumberOfDaysInYear(ModelYear);
				  STEOTargetLNGImports(ModelYear) := NGIMPUS_LNG(ModelYear) *1000;
				  STEOLNGImportsFactor(ModelYear) := STEOTargetLNGImports(ModelYear) /sum((modelyrmn,l48), Supply(modelyrmn, Supply_LNG, l48));
				  !*************************************************************************************
				
				  !LEASE AND PLANT FUEL
				  !STEOTargetLeaseFuel(ModelYear) := NGLPPUS(ModelYear) *NumberOfDaysInYear(ModelYear) - sum(r_ak, AK_LeasePlant(ModelYear,r_ak))- sum((l48,modelyrmn),PlantFuel(modelyrmn,l48)) ;
				  !STEOTargetLeaseFuel(ModelYear) := NGLPPUS(ModelYear) *1000 - sum(r_ak, AK_LeasePlant(ModelYear,r_ak))- sum((l48,modelyrmn),PlantFuel(modelyrmn,l48)) ;
				  STEOTargetLeaseFuel(ModelYear) := NGLPPUS(ModelYear) *1000 - sum(r_ak, AK_LeasePlant(ModelYear,r_ak))- sum((l48,modelyrmn),PlantFuel(modelyrmn,l48)) ;
				
				  !*****************************************************************************************
				
				  !PIPELINE FUEL
				  !  STEOTargetPipeFuel(ModelYear) := NGACPUS(ModelYear) *NumberOfDaysInYear(ModelYear) - sum(r_ak, AK_Pipeline(r_ak, ModelYear))-
				  !                                   sum(l48, (StorageLossesAnnual(ModelYear,l48)+DistributionLossesAnnual(ModelYear,l48))) ;
				  STEOTargetPipeFuel(ModelYear) := NGACPUS(ModelYear) *1000 - sum(r_ak, AK_Pipeline(ModelYear,r_ak))-
				                                   sum(l48, (StorageLossesAnnual(ModelYear,l48)+DistributionLossesAnnual(ModelYear,l48)+IntrastatePipeFuelLossesAnnual(ModelYear,l48)))
				                                   - (STEOTargetLNGExports(ModelYear)* Pct_Liquifaction_Fuel) ;
				  !****************************************************************************************************
				  !WELLHEAD PRICES
				  STEOTargetHenryHubPrice(ModelYear) := NGHHUUS(ModelYear)*Convert_TBtu_Bcf(ModelYear);!  / GDPPriceDeflator87(ModelYear); !yda: looks like it is already in $87
				  !****************************************************************************************************
				  !PIPELINE IMPORTS/EXPORTS
				  STEOTargetFlowOutCNW(ModelYear) := STEOTargetCNImports(ModelYear) - STEOTargetCNExports(ModelYear) + sum(modelyrmn, TotalConsumption(modelyrmn, CanadaEast) +
				         LNGExports(modelyrmn, CanadaEast) - sum(naadgas, Supply(modelyrmn, naadgas, CanadaEast)) - BalanceItem(modelyrmn, CanadaEast) ) ;
				  STEOTargetCNWProduction(ModelYear) := STEOTargetCNImports(ModelYear) - STEOTargetCNExports(ModelYear) + sum(modelyrmn, LNGExports(modelyrmn, CanadaEast) -
				         sum(naadgas,Supply(modelyrmn, naadgas, CanadaEast)) + sum(cn, TotalConsumption(modelyrmn, cn) - BalanceItem(modelyrmn, cn)) ) ;
				  !temp
				
				!  STEOQP_Run;
				!  STEOPipelineExportFactor(MonthInPeriod(tmon),steocnmx):=STEODemandAdj(tmon, steocnmx);
				!  STEOImpExpAnnualFactor(ModelYear,steocnmx):=sum(modelyrmn, STEOPipelineImpExpFactor(modelyrmn,steocnmx));
				!  !temp
				!  SteoConvergenceFlag:=1;
				
				
				else
				!Phase out years
				 if (ModelYear=LastSteoYear+1) then
				  tempimpexp(mn,steocnmx):=sum(lagyrmn |map_Month_MonthinYear(lagyrmn,mn) and lagyrmn< YearToMonth(ModelYear), STEOPipelineExportFactor(lagyrmn,steocnmx))/NumberOfSTEOPhaseOutYears;
				  endif;
				
				  STEOBalancingItemFactor(ModelYear) := STEOBalancingItemFactor(ModelYear-1) + (STEOFactor0-STEOBalancingItemFactor(LastSTEOYear))/NumberOfSTEOPhaseOutYears;
				  STEOLNGImportsFactor(ModelYear) := STEOLNGImportsFactor(ModelYear-1) + (STEOFactor0-STEOLNGImportsFactor(LastSTEOYear))/NumberOfSTEOPhaseOutYears;
				  STEOLeaseFuelFactor(ModelYear) := STEOLeaseFuelFactor(ModelYear-1) + (STEOFactor0-STEOLeaseFuelFactor(LastSTEOYear))/NumberOfSTEOPhaseOutYears;
				  STEOPipeFuelFactor(ModelYear) := STEOPipeFuelFactor(ModelYear-1) + (STEOFactor0-STEOPipeFuelFactor(LastSTEOYear))/NumberOfSTEOPhaseOutYears;
				  STEOStorageWithdrawalFactor(ModelYear) := STEOStorageWithdrawalFactor(ModelYear-1) + (STEOFactor0-STEOStorageWithdrawalFactor(LastSTEOYear))/NumberOfSTEOPhaseOutYears;
				  STEOStorageInjectionFactor(ModelYear) := STEOStorageInjectionFactor(ModelYear-1)+ (STEOFactor0-STEOStorageInjectionFactor(LastSTEOYear))/NumberOfSTEOPhaseOutYears;
				  STEOSupplementalSupplyFactor(ModelYear) := STEOSupplementalSupplyFactor(ModelYear-1) + (STEOFactor0-STEOSupplementalSupplyFactor(LastSTEOYear))/NumberOfSTEOPhaseOutYears;
				
				! Only do STEO benchmarking based on flags read in from ngassumptions.txt
				if (STEOMXExportsPhaseOutFlag = 1) then
					  STEOMXExportFactor(ModelYear) := STEOMXExportFactor(ModelYear-1) + (STEOFactor0-STEOMXExportFactor(LastSTEOYear))/NumberOfSTEOPhaseOutYears;
				endif;
				if (STEOCANExportsPhaseOutFlag = 1) then
					  STEOCNExportFactor(ModelYear) := STEOCNExportFactor(ModelYear-1) + (STEOFactor0-STEOCNExportFactor(LastSTEOYear))/NumberOfSTEOPhaseOutYears;
				endif;
				if (STEOPipelineImportPhaseOutFlag = 1) then
				  	STEOPipelineImportFactor(ModelYear) := STEOPipelineImportFactor(ModelYear-1) + (STEOFactor0-STEOPipelineImportFactor(LastSTEOYear))/NumberOfSTEOPhaseOutYears;
				endif;
				
				  !STEOWellhdPriceFactor(ModelYear) := STEOWellhdPriceFactor(ModelYear-1) + (STEOFactor0-STEOWellhdPriceFactor(LastSTEOYear))/NumberOfSTEOPhaseOutYears;
				
				 ! STEOPipelineExportFactor((lagyrmn,steocnmx) | lagyrmn>= YearToMonth(ModelYear)) := STEOPipelineExportFactor(lagyrmn-12,steocnmx) -
				 !              sum(mn | map_Month_MonthinYear(lagyrmn,mn), tempimpexp(mn,steocnmx));
				 ! STEOImpExpAnnualFactor(ModelYear,steocnmx):=sum(modelyrmn, STEOPipelineExportFactor(modelyrmn,steocnmx));
				endif;
				!*************************************************************************************
			}
			Comment: {
				"Run only in Steo + phase out years (TotalSteoYears_)
				This procedure calculates the STEO target values and STEO factors that change every model year, but are not determined by iterative process"
			}
			DeclarationSection Local_Declaration {
				Parameter DIFF_LP;
				Parameter DIFF;
			}
		}
		Procedure STEOFactors_IterateCombined {
			Body: {
				SteoIter:='1';
				SteoConvergenceFlag := 0;
				STEOLeaseFuelFactor(ModelYear):=STEOFactor0;
				STEOPipeFuelFactor(ModelYear):=STEOFactor0;
				STEOWellhdPriceFactor(ModelYear):=STEOFactor0;
				STEOPipelineImportFactor(ModelYear):=STEOFactor0;
				STEOMXExportFactor(ModelYear):=0;
				repeat
				   STEOQP_Run;
				!  STEOPipelineExportFactor(MonthInPeriod(tmon),steocnmx):=STEODemandAdj(tmon, steocnmx);
				!  STEOImpExpAnnualFactor(ModelYear,steocnmx):=sum(modelyrmn, STEOPipelineExportFactor(modelyrmn,steocnmx));
				!  STEOMXExpAnnualFactor(ModelYear):=sum(steocnmx, STEOImpExpAnnualFactor(ModelYear,steocnmx));
				  STEO_CNWproduction;
				 ! delta_Imports:=STEOTargetCNWProduction(ModelYear)/ProductionCNW(ModelYear);
				  delta_Imports:=STEOTargetCNNetImports(ModelYear)/NetImports_Canada(ModelYear);
				  delta_MxExports:=Exports_Mexico(ModelYear)-STEOTargetMXExports(ModelYear);
				  STEO_CalculateFuel;
				
				  !delta_Lease:= abs(STEOTargetLeaseFuel(ModelYear)-TotalLeaseFuelAnnual(ModelYear));
				  delta_Lease:= STEOTargetLeaseFuel(ModelYear)/TotalLeaseFuelAnnual(ModelYear);
				  delta_Pipe:= STEOTargetPipeFuel(ModelYear)/TotalTranFuelAnnual(ModelYear);
				  delta_HH:=STEOTargetHenryHubPrice(ModelYear)/HenryHubPrice(ModelYear);
				  !delta_HH:=abs(STEOTargetHenryHubPrice(ModelYear)-HenryHubPrice(ModelYear));
				  TempLease(ModelYear,SteoIter):=TotalLeaseFuelAnnual(ModelYear);
				  TempPipe(ModelYear,SteoIter):=TotalTranFuelAnnual(ModelYear);
				  TempHHPrice(ModelYear,SteoIter):=HenryHubPrice(ModelYear);
				  if (0.98<=delta_Lease <= 1.02 and 0.98<=delta_Pipe <= 1.02 and 0.98<=delta_HH <= 1.02 and 0.975<=delta_Imports <= 1.025 ) then SteoConvergenceFlag:=1; endif;
				  break when SteoConvergenceFlag;
				  if SteoIter = MaxSteoIter then
				     RAISE WARNING "Maximum number of STEO BM Iterations achieved in year "+ModelYear+" without converging. Continuing execution. For details see NGATTENTION.txt" CODE 'SteoConvergence';
				     SteoConvergenceFlag:=1;
				     if (0.98>=delta_Lease or delta_Lease >= 1.02 ) then
				     	write delta_Lease to file "NGATTENTION.txt" in merge mode;
				     endif;
				     if (0.98>=delta_Pipe or delta_Pipe >= 1.02 ) then
				     	write delta_Pipe to file "NGATTENTION.txt" in merge mode;
				     endif;
				     if (0.98>=delta_HH or delta_HH>= 1.02 ) then
				     	write delta_HH to file "NGATTENTION.txt" in merge mode;
				     endif;
				     if (0.975>=delta_Imports or delta_Imports >= 1.025 ) then
				     	write delta_Imports to file "NGATTENTION.txt" in merge mode;
				     endif;
				  endif;
				
				break when SteoConvergenceFlag;
				!break when (0.9999<=delta_Lease <= 1.0001 and 0.9999<=delta_Pipe <= 1.0001 and 0.99<=delta_HH <= 1.01);
				!break when (0.98<=delta_Lease <= 1.02 and 0.98<=delta_Pipe <= 1.02 and 0.98<=delta_HH <= 1.02);
				!break when (0.98<=delta_Lease <= 1.02 and 0.98<=delta_Pipe <= 1.02 and delta_HH <= 0.05);
				!break when ( 0.98<=delta_Pipe <= 1.02 and delta_HH <= 0.05);
				
				  !LEASE FUEL
				  STEOTempLeaseFuelFactor(ModelYear,SteoIter):=STEOLeaseFuelFactor(ModelYear);
				  STEOLeaseFuelFactor(ModelYear):=STEOTempLeaseFuelFactor(ModelYear,SteoIter)*STEOTargetLeaseFuel(ModelYear)/TotalLeaseFuelAnnual(ModelYear);
				
				  !PIPE FUEL
				  STEOTempPipeFuelFactor(ModelYear,SteoIter):=STEOPipeFuelFactor(ModelYear);
				  STEOPipeFuelFactor(ModelYear):=STEOTempPipeFuelFactor(ModelYear,SteoIter)*STEOTargetPipeFuel(ModelYear)/TotalTranFuelAnnual(ModelYear);
				  !WELLHEAD PRICES
				  STEOTempWellhdPriceFactor(ModelYear,SteoIter):=STEOWellhdPriceFactor(ModelYear);
				  STEOWellhdPriceFactor(ModelYear):=STEOTempWellhdPriceFactor(ModelYear,SteoIter)*STEOTargetHenryHubPrice(ModelYear)/HenryHubPrice(ModelYear);
				
				  !CANADA NET IMPORTS
				  STEOTempPipelineImportFactor(ModelYear,SteoIter):=STEOPipelineImportFactor(ModelYear);
				!  STEOPipelineImportFactor(ModelYear):=STEOTempPipelineImportFactor(ModelYear,SteoIter)*STEOTargetCNWProduction(ModelYear)/ProductionCNW(ModelYear);
				  STEOPipelineImportFactor(ModelYear):=STEOTempPipelineImportFactor(ModelYear,SteoIter)*STEOTargetCNNetImports(ModelYear)/NetImports_Canada(ModelYear);
				
				  TempFactorBracket(ModelYear,SteoIter):=STEOTargetCNNetImports(ModelYear)/NetImports_Canada(ModelYear);
				  !The idea is to change the factor for the percent difference between target and solution [(target-solution)/solution ]
				  STEOPipelineImportFactor(ModelYear):=STEOTempPipelineImportFactor(ModelYear,SteoIter)+
				                STEOTargetCNNetImports(ModelYear)/NetImports_Canada(ModelYear)-1;
				  !MEXICO EXPORTS
				   STEOTempPipelineExportFactor(ModelYear,SteoIter):=STEOMXExportFactor(ModelYear); 
				 !  STEOMXExportFactor(ModelYear):= Exports_Mexico(ModelYear)-STEOTargetMXExports(ModelYear);             
				  STEOMXExportFactor(ModelYear):= STEOTempPipelineExportFactor(ModelYear,SteoIter)+Exports_Mexico(ModelYear)-STEOTargetMXExports(ModelYear); 
				
				
				  SteoIter +=1;
				
				
				endrepeat;
			}
			Comment: "This procedure sets up the iterative algorithm for calculating STEO factors";
			DeclarationSection Local_Declaration;
		}
		Procedure STEOScaling_Run {
			Body: {
				!Align to STEO
				if (not LastDataYearFlg_Storage(ModelYear)) then
					StorageInjections(modelyrmn,l48) *=   STEOStorageInjectionFactor(MonthToYear(modelyrmn));
					StorageWithdrawals(modelyrmn,l48) *=  STEOStorageWithdrawalFactor(MonthToYear(modelyrmn));
				endif;
				if (not LastDataYearFlg_SupProd(ModelYear)) then
					Supply(modelyrmn, sng, qps)  *= STEOSupplementalSupplyFactor(MonthToYear(modelyrmn));
				endif;
				if (not LastDataYearFlg_LNGImp(ModelYear)) then Supply(modelyrmn, Supply_LNG, l48) *= STEOLNGImportsFactor(MonthToYear(modelyrmn)); endif;
				
				!BalanceItem(modelyrmn,l48) *=   STEOBalancingItemFactor(MonthToYear(modelyrmn));
				TotalLNGExports :=sum((modelyrmn,lngexp_l48), LNGExports(modelyrmn,lngexp_l48));
				LNGExports(modelyrmn,lngexp_l48) +=  STEOLNGExportsFactor(MonthToYear(modelyrmn))* LNGExports(modelyrmn,lngexp_l48)/ $ TotalLNGExports;
				!Supply(modelyrmn, Supply_LNG, l48) *= STEOLNGImportsFactor(MonthToYear(modelyrmn));
				!Supply(modelyrmn, sng, l48)  *= STEOSupplementalSupplyFactor(MonthToYear(modelyrmn));
			}
			Comment: "This procedure scales the parameters to match STEO";
			DeclarationSection Local_Declaration {
				Parameter TotalLNGExports;
			}
		}
		Procedure STEO_CalculateFuel {
			Body: {
				!Lease Fuel
				ActualProductionMonthly(MonthInPeriod(tmon), suptype, qps) := QProduction(tmon,suptype,qps);
				LeaseFuelBySupplyRegion(modelyrmn,l48s) := sum(naadgas, ActualProductionMonthly(modelyrmn, naadgas, l48s)) * LeaseFuelFactor(l48s)*STEOLeaseFuelFactor(ModelYear) /
				                                          (1 - LeaseFuelFactor(l48s)*STEOLeaseFuelFactor(ModelYear));
				LeaseFuel(modelyrmn,l48) := sum(l48s | map_SupplyArcs(l48s, l48), LeaseFuelBySupplyRegion(modelyrmn,l48s));
				TotalLeaseFuelAnnual(ModelYear) := sum((modelyrmn,l48), LeaseFuel(modelyrmn,l48));
				!Pipeline Fuel
				FlowsMonthly(MonthInPeriod(tmon), h, h1) := FlowHubToHub(tmon,h,h1);
				TranFuelLosses(modelyrmn, h) := (sum(h1, FlowsMonthly(modelyrmn, h, h1) * PipeFuelLossFactorOUT(h, h1))
				                              + sum(h1, FlowsMonthly(modelyrmn, h1, h) * (1 - PipeFuelLossFactorOUT(h1, h))* PipeFuelLossFactorIN(h1, h)))*STEOPipeFuelFactor(ModelYear);
				TotalTranFuelAnnual(ModelYear) :=sum((modelyrmn,l48), TranFuelLosses(modelyrmn, l48));
				
				!Wellhead Prices
				QP_SupplyPriceSolution((MonthInPeriod(tmon),suptype, qps) | SupplyAccounting.ShadowPrice(tmon,suptype,qps)> 0.7) := SupplyAccounting.ShadowPrice(tmon,suptype,qps);
				
				!Do weighted average to calculate annual price
				STEOSolnWellhdPrice((ModelYear, Supply_NA, qps,SteoIter) | map_Supply(qps, Supply_NA)):= $ sum(modelyrmn, QP_SupplyPriceSolution(modelyrmn,Supply_NA, qps)* ActualProductionMonthly(modelyrmn, Supply_NA, qps))/$
				                                                          sum(modelyrmn, ActualProductionMonthly(modelyrmn, Supply_NA, qps));
				!Stepnumber(MonthInPeriod(tmon), qps) := count(step | QSupplyStep(tmon, Supply_NA, qps, step)) ;
				!MaxStepsln(modelyrmn, qps) := Element(Supply_Curve_Step_, Stepnumber(modelyrmn, qps));
				!WHPrcCalc_monthly((MonthInPeriod(tmon), qps) | map_Supply(qps, Supply_NA) ) := Pbase(tmon, Supply_NA, qps, MaxStepsln(MonthInPeriod(tmon), qps)) +
				!  ( QProduction(tmon, Supply_NA, qps) - Qbase(tmon, Supply_NA, qps, MaxStepsln(MonthInPeriod(tmon), qps)) ) *
				!  ( Pbase(tmon, Supply_NA, qps, MaxStepsln(MonthInPeriod(tmon), qps)+1) - Pbase(tmon, Supply_NA, qps, MaxStepsln(MonthInPeriod(tmon), qps)) ) /$
				!  ( Qbase(tmon, Supply_NA, qps, MaxStepsln(MonthInPeriod(tmon), qps)+1) - Qbase(tmon, Supply_NA, qps, MaxStepsln(MonthInPeriod(tmon), qps)) );
				!
				!!Do weighted average to calculate annual price
				!STEOWHPrcCalc_annual((ModelYear, qps,SteoIter)| map_Supply(qps, Supply_NA) ) :=  sum(modelyrmn, WHPrcCalc_monthly(modelyrmn, qps)* ActualProductionMonthly(modelyrmn, Supply_NA, qps))/ $
				!                                                                 sum(modelyrmn, ActualProductionMonthly(modelyrmn, Supply_NA, qps));
				!
				!WellhdPrice((ModelYear, naadgas, qps) | map_Supply(qps, naadgas)):= WHPrcCalc_annual(ModelYear, qps);
				
				HenryHubPrice(ModelYear):= (STEOSolnWellhdPrice(ModelYear, Supply_NA, HenryHubRegion,SteoIter)+GatheringCharge(HenryHubRegion));
			}
			Comment: "Postprocess the QP results to determine the values needed for the next iteration of STEO benchmarking iterative algorithm";
			DeclarationSection LP_Fuel_Declaration {
				Parameter LeaseFuelBySupplyRegion {
					IndexDomain: (mon,s);
				}
				Parameter TranFuelLosses {
					IndexDomain: (mon,reg);
				}
			}
		}
		Procedure STEO_CNWproduction {
			Body: {
				ProductionCNW(ModelYear):= sum(tmon,QProduction(tmon,Supply_NA,CanadaWest));
				TempProductionCNW(ModelYear,SteoIter):=ProductionCNW(ModelYear);
				TempQNodeCNW(ModelYear,SteoIter):=sum(tmon, QP_Supply(tmon,Supply_NA,CanadaWest)) ;
				TempWHPriceCNW(ModelYear,SteoIter):= sum(tmon, SupplyAccounting.ShadowPrice(tmon,Supply_NA,CanadaWest)* QProduction(tmon,Supply_NA,CanadaWest))/$ ProductionCNW(ModelYear);
				TempCNImports(ModelYear,SteoIter):= sum((tmon,cn,BX)|map_hubs_borderXings(cn,bx),FlowHubToHub(tmon,cn,bx));
				TempCNWimports(ModelYear,SteoIter):= sum((tmon,BX)|map_hubs_borderXings(CanadaWest,bx),FlowHubToHub(tmon,CanadaWest,bx));
				TempCNEimports(ModelYear,SteoIter):= sum((tmon,BX)|map_hubs_borderXings(CanadaEast,bx),FlowHubToHub(tmon,CanadaEast,bx));
				TempCNExports(ModelYear,SteoIter):= sum((tmon,cn,BX)|map_hubs_borderXings(cn,bx),FlowHubToHub(tmon,bx,cn));
				TempCNW_CNE_Flow(ModelYear,SteoIter):= sum(tmon, FlowHubToHub(tmon,CanadaWest,CanadaEast));
				TempCNNetImports(ModelYear,SteoIter):= TempCNImports(ModelYear,SteoIter) - TempCNExports(ModelYear,SteoIter);
				NetImports_Canada(ModelYear):= TempCNNetImports(ModelYear,SteoIter);
				
				TempMXExports(ModelYear,SteoIter):= sum((tmon,mx,BX)|map_hubs_borderXings(mx,bx),FlowHubToHub(tmon,bx,mx));
				Exports_Mexico(ModelYear):=TempMXExports(ModelYear,SteoIter);
			}
		}
		Procedure STEO_EndusePrices {
			Body: {
				if ModelYear<=LastSTEOYear then
				!STEO years
				   STEOEndUsePriceFactor(ModelYear, Sector_Residential, r_cen):= STEOTargetEndUsePrice(ModelYear, Sector_Residential, r_cen)/Price_Enduse(ModelYear, Sector_Residential, r_cen, ResidentialOption);
				   STEOEndUsePriceFactor(ModelYear, Sector_Commercial, r_cen):= STEOTargetEndUsePrice(ModelYear, Sector_Commercial, r_cen)/Price_Enduse(ModelYear, Sector_Commercial, r_cen, CommercialOption);
				   if STEONGIND then
				       STEOEndUsePriceFactor(ModelYear, Sector_Industrial, r_cen):= STEOTargetEndUsePrice(ModelYear, Sector_Industrial, r_cen)/Price_Enduse(ModelYear, Sector_Industrial, r_cen, IndustrialOption);
				   endif;
				   STEOElectricPriceFactor(ModelYear) := STEOTargetElectricPrice(ModelYear)/AveragePrice_EnduseElectric(ModelYear);
				
				else
				!!Phase out years
				  STEOEndUsePriceFactor(ModelYear, rescom, r_cen) := STEOEndUsePriceFactor(ModelYear-1, rescom, r_cen) + (STEOFactor0-STEOEndUsePriceFactor(LastSTEOYear, rescom, r_cen))/NumberOfSTEOPhaseOutYears;
				  if STEONGIND then
				       STEOEndUsePriceFactor(ModelYear, Sector_Industrial, r_cen):= STEOEndUsePriceFactor(ModelYear-1, Sector_Industrial, r_cen) +
				                              (STEOFactor0-STEOEndUsePriceFactor(LastSTEOYear, Sector_Industrial, r_cen))/NumberOfSTEOPhaseOutYears;
				   endif;
				    STEOElectricPriceFactor(ModelYear):= STEOElectricPriceFactor(ModelYear-1) + (STEOFactor0-STEOElectricPriceFactor(LastSTEOYear))/NumberOfSTEOPhaseOutYears;
				endif;
			}
			Comment: "Calculate STEO factors for enduse prices";
		}
		Procedure STEO_ImportExportPostprocess {
			Body: {
				if (STEOBM=1 and STEONG=1) then
				   if (STSCALNG=0 or ModelYear < LastSTEOYear) then   !temp for aeo2018 !if STSCALNG=0 then
				      STEOCNExportFactor(ModelYear) := STEOTargetCNExports(ModelYear) / Exports_Canada(ModelYear);
				   endif;
				endif;
				Exports_Canada(ModelYear) *= STEOCNExportFactor(ModelYear) ;
				Imports_Canada(ModelYear) := NetImports_Canada(ModelYear) + Exports_Canada(ModelYear);
			}
			Comment: "Postprocess Canada imports and exports to align with the STEO numbers";
		}
		Procedure STEOFactors_Write {
			Body: {
				!write STEOStorageInjectionFactor to file "data\\NGSTEOFactors.txt" ;
				!write STEOStorageWithdrawalFactor to file "data\\NGSTEOFactors.txt" in merge mode;
				!write STEOBalancingItemFactor to file "data\\NGSTEOFactors.txt" in merge mode;
				!write STEOSupplementalSupplyFactor to file "data\\NGSTEOFactors.txt" in merge mode;
				!write STEOLNGExportsFactor to file "data\\NGSTEOFactors.txt" in merge mode;
				!write STEOLNGImportsFactor to file "data\\NGSTEOFactors.txt" in merge mode;
				!write STEOLeaseFuelFactor to file "data\\NGSTEOFactors.txt" in merge mode;
				!write STEOPipeFuelFactor to file "data\\NGSTEOFactors.txt" in merge mode;
				!write STEOWellhdPriceFactor to file "data\\NGSTEOFactors.txt" in merge mode;
				!write STEOEndUsePriceFactor to file "data\\NGSTEOFactors.txt" in merge mode;
				!write STEOElectricPriceFactor to file "data\\NGSTEOFactors.txt" in merge mode;
				!write STEOPipelineExportFactor to file "data\\NGSTEOFactors.txt" in merge mode;
				!write STEOPipelineImportFactor to file "data\\NGSTEOFactors.txt" in merge mode;
				!write STEOMXExportFactor to file "data\\NGSTEOFactors.txt" in merge mode;
				!write STEOCNExportFactor to file "data\\NGSTEOFactors.txt" in merge mode;
				
				tempfilename:="data\\NGSTEOFactors.txt";
				put TempFile;
				put "Composite table:",/;
				put "year":>5, "STEOStorageInjectionFactor":>29, "STEOStorageWithdrawalFactor":>29, "STEOBalancingItemFactor":>29, /;
				put "!----":>5, "--------------------------":>29, "---------------------------":>29, "-----------------------":>29, /;
				for (totsteoyr) do put totsteoyr:>5, STEOStorageInjectionFactor(totsteoyr):>29:6, STEOStorageWithdrawalFactor(totsteoyr):>29:6, STEOBalancingItemFactor(totsteoyr):>29:6, /; endfor;
				put ";", /;
				
				put "Composite table:",/;
				put "year":>5, "STEOLNGExportsFactor":>22, "STEOLNGImportsFactor":>22, /;
				put "!----":>5, "--------------------":>22, "--------------------":>22, /;
				for (totsteoyr) do put totsteoyr:>5, STEOLNGExportsFactor(totsteoyr):>22:6, STEOLNGImportsFactor(totsteoyr):>22:6, /; endfor;
				put ";", /;
				
				put "Composite table:",/;
				put "year":>5, "STEOLeaseFuelFactor":>22, "STEOPipeFuelFactor":>22, "STEOSupplementalSupplyFactor":>30, /;
				put "!----":>5, "-------------------":>22, "------------------":>22, "----------------------------":>30, /;
				for (totsteoyr) do put totsteoyr:>5, STEOLeaseFuelFactor(totsteoyr):>22:6, STEOPipeFuelFactor(totsteoyr):>22:6, STEOSupplementalSupplyFactor(totsteoyr):>30:6, /; endfor;
				put ";", /;
				
				put "Composite table:",/;
				put "year":>5, "STEOWellhdPriceFactor":>25, "STEOElectricPriceFactor":>25, /;
				put "!----":>5, "---------------------":>25, "-----------------------":>25, /;
				for (totsteoyr) do put totsteoyr:>5, STEOWellhdPriceFactor(totsteoyr):>25:9, STEOElectricPriceFactor(totsteoyr):>25:6, /; endfor;
				put ";", /;
				
				put "Composite table:",/;
				put "year":>5, "STEOPipelineImportFactor":>28, "STEOMXExportFactor":>22, "STEOCNExportFactor":>22, /;
				put "!----":>5, "------------------------":>28, "------------------":>22, "------------------":>22, /;
				for (totsteoyr) do put totsteoyr:>5, STEOPipelineImportFactor(totsteoyr):>28:6, STEOMXExportFactor(totsteoyr):>22:6, STEOCNExportFactor(totsteoyr):>22:6, /; endfor;
				put ";", /;
				
				put "STEOEndUsePriceFactor := data table", /;
				put @22;
				for (r_cen) do put r_cen:>12; endfor;
				put /;
				put @21, "!";
				for (r_cen) do put "-----------":>12; endfor;
				put /;
				for (sec,totsteoyr) do
				!  for (totsteoyr) do 
				put "(", totsteoyr:>4,",", sec:<14, ")", @22;
				    for (r_cen) do put STEOEndUsePriceFactor(totsteoyr, sec, r_cen):>12:6; endfor;
				    put /;
				 ! endfor;
				endfor; 
				put ";";
				!display {STEOStorageInjectionFactor decimals:=6, STEOStorageWithdrawalFactor decimals:=6, STEOBalancingItemFactor decimals:=6}; 
				!display {STEOLNGExportsFactor decimals:=6, STEOLNGImportsFactor decimals:=6};
				!display {STEOLeaseFuelFactor decimals:=6, STEOPipeFuelFactor decimals:=6, STEOSupplementalSupplyFactor decimals:=6};
				!display {STEOWellhdPriceFactor decimals:=6, STEOElectricPriceFactor decimals:=6};
				!display {STEOPipelineImportFactor decimals:=6, STEOMXExportFactor decimals:=6, STEOCNExportFactor decimals:=6};
				!display STEOEndUsePriceFactor where decimals :=6;
				putclose TempFile;
			}
			Comment: "Write out calculated STEO factors to a txt file";
		}
		Procedure STEOTransferDataIntoQPparameters {
			Body: {
				LinkHorizonToCalendar; !Create timetable
				!Define maximum step on the tariff curve
				PTCrv_MaxStep := Element(Supply_Curve_Step_,3);
				
				!Transfer data into QP Parameters
				
				!TotalConsumption( (mon,l48)  ) :=  sum(sec, Cons_State_Mon(mon, sec, l48)); !End Use Consumption Subroutine **moved to End Use Consumption Run... delete once verified it works
				QP_Consumption(tmon,d) := 	TotalConsumption(MonthInPeriod(tmon), d);
				!QP_Consumption(tmon,l48) := 	sum(sec, Cons_State_Mon(MonthInPeriod(tmon), sec, l48));	!End Use Consumption Subroutine
				
				QP_Discrepancy(tmon,d) := BalanceItem(MonthInPeriod(tmon), d);
				!This code replaces the line above in the attempt to avoid infeasibilities caused by negative "demand" when discrepancy for a state is larger than consumption in that state
				!QP_Discrepancy_Demand((tmon,d) | BalanceItem(MonthInPeriod(tmon), d)<=0) := BalanceItem(MonthInPeriod(tmon), d);
				!QP_Discrepancy_Supply((tmon,s) | BalanceItem(MonthInPeriod(tmon), s)>=0) := BalanceItem(MonthInPeriod(tmon), s);
				!
				
				! Add LNG exports to Mexico region for consumption
				QP_Consumption(tmon,Mexico_NE) += IEO_LNGExport_Monthly(MonthInPeriod(tmon), Mexico_NE);
				QP_Consumption(tmon,Mexico_SS) += IEO_LNGExport_Monthly(MonthInPeriod(tmon), Mexico_SS);
				
				QP_Storage_Withdrawals(tmon,storage) := StorageWithdrawals(MonthInPeriod(tmon), storage);
				QP_Storage_Injections(tmon,storage) := StorageInjections(MonthInPeriod(tmon), storage);
				
				QP_Supply(tmon,suptype,s) := Supply(MonthInPeriod(tmon), suptype, s) ;
				!Subtract lease fuel
				!QP_Supply(tmon,naadgas, s) *= (1 - LeaseFuelFactor(s)*STEOLeaseFuelFactor(YearInPeriod(tmon)));
				QP_SupplyPrice(tmon,suptype,s) := WellhdPrice(YearInPeriod(tmon)-1, suptype, s)* STEOWellhdPriceFactor(ModelYear);
				if ModelYear=FirstModelYear then QP_SupplyPrice(tmon,suptype,s) := WellhdPrice(YearInPeriod(tmon), suptype, s)* STEOWellhdPriceFactor(ModelYear); endif;
				QP_GatheringCharge(tmon,s) := GatheringCharge(s);
				QP_Capacity(tmon,h,h1) := CurrentPipeCapacity(MonthInPeriod(tmon), h, h1);
				Parameter_CapacityUtilization(h, h1, step) := VariableTariffCurve(h, h1, Qtype, step);
				Parameter_TariffCurvePrice(h, h1, step) := VariableTariffCurve(h, h1, Ptype, step);
				!QP_PipelineTariff(tmon,h,h1) := 1;
				QP_LNGExportCapacity(tmon,lngexp_qp) := LNGExports(MonthInPeriod(tmon), lngexp_qp);
				
				! storage losses
				QP_StorageLoss(tmon,storage) := StorageLosses(MonthInPeriod(tmon), storage);
				! distribution losses
				!**********Add Canada and Mexico later **************
				QP_DistributionLoss(tmon,l48) := DistributionLosses(MonthInPeriod(tmon), l48) ;
				!intrastate pipefuel loss
				QP_IntrastatePipeFuelLoss(tmon,l48) := IntrastatePipeFuelLosses(MonthInPeriod(tmon), l48) ;
				
				!plant fuel
				QP_PlantFuel(tmon,l48) := PlantFuel(MonthInPeriod(tmon), l48) ;
				
				!Assign supply curve parameters for fixed and variable supply
				Parameter_SupCrv(fixsup,step, n)  := Parameter_SupCrv(Supply_AD,step, n);
				Parameter_SupElasticity(fixsup,step, n)  := Parameter_SupElasticity(Supply_AD,step, n);
				Parameter_PrcElasticity(fixsup,step, n)  := Parameter_PrcElasticity(Supply_AD,step, n);
				Parameter_SupCrv(varsup,step, n)  := Parameter_SupCrv(Supply_NA,step, n);
				Parameter_SupElasticity(varsup,step, n)  := Parameter_SupElasticity(Supply_NA,step, n);
				Parameter_PrcElasticity(varsup,step, n)  := Parameter_PrcElasticity(Supply_NA,step, n);
			}
			Comment: "Transfer data for Planning Period into QP parameters";
		}
	}
	Section Storage_Section {
		DeclarationSection Storage_Declarations {
			Parameter StorageInjections {
				IndexDomain: (mon,reg);
			}
			Parameter StorageWithdrawals {
				IndexDomain: (mon,reg);
			}
			Parameter StorageScalingParameter {
				IndexDomain: storage;
			}
			Parameter AnnualStorageInjections {
				IndexDomain: (year,storage);
			}
			Parameter AnnualStorageWithdrawals {
				IndexDomain: (year,storage);
			}
			Parameter AverageStorageInjections {
				IndexDomain: (mn,storage);
			}
			Parameter AverageStorageWithdrawals {
				IndexDomain: (mn,storage);
			}
			Parameter AnnualAverageStorageInjections {
				IndexDomain: storage;
			}
			Parameter AnnualAverageStorageWithdrawals {
				IndexDomain: storage;
			}
			Parameter AnnualStorageNetWithdrawals {
				IndexDomain: year;
			}
			Parameter LastDataYearFlg_Storage {
				IndexDomain: year;
				Text: "flag to indicate that data exists for first model year";
				Range: binary;
			}
		}
		Procedure Storage_Run {
			Body: {
				! In the STEO years, a scaling factor for each month will be applied to align to the national STEO values
				
				!Assign monthly and annual storage levels in ModelYear
				
				if LastDataYearFlg_Storage(ModelYear) then
				   StorageInjections(modelyrmn, storage) := HistoricalStorageInjections(modelyrmn, storage);
				   StorageWithdrawals(modelyrmn, storage) := HistoricalStorageWithdrawals(modelyrmn, storage);
				
				else
					StorageInjections(modelyrmn,storage) :=  sum(mn | map_Month_MonthinYear(modelyrmn,mn), AverageStorageInjections(mn,storage)) ;
					StorageWithdrawals(modelyrmn,storage) :=  sum(mn | map_Month_MonthinYear(modelyrmn,mn), AverageStorageWithdrawals(mn,storage));
				
				endif;
			}
		}
		Procedure Storage_InitializeData {
			Body: {
				StorageInjections(datamon, storage) := HistoricalStorageInjections(datamon, storage);
				StorageWithdrawals(datamon, storage) := HistoricalStorageWithdrawals(datamon, storage);
				
				! Divide up TX regions based on share of storage capacity
				! Add year component?
				HistoricalStorageInjections(datamon, storage | storage in TXRegion_)  := HistoricalStorageInjections(datamon,TexasState) * TexasStorageShares(storage);
				HistoricalStorageWithdrawals(datamon, storage | storage in TXRegion_)  := HistoricalStorageWithdrawals(datamon,TexasState) * TexasStorageShares(storage);
				
				StorageInjections(datamon, storage | storage in TXRegion_)  := HistoricalStorageInjections(datamon,TexasState) * TexasStorageShares(storage);
				StorageWithdrawals(datamon, storage | storage in TXRegion_)  := HistoricalStorageWithdrawals(datamon,TexasState) * TexasStorageShares(storage);
				
				
				
				!Calculate annual historical storage levels
				AnnualStorageInjections(datayear, storage) := sum( datamon | map_month_year(datamon, datayear), StorageInjections(datamon,storage));
				AnnualStorageWithdrawals(datayear, storage) := sum( datamon | map_month_year(datamon, datayear), StorageWithdrawals(datamon,storage));
				!Determine last month for which EIA historical data exists and determine LastHistoricalDataYear by testing if LastHistoricalDataMonth is December
				LastHistoricalDataMonth := Last(datamon | Exists((storage)|HistoricalStorageInjections(datamon,storage)));
				if (MonthToYear(LastHistoricalDataMonth)=MonthToYear(LastHistoricalDataMonth-11)) then
					LastHistoricalDataYear := MonthToYear(LastHistoricalDataMonth);
				else
					LastHistoricalDataYear := MonthToYear(LastHistoricalDataMonth)-1;
				endif;
				!if LastHistoricalDataYear>=FirstModelYear then LastDataYearFlg_Storage(hdatayear):=1; endif;
				LastDataYearFlg_Storage(hdatayear):=1;
				! Calculate average storage withdrawals and injections for last NumberOfYearsForAverage_Storage_ (5) historical years
				
				AverageStorageInjections(mn,storage)  :=  sum((hdatamon,navgyr_storage) | map_Month_MonthinYear(hdatamon,mn) and hdatamon>=(last(ActualDataMonths_)-11),
				                                           StorageInjections(hdatamon-12*Val(navgyr_storage)+12, storage))/ Card(NumberOfYearsForAverage_Storage_);
				AverageStorageWithdrawals(mn,storage)  :=  sum((hdatamon,navgyr_storage) | map_Month_MonthinYear(hdatamon,mn) and hdatamon>=(last(ActualDataMonths_)-11),
				                                           StorageWithdrawals(hdatamon-12*Val(navgyr_storage)+12, storage))/ Card(NumberOfYearsForAverage_Storage_);
				
				! Calclulate annual averages
				AnnualAverageStorageInjections(storage) := sum(mn, AverageStorageInjections(mn,storage));
				AnnualAverageStorageWithdrawals(storage) := sum(mn, AverageStorageWithdrawals(mn,storage));
				
				! Storage needs to be scaled to insure that the net withdrawals over the year sum to zero for each state
				!Calculate the scaling parameter
				StorageScalingParameter(storage) :=  (AnnualAverageStorageInjections(storage) - AnnualAverageStorageWithdrawals( storage)) / $
				                                     (AnnualAverageStorageInjections(storage) + AnnualAverageStorageWithdrawals( storage));
				!Scale average storage numbers
				AverageStorageInjections(mn,storage) *=   (1 - StorageScalingParameter(storage));
				AverageStorageWithdrawals(mn,storage) *=   (1 + StorageScalingParameter(storage));
				! Calclulate annual averages
				AnnualAverageStorageInjections(storage) := sum(mn, AverageStorageInjections(mn,storage));
				AnnualAverageStorageWithdrawals(storage) := sum(mn, AverageStorageWithdrawals(mn,storage));
			}
			Comment: {
				"Set up average storage levels using historical data; scale to insure that the net withdrawals over the year sum to zero
				Similar scaling will be used for STEO scaling"
			}
		}
		Procedure Storage_PostProcess {
			Body: {
				!Calculate annual storage withdrawals and injections for report
				AnnualStorageInjections(ModelYear, storage) := sum( modelyrmn, StorageInjections(modelyrmn,storage));
				AnnualStorageWithdrawals(ModelYear, storage) := sum( modelyrmn, StorageWithdrawals(modelyrmn,storage));
				!Calculate annual net storage withdrawals for report
				AnnualStorageNetWithdrawals(ModelYear) := sum(l48, AnnualStorageWithdrawals(ModelYear, l48) - AnnualStorageInjections(ModelYear, l48));
			}
		}
	}
	Section Tariff_Section {
		Procedure Check_FlowsTariffs {
			Body: {
				for ((h,h1)|Exists(datayear|HistoricalCapacity(h,h1,datayear)) or Exists(year|PlannedCapacity(h,h1,year))) do
					if not Exists((pqtype,step)|VariableTariffCurve(h,h1,pqtype,step)) then
						VariableTariffCurve(h,h1,pqtype,step) := GenericTariffCurve(Tariff_Option2,pqtype,step);
					endif;
				endfor;
			}
		}
		Procedure Tariffs_Initialize {
			Body: {
				!HPTCrv_MaxStep := Element(Supply_Curve_Step_,3);
				HistoricalTariff((histyr, l48, h) | FlowsPrimary(histyr, l48, h)) := HistoricalAnnualSpotPrice(histyr, h) - HistoricalAnnualSpotPrice(histyr, l48)/ $
				         ((1-HisPipeFuelLossFactorIN(histyr,l48,h))*(1-HisPipeFuelLossFactorOUT(histyr,l48,h)));
				!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				! This is done for non l48 arcs !
				!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				!HTariffCurvePrc(histyr, h, h1, step) := VariableTariffCurve(h, h1, Ptype, step);
				!!Set tariff curves on secondary arcs equal to those on the primary arcs
				!HTariffCurvePrc((histyr, h, h1, step) | FlowsSecondary(histyr, h, h1)) := HTariffCurvePrc(histyr, h1, h, step);
				!Adjust tariffs
				Calculate_Hist_Tariff_Adj(histyr, h,h1,HistoricalTariff(histyr, h, h1),FlowsAnnual(histyr, h, h1));         
				!HistoricalCapacityUtil((histyr, l48, h) | CapacityAnnual(histyr, l48, h)):= FlowsAnnual(histyr, l48, h) / CapacityAnnual(histyr, l48, h);
				!
				!HTariffCurveUtil(histyr, l48, h, step) := VariableTariffCurve(l48, h, Qtype, step);
				!HTariffCurvePrc(histyr, h, h1, step) := VariableTariffCurve(h, h1, Ptype, step);
				!
				!BracketTarQty1((histyr, l48, h, step) | CapacityAnnual(histyr, l48, h) and HTariffCurveUtil(histyr, l48, h, step)<=HistoricalCapacityUtil(histyr, l48, h)):= HTariffCurveUtil(histyr, l48, h, step) ;
				!lstep( (histyr, l48, h) | CapacityAnnual(histyr, l48, h) ):=Argmax(step, BracketTarQty1(histyr, l48, h, step) );
				!BracketTarQty2((histyr, l48, h, step) | CapacityAnnual(histyr, l48, h) and HTariffCurveUtil(histyr, l48, h, step)<HistoricalCapacityUtil(histyr, l48, h)):= 2 ;
				!BracketTarQty2((histyr, l48, h, step) | CapacityAnnual(histyr, l48, h) and HTariffCurveUtil(histyr, l48, h, step)>=HistoricalCapacityUtil(histyr, l48, h)):= HTariffCurveUtil(histyr, l48, h, step) ;
				!ustep( (histyr, l48, h) | CapacityAnnual(histyr, l48, h) ):=Argmin(step, BracketTarQty2(histyr, l48, h, step) );
				!
				!HistoricalTariffAdj((histyr, l48, h) | FlowsPrimary(histyr, l48, h)):= HistoricalTariff(histyr, l48, h)- HTariffCurvePrc(histyr, l48, h, lstep(histyr, l48, h)) -
				!                     (HTariffCurvePrc(histyr, l48, h, ustep(histyr, l48, h))-HTariffCurvePrc(histyr, l48, h, lstep(histyr, l48, h)))*
				!                     (HistoricalCapacityUtil(histyr, l48, h)-HTariffCurveUtil(histyr, l48, h, lstep(histyr, l48, h)) )/$
				!                     (HTariffCurveUtil(histyr, l48, h, ustep(histyr, l48, h))-HTariffCurveUtil(histyr, l48, h, lstep(histyr, l48, h)) );
				!
				!!Adjust tariffs on the primary arcs
				!HTariffCurvePrc( (histyr, l48, h, step) | FlowsPrimary(histyr, l48, h) and step<=HPTCrv_MaxStep+1) := VariableTariffCurve(l48, h, Ptype, step) +HistoricalTariffAdj(histyr, l48, h) ;
				!!Set tariff curves on secondary arcs equal to those on the primary arcs
				!HTariffCurvePrc((histyr, h, h1, step) | FlowsSecondary(histyr, h, h1)) := HTariffCurvePrc(histyr, h1, h, step);
				!
			}
			Comment: "Q: how to identify which arcs are primary and which secondary? based on the flow/capacity magnitude?";
			Parameter BracketTarQty1 {
				IndexDomain: (datayear,reg,reg1,step);
			}
			Parameter BracketTarQty2 {
				IndexDomain: (datayear,reg,reg1,step);
			}
			ElementParameter lstep {
				IndexDomain: (datayear,reg,reg1);
				Range: Supply_Curve_Step_;
			}
			ElementParameter ustep {
				IndexDomain: (datayear,reg,reg1);
				Range: Supply_Curve_Step_;
			}
		}
		Procedure Calculate_Hist_Tariff_Adj {
			Arguments: (Y_,R_,R1_,Tar,Flo);
			Body: {
				!HistoricalCapacityUtil((yyy, r, r1) | CapacityAnnual(yyy, r, r1)):= FlowsAnnual(yyy, r, r1) / CapacityAnnual(yyy, r, r1);
				HistoricalCapacityUtil((yyy, r, r1) | CapacityAnnual(yyy, r, r1)):= Flo(yyy, r, r1) / CapacityAnnual(yyy, r, r1);
				
				HTariffCurveUtil(yyy, r, r1, step) := VariableTariffCurve(r, r1, Qtype, step);
				HTariffCurvePrc(yyy, r, r1, step) := VariableTariffCurve(r, r1, Ptype, step);
				
				BracketTarQty1((yyy, r, r1, step) | CapacityAnnual(yyy, r, r1) and HTariffCurveUtil(yyy, r, r1, step)<=HistoricalCapacityUtil(yyy, r, r1)):= HTariffCurveUtil(yyy, r, r1, step) ;
				lstep( (yyy, r, r1) | CapacityAnnual(yyy, r, r1) ):=Argmax(step, BracketTarQty1(yyy, r, r1, step) );
				BracketTarQty2((yyy, r, r1, step) | CapacityAnnual(yyy, r, r1) and HTariffCurveUtil(yyy, r, r1, step)<HistoricalCapacityUtil(yyy, r, r1)):= 2 ;
				BracketTarQty2((yyy, r, r1, step) | CapacityAnnual(yyy, r, r1) and HTariffCurveUtil(yyy, r, r1, step)>=HistoricalCapacityUtil(yyy, r, r1)):= HTariffCurveUtil(yyy, r, r1, step) ;
				ustep( (yyy, r, r1) | CapacityAnnual(yyy, r, r1) ):=Argmin(step, BracketTarQty2(yyy, r, r1, step) );
				
				!HistoricalTariffAdj((yyy, r, r1) | FlowsPrimary(yyy, r, r1)):= HistoricalTariff(yyy, r, r1)- HTariffCurvePrc(yyy, r, r1, lstep(yyy, r, r1)) -
				HistoricalTariffAdj((yyy, r, r1) | FlowsPrimary(yyy, r, r1)):= Tar(yyy, r, r1) - HTariffCurvePrc(yyy, r, r1, lstep(yyy, r, r1)) -
				                     (HTariffCurvePrc(yyy, r, r1, ustep(yyy, r, r1))-HTariffCurvePrc(yyy, r, r1, lstep(yyy, r, r1)))*
				                     (HistoricalCapacityUtil(yyy, r, r1)-HTariffCurveUtil(yyy, r, r1, lstep(yyy, r, r1)) )/$
				                     (HTariffCurveUtil(yyy, r, r1, ustep(yyy, r, r1))-HTariffCurveUtil(yyy, r, r1, lstep(yyy, r, r1)) );
				
				!Adjust tariffs on the primary arcs
				HTariffCurvePrc( (yyy, r, r1, step) | FlowsPrimary(yyy, r, r1) and step<=HPTCrv_MaxStep+1) := VariableTariffCurve(r, r1, Ptype, step) +HistoricalTariffAdj(yyy, r, r1) ;
				!Set tariff curves on secondary arcs equal to those on teh primary arcs
				HTariffCurvePrc((yyy, r, r1, step) | FlowsSecondary(yyy, r, r1)) := HTariffCurvePrc(yyy, r1, r, step);
			}
			Parameter BracketTarQty1 {
				IndexDomain: (datayear,reg,reg1,step);
			}
			Parameter BracketTarQty2 {
				IndexDomain: (datayear,reg,reg1,step);
			}
			ElementParameter lstep {
				IndexDomain: (datayear,reg,reg1);
				Range: Supply_Curve_Step_;
			}
			ElementParameter ustep {
				IndexDomain: (datayear,reg,reg1);
				Range: Supply_Curve_Step_;
			}
			Set Y_ {
				SubsetOf: HistoricalDataYears_;
				Index: yyy;
				Property: Input;
			}
			Set R_ {
				SubsetOf: Regions_;
				Index: r;
				Property: Input;
			}
			Set R1_ {
				SubsetOf: Regions_;
				Index: r1;
				Property: Input;
			}
			Parameter Tar {
				IndexDomain: (yyy,r,r1);
				Range: free;
				Property: Input;
			}
			Parameter Flo {
				IndexDomain: (yyy, r, r1);
				Property: Input;
			}
		}
		DeclarationSection Tariff_Declarations {
			Set pqtype_ {
				Index: pqtype;
				Definition: data{q,p};
			}
			ElementParameter Ptype {
				Range: pqtype_;
				Definition: 'p';
			}
			ElementParameter Qtype {
				Range: pqtype_;
				Definition: 'q';
			}
			ElementParameter TariffYearDollar {
				Range: Years_;
			}
			Parameter VariableTariffCurve {
				IndexDomain: (qph,qph1,pqtype,step);
			}
			Set GenericTariffCurveOption_ {
				SubsetOf: Integers;
				Index: opt_tc;
				Definition: {
					{1..3}
				}
			}
			ElementParameter Tariff_Option1 {
				Text: "Option 1";
				Range: GenericTariffCurveOption_;
				Definition: first(opt_tc);
				Comment: "Minimal price runup as flow hits maximum capacity";
			}
			ElementParameter Tariff_Option2 {
				Text: "Option 2";
				Range: GenericTariffCurveOption_;
				Definition: element(GenericTariffCurveOption_,2);
				Comment: "Medium price run up as flow reaches maximum capacity";
			}
			ElementParameter Tariff_Option3 {
				Text: "Option 3";
				Range: GenericTariffCurveOption_;
				Definition: element(GenericTariffCurveOption_,3);
				Comment: "Very high price runup as flow hits capacity";
			}
			Parameter GenericTariffCurve {
				IndexDomain: (opt_tc,pqtype,step);
			}
		}
	}
	Section Error_Handling {
		Procedure NGMM_Error_Handler {
			Arguments: (err);
			Body: {
				if AIMMS_Standalone_Switch=0 then
				        put "error trapped, invoked externally, error was " + errh::message(err);
					SaveAll( FormatString("ngtdm%e_%i", ModelYear,ncntrl_curitr(1)));
					if errh::Code(err)='NegativeRHS' or errh::Code(err)='NoVarTarCurve' or errh::Code(err)='SteoConvergence' then
						errh::Adapt(err,message:errh::Message(err) );
					endif;
				else
					if errh::Code(err)='NegativeRHS' or errh::Code(err)='NoVarTarCurve' or errh::Code(err)='SteoConvergence' then
						errh::Adapt(err,message:errh::Message(err) );
						DialogMessage(errh::Message(err));
						errh::MarkAsHandled(err);
					elseif errh::Code(err)='CapFloCHK' then
						DialogMessage(errh::Message(err));
						errh::MarkAsHandled(err);
					endif;
				endif;
				err_code:=errh::Code(err);
				err_filename:=errh::Filename(err);
				err_node:=Formatstring("%e",errh::Node(err));
				err_attribute:=Formatstring("%e", errh::Attribute(err));
				if errh::Filename(err)="data\PipelineCapacityByArc.txt" and errh::Code(err)='DOM_DOUBLETUP' then
				
				endif;
			}
			ElementParameter err {
				Range: errh::PendingErrors;
				Property: Input;
			}
		}
		Procedure ForceError {
			Body: {
				Xpar:=1/0;
			}
			Parameter Xpar;
		}
		Procedure Check_FlowsAndCapacities {
			Body: {
				NoFlowFlg((histyr,h,h1) | histyr>= FirstHQPYear and CapacityAnnual(histyr, h, h1) and FlowsAnnual(histyr, h, h1)<=0.0001):=1;
				NoCapacityFlg((histyr,h,h1) | histyr>= FirstHQPYear and FlowsAnnual(histyr, h, h1) and CapacityAnnual(histyr, h, h1)<=0):=1;
				FlowGTCapacityFlg((histyr,h,h1) | histyr>= FirstHQPYear and (FlowsAnnual(histyr, h, h1)-CapacityAnnual(histyr, h, h1))>0.0001):=1;
				FlowsAnnual((histyr, h, h1) | FlowGTCapacityFlg(histyr,h,h1) ):=CapacityAnnual(histyr, h, h1);
				!if sum((histyr, h, h1), NoFlowFlg(histyr,h,h1)) then
				!   write NoFlowFlg((histyr,h,h1) | NoFlowFlg(histyr,h,h1)) to file "NGATTENTION.txt" in merge mode;
				!   RAISE WARNING " Historical flow data are missing; See NGATTENTION.txt for details." CODE 'CapFloCHK';
				!endif;
				if sum((histyr, h, h1), NoCapacityFlg(histyr,h,h1)) then
				   write NoCapacityFlg((histyr,h,h1) | NoCapacityFlg(histyr,h,h1)) to file "NGATTENTION.txt" in merge mode;
				   RAISE WARNING " Historical capacity is missing; See NGATTENTION.txt for details." CODE 'CapFloCHK';
				endif;
				if sum((histyr, h, h1), FlowGTCapacityFlg(histyr,h,h1)) then
				   write FlowGTCapacityFlg((histyr,h,h1) | FlowGTCapacityFlg(histyr,h,h1)) to file "NGATTENTION.txt" in merge mode;
				   RAISE WARNING " Historical flow is greater than capacity and has been adjusted; See NGATTENTION.txt for details." CODE 'CapFloCHK';
				endif;
			}
		}
		ElementParameter err1 {
			Range: errh::PendingErrors;
		}
		Parameter NoFlowFlg {
			IndexDomain: (histyr,h,h1);
		}
		Parameter NoCapacityFlg {
			IndexDomain: (histyr,h,h1);
		}
		Parameter FlowGTCapacityFlg {
			IndexDomain: (histyr,h,h1);
		}
		ElementParameter err_code {
			Range: errh::ErrorCodes;
		}
		StringParameter err_attribute;
		StringParameter err_filename;
		StringParameter err_node;
	}
	Section Rolling_Horizon_Procedures {
		Section Single_Step_Procedures {
			Procedure LinkHorizonToCalendar {
				Body: {
					
					CreateTimeTable(
					         TimeTable         : MonthInPeriod,
					         CurrentTimeSlot   : FirstMonthInPlanningInterval,
					         CurrentPeriod     : FirstPeriodInPlanningInterval,
					         PeriodLength      : NumberOfMonthsInPeriod,
					         LengthDominates   : LengthDominatesNotActive,
					         InactiveTimeSlots : InactiveMonths,
					         DelimiterSlots    : Months_ );
					
					
					YearInPeriod(tmon) := MonthToYear(MonthInPeriod(tmon));
				}
			}
			Procedure LinkHorizonToCalendarForCapExp {
				Body: {
					
					CreateTimeTable(
					         TimeTable         : CapExpMonthInPeriod,
					         CurrentTimeSlot   : FirstMonthInPlanningInterval,
					         CurrentPeriod     : CapExpFirstPeriodInPlanningInterval,
					         PeriodLength      : CapExpNumberOfMonthsInPeriod,
					         LengthDominates   : CapExpLengthDominatesNotActive,
					         InactiveTimeSlots : InactiveMonthsCapExp,
					         DelimiterSlots    : Months_ );
					
					
					CapExpYearInPeriod(tcapexp) := MonthToYear(CapExpMonthInPeriod(tcapexp));
				}
			}
			Procedure LinkHistHorizonToCalendar {
				Body: {
					
					CreateTimeTable(
					         TimeTable         : MonthInHistPeriod,
					         CurrentTimeSlot   : FirstMonthInHistPlanningInterval,
					         CurrentPeriod     : FirstPeriodInHistPlanningInterval,
					         PeriodLength      : NumberOfMonthsInHistPeriod,
					         LengthDominates   : HistLengthDominatesNotActive,
					         InactiveTimeSlots : InactiveMonths,
					         DelimiterSlots    : Months_ );
					
					
					YearInHistPeriod(htmon) := MonthToYear(MonthInHistPeriod(htmon));
				}
			}
			Procedure QPStatusNotOptimal {
				Body: {
					!Display error message when QP is not optimal during standalone execution
					QPErrorString := FormatString("Mathematical program is not optimal in year %e", ModelYear);
					halt with QPErrorString
					when (MaxConsumerProducerSurplus.ProgramStatus <> 'Optimal');
				}
			}
			Procedure CapExpQPStatusNotOptimal {
				Body: {
					!Display error message when QP is not optimal during standalone execution
					QPErrorString := FormatString("Mathematical program is not optimal in year %e", ModelYear);
					halt with QPErrorString
					when (CapacityExpansionQP.ProgramStatus <> 'Optimal');
				}
			}
			Procedure SolveTestQP {
				Body: {
					solve TestQP;
					halt with "Mathematical program is not optimal"
					when (TestQP.ProgramStatus <> 'Optimal');
				}
			}
			Procedure PrepareDataForNextRoll {
				Body: {
					FirstPeriodInPlanningInterval += 12;
					!FirstMonthInPlanningInterval := First(ModelYearMonths_);
					FirstPeriodInYear := FirstPeriodInPlanningInterval;
					PeriodsInYear(ModelYear+1) := {FirstPeriodInYear..FirstPeriodInYear+11};
					
					CapExpFirstPeriodInPlanningInterval += 2;
				}
			}
			Procedure RollToNextYear {
				Body: {
					ModelYear += 1;
				}
			}
			Procedure QP_Run {
				Body: {
					return when ModelYear<=LastSTEOYear and SteoConvergenceFlag;
					TransferDataIntoQPparameters; !Transfer from main array to QP array
					CurveDefinitions;  !Define supply curves, variable pipeline tariff curve, LNG export curves
					
					!Run QP to solve for optimum natural gas transmission and distribution :)
					!Solve the Quadratic Program
					
					solve MaxConsumerProducerSurplus in merge mode;
					QPStatusNotOptimal;
				}
			}
			Procedure CapacityExpansion_Run {
				Body: {
					!TransferDataIntoQPparameters; !Transfer from main array to QP array
					!DefineParametersForCapExp; !Define parameters that are different from the regular QP
					!CurveDefinitions;  !Define supply curves, variable pipeline tariff curve, LNG export curves
					
					!Run QP to solve for optimum natural gas transmission and distribution :)
					!Solve the Quadratic Program
					!solve MaxConsumerProducerSurplus in merge mode;
					!QPStatusNotOptimal;
					
					!DetermineCapacityAdditions; !Extract Capacity Additions from the QP solution
				}
				Comment: "This is to be used if running capacity expansion for 12 months";
			}
			Procedure STEOQP_Run {
				Body: {
					TransferDataIntoQPparameters; !Transfer from main array to QP array
					CurveDefinitions;  !Define supply curves, variable pipeline tariff curve, LNG export curves
					
					!Run QP to solve for optimum natural gas transmission and distribution :)
					solve STEOQP in merge mode; !Solve the Quadratic Program
					!Display error message when QP is not optimal during standalone execution
					QPErrorString := FormatString("STEO Mathematical program is not optimal in year %e", ModelYear);
					if AIMMS_Standalone_Switch then
					halt with QPErrorString
					when (STEOQP.ProgramStatus <> 'Optimal');
					endif;
				}
			}
		}
		Section Rolling_Procedures {
			Procedure RunOneYear {
				Body: {
					if ModelYear = FirstModelYear then
					       ! LoadData("restart_initial");
					       InitializeStandalone;
					       FirstYearInitialization;
					endif;
					
					NGMM;
					RollToNextYear;
				}
			}
			Procedure RunHistoricalYearsOnly {
				Body: {
					empty Cleared_Identifiers_;
					LoadData("restart_initial");
					Read_Runtime_Parameters;
					AIMMS_Standalone_Switch :=1;
					InitializeFirstModelYear;
					FirstYearInitialization;
				}
			}
		}
		Section Rolling_Horizon_Initialization_Procedures {
			Procedure InitializeLengthOfPlanningInterval {
				Body: {
					NumberOfPeriods :=(LastModelYear-LastHistoricalYear)*12;
					NumberOfPeriodsInPlanningInterval := 12;
					CapExpNumberOfPeriods :=(LastModelYear-LastHistoricalYear)*2;
					CapExpNumberOfPeriodsInPlanningInterval := 2;
					NumberOfHistoricalPeriods :=(LastHQPYear-FirstHQPYear)*12;
					NumberOfHistoricalPeriods +=12;
				}
			}
			Procedure InitializeFirstModelYear {
				Body: {
					ModelYear := FirstModelYear;
					HQPYear:=FirstHQPYear;
				}
				Comment: "Set ModelYear to FirstModelYear only for standalone runs";
			}
			Procedure MovePlanningIntervalToFirstModelYear {
				Body: {
					
					FirstPeriodInPlanningInterval := 'period-001';
					MonthInPeriod(tmon) := Element( Months_, Ord(tmon)+card(HistoricalYearMonths_)-12);
					YearInPeriod(tmon) := MonthToYear(MonthInPeriod(tmon));
					FirstPeriodInYear := FirstPeriodInPlanningInterval;
					PeriodsInYear(ModelYear) := {FirstPeriodInYear..FirstPeriodInYear+11};
					
					CapExpFirstPeriodInPlanningInterval := 'p-01';
					CapExpMonthInPeriod(tcapexp) := Element( Months_, Ord(tcapexp+card(HistoricalYearMonths_)-12));
					CapExpYearInPeriod(tcapexp) := MonthToYear(CapExpMonthInPeriod(tcapexp));
					
					FirstPeriodInHistPlanningInterval := 'period-01';
					MonthInHistPeriod(htmon):= Element( Months_, Ord(htmon)+Ord(FirstHQPYear)*12-12);
				}
			}
		}
		DeclarationSection Rolling_Horizon_Declarations {
			ElementParameter FirstMonthInPlanningInterval {
				Range: Months_;
				Property: NoSave;
				Definition: First(ModelYearMonths_);
			}
			Set MonthsInPlannigInterval {
				SubsetOf: Months_;
				Definition: union[tmon, MonthInPeriod(tmon)];
			}
			ElementParameter FirstYearInPlanningInterval {
				Range: Years_;
				Definition: MonthToYear(FirstMonthInPlanningInterval);
			}
			ElementParameter LastMonthInPlanningInterval {
				Range: Months_;
				Definition: last(MonthsInPlannigInterval);
			}
			Parameter LengthDominatesNotActive {
				IndexDomain: tmon;
			}
			Parameter CapExpLengthDominatesNotActive {
				IndexDomain: (tcapexp);
			}
			StringParameter QPErrorString;
		}
		DeclarationSection Rolling_Horizon_Declarations_for_History {
			ElementParameter FirstMonthInHistPlanningInterval {
				Range: Months_;
				Definition: First(HQPYearMonths_);
			}
			Set MonthsInHistPlannigInterval {
				SubsetOf: Months_;
				Definition: union[htmon, MonthInHistPeriod(htmon)];
			}
			Parameter HistLengthDominatesNotActive {
				IndexDomain: htmon;
			}
		}
	}
	Section Reports_Section {
		DeclarationSection Profiling {
			Set IterationNumber_ {
				Index: iteration;
			}
			Set CycleNumber_ {
				Index: cycle;
			}
			Parameter ResultsNEMS {
				IndexDomain: (year, cycle, iteration, IndexProcedures, line, IndexProfilerTypes);
			}
			Parameter Results {
				IndexDomain: (IndexProcedures,line,IndexProfilerTypes);
			}
			Set Lines_ {
				SubsetOf: Integers;
				Index: line;
			}
		}
		Procedure AddedCapacity_Report {
			Body: {
				CumulativeAddedCapacity(ModelYear, h, h1) := CapacityAnnual(ModelYear, h, h1) - CapacityAnnual((FirstModelYear-1), h, h1);
			}
		}
		DeclarationSection Identifier_Display_Declarations {
			ElementParameter DisplayedAddedCapacityEndYear {
				Range: Years_;
			}
			ElementParameter DisplayedAddedCapacityStartYear {
				Range: Years_;
			}
			ElementParameter DisplayedYear {
				Range: Years_;
			}
			ElementParameter PreviousYear {
				Range: Years_;
				Definition: ModelYear-1;
			}
			StringParameter PeriodDescription {
				IndexDomain: (tmon in MonthlyHorizon_);
				Definition: FormatString("%e",MonthInPeriod(tmon));
			}
			ElementParameter DisplayedRegion {
				Range: Hubs_;
			}
			ElementParameter DisplayedState {
				Range: L_48_;
			}
			ElementParameter DisplayedState50 {
				Range: States_;
			}
			ElementParameter DisplayedDemandRegion {
				Range: DemandNode_;
			}
			ElementParameter DisplayedSupplyRegion {
				Range: QPSupplyNode_;
			}
			ElementParameter DisplayedSupplyType {
				Range: SupplyType_;
			}
			ElementParameter DisplayedCensusRegion {
				Range: Region_Census_;
			}
			ElementParameter DisplayedSector {
				Range: Sector_;
			}
			ElementParameter DisplayedNNGEMMRegion {
				Range: NNGEMM_;
			}
			ElementParameter DisplayedMonthInYear {
				IndexDomain: mon;
				Range: MonthinYear_;
				Definition: TimeSlotCharacteristic(mon, 'month');
			}
			ElementParameter DisplayedMexicoRegion {
				Range: Mexico_;
			}
			Set DisplayedCensusStates {
				SubsetOf: States_;
				Index: show_cen;
				Definition: {
					{state|map_State_CensusRegion(state,DisplayedCensusRegion)}
				}
			}
			Set DisplayedNNGEMMStates {
				SubsetOf: States_;
				Index: show_emm;
				Definition: {
					{state| map_State_NNGEMM(state,DisplayedNNGEMMRegion)}
				}
			}
			ElementParameter DisplayedHubFrom {
				Range: QP_Hubs_;
			}
			ElementParameter DisplayedHubTo {
				Range: QP_Hubs_;
			}
			ElementParameter DisplayedBorderCrossing {
				Range: BorderCrossings_;
			}
			ElementParameter DisplayedBorderCrossing2 {
				Range: BorderCrossings_;
			}
			ElementParameter DisplayedOilGasRegionFrom {
				Range: Region_OilGas_;
			}
			ElementParameter DisplayedFlowRegionFrom {
				Range: Region_Flow_;
			}
			ElementParameter DisplayedOilGasRegionTo {
				Range: Region_OilGas_;
			}
			ElementParameter DisplayedFlowRegionTo {
				Range: Region_Flow_;
			}
			ElementParameter SelectedHubFrom {
				Range: SelectArcFrom_;
			}
			ElementParameter SelectedHubTo {
				Range: SelectArcTo_;
			}
			ElementParameter DisplayedHub {
				Range: Hubs_;
			}
			Set SelectArcFrom_ {
				SubsetOf: Regions_;
				Index: safrom;
			}
			Set SelectArcTo_ {
				SubsetOf: Regions_;
				Index: sato;
			}
			ElementParameter DisplayedTransFuel {
				Range: TransFuel_;
			}
			ElementParameter DisplayedVehicle {
				Range: VehicleType_;
			}
			ElementParameter PreviousDisplayedYear {
				Range: Years_;
				Definition: DisplayedYear-1;
			}
			Set DisplayedOilGasRegionsFrom {
				SubsetOf: Region_OilGas_;
				Index: show_r_og_from;
				Definition: {
					{r_og|Exists(year|FlowsRegional(year,r_og,DisplayedOilGasRegionTo))}
				}
			}
			Set DisplayedFlowRegionsFrom {
				SubsetOf: Region_Flow_;
				Definition: {
					{r_flow|Exists(year|FlowRegional(year,r_flow,DisplayedFlowRegionTo))}
				}
			}
			Set DisplayedOilGasRegionsTo {
				SubsetOf: Region_OilGas_;
				Index: show_r_og_to;
				Definition: {
					{r_og1|Exists(year|FlowsRegional(year,DisplayedOilGasRegionFrom,r_og1))}
				}
			}
			Set DisplayedFlowRegionsTo {
				SubsetOf: Region_Flow_;
				Definition: {
					{r_flow1|Exists(year|FlowRegional(year,DisplayedFlowRegionFrom,r_flow1))}
				}
			}
			ElementParameter DisplayedLNGRegion {
				Range: PossibleLNGTerminals_;
			}
		}
		Section EMM_Analysis {
			Procedure Initialize_EMM {
				Body: {
					read from file "data\\EMM_NGMM_Report.txt";
					
					Transfer_NEMS_Data;
				}
			}
			Procedure Transfer_NEMS_Data {
				Body: {
					NetGeneration(year,MNUMNR,GenType_Coal) := UDATOUT_UGENPC(MNUMNR,NEMSmap_MNUMYR(year)) + UDATOUT_UGENSQ(MNUMNR,NEMSmap_MNUMYR(year)) 
						+ UDATOUT_UGENIG(MNUMNR,NEMSmap_MNUMYR(year))  + UDATOUT_UGENIS(MNUMNR,NEMSmap_MNUMYR(year));
					
					NetGeneration(year,MNUMNR,GenType_NatGas) := UDATOUT_UGENCC(MNUMNR,NEMSmap_MNUMYR(year)) + UDATOUT_UGENAC(MNUMNR,NEMSmap_MNUMYR(year)) 
						+ UDATOUT_UGENCS(MNUMNR,NEMSmap_MNUMYR(year))  + UDATOUT_UGENCT(MNUMNR,NEMSmap_MNUMYR(year)) + UDATOUT_UGENAT(MNUMNR,NEMSmap_MNUMYR(year));
					
					NetGeneration(year,MNUMNR,GenType_Oil) := UDATOUT_UGENOS(MNUMNR,NEMSmap_MNUMYR(year));
					
					NetGeneration(year,MNUMNR,GenType_Nuclear) := UDATOUT_UGENNU(MNUMNR,NEMSmap_MNUMYR(year));
					
					NetGeneration(year,MNUMNR,GenType_Renew) := UDATOUT_UGENRN(MNUMNR,NEMSmap_MNUMYR(year));
				}
			}
			DeclarationSection EMM_Declarations {
				Set GenerationTypes_ {
					Index: gen;
				}
				Set DisplayedEMMYears_ {
					SubsetOf: Years_;
					Index: yr_xaxis;
					Definition: {
						{year|year>=DisplayedEMMStartYear}
					}
				}
				ElementParameter DisplayedGenerationType {
					Range: GenerationTypes_;
				}
				ElementParameter DisplayedNERCRegion {
					Range: MNUMNR_;
				}
				ElementParameter DisplayedNERCName {
					Range: NERC_name_;
					Definition: first(NERC_name|map_MNUMNR_NERCname_New(DisplayedNERCRegion,NERC_name));
				}
				ElementParameter DisplayedNERCNameOld {
					Range: NERC_Old_;
					Definition: first(NERC_old|map_MNUMNR_NERCname_Old(DisplayedNERCRegion,NERC_old));
				}
				ElementParameter DisplayedEMMStartYear {
					Range: Years_;
				}
				ElementParameter GenType_Coal {
					Range: GenerationTypes_;
				}
				ElementParameter GenType_NatGas {
					Range: GenerationTypes_;
				}
				ElementParameter GenType_Nuclear {
					Range: GenerationTypes_;
				}
				ElementParameter GenType_Renew {
					Range: GenerationTypes_;
				}
				ElementParameter GenType_Oil {
					Range: GenerationTypes_;
				}
				ElementParameter Copy3_GenType_Coal {
					Range: GenerationTypes_;
				}
				Parameter NetGeneration {
					IndexDomain: (year,MNUMNR,gen);
				}
				Parameter map_MNUMNR_NNGEMM {
					IndexDomain: (MNUMNR, NNGEMM);
					Range: binary;
				}
				Set NERC_name_ {
					Index: NERC_name;
				}
				Set NERC_Old_ {
					Index: nerc_old;
				}
				Parameter map_MNUMNR_NERCname_Old {
					IndexDomain: (MNUMNR,NERC_old);
					Range: binary;
				}
				Parameter map_MNUMNR_NERCname_New {
					IndexDomain: (MNUMNR,NERC_name);
					Range: binary;
				}
			}
		}
		Procedure SelectRegionOnMap {
			Arguments: (SelectedRegion);
			Body: {
				DisplayedHub:=SelectedRegion;
			}
			ElementParameter SelectedRegion {
				Range: Regions_;
				Property: Input;
			}
		}
		Procedure SelectArcOnMap {
			Arguments: (SelectRegFrom,SelectRegTo);
			Body: {
				SelectArcFrom_+= SelectRegFrom;
				SelectArcTo_+= SelectRegTo;
				FlowsMonthlyDebug(mon, SelectRegFrom,SelectRegTo):= FlowsMonthly(mon, SelectRegFrom,SelectRegTo);
				CapacityMonthlyDebug(mon, SelectRegFrom,SelectRegTo):= PipeCapacity(mon, SelectRegFrom,SelectRegTo);
				TariffMonthlyDebug(mon, SelectRegFrom,SelectRegTo):= Tariff_Soln(mon, SelectRegFrom,SelectRegTo);
				FlowColor1(year, SelectRegFrom,SelectRegTo) := 'Red';
				
				FlowsAnnualDebug(year, SelectRegFrom,SelectRegTo):= FlowsAnnual(year, SelectRegFrom,SelectRegTo);
				CapacityAnnualDebug(year, SelectRegFrom,SelectRegTo):= CapacityAnnual(year, SelectRegFrom,SelectRegTo);
				TariffAnnualDebug(year, SelectRegFrom,SelectRegTo):= TariffAnnual(year, SelectRegFrom,SelectRegTo);
			}
			ElementParameter SelectRegFrom {
				Range: Hubs_;
				Property: Input;
			}
			ElementParameter SelectRegTo {
				Range: Hubs_;
				Property: Input;
			}
		}
		Procedure SelectArcOnMapAnnual {
			Arguments: (SelectRegFrom,SelectRegTo);
			Body: {
				
				FlowsAnnualDebug(year, SelectRegFrom,SelectRegTo):= FlowsAnnual(year, SelectRegFrom,SelectRegTo);
				CapacityAnnualDebug(year, SelectRegFrom,SelectRegTo):= CapacityAnnual(year, SelectRegFrom,SelectRegTo);
				TariffAnnualDebug(year, SelectRegFrom,SelectRegTo):= TariffAnnual(year, SelectRegFrom,SelectRegTo);
				FlowColor1(year, SelectRegFrom,SelectRegTo) := 'Red';
			}
			ElementParameter SelectRegFrom {
				Range: Hubs_;
				Property: Input;
			}
			ElementParameter SelectRegTo {
				Range: Hubs_;
				Property: Input;
			}
		}
		Procedure DeselectAllArcsOnMap {
			Body: {
				empty SelectArcFrom_, SelectArcTo_;
				empty FlowsMonthlyDebug, CapacityMonthlyDebug, TariffMonthlyDebug;
				FlowColor1(year, h, h1) := 'Black';
				empty FlowsAnnualDebug, CapacityAnnualDebug, TariffAnnualDebug ;
			}
		}
		DeclarationSection Flow_Reports_Declaration {
			Parameter FlowBinding {
				IndexDomain: (year,h,h1);
			}
			Set DisplayXYears_ {
				SubsetOf: XYears_;
				Index: xyr_show;
				Definition: {
					{'2000'..'2020'}
				}
			}
			Set DisplayYears_ {
				SubsetOf: Years_;
				Index: yr_show;
				Definition: {
					{'2000'..'2020'}
				}
			}
			Parameter ImportsAnnual {
				IndexDomain: (year,l48);
			}
			Parameter ExportsAnnual {
				IndexDomain: (year,l48);
			}
			Parameter Longitude_center {
				IndexDomain: reg;
			}
			Parameter Latitude_center {
				IndexDomain: reg;
			}
			Parameter FlowDifference {
				IndexDomain: (year,h,h1);
			}
			Parameter FlowDifference2015 {
				IndexDomain: (h,h1);
			}
			ElementParameter FlowColor {
				IndexDomain: (year,h,h1);
				Range: AllColors;
			}
			ElementParameter FlowColor2 {
				IndexDomain: (h,h1);
				Range: AllColors;
			}
			ElementParameter FlowColor1 {
				IndexDomain: (year,h,h1);
				Range: AllColors;
			}
			ElementParameter BindingFlowColor {
				IndexDomain: (year,h,h1);
				Range: AllColors;
			}
			ElementParameter CapacityColor {
				IndexDomain: (year,h,h1);
				Range: AllColors;
			}
			Parameter FlowColorThreshold {
				InitialData: {
					50 ;
				}
			}
			Parameter NodeFlowInMonthly {
				IndexDomain: (mon,h);
			}
			Parameter NodeFlowOutMonthly {
				IndexDomain: (mon,h);
			}
			Parameter NodeFlowInAnnual {
				IndexDomain: (year,h);
			}
			Parameter NodeFlowOutAnnual {
				IndexDomain: (year,h);
			}
			Parameter NetDemand {
				IndexDomain: (mon,h);
			}
			Parameter NetDemandAnnual {
				IndexDomain: (year,h);
			}
			Parameter FlowsMonthlyDebug {
				IndexDomain: (mon,h,h1);
			}
			Parameter CapacityMonthlyDebug {
				IndexDomain: (mon,h,h1);
			}
			Parameter TariffMonthlyDebug {
				IndexDomain: (mon,h,h1);
			}
			Parameter FlowsAnnualDebug {
				IndexDomain: (year,h,h1);
			}
			Parameter CapacityAnnualDebug {
				IndexDomain: (year,h,h1);
			}
			Parameter TariffAnnualDebug {
				IndexDomain: (year,h,h1);
			}
		}
		DeclarationSection LNG_Exports_Reports_Declaration {
			Parameter AnnualLNGExportForReports {
				IndexDomain: (year,lngexp_qp);
				Text: "Annual LNG exports from QP";
			}
			Parameter LNGExportForReports {
				IndexDomain: (mon,reg);
				Text: "Monthly LNG exports from QP";
			}
		}
		DeclarationSection Production_Reports_Declaration {
			Parameter MonthlyProductionForReport {
				IndexDomain: (mon,suptype,reg);
				Text: "Monthly Production by type and region";
			}
			Parameter TotalExpectedProductionMonthly {
				IndexDomain: (mon,reg);
			}
			Parameter TotalExpectedProductionAnnual {
				IndexDomain: (year,reg);
			}
			Parameter MinimumProductionAnnual {
				IndexDomain: (year,suptype,reg);
			}
			Parameter MinimumProductionMonthly {
				IndexDomain: (mon,suptype,reg);
			}
			Parameter MaximumProductionAnnual {
				IndexDomain: (year,suptype,reg);
			}
			Parameter MaximumProductionMonthly {
				IndexDomain: (mon,suptype,reg);
			}
		}
		DeclarationSection Totals_Declarations {
			Parameter TotalUSProductionAnnual {
				IndexDomain: year;
			}
			Parameter TotalUSStorageWthAnnual {
				IndexDomain: year;
			}
			Parameter TotalUSStorageInjAnnual {
				IndexDomain: year;
			}
			Parameter TotalUSLNGexports {
				IndexDomain: year;
			}
			Parameter TotalUSSupplyAnnual {
				IndexDomain: year;
			}
			Parameter TotalExpectedUSSupplyAnnual {
				IndexDomain: year;
			}
			Parameter TotalUSDemandAnnual {
				IndexDomain: year;
			}
			Parameter TotalUSConsumptionAnnual {
				IndexDomain: year;
			}
			Parameter TotalImportsAnnual {
				IndexDomain: year;
			}
			Parameter TotalExportsAnnual {
				IndexDomain: year;
			}
			Parameter TotalModelDemand {
				IndexDomain: year;
			}
			Parameter TotalModelSupply {
				IndexDomain: year;
			}
			Parameter TotalLNGExportsAnnual {
				IndexDomain: year;
			}
			Parameter TotalBalanceItemAnnual {
				IndexDomain: year;
			}
			Parameter TotalSupplementalAnnual {
				IndexDomain: year;
			}
			Parameter TotalLNGImportsAnnual {
				IndexDomain: year;
			}
			Parameter TotalLeaseFuelAnnual {
				IndexDomain: year;
			}
			Parameter TotalTranFuelAnnual {
				IndexDomain: year;
			}
			Parameter HenryHubPrice {
				IndexDomain: year;
			}
		}
		DeclarationSection WHPrice_Declaration {
			Parameter WHPrcSoln_monthly {
				IndexDomain: (mon,s);
			}
			Parameter WHPrcSoln_annual {
				IndexDomain: (year,s);
			}
			Parameter WHPrcCalc_monthly {
				IndexDomain: (mon,s);
			}
			Parameter WHPrcCalc_annual {
				IndexDomain: (year,s);
			}
			Parameter Stepnumber {
				IndexDomain: (mon,s);
			}
			ElementParameter MaxStepsln {
				IndexDomain: (mon,s);
				Range: Supply_Curve_Step_;
			}
			Parameter Pnode {
				IndexDomain: (year,s);
			}
			Parameter Qnode {
				IndexDomain: (year,s);
			}
		}
		DeclarationSection Tariff_Debug_Declarations {
			Parameter Tariff_Calc {
				IndexDomain: (mon,h,h1);
			}
			Parameter Tariff_Soln {
				IndexDomain: (mon,h,h1);
			}
			Parameter Tariff_SolnAlt {
				IndexDomain: (mon,h,h1,step);
			}
			Parameter TariffStep_Calc {
				IndexDomain: (tmon,qph,qph1,step);
			}
			Parameter ArcPrice_Soln {
				IndexDomain: (mon,h,h1);
			}
			Parameter NodePrice_Soln {
				IndexDomain: (mon,h);
			}
			Parameter NodePriceAnnual {
				IndexDomain: (year,h);
			}
			Parameter TariffStepnumber {
				IndexDomain: (mon,h,h1);
			}
			ElementParameter TariffMaxStepSln {
				IndexDomain: (mon,h,h1);
				Range: Supply_Curve_Step_;
			}
			Parameter TariffAnnual {
				IndexDomain: (year,h,h1);
			}
			Parameter DebugTariffOBJYr {
				IndexDomain: year;
			}
			Parameter DebugTariffOBJMn {
				IndexDomain: mon;
			}
			Parameter DebugTariffOBJ {
				IndexDomain: (mon,h,h1);
			}
			Parameter DebugTariffOBJstep {
				IndexDomain: (mon,h,h1,step);
			}
			Parameter DebugSlackYr {
				IndexDomain: year;
			}
			Parameter NoVarTariffCurveFlg {
				IndexDomain: (mon,h,h1,step);
			}
			Parameter SpotPrc_Diff {
				IndexDomain: (year,reg);
			}
			Parameter LastDataYearFlg_SpotPrc {
				IndexDomain: year;
				Text: "flag to indicate that data exists for model years";
				Range: binary;
			}
		}
		DeclarationSection Tariff_Curve_Analysis_Declarations {
			Set PossibleHubsTo {
				SubsetOf: QP_Hubs_;
				Index: show_h1;
				Definition: {
					{h1|CapacityAnnual(LastModelYear,DisplayedHubFrom,h1)}
				}
			}
			Set PossibleHubsFrom_ {
				SubsetOf: QP_Hubs_;
				Index: show_h;
				Definition: {
					{h|CapacityAnnual(LastModelYear,h,DisplayedHubTo)}
				}
			}
			ElementParameter DisplayedHubTo1 {
				Range: PossibleHubsTo;
			}
			ElementParameter DisplayedHubTo2 {
				Range: PossibleHubsTo;
			}
			ElementParameter DisplayedHubTo3 {
				Range: PossibleHubsTo;
			}
			ElementParameter DisplayedHubFrom1 {
				Range: PossibleHubsFrom_;
			}
			ElementParameter DisplayedHubFrom2 {
				Range: PossibleHubsFrom_;
			}
			ElementParameter DisplayedHubFrom3 {
				Range: PossibleHubsFrom_;
			}
			Parameter Displayed_Max_PriceTo {
				Definition: max((show_h1,step),Parameter_TariffCurvePrice(DisplayedHubFrom,show_h1,step));
			}
			Parameter Displayed_Max_PriceFrom {
				Definition: max((show_h,step),Parameter_TariffCurvePrice(show_h,DisplayedHubTo,step));
			}
		}
		DeclarationSection Capacity_and_Flow_Debugging {
			ElementParameter CapacityUtilizationColor {
				IndexDomain: (year,h,h1);
				Range: AllColors;
			}
			Parameter CapacityUtilization {
				IndexDomain: (year,h,h1);
			}
			ElementParameter DisplayedHubFromCapacity {
				Range: Hubs_;
			}
			StringParameter CapacityChartTitle {
				Definition: "Cumulative Added Capacity from " + DisplayedHubFromCapacity + " since " + (FirstModelYear-1);
			}
			Set PossibleHubsToCapacity {
				SubsetOf: Hubs_;
				Definition: {
					{h1|CapacityAnnual(LastModelYear,DisplayedHubFromCapacity,h1)}
				}
			}
			Parameter CumulativeAddedCapacity {
				IndexDomain: (year, h, h1);
			}
			Parameter Diff_Capacity_EIA_Old {
				IndexDomain: (datayear,h,h1);
			}
			Parameter Diff_Capacity_Flow {
				IndexDomain: (datayear,h,h1);
			}
			ElementParameter HistFlowColor {
				IndexDomain: (datayear,h,h1);
				Range: AllColors;
			}
			ElementParameter HistCapacityColor {
				IndexDomain: (datayear,h,h1);
				Range: AllColors;
			}
		}
		DeclarationSection Output_files {
			StringParameter tempfilename;
			File TempFile {
				Name: tempfilename;
				Device: Disk;
				Mode: replace;
			}
		}
		Procedure Flow_report {
			Body: {
				!FlowsMonthly(MonthInPeriod(tmon), h, h1) := FlowHubToHub(tmon,h,h1);
				!FlowsAnnual(ModelYear, h, h1)  := sum(modelyrmn, FlowsMonthly(modelyrmn, h, h1));
				
				FlowDifference((ModelYear,h,h1) | map_HubArcs(h, h1)) :=FlowsAnnual(ModelYear, h, h1)-FlowsAnnual(ModelYear-1, h, h1);
				FlowDifference2015((h,h1) | map_HubArcs(h, h1)) := FlowsAnnual(FirstModelYear, h, h1)-HistoricalFlowAnnual(h,h1,FirstModelYear);
				
				FlowBinding( (ModelYear,h,h1) | map_HubArcs(h, h1) and (CapacityAnnual(ModelYear,h,h1)- FlowsAnnual(ModelYear,h,h1))< 0.01) := FlowsAnnual(ModelYear,h,h1);
				
				NodeFlowInMonthly(modelyrmn, h) :=sum(h1 | map_HubArcs(h1, h), FlowsMonthly(modelyrmn, h1, h));
				NodeFlowOutMonthly(modelyrmn, h) :=sum(h1 | map_HubArcs(h, h1), FlowsMonthly(modelyrmn, h, h1));
				NodeFlowInAnnual(ModelYear, h) := sum(modelyrmn, NodeFlowInMonthly(modelyrmn, h));
				NodeFlowOutAnnual(ModelYear, h) := sum(modelyrmn, NodeFlowOutMonthly(modelyrmn, h));
			}
		}
		Procedure Capacity_Flow_Report {
			Body: {
				Diff_Capacity_EIA_Old(datayear,h,h1) := HistoricalCapacity(h,h1,datayear) - HistoricalCapacityOld(h,h1,datayear);
				Diff_Capacity_Flow(datayear,h,h1) := HistoricalCapacity(h,h1,datayear) - HistoricalFlowAnnual(h,h1,datayear);
				
				 HistFlowColor(datayear,h,h1) :=  if (Diff_Capacity_Flow(datayear,h,h1) < 0) then
					'Red'
				elseif (Diff_Capacity_Flow(datayear,h,h1) > 0) then
					'Cyan'
				endif;
				
				HistCapacityColor(datayear,h,h1) :=  if (Diff_Capacity_EIA_Old(datayear,h,h1) < 0) then
					'Red'
				elseif (Diff_Capacity_EIA_Old(datayear,h,h1) > 0) then
					'Cyan'
				endif;
			}
		}
		Procedure Production_Report {
			Body: {
				!ActualProductionMonthly(MonthInPeriod(tmon), suptype, qps) := QProduction(tmon,suptype,qps); !sum(step, QSupplyStep(tmon,suptype,s,step)); !net of lease fuel
				!ActualProductionAnnual(ModelYear, suptype, qps) := sum(modelyrmn, ActualProductionMonthly(modelyrmn, suptype, qps));
				MinimumProductionMonthly(MonthInPeriod(tmon), suptype, qps)  := QbaseMin(tmon,suptype,qps);
				MinimumProductionAnnual(ModelYear, suptype, qps) := sum(modelyrmn, MinimumProductionMonthly(modelyrmn, suptype, qps));
				MaximumProductionMonthly(MonthInPeriod(tmon), suptype, qps)  := QbaseMax(tmon,suptype,qps);
				MaximumProductionAnnual(ModelYear, suptype, s) := sum(modelyrmn, MaximumProductionMonthly(modelyrmn, suptype, s));
				!TotalProduction(modelyrmn, h) := sum((suptype, s) | map_SupplyArcs(s, h), ActualProductionMonthly(modelyrmn, suptype, s));
				MonthlyProductionForReport(modelyrmn, suptype, d) := sum( qps | map_SupplyArcs(qps, d), ActualProductionMonthly(modelyrmn, suptype, qps));
				TotalExpectedProductionMonthly(modelyrmn, d) := sum((naadgas, qps) | map_SupplyArcs(qps, d), Supply(modelyrmn, naadgas, qps)* (1 - LeaseFuelFactor(qps)*STEOLeaseFuelFactor(ModelYear)));
				TotalExpectedProductionMonthly(modelyrmn, d) += sum((suptype, qps) | map_SupplyArcs(qps, d) and suptype in (SupplyType_-NA_AD_), Supply(modelyrmn, suptype, qps));
				TotalExpectedProductionAnnual(ModelYear,  d) := sum(modelyrmn, TotalExpectedProductionMonthly(modelyrmn, d));
				
				!SetWellheadPrices; !Set wellhead prices for next year
				WellheadPrice_Report_Debug;
				Tariff_Report_Debug;
				
				!ALL MOVED TO Write_to_NEMS procedure
				!! Fill the NEMS arrays
				!!SUPPLEMENTAL
				!!national total across all three categories (coal, oil, other) of supplemental fuel produced
				!NGTDMREP_OGPRSUP(NEMSmap_MNUMYR(ModelYear)) := sum((sng,l48), ActualProductionAnnual(ModelYear, sng, l48));
				!!SNG-coal
				!NGTDMREP_OGSUPGAS(1, TotalUS_MNUMCR, NEMSmap_MNUMYR(ModelYear)) := sum(l48, ActualProductionAnnual(ModelYear, Supply_SNGcoal, l48));
				!!SNG-oil+other
				!NGTDMREP_OGSUPGAS(2, TotalUS_MNUMCR, NEMSmap_MNUMYR(ModelYear)) := sum((sng,l48) | sng in (SNG_-Supply_SNGcoal), ActualProductionAnnual(ModelYear, sng, l48));
				!
				!!NA production
				!NGTDMREP_NGRNAGPRD(OGDIST, NEMSmap_MNUMYR(ModelYear)) := sum(ussup | NEMSmap_OGDIST_SupplyNode(OGDIST, ussup), ActualProductionAnnual(ModelYear, Supply_NA, ussup)/
				!                                                       (1 - LeaseFuelFactor(ussup)*STEOLeaseFuelFactor(ModelYear)));
				!
				!!NA + AD production by MNUMOR region
				!! Alaska ActualProductionAnnual and Wellhdprice should be set prior to this in AK subroutine
				!NGTDMREP_OGPRDNG(MNUMOR, NEMSmap_MNUMYR(ModelYear)) := sum(ussup | NEMSmap_SupplyNode_MNUMOR(ussup,MNUMOR), (ActualProductionAnnual(ModelYear, Supply_AD, ussup)+
				!                                                                 ActualProductionAnnual(ModelYear, Supply_NA, ussup))/ (1 - LeaseFuelFactor(ussup)*STEOLeaseFuelFactor(ModelYear)));
				!!W/h prices
				!NGTDMREP_OGWPRNG(MNUMOR, NEMSmap_MNUMYR(ModelYear)) := sum(ussup | NEMSmap_SupplyNode_MNUMOR(ussup,MNUMOR), WellhdPrice(ModelYear, Supply_NA, ussup)*(ActualProductionAnnual(ModelYear, Supply_AD, ussup)+
				!                                                                 ActualProductionAnnual(ModelYear, Supply_NA, ussup))/ (1 - LeaseFuelFactor(ussup)*STEOLeaseFuelFactor(ModelYear)))/$
				!                                                                  NGTDMREP_OGPRDNG(MNUMOR, NEMSmap_MNUMYR(ModelYear));
				!!US total
				!NGTDMREP_OGPRDNG(TotalUS_MNUMOR, NEMSmap_MNUMYR(ModelYear)) := sum(l48_MNUMOR, NGTDMREP_OGPRDNG(l48_MNUMOR, NEMSmap_MNUMYR(ModelYear)));
				!!Average l48 price
				!NGTDMREP_OGWPRNG(TotalUS_MNUMOR, NEMSmap_MNUMYR(ModelYear)) := sum(l48_MNUMOR, NGTDMREP_OGPRDNG(l48_MNUMOR, NEMSmap_MNUMYR(ModelYear))*NGTDMREP_OGWPRNG(l48_MNUMOR, NEMSmap_MNUMYR(ModelYear)))/$
				!                                                                sum(l48_MNUMOR, NGTDMREP_OGPRDNG(l48_MNUMOR, NEMSmap_MNUMYR(ModelYear)));
				!
				!!YDA: need to add OGPRCNG(OGDIST,MNUMYR) to global structure to fill in the prices
				!NGTDMREP_OGPRCNG(OGDIST, NEMSmap_MNUMYR(ModelYear)) := sum(ussup | NEMSmap_OGDIST_SupplyNode(OGDIST, ussup),  WellhdPrice(ModelYear, Supply_NA, ussup));
				!!The Henry Hub prices ( 87$/MMBtu)
				!NGTDMREP_OGHHPRNG(NEMSmap_MNUMYR(ModelYear)) := (WellhdPrice(ModelYear, Supply_NA, HenryHubRegion)+GatheringCharge(HenryHubRegion))/Convert_TBtu_Bcf(ModelYear);
				!
			}
		}
		Procedure WellheadPrice_Report_Debug {
			Body: {
				
				WHPrcSoln_monthly((MonthInPeriod(tmon), qps)| map_Supply(qps, Supply_NA) )  := SupplyAccounting.ShadowPrice(tmon,Supply_NA,qps);
				
				Stepnumber(MonthInPeriod(tmon), qps) := count(step | QSupplyStep(tmon, Supply_NA, qps, step)) ;
				!
				MaxStepsln(modelyrmn, qps) := Element(Supply_Curve_Step_, Stepnumber(modelyrmn, qps));
				
				WHPrcCalc_monthly((MonthInPeriod(tmon), qps) | map_Supply(qps, Supply_NA) ) := Pbase(tmon, Supply_NA, qps, MaxStepsln(MonthInPeriod(tmon), qps)) +
				  ( QProduction(tmon, Supply_NA, qps) - Qbase(tmon, Supply_NA, qps, MaxStepsln(MonthInPeriod(tmon), qps)) ) *
				  ( Pbase(tmon, Supply_NA, qps, MaxStepsln(MonthInPeriod(tmon), qps)+1) - Pbase(tmon, Supply_NA, qps, MaxStepsln(MonthInPeriod(tmon), qps)) ) /$
				  ( Qbase(tmon, Supply_NA, qps, MaxStepsln(MonthInPeriod(tmon), qps)+1) - Qbase(tmon, Supply_NA, qps, MaxStepsln(MonthInPeriod(tmon), qps)) );
				
				!Do weighted average to calculate annual price
				
				WHPrcSoln_annual((ModelYear, qps)| map_Supply(qps, Supply_NA) ) :=  sum(modelyrmn, WHPrcSoln_monthly(modelyrmn, qps)* ActualProductionMonthly(modelyrmn, Supply_NA, qps))/ $
				                                                                 ActualProductionAnnual(ModelYear, Supply_NA, qps);
				WHPrcCalc_annual((ModelYear, qps)| map_Supply(qps, Supply_NA) ) :=  sum(modelyrmn, WHPrcCalc_monthly(modelyrmn, qps)* ActualProductionMonthly(modelyrmn, Supply_NA, qps))/ $
				                                                                 ActualProductionAnnual(ModelYear, Supply_NA, qps);
				
				Pnode((ModelYear, qps)| map_Supply(qps, Supply_NA) ) :=
				!   if (ModelYear=FirstModelYear and WellhdPrice(ModelYear, Supply_NA, qps)) then 
				   if LastDataYearFlg_WHPrice(ModelYear) then 
				   	WellhdPrice(ModelYear, Supply_NA, qps)*STEOWellhdPriceFactor(ModelYear)	
				   else WellhdPrice(ModelYear-1, Supply_NA, qps) *STEOWellhdPriceFactor(ModelYear)
				   endif;
				!Pnode((ModelYear, l48s)| map_Supply(l48s, Supply_NA) ) *= STEOWellhdPriceFactor(ModelYear);
				Qnode((ModelYear, qps)| map_Supply(qps, Supply_NA) ) :=sum(modelyrmn, Supply(modelyrmn, Supply_NA, qps)* (1 - LeaseFuelFactor(qps)*STEOLeaseFuelFactor(ModelYear)) );
				Qnode(ModelYear, CanadaWest)*= STEOPipelineImportFactor(ModelYear);
			}
		}
		Procedure Tariff_Report_Debug {
			Body: {
				!QTariffCurve((tmon, h, h1, step) | QTariffCurve(tmon, h, h1, step)<0.005 and map_HubArcs(h, h1)) := 0;
				TariffStepnumber((MonthInPeriod(tmon), h,h1) | map_HubArcs(h, h1)) := count(step | QTariffCurve(tmon, h, h1, step)) ;
				!
				TariffMaxStepSln((modelyrmn, h,h1) | CurrentPipeCapacity(modelyrmn, h, h1)) := Element(Supply_Curve_Step_, TariffStepnumber(modelyrmn, h, h1));
				
				Tariff_Calc((MonthInPeriod(tmon), h, h1) | QP_Capacity(tmon,h,h1))  := Slope_TariffCurve(tmon, h, h1, TariffMaxStepSln(MonthInPeriod(tmon), h, h1))*
				      QTariffCurve(tmon, h, h1, TariffMaxStepSln(MonthInPeriod(tmon), h, h1)) + PipelineTariff(tmon, h, h1, TariffMaxStepSln(MonthInPeriod(tmon), h, h1));
				!PipelineTariff(tmon, h, h1, TariffMaxStepSln(MonthInPeriod(tmon), h, h1)) +
				!  ( FlowHubToHub(tmon,h,h1) - PipeTariffCurveQty(tmon, h, h1, TariffMaxStepSln(MonthInPeriod(tmon), h, h1)) ) *
				!  ( PipelineTariff(tmon, h, h1, TariffMaxStepSln(MonthInPeriod(tmon), h, h1)+1) - PipelineTariff(tmon, h, h1, TariffMaxStepSln(MonthInPeriod(tmon), h, h1)) ) /$
				!  ( PipeTariffCurveQty(tmon, h, h1, TariffMaxStepSln(MonthInPeriod(tmon), h, h1)+1) - PipeTariffCurveQty(tmon, h, h1, TariffMaxStepSln(MonthInPeriod(tmon), h, h1)) );
				
				  Tariff_Soln((MonthInPeriod(tmon), h, h1) | QP_Capacity(tmon,h,h1))  := TariffCurveQtyBalance.ShadowPrice(tmon,h,h1);
				  Tariff_Soln((modelyrmn, h, h1) | Tariff_Soln(modelyrmn, h, h1)<0) := 0;
				  Tariff_SolnAlt((MonthInPeriod(tmon), h, h1,step) | QP_Capacity(tmon,h,h1))  := TariffCurveQtyTotal.ShadowPrice(tmon,h,h1,step);
				
				TariffStep_Calc((tmon, h, h1,step) | step <= PTCrv_MaxStep and map_HubArcs(h, h1) and QTariffCurve(tmon,h,h1,step)>0 )  := PipelineTariff(tmon, h, h1, step) +
				  ( QTariffCurve(tmon,h,h1,step) ) *
				  ( PipelineTariff(tmon, h, h1, step+1) - PipelineTariff(tmon, h, h1, step) ) /$
				  ( PipeTariffCurveQty(tmon, h, h1, step+1) - PipeTariffCurveQty(tmon, h, h1, step) );
				
				PipelineTariffReport((tmon,h,h1,step) | step <= PTCrv_MaxStep and map_HubArcs(h, h1)) :=  Parameter_TariffCurvePrice(h, h1,step+1);
				
				NodePrice_Soln(MonthInPeriod(tmon), h) := -HubBalance.ShadowPrice(tmon, h);
				if LastDataYearFlg_SpotPrc(ModelYear) then 
				    SpotPrc_Diff(ModelYear,l48):=sum(modelyrmn, (HistoricalSpotPrice(modelyrmn,l48)-NodePrice_Soln(modelyrmn,l48)))/12; 
				else
				    tempfilename:="spot_prc_diff.txt";
				    put TempFile;
				    display{SpotPrc_Diff};
				    putclose TempFile;
				endif;
				
				
				!Calculate OBJ function piece
				NoVarTariffCurveFlg((MonthInPeriod(tmon),h,h1,step) | map_HubArcs(h, h1) and step <= PTCrv_MaxStep and
				                                            (PipeTariffCurveQty(tmon,h,h1,step+1) - PipeTariffCurveQty(tmon,h,h1,step) )<0):=1;
				if sum((modelyrmn, h, h1, step), NoVarTariffCurveFlg(modelyrmn, h, h1, step)) then
				   write NoVarTariffCurveFlg((modelyrmn, h, h1, step) | NoVarTariffCurveFlg(modelyrmn, h, h1, step)) to file "NGATTENTION.txt" in merge mode;
				   RAISE WARNING " Variable Tariff Curve data are missing in "+ModelYear+"; See NGATTENTION.txt for details." CODE 'NoVarTarCurve';
				endif;
				
				!DebugTariffOBJMn(MonthInPeriod(tmon)):= sum((h,h1,step)| QP_Capacity(tmon,h,h1) and step <= PTCrv_MaxStep, PipelineTariff(tmon,h,h1,step) * QTariffCurve(tmon,h,h1,step) +
				!     0.5 * sqr( QTariffCurve(tmon,h,h1,step) ) *
				!    ! 0.5 * QTariffCurve(tmon,h,h1,step) * (QTariffCurve(tmon,h,h1,step)- PipeTariffCurveQty(tmon,h,h1,step)) *
				!     (PipelineTariff(tmon,h,h1,step+1) - PipelineTariff(tmon,h,h1,step) )/ (PipeTariffCurveQty(tmon,h,h1,step+1) - PipeTariffCurveQty(tmon,h,h1,step) ) );
				!DebugTariffOBJ(MonthInPeriod(tmon),h,h1):= sum((step)| QP_Capacity(tmon,h,h1) and step <= PTCrv_MaxStep, PipelineTariff(tmon,h,h1,step) * QTariffCurve(tmon,h,h1,step) +
				!     0.5 * sqr( QTariffCurve(tmon,h,h1,step) ) *
				!     (PipelineTariff(tmon,h,h1,step+1) - PipelineTariff(tmon,h,h1,step) )/ (PipeTariffCurveQty(tmon,h,h1,step+1) - PipeTariffCurveQty(tmon,h,h1,step) ) );
				!DebugTariffOBJstep((MonthInPeriod(tmon),h,h1,step) | QP_Capacity(tmon,h,h1) and step <= PTCrv_MaxStep) :=  PipelineTariff(tmon,h,h1,step) * QTariffCurve(tmon,h,h1,step) +
				!     0.5 * sqr( QTariffCurve(tmon,h,h1,step) ) *
				!     !0.5 * QTariffCurve(tmon,h,h1,step) * (QTariffCurve(tmon,h,h1,step)- PipeTariffCurveQty(tmon,h,h1,step)) *
				!     (PipelineTariff(tmon,h,h1,step+1) - PipelineTariff(tmon,h,h1,step) )/ (PipeTariffCurveQty(tmon,h,h1,step+1) - PipeTariffCurveQty(tmon,h,h1,step) ) ;
				!DebugTariffOBJYr(ModelYear):= sum(modelyrmn, DebugTariffOBJMn(modelyrmn));
				!DebugSlackYr(ModelYear):= sum((tmon,qps), 10^9* SLackVar(tmon,qps));
				!
			}
		}
		Procedure Debug_Report_Calculations {
			Body: {
				NetDemand(modelyrmn, h) := TotalConsumption(modelyrmn, h) + StorageInjections(modelyrmn, h) + QTotalLNGExports(modelyrmn, h) -
				sum(suptype, MonthlyProductionForReport(modelyrmn, suptype, h)) - StorageWithdrawals(modelyrmn, h) - BalanceItem(modelyrmn, h) -
				LeaseFuel(modelyrmn, h);
				
				NetDemandAnnual(ModelYear, h) := sum(modelyrmn, NetDemand(modelyrmn, h));
				
				!Price
				!weighted average tariff based on flows
				TariffAnnual(ModelYear,h,h1) := sum(modelyrmn, Tariff_Soln(modelyrmn, h, h1)*FlowsMonthly(modelyrmn, h, h1))/$ FlowsAnnual(ModelYear,h,h1);
				!straight average node price
				NodePriceAnnual(ModelYear, h) := sum(modelyrmn, NodePrice_Soln(modelyrmn, h))/card(ModelYearMonths_);
				
				Capacity_Utilization_Report;
			}
		}
		Procedure Totals_Report {
			Body: {
				!Calculate annual totals for the US
				TotalUSProductionAnnual(ModelYear):= sum((l48,modelyrmn),TotalProduction(modelyrmn, l48));
				TotalUSStorageWthAnnual(ModelYear):= sum(l48, AnnualStorageWithdrawals(ModelYear, l48));
				TotalUSStorageInjAnnual(ModelYear):= sum(l48, AnnualStorageInjections(ModelYear, l48));
				TotalUSConsumptionAnnual(ModelYear):= sum((l48,modelyrmn),TotalConsumption(modelyrmn, l48));
				TotalUSLNGexports(ModelYear) := sum(lngexp,AnnualLNGExports(ModelYear, lngexp));
				TotalImportsAnnual(ModelYear) := sum(bx,AnnualImports(ModelYear,bx));
				TotalExportsAnnual(ModelYear) := sum(bx,AnnualExports(ModelYear,bx));
				
				TotalUSSupplyAnnual(ModelYear):= TotalUSProductionAnnual(ModelYear) + TotalUSStorageWthAnnual(ModelYear) + TotalImportsAnnual(ModelYear);
				TotalExpectedUSSupplyAnnual(ModelYear):=  TotalUSStorageWthAnnual(ModelYear) + sum(l48, TotalExpectedProductionAnnual(ModelYear, l48))+ TotalImportsAnnual(ModelYear);
				
				TotalUSDemandAnnual(ModelYear):= TotalUSConsumptionAnnual(ModelYear) + TotalUSStorageInjAnnual(ModelYear) + TotalUSLNGexports(ModelYear) + TotalExportsAnnual(ModelYear);
				
				TotalModelDemand(ModelYear) := sum((d,modelyrmn),TotalConsumption(modelyrmn, d)+StorageInjections(modelyrmn,d) +PipeFuelLoss(modelyrmn, d) )+ TotalUSLNGexports(ModelYear); !plus losses
				TotalModelSupply(ModelYear) := sum((d,modelyrmn),TotalProduction(modelyrmn, d)+StorageWithdrawals(modelyrmn,d) );
				
				TotalBalanceItemAnnual(ModelYear) := sum((l48,modelyrmn),BalanceItem(modelyrmn, l48));
				TotalSupplementalAnnual(ModelYear) :=sum((sng,l48), ActualProductionAnnual(ModelYear, sng, l48));
				TotalLNGImportsAnnual(ModelYear) :=sum(l48, ActualProductionAnnual(ModelYear, Supply_LNG, l48));
			}
		}
		Procedure Colors_Report {
			Body: {
				 FlowColor(year,h,h1) :=  if (FlowDifference(year, h, h1) > FlowColorThreshold) then
					'Red'
				elseif (FlowDifference(year, h, h1) < - FlowColorThreshold) then
					'Cyan'
				endif;
				
				 FlowColor(year,h,h1) :=  if (FlowDifference2015(h, h1) > FlowColorThreshold) then
					'Red'
				elseif (FlowDifference2015(h, h1) < - FlowColorThreshold) then
					'Cyan'
				endif;
				
				CapacityColor(year,h,h1) :=  if (CapacityAdditionAnnual(year, h, h1) > FlowColorThreshold) then
					'Red'
				elseif (CapacityAdditionAnnual(year, h, h1) < - FlowColorThreshold) then
					'Cyan'
				endif;
			}
		}
		Procedure Colors_Flows_Report {
			Body: {
				 FlowColor2(h, h1) :=  if (delta_chk(h, h1) > 1+FlowColorThreshold) then
					'Red'
				elseif (delta_chk(h, h1) < 1- FlowColorThreshold) then
					'Cyan'
				endif;
			}
		}
		Procedure Colors_Report2 {
			Body: {
				
				BindingFlowColor(year,h,h1) :=  if (FlowBinding(year, h, h1) > 0) then
					'Red'
				else
					'Black'
				endif;
			}
		}
		Procedure Capacity_Utilization_Report {
			Body: {
				CapacityUtilization(ModelYear, h, h1) :=  FlowsAnnual(ModelYear, h, h1)  /$  CapacityAnnual(ModelYear, h, h1);
				
				!if last(AllColors) <> 'orange' then
				!	UserColorAdd("orange", 255, 165, 0);
				!endif;
				
				CapacityUtilizationColor(ModelYear, h, h1) | CapacityUtilization(ModelYear, h, h1) >= 0.95 := 'red';  
				CapacityUtilizationColor(ModelYear, h, h1) | CapacityUtilization(ModelYear, h, h1) < 0.95 and CapacityUtilization(ModelYear, h, h1) >= 0.90 := 'redorange'; 
				CapacityUtilizationColor(ModelYear, h, h1) | CapacityUtilization(ModelYear, h, h1) < 0.90 and CapacityUtilization(ModelYear, h, h1) >= 0.80 := 'orange'; 
				CapacityUtilizationColor(ModelYear, h, h1) | CapacityUtilization(ModelYear, h, h1) < 0.80 and CapacityUtilization(ModelYear, h, h1) >= 0.70 := 'oranyel'; 
				CapacityUtilizationColor(ModelYear, h, h1) | CapacityUtilization(ModelYear, h, h1) < 0.70 and CapacityUtilization(ModelYear, h, h1) >= 0.60 := 'yellow'; 
				CapacityUtilizationColor(ModelYear, h, h1) | CapacityUtilization(ModelYear, h, h1) < 0.6 and CapacityUtilization(ModelYear, h, h1) >= 0.4 := 'greenyellow';  
				CapacityUtilizationColor(ModelYear, h, h1) | CapacityUtilization(ModelYear, h, h1) < 0.4  := 'green';
			}
		}
	}
	Section Case_Comparison {
		Procedure CompareCases {
			Arguments: (CaseName1,CaseName2);
			Body: {
				CaseFileURLtoElement( FormatString("data\\cases\\%s.data",CaseName1),Case1);
				CaseFileURLtoElement( FormatString("data\\cases\\%s.data",CaseName2),Case2);
				
				! This determines the difference between the two cases per identifier
				IdentifierDifference(IndexParameters)
					:= CaseCompareIdentifier(
						FirstCase  :  Case1, 		! For here, just one of the cases
						SecondCase :  Case2, 		! For here, just one of the cases
						Identifier :  IndexParameters,
						Suffix     :  'level', 			! We want to compare the level values
						Mode       :  'count');			! We want to count the differences.
				
				! This creates a set with the identifiers that have differences
				! This will be used as "Implicit Identifiers" in the pivot table on page "Compare Case"
				IdentifiersWithDifference := {IndexParameters | IdentifierDifference(IndexParameters)};
				
				! This is the same as manually selecting the two cases
				CurrentCaseSelection := AllCases;
			}
			StringParameter CaseName1 {
				Property: Input;
			}
			ElementParameter Case1 {
				Range: AllCases;
			}
			StringParameter CaseName2 {
				Property: Input;
			}
			ElementParameter Case2 {
				Range: AllCases;
			}
		}
		Procedure CompareNEMSruns {
			Arguments: (CaseName1,CaseName2);
			Body: {
				CaseFileURLtoElement( FormatString("_NEMSruns\\%s.data",CaseName1),Case1);
				CaseFileURLtoElement( FormatString("_NEMSruns\\%s.data",CaseName2),Case2);
				
				! This determines the difference between the two cases per identifier
				IdentifierDifference(IndexParameters)
					:= CaseCompareIdentifier(
						FirstCase  :  Case1, 		! For here, just one of the cases
						SecondCase :  Case2, 		! For here, just one of the cases
						Identifier :  IndexParameters,
						Suffix     :  'level', 			! We want to compare the level values
						Mode       :  'count');			! We want to count the differences.
				
				! This creates a set with the identifiers that have differences
				! This will be used as "Implicit Identifiers" in the pivot table on page "Compare Case"
				IdentifiersWithDifference := {IndexParameters | IdentifierDifference(IndexParameters)};
				
				! This is the same as manually selecting the two cases
				CurrentCaseSelection := AllCases;
			}
			StringParameter CaseName1 {
				Property: Input;
			}
			ElementParameter Case1 {
				Range: AllCases;
			}
			StringParameter CaseName2 {
				Property: Input;
			}
			ElementParameter Case2 {
				Range: AllCases;
			}
		}
		Procedure CaseCompareDebug {
			Body: {
				!CompareCases("FixedLNG", "ModelLNG");
				CompareCases("base", "aimms476");
				!CompareNEMSruns("refngmm_d092717a", "refngmm_d100117a_p2");
			}
			Comment: "If this gives an error about explicit identifiers, then change CaseName1 and CaseName2 in CompareCases to strictly input.";
		}
		Procedure testing {
			Body: {
				debug(year, s_ogsm) :=    AnnualSupply (ModelYear, Supply_NA, s_ogsm) -  sum(OGDIST | NEMSmap_OGDIST_SupplyNode(OGDIST, s_ogsm),OGSMOUT_OGENAGPRD(OGDIST,5,NEMSmap_MNUMYR(ModelYear)));
			}
		}
		DeclarationSection Case_Compare_Identifiers {
			Parameter IdentifierDifference {
				IndexDomain: IndexParameters;
			}
			Set IdentifiersWithDifference {
				SubsetOf: AllIdentifiers;
			}
			Parameter debug {
				IndexDomain: (year,s);
			}
		}
	}
	Section RNG_Section {
		DeclarationSection RNG_Production_Declarations {
			Parameter USVehicileConsAnnual {
				IndexDomain: year;
			}
			Parameter CAVehicleConsAnnual {
				IndexDomain: year;
			}
			Parameter LCFSProductionAnnual {
				IndexDomain: year;
			}
			Parameter TotalAnnualRNGProductionType {
				IndexDomain: (year,rng_type);
			}
			Set active_rng_projects {
				SubsetOf: id;
			}
			Set available_rng_projects {
				SubsetOf: id;
			}
			Set lcfs_projects {
				SubsetOf: id;
			}
			ElementParameter rng_project_add {
				Range: id;
			}
			ElementParameter rng_project_add_type {
				Range: rng_prod_type;
			}
			Parameter max_profit_from_project;
			Parameter ModelYearRNGProduction;
			Set TotalAnnualRNGProductionf;
			StringParameter mapProjectsFarm {
				IndexDomain: (proj_id,reg);
			}
			StringParameter MapRNGProjectType {
				IndexDomain: (proj_id,reg);
			}
			Parameter landfill_projects {
				IndexDomain: proj_id;
			}
			Parameter CAVehicleCons;
			StringParameter mapProjectsLandfill {
				IndexDomain: (proj_id,reg);
			}
			Parameter mapProj_id_ToReg {
				IndexDomain: proj_id;
			}
			Parameter PacifcRegCons;
			Parameter annual_rng_capacity_flag {
				IndexDomain: (year,proj_id,rng_type);
				Range: binary;
			}
			Parameter rng_produced_monthly {
				IndexDomain: (proj_id,reg,rng_type);
			}
			Parameter lcoe_rfs_lcfs_adj {
				IndexDomain: (proj_id,reg,rng_type);
			}
		}
		DeclarationSection LCFS_Declarations {
			Parameter LCFS_carbon_offset_project {
				IndexDomain: (proj_id,reg,rng_type);
			}
			Set AnnualLCFSProjects {
				SubsetOf: id;
			}
			Parameter AnnualRNGCarbonOffset {
				IndexDomain: year;
			}
			Parameter rng_lcfs_production {
				IndexDomain: year;
			}
			Parameter rng_lcfs_totalCI_difference_from_target {
				IndexDomain: year;
			}
			Parameter RNGProduction_LCFS {
				Comment: "RNG Production from LCFS. Constrained by California transportation volumes.";
			}
			Parameter baseline_CI {
				IndexDomain: xyear;
			}
			Parameter CI_adder_from_elec {
				IndexDomain: reg;
			}
			Parameter MJ_to_MMBtu;
			Parameter LCFS_credit_per_MMBtu {
				IndexDomain: (proj_id,reg,rng_type);
			}
			Parameter target_CI;
			Parameter CI_difference_from_target {
				IndexDomain: (proj_id,reg,rng_type);
			}
			Parameter CI_penalty_per_mile;
			Parameter proj_base_ci {
				IndexDomain: (proj_id,reg,rng_type);
			}
			Parameter proj_distance {
				IndexDomain: (proj_id,reg,rng_type);
			}
			Parameter proj_CI {
				IndexDomain: (proj_id,reg,rng_type);
			}
			Parameter distance {
				IndexDomain: reg;
			}
			Parameter assumed_CI_base {
				IndexDomain: rng_type;
			}
			ElementParameter LatestLCFSVolumeYear {
				Range: Years_;
			}
			Parameter LatestLCFSVolume;
		}
		DeclarationSection RNG_Supply_Curve_Declarations {
			Set rng_state_loop_iterator {
				SubsetOf: Regions_;
				Index: rng_state_loop_i;
			}
			Parameter RNG_prod_last_historical_year {
				IndexDomain: rng_type;
			}
			Parameter RNG_prod_last_historical_yearState {
				IndexDomain: (rng_type,state);
			}
			Parameter proj_rng {
				IndexDomain: (proj_id,reg,rng_type);
			}
		}
		DeclarationSection Starting_RNG_Capacity_Declarations {
			Set smallest_allowable_proj {
				SubsetOf: id;
				Index: proj_small;
			}
			Set RNGSources_ {
				SubsetOf: rng_prod_type;
				Index: rng_source_i;
				Comment: "RNG sources for the capacity loops";
			}
			Parameter state_project_id {
				IndexDomain: proj_id;
			}
			Parameter project_id_ord_iterator;
			Parameter RNG_from_historical_capacity {
				IndexDomain: (reg,rng_type);
			}
			Parameter rng_state_sum_temp;
			Set projects_for_state {
				SubsetOf: id;
			}
			Parameter historical_capacity_flag {
				IndexDomain: proj_id;
				Range: binary;
			}
			Parameter ANL_rng_historicalProductionAnnual {
				IndexDomain: (year,rng_type, h);
			}
			Parameter RNG_CapacityLastHistoricalYear;
		}
		DeclarationSection LCOE_declarations {
			Parameter profit_lcfs {
				IndexDomain: (proj_id,reg,rng_type);
			}
			Parameter profit_rfs {
				IndexDomain: (proj_id,reg,rng_type);
			}
			Parameter profit_lcfs_rfs {
				IndexDomain: (proj_id,reg,rng_type);
			}
			Parameter profit_noCredits {
				IndexDomain: (proj_id,reg,rng_type);
			}
			Parameter AnnualStateSpotPrice_RNG {
				IndexDomain: (year,reg);
			}
			Parameter lcoe_lcfs_rfs_adj {
				IndexDomain: (proj_id,reg,rng_type);
			}
			Parameter lcoe_rfs_adj {
				IndexDomain: (proj_id,reg,rng_type);
			}
			Parameter lcoe_lcfs_adj {
				IndexDomain: (proj_id,reg,rng_type);
				Range: free;
			}
			Parameter LCFS_credit_price;
			ElementParameter LCFS_credit_price_year {
				Range: Years_;
			}
			Parameter rng_produced {
				IndexDomain: (proj_id,reg,rng_type);
			}
			Parameter lcoe {
				IndexDomain: (proj_id,reg,rng_type);
			}
			Set id {
				Index: proj_id;
			}
			StringParameter rng_source {
				IndexDomain: (proj_id,reg);
			}
		}
		Procedure Calculate_LCOE_and_Credits {
			Body: {
				!ModelYear := '2022';
				
				! Calculate difference from target CI
				CI_difference_from_target(proj_id, reg, rng_type | lcoe(proj_id, reg, rng_type)) := baseline_CI(ModelYear)  - proj_CI(proj_id, reg, rng_type);
				
				! Calculate how $/MMBtu credit value each project would get for LCFS and RIN credits
				LCFS_credit_per_MMBtu(proj_id, reg, rng_type) := CI_difference_from_target(proj_id, reg, rng_type) * LCFS_credit_price * MJ_to_MMBtu ;
				RIN_credit_per_MMBTU(proj_id, reg, rng_type | lcoe(proj_id, reg, rng_type)) := D3_RIN_Price;
				
				! Convert RNG from Bcf, to MMBtu, and then to MJ. Then multiply by CI difference to get grams of CO2. Divide by 1,000,000 to convert to tons,
				! and then divide by 1,000,000 to convert to million tons. 
				LCFS_carbon_offset_project(proj_id, reg, rng_Type) := ((rng_produced(proj_id, reg, rng_type)*1037000)/MJ_to_MMBtu) * 
									       (CI_difference_from_target(proj_id, reg, rng_type)) / 1000000 / 1000000;
				
				! Make adjusted LCOE parameters using the credits
				lcoe_lcfs_adj(proj_id,reg,rng_type) := lcoe(proj_id, reg, rng_type) - LCFS_credit_per_MMBtu(proj_id, reg, rng_type);
				lcoe_rfs_adj(proj_id,reg,rng_type) := lcoe(proj_id, reg, rng_type) - RIN_credit_per_MMBtu(proj_id, reg, rng_type);
				lcoe_lcfs_rfs_adj(proj_id, reg, rng_type) := lcoe(proj_id, reg, rng_type) - LCFS_credit_per_MMBtu(proj_id, reg, rng_type) - RIN_credit_per_MMBtu(proj_id, reg, rng_type);
				
				! Calculate Annual Spot Prices (including Texas)
				AnnualStateSpotPrice_RNG(year, reg) := sum((mon,sec)| map_month_year(mon,year), Price_Spot(mon,reg)*
				     Cons_State_Mon(mon,sec, reg))/$
				     sum(sec,Cons_State_Yr(year, sec, reg));
				
				 ! Take the weighted average of the Texas regions spot price so we have prices for Texas
				!AnnualStateSpotPrice_RNG(ModelYear, TexasState) := sum((modelyrmn,sec, r_tx), Price_Spot(modelyrmn,r_tx)* Cons_State_Mon(modelyrmn,sec,r_tx))/$
				!     sum((sec, r_tx),Cons_State_Yr(ModelYear-1, sec, r_tx));
				
				! Calculate $/MMBtu profit under various credit systems
				 profit_lcfs(proj_id, reg, rng_type) := AnnualStateSpotPrice_RNG(ModelYear-1, CaliforniaState | lcoe_lcfs_adj(proj_id, reg, rng_type)) - lcoe_lcfs_adj(proj_id, reg, rng_type);
				 profit_rfs(proj_id, reg, rng_type) := AnnualStateSpotPrice_RNG(ModelYear-1, reg | lcoe_rfs_adj(proj_id, reg, rng_type)) - lcoe_rfs_adj(proj_id, reg, rng_type);
				 profit_lcfs_rfs(proj_id, reg, rng_type) := AnnualStateSpotPrice_RNG(ModelYear-1, CaliforniaState | lcoe_lcfs_rfs_adj(proj_id, reg, rng_type)) - lcoe_lcfs_rfs_adj(proj_id, reg, rng_type);
				 profit_noCredits(proj_id, reg, rng_type) := AnnualStateSpotPrice_RNG(ModelYear-1, reg | lcoe(proj_id, reg, rng_type)) - lcoe(proj_id, reg, rng_type);
			}
		}
		Procedure RNG_Production_Run {
			Body: {
				Calculate_LCOE_and_Credits;
				! Convert to Bcf/month (need to redo properly)
				rng_produced_monthly(proj_id, reg, rng_type) := rng_produced(proj_id, reg, rng_type) / 12;
				
				! Determine HH spot price
				rng_avg_spot_prc(reg) := mean(rng_avg_year, PriceSpotAnnualState(rng_avg_year, reg));
				! Convert RINs from EGE to MMcf
				RIN_D3_Mandate_MMcf(year) := RIN_D3_Mandate(year) * 1000000000 * EGE_to_MMcf;
				
				! Convert RIN mandate from MMcf to Bcf
				RIN_D3_Mandate_Bcf(year) := RIN_D3_Mandate_MMcf(year)/1000;
				
				! Determine last year of RIN mandate and corresponding volumes
				Last_RIN_Mandate_Year := Last(year | RIN_D3_Mandate_Bcf(year) <> 0);
				Last_RIN_Mandate_Volume := RIN_D3_Mandate_Bcf(Last(year | RIN_D3_Mandate_Bcf(year) <> 0));
				
				! Apply last year of RIN mandate volumes forward into the future.
				RIN_D3_Mandate_Bcf(year | year > Last_RIN_Mandate_Year) := Last_RIN_Mandate_Volume;
				
				! Pacific region veihicle transportation consumption
				PacifcRegCons := sum((fuel, vehicle), NEMS_AnnualConsByMode(ModelYear, fuel, vehicle, CD_Pacific));
				
				! Apply california share of Pacific consumption
				CAVehicleCons := Cons_share_StateCen(Sector_Transportation,CaliforniaState,CD_Pacific)*PacifcRegCons;
				CAVehicleConsAnnual(year) := sum((fuel, vehicle), NEMS_AnnualConsByMode(year, fuel, vehicle, CD_Pacific)) * Cons_share_StateCen(Sector_Transportation,CaliforniaState,CD_Pacific);
				
				USVehicileConsAnnual(year):= sum((fuel, vehicle, r_cen), NEMS_AnnualConsByMode(year, fuel, vehicle, r_cen));
				
				ModelYearRNGProduction :=  sum(l48,AnnualSupply(ModelYear-1, Supply_RNG, l48 ));
				
				! Re-do to ensure that just because production is hit in a prior year, it does skip the RFS mandate section
				if ModelYear = '2022' then
					ModelYearRNGProduction := 0;
				endif;
				
				active_rng_projects := {proj_id | Exists((year, rng_type), annual_rng_capacity_flag(year, proj_id, rng_type))};
				available_rng_projects := id - active_rng_projects;
				
				!available_rng_projects := {33, 34};
				
				!RNGProduction_LCFS := LatestLCFSVolume;
				
				empty AnnualLCFSProjects;
				
				! Pull forward prior year projects
				if ModelYear = RNGYear then
					annual_rng_capacity_flag(ModelYear, proj_id, rng_type) := annual_rng_capacity_flag(RNGYear, proj_id, rng_type);
				else
					annual_rng_capacity_flag(ModelYear, proj_id, rng_type) := annual_rng_capacity_flag(ModelYear-1, proj_id, rng_type);
				endif;
				
				 While (RIN_D3_Mandate_Bcf(ModelYear) > ModelYearRNGProduction) and ModelYearRNGProduction < USVehicileConsAnnual(ModelYear)  do
				
					if ((RIN_D3_Mandate_Bcf(ModelYear) > ModelYearRNGProduction) and (RNGProduction_LCFS < CAVehicleCons)) then
						! Use LCOE_RFS_LCFS
				
						! Determine value of most profitable project
						max_profit_from_project := max((proj_id, reg, rng_type), profit_lcfs_rfs(proj_id, reg, rng_type | proj_id in available_rng_projects and profit_lcfs_rfs(proj_id, reg, rng_type) > 0));
						! Use profit value to determine which project is associated with the profit value
						rng_project_add := Element({proj_id | Exists(((reg, rng_type)) | profit_lcfs_rfs(proj_id, reg, rng_type | proj_id in available_rng_projects) = max_profit_from_project ) }, 1);
				
						rng_project_add_type := Element({rng_type | Exists(((proj_id, reg)) | profit_lcfs_rfs(proj_id, reg, rng_type | proj_id in available_rng_projects) = max_profit_from_project )}, 1);
				
						annual_rng_capacity_flag(ModelYear, rng_project_add, rng_project_add_type) := 1;
						available_rng_projects -= rng_project_add;
						lcfs_projects += rng_project_add;
						AnnualLCFSProjects += rng_project_add;
				
						ModelYearRNGProduction := sum( (proj_id, rng_type, reg) | annual_rng_capacity_flag(ModelYear, proj_id, rng_type) , rng_produced(proj_id, reg, rng_type ));
						RNGProduction_LCFS := LatestLCFSVolume + sum( (proj_id, rng_type, reg) | annual_rng_capacity_flag(ModelYear, proj_id, rng_type | proj_id in lcfs_projects ) , rng_produced(proj_id, reg, rng_type ));
						!break;
				
						! Keep track of projects that are added in this section because of LCFS accounting
					elseif (RNGProduction_LCFS > CAVehicleCons) then
						! Use only RFS credits
								! Determine value of most profitable project
						max_profit_from_project := max((proj_id, reg, rng_type), profit_rfs(proj_id, reg, rng_type | proj_id in available_rng_projects and  profit_rfs(proj_id, reg, rng_type) > 0));
				
						if max_profit_from_project > 0 then
							! Use profit value to determine which project is associated with the profit value
							rng_project_add := Element({proj_id | Exists(((reg, rng_type)) | profit_rfs(proj_id, reg, rng_type | proj_id in available_rng_projects) = max_profit_from_project ) }, 1);
				
							rng_project_add_type := Element({rng_type | Exists(((proj_id, reg)) | profit_rfs(proj_id, reg, rng_type | proj_id in available_rng_projects) = max_profit_from_project )}, 1);
				
							annual_rng_capacity_flag(ModelYear, rng_project_add, rng_project_add_type) := 1;
							available_rng_projects -= rng_project_add;
				
				
							ModelYearRNGProduction := sum( (proj_id, rng_type, reg) | annual_rng_capacity_flag(ModelYear, proj_id, rng_type) , rng_produced(proj_id, reg, rng_type ));
							RNGProduction_LCFS := LatestLCFSVolume + sum( (proj_id, rng_type, reg) | annual_rng_capacity_flag(ModelYear, proj_id, rng_type | proj_id in lcfs_projects ) , rng_produced(proj_id, reg, rng_type ));
						else
							break;
						endif;
				
					else 
						break;
					endif;
				
				
				
					endwhile;
				
				! If the D3 RFS Mandate has already been reached, then only look at projects that use LCFS credits
				while  CAVehicleCons > RNGProduction_LCFS and ModelYear > RNGYear do
					max_profit_from_project := max((proj_id, reg, rng_type), profit_lcfs(proj_id, reg, rng_type | proj_id in available_rng_projects and profit_lcfs(proj_id, reg, rng_type) > 0));
				
					if max_profit_from_project > 0 then
				
						! Use profit value to determine which project is associated with the profit value
						rng_project_add := Element({proj_id | Exists(((reg, rng_type)) | profit_lcfs(proj_id, reg, rng_type | proj_id in available_rng_projects) = max_profit_from_project ) }, 1);
				
						rng_project_add_type := Element({rng_type | Exists(((proj_id, reg)) | profit_lcfs(proj_id, reg, rng_type | proj_id in available_rng_projects) = max_profit_from_project )}, 1);
				
						annual_rng_capacity_flag(ModelYear, rng_project_add, rng_project_add_type) := 1;
						available_rng_projects -= rng_project_add;
						lcfs_projects += rng_project_add;
						AnnualLCFSProjects += rng_project_add;
				
						ModelYearRNGProduction := sum( (proj_id, rng_type, reg) | annual_rng_capacity_flag(ModelYear, proj_id, rng_type) , rng_produced(proj_id, reg, rng_type ));
						RNGProduction_LCFS := LatestLCFSVolume + sum( (proj_id, rng_type, reg) | annual_rng_capacity_flag(ModelYear, proj_id, rng_type | proj_id in lcfs_projects ) , rng_produced(proj_id, reg, rng_type ));
					else
						break;
					endif;
				
				endwhile;
				
				! Add to Annual Supply 
				if ModelYear > RNGYear then
				
					rng_lcfs_production(ModelYear) := RNGProduction_LCFS-LatestLCFSVolume;
					!rng_lcfs_totalCI_difference_from_target(ModelYear) := sum((proj_id, rng_type, reg), CI_difference_from_target(proj_id, reg, rng_type) | proj_id in lcfs_projects);
					! Convert from Bcf to MMBtu/ and then to MJ (look for conversion factor for this)
					! Reduces down to multiplying Bcf by ~1094.112682.
					! Dividy mass by 907200 to convert grams to tons.
					!rng_carbon_offset(ModelYear) := (rng_lcfs_totalCI_difference_from_target(ModelYear)* (rng_lcfs_production(ModelYear)*1094.112682))/907200/1000;
				
					AnnualRNGCarbonOffset(ModelYear) := sum( (proj_id, reg, rng_type), LCFS_carbon_offset_project(proj_id, reg, rng_type | proj_id in lcfs_projects)) + AnnualRNGCarbonOffset('2021');
				
					AnnualSupply(ModelYear, Supply_RNG, reg) := sum( (proj_id, rng_type) | annual_rng_capacity_flag(ModelYear, proj_id, rng_type) , rng_produced(proj_id, reg, rng_type )) + ANL_rng_historicalProductionAnnual(RNGYear,'food_waste', reg) + ANL_rng_historicalProductionAnnual(RNGYear,'WRRF', reg) ;
					LCFSProductionAnnual(ModelYear) :=  LatestLCFSVolume + sum( (proj_id, rng_type, reg) | annual_rng_capacity_flag(ModelYear, proj_id, rng_type | proj_id in lcfs_projects ) , rng_produced(proj_id, reg, rng_type ));
					Supply(modelyrmn, Supply_RNG, reg)  := AnnualSupply(MonthToYear(modelyrmn), Supply_RNG, reg) * NumberOfDaysInMonth(modelyrmn)/ NumberOfDaysInYear(MonthToYear(modelyrmn));
				
					! For debug/report page
					TotalAnnualRNGProduction(year) := sum(reg , AnnualSupply(year, Supply_RNG, reg));
					TotalAnnualRNGProductionType(year, rng_type) := sum( (proj_id, reg) | annual_rng_capacity_flag(year, proj_id, rng_type) , rng_produced(proj_id, reg, rng_type ));
				endif;
			}
		}
		Procedure Set_Historical_RNG_Capacity_old {
			Body: {
				
				
				! Calculate the amount of RNG, by type that history ends on
				!RNG_prod_last_historical_year(rng_type)(rng_type) := sum((datamon, h), ANL_rng_historicalProduction(datamon, h, rng_type | datamon = 'December, 2022'));
				
				! Calculate historical production by year
				ANL_rng_historicalProductionAnnual(datayear, rng_type, h) := sum((datamon) |map_month_year(datamon,datayear), ANL_rng_historicalProduction(datamon, h, rng_type));
				
				! Determine total natural gas production by type for last historical year
				! Remove hardcoding to dynamically select last RNG year
				RNG_prod_last_historical_year(rng_type) := sum((datayear, h), ANL_rng_historicalProductionAnnual(datayear, rng_type, h | datayear = '2022'));
				RNG_prod_last_historical_yearState(rng_type, h) := sum((datayear), ANL_rng_historicalProductionAnnual(datayear, rng_type, h | datayear = '2022'));
				
				historical_capacity_flag(proj_id) := 0;
				
				! Right now, this is just for landfills
				!rng_state_loop_iterator := Hubs_;
				!rng_state_loop_iterator := { reg | Exists((proj_id, rng_type), lcoe(proj_id, reg, rng_type)) } ;
				rng_state_loop_iterator := { h | Exists((rng_type | rng_type = 'landfill'), RNG_prod_last_historical_yearState(rng_type, h)) } ;
				for rng_state_loop_i do
					! Determine projects that are associated with a particular state
					! Each state will have certain projects associated with it given a certain type of RNG source
					! We will be looping through each of these projects, and turning the `historical_capacity_flag` to 1 UNTIL
					! the cumulative sum of what is produced annually from those projects is at least equal to what the historical production is for that state.
					! If the largest project is larger than what the state produced anually, then the largest project will be the first and only project turned on.
					projects_for_state := { proj_id | Exists((reg, rng_type), lcoe(proj_id, rng_state_loop_i, 'landfill')) } ;
					rng_loop_iterator := projects_for_state;
				
					for rng_loop_i do
				
						! rng_state_sum_temp is the rolling cumulative sum of RNG production from the projects associated with the state.
						rng_state_sum_temp := sum((proj_id, rng_type) | proj_id <= rng_loop_i, rng_produced(proj_id ,rng_state_loop_i, rng_type | rng_type = 'landfill' ));
				
						! IF the cumulative sum from the projects (including the project in question) is less than the historical RNG projection from the most recent year,
						! then set that project as active. (historical_capacity_flag to 1)
						if(rng_state_sum_temp <= RNG_prod_last_historical_yearState('landfill', rng_state_loop_i)) then
							historical_capacity_flag(rng_loop_i) := 1;
				
						! IF the cumulative sum of the projects (including the project in question) is more than the historical production AND we're only on the first project,
						! then set the first project as active and break out of the loop/move on to the next state 
						elseif( (rng_state_sum_temp > RNG_prod_last_historical_yearState('landfill', rng_state_loop_i) ) and
						rng_loop_i = Element(rng_loop_iterator, 1))  then
							historical_capacity_flag(rng_loop_i) := 1;
							break;
				
						! ! IF the cumulative sum of the projects (including the project in question) is more than the historical production and we're not on the first project
						! THEN break out of the loop and move on to the next state.
						elseif(rng_state_sum_temp > RNG_prod_last_historical_yearState('landfill', rng_state_loop_i)) then
							break;
						endif;
						endfor;
					endfor;
				
				!RNG_from_historical_capacity(reg) := sum( (proj_id, rng_type) | historical_capacity_flag(proj_id) , rng_produced(proj_id, reg, rng_type ));
				
				! Set initial projects online to 
				annual_rng_capacity_flag('2022', proj_id, 'landfill') := historical_capacity_flag(proj_id);
				
				! Now do farms
				historical_capacity_flag(proj_id) := 0;
				
				! Right now, this is just for landfills
				!rng_state_loop_iterator := Hubs_;
				!rng_state_loop_iterator := { reg | Exists((proj_id, rng_type), lcoe(proj_id, reg, rng_type)) } ;
				rng_state_loop_iterator := { h | Exists((rng_type | rng_type = 'farm'), RNG_prod_last_historical_yearState(rng_type, h)) } ;
				for rng_state_loop_i do
					! Determine projects that are associated with a particular state
					! Each state will have certain projects associated with it given a certain type of RNG source
					! We will be looping through each of these projects, and turning the `historical_capacity_flag` to 1 UNTIL
					! the cumulative sum of what is produced annually from those projects is at least equal to what the historical production is for that state.
					! If the largest project is larger than what the state produced anually, then the largest project will be the first and only project turned on.
					projects_for_state := { proj_id | Exists((reg, rng_type), lcoe(proj_id, rng_state_loop_i, 'farm')) } ;
					rng_loop_iterator := projects_for_state;
				
					for rng_loop_i do
				
						! rng_state_sum_temp is the rolling cumulative sum of RNG production from the projects associated with the state.
						rng_state_sum_temp := sum((proj_id, rng_type) | proj_id <= rng_loop_i, rng_produced(proj_id ,rng_state_loop_i, rng_type | rng_type = 'farm'));
				
						! IF the cumulative sum from the projects (including the project in question) is less than the historical RNG projection from the most recent year,
						! then set that project as active. (historical_capacity_flag to 1)
						if(rng_state_sum_temp <= RNG_prod_last_historical_yearState('farm', rng_state_loop_i)) then
							historical_capacity_flag(rng_loop_i) := 1;
				
						! IF the cumulative sum of the projects (including the project in question) is more than the historical production AND we're only on the first project,
						! then set the first project as active and break out of the loop/move on to the next state 
						elseif( (rng_state_sum_temp > RNG_prod_last_historical_yearState('farm', rng_state_loop_i) ) and
						rng_loop_i = Element(rng_loop_iterator, 1))  then
							historical_capacity_flag(rng_loop_i) := 1;
							break;
				
						! ! IF the cumulative sum of the projects (including the project in question) is more than the historical production and we're not on the first project
						! THEN break out of the loop and move on to the next state.
						elseif(rng_state_sum_temp > RNG_prod_last_historical_yearState('farm', rng_state_loop_i)) then
							break;
						endif;
						endfor;
					endfor;
				
				annual_rng_capacity_flag('2022', proj_id, 'farm') := historical_capacity_flag(proj_id);
				
				!RNG_from_historical_capacity(reg, rng_type) := sum( (proj_id) | historical_capacity_flag(proj_id) , rng_produced(proj_id, reg, rng_type ));
				
				RNG_from_historical_capacity(reg, rng_type) := sum( (proj_id) | annual_rng_capacity_flag('2022', proj_id, rng_type) , rng_produced(proj_id, reg, rng_type ));
				
				!
				!for rng_state_loop_i do
				!
				!	! Determine projects that are associated with a particular state
				!	projects_for_state := { proj_id | Exists((reg, rng_type), lcoe(proj_id, rng_state_loop_i, rng_type)) } ;
				!	rng_loop_iterator := projects_for_state;
				!
				!	project_id_ord_iterator := 1;
				!	rng_state_sum_temp := 0;
				!
				!
				!
				!	while(rng_state_sum_temp <= sum((proj_id, rng_type) | proj_id <= Element(projects_for_state,project_id_ord_iterator) , proj_rng(proj_id ,rng_state_loop_i, rng_type))) do
				!
				!		rng_state_sum_temp := sum((proj_id, rng_type) | proj_id <= Element(projects_for_state,project_id_ord_iterator), proj_rng(proj_id ,rng_state_loop_i, rng_type));
				!		if(rng_state_sum_temp <= RNG_prod_last_historical_yearState('landfill', rng_state_loop_i)) then
				!			historical_capacity_flag(Element(projects_for_state,project_id_ord_iterator)) := 1;
				!		elseif(rng_state_sum_temp > RNG_prod_last_historical_yearState('landfill', rng_state_loop_i)) then
				!			break;
				!		endif;
				!		project_id_ord_iterator += 1;
				!	endwhile;
				!endfor;
				!
				!RNG_from_historical_capacity(reg) := sum( (proj_id | historical_capacity_flag(proj_id)) , proj_rng(proj_id, reg, rng_type));
				!
				!
				!
				!
				!
				!
				!
				!	rng_sum_temp := sum((reg, proj_id) | proj_id <= rng_loop_i, proj_rng(proj_id, reg)) ;
				!	if (rng_sum_temp <= RNG_prod_last_historical_year('landfill') ) then
				!		historical_capacity_flag(rng_loop_i) := 1;
				!	elseif (rng_sum_temp >= RNG_prod_last_historical_year('landfill')) then
				!		break;
				!		endif;
				!	endfor;
				!
				! Set initial projects online to 
				!annual_rng_capacity_flag('2022', proj_id, 'landfill') := historical_capacity_flag(proj_id);
				!
			}
		}
		Procedure Set_Historical_RNG_Capacity {
			Body: {
				! Calculate the amount of RNG, by type that history ends on
				!RNG_prod_last_historical_year(rng_type)(rng_type) := sum((datamon, h), ANL_rng_historicalProduction(datamon, h, rng_type | datamon = 'December, 2022'));
				
				! Calculate historical production by year
				ANL_rng_historicalProductionAnnual(datayear, rng_type, h) := sum((datamon) |map_month_year(datamon,datayear), ANL_rng_historicalProduction(datamon, h, rng_type));
				
				! Determine total natural gas production by type for last historical year
				! Remove hardcoding to dynamically select last RNG year
				RNG_prod_last_historical_year(rng_type) := sum((datayear, h), ANL_rng_historicalProductionAnnual(datayear, rng_type, h | datayear = RNGYear));
				RNG_prod_last_historical_yearState(rng_type, h) := sum((datayear), ANL_rng_historicalProductionAnnual(datayear, rng_type, h | datayear = RNGYear));
				
				for rng_source_i do
				
					historical_capacity_flag(proj_id) := 0;
				
					! Right now, this is just for landfills
					!rng_state_loop_iterator := Hubs_;
					!rng_state_loop_iterator := { reg | Exists((proj_id, rng_type), lcoe(proj_id, reg, rng_type)) } ;
					rng_state_loop_iterator := { h | Exists((rng_type | rng_type = rng_source_i), RNG_prod_last_historical_yearState(rng_type, h)) } ;
					for rng_state_loop_i do
						! Determine projects that are associated with a particular state
						! Each state will have certain projects associated with it given a certain type of RNG source
						! We will be looping through each of these projects, and turning the `historical_capacity_flag` to 1 UNTIL
						! the cumulative sum of what is produced annually from those projects is at least equal to what the historical production is for that state.
						! If the largest project is larger than what the state produced anually, then the largest project will be the first and only project turned on.
						projects_for_state := { proj_id | Exists((reg, rng_type), lcoe(proj_id, rng_state_loop_i,rng_source_i)) } ;
						rng_loop_iterator := projects_for_state;
				
						for rng_loop_i do
				
							! rng_state_sum_temp is the rolling cumulative sum of RNG production from the projects associated with the state.
							rng_state_sum_temp := sum((proj_id, rng_type) | proj_id <= rng_loop_i, rng_produced(proj_id ,rng_state_loop_i, rng_type | rng_type = rng_source_i));
				
							! IF the cumulative sum from the projects (including the project in question) is less than the historical RNG projection from the most recent year,
							! then set that project as active. (historical_capacity_flag to 1)
							if(rng_state_sum_temp <= RNG_prod_last_historical_yearState(rng_source_i, rng_state_loop_i)) then
								historical_capacity_flag(rng_loop_i) := 1;
				
							! IF the cumulative sum of the projects (including the project in question) is more than the historical production AND we're only on the first project,
							! then set the first project that would be less than or equal to the current production level as active
							elseif( (rng_state_sum_temp > RNG_prod_last_historical_yearState(rng_source_i, rng_state_loop_i)) and
							rng_loop_i = Element(rng_loop_iterator, 1))  then
				
								! Find the proj_id that would at least be equal to the historical production
								smallest_allowable_proj := First(proj_id | rng_produced(proj_id | rng_produced(proj_id, rng_state_loop_i, rng_source_i) <= 
								RNG_prod_last_historical_yearState(rng_source_i, rng_state_loop_i),rng_state_loop_i, rng_source_i));
								historical_capacity_flag(proj_small) := 1;
								break;
				
							! ! IF the cumulative sum of the projects (including the project in question) is more than the historical production and we're not on the first project
							! THEN break out of the loop and move on to the next state.
							elseif(rng_state_sum_temp > RNG_prod_last_historical_yearState(rng_source_i, rng_state_loop_i)) then
								break;
							endif;
							endfor;
						endfor;
					! Set initial projects online to 
					annual_rng_capacity_flag(RNGYear, proj_id, rng_source_i) := historical_capacity_flag(proj_id);
				endfor;
				
				RNG_from_historical_capacity(reg, rng_type) := sum( (proj_id) | annual_rng_capacity_flag(RNGYear, proj_id, rng_type) , rng_produced(proj_id, reg, rng_type ));
			}
		}
		Procedure RNG_Initialize {
			Body: {
				read from file "input/ngrng.txt" in merge mode;
				read from file "input/lcoe.txt" in merge mode;
				
				! Intiailize LCFS Basline CI Target from GDS
				baseline_CI(NEMSmap_XYear(MNXYRS)) := LFMMOUT_LCFS_BaseLine('1', MNXYRS);
				
				!historical RNG production
				HistoricalSupply(mon, Supply_RNG, s) := sum((rng_type), ANL_rng_historicalProduction(mon, s, rng_type));
				HistoricalAnnualSupply(datayear, Supply_RNG, s) := sum((datamon) |map_month_year(datamon,datayear), HistoricalSupply(datamon, Supply_RNG, s));
				
				!HistoricalFoodWasteRNGProductionAnnual(year, s, rng_type) := 
				
				Supply(mon, Supply_RNG, s) := HistoricalSupply(mon, Supply_RNG, s);
				AnnualSupply(datayear, Supply_RNG, s) := HistoricalAnnualSupply(datayear, Supply_RNG, s);
				
				RNGProduction_LCFS := LatestLCFSVolume;
				
				! Convert D3 RIN/LCFS credit price, and  LCOE costs to 1987 dollars 
				D3_RIN_Price /= GDPPriceDeflator87(RIN_Price_Year);
				lcoe(proj_id, reg, rng_type) /= GDPPriceDeflator87(RIN_Price_Year);
				LCFS_credit_price /= GDPPriceDeflator87(LCFS_credit_price_year);
				
				! Convert MMcf/yr of supply curve to Bcf/yr
				! NOTE: NEED TO CHANGE CODE TO EXPORT TO BCF/YR PRIOR TO BEING READ INTO AIMMS
				!proj_rng(proj_id, reg, rng_type) := proj_rng(proj_id, reg, rng_type) / (1/0.001);
				
				! Convert MMcf/yr of supply curve to Bcf/yr
				rng_produced(proj_id, reg, rng_type) := rng_produced(proj_id, reg, rng_type) / (1/0.001);
				
				! Map distances to project IDs
				proj_distance(proj_id, reg, rng_type | lcoe(proj_id, reg, rng_type)) := distance(reg);
				
				! Map assumed CI to projects and multiply by the CI penalty per mile. Add CI adder for electricity generation mix source.
				proj_CI(proj_id, reg, rng_type | lcoe(proj_id, reg, rng_type)) := assumed_CI_base(rng_type) + proj_distance(proj_id, reg, rng_type) * CI_penalty_per_mile + CI_adder_from_elec(reg);
				
				Set_Historical_RNG_Capacity;
			}
		}
		DeclarationSection RNG_Declarations {
			Set non_modeled_rng_types {
				SubsetOf: rng_prod_type;
				Definition: rng_prod_type - 'food_waste' - 'WRRF';
			}
			ElementParameter RNGYear {
				Range: XYears_;
			}
			Parameter starting_rng {
				IndexDomain: rng_type;
			}
			ElementParameter Supply_RNG {
				Range: SupplyType_;
			}
			Parameter master_running_capacity_flag {
				IndexDomain: proj_id;
			}
			Parameter TotalAnnualRNGProduction {
				IndexDomain: year;
			}
			Parameter rng_production {
				IndexDomain: (year,reg);
			}
			Set rng_loop_iterator {
				SubsetOf: id;
				Index: rng_loop_i;
			}
			Parameter rng_sum_temp;
			Parameter landfill_potential_cumsum {
				IndexDomain: proj_id;
			}
			Set rng_prod_type {
				Index: rng_type;
			}
			Parameter ANL_rng_historicalProduction {
				IndexDomain: (datamon,h, rng_type);
			}
			Parameter current_rng_capacity {
				IndexDomain: reg;
			}
			Parameter rng_avg_spot_prc {
				IndexDomain: reg;
			}
			Set rng_avg_spot_price_years {
				SubsetOf: Years_;
				Index: rng_avg_year;
				Definition: {
					{'2030', '2031'}
				}
			}
			Parameter rng_capacity_install_flag {
				IndexDomain: proj_id;
			}
			Parameter EGE_to_MMBtu {
				Comment: "Assumed price of a D3 RIN in MMBtu";
			}
			Parameter EGE_to_MMcf;
		}
		DeclarationSection RIN_Declarations {
			Parameter RIN_credit_per_MMBtu {
				IndexDomain: (proj_id,reg,rng_type);
			}
			Parameter RIN_volumes_needed;
			Parameter Last_RIN_Mandate_Volume;
			ElementParameter Last_RIN_Mandate_Year {
				Range: Years_;
			}
			Parameter new_RNG_from_RIN_flag {
				IndexDomain: proj_id;
				Range: binary;
			}
			Parameter RNG_RIN_flag {
				IndexDomain: proj_id;
			}
			Parameter D3_RIN_Price;
			Parameter RIN_D3_Mandate_MMcf {
				IndexDomain: year;
			}
			Parameter RIN_D3_Mandate {
				IndexDomain: year;
			}
			Parameter RIN_D3_Mandate_Bcf {
				IndexDomain: year;
			}
			ElementParameter RIN_Price_Year {
				Range: Years_;
			}
		}
	}
	Section DEX_Processing_Section {
		DeclarationSection DEX_Declarations {
			StringParameter fromAIMMSFolder;
			StringParameter toAIMMSFolder;
			Parameter ParquetWriteSwitch;
			Parameter ParquetReadSwitch;
		}
		Procedure SendGlobalDatatoNEMS_parquet {
			UsesRuntimeLibs: ParquetMappingToAIMMS;
			Body: {
				dex::AddMapping(mappingName : "ParquetMappingFromAIMMS",
						mappingFile : "Mappings/ParquetMappingFromAIMMS.xml");
				
				FromAIMMSFolder := "FromAIMMS/" + formatstring("%i",ncntrl_curcalyr(1)) + "_" + formatstring("%i",ncntrl_curitr(1)) + "/";
				
				dex::WriteToFile(
				    FromAIMMSFolder,                   ! location + name of the output file
				    "ParquetMappingFromAIMMS",                 ! mapping name
				    1                               ! use a pretty writer
				);
			}
		}
		Procedure ReadGlobalDataFromNEMS_parquet {
			UsesRuntimeLibs: ParquetMappingToAIMMS;
			Body: {
				dex::AddMapping(mappingName : "ParquetMappingToAIMMS",
						mappingFile : "Mappings/ParquetMappingToAIMMS.xml");
				
				
				! Write out the parquet files to a folder for the given year/iteration in the format ToAIMMS/YYYY_i/
				ToAIMMSFolder := "ToAIMMS/" + formatstring("%i",ncntrl_curcalyr(1)) + "_" + formatstring("%i",ncntrl_curitr(1)) + "/";
				
				dex::ReadFromFile(
				    toAIMMSFolder,                   ! location + name of the output file
				    "ParquetMappingToAIMMS",                 ! mapping name
				    1                               ! use a pretty writer
				);
			}
		}
		DeclarationSection SetsToWrite;
		Procedure Read_Parquet {
			Body: {
				!dex::AddMapping(mappingName : "ParquetMappingAll_Mike",
				!		mappingFile : "Mappings/ParquetMappingAll_Mike.xml");
				
				
				!empty COMMREP_DegreeDays;
				!empty QBLK_QGFIN;
				
				!empty GDS_Identifiers_;
				
				!dex::ReadFromFile("COMMREP_DegreeDays.parquet",
				!"COMREP_DegreeDaysMapping",
				!);
				
				! Read parquet file
				!dex::ReadFromFile(
				!dataFile : "parquet_files",
				!mappingName : "ParquetMappingAll_Mike");
				
				! Read text file (current status quo)
				!read from file "ToAimms/GlobalDataToAIMMS_2050_05.txt";
				
				! Write the parquet files
				!dex::WriteToFile(
				!    "written_parquet_files",                   ! location + name of the output file
				!    "ParquetMappingAll_Mike",                 ! mapping name
				!    0                               ! use a pretty writer
				!);
				
				!write GDS_Identifiers_ to file "written_parquet_files/GDS.txt";
				
				!SendGlobalDataToNEMS;
			}
		}
		Procedure DEX_Processing {
			Body: {
				!dex::ReadAllMappings();
				
				!dex::WriteToFile(
				!    "QBLK_QGFIN.csv",                   ! location + name of the output file
				!    "CSVMapping",                 ! mapping name
				!    1                               ! use a pretty writer
				!);
				
				!dex::WriteToFile(
				!    "QBLK_QGFIN.parquet",                   ! location + name of the output file
				!    "ParquetMapping",                 ! mapping name
				!    1                               ! use a pretty writer
				!);
				
				!dex::ReadFromFile("QBLK_QGFIN.parquet",
				!"ParquetMapping",
				!);
				
				!empty QBLK_QGFIN; 
				
				!dex::ReadFromFile("QBLK_QGFIN.csv",
				!"CSVMapping",
				!);
			}
		}
	}
	Procedure MainTermination {
		Body: {
			!return DataManagementExit();
			EnterMainTermination := CurrentToString("%c%y-%m-%d %H:%M:%S") +  " I'm Alive! AIMMS Entering MainTermination - " + FormatString("Cycle %i, ", CYCLEINFO_CURIRUN(1)) +
			formatstring("iteration %>02i, ",ncntrl_curitr(1)) +
			formatstring("%i, ",ncntrl_curcalyr(1));
			put ngStatusFile;
			put EnterMainTermination;
			putclose;
			
			sAction:="Exited";    ! Action message for NEMS
			write sAction to file NEMSMessageOutFile in replace mode;  
			return 1;
		}
	}
	Section Offline_Model_Input_Processing {
		Section Pipeline_Capacity_Processing {
			Procedure Run_CapacityDataProcessing {
				Body: {
					!Clear out old data series to avoid confusion
					empty Cleared_Identifiers_ ;
					
					Read_Runtime_Parameters;
					Read_set_data;	                        !Reads all main sets used to create "NLP Structure"
					ReadPipelineProjects;			!Reads EIA_NaturalGasPipelineProjects.xls file from input directory outside of project directory
					ReadStateToStateCapacity;		!Reads EIA_StatetoStateCapacity.xls file from input directory outside of project directory
					
					Adjustments_StateToStateCapacity;
					
					!Assign provinces and international points to border crossings
					for ((i,datayear,pipe,prov,st_to)|StateToStateCapacity(i,datayear,pipe,prov,st_to)) do
						ProvinceStateBorder(prov,st_to) := ArgMax(BX, sum(state,map_statename_state(st_to,state)*map_hubs_borderXings(state,BX)));
					endfor;
					for ((i,datayear,pipe,st_from,prov)|StateToStateCapacity(i,datayear,pipe,st_from,prov)) do
						ProvinceStateBorder(st_from,prov) := ArgMax(BX, sum(state,map_statename_state(st_from,state)*map_hubs_borderXings(state,BX)));
					endfor;
					
					!Calculate capacities by state and year
					HistoricalCapacity(h,h1,datayear) := sum((i,pipe,st_from,st_to)|
						map_statename_state(st_from,h) and map_statename_state(st_to,h1),
						StateToStateCapacity(i,datayear,pipe,st_from,st_to));
					
					HistoricalCapacity(h,bx,datayear) := sum((i,pipe,st_from,prov)|
						map_statename_state(st_from,h) and ProvinceStateBorder(st_from,prov)=bx,
						StateToStateCapacity(i,datayear,pipe,st_from,prov));
					
					HistoricalCapacity(bx,h1,datayear) := sum((i,pipe,prov,st_to)|
						ProvinceStateBorder(prov,st_to)=bx and map_statename_state(st_to,h1),
						StateToStateCapacity(i,datayear,pipe,prov,st_to));
					
					!Apply final adjustments
					Adjustments_HistoricalCapacity_Final;
					
					!Do Preprocessing for assigning planned capacities by identifying flow through hubs
					Calculate_ThroughStates;
					
					!Calculate last year of historical pipeline capacities
					LastHistoricalPipelineYear := ArgMax(datayear,Exists((i,pipe,st_from,st_to)|StateToStateCapacity(i,datayear,pipe,st_from,st_to)));
					
					!Assign capacity additions to Planned Capacity parameter; only for years greater than or equal to first model year
					for (proj|Proj_AddedCapacity(proj) and Proj_YearInService(proj) > LastHistoricalPipelineYear and Proj_Status(proj) ="Construction" or "Completed" or "Applied" or "Approved") do
						counter :=1;
						while (counter < Num_ThroughStates(proj)) do
							CapacityAddedByProject((proj,h,h1,Proj_YearInService(proj))|map_proj_reg_order(proj,h,counter) and map_proj_reg_order(proj,h1,counter+1)) := Proj_AddedCapacity(proj);
							counter +=1;
						endwhile;
					endfor;
					
					PlannedCapacity(h,h1,year) := sum(proj, CapacityAddedByProject(proj,h,h1,year));
					
					!write HistoricalCapacity(h,h1,datayear) to file "data/CapacitiesEIA.txt";
					put ngcapacity;
					display {HistoricalCapacity};
					display {PlannedCapacity};
					putclose ngcapacity;
				}
			}
			Section Pipeline_Projects_EIA {
				Procedure ReadPipelineProjects {
					Body: {
						!-- Reading from Excel file EIA_NaturalGasPipelineProjects.xlsx"
						
						WorkbookName := "input\\EIA_NaturalGasPipelineProjects.xlsx";
						!BLOCK
						if axll::WorkBookIsOpen(WorkbookName) then
							axll::SelectWorkBook(WorkbookName);
						else
							axll::OpenWorkBook(WorkbookName);
						endif;
						
						
						!Spreadsheet::SetActiveSheet( WorkbookName, "Regions" );
						axll::SelectSheet("Regions" );
						
						
						
						!Spreadsheet::RetrieveSet( WorkbookName, StateName_,   	"StateName", 	"Regions");
						!Spreadsheet::RetrieveSet( WorkbookName, ProvinceName_,	"ProvinceName",	"Regions");
						!Spreadsheet::RetrieveTable( Workbook : WorkbookName,
						 !                                  Parameter     : StateAbbrev(st_name),
						  !                                 DataRange     : "StateAbbrev",
						   !                                RowsRange     : "StateName",
						    !!                              AutomaticallyExtendSets : 1
						      !                         	);
						
						axll::ReadSet(
							SetReference	: StateName_,
							SetRange	: "A2:A90",
							ExtendSuperSets	: 1);
						
						axll::ReadSet(
							SetReference	: ProvinceName_,
							SetRange	: "E2:E9",
							ExtendSuperSets	: 1);
						
						axll::ReadList(
							IdentifierReference	: StateAbbrev(st_name),
							RowHeaderRange		: "A2:A90",
							DataRange		: "B2:B90");
						
						!Spreadsheet::RetrieveTable( Workbook : WorkbookName,
						!                                   Parameter     : ProvAbbrev(prov),
						!                                   DataRange     : "ProvAbbrev",
						!                                   RowsRange     : "ProvinceName",
						!                                   Sheet	: "Regions",
						!                                   AutomaticallyExtendSets : 1
						!                               	);
						
						axll::SelectSheet("Natural Gas Pipeline Projects" );
						
						
						!Spreadsheet::RetrieveSet( WorkbookName, Project_,   "Project", "Natural Gas Pipeline Projects"  );
						
						axll::ReadSet(
							SetReference	: Project_,
							SetRange	: "Project",
							ExtendSuperSets	: 1);
						
						!Spreadsheet::RetrieveTable( Workbook : WorkbookName,
						 !                                  Parameter     : Proj_Status(proj),
						  !                                 DataRange     : "Status",
						   !                                RowsRange     : "Project",
						    !                               Sheet	: "Natural Gas Pipeline Projects",
						     !                              AutomaticallyExtendSets : 1
						      !                         	);
						!Spreadsheet::RetrieveTable( Workbook : WorkbookName,
						 !                                  Parameter     : Proj_YearInService(proj),
						  !                                 DataRange     : "YearInService",
						   !                                RowsRange     : "Project",
						    !                               Sheet	: "Natural Gas Pipeline Projects",
						     !                              AutomaticallyExtendSets : 1
						      !                         	);
						!Spreadsheet::RetrieveTable( Workbook : WorkbookName,
						 !                                  Parameter     : Proj_ThroughStates(proj),
						  !                                 DataRange     : "ThroughStates",
						   !                                RowsRange     : "Project",
						    !                               Sheet	: "Natural Gas Pipeline Projects",
						     !                              AutomaticallyExtendSets : 1
						      !                         	);
						!Spreadsheet::RetrieveTable( Workbook : WorkbookName,
						 !!                                 DataRange     : "AddedCapacity",
						   !                                RowsRange     : "Project",
						    !                               Sheet	: "Natural Gas Pipeline Projects",
						     !                              AutomaticallyExtendSets : 1
						      !                         	);
						axll::ReadList(
							IdentifierReference	: Proj_Status(proj),
							RowHeaderRange		: "Project",
							DataRange		: "Status");
						
						axll::ReadList(
							IdentifierReference	: Proj_YearInService(proj),
							RowHeaderRange		: "Project",
							DataRange		: "YearInService");
						
						axll::ReadList(
							IdentifierReference	: Proj_ThroughStates(proj),
							RowHeaderRange		: "Project",
							DataRange		: "ThroughStates");
						
						axll::ReadList(
							IdentifierReference	: Proj_AddedCapacity(proj),
							RowHeaderRange		: "Project",
							DataRange		: "AddedCapacity");
						
						!Spreadsheet::CloseWorkbook( WorkbookName,0);
						axll::CloseWorkBook(WorkbookName);
						!ONERROR err DO
						!	CheckExcelError;
						!ENDBLOCK;
					}
				}
				Procedure Calculate_ThroughStates {
					Body: {
						!Calculate number of through states from the string containing all states
						Num_ThroughStates(proj) := (StringLength(Proj_ThroughStates(proj))+1)/3;
						
						!Remove AK projects; they are largely unknown and are not part of the QP
						for ((proj)|Proj_ThroughStates(proj)) do
							if (StringToElement(Regions_, SubString(Proj_ThroughStates(proj), 1,2)) = AKState) then
								Proj_AddedCapacity(proj) :=0;
								SetElementAdd(RemovedProject_, Element_Removed, proj);
							endif;
						endfor;
						
						!Clean up and out AK projects from file
						Project_ -= RemovedProject_;
						cleandependents Project_;
						
						!Calculate set of flow through states for each project; assign correct border crossing and international regions as well
						for ((proj)|Proj_AddedCapacity(proj)) do
							counter :=1;
							counter2 :=1;
							while (counter <= Num_ThroughStates(proj)) do
						
								if (StringToElement(Regions_, SubString(Proj_ThroughStates(proj), counter2, counter2+1))in Regions_ ) then
									ThroughStates(proj) += StringToElement(Regions_, SubString(Proj_ThroughStates(proj), counter2, counter2+1));
									map_proj_reg_order(proj, StringToElement(Regions_, SubString(Proj_ThroughStates(proj), counter2, counter2+1)),counter) :=1;
									counter +=1;
						
								else
									ThroughStates(proj) += First(bx| map_hubs_borderXings(ArgMax(reg,map_proj_reg_order(proj,reg,Last(set_order|map_proj_reg_order(proj,reg,set_order)))),bx));
									map_proj_reg_order((proj, bx,counter)|bx in ThroughStates(proj)) :=1;
									counter +=1;
									ThroughStates(proj) += First(r_int| Exists(bx|map_hubs_borderXings(r_int,bx) and bx in ThroughStates(proj)));
									map_proj_reg_order((proj, r_int,counter)|r_int in ThroughStates(proj)) :=1;
									counter +=1;
								endif;
								counter2 +=3;
							endwhile;
						endfor;
						
						!Add an additional flow through state to total number for border crossings
						Num_ThroughStates(proj|Exists(bx in ThroughStates(proj)))+=1;
					}
				}
				DeclarationSection Pipeline_Projects_Declarations {
					Set Project_ {
						Index: proj;
					}
					Set RemovedProject_ {
						SubsetOf: Project_;
					}
					ElementParameter Element_Removed {
						Range: RemovedProject_;
					}
					ElementParameter Element_Added {
						Range: Regions_;
					}
					Set StateName_ {
						SubsetOf: AllStateReads_;
						Index: st_name;
					}
					Set ProvinceName_ {
						SubsetOf: AllStateReads_;
						Index: prov;
					}
					StringParameter StateAbbrev {
						IndexDomain: st_name;
					}
					StringParameter Proj_Status {
						IndexDomain: proj;
					}
					StringParameter ProvAbbrev {
						IndexDomain: prov;
					}
					ElementParameter Proj_YearInService {
						IndexDomain: proj;
						Range: Years_;
					}
					StringParameter Proj_ThroughStates {
						IndexDomain: proj;
					}
					Parameter Proj_AddedCapacity {
						IndexDomain: proj;
					}
					Set ThroughStates {
						IndexDomain: proj;
						SubsetOf: Regions_;
					}
					Parameter map_proj_reg_order {
						IndexDomain: (proj,reg,set_order);
						Range: binary;
					}
					Parameter Num_ThroughStates {
						IndexDomain: proj;
					}
					Parameter CapacityAddedByProject {
						IndexDomain: (proj,h,h1,year);
					}
				}
			}
			Section State_To_State_Capacities {
				Procedure ReadStateToStateCapacity {
					Body: {
						!-- Reading from Excel file PemexHistoricalProduction.xlsm"
						
						WorkbookName := "input\\EIA_StatetoStateCapacity.xlsx";
						!BLOCK
						
						if axll::WorkBookIsOpen(WorkbookName) then
							axll::SelectWorkBook(WorkbookName);
						else
							axll::OpenWorkBook(WorkbookName);
						endif;
						
						!Spreadsheet::SetActiveSheet( WorkbookName, "State2StateAIMMS" );
						axll::SelectSheet("State2StateAIMMS" );
						
						
						!Spreadsheet::RetrieveSet( WorkbookName, RowCount_,   "RowCount");
						!Spreadsheet::RetrieveSet( WorkbookName, Pipeline_,   "Pipeline");
						!Spreadsheet::RetrieveSet( WorkbookName, StateFrom_,  "StateFrom");
						!Spreadsheet::RetrieveSet( WorkbookName, StateTo_,  "StateTo");
						
						axll::ReadSet(
							SetReference	: RowCount_,
							SetRange	: "A1:A17984",
							ExtendSuperSets	: 1);
						
						axll::ReadSet(
							SetReference	: Pipeline_,
							SetRange	: "C1:C17984",
							ExtendSuperSets	: 1);
						
						axll::ReadSet(
							SetReference	: StateFrom_,
							SetRange	: "D1:D17984",
							ExtendSuperSets	: 1);
						
						axll::ReadSet(
							SetReference	: StateTo_,
							SetRange	: "E1:E17984",
							ExtendSuperSets	: 1);
						
						!Spreadsheet::RetrieveTable( Workbook : WorkbookName,
						 !                                  Parameter     : StateToStateCapacity(i,year,pipe,st_from,st_to),
						  !                                 DataRange     : "CapacityData",
						   !                                RowsRange     : "CapacityRows",
						    !                               AutomaticallyExtendSets : 1
						     !                            ) ;
						
						!Spreadsheet::RetrieveTable( Workbook : WorkbookName,
						 !                                  Parameter     : flows_to_remove(pipe,st_from,st_to),
						  !                                 DataRange     : "RemoveData",
						   !                                RowsRange     : "RemoveRows",
						    !                               AutomaticallyExtendSets : 1
						     !                            ) ;
						
						!Spreadsheet::RetrieveTable( Workbook : WorkbookName,
						 !                                  Parameter     : flows_to_add(pipe,st_from,st_to),
						  !                                 DataRange     : "AddData",
						   !                                RowsRange     : "AddRows",
						    !                               AutomaticallyExtendSets : 1
						     !                            ) ;
						
						axll::ReadList(
							IdentifierReference	: StateToStateCapacity(i,year,pipe,st_from,st_to),
							RowHeaderRange		: "A1:E17984",
							DataRange		: "F1:F17984");
						
						axll::ReadList(
							IdentifierReference	: flows_to_remove(pipe,st_from,st_to),
							RowHeaderRange		: "J2:L9",
							DataRange		: "M2:M9");
						
						axll::ReadList(
							IdentifierReference	: flows_to_add(pipe,st_from,st_to),
							RowHeaderRange		: "J12:L13",
							DataRange		: "M12:M13");
						
						
						!Spreadsheet::CloseWorkbook( WorkbookName,0);
						
						axll::CloseWorkBook(WorkbookName);
						!ONERROR err DO
						!	CheckExcelError;
						!ENDBLOCK;
					}
				}
				Procedure Adjustments_StateToStateCapacity {
					Body: {
						!Calculate the additional capacity to add onto certain arcs after main processing is done.
						!This is only done for two pipelines (ANR, Trunkline) in one spot.  Two state flows are averaged (thus the 2 in the formula)
						!This may need revisiting if more capacity adjustments are done.
						
						!Also used to add on capacity that is bidirectional.  This is a temporary fix until the state-to-state capacity file is updated.
						
						CorrectedCapacity((datayear,pipe)|Exists((st_from,st_to)|flows_to_add(pipe,st_from,st_to))) :=
							sum ((i,st_from,st_to)|flows_to_remove(pipe,st_from,st_to),
								StateToStateCapacity(i,datayear,pipe,st_from,st_to)/2);
						
						
						!Correct for bidirectional capacity by assigning the reverse capacity
						!CorrectedCapacity((datayear,pipe)|Exists((st_from,st_to)|flows_bidirectional(pipe,st_from,st_to))) :=
							!sum ((i,st_from,st_to)|flows_bidirectional(pipe,st_from,st_to),
							!	StateToStateCapacity(i,datayear,pipe,st_from,st_to));
						
						
						
						!Clear out data for capacities and flows that are not truly going through state (i.e., snaking, across corner)
						
						for ((pipe,st_from,st_to)| flows_to_remove(pipe,st_from,st_to)) do
							empty StateToStateCapacity(i,datayear,pipe,st_from,st_to);
						endfor;
					}
				}
				Procedure Adjustments_HistoricalCapacity_Final {
					Body: {
						!Add the corrections calculated in Adjustments_StateToStateCapacity to final numbers
						HistoricalCapacity(h,h1,datayear) := HistoricalCapacity(h,h1,datayear) +
							sum((pipe,st_from,st_to)|map_statename_state(st_from,h) and map_statename_state(st_to,h1) and flows_to_add(pipe,st_from,st_to),
							CorrectedCapacity(datayear,pipe));
						
						!Assign capacities from US to border points across the border to Canada and Mexico
						HistoricalCapacity(bx,r_int,datayear) := sum (h|map_hubs_borderXings(h,bx) and map_hubs_borderXings(r_int,bx), HistoricalCapacity(h,bx,datayear));
						
						if (Exists((bx,state,datayear)|HistoricalCapacity(bx,state,datayear))) then
							HistoricalCapacity(r_int,bx,datayear) := sum (state|map_hubs_borderXings(state,bx) and map_hubs_borderXings(r_int,bx), HistoricalCapacity(bx,state,datayear));
						endif;
						
						!Remove intrastate pipelines if present (for example, CA)
						for ((h,h1)| h=h1) do
							empty HistoricalCapacity(h,h1,datayear);
						endfor;
					}
				}
				DeclarationSection StateToStateCapacity_Declarations {
					Set Pipeline_ {
						Index: pipe;
					}
					Set StateFrom_ {
						SubsetOf: AllStateReads_;
						Index: st_from;
					}
					Set StateTo_ {
						SubsetOf: AllStateReads_;
						Index: st_to;
					}
					Set AllStateReads_ {
						Index: all;
						Definition: StateFrom_ + StateTo_ + StateName_ + ProvinceName_;
					}
					Set RowCount_ {
						SubsetOf: Integers;
						Index: i, j;
					}
					Parameter StateToStateCapacity {
						IndexDomain: (i,year,pipe,st_from,st_to);
					}
					Parameter map_statename_state {
						IndexDomain: (st_name, state);
						Range: binary;
						Definition: {
							if StateAbbrev(st_name)= state then
							1
							endif;
						}
					}
					ElementParameter ProvinceStateBorder {
						IndexDomain: (st_from,st_to);
						Range: BorderCrossings_;
					}
					Parameter flows_to_remove {
						IndexDomain: (pipe,st_from,st_to);
						Range: binary;
					}
					Parameter flows_to_add {
						IndexDomain: (pipe,st_from,st_to);
						Range: binary;
					}
					Parameter CorrectedCapacity {
						IndexDomain: (datayear,pipe);
					}
					Parameter HistoricalCapacityOld {
						IndexDomain: (h,h1,datayear);
					}
					ElementParameter LastHistoricalPipelineYear {
						Range: XYears_;
					}
				}
			}
			DeclarationSection EIA_Capacity_Output_Declarations {
				File ngcapacity {
					Name: "data//ngcapacity.txt";
					Device: Disk;
					Mode: replace;
				}
			}
		}
		Section Canada_Pipeline_Capacity {
			Procedure Run_NEB_Capacities {
				Body: {
					!Clear out old data series to avoid confusion
					empty Cleared_Identifiers_ ;
					
					Read_set_data;	                        !Reads all main sets used to create "NLP Structure"
					Read_NEB_Capacities;
					
					!Transform indices into hubs and border crossings
					HistoricalFlowCanada(datamon,h_cn,h1_cn) := sum((city,trade_cn)|map_border_trade_h(city,trade_cn)=h_cn and map_border_trade_h1(city,trade_cn)=h1_cn ,
						FlowsCanada(datamon,city,trade_cn));
					
					HistoricalMonthlyCapacityCanada(datamon,h_cn,h1_cn) := sum((city,trade_cn)|map_border_trade_h(city,trade_cn)=h_cn and map_border_trade_h1(city,trade_cn)=h1_cn ,
						CapacityCanada(datamon,city,trade_cn));
					
					!Calculate annual values for report, debugging, and comparison purposes
					HistoricalAnnualFlowCanada(datayear,h_cn, h1_cn) := sum(datamon|map_month_year(datamon,datayear), HistoricalFlowCanada(datamon,h_cn,h1_cn) );
					
					HistoricalCapacityCanada(datayear,h_cn, h1_cn) := sum(datamon|map_month_year(datamon,datayear), HistoricalMonthlyCapacityCanada(datamon,h_cn,h1_cn))/12;
					
					!Map capacities and West to East Canada flows to historical arrays
					HistoricalFlowAnnual(CanadaWest,CanadaEast,datayear) := HistoricalAnnualFlowCanada(datayear,CanadaWest,CanadaEast);
					
					!HistoricalFlow
					HistoricalCapacity((h_cn,h1_cn, datayear)| map_use_NEB_capacity(h_cn,h1_cn)) := HistoricalCapacityCanada(datayear,h_cn, h1_cn);
					
					
					!Assign capacities from Canada border points to US
					HistoricalCapacity(bx,state,datayear) := sum (cn|map_hubs_borderXings(state,bx) and map_hubs_borderXings(cn,bx), HistoricalCapacity(cn,bx,datayear));
					HistoricalCapacity(state,bx,datayear) := sum (cn|map_hubs_borderXings(state,bx) and map_hubs_borderXings(cn,bx), HistoricalCapacity(bx,cn,datayear));
					
					!Assign capacity of first year where there's data to prior historical years
					if (Exists((h,h1,datayear)|HistoricalCapacity(h,h1,datayear))) then
						for ((h,h1,datayear)|HistoricalCapacity(h,h1,datayear)=0) do
							HistoricalCapacity(h,h1,datayear) := HistoricalCapacity(h,h1,FirstCapacityYear(h,h1));
						endfor;
					endif;
					
					!Write Input File
					write HistoricalCapacity to file "data/CapacitiesNEB.txt";
					write HistoricalFlowAnnual to file "data/CapacitiesNEB.txt" in merge mode;
					!write HistoricalCapacity and HistoricalFlowAnnual to file "data/CapacitiesNEB.txt";
					put CapacitiesNEB;
					display {HistoricalCapacity};
					display {HistoricalFlowAnnual};
					putclose CapacitiesNEB;
				}
			}
			Procedure Read_NEB_Capacities {
				Body: {
					!-- Reading from Excel file EIA_NaturalGasPipelineProjects.xlsx"
					
					WorkbookName := "..\\input\\NEB_PipelineFlows.xlsx";
					
					
					Spreadsheet::RetrieveSet( WorkbookName, BorderPoint_,   	"BorderPoint", "NEB_Pipelines");
					Spreadsheet::RetrieveSet( WorkbookName, TradeType_,	"TradeType",	"NEB_Pipelines");
					Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					                                   Parameter     : FlowsCanada(mon,city,trade_cn),
					                                   DataRange     : "Flow",
					                                   RowsRange     : "DataRows",
					                                   Sheet	: "NEB_Pipelines",
					                                   AutomaticallyExtendSets : 1
					                               	);
					
					Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					                                   Parameter     : CapacityCanada(mon,city,trade_cn),
					                                   DataRange     : "Capacity",
					                                   RowsRange     : "DataRows",
					                                   Sheet	: "NEB_Pipelines",
					                                   AutomaticallyExtendSets : 1
					                               	);
					
					Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					                                   Parameter     : map_border_trade_h(city,trade_cn),
					                                   DataRange     : "CN_map_h",
					                                   RowsRange     : "MapPoints",
					                                   Sheet	: "VLOOKUP",
					                                   AutomaticallyExtendSets : 1
					                               	);
					
					Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					                                   Parameter     : map_border_trade_h1(city,trade_cn),
					                                   DataRange     : "CN_map_h1",
					                                   RowsRange     : "MapPoints",
					                                   Sheet	: "VLOOKUP",
					                                   AutomaticallyExtendSets : 1
					                               	);
					
					Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					                                   Parameter     : map_use_NEB_capacity(h,h1),
					                                   DataRange     : "UseData",
					                                   RowsRange     : "UseRows",
					                                   Sheet	: "VLOOKUP",
					                                   AutomaticallyExtendSets : 1
					 				);
					
					Spreadsheet::CloseWorkbook( WorkbookName,0);
					!ONERROR err DO
					!	CheckExcelError;
					!ENDBLOCK;
				}
			}
			DeclarationSection Canada_Capacity_Declarations {
				Set BorderPoint_ {
					Index: city;
				}
				Set TradeType_ {
					Index: trade_cn;
				}
				Set CanadaHubs_ {
					SubsetOf: Hubs_;
					Index: h_cn, h1_cn;
					Definition: Canada_ + BorderCrossingsCN_;
				}
				ElementParameter map_border_trade_h {
					IndexDomain: (city,trade_cn);
					Range: Hubs_;
				}
				ElementParameter map_border_trade_h1 {
					IndexDomain: (city,trade_cn);
					Range: Hubs_;
				}
				Parameter FlowsCanada {
					IndexDomain: (mon,city,trade_cn);
				}
				Parameter CapacityCanada {
					IndexDomain: (mon,city,trade_cn);
				}
				Parameter HistoricalFlowCanada {
					IndexDomain: (datamon,h_cn,h1_cn);
				}
				Parameter HistoricalMonthlyCapacityCanada {
					IndexDomain: (datamon,h_cn,h1_cn);
				}
				Parameter HistoricalAnnualFlowCanada {
					IndexDomain: (datayear,h_cn,h1_cn);
				}
				Parameter HistoricalCapacityCanada {
					IndexDomain: (datayear,h_cn,h1_cn);
				}
				Parameter map_use_NEB_capacity {
					IndexDomain: (h,h1);
					Range: binary;
				}
				ElementParameter FirstCapacityYear {
					IndexDomain: (h,h1)|map_use_NEB_capacity(h,h1);
					Range: HistoricalDataYears_;
					Definition: First(datayear|HistoricalCapacity(h,h1,datayear));
				}
			}
			DeclarationSection NEB_Capacity_Output_Declarations {
				File CapacitiesNEB {
					Name: "data//CapacitiesNEB.txt";
					Device: Disk;
					Mode: replace;
				}
			}
		}
		Section Electric_Power_Data {
			Procedure Run_EIA_Power_Data {
				Body: {
					!Clear out old data series to avoid confusion
					empty Cleared_Identifiers_ ;
					
					Read_set_data;	                        !Reads all main sets used to create "NLP Structure"
					Initialize_EMM;
					
					Read_EIA_860_Data;
					Read_EIA_923_Data;
					
					Set_parameters;
					
					Calculate_Power_Data;
				}
			}
			DeclarationSection Display_Identifiers {
				ElementParameter Displayed_Fuel_Group {
					Range: Fuel_Group_;
				}
				ElementParameter Displayed_BalancingAuthority {
					Range: Balancing_Authority_;
				}
				ElementParameter Displayed_Energy_Source {
					Range: Energy_Source_;
				}
				ElementParameter Displayed_NERC_Region {
					Range: NERC_Region_;
				}
				Set Displayed_Plants_NERC {
					SubsetOf: Plant_ID_;
					Index: show_p_nerc;
					Definition: {
						{p|PlantRegion(p) = Displayed_NERC_Region}
					}
				}
				Set Displayed_Plants_BA {
					SubsetOf: Plant_ID_;
					Index: show_p_ba;
					Definition: {
						{p|PlantBA(p) = Displayed_BalancingAuthority}
					}
				}
			}
			Procedure Read_EIA_860_Data {
				Body: {
					!-- Reading from Excel file EIA_NaturalGasPipelineProjects.xlsx"
					
					WorkbookName := "..\\input\\EIA_860_AIMMS.xlsx";
					!BLOCK
					
					Spreadsheet::SetActiveSheet( WorkbookName, "Utility" );
					
					Spreadsheet::RetrieveSet( WorkbookName, Utility_ID_,   	"utility_id");
					
					Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					                                   Parameter     : Utility_Name(u),
					                                   DataRange     : "utility_name",
					                                   RowsRange     : "utility_id",
					                                   Sheet	: "Utility" ,
					                                   AutomaticallyExtendSets : 1
					                               	);
					Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					                                   Parameter     : UtilityState(u),
					                                   DataRange     : "st",
					                                   RowsRange     : "utility_id",
					                                   Sheet	: "Utility" ,
					                                   AutomaticallyExtendSets : 1
					                               	);
					
					Spreadsheet::SetActiveSheet( WorkbookName, "Plant" ) ;
					Spreadsheet::RetrieveSet( WorkbookName, Balancing_Authority_,   "ba" );
					Spreadsheet::RetrieveSet( WorkbookName,NERC_Region_ ,   "nerc" );
					
					
					Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					                                   Parameter     : Plant_Name(p),
					                                   DataRange     : "plant_name",
					                                   RowsRange     : "plant_id",
					                                   Sheet	: "Plant" ,
					                                   AutomaticallyExtendSets : 1
					                               	);
					
					Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					                                   Parameter     : PlantRegion(p),
					                                   DataRange     : "nerc",
					                                   RowsRange     : "plant_id",
					                                   Sheet	: "Plant" ,
					                                   AutomaticallyExtendSets : 1
					                               	);
					
					Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					                                   Parameter     : PlantBA(p),
					                                   DataRange     : "ba",
					                                   RowsRange     : "plant_id",
					                                   Sheet	: "Plant" ,
					                                   AutomaticallyExtendSets : 1
					                               	);
					
					Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					                                   Parameter     : PlantSector(p),
					                                   DataRange     : "sector",
					                                   RowsRange     : "plant_id",
					                                   Sheet	: "Plant" ,
					                                   AutomaticallyExtendSets : 1
					                               	);
					Spreadsheet::SetActiveSheet( WorkbookName, "map" ) ;
					Spreadsheet::RetrieveSet( WorkbookName,Sector_Name_ ,   "sec_name" );
					Spreadsheet::RetrieveSet( WorkbookName,Fuel_Technology_ ,   "tech_set" );
					Spreadsheet::RetrieveSet( WorkbookName, Energy_Source_,   "fuel" );
					
					Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					                                   Parameter     : map_utility_plant(u,p),
					                                   DataRange     : "map_ut_pl",
					                                   RowsRange     : "ut_pl",
					                                   Sheet	: "map" ,
					                                   AutomaticallyExtendSets : 1
					                               	);
					
					Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					                                   Parameter     : map_sector_sector_name(elsec,elsec_name),
					                                   DataRange     : "map_sec_info",
					                                   RowsRange     : "sec_info",
					                                   Sheet	: "map" ,
					                                   AutomaticallyExtendSets : 1
					                              	);  
					Spreadsheet::SetActiveSheet( WorkbookName, "Operable" ) ;
					
					Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					                                   Parameter     : Generator_Technology(p,g),
					                                   DataRange     : "tech",
					                                   RowsRange     : "generator",
					                                   Sheet	: "Operable" ,
					                                   AutomaticallyExtendSets : 1
									); 
					Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					                                   Parameter     : CapacityNameplate(p,g),
					                                   DataRange     : "cap_nameplate",
					                                   RowsRange     : "generator",
					                                   Sheet	: "Operable" ,
					                                   AutomaticallyExtendSets : 1
					                              	);  
					
					Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					                                   Parameter     : CapacitySummer(p,g),
					                                   DataRange     : "cap_summer",
					                                   RowsRange     : "generator",
					                                   Sheet	: "Operable" ,
					                                   AutomaticallyExtendSets : 1
					                              	);  
					
					Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					                                   Parameter     : GenerationFuel(p,g),
					                                   DataRange     : "fuel",
					                                   RowsRange     : "generator",
					                                   Sheet	: "Operable" ,
					                                   AutomaticallyExtendSets : 1
					                              	);                               	
					Spreadsheet::CloseWorkbook( WorkbookName,0);
					!ONERROR err DO
					!	CheckExcelError;
					!ENDBLOCK;
				}
			}
			Procedure Read_EIA_923_Data {
				Body: {
					!-- Reading from Excel file EIA_NaturalGasPipelineProjects.xlsx"
					
					WorkbookName := "..\\input\\EIA_923_AIMMS.xlsx";
					!BLOCK
					
					Spreadsheet::SetActiveSheet( WorkbookName, "sets" );
					
					!Spreadsheet::RetrieveSet( WorkbookName, Energy_Source_923_,   	"fuel");
					Spreadsheet::RetrieveSet( WorkbookName,Generator_Type_ ,   	"g_type");
					Spreadsheet::RetrieveSet( WorkbookName,Fuel_Type_ ,   	"fuel2");
					Spreadsheet::RetrieveSet( WorkbookName,Fuel_Group_ ,   	"fuel_group");
					
					Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					                                   Parameter     : map_energy_source_fuel_type(e,gen_fuel),
					                                   DataRange     : "map_both_fuels",
					                                   RowsRange     : "both_fuels",
					                                   Sheet	: "sets",
					                                   AutomaticallyExtendSets : 1
					                               	);
					Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					                                   Parameter     : map_energy_source_fuel_group(e,f),
					                                   DataRange     : "map_e_fuel",
					                                   RowsRange     : "e_fuel",
					                                   Sheet	: "sets",
					                                   AutomaticallyExtendSets : 1
					                               	);
					
					Spreadsheet::SetActiveSheet( WorkbookName, "data" ) ;
					
					Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					                                   Parameter     :Consumption_Gen_Thermal(p,g_type,e,mon) ,
					                                   DataRange     : "data_pu",
					                                   RowsRange     : "data_923",
					                                   ColumnsRange  : "col_pu",
					                                   AutomaticallyExtendSets : 1
					                                 ) ;
					
					Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					                                   Parameter     :Consumption_Gen(p,g_type,e,mon) ,
					                                   DataRange     : "data_gen",
					                                   RowsRange     : "data_923",
					                                   ColumnsRange  : "col_gen",
					                                   AutomaticallyExtendSets : 1
					                                 ) ; 
					
					Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					                                   Parameter     :Heat_Content(p,g_type,e,mon) ,
					                                   DataRange     : "data_hc",
					                                   RowsRange     : "data_923",
					                                   ColumnsRange  : "col_hc",
					                                   AutomaticallyExtendSets : 1
					                                 ) ; 
					
					Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					                                   Parameter     :Total_Fuel_MMBtu(p,g_type,e,mon) ,
					                                   DataRange     : "data_tot_fuel",
					                                   RowsRange     : "data_923",
					                                   ColumnsRange  : "col_tot_mmbtu",
					                                   AutomaticallyExtendSets : 1
					                                 ) ; 
					
					Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					                                   Parameter     :Total_Fuel_Gen_MMBtu(p,g_type,e,mon) ,
					                                   DataRange     : "data_tot_fuel_gen",
					                                   RowsRange     : "data_923",
					                                   ColumnsRange  : "col_tot_fuel_gen",
					                                   AutomaticallyExtendSets : 1
					                                 ) ; 
					
					Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					                                   Parameter     :NetGeneration_MWh(p,g_type,e,mon) ,
					                                   DataRange     : "data_el",
					                                   RowsRange     : "data_923",
					                                   ColumnsRange  : "col_el",
					                                   AutomaticallyExtendSets : 1
					                                 ) ; 
					Spreadsheet::SetActiveSheet( WorkbookName, "costs" ) ;
					
					Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					                                   Parameter     :PlantState(row,year,mn,p,e) ,
					                                   DataRange     : "pl_st",
					                                   RowsRange     : "rows_costs",
					
					                                   AutomaticallyExtendSets : 1
					                                 ) ;
					
					Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					                                   Parameter     :QuantityPurchased(row,year,mn,p,e) ,
					                                   DataRange     : "quantity",
					                                   RowsRange     : "rows_costs",
					
					                                   AutomaticallyExtendSets : 1
					                                 ) ;
					
					Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					                                   Parameter     :Ave_HeatContent(row,year,mn,p,e) ,
					                                   DataRange     : "hc_ave",
					                                   RowsRange     : "rows_costs",
					
					                                   AutomaticallyExtendSets : 1
					                                 ) ;
					
					Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					                                   Parameter     :FuelCost(row,year,mn,p,e) ,
					                                   DataRange     : "fuel_cost",
					                                   RowsRange     : "rows_costs",
					
					                                   AutomaticallyExtendSets : 1
					                                 ) ;
					
					Spreadsheet::CloseWorkbook( WorkbookName,0);
					!ONERROR err DO
					!	CheckExcelError;
					!ENDBLOCK;
				}
			}
			Procedure Calculate_Plant {
				Body: {
					count_temp(year,mn,p,f) := count((row,e)| FuelCost(row,year,mn,p,e) and map_energy_source_fuel_group(e,f));
					
					DeliveredFuel_MMBtu (mon,p,f):= sum((row,year,mn,e)|map_Month_MonthinYear(mon,mn) and map_month_year(mon,year) and map_energy_source_fuel_group(e,f),
						QuantityPurchased (row,year,mn,p,e)* Ave_HeatContent(row,year,mn,p,e));
					
					DeliveredFuelPrice(mon,p,f) := sum((year,mn)|map_Month_MonthinYear(mon,mn) and map_month_year(mon,year),
						sum((row,e)|map_energy_source_fuel_group(e,f),  
							FuelCost(row,year,mn,p,e)*QuantityPurchased (row,year,mn,p,e)* Ave_HeatContent(row,year,mn,p,e)));
					
					DeliveredFuelPrice(mon,p,f) := 0.01 * DeliveredFuelPrice(mon,p,f) /$ DeliveredFuel_MMBtu (mon,p,f);
					
					PlantCapacity(p,f) := sum((g,e)|GenerationFuel(p,g)=e and map_energy_source_fuel_group(e,f), CapacitySummer(p,g));
					
					PlantNetGeneration(mon,p,f) := sum((g_type,e)|map_energy_source_fuel_group(e,f), NetGeneration_MWh(p,g_type,e,mon));
					
					PlantCapacityFactor(mon,p,f) := PlantNetGeneration(mon,p,f)/$(PlantCapacity(p,f) *NumberOfDaysInMonth(mon) *24);
					
					PlantCapacityFactor_Annual(year,p,f) := sum(mon|map_month_year(mon,year), PlantNetGeneration(mon,p,f)) /$
						(PlantCapacity(p,f) *NumberOfDaysInYear(year) *24 );
				}
			}
			Procedure Calculate_State {
				Body: {
					DeliveredFuel_MMBtu_State(mon,state,f):= sum(p| map_plant_state(p,state), DeliveredFuel_MMBtu(mon,p,f ));
					
					DeliveredFuelPrice_State(mon,state,f) := sum(p| map_plant_state(p,state), DeliveredFuelPrice(mon,p,f ));
					
					DeliveredFuelPrice_State(mon,state,f) := 0.01 * DeliveredFuelPrice_State(mon,state,f) /$ DeliveredFuel_MMBtu_State(mon,state,f);
					
					StateCapacity(state,f) := sum(p| map_plant_state(p,state),PlantCapacity(p,f) );
					
					StateNetGeneration(mon,state,f) := sum(p| map_plant_state(p,state), PlantNetGeneration(mon,p,f ));
					
					CapacityFactor_State(mon,state,f) := StateNetGeneration(mon,state,f) /$(StateCapacity(state,f) *NumberOfDaysInMonth(mon) *24);
					
					CapacityFactor_State_Annual(year,state,f) := sum(mon|map_month_year(mon,year), StateNetGeneration(mon,state,f) ) /$
						(StateCapacity(state,f) *NumberOfDaysInYear(year) *24 );
				}
			}
			Procedure Calculate_NERC_EMM {
				Body: {
					NERC_DeliveredFuel_MMBtu(mon,nerc_name,f):= sum(p| map_plant_NERC_name(p,nerc_name), DeliveredFuel_MMBtu(mon,p,f ));
					
					DeliveredFuelPrice_NERC(mon,nerc_name,f) := sum(p| map_plant_NERC_name(p,nerc_name), DeliveredFuelPrice(mon,p,f ));
					
					DeliveredFuelPrice_NERC(mon,nerc_name,f) := 0.01 * DeliveredFuelPrice_NERC(mon,nerc_name,f) /$ NERC_DeliveredFuel_MMBtu(mon,nerc_name,f);
					
					NERCCapacity(nerc_name,f) := sum(p| map_plant_NERC_name(p,nerc_name),PlantCapacity(p,f) );
					
					NERCNetGeneration(mon,nerc_name,f) := sum(p| map_plant_NERC_name(p,nerc_name), PlantNetGeneration(mon,p,f ));
					
					NERCCapacityFactor(mon,nerc_name,f) := NERCNetGeneration(mon,nerc_name,f) /$(NERCCapacity(nerc_name,f) *NumberOfDaysInMonth(mon) *24);
					
					NERCCapacityFactor_Annual(year,nerc_name,f) := sum(mon|map_month_year(mon,year), NERCNetGeneration(mon,nerc_name,f) ) /$
						(NERCCapacity(nerc_name,f) *NumberOfDaysInYear(year) *24 );
				}
			}
			Procedure Set_parameters {
				Body: {
					map_utility_ba ((u,ba)|Exists(p|map_utility_plant(u,p) and PlantBA(p)=ba)) :=1;
					map_plant_state((p,state)|Exists(u|map_utility_plant(u,p) and UtilityState(u))) :=1;
					map_plant_NERC_name(p,NERC_name) := sum(ba|map_ba_NERC_Name(ba, nerc_name), map_plant_ba(p,ba) );
					!map_plant_NERC_name((p,NERC_name)|Exists((ba,state)|map_ba_state_nerc_name(ba,state,nerc_name))) := 
						!sum((ba,state)|map_ba_state_nerc_name(ba,state,nerc_name), map_plant_state(p,state));
				}
			}
			Procedure Calculate_Power_Data {
				Body: {
					Calculate_Plant;
					Calculate_State;
					Calculate_NERC_EMM;
				}
			}
			DeclarationSection Electric_Power_Sets {
				Set Plant_ID_ {
					SubsetOf: Integers;
					Index: p;
				}
				Set ElectricDataMonths_ {
					SubsetOf: Months_;
					Index: mon_e;
					Definition: {
						{mon|Exists((p,g_type,e)|NetGeneration_MWh(p,g_type,e,mon))}
					}
				}
				Set ElectricDataYears_ {
					SubsetOf: Years_;
					Index: year_e;
					Definition: {
						{year|Exists(mon_e|map_month_year(mon_e,year))}
					}
				}
				Set Fuel_Technology_ {
					Index: tech;
				}
				Set Sector_ID_ {
					SubsetOf: Integers;
					Index: elsec;
				}
				Set Sector_Name_ {
					Index: elsec_name;
				}
				Set Generator_ID_ {
					Index: g;
				}
				Set Utility_ID_ {
					SubsetOf: Integers;
					Index: u;
				}
				Set NERC_Region_ {
					Index: reg_nerc;
				}
				Set Energy_Source_ {
					Index: e;
				}
				Set Fuel_Type_ {
					Index: gen_fuel;
				}
				Set Fuel_Group_ {
					Index: f;
				}
				Set Balancing_Authority_ {
					Index: ba;
				}
				Set Generator_Type_ {
					Index: g_type;
				}
				Set Row_ {
					SubsetOf: Integers;
					Index: row;
				}
			}
			DeclarationSection NERC_Element_Parameters {
				ElementParameter MISO {
					Range: Balancing_Authority_;
				}
				ElementParameter PJM {
					Range: Balancing_Authority_;
				}
				ElementParameter SPP {
					Range: Balancing_Authority_;
				}
				ElementParameter NYISO {
					Range: Balancing_Authority_;
				}
				ElementParameter CAISO {
					Range: Balancing_Authority_;
				}
			}
			DeclarationSection Electric_Element_String_Parameters {
				StringParameter Plant_Name {
					IndexDomain: p;
				}
				ElementParameter Generator_Technology {
					IndexDomain: (p,g);
					Range: Fuel_Technology_;
				}
				ElementParameter PlantBA {
					IndexDomain: p;
					Range: Balancing_Authority_;
				}
				ElementParameter PlantRegion {
					IndexDomain: p;
					Range: NERC_Region_;
				}
				ElementParameter PlantSector {
					IndexDomain: p;
					Range: Electric_Sector_;
				}
				ElementParameter UtilityState {
					IndexDomain: u;
					Range: States_;
				}
				StringParameter Utility_Name {
					IndexDomain: u;
				}
			}
			DeclarationSection Electric_Mapping_Paramters {
				Parameter map_utility_plant {
					IndexDomain: (u,p);
					Range: binary;
				}
				Parameter map_sector_sector_name {
					IndexDomain: (elsec,elsec_name);
					Range: binary;
				}
				Parameter map_energy_source_fuel_type {
					IndexDomain: (e,gen_fuel);
					Range: binary;
				}
				Parameter map_energy_source_fuel_group {
					IndexDomain: (e,f);
					Range: binary;
				}
				Parameter map_plant_state {
					IndexDomain: (p,state);
					Range: binary;
				}
				Parameter map_plant_ba {
					IndexDomain: (p,ba)|PlantBA(p)=ba;
					Range: binary;
					Definition: 1;
				}
				Parameter map_plant_NERC_name {
					IndexDomain: (p,nerc_name);
					Range: binary;
				}
				Parameter map_NERC_name_ba {
					IndexDomain: (nerc_name,ba);
					Range: binary;
				}
				Parameter map_ba_NERC_Name {
					IndexDomain: (ba,nerc_name);
					Range: binary;
				}
				Parameter map_utility_ba {
					IndexDomain: (u,ba);
					Range: binary;
				}
				Parameter map_ba_state_nerc_name {
					IndexDomain: (ba,state,nerc_name);
					Range: binary;
				}
			}
			DeclarationSection Electric_Capacity {
				Parameter CapacityNameplate {
					IndexDomain: (p,g);
				}
				Parameter CapacitySummer {
					IndexDomain: (p,g);
				}
				ElementParameter GenerationFuel {
					IndexDomain: (p,g);
					Range: Energy_Source_;
				}
			}
			Section EIA_923_Data {
				DeclarationSection Fuel_Generation_Declarations {
					Parameter Consumption_Gen_Thermal {
						IndexDomain: (p,g_type,e,mon);
					}
					ElementParameter PlantState {
						IndexDomain: (row,year,mn,p,e);
						Range: States_;
					}
					Parameter Consumption_Gen {
						IndexDomain: (p,g_type,e,mon);
					}
					Parameter Heat_Content {
						IndexDomain: (p,g_type,e,mon);
					}
					Parameter Total_Fuel_MMBtu {
						IndexDomain: (p,g_type,e,mon);
					}
					Parameter Total_Fuel_Gen_MMBtu {
						IndexDomain: (p,g_type,e,mon);
					}
					Parameter NetGeneration_MWh {
						IndexDomain: (p,g_type,e,mon);
					}
				}
				DeclarationSection Fuel_Cost_Declarations {
					Parameter QuantityPurchased {
						IndexDomain: (row,year,mn,p,e);
					}
					Parameter Ave_HeatContent {
						IndexDomain: (row,year,mn,p,e);
					}
					Parameter FuelCost {
						IndexDomain: (row,year,mn,p,e);
					}
				}
			}
			DeclarationSection NERC_EMM_Level_Data {
				Parameter DeliveredFuelPrice_NERC {
					IndexDomain: (mon_e,nerc_name,f);
				}
				Parameter NERCCapacityFactor {
					IndexDomain: (mon_e,nerc_name,f);
				}
				Parameter NERCCapacityFactor_Annual {
					IndexDomain: (year_e,nerc_name,f);
				}
				Parameter NERCNetGeneration {
					IndexDomain: (mon_e,nerc_name,f);
				}
				Parameter NERC_DeliveredFuel_MMBtu {
					IndexDomain: (mon_e,nerc_name,f);
				}
				Parameter NERCCapacity {
					IndexDomain: (nerc_name,f);
				}
			}
			DeclarationSection State_Level_Data {
				Parameter DeliveredFuelPrice_State {
					IndexDomain: (mon_e,state,f);
				}
				Parameter CapacityFactor_State {
					IndexDomain: (mon_e,state,f);
				}
				Parameter CapacityFactor_State_Annual {
					IndexDomain: (year_e,state,f);
				}
				Parameter StateNetGeneration {
					IndexDomain: (mon_e,state,f);
				}
				Parameter DeliveredFuel_MMBtu_State {
					IndexDomain: (mon_e,state,f);
				}
				Parameter StateCapacity {
					IndexDomain: (state,f);
				}
			}
			DeclarationSection Plant_Level_Data {
				Parameter DeliveredFuelPrice {
					IndexDomain: (mon_e,p,f)|Exists((row,year,mn,e)|FuelCost(row,year,mn,p,e));
				}
				Parameter PlantCapacityFactor {
					IndexDomain: (mon_e,p,f)|Exists(g|CapacitySummer(p,g));
				}
				Parameter PlantCapacityFactor_Annual {
					IndexDomain: (year_e,p,f)|Exists(g|CapacitySummer(p,g));
				}
				Parameter PlantNetGeneration {
					IndexDomain: (mon_e,p,f)|Exists(g|CapacitySummer(p,g));
				}
				Parameter DeliveredFuel_MMBtu {
					IndexDomain: (mon_e,p,f)|Exists((row,year,mn,e)|FuelCost(row,year,mn,p,e));
				}
				Parameter count_temp {
					IndexDomain: (year,mn,p,f);
				}
				Parameter PlantCapacity {
					IndexDomain: (p,f);
				}
			}
		}
		Section CANSIM_Data {
			DeclarationSection CANSIM_Declarations;
		}
		Section Spot_Price_Processing {
			DeclarationSection Spot_Price_Processing_Declarations {
				Set PricingPoint_ {
					Index: pp, pp1, pp2;
				}
				Parameter map_reg_pricepoint {
					IndexDomain: (reg,pp);
					Range: binary;
				}
				ElementParameter RegionalPrice1 {
					IndexDomain: reg;
					Range: PricingPoint_;
				}
				ElementParameter RegionalPrice2 {
					IndexDomain: reg;
					Range: PricingPoint_;
				}
				ElementParameter RegionalPrice3 {
					IndexDomain: reg;
					Range: PricingPoint_;
				}
				Parameter DailySpotPrice {
					IndexDomain: (days,pp);
				}
				Parameter HistoricalSpotPrice2 {
					IndexDomain: (datamon,reg);
				}
				File ngspotprc_add {
					Name: "data//ngspotprc_add.txt";
					Device: Disk;
					Mode: replace;
				}
				ElementParameter FirstCalcYear {
					Range: XYears_;
				}
				Parameter CorrectionFactor {
					IndexDomain: (reg,mn);
				}
			}
			Procedure ReadMasterNGIPrices {
				Body: {
					!-- Reading from Excel file MasterNGIPrices.xlsx, which is the NGWU/NGI Master list of prices adapted to read into AIMMS
					
					
					WorkbookName := "input\\MasterNGIPrices.xlsx";
					!BLOCK
					if axll::WorkBookIsOpen(WorkbookName) then
						axll::SelectWorkBook(WorkbookName);
					else
						axll::OpenWorkBook(WorkbookName);
					endif;
					
					axll::SelectSheet("PricesNGMM" );
					
					
					!Read in set of pricing points
					!Spreadsheet::RetrieveSet( WorkbookName, PricingPoint_,   	"PricingPoint", 	"PricesNGMM");
					
					axll::ReadSet(
						SetReference	: PricingPoint_,
						SetRange	: "B2:B488512",
						ExtendSuperSets	: 1);
					
					!Read in daily spot prices for all trading points
					!Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					 !                                  Parameter     : DailySpotPrice(days,pp),
					  !                                 DataRange     : "PriceData",
					   !                                RowsRange     : "PriceRows",
					    !                               Sheet	 : "PricesNGMM",                                  
					     !                              AutomaticallyExtendSets : 1
					      !                           ) ;
					axll::ReadList(
						IdentifierReference	: DailySpotPrice(days,pp),
						RowHeaderRange		: "A2:B488512",
						DataRange		: "C2:C488512");
					
					!Read in the pricing points (up to 3) used for each hub/state/region/supply node
					
					axll::SelectSheet("StateHubs" );
					
					!Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					 !                                  Parameter     : RegionalPrice1(reg),
					  !                                 DataRange     : "Point1",
					   !                                RowsRange     : "Region",
					    !                               Sheet	: "StateHubs",
					     !                              AutomaticallyExtendSets : 1
					      !                         	);
					
					!Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					 !                                  Parameter     : RegionalPrice2(reg),
					  !                                 DataRange     : "Point2",
					   !                                RowsRange     : "Region",
					    !                               Sheet	: "StateHubs",
					     !                              AutomaticallyExtendSets : 1
					      !                         	);
					
					!Spreadsheet::RetrieveTable( Workbook : WorkbookName,
					 !                                  Parameter     : RegionalPrice3(reg),
					  !                                 DataRange     : "Point3",
					   !                                RowsRange     : "Region",
					    !                               Sheet	: "StateHubs",
					     !                              AutomaticallyExtendSets : 1
					      !                         	);                               	                             	
					axll::ReadList(
						IdentifierReference	: RegionalPrice1(reg),
						RowHeaderRange		: "A4:A111",
						DataRange		: "B4:B111");
					
					axll::ReadList(
						IdentifierReference	: RegionalPrice2(reg),
						RowHeaderRange		: "A4:A111",
						DataRange		: "C4:C111");
					
					axll::ReadList(
						IdentifierReference	: RegionalPrice3(reg),
						RowHeaderRange		: "A4:A111",
						DataRange		: "D4:D111");
					
					!Spreadsheet::CloseWorkbook( WorkbookName,0);
					axll::CloseWorkBook(WorkbookName);
				}
			}
			Procedure Run_SpotPricesProcessing {
				Body: {
					empty Cleared_Identifiers_ ;
					
					Read_Runtime_Parameters;
					Read_set_data;	                        !Reads all main sets used to create "NLP Structure"
					ReadMasterNGIPrices;
					
					!!set up mapping parameter
					map_reg_pricepoint((reg,pp)|RegionalPrice1(reg)=pp or RegionalPrice2(reg)=pp or RegionalPrice3(reg)=pp) :=1;
					
					!Determine first spot price year for updating calculations
					if TimeSlotCharacteristic(DayToMonth(first(days|Exists(pp|DailySpotPrice(days,pp)))),'month')=1  then
						FirstCalcYear := DayToYear(first(days|Exists(pp|DailySpotPrice(days,pp))));
					else
						FirstCalcYear := DayToYear(first(days|Exists(pp|DailySpotPrice(days,pp)))) + 1;
					endif;
					
					
					!Calculate straight average to obtain monthly prices
					HistoricalSpotPrice(datamon,reg) := sum((days,pp)|DayToMonth(days)=datamon and DayToYear(days)>=FirstCalcYear and map_reg_pricepoint(reg,pp), DailySpotPrice(days,pp))/$
										count((days,pp)|DayToMonth(days)=datamon and map_reg_pricepoint(reg,pp) and DailySpotPrice(days,pp));
					
					!Calculate straight average to obtain annual prices; only for full years
					HistoricalAnnualSpotPrice(datayear,reg) := sum (datamon|map_month_year(datamon, datayear) and datayear>=FirstCalcYear, HistoricalSpotPrice(datamon,reg)) /$
										count (datamon|map_month_year(datamon, datayear) and HistoricalSpotPrice(datamon,reg));
					
					!Fill in zeros for any missing data
					CorrectMissingSpotPrices;
					
					!Write out to temporary text file; merge this text file with existing ngspotprc.txt 
					put ngspotprc_add;
					display {HistoricalSpotPrice};
					display {HistoricalAnnualSpotPrice};
					putclose ngspotprc_add;
				}
			}
			Procedure CorrectMissingSpotPrices {
				Body: {
					CorrectionFactor(reg,mn) := sum(datamon|map_Month_MonthinYear(datamon,mn) and HistoricalSpotPrice(datamon,reg),  
									HistoricalSpotPrice(datamon,reg)/$ HistoricalAnnualSpotPrice(MonthToYear(datamon),reg))/$
									count(datamon|map_Month_MonthinYear(datamon,mn) and HistoricalSpotPrice(datamon,reg));
					
					
					for ((datamon,reg)|HistoricalSpotPrice(datamon,reg)=0) do
						HistoricalSpotPrice(datamon,reg) := sum(mn|map_Month_MonthinYear(datamon,mn), 
							CorrectionFactor(reg,mn)* HistoricalAnnualSpotPrice(MonthToYear(datamon),reg));
					endfor;
				}
			}
		}
		Section Pemex_Production_Data {
			Procedure Run_MexicoProduction {
				Body: {
					empty Cleared_Identifiers_ ;
					
					Read_Runtime_Parameters;	
					Read_set_data;	                        !Reads all main sets used to create "NLP Structure"
					
					!Read in historical data from PEMEX (SENER consumption and prices read in with rest of historical data in historical_reads
					Pemex_reads;
					
					!Process miscellaneous PEMEX historical production data
					
					!Subtract nitrogen from historical data array.  Note this may cause some discrepancies (nitrogen accounting started in 2007 and 2014)
					!Currently not doing this because correction to dry gas includes this adjustment
					!HistoricalData_PEMEX(mx_prod,Supply_AD, mon_pemex) -= HistoricalNitrogenPEMEX(mx_prod,mon_pemex);
					
					!Map Pemex data to months and sum over fields to apply to NGMM mexico regions
					HistoricalProductionPemex(mon, suptype,mx) := sum((mon_pemex,mx_field)|map_mon_pemex_mon(mon_pemex,mon) and map_mx_field_mx(mx_field,mx),
									HistoricalData_PEMEX(mx_field,suptype,mon_pemex));
					!Correct for reinjection, processing, lease/plant fuel here by subtracting the difference from MX_SS
					HistoricalProductionPemex(mon, Supply_AD,Mexico_SS) -= sum(mon_pemex|map_mon_pemex_mon(mon_pemex,mon),HistoricalAdjustmentPEMEX(mon_pemex));
					
					!Convert historical Pemex data from MMcf/d to Bcf/yr
					HistoricalProductionPemex(mon, suptype,mx) *= NumberOfDaysInMonth(mon)/1000;
					
					!Determine last month for which PEMEX historical data exists and determine LastHistoricalDataYear by testing if LastHistoricalDataMonth is December
					LastHistoricalDataMonth := Last(mon | Exists((naadgas,mx)|HistoricalProductionPemex(mon, naadgas,mx)));
					if (MonthToYear(LastHistoricalDataMonth)=MonthToYear(LastHistoricalDataMonth-11)) then
						LastHistoricalDataYear := MonthToYear(LastHistoricalDataMonth);
					else
						LastHistoricalDataYear := MonthToYear(LastHistoricalDataMonth)-1;
					endif;
					
					!Determine annual total production by region (will exclude LNG)
					HistoricalAnnualProductionPemex(hdatayear,mx) := sum((suptype,hdatamon)|map_month_year(hdatamon,hdatayear) ,HistoricalProductionPemex(hdatamon, suptype,mx));
					HistoricalTotalAnnualProductionPemex(hdatayear) := sum(mx, HistoricalAnnualProductionPemex(hdatayear,mx));
					
					
					!Write out to temporary text file; merge this text file with existing ngspotprc.txt 
					put ngmexico_add;
					display {HistoricalProductionPemex};
					display {HistoricalAnnualProductionPemex};
					display {HistoricalTotalAnnualProductionPemex};
					putclose ngmexico_add;
				}
			}
			Procedure Pemex_reads {
				Body: {
					! Replaced old PEMEX_code with new method on 8/11/21
					!-- Reading from Excel file PemexHistoricalProduction.xlsm"
					
					!Clear out old data series to avoid confusion
					empty Pemex_Production_Data ;
					
					WorkbookName := "input\\PemexHistoricalProduction.xlsm";
					!BLOCK
					
					!—Deals with reading workbook if it’s already open or closed
					if axll::WorkBookIsOpen(WorkbookName) then
					      axll::SelectWorkBook(WorkbookName);
					else
					      axll::OpenWorkBook(WorkbookName);
					endif;
					
					!-- Reading from worksheet "Mappings"
					axll::SelectSheet( "Mappings" ) ;
					
					axll::ReadSet(
					      SetReference      : Mexico_Production_Regions_,
					      SetRange    : "G2:G13",
					      ExtendSuperSets   : 1);
					axll::ReadSet(
					      SetReference      : Pemex_Regions_,
					      SetRange    : "K2:K5",
					      ExtendSuperSets   : 1);
					axll::ReadSet(
					      SetReference      : Pemex_Dates_,
					      SetRange    : "A3:A296",
					      ExtendSuperSets   : 1);
					
					!Determine set elements for Pemex_Fields
					Pemex_Fields_ := Mexico_Production_Regions_-Pemex_Regions_;
					
					!Read in mapping parameters.  Note must extend date range in excel and here
					axll::ReadList(
					      IdentifierReference     : map_mon_pemex_mon(mon_pemex,mon),
					      RowHeaderRange          : "A3:B296",
					      DataRange         : "C3:C296");
					axll::ReadList(
					      IdentifierReference     : map_mx_field_mx(mx_field, mx),
					      RowHeaderRange          : "G2:H13",
					      DataRange         : "I2:I13");
					
					!Change sheet to read in actual data
					axll::SelectSheet( "PemexProduction" );
					
					axll::ReadTable(
					      IdentifierReference     : HistoricalData_PEMEX(mx_prod,suptype,mon_pemex),
					      RowHeaderRange          : "A12:B38",
					      ColumnHeaderRange : "C6:KJ6",
					      DataRange         : "C12:KJ38",
					      ModeForUnknownElements  : 2,  !2=skip non-elements, 0-3 are options
					      MergeWithExistingData   : 0); !0=completely empty then write, 1=merge
					
					axll::ReadTable(
					      IdentifierReference     :  HistoricalNitrogenPEMEX(mx_prod,mon_pemex),
					      RowHeaderRange          : "A49:A54",
					      ColumnHeaderRange : "C6:KJ6",
					      DataRange         : "C49:KJ54",
					      ModeForUnknownElements  : 2,  !2=skip non-elements, 0-3 are options
					      MergeWithExistingData   : 0); !0=completely empty then write, 1=merge
					
					axll::ReadTable(
					      IdentifierReference     :  HistoricalAdjustmentPEMEX(mon_pemex),
					      RowHeaderRange          : "",
					      ColumnHeaderRange : "C6:KJ6",
					      DataRange         : "C56:KJ56",
					      ModeForUnknownElements  : 2,  !2=skip non-elements, 0-3 are options
					      MergeWithExistingData   : 0); !0=completely empty then write, 1=merge   
					
					
					axll::CloseWorkBook(WorkbookName);
					!ONERROR err DO
					!     CheckExcelError;
					!ENDBLOCK;
				}
			}
			DeclarationSection Pemex_Sets_and_Mappings_Declaration {
				Set Pemex_Fields_ {
					SubsetOf: Mexico_Production_Regions_;
					Index: mx_field;
					Comment: {
						"All field level data for Pemex; these are mapped to SENER/NGMM mexico regions using map_mx_field_mx"
					}
				}
				Set Pemex_Dates_ {
					Index: mon_pemex;
					Comment: {
						"Pemex-format for monthly dates; also used in SENER Miscellaneous Excel sheet, so PEMEX must be read in first"
					}
				}
				Set Mexico_Production_Regions_ {
					Index: mx_prod;
					Comment: "Includes both field-level data and the Pemex regions (4, not used by us).  This is used for mapping in order to minimize data processing in Excel/outside of AIMMS";
				}
				Set Pemex_Regions_ {
					SubsetOf: Mexico_Production_Regions_;
					Index: reg_pemex;
					Comment: "4 reporting regions for PEMEX";
				}
				Parameter map_mx_field_mx {
					IndexDomain: (mx_field,mx);
					Comment: {
						"Maps field-level data to SENER/NGMM regions of Mexico. Only Burgos (MX_NE) does not go to MX_SS.
						This is an approximation.  In reality, several fields overlap some regions.  There are minor amounts of associated gas production that go to MX_IW, MX_CE, and MX_NE.
						This level of detail is not necessary."
					}
				}
				Parameter map_mon_pemex_mon {
					IndexDomain: (mon_pemex,mon);
					Range: binary;
					Comment: "Converts PEMEX format to monthly dates used in NGMM";
				}
				File ngmexico_add {
					Name: "data//ngmexico_add.txt";
					Device: Disk;
					Mode: replace;
				}
			}
			DeclarationSection Mexico_Pemex_Data_Declarations {
				Parameter HistoricalNitrogenPEMEX {
					IndexDomain: (mx_prod,mon_pemex);
					Text: "Bcf/yr";
					Comment: {
						"read in as MMcf/d; converted to Bcf/yr
						Not currently being used in model because SENER reports reinjection/petroleum industry consumption with it included"
					}
				}
				Parameter HistoricalAdjustmentPEMEX {
					IndexDomain: (mon_pemex);
					Comment: {
						"read in as MMcf/d; converted to Bcf/yr
						Not currently being used in model because SENER reports reinjection/petroleum industry consumption with it included"
					}
				}
				Parameter HistoricalData_PEMEX {
					IndexDomain: (mx_prod,suptype,mon_pemex);
					Text: "MMcf/d";
					Comment: {
						"Raw data; should be equivalent to values in HistoricalProductionPemex (except regions are different)."
					}
				}
				Parameter HistoricalProductionPemex {
					IndexDomain: (mon,suptype,mx);
					Text: "Bcf/yr";
					Comment: "Reinjection fuel is subtracted at this level using SENER yearly data.";
				}
				Parameter HistoricalAnnualProductionPemex {
					IndexDomain: (year,mx);
					Text: "Bcf";
					Comment: "Excludes reinjected fuel.  Includes nitrogen.";
				}
				Parameter HistoricalTotalAnnualProductionPemex {
					IndexDomain: year;
				}
			}
		}
	}
}
