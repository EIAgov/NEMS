## ams_version=1.0

Model Main_EMM_renewable {
	Section EMMRenewable_Structure {
		DeclarationSection ER_sets {
			Set CanSteps {
				Index: CSteps;
				Definition: data { 1, 2, 3, 4, 5};
			}
			Set tech1 {
				Definition: data { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,23,24,25 };
			}
			Set EmmRe_hour {
				SubsetOf: Hour;
				Index: hr;
			}
			Set MonFirstHour {
				SubsetOf: EmmRe_hour;
				Index: hr1;
				Comment: "First hour of the day";
			}
			Set MonLastHour {
				SubsetOf: EmmRe_hour;
				Index: hrl;
				Comment: "Last hour of the day";
			}
			Set Year {
				Index: y;
				OrderBy: val(y);
			}
			Set Month {
				Index: m;
				OrderBy: val(m);
				Definition: {
					{1..12};
				}
			}
			Set ECP_Hour {
				Index: h;
				OrderBy: val(h);
			}
			Set Hour {
				Index: hh;
				Definition: {
					{1..8760}
				}
			}
			Set DayType {
				Index: d;
			}
			Set LoadGroup {
				Index: loadgp;
				Definition: {
					{1,2,3,4,5,6}
				}
				Comment: "EMM Load Group - used for EFD Storage SR output";
			}
			Set LoadSegment {
				Index: loadseg;
				Definition: {
					{1,2,3,4,5,6}
				}
				Comment: "EMM Load Segment - used for EFD Storage SR output";
			}
			Set CPGroup {
				Index: cpgp;
				Definition: {
					{1,2,3,4,5,6}
				}
				Comment: "ECP Load Group - used for ECP Storage SR output";
			}
			Set CPSegment {
				Index: cpseg;
				Definition: {
					{1,2,3,4,5,6}
				}
				Comment: "ECP Load Segment - used for ECP Storage SR output";
			}
			Set EMMReg1 {
				SubsetOf: EMMReg;
				Index: r;
				Definition: data { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,23,24,25 };
			}
			Set EMMReg {
				Index: r1;
				Definition: data { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,23,24,25, 26, 27, 28, 29, 30, 31, 32, 33};
			}
			Set EMMRegCan {
				SubsetOf: EMMReg;
				Index: rcan;
				Definition: data {29, 30, 31, 32, 33};
			}
			Set EMMRegCan_conn {
				SubsetOf: EMMReg;
				Index: rcan_conn;
				Definition: data {3, 5,7,9,23};
			}
			Set SubEMMReg {
				SubsetOf: EMMReg1;
				Index: rsub;
				Definition: {
					{1..25}
				}
			}
			Set Season {
				Index: s;
				Definition: {
					{1,2,3}
				}
			}
			Set ephrts_Season {
				Index: es;
				Definition: {
					{1,2,3,4}
				}
			}
			Set ECPtype {
				Index: tech;
				Definition: {
					{1..80}
				}
			}
			Set Storage_technology {
				SubsetOf: ECPtype;
				Index: ts;
				Definition: data { 67, 68, 69 };
			}
			Set Conventional_technology {
				SubsetOf: ECPtype;
				Index: tc;
				Definition: {
					data 
					    { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
					      33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 79, 80 }
				}
			}
			Set Renewable_technology {
				SubsetOf: ECPtype;
				Index: tr;
				Definition: data { 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 78 };
			}
			Set Intermittent_technology {
				SubsetOf: ECPtype;
				Index: ti;
				Definition: data { 70, 71, 72, 73, 74, 75, 76, 77 };
			}
			Set Hydro_technology {
				SubsetOf: Renewable_technology;
				Index: th;
				Definition: data { 61, 62 };
			}
			Set NonHydroRenewable_technology {
				SubsetOf: Renewable_technology;
				Index: tnh;
				Definition: data { 56, 57, 58, 59, 60, 63, 64, 66 };
			}
			Set Technologycode {
				Index: Techcode;
			}
			Set DayPerMon {
				Index: dm;
				OrderBy: dm;
				Comment: "Number of days per month to solve the problem.";
			}
			Set GenSteps {
				Index: Steps;
				OrderBy: steps;
			}
		}
		DeclarationSection New_Group_Sets {
			Set Ecptechgroup {
				SubsetOf: Ecpgroup;
				Index: pt;
				Definition: data{1..23};
			}
			Set Storage_Group {
				SubsetOf: Ecptechgroup;
				Index: pts;
				Definition: data { 11, 13, 21 };
			}
			Set Storage_noPV_Group {
				SubsetOf: Storage_Group;
				Index: ptn;
				Definition: data { 11, 13};
			}
			Set PVBatt_Group {
				SubsetOf: Storage_Group;
				Index: ptpvb;
				Definition: data {21};
			}
			Set Conventional_Group {
				SubsetOf: Ecptechgroup;
				Index: ptc;
				Definition: data { 1, 2, 3, 4, 5, 6, 15, 23 };
			}
			Set Renewable_Group {
				SubsetOf: Ecptechgroup;
				Index: ptr;
				Definition: data { 7, 8, 9, 10, 12, 22 };
			}
			Set Intermittent_Group {
				SubsetOf: Intermittent_PVBatt_Group;
				Index: pti;
				Definition: data { 14, 16, 17, 18, 19, 20 };
			}
			Set Intermittent_PVBatt_Group {
				SubsetOf: Ecptechgroup;
				Index: ptipv;
				Definition: data { 14, 16, 17, 18, 19, 20 ,21};
			}
			Set Solar_Group {
				SubsetOf: Intermittent_PVBatt_Group;
				Index: ptsol;
				Definition: data { 17, 18, 19, 20 ,21};
			}
			Set Solar_Group2 {
				SubsetOf: Solar_Group;
				Index: ptsol2;
				Definition: data { 17, 18, 19, 20 ,21};
			}
			Set Hydro_Group {
				SubsetOf: Renewable_Group;
				Index: pth;
				Definition: data {10 };
			}
			Set Ecpgroup {
				Index: pt_rep;
				Definition: data {1..23,Curtailment,Load,Unserved_Load};
			}
		}
		DeclarationSection ER_Mapping_Parameters {
			Parameter SW_OutputData;
			Parameter SW_trade {
				Definition: 1;
			}
			Parameter Map_ms {
				IndexDomain: (m,s);
				Comment: "Map Month to season";
			}
			Parameter Map_PeakMonth {
				IndexDomain: m;
			}
			Parameter Map_mes {
				IndexDomain: (m,es);
			}
			Parameter Map_Daypattern {
				IndexDomain: (m,d,dm);
			}
			Parameter Map_MonthHour {
				IndexDomain: (m,hr);
			}
			Parameter Map_SeasonHour {
				IndexDomain: (s,hr);
			}
			Parameter Map_EcpHour_Emmhour {
				IndexDomain: (hr,h);
			}
			Parameter Map_Daytype_Hour {
				IndexDomain: (d,hr);
			}
			Parameter Map_DmHour {
				IndexDomain: (dm,hr);
			}
			Parameter DummyMonHour {
				IndexDomain: (r,y,m,hr);
			}
			Parameter Map_EcpGroup {
				IndexDomain: (tech,pt);
			}
			Parameter Map_PlantSteps {
				IndexDomain: (pt,Steps);
			}
			Parameter a;
			Parameter b;
			Parameter TotalHour;
			Parameter Idaytq {
				IndexDomain: (m,d);
			}
			Parameter Idaytq_orig {
				IndexDomain: (m,d);
			}
			Parameter EMMGroup {
				IndexDomain: (r,y,m,d,h);
				Comment: "Mapping from hour to EMM load group";
			}
			Parameter EMMSegment {
				IndexDomain: (r,y,m,d,h);
				Comment: "Mapping from hour to EMM load segment";
			}
			Parameter Group_ECP {
				IndexDomain: (r,y,m,d,h);
			}
			Parameter Segment_ECP {
				IndexDomain: (r,y,m,d,h);
			}
			Parameter SW_RunDm {
				IndexDomain: (hr);
			}
			Parameter SW_RunDmM {
				IndexDomain: (m,d);
			}
		}
		DeclarationSection ER_Model_Parameters {
			Parameter SolarCurtailment {
				IndexDomain: (r,y,hr);
				Text: "GW";
			}
			Parameter TransLoss;
			Parameter NetTradeTS {
				IndexDomain: (reg,y,loadgp);
			}
			Parameter h2_turbine_generation {
				IndexDomain: (es,r);
			}
			Parameter TranLimitHr {
				IndexDomain: (r,r1,y,hr);
			}
			Parameter TranLimitCan {
				IndexDomain: (rcan,y,loadgp,loadseg,CSteps);
			}
			Parameter TradeCanLimit {
				IndexDomain: (rcan,y,hr,CSteps);
			}
			Parameter TranCost {
				IndexDomain: (r,r1,y,CSteps);
			}
			Parameter TranLimit {
				IndexDomain: (r,r1,y,s);
			}
			Parameter Load_EMMRen {
				IndexDomain: (r,y,hr);
				Text: "GW";
				Comment: "Hourly wholesale load demand in GW";
			}
			Parameter NetTrade {
				IndexDomain: (r,y,mm,d,h);
			}
			Parameter SolWinCapFactor_ER {
				IndexDomain: (r,y,hr,tech);
				Comment: "hourly solar and wind capacity factor";
			}
			Parameter HydroCapFactor {
				IndexDomain: (m,r);
				Comment: "Average capacity factor for hydro in month M";
			}
			Parameter ClipCapFactor_ER {
				IndexDomain: (r,y,hr,tech);
			}
			Parameter RampUp_Cost {
				IndexDomain: (ptc);
				Text: "$/MW";
				Comment: "Load change cost for increases for tech T in hour h in $/MW";
			}
			Parameter RampDown_Cost {
				IndexDomain: (ptc);
				Text: "$/MW";
				Comment: "Load change cost for decreases for tech T in hour h in $/MW";
			}
			Parameter Battery_ChargeCap {
				IndexDomain: (pts,r,y,Steps,hr);
				Text: "GW";
				Comment: "Charge capacity of storage technology TS in GW";
			}
			Parameter Battery_DischargeCap {
				IndexDomain: (pts,r,y,Steps,hr);
				Text: "GW";
				Comment: "Discharge capacity of storage technology TS in GW";
			}
			Parameter UNRGNS {
				Range: integer;
			}
			Parameter BatteryEfficiency {
				IndexDomain: pts;
				Comment: "Roundtrip efficiency of battery tech";
			}
			Parameter HourstoBuy;
			Parameter HourstoSell;
			Parameter RampRate {
				IndexDomain: (ptc);
				Comment: "Ramp rate of tech T";
			}
			Parameter DayPerMonth {
				IndexDomain: (m,d);
			}
			Parameter UnmetLoad_penalty {
				Text: "$/MW";
				Comment: "slack penalty";
			}
			Parameter lasthr;
			Parameter Dayweights {
				IndexDomain: hr;
			}
			Parameter SupplyPrice {
				IndexDomain: (r,s,pt,y,Steps);
				Text: "$/MWh";
			}
			Parameter SupplyCurve {
				IndexDomain: (r,s,pt,y,Steps);
				Text: "GW";
			}
			Parameter M864_LF {
				IndexDomain: (pt,Steps);
			}
			Parameter CapacityFactor {
				IndexDomain: (pt,y,r,Steps,hr);
			}
			Parameter HydroDispatchablePortion {
				IndexDomain: r;
				Text: "Hydro plant dispatchable part";
			}
			Parameter BatteryIncrement {
				IndexDomain: (y,r,pts);
			}
			Parameter Storagelvl_cost {
				Comment: "Prevent the storage lvl keep saving useless energy though the time.";
			}
			Parameter PVBatt_maxCF {
				IndexDomain: (y,reg,Steps,hr);
			}
			Parameter PVBattClipping {
				IndexDomain: (reg,y,hr);
				Text: "GW";
			}
			Parameter GenerationMaxTotal {
				IndexDomain: (ptpvb,y,reg,Steps,hr);
				Text: "GW";
			}
			Parameter DPVcap {
				IndexDomain: (y,reg);
			}
			Parameter DPVgen {
				IndexDomain: (y,reg);
			}
			Parameter Rep_curt_slice {
				IndexDomain: (y,pt,r,Steps,loadgp,loadseg);
			}
			Parameter TotGen {
				IndexDomain: reg;
			}
			Parameter TotGen2 {
				IndexDomain: reg;
			}
			Parameter TotGenNoDPV {
				IndexDomain: reg;
			}
			Parameter TotGenDPV {
				IndexDomain: reg;
			}
			StringParameter ReadinData;
			StringParameter OutputDir;
			ElementParameter NewStor {
				Range: Ecptechgroup;
			}
		}
		DeclarationSection ER_Variables {
			Variable TradeToFrom {
				IndexDomain: (r,rsub,y,hr);
				Range: nonnegative;
			}
			Variable TradeToFromCan {
				IndexDomain: (r,rcan,y,hr,CSteps);
				Range: nonnegative;
			}
			Variable RampUp {
				IndexDomain: (ptc,y,r,Steps,hr);
				Text: "GW";
				Range: nonnegative;
				Comment: "Operation increase GW of Tech T in hour h";
			}
			Variable RampDown {
				IndexDomain: (ptc,y,r,Steps,hr);
				Text: "GW";
				Range: nonnegative;
				Comment: "Operation decrease GW of Tech T in hour h";
			}
			Variable Storage_inflow {
				IndexDomain: (pts,y,r,Steps,hr);
				Text: "GW";
				Range: nonnegative;
				Comment: "Storage inflow in hour h in GW";
			}
			Variable Storage_outflow {
				IndexDomain: (pts,y,r,Steps,hr);
				Text: "GW";
				Range: nonnegative;
				Comment: "Storage outflow in hour h in GW";
			}
			Variable Storage_level {
				IndexDomain: (pts,y,r,Steps,hr);
				Text: "GWh";
				Range: nonnegative;
				Comment: "Energy level of storage tech T_S in hour h in GWh";
			}
			Variable Generation {
				IndexDomain: (pt,y,r,Steps,hr);
				Text: "GW";
				Range: nonnegative;
				Comment: "Operated capacity GW use of technology group T in hour h";
			}
			Variable unmet_Load {
				IndexDomain: (r,y,hr);
				Text: "GW";
				Range: nonnegative;
				Comment: "slack variable";
			}
		}
		DeclarationSection ER_Constraints {
			Variable Objectivefunction {
				Text: "1000$";
				Range: free;
				Definition: {
					
					sum((hr,reg),
					(sum((ptn,y,steps),0.5* sum(s| Map_SeasonHour(s, hr),SupplyPrice(reg, s, ptn, y, Steps))*(Storage_inflow(ptn, y, reg, Steps, hr)+Storage_outflow(ptn, y, reg, Steps, hr))
					+Storagelvl_cost*Storage_level(ptn, y, reg, Steps, hr))
					+sum((ptpvb,y,steps),1.0* sum(s| Map_SeasonHour(s, hr),SupplyPrice(reg, s, ptpvb, y, Steps))*(Storage_inflow(ptpvb, y, reg, Steps, hr)+Storage_outflow(ptpvb, y, reg, Steps, hr))
					+Storagelvl_cost*Storage_level(ptpvb, y, reg, Steps, hr))
					!using PV pricing for PV portion of PV+battery
					+ sum((ptc,y,steps), sum(s|Map_SeasonHour(s, hr),SupplyPrice(reg, s, ptc, y, Steps))*Generation(ptc, y, reg, Steps, hr))
					+ sum((ptr,y,steps), sum(s|Map_SeasonHour(s, hr),SupplyPrice(reg, s, ptr, y, Steps))*Generation(ptr, y, reg, Steps, hr))
					+ sum((ptipv,y,steps), sum(s|Map_SeasonHour(s, hr),SupplyPrice(reg, s, ptipv, y, Steps))*Generation(ptipv, y, reg, Steps, hr))
					+ sum((ptc,y,steps),RampUp_Cost(ptc)*RampUp(ptc, y, reg, Steps, hr)+ RampDown_Cost(ptc)*RampDown(ptc, y, reg, Steps, hr))
					+ sum((y),unmet_Load(reg, y, hr)*UnmetLoad_penalty)
					+ sum((y,rsub),TradeToFrom(reg,rsub,y,hr)*TranCost(reg,rsub,y,'1')) 
					+ sum((y,rcan,csteps),TradeToFromCan(reg,rcan,y,hr,CSteps)*TranCost(reg,rcan,y,CSteps)) 
					)*Dayweights(hr) | SW_RunDm(hr))
				}
			}
			Constraint Can_Trade_Limit {
				IndexDomain: (rcan,y,hr,CSteps)|TradeCanLimit(rcan,y,hr,CSteps)>0 and SW_RunDm(hr);
				Definition: TradeCanLimit(rcan,y,hr,CSteps) >= sum(rcan_conn,TradeToFromCan(rcan_conn,rcan,y,hr,CSteps));
			}
			Constraint Can_Trade_Limit2 {
				IndexDomain: (rcan_conn,rcan,y,hr)| TranLimitHr(rcan_conn,rcan,y,hr)>0 and SW_RunDm(hr);
				Definition: TranLimitHr(rcan_conn,rcan,y,hr) >= sum(CSteps,TradeToFromCan(rcan_conn,rcan,y,hr,CSteps));
			}
			Constraint Demand_balance {
				IndexDomain: (reg, y, hr)| SW_RunDm(hr);
				Property: ShadowPrice;
				Definition: {
					Load_EMMRen(reg, y, hr) <= 
					sum((ptc,steps)|Map_PlantSteps(ptc, Steps),Generation(ptc, y, reg, Steps,hr))
					+sum((ptr,steps)|Map_PlantSteps(ptr, Steps),Generation(ptr, y, reg, Steps,hr))
					+sum((pti,steps)|Map_PlantSteps(pti, Steps),Generation(pti, y, reg, Steps,hr))
					+sum((ptn,steps)|Map_PlantSteps(ptn, Steps),Storage_outflow(ptn, y, reg, Steps, hr)-Storage_inflow(ptn, y, reg, Steps, hr))
					+sum((ptpvb,steps)|Map_PlantSteps(ptpvb, Steps),Generation(ptpvb, y, reg, Steps,hr)+ Storage_outflow(ptpvb, y, reg, Steps, hr) ) !grid charging inflow only
					+ unmet_Load(reg, y, hr) 
					+ sum((rsub),TradeToFrom(reg,rsub,y,hr)*(1-TransLoss) - TradeToFrom(rsub,reg,y,hr)) !TradeToFrom(reg,r1,y,hr,CSteps)*(1-0.02)
					+ sum((rcan,CSteps),TradeToFromCan(reg,rcan,y,hr,CSteps)*(1-TransLoss))
					! imports - exports
				}
				Comment: "*sum((mm,d),Idaytq(mm, d)*Map_MonthHour(mm, hr)*Map_Daytype_Hour(d, hr))";
			}
			Constraint Gen_ramp {
				IndexDomain: (ptc, y, reg, Steps, hr)| NOT (Ord(hr,MonFirstHour) > 0) AND SW_RunDm(hr);
				Definition: Generation(ptc, y, reg, Steps, hr)= (Generation(ptc, y, reg, Steps, hr-1)+ RampUp(ptc, y, reg,Steps, hr)- RampDown(ptc, y, reg, Steps, hr));
			}
			Constraint FirstHour_gen_ramp {
				IndexDomain: (ptc,y,reg,Steps,hr)| (Ord(hr,MonFirstHour) > 0) AND SW_RunDm(hr);
				Definition: Generation(ptc, y, reg, Steps, hr)= (Generation(ptc, y, reg, Steps, hr+23)+ RampUp(ptc, y, reg,Steps, hr)- RampDown(ptc, y, reg, Steps, hr));
			}
			Constraint StorageBalance {
				IndexDomain: {
					(pts, y, reg, Steps, hr)
					| NOT (Ord(hr,MonFirstHour) > 0)AND SW_RunDm(hr)
				}
				Definition: {
					Storage_level(pts, y, reg, Steps,hr) = 
					(Storage_level(pts, y, reg, Steps,hr-1)
					+ BatteryEfficiency(pts)*Storage_inflow(pts, y, reg, Steps,hr)
					- Storage_outflow(pts, y, reg, Steps,hr))
				}
			}
			Constraint FirstHourStorageBalance2 {
				IndexDomain: (pts, y, reg, Steps, hr)| (Ord(hr,MonFirstHour) > 0) AND SW_RunDm(hr);
				Definition: {
					Storage_level(pts, y, reg, Steps,hr) = 
					Storage_level(pts, y, reg, Steps,hr+23)
					+ BatteryEfficiency(pts)*Storage_inflow(pts, y, reg, Steps,hr)
					- Storage_outflow(pts, y, reg, Steps,hr)
				}
			}
			Parameter Load {
				IndexDomain: (r,y,m,d,h);
				Text: "GW";
				Comment: "Hourly wholesale load demand GW from ECP";
			}
			Constraint Hydro_Gen_Cap {
				IndexDomain: (pth, y, reg, mm);
				Definition: {
					sum((hr,d)|Map_MonthHour(mm, hr) and Map_Daytype_Hour(d, hr) AND SW_RunDmM(mm,d),Generation(pth, y, reg, '1',hr)*Idaytq(mm, d)) <= 
					    sum(s|Map_ms(mm, s) ,HydroCapFactor(mm, reg)*SupplyCurve(reg, s, pth, y, '1'))*sum(d,Idaytq(mm, d)*SW_RunDmM(mm,d))*24
				}
			}
			Constraint PVBattery_balance {
				IndexDomain: (y,reg,Steps,hr) | SW_RunDm(hr);
				Definition: {
					Generation('21', y, reg, Steps,hr)  + Storage_outflow('21', y, reg, Steps, hr) <= PVBatt_maxCF(y,reg,Steps,hr)  !max generation (inverter capacity)
					!kW PV to grid + kW batt to grid + kW grid to batt <= inverter capacity kW
				}
			}
			Constraint PVBattery_balance2 {
				IndexDomain: (y,reg,Steps,hr) | SW_RunDm(hr);
				Definition: {
					!kW PV to grid + kW PV to Batt <= PV available (unclipped by inverter)
					Generation('21', y, reg, Steps,hr) + (Storage_inflow('21', y, reg, Steps, hr))  <=  
					GenerationMaxTotal('21',y,reg,Steps,hr)
				}
			}
			Constraint H2_Gen_Cap_max {
				IndexDomain: (es,reg,y);
				Definition: {
					sum((hr,d,m,s, Steps)| Map_mes(m, es) and Map_SeasonHour(s, hr) and Map_Daytype_Hour(d, hr) and Map_MonthHour(m, hr) and SW_RunDm(hr),
							Generation('15', y, reg, Steps ,hr)*Idaytq(m, d)) <=
							h2_turbine_generation(es,reg)
				}
			}
			Constraint H2_Gen_Cap_min {
				IndexDomain: (es,reg,y);
				Definition: {
					sum((hr,d,m,s, Steps)| Map_mes(m, es) and Map_SeasonHour(s, hr) and Map_Daytype_Hour(d, hr) and Map_MonthHour(m, hr) and SW_RunDm(hr),
							Generation('15', y, reg, Steps ,hr)*Idaytq(m, d)) >=
							h2_turbine_generation(es,reg)*(1.0-0.15)
				}
			}
			Constraint NetTransmission {
				IndexDomain: (reg,y,loadgp);
				Definition: {
					NetTradeTS(reg,y,loadgp) <= 
					0.001-sum((m,d,h,hr,rsub,CSteps)|Map_MonthHour(m, hr) and Map_Daytype_Hour(d,hr) and Map_EcpHour_Emmhour(hr,h) and EMMGroup(reg,y,m,d,h)=ORD(loadgp), 
						(TradeToFrom(reg,rsub,y,hr)*(1-TransLoss) - TradeToFrom(rsub,reg,y,hr))*IDAYTQ(m,d))
				}
				Comment: {
					"Net exports must balance
					!TradeToFrom(reg,r1,y,hr,CSteps)*(1-0.02)"
				}
			}
			Constraint NetTransmissionMin {
				IndexDomain: (reg,y,loadgp);
				Definition: {
					NetTradeTS(reg,y,loadgp) >= 
					-0.001-sum((m,d,h,hr,rsub,CSteps)|Map_MonthHour(m, hr) and Map_Daytype_Hour(d,hr) and Map_EcpHour_Emmhour(hr,h) and EMMGroup(reg,y,m,d,h)=ORD(loadgp), 
						(TradeToFrom(reg,rsub,y,hr)*(1-TransLoss) - TradeToFrom(rsub,reg,y,hr))*IDAYTQ(m,d))
				}
			}
		}
		DeclarationSection ER_Model_Structure {
			MathematicalProgram EMM_renewable {
				Objective: Objectivefunction;
				Direction: minimize;
				Constraints: EMM_Constraints;
				Variables: EMM_Variables;
				Type: LP;
			}
			Set EMM_Constraints {
				SubsetOf: AllConstraints;
				InitialData: {
					data 
					    { Objectivefunction       , Demand_balance          , Gen_ramp                , StorageBalance , FirstHour_gen_ramp         ,
					      FirstHourStorageBalance2,Hydro_Gen_Cap,Can_Trade_Limit, Can_Trade_Limit2, PVBattery_balance      , PVbattery_balance2, H2_Gen_Cap_max, H2_Gen_Cap_min}
				}
			}
			Set EMM_Variables {
				SubsetOf: AllVariables;
				Definition: {
					data 
					    { RampUp           , RampDown         , Storage_inflow   , Storage_outflow  , Storage_level    , Generation       ,
					      unmet_Load       , Objectivefunction, TradeToFrom, TradeToFromCan }
				}
			}
		}
	}
	Section Data_To_NEMS {
		DeclarationSection Rep_Parameters {
			Set Storage_rep {
				Index: Stor_rep;
				Definition: data {Charge,Discharge,Generation,Load};
			}
			Set StorageType {
				Index: Stor;
				Definition: data { Storage_In, Storage_Out };
			}
			Set SolveIndex {
				Index: k;
				Definition: data { 1, 2 };
			}
			Parameter SwitchSolve {
				IndexDomain: k;
				Definition: data { 2 : 1 };
			}
			Parameter Rep_NetExport {
				IndexDomain: (y,r,m,d,h);
			}
			Parameter Rep_Load {
				IndexDomain: (r,y,m,d,h);
				Definition: Load(r,y,m,d,h);
			}
			Parameter Rep_Generation {
				IndexDomain: (y,pt,r,Steps,m,d,h,k);
				Text: "GW";
			}
			Parameter Rep_GenerationUpper {
				IndexDomain: (y,pt,r,Steps,m,d,h,k);
				Text: "GW";
			}
			Parameter Rep_GenerationDelta {
				IndexDomain: (y,pt,r,Steps,m,d,h,k);
				Text: "GW";
			}
			Parameter Rep_Curtailment {
				IndexDomain: (y,pt,r,Steps,m,d,h,k);
				Text: "GW";
			}
			Parameter Rep_MarginalPrices {
				IndexDomain: (y,r,m,d,h,k);
				Text: "87$/MWh";
			}
			Parameter Rep_Storage {
				IndexDomain: (y,pts,r,Steps,m,d,h,Stor);
				Text: "GW";
			}
			Parameter Rep_StorageLevel {
				IndexDomain: (y,pts,r,Steps,m,d,h);
			}
			Parameter Rep_umet_Load {
				IndexDomain: (y,r,m, d, h,k);
				Text: "GW";
				Range: nonnegative;
				Comment: "slack variable";
			}
			Parameter Rep_Generation_wos {
				IndexDomain: (y,pt,r,m,d,h);
				Text: "GW";
			}
			Parameter Rep_Curtailment_wos {
				IndexDomain: (y,pt,r,m,d,h);
				Text: "GW";
			}
			Parameter Rep_MarginalPirces_wos {
				IndexDomain: (y,r,m,d,h);
				Text: "87$/MWh";
			}
			Parameter Rep_Storage_wos {
				IndexDomain: (y,pts,r,Steps,m,d,h,Stor);
				Text: "GW";
			}
			Parameter Rep_Gen_slice {
				IndexDomain: (y,pt,r,Steps,loadgp,loadseg);
				Text: "GWh";
				Comment: "debug calculating generation by EMM slice for comparison to EFD";
			}
			Parameter Rep_Sto_slice {
				IndexDomain: (y,pts,r,Steps,loadgp,loadseg);
				Text: "GWh";
				Comment: "debug calculating net storage gen by EMM slice for comparison to EFD";
			}
			Parameter Rep_Hours_per_slice {
				IndexDomain: (y,r,loadgp,loadseg);
				Text: "hours";
				Comment: "hours per EMM load group/segment";
			}
			Parameter Rep_Hours_per_CPslice {
				IndexDomain: (y,r,cpgp,cpseg);
				Comment: "hours per ECP load group/segment";
			}
			Parameter Rep_DischargeCap {
				IndexDomain: (y,pts,r,Steps,m,d,h);
				Comment: "Storage capacity";
			}
			Parameter Rep_Storage_sr {
				IndexDomain: (y,pts,r,Steps,m,d,h);
				Comment: "Storage available for spinning reserves. Only output for debug (not read directly into EMM)";
			}
			Parameter Rep_Sto_sr_CPSlice_frac {
				IndexDomain: (y,pts,r,Steps,cpgp,cpseg);
				Comment: "Storage available for spinning reserves as a fraction of capacity mapped to ECP slices";
			}
			Parameter Rep_Sto_sr_Slice_frac {
				IndexDomain: (y,pts,r,Steps,loadgp,loadseg);
				Comment: "Storage available for spinning reserves as a fraction of capacity mapped to EMM (EFD) slices";
			}
			Parameter Rep_TradeToFrom {
				IndexDomain: (y,r,r1,m,d,h,k);
			}
			Parameter Rep_Export_Slice {
				IndexDomain: (y,r,loadgp,loadseg);
			}
			Parameter Rep_Import_Slice {
				IndexDomain: (y,r,loadgp,loadseg);
			}
			Parameter Rep_NetExport_Slice {
				IndexDomain: (y,r,loadgp,loadseg);
			}
			Parameter Rep_output_all {
				IndexDomain: (y,pt_rep,h,Stor_rep);
			}
			Parameter Rep_output_seasonal {
				IndexDomain: (y,pt_rep,s,h,Stor_rep);
			}
			Parameter Rep_PVBattClipping {
				IndexDomain: (y,r,m,d,h,k);
			}
			Parameter Rep_Gen_Slice_frac {
				IndexDomain: (y,pt,r,Steps,m,d);
			}
			Parameter Rep_Curt_Slice_frac {
				IndexDomain: (y,pt,r,Steps,m,d);
			}
			Parameter Rep_Gen_Slice_frac_real {
				IndexDomain: (y,pt,r,Steps,loadgp,loadseg);
			}
			Parameter Rep_Curt_Slice_frac_real {
				IndexDomain: (y,pt,r,Steps,loadgp,loadseg);
			}
			Parameter ave_cap {
				IndexDomain: (r,pt,y,Steps,loadgp,loadseg);
			}
			Set M1_ {
				SubsetOf: Integers;
				Index: M1;
				InitialData: {
					{1..0001}
				}
			}
			Parameter RESTCODE {
				IndexDomain: (M1);
				Text: "SolverStaus, ProgramStatus combination return code, 0 is success";
			}
			File RETURNCODE {
				Name: "fromAIMMS/RETURNCODE.txt";
				Device: Disk;
				Mode: replace;
			}
			StringParameter CSVExportDllName {
				Definition: {
					if AimmsStringConstants('Architecture') = 'x86' then
					        "CSVExport.dll"
					else
					        "CSVExport64.dll"
					endif
				}
			}
		}
	}
	Section Data_From_UECP {
		DeclarationSection DataFrom_UECP {
			Parameter DailyPeakLoad {
				IndexDomain: (r,y,m,d);
				Comment: "Hourly wholesale load demand from ECP";
			}
			Parameter SolWindCapFactor {
				IndexDomain: (r,y,m,d,h,tech);
				Comment: "Solar and wind capacity factor from ecp";
			}
			Parameter ClipCapFactor {
				IndexDomain: (r,y,m,d,h,tech);
			}
			Parameter Map_techs {
				IndexDomain: (tech,Techcode);
			}
			Parameter SR_MAX_LF {
				IndexDomain: (tech,Techcode);
			}
			Parameter M864_TEC {
				IndexDomain: (tech,Techcode);
			}
		}
	}
	Section DebugSetup {
		DeclarationSection sub_emm {
			Set AcitveEMMReg {
				SubsetOf: EMMReg1;
				Index: reg;
				OrderBy: val(reg);
			}
			Set AcitveMonth {
				SubsetOf: Month;
				Index: mm;
				OrderBy: val(m);
				Definition: data { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 };
			}
		}
		DeclarationSection Debug_Parameters {
			ElementParameter yrselect {
				Range: Year;
			}
			ElementParameter grpselect {
				Range: GroupECP;
			}
			Set GroupECP {
				Index: techgro;
				Definition: data { Nuclear,Coal,Steam,CC,Biomass, Geother, MSW,FuelC, DistGen,Turbine,Hydro,Solar, Wind,OtherIn,P2,Storage_out };
			}
			Parameter Map_ptecpgroup {
				IndexDomain: (pt,techgro);
				Definition: {
					data 
					{ ( 1 , Coal    ) : 1,  ( 2 , Steam   ) : 1,  ( 3 , Turbine ) : 1,  ( 4 , CC      ) : 1,  ( 5 , FuelC   ) : 1,
					  ( 6 , Nuclear ) : 1,  ( 7 , Biomass ) : 1,  ( 8 , Geother ) : 1,  ( 9 , MSW     ) : 1,  ( 10, Hydro   ) : 1,
					  ( 12, P2      ) : 1,  ( 14, Wind    ) : 1,  ( 15, Wind    ) : 1,  ( 16, Wind    ) : 1,  ( 17, Solar   ) : 1,
					  ( 18, Solar   ) : 1,  ( 19, Solar   ) : 1,  ( 20, Solar   ) : 1,  ( 21, Solar   ) : 1,  ( 22, OtherIn ) : 1,
					  ( 23, DistGen ) : 1 }
				}
			}
			Parameter GenerationBy_ECPType {
				IndexDomain: (tech,y,hr,r);
			}
			Parameter GenerationBy_Group {
				IndexDomain: (techgro,y,hr,r);
			}
			Parameter HourlyShadowPrice {
				IndexDomain: (r,y,hr);
			}
			Parameter IntermittentCurtailment {
				IndexDomain: (pt,r,y,hr,Steps);
			}
			Parameter IntermittentCurtailment2 {
				IndexDomain: (pt,r,y,hr,Steps);
			}
			Parameter Tot_generation {
				IndexDomain: (pt,y,m,r,d);
			}
			Parameter Tot_Rep_Storage {
				IndexDomain: (y,pts,r,Steps,m,d,Stor);
				Text: "GW";
			}
			Parameter RE_Upperbound {
				IndexDomain: (pt,r,y,hr);
			}
			ElementParameter epselect {
				Range: SubEMMReg;
			}
		}
	}
	Procedure MainInitialization {
		Body: {
			Model_Prepare;
			!Solving_Model;
			Solve_Model_Fixed;
		}
	}
	Procedure Model_Prepare {
		Body: {
			empty Allparameters;
			! read data from NEMS
			!read in current year and input file
			read year from file "ECPYEAR.txt";
			ReadinData := "toAIMMS/ECPout_"+ first(year) +".txt";
			OutputDir := "fromAIMMS/Output_"+ first(year);
			if DirectoryExists(OutputDir) = 0 then
			    DirectoryCreate(OutputDir);
			endif;
			
			read Map_MS,Map_MES,Map_PlantSteps,SolWindCapFactor,HydroCapFactor,EMMGroup,EMMSegment,Group_ECP,Segment_ECP,Load,NetTrade,HourstoBuy,HourstoSell,SupplyPrice, SupplyCurve,Idaytq,Map_techs,BatteryEfficiency,M864_LF,BatteryIncrement,UNRGNS,ClipCapFactor,SW_OutputData, h2_turbine_generation, DPVcap,
				TranLimit, TranCost, TranLimitCan, TransLoss, Map_PeakMonth from file ReadinData;
			! read data from local files
			read Map_EcpGroup,RampRate,RampUp_Cost,RampDown_Cost,UnmetLoad_penalty,HydroDispatchablePortion from file "input/restprep.txt";
			AcitveEMMReg:= {r|val(r)<=UNRGNS};
			
			! do hour prep
			EmmRe_hour := {1..864} ; !576
			!EmmRe_hour :={1..576};
			
			!calculate the total number of hours in this model
			lasthr:= val(last(hr));
			
			!DayPerMon := {1 .. 2};
			DayType := {1 .. 3};
			DayPerMon := {1 .. 3};
			
			! map hours depending on daytypes
			MonLastHour:= {24 .. lasthr by 24} ; 
			MonFirstHour:= {1 .. lasthr by 24} ; 
			
			Map_Daypattern(m,'1','2') := 1;
			Map_Daypattern(m,'2','1') := 1;
			if (Val(Last(DayPerMon)) = 3) then
				Map_Daypattern(m,'3','3') := 1;
					endif;
			
			SW_RunDmM((m,d) | (Map_PeakMonth(m)=1 OR NOT d = last(DayType))) := 1;
			
			if SW_trade=0 then
				Load(r, y, mm, d, h):=Load(r, y, mm, d, h)+NetTrade(r, y, mm, d, h);
			endif;
			
			
			!load shape calculation,solar and wind hourly capacity factors calculation,Mapping Month and hour
			a:=1;
			for (mm,dm,h) do
				Map_DmHour((dm,hr)|ord(hr)=a) := 1 ;
				Load_EMMRen((r, y, hr)|ord(hr)=a) :=sum(d,Load(r, y, mm, d, h)*Map_Daypattern( mm, d, dm));
				SolWinCapFactor_ER((r, y, hr, tech)|ord(hr)=a) :=sum(d,SolWindCapFactor(r, y, mm, d, h, tech)*Map_Daypattern( mm, d, dm));
				ClipCapFactor_ER((r, y, hr, tech)|ord(hr)=a) := sum(d,ClipCapFactor(r, y, mm, d, h, tech)*Map_Daypattern( mm, d, dm));
				DummyMonHour((r,y,mm,hr)|ord(hr)=a) :=sum(d,Load(r, y, mm, d, h)*Map_Daypattern( mm, d, dm));
				SW_RunDm((hr)|ord(hr)=a AND (Map_PeakMonth(mm)=1 OR NOT dm = last(DayPerMon))):= 1;
			    a:=a+1;
			endfor;
			
			Map_MonthHour((mm, hr)|DummyMonHour(first(r), first(y), mm, hr)) := 1;
			Map_SeasonHour(s, hr) := sum(m|Map_MonthHour(m, hr), Map_ms(m, s));
			Map_Daytype_Hour(d,hr):= sum((dm,mm)|Map_Daypattern( mm, d, dm), Map_MonthHour(mm,hr)*Map_DmHour(dm, hr));
			
			!This mostly avoids storage cycling to avoid curtailment of intermittents (since it's more expensive than ints)... probably reflects cycling costs anyway.
			SupplyPrice(r, s, ptpvb, y, '1'):=0.001;
			
			!Add an increment storage capacity, Now using storage steps=2 to represent the increment storage capacity and cost
			SupplyPrice(r, s, pts, y, '2'):=SupplyPrice(r, s, pts, y, '1');
			
			!Add a small variable cost for solar, hydro and wind, which is used for the curtialment sequence.
			SupplyPrice(r, s, pth, y, '1'):=0.003;
			SupplyPrice(r, s, pth, y, '2'):=0.003;
			SupplyPrice(r, s, '14', y,'1'):=0.002;
			!SupplyPrice(r, s, '15', y,'1'):=0.002;
			SupplyPrice(r, s, '16', y,'1'):=0.002;
			SupplyPrice(r, s, '17', y, '1'):=0.001;
			SupplyPrice(r, s, '18', y, '1'):=0.001;
			SupplyPrice(r, s, '19', y, '1'):=0.001;
			SupplyPrice(r, s, '20', y, '1'):=0.001;
			SupplyPrice(r, s, '20', y, '2'):=0.0001;
			!warning: PV part of PV+battery (21) also uses PV (20) supply price.
			
			Storagelvl_cost := 0.00000001;
			
			!Map ecp hour with emm renewable hour
			a:= 1;
			b:= 1;
			for hr do
			if a<=lasthr then
			    if b = 25 then
			            b:=1;           
			            Map_EcpHour_Emmhour((hr, h)|val(hr) = a and val(h)= b):=1;
			    else
			            Map_EcpHour_Emmhour((hr, h)|val(hr) = a and val(h)= b):=1;
			    endif;
			a := a+1;
			b := b+1;
			endif;
			endfor;
			
			!Add peak day dayweight to the weekday dayweight
			Idaytq_orig(m,d) := Idaytq(m,d);
			!Idaytq(mm| not (mm in PeakMonths) OR (Val(Last(DayPerMon)) = 2), '1') := Idaytq(mm, '1')+Idaytq(mm, '3');
			Idaytq((mm,'1')| NOT SW_RunDmM(mm,'3')) := Idaytq(mm, '1')+Idaytq(mm, '3');
			Idaytq((mm,'3')| NOT SW_RunDmM(mm,'3')) := 0;
			
			!Calculate day weights for each hr
			Dayweights(hr) := sum((mm,d),Idaytq(mm, d)*Map_MonthHour(mm, hr)*Map_Daytype_Hour(d, hr)); !fix probably
			
			! Net trade coming from EFD (this is net exports)
			NetTradeTS(reg,y,loadgp) := sum((m,d,h)| EMMGroup(reg,y,m,d,h)=ORD(loadgp),
				NetTrade(reg,y,m,d,h)*IDAYTQ_orig(m,d));
			
			!Daily conventional plants generation capacity factor
			DailyPeakLoad(r, y, m, d):=max(h,Load(r, y, m, d, h));
			CapacityFactor(pt, y, reg, Steps, hr):=sum((m,d,h)|Map_MonthHour(m, hr) and Map_Daytype_Hour(d, hr) and Map_PlantSteps(pt, Steps) and Map_EcpHour_Emmhour(hr, h),
			M864_LF(pt, Steps)+(1-M864_LF(pt, Steps))*(Load(reg, y, m, d, h)$(Load(reg, y, m, d, h) > 0.0))/DailyPeakLoad(reg, y, m, d));
			
			!Add one more steps for hydro supply curve for flat dispatch
			SupplyCurve(r, s, '10', y, '2') := (1-HydroDispatchablePortion(r))*SupplyCurve(r, s, '10', y, '1');
			SupplyCurve(r, s, '10', y, '1') := HydroDispatchablePortion(r)*SupplyCurve(r, s, '10', y, '1');
			
			!TotGen(reg) := sum((mm,d,hr)|(Map_MonthHour(mm, hr) and Map_Daytype_Hour(d, hr)),Idaytq(mm,d)*sum((y,s,tech,Steps)|Map_SeasonHour(s, hr) and Map_EcpGroup(tech, '20') ,SupplyCurve(reg, s, '20', y, Steps)*SolWinCapFactor_ER(reg, y, hr, tech)));
			!TotGenNoDPV(reg) := sum(y,TotGen(reg)-DPVgen(y,reg));
			
			!SupplyCurve(reg, s, '20', y, '1') := max(0.1,SupplyCurve(reg, s, '20', y, '1') - DPVcap(y,reg)/1000);
			
			!SupplyCurve(reg, s, '20', y, '3') := SupplyCurve(reg, s, '20', y, '2') + SupplyCurve(reg, s, '20', y, '3');
			
			!SupplyCurve(reg, s, '20', y, '2') := SupplyCurve(reg, s, '20', y, '1');
			!SupplyCurve(reg, s, '20', y, '1') := SupplyCurve(reg, s, '20', y, '3');
			!SupplyCurve(reg, s, '20', y, '3') := 0.0;
			
			!TotGen2(reg) := sum((mm,d,hr)|(Map_MonthHour(mm, hr) and Map_Daytype_Hour(d, hr)),Idaytq(mm,d)*sum((y,s,tech,Steps)|Map_SeasonHour(s, hr) and Map_EcpGroup(tech, '20') ,SupplyCurve(reg, s, '20', y, Steps)*SolWinCapFactor_ER(reg, y, hr, tech)));
			!TotGenDPV(reg) := sum((mm,d,hr)|(Map_MonthHour(mm, hr) and Map_Daytype_Hour(d, hr)),Idaytq(mm,d)*sum((y,s,tech)|Map_SeasonHour(s, hr) and Map_EcpGroup(tech, '20') ,DPVcap(y,reg)/1000*SolWinCapFactor_ER(reg, y, hr, tech)));
			
			!SolWinCapFactor_ER(reg, y, hr, '76') := SolWinCapFactor_ER(reg, y, hr, '76') * TotGenNoDPV(reg)/TotGen2(reg);
			!SupplyCurve(reg, s, '20', y, '2') := DPVcap(y,reg)/1000;
			
			Map_PlantSteps('20','2') :=1;
		}
	}
	Procedure Solve_Model_Fixed {
		Body: {
			Empty Allvariables;
			option Bound_Tolerance := 1.0e-8;
			!option linear_presolve := off;
			!option postsolve_continuous_variables := "no_rounding";
			
			if SW_trade = 0 then
				TradeToFromCan(r,rcan,y,hr,CSteps) := 0;
				TradeToFromCan(r,rcan,y,hr,CSteps).nonvar:= 1; 
				TradeToFrom(r,rsub,y,hr) := 0;
				TradeToFrom(r,rsub,y,hr).nonvar:= 1; 
			
			endif;
			
			!Upper bound of all Units
			Generation(ptc, y, reg, Steps, hr).Upper := sum(s|Map_SeasonHour(s, hr),SupplyCurve(reg, s, ptc, y, Steps)*CapacityFactor(ptc, y, reg, Steps, hr));
			Generation(ptr, y, reg, Steps, hr).Upper := sum(s|Map_SeasonHour(s, hr),SupplyCurve(reg, s, ptr, y, Steps)*CapacityFactor(ptr, y, reg, Steps, hr));
			Generation(pth, y, reg, '2', hr).Upper := sum((s,mm)|Map_SeasonHour(s, hr) and Map_MonthHour(mm, hr) ,SupplyCurve(reg, s, pth, y, '2')*HydroCapFactor(mm, reg));
			Generation(ptipv, y, reg, Steps, hr).Upper := sum((s,tech)|Map_SeasonHour(s, hr) and Map_EcpGroup(tech, ptipv) ,SupplyCurve(reg, s, ptipv, y, Steps)*SolWinCapFactor_ER(reg, y, hr, tech));
			Generation(ptn, y, reg, Steps, hr).Upper := 0;
			
			!Generation('20', y, reg, '1', hr).Upper := sum((s)|Map_SeasonHour(s, hr),SupplyCurve(reg, s, '20', y, '1')*SolWinCapFactor_ER(reg, y, hr, '76'))*TotGenNoDPV(reg)/$TotGen2(reg);
			!Generation('20', y, reg, '2', hr).Upper := sum((s)|Map_SeasonHour(s, hr),SupplyCurve(reg, s, '20', y, '2')*SolWinCapFactor_ER(reg, y, hr, '76'))*DPVgen(y,reg)/$TotGenDPV(reg);
			
			TotGennoDPV(reg) := sum((mm,d,hr,y)|(Map_MonthHour(mm, hr) and Map_Daytype_Hour(d, hr)),Idaytq(mm,d)*Generation('20', y, reg, '1', hr).Upper);
			TotGenDPV(reg) := sum((mm,d,hr,y)|(Map_MonthHour(mm, hr) and Map_Daytype_Hour(d, hr)),Idaytq(mm,d)*Generation('20', y, reg, '2', hr).Upper);
			
			
			!this is the unclipped by the inverter CF ... GenerationMaxTotal, adding clipped back in
			GenerationMaxTotal(ptpvb,y,reg,Steps,hr) := sum((s,tech)|Map_SeasonHour(s, hr) and Map_EcpGroup(tech, ptpvb),SupplyCurve(reg, s, ptpvb, y, Steps)*(ClipCapFactor_ER(reg, y, hr, tech)+SolWinCapFactor_ER(reg, y, hr, tech))) ;
			PVBatt_maxCF(y,reg,Steps,hr) := sum((s,ptpvb)|Map_SeasonHour(s, hr),SupplyCurve(reg, s, ptpvb, y, Steps));
			
			RampUp(ptc, y, reg, Steps, hr).Upper := RampRate(ptc)*sum(s|Map_SeasonHour(s, hr),SupplyCurve(reg, s, ptc, y, Steps));
			RampDown(ptc, y, reg, Steps, hr).Upper := RampRate(ptc)*sum(s|Map_SeasonHour(s, hr),SupplyCurve(reg, s, ptc, y, Steps));
			
			TranLimitHr(r,r1,y,hr) := sum(s|Map_SeasonHour(s, hr),TranLimit(r,r1,y,s)); 
			!TradeToFrom(r,r1,y,hr,CSteps).Upper := 0;
			TradeToFrom(r,rsub,y,hr).Upper  := TranLimitHr(r,rsub,y,hr); !tranlimit is ToFrom, we want to switch to FromTo
			
			!TradeToFrom(r,r1,y,hr,csteps).Lower  := 0.0;
			TradeCanLimit(rcan,y,hr,CSteps) := 
				sum((m,d,h)|Map_MonthHour(m, hr) and Map_Daytype_Hour(d,hr) and Map_EcpHour_Emmhour(hr,h) , 
					sum(loadgp|EMMGroup('1',y,m,d,h)=ORD(loadgp), 
						TranLimitCan(rcan,y,loadgp,'1',CSteps)));
			TradeToFromCan(r,rcan,y,hr,CSteps).Upper  := min(TradeCanLimit(rcan,y,hr,CSteps), TranLimitHr(r,rcan,y,hr)); !TranLimitHr(r,rcan,y,hr);
			
			
			!Solving model without increment storage(switchsolve(k)=0)
			!Solving model with increment storage(switchsolve(k)=1)
			for k do
			    if SwitchSolve(k) = 0 then                              
			            SupplyCurve(r, s, pts, y, '2'):= 0;
			            Battery_ChargeCap(ptn, r, y, Steps, hr) := sum(s|Map_SeasonHour(s, hr),SupplyCurve(r, s, ptn, y, Steps));
			            Battery_DischargeCap(ptn, r, y, Steps, hr) := sum(s|Map_SeasonHour(s, hr),SupplyCurve(r, s, ptn, y, Steps));
			            Battery_ChargeCap(ptpvb, r, y, Steps, hr) := sum(s|Map_SeasonHour(s, hr),SupplyCurve(r, s, ptpvb, y, Steps)) / 3; !3 is storage cap fraction of inverter
			            Battery_DischargeCap(ptpvb, r, y, Steps, hr) := sum(s|Map_SeasonHour(s, hr),SupplyCurve(r, s, ptpvb, y, Steps)) / 3; !3 is storage cap fraction of inverter
			
				    Storage_level('13', y, reg, Steps, hr).Upper := sum(s|Map_SeasonHour(s, hr),SupplyCurve(reg, s, '13', y, Steps))*HourstoBuy;
			            Storage_level('11', y, reg, Steps, hr).Upper := sum(s|Map_SeasonHour(s, hr),SupplyCurve(reg, s, '11', y, Steps))*12;
			            Storage_level(ptpvb, y, reg, Steps, hr).Upper := sum(s|Map_SeasonHour(s, hr),SupplyCurve(reg, s, ptpvb, y, Steps))*HourstoBuy / 3; !3 is storage cap fraction of inverter
			
				    Storage_inflow(pts, y, reg, Steps, hr).Upper := Battery_ChargeCap(pts, reg, y, Steps, hr);
			            Storage_outflow(pts, y, reg, Steps, hr).Upper := Battery_DischargeCap(pts, reg, y, Steps, hr);
			
				    solve EMM_renewable;
			            PostMainInitialization_wos;     
			    else 
			            option Bound_Tolerance := 1.0e-6;
			            option postsolve_continuous_variables := 'Round to nearest bound';
			
			            SupplyCurve(r, s, pts, y, '2'):= BatteryIncrement(y, r, pts);
			            Battery_ChargeCap(ptn, r, y, Steps, hr) := sum(s|Map_SeasonHour(s, hr),SupplyCurve(r, s, ptn, y, Steps));
			            Battery_DischargeCap(ptn, r, y, Steps, hr) := sum(s|Map_SeasonHour(s, hr),SupplyCurve(r, s, ptn, y, Steps));    
			            Battery_ChargeCap(ptpvb, r, y, Steps, hr) := sum(s|Map_SeasonHour(s, hr),SupplyCurve(r, s, ptpvb, y, Steps)) / 3;
			            Battery_DischargeCap(ptpvb, r, y, Steps, hr) := sum(s|Map_SeasonHour(s, hr),SupplyCurve(r, s, ptpvb, y, Steps)) / 3;
			            Storage_level('13', y, reg, Steps, hr).Upper := sum(s|Map_SeasonHour(s, hr),SupplyCurve(reg, s, '13', y, Steps))*HourstoBuy;
			            Storage_level('11', y, reg, Steps, hr).Upper := sum(s|Map_SeasonHour(s, hr),SupplyCurve(reg, s, '11', y, Steps))*12;
			            Storage_level(ptpvb, y, reg, Steps, hr).Upper := sum(s|Map_SeasonHour(s, hr),SupplyCurve(reg, s, ptpvb, y, Steps))*HourstoBuy / 3;
			            Storage_inflow(pts, y, reg, Steps, hr).Upper := Battery_ChargeCap(pts, reg, y, Steps, hr);
			            Storage_outflow(pts, y, reg, Steps, hr).Upper := Battery_DischargeCap(pts, reg, y, Steps, hr);
			            !Fixed existing storage dispatch and trade
						TradeToFromCan(r,rcan,y,hr,CSteps).nonvar:= 1;  
						TradeToFrom(r,rsub,y,hr).nonvar:= 1;  
						Storage_inflow(pts, y, r, '1', hr).nonvar:=1;
						Storage_outflow(pts, y, r, '1', hr).nonvar:=1;
						Storage_level(pts, y, r, '1', hr).nonvar:=1;
			            solve EMM_renewable;
			            PostMainInitialization;         
			    endif;
			endfor;
			
			!Output national summary data for chart library. Only first and last RESTORE years.
			if SW_OutputData = 1 then
				Rep_output_all(y,pts,h,'Discharge'):= sum((m,d,r), Rep_Storage(y,pts,r,'1',m,d,h,'Storage_Out')*IDAYTQ_orig(m,d)/1000);
				Rep_output_all(y,pts,h,'Charge'):= sum((m,d,r), Rep_Storage(y,pts,r,'1',m,d,h,'Storage_In')*IDAYTQ_orig(m,d)/1000);
				Rep_output_all(y,'Curtailment',h,'Generation'):= sum((m,d,pt,r,Steps),Rep_Curtailment(y, pt, r, Steps,m, d, h, '1')*IDAYTQ_orig(m,d)/1000);
				Rep_output_all(y,pt,h,'Generation'):= sum((m,d,Steps,r), Rep_Generation(y,pt,r,Steps,m,d,h,'1')*IDAYTQ_orig(m,d)/1000);
				Rep_output_all(y,'Load',h,'Load'):= sum((m,d,r),Load(r, y, m, d, h)*IDAYTQ_orig(m,d)/1000);
				Rep_output_all(y,'Unserved_Load',h,'Load'):= sum((m,d,r,hr), Rep_umet_Load(y, r, m, d, h,'1')*IDAYTQ_orig(m,d)/1000);
			
				Rep_output_seasonal(y,pts,s,h,'Discharge'):= sum((m,d,r)| Map_ms(m,s), Rep_Storage(y,pts,r,'1',m,d,h,'Storage_Out')*IDAYTQ_orig(m,d)/1000);
				Rep_output_seasonal(y,pts,s,h,'Charge'):= sum((m,d,r)| Map_ms(m,s), Rep_Storage(y,pts,r,'1',m,d,h,'Storage_In')*IDAYTQ_orig(m,d)/1000);
				Rep_output_seasonal(y,'Curtailment',s,h,'Generation'):= sum((m,d,pt,r,Steps)| Map_ms(m,s),Rep_Curtailment(y, pt, r, Steps,m, d, h, '1')*IDAYTQ_orig(m,d)/1000);
				Rep_output_seasonal(y,'Load',s,h,'Load'):= sum((m,d,r)| Map_ms(m,s), Load(r, y, m, d, h)*IDAYTQ_orig(m,d)/1000);
				Rep_output_seasonal(y,pt,s,h,'Generation'):= sum((m,d,Steps,r)| Map_ms(m,s), Rep_Generation(y,pt,r,Steps,m,d,h,'1')*IDAYTQ_orig(m,d)/1000);
				Rep_output_seasonal(y,'Unserved_Load',s,h,'Load'):= sum((m,d,r,hr) | Map_ms(m,s), Rep_umet_Load(y, r, m, d, h,'1')*IDAYTQ_orig(m,d)/1000);
			
			endif;
			
			Rep_Hours_per_slice(y,r,loadgp,loadseg):=sum((m,d,h)|EMMGroup(r,y,m,d,h)=ORD(loadgp) and EMMSegment(r,y,m,d,h)=ORD(loadseg),IDAYTQ_orig(m,d));
			Rep_Hours_per_CPslice(y,r,cpgp,cpseg) :=sum((m,d,h)|Group_ECP(r,y,m,d,h)=ORD(cpgp) and Segment_ECP(r,y,m,d,h)=ORD(cpseg),IDAYTQ_orig(m,d));
			
			!Storage capacity
			Rep_DischargeCap(y,pts,r,Steps,m,d,h) := sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr),
								Battery_DischargeCap(pts, r, y, Steps, hr));
			!Rep_DischargeCap(y,pts,r,Steps,m,'3',h) := Rep_DischargeCap(y,pts,r,Steps,m,'1',h)	;
			
			!Available storage for spinning reserves
			Rep_Storage_sr(y,pts,r,Steps,m,d,h) := max(0,min(Rep_DischargeCap(y,pts,r,Steps,m,d,h),Rep_StorageLevel(y,pts,r,Steps,m,d,h) + Rep_Storage(y,pts,r,Steps,m,d,h,'Storage_In')*BatteryEfficiency(pts))
								- Rep_Storage(y,pts,r,Steps,m,d,h,'Storage_Out'));
			Rep_Storage_sr(y,ptpvb,r,'1',m,d,h) := min(Rep_DischargeCap(y,ptpvb,r,'1',m,d,h) * 3 - Rep_Generation(y, ptpvb, r, '1', m, d, h, '1'), Rep_Storage_sr(y,ptpvb,r,'1',m,d,h)) ;
			Rep_Storage_sr(y,ptpvb,r,'2',m,d,h) := min(Rep_DischargeCap(y,ptpvb,r,'1',m,d,h) * 3 - Rep_Generation(y, ptpvb, r, '1', m, d, h, '2'), Rep_Storage_sr(y,ptpvb,r,'1',m,d,h)) ;
			
			!these are temporary accounting for PV+battery (generation = generation (PV -> grid) + storage_out (Batt -> grid)
			Rep_Generation(y, ptpvb, r, '1', m, d, h, '1'):= Rep_Generation(y, ptpvb, r, '1', m, d, h, '1') + Rep_Storage(y, ptpvb, r,'1', m, d, h, 'Storage_Out');
			Rep_Generation(y, ptpvb, r, '1', m, d, h, '2'):= Rep_Generation(y, ptpvb, r, '1', m, d, h, '2') + Rep_Storage(y, ptpvb, r,'1', m, d, h, 'Storage_Out');
			
			Rep_Gen_Slice(y,pt,r,Steps,loadgp,loadseg):=sum((m,d,h)|EMMGroup(r,y,m,d,h)=ORD(loadgp) and EMMSegment(r,y,m,d,h)=ORD(loadseg),Rep_Generation(y,pt,r,Steps,m,d,h,'1')*IDAYTQ_orig(m,d));
			Rep_Sto_Slice(y,pts,r,Steps,loadgp,loadseg):=sum((m,d,h,Stor)|EMMGroup(r,y,m,d,h)=ORD(loadgp) and EMMSegment(r,y,m,d,h)=ORD(loadseg),Rep_Storage(y,pts,r,Steps,m,d,h,Stor)*IDAYTQ_orig(m,d));
			Rep_Curt_Slice(y,pt,r,Steps,loadgp,loadseg):=sum((m,d,h)|EMMGroup(r,y,m,d,h)=ORD(loadgp) and EMMSegment(r,y,m,d,h)=ORD(loadseg),Rep_Curtailment(y,pt,r,Steps,m,d,h,'1')*IDAYTQ_orig(m,d));
			
			ave_cap(r, pt, y, Steps, loadgp,loadseg) := mean((s,m,d,h)| Map_ms(m,s) and EMMGroup(r,y,m,d,h)=ORD(loadgp) and EMMSegment(r,y,m,d,h)=ORD(loadseg), SupplyCurve(r, s, pt, y, Steps));
			
			!Available storage for spinning reserves as a fraction of capacity mapped to slices
			!Rep_Gen_Slice_frac(y,pt,r,Steps,loadgp,loadseg):=
			!	sum((m,d,h)|EMMGroup(r,y,m,d,h)=ORD(loadgp) and EMMSegment(r,y,m,d,h)=ORD(loadseg), 
			!		Rep_Generation(y, pt, r, Steps, m, d, h, '1')*IDAYTQ_orig(m,d))/$ave_cap(r,pt,y,Steps))/8760 ;!$Rep_Hours_per_slice(y,r,loadgp,loadseg) ;
			
			Rep_Gen_Slice_frac(y,pt,r,Steps,m,d):=
				sum(h, Rep_Generation(y, pt, r, Steps, m, d, h, '1')/$sum(s| Map_ms(m,s),SupplyCurve(r, s, pt, y, Steps))/24) ;!$Rep_Hours_per_slice(y,r,loadgp,loadseg) ;
			
			Rep_Curt_Slice_frac(y,pt,r,Steps,m,d):=
				sum(h, Rep_Curtailment(y, pt, r, Steps, m, d, h, '1')/$sum(s| Map_ms(m,s),SupplyCurve(r, s, pt, y, Steps))/24) ;
			
			Rep_Gen_Slice_frac_real(y,pt,r,Steps,loadgp,loadseg):=Rep_Gen_Slice(y,pt,r,Steps,loadgp,loadseg)/$ave_cap(r,pt,y,Steps, loadgp,loadseg)/$Rep_Hours_per_slice(y,r,loadgp,loadseg);
			Rep_Curt_Slice_frac_real(y,pt,r,Steps,loadgp,loadseg):=Rep_Curt_Slice(y,pt,r,Steps,loadgp,loadseg)/$ave_cap(r,pt,y,Steps,loadgp,loadseg)/$Rep_Hours_per_slice(y,r,loadgp,loadseg);
			
			!Available storage for spinning reserves as a fraction of capacity mapped to slices
			Rep_Sto_sr_Slice_frac(y,pts,r,Steps,loadgp,loadseg):=sum((m,d,h)|EMMGroup(r,y,m,d,h)=ORD(loadgp) and EMMSegment(r,y,m,d,h)=ORD(loadseg) and (ORD(Steps) = 1 or ORD(Steps) = 2), Rep_Storage_sr(y,pts,r,Steps,m,d,h)*IDAYTQ_orig(m,d)/$Rep_DischargeCap(y,pts,r,Steps,m,d,h))/$Rep_Hours_per_slice(y,r,loadgp,loadseg) ;
			Rep_Sto_sr_CPSlice_frac(y,pts,r,Steps,cpgp,cpseg):=sum((m,d,h)|Group_ECP(r,y,m,d,h)=ORD(cpgp) and Segment_ECP(r,y,m,d,h)=ORD(cpseg) and (ORD(Steps) = 1 or ORD(Steps) = 2), Rep_Storage_sr(y,pts,r,Steps,m,d,h)*IDAYTQ_orig(m,d)/$Rep_DischargeCap(y,pts,r,Steps,m,d,h))/$Rep_Hours_per_CPslice(y,r,cpgp,cpseg) ;
			
			!correct for inverter capacity
			Rep_Sto_sr_Slice_frac(y,ptpvb,r,Steps,loadgp,loadseg):= Rep_Sto_sr_Slice_frac(y,ptpvb,r,Steps,loadgp,loadseg)/3.0; 
			Rep_Sto_sr_CPSlice_frac(y,ptpvb,r,Steps,cpgp,cpseg):= Rep_Sto_sr_CPSlice_frac(y,ptpvb,r,Steps,cpgp,cpseg)/3.0 ;
			
			Rep_NetExport(y,r,m,d,h) := sum(r1,Rep_TradeToFrom(y,r1,r,m,d,h,'1') - Rep_TradeToFrom(y,r,r1,m,d,h,'1'));
			
			Rep_Import_Slice(y,r,loadgp,loadseg):=sum((m,d,h,r1)|EMMGroup(r,y,m,d,h)=ORD(loadgp) and EMMSegment(r,y,m,d,h)=ORD(loadseg),
				Rep_TradeToFrom(y,r,r1,m,d,h,'1')*(1-TransLoss)*IDAYTQ_orig(m,d)); !*(1-0.02)
			Rep_Export_Slice(y,r,loadgp,loadseg):=sum((m,d,h,r1)|EMMGroup(r,y,m,d,h)=ORD(loadgp) and EMMSegment(r,y,m,d,h)=ORD(loadseg),
				Rep_TradeToFrom(y,r1,r,m,d,h,'1')*IDAYTQ_orig(m,d));
			Rep_NetExport_Slice(y,r,loadgp,loadseg):= Rep_Export_Slice(y,r,loadgp,loadseg) - Rep_Import_Slice(y,r,loadgp,loadseg) ;
			
			
			
			ReportData;
		}
	}
	Procedure PostMainInitialization_wos {
		Body: {
			!Rep Curtailment    
			IntermittentCurtailment(pti, reg, y, hr,Steps) := 
			    sum((s,tech)|Map_SeasonHour(s, hr) and Map_EcpGroup(tech, pti),SupplyCurve(reg, s, pti, y, Steps)*SolWinCapFactor_ER(reg, y, hr, tech))
			    - Generation(pti, y, reg, Steps, hr).Level;
			IntermittentCurtailment('20', reg, y, hr,Steps) := 
			    Generation('20', y, reg, Steps, hr).Upper - Generation('20', y, reg, Steps, hr).Level;
			IntermittentCurtailment(pth, reg, y, hr,'1') := 
			    sum((s,mm)|Map_SeasonHour(s, hr) and Map_MonthHour(mm, hr) ,SupplyCurve(reg, s, pth, y, '2')*HydroCapFactor(mm, reg))
			    - Generation(pth, y, reg, '2', hr).Level;
			!for PV+battery, we need to make sure we don't count inverter clipping as curtailment.
			IntermittentCurtailment(ptpvb, reg, y, hr,Steps) := 
			    sum((s,tech)|Map_SeasonHour(s, hr) and Map_EcpGroup(tech, ptpvb),SupplyCurve(reg, s, ptpvb, y, Steps)*(ClipCapFactor_ER(reg, y, hr, tech)+SolWinCapFactor_ER(reg,y,  hr, tech)))
			    - Generation(ptpvb, y, reg, Steps, hr).Level - Storage_inflow(ptpvb, y, reg, '1',hr);
			PVBattClipping(reg,y,hr) :=     sum(ptpvb,sum(Steps,GenerationMaxTotal(ptpvb,y,reg,Steps,hr))
			    - sum(Steps,Generation(ptpvb, y, reg, Steps, hr).Level) - Storage_inflow(ptpvb, y, reg, '1',hr) - sum(Steps,IntermittentCurtailment(ptpvb, reg, y, hr,Steps)|(IntermittentCurtailment(ptpvb, reg, y, hr,Steps)>0.000000001)  ));
			Rep_PVBattClipping(y,r,m,d,h,'1') := sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr),PVBattClipping(r,y,hr)|(PVBattClipping(r,y,hr)>0.000000001));
			Rep_PVBattClipping(y,r,m,'3',h,'1')|(NOT SW_RunDmM(m,'3') OR (Val(Last(DayPerMon)) = 2)) := 
			sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour('1', hr),PVBattClipping(r,y,hr)|(PVBattClipping(r,y,hr)>0.000000001));
			
			!adjusting curtailment and generation numbers to make it even among groups
			SolarCurtailment(reg, y, hr):= sum(ptsol,IntermittentCurtailment(ptsol, reg, y, hr,'1')|(IntermittentCurtailment(ptsol, reg, y, hr,'1')>0.000000001));
			
			IntermittentCurtailment2(ptsol, reg, y, hr,'1') := SolarCurtailment(reg, y, hr) * 
			 sum((s,tech)|Map_SeasonHour(s, hr) and Map_EcpGroup(tech, ptsol),SupplyCurve(reg, s, ptsol, y, '1')*(ClipCapFactor_ER(reg, y, hr, tech)+SolWinCapFactor_ER(reg, y, hr, tech)) - Storage_inflow(ptsol,y,reg,'1',hr))/
			 $sum((s,tech,ptsol2)|Map_SeasonHour(s, hr) and Map_EcpGroup(tech, ptsol2),SupplyCurve(reg, s, ptsol2, y, '1')*(ClipCapFactor_ER(reg, y, hr, tech)+SolWinCapFactor_ER(reg, y, hr, tech)) - Storage_inflow(ptsol2,y,reg,'1',hr));
			
			Generation(ptsol, y, r, '1', hr).Level := Generation(ptsol, y, r, '1', hr).Level + IntermittentCurtailment(ptsol, r, y, hr,'1') - max(0.0,IntermittentCurtailment2(ptsol, r, y, hr,'1'));
			
			IntermittentCurtailment(ptsol, reg, y, hr,'1') := IntermittentCurtailment2(ptsol, reg, y, hr,'1') ;
			
			Rep_Curtailment(y, ptipv, r, Steps, m, d, h, '1'):= sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr),IntermittentCurtailment(ptipv, r, y, hr,Steps)|(IntermittentCurtailment(ptipv, r, y, hr,Steps)>0.000000001));
			Rep_Curtailment(y, ptipv, r, Steps, m, '3', h, '1')|(NOT SW_RunDmM(m,'3')  OR (Val(Last(DayPerMon)) = 2)):= 
			sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour('1', hr),IntermittentCurtailment(ptipv, r, y, hr, Steps)|(IntermittentCurtailment(ptipv, r, y, hr, Steps)>0.000000001));
			
			
			Rep_Curtailment(y,pth,r,Steps,m,d,h,'1') :=sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr), IntermittentCurtailment(pth, r, y, hr,Steps)|(IntermittentCurtailment(pth, r, y, hr,Steps)>0.000000001));
			Rep_Curtailment(y,pth,r, Steps, m,'3',h,'1')|(NOT SW_RunDmM(m,'3') OR (Val(Last(DayPerMon)) = 2)) :=
			sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour('1', hr), IntermittentCurtailment(pth, r, y, hr, Steps)|(IntermittentCurtailment(pth, r, y, hr,  Steps)>0.000000001));
			
			!Report generation dispatch data
			!Rep Generation
			Rep_Generation(y, pt, r, Steps, m, d, h, '1'):= 
			    sum(hr| Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr),
			    Generation(pt, y, r, Steps, hr).Level);
			Rep_Generation(y, pt, r, Steps, m, '3', h, '1')|(NOT SW_RunDmM(m,'3') OR (Val(Last(DayPerMon)) = 2)):= 
			    sum(hr| Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour('1', hr),
			    Generation(pt, y, r, Steps, hr).Level);
			
			!Delta between generation upper bound and generation for HMM electrolyzer limit
			Rep_GenerationDelta(y, pt, r, Steps, m, d, h, '1'):= 
			    sum(hr| Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr),
			    Generation(pt, y, r, Steps, hr).Upper) - sum(hr| Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr),
			    Generation(pt, y, r, Steps, hr).Level);
			Rep_GenerationDelta(y, pt, r, Steps, m, '3', h, '1')|(NOT SW_RunDmM(m,'3') OR (Val(Last(DayPerMon)) = 2)):= 
			    sum(hr| Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour('1', hr),
			    Generation(pt, y, r, Steps, hr).Upper) - sum(hr| Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour('1', hr),
			    Generation(pt, y, r, Steps, hr).Level);
			
			!Generation upper bound
			Rep_GenerationUpper(y, pt, r, Steps, m, d, h, '1'):= 
			    sum(hr| Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr),
			    Generation(pt, y, r, Steps, hr).Upper);
			Rep_GenerationUpper(y, pt, r, Steps, m, '3', h, '1')|(NOT SW_RunDmM(m,'3') OR (Val(Last(DayPerMon)) = 2)):= 
			    sum(hr| Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour('1', hr),
			    Generation(pt, y, r, Steps, hr).Upper);    
			
			!Rep Shadow price
			HourlyShadowPrice(reg, y, hr)|SW_RunDm(hr) := -Demand_balance(reg, y, hr).ShadowPrice;
			HourlyShadowPrice((reg, y, hr)|SW_RunDm(hr)) :=HourlyShadowPrice(reg, y, hr)/Dayweights(hr);
			Rep_MarginalPrices(y, r, m, d, h, '1'):= sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr),HourlyShadowPrice(r, y, hr));
			Rep_MarginalPrices(y, r, m, '3', h, '1')|(NOT SW_RunDmM(m,'3') OR (Val(Last(DayPerMon)) = 2)):= 
			sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour('1', hr),HourlyShadowPrice(r, y, hr));
			
			!Rep trade
			Rep_TradeToFrom(y,r,rsub,m,d,h,'1'):= sum((hr)|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr),
				TradeToFrom(r,rsub,y,hr).Level);
			Rep_TradeToFrom(y,r,rcan,m,d,h,'1'):= sum((hr,CSteps)|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr),
				TradeToFromCan(r,rcan,y,hr,CSteps).Level);
			Rep_TradeToFrom(y,r,r1,m,'3',h,'1')|(NOT SW_RunDmM(m,'3') OR (Val(Last(DayPerMon)) = 2)):= 
				Rep_TradeToFrom(y,r,r1,m,'1',h,'1');
			
			!Rep unmet load
			Rep_umet_Load(y, r, m, d, h,'1'):=sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr), unmet_Load(r, y, hr).Level);
			Rep_umet_Load(y, r, m, '3', h,'1')|(NOT SW_RunDmM(m,'3') OR (Val(Last(DayPerMon)) = 2)):=
			sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour('1', hr), unmet_Load(r, y, hr).Level);
		}
	}
	Procedure PostMainInitialization {
		Body: {
			!Rep Curtailment    
			IntermittentCurtailment(pti, reg, y, hr,Steps) := 
			    sum((s,tech)|Map_SeasonHour(s, hr) and Map_EcpGroup(tech, pti),SupplyCurve(reg, s, pti, y, Steps)*SolWinCapFactor_ER(reg, y, hr, tech))
			    - Generation(pti, y, reg, Steps, hr).Level;
			IntermittentCurtailment('20', reg, y, hr,Steps) := 
			    Generation('20', y, reg, Steps, hr).Upper - Generation('20', y, reg, Steps, hr).Level;
			IntermittentCurtailment(pth, reg, y, hr,'1') := 
			    sum((s,mm)|Map_SeasonHour(s, hr) and Map_MonthHour(mm, hr) ,SupplyCurve(reg, s, pth, y, '2')*HydroCapFactor(mm, reg))
			    - Generation(pth, y, reg, '2', hr).Level;
			!need to make sure PV+battery doesn't count inverter clipping as curtailment
			IntermittentCurtailment(ptpvb, reg, y, hr,Steps) := 
			    sum((s,tech)|Map_SeasonHour(s, hr) and Map_EcpGroup(tech, ptpvb),SupplyCurve(reg, s, ptpvb, y, Steps)*(ClipCapFactor_ER(reg, y, hr, tech)+SolWinCapFactor_ER(reg, y, hr, tech)))
			    - Generation(ptpvb, y, reg, Steps, hr).Level - Storage_inflow(ptpvb, y, reg, '1',hr);
			
			PVBattClipping(reg,y,hr) :=     sum(ptpvb,sum(Steps,GenerationMaxTotal(ptpvb,y,reg,Steps,hr))
			    - sum(Steps,Generation(ptpvb, y, reg, Steps, hr).Level) - Storage_inflow(ptpvb, y, reg, '1',hr) - IntermittentCurtailment(ptpvb, reg, y, hr, '1')|(IntermittentCurtailment(ptpvb, reg, y, hr, '1')>0.000000001));
			Rep_PVBattClipping(y,r,m,d,h,'2') := sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr),PVBattClipping(r,y,hr)|(PVBattClipping(r,y,hr)>0.000000001));
			Rep_PVBattClipping(y,r,m,'3',h,'2')|(NOT SW_RunDmM(m,'3') OR (Val(Last(DayPerMon)) = 2)) := sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour('1', hr),PVBattClipping(r,y,hr)|(PVBattClipping(r,y,hr)>0.000000001));
			
			!adjusting curtailment and generation numbers to make it even among groups
			SolarCurtailment(reg, y, hr):= sum(ptsol,IntermittentCurtailment(ptsol, reg, y, hr,'1')|(IntermittentCurtailment(ptsol, reg, y, hr,'1')>0.000000001));
			
			IntermittentCurtailment2(ptsol, reg, y, hr,'1') := SolarCurtailment(reg, y, hr) * 
			 sum((s,tech)|Map_SeasonHour(s, hr) and Map_EcpGroup(tech, ptsol),SupplyCurve(reg, s, ptsol, y, '1')*(ClipCapFactor_ER(reg, y, hr, tech)+SolWinCapFactor_ER(reg, y, hr, tech)) - Storage_inflow(ptsol,y,reg,'1',hr))/
			 $sum((s,tech,ptsol2)|Map_SeasonHour(s, hr) and Map_EcpGroup(tech, ptsol2),SupplyCurve(reg, s, ptsol2, y, '1')*(ClipCapFactor_ER(reg, y, hr, tech)+SolWinCapFactor_ER(reg, y, hr, tech)) - Storage_inflow(ptsol2,y,reg,'1',hr));
			
			Generation(ptsol, y, r, '1', hr).Level := Generation(ptsol, y, r, '1', hr).Level + IntermittentCurtailment(ptsol, r, y, hr,'1') - max(0.0,IntermittentCurtailment2(ptsol, r, y, hr,'1'));
			
			IntermittentCurtailment(ptsol, reg, y, hr, '1') := IntermittentCurtailment2(ptsol, reg, y, hr,'1') ;
			Rep_Curtailment(y, ptipv, r, Steps,m, d, h, '2'):= sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr),IntermittentCurtailment(ptipv, r, y, hr, Steps)|(IntermittentCurtailment(ptipv, r, y, hr, Steps)>0.000000001));
			Rep_Curtailment(y, ptipv, r, Steps,m, '3', h, '2')|(NOT SW_RunDmM(m,'3') OR (Val(Last(DayPerMon)) = 2)):= sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour('1', hr),IntermittentCurtailment(ptipv, r, y, hr, Steps)|(IntermittentCurtailment(ptipv, r, y, hr, Steps)>0.000000001));
			Rep_Curtailment(y,pth,r, Steps,m,d,h,'2') :=sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr), IntermittentCurtailment(pth, r, y, hr, Steps)|(IntermittentCurtailment(pth, r, y, hr, Steps)>0.000000001));
			Rep_Curtailment(y,pth,r, Steps,m,'3',h,'2')|(NOT SW_RunDmM(m,'3') OR (Val(Last(DayPerMon)) = 2)) :=sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour('1', hr), IntermittentCurtailment(pth, r, y, hr, Steps)|(IntermittentCurtailment(pth, r, y, hr, Steps)>0.000000001));
			
			!Rep Shadow price
			HourlyShadowPrice(reg, y, hr)|SW_RunDm(hr) := -Demand_balance(reg, y, hr).ShadowPrice;
			HourlyShadowPrice(reg, y, hr)|SW_RunDm(hr) :=HourlyShadowPrice(reg, y, hr)/Dayweights(hr);
			Rep_MarginalPrices(y, r, m, d, h, '2'):= sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr),HourlyShadowPrice(r, y, hr));
			Rep_MarginalPrices(y, r, m, '3', h, '2')|(NOT SW_RunDmM(m,'3') OR (Val(Last(DayPerMon)) = 2)):= sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour('1', hr),HourlyShadowPrice(r, y, hr));
			!Rep trade
			Rep_TradeToFrom(y,r,rsub,m,d,h,'2'):= sum((hr)|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr),
				TradeToFrom(r,rsub,y,hr).Level);
			Rep_TradeToFrom(y,r,rcan,m,d,h,'2'):= sum((hr,CSteps)|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr),
				TradeToFromCan(r,rcan,y,hr,CSteps).Level);
			Rep_TradeToFrom(y,r,r1,m,'3',h,'2')|(NOT SW_RunDmM(m,'3') OR (Val(Last(DayPerMon)) = 2)):= Rep_TradeToFrom(y,r,r1,m,'1',h,'2');
			
			
			!Report generation dispatch data
			!Rep Generation
			Rep_Generation(y, pt, r, Steps, m, d, h, '2'):= 
			    sum(hr| Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr),
			    Generation(pt, y, r, Steps, hr).Level);
			Rep_Generation(y, pt, r, Steps, m, '3', h, '2')|(NOT SW_RunDmM(m,'3') OR (Val(Last(DayPerMon)) = 2)):= 
			    sum(hr| Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour('1', hr),
			    Generation(pt, y, r, Steps, hr).Level); 
			
			!Rep Storage!! Attention: Steps=2 is increment storage
			Rep_Storage(y, pts, r,Steps, m, d, h, 'Storage_Out'):= 
			    sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr),
			    Storage_outflow(pts, y, r, Steps, hr));
			
			Rep_Storage(y, pts, r,Steps, m, d, h, 'Storage_In'):= 
			    -sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr),
			    Storage_inflow(pts, y, r, Steps, hr));  
			
			Rep_Storage(y, pts, r,Steps, m, '3', h, 'Storage_Out')|(NOT SW_RunDmM(m,'3') OR (Val(Last(DayPerMon)) = 2)):= 
			    sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour('1', hr),
			    Storage_outflow(pts, y, r, Steps, hr));
			
			Rep_Storage(y, pts, r,Steps, m, '3', h, 'Storage_In')|(NOT SW_RunDmM(m,'3') OR (Val(Last(DayPerMon)) = 2)):= 
			    -sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour('1', hr),
			    Storage_inflow(pts, y, r, Steps, hr));  
			
			Rep_StorageLevel(y, pts, r, Steps, m, d, h):= sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr),
			                    Storage_level(pts, y, r, Steps, hr));   
			Rep_StorageLevel(y, pts, r, Steps, m, '3', h)|(NOT SW_RunDmM(m,'3') OR (Val(Last(DayPerMon)) = 2)):= Rep_StorageLevel(y, pts, r, Steps, m, '1', h);                     
			
			!Rep unmet load
			Rep_umet_Load(y, r, m, d, h,'2'):=sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr), unmet_Load(r, y, hr).Level);
			Rep_umet_Load(y, r, m, '3', h,'2')|(NOT SW_RunDmM(m,'3') OR (Val(Last(DayPerMon)) = 2)):=
			sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour('1', hr), unmet_Load(r, y, hr).Level);
		}
	}
	ExternalProcedure CSVExport {
		Arguments: (param,location);
		DllName: CSVExportDllName;
		BodyCall: {
			CSVExport(
			        scalar string : param,
			        scalar string : location
			        )
		}
		ElementParameter param {
			Range: AllIdentifiers;
			Property: Input;
		}
		StringParameter location {
			Default: ".";
			Property: Optional;
		}
	}
	Procedure ReportData {
		Body: {
			CSVExport('Rep_Generation',OutputDir);
			CSVExport('Rep_GenerationDelta',OutputDir);
			!CSVExport('Rep_GenerationUpper',OutputDir);
			CSVExport('Rep_Curtailment',OutputDir);
			CSVExport('Rep_MarginalPrices',OutputDir);
			CSVExport('Rep_Storage',OutputDir);
			CSVExport('Rep_umet_Load',OutputDir);
			CSVExport('Rep_StorageLevel',OutputDir);
			CSVExport('Rep_Gen_Slice',OutputDir);
			CSVExport('Rep_Sto_Slice',OutputDir);
			CSVExport('Rep_Hours_per_slice',OutputDir);
			CSVExport('Rep_PVBattClipping',OutputDir);
			!CSVExport('Rep_Storage_sr',OutputDir);
			!CSVExport('Rep_DischargeCap',OutputDir);
			            CSVExport('Rep_Load',OutputDir);
			CSVExport('Rep_TradeToFrom',OutputDir);
			CSVExport('Rep_NetExport',OutputDir);
			CSVExport('Rep_Export_Slice',OutputDir);
			CSVExport('Rep_Import_Slice',OutputDir);
			CSVExport('Rep_NetExport_Slice',OutputDir);
			CSVExport('Rep_Sto_sr_Slice_frac',OutputDir);
			CSVExport('Rep_Sto_sr_CPSlice_frac',OutputDir);
			
			if SW_OutputData = 1 then
				CSVExport('Rep_output_all',OutputDir);
				CSVExport('Rep_output_seasonal',OutputDir);
			endif;
			
			! set return code
			if EMM_renewable.ProgramStatus = 'Optimal' and EMM_renewable.SolverStatus = 'NormalCompletion' then
				restcode(1) := 0;
			elseif EMM_renewable.ProgramStatus = 'Infeasible' then
			  	restcode(1) := 1;
			elseif EMM_renewable.ProgramStatus = 'Unbounded' then
				restcode(1) := 2;
			elseif EMM_renewable.SolverStatus = 'InternalSolverError' then
				restcode(1) := 3;
			elseif EMM_renewable.SolverStatus = 'SolverNotCalled' then
				restcode(1) := 4;
			elseif EMM_renewable.SolverStatus = 'SolverFailure' then
				restcode(1) := 5;
			elseif EMM_renewable.SolverStatus = 'SetupFailure' then
				restcode(1) := 6;
			elseif EMM_renewable.SolverStatus = 'PreprocessorError' then
				restcode(1) := 7;
			elseif EMM_renewable.SolverStatus = 'PostProcessorError' then
				restcode(1) := 8;
			elseif EMM_renewable.ProgramStatus = 'NoSolution' then
				restcode(1) := 9;
			else
			        restcode(1) :=10;  !See ResultsMessage(yr) for specific cause of error
			endif;
			put RETURNCODE;          ! opens file to hold return code
			display {RESTCODE(M1)};
			putclose;
		}
	}
	Procedure MainTermination {
		Body: {
			!return DataManagementExit();
			sAction:="Exited";    ! Action message for NEMS
			write sAction to file NEMSMessageOutFile in replace mode;  
			return 1;
		}
		Comment: {
			"Add termination statements here that do not require all libraries to be still alive.
			Return 1 to allow the termination sequence to continue.
			Return 0 if you want to cancel the termination sequence.
			It is recommended to only use the procedure PreMainTermination to cancel the termination sequence and let this procedure always return 1."
		}
	}
	Procedure DataVisualization {
		Body: {
			GenerationBy_Group(techgro, y, hr, r) :=sum((pt,steps)|Map_ptecpgroup(pt, techgro), Generation(pt, y, r, Steps, hr));
			GenerationBy_Group('Storage_out', y, hr, r) :=sum((pts,steps), Storage_outflow(pts, y, r, Steps, hr));
		}
	}
	DeclarationSection NEMS_Monitor_Identifiers {
		Parameter CountSleep;
		File NEMSMessageInFile {
			Name: sMessageInFile;
			Device: Disk;
			Mode: replace;
		}
		File NEMSMessageOutFile {
			Name: sMessageOutFile;
			Device: Disk;
			Mode: replace;
		}
		StringParameter sMessageInFile {
			Definition: "monitor.in.txt";
		}
		StringParameter sMessageOutFile {
			Definition: "monitor.out.txt";
		}
		StringParameter sAction;
		StringParameter sStatusMessage;
	}
	Procedure NEMS_Monitor {
		Body: {
			! an initial LoadGlobal would be required because this procedure is invoked from the command line, but restore seems not to save cases.
			! Aimms doesn't load case files automatically, as specified in the project settings, when a procedure is invoked from the command line.   
			! Also not doing Read of data; that gets done in MainInitialization called below.
			
			! the following allows the aimms project to be kept open (when keepopen=1) and to later Quit at direction of NEMS,
			! or to run and exit immediately. NEMS is set up to wait for 
			! an action message of "Exited" written by the MainTermination procedure right before aimms exits.
			CountSleep := 0;
			! count sleep/wake cycles while waiting for direction from nems via sAction in the message file, monitor.in.txt
			while ( CountSleep <= 2000 ) do
			   if fileexists(sMessageInFile) then
			   ! read sAction, current model year, and current iteration from sMessageInFile
			     sAction:=" ";
			     read from file sMessageInFile in merge mode;
			   else
			     put "the NEMS message file not found, CountSleep=",CountSleep," \n ";
			   endif;
			   if sAction = "MainExecution" then
			     sAction:="executing";    ! Action message to tell NEMS I'm executing
			     write sAction to file NEMSMessageOutFile in replace mode;  
			
			     dialogProgress(""); ! remove progress dialog
			     read year from file "ECPYEAR.txt";
			     sStatusMessage := formatstring("Invoking MainInitialization for %s",first(year));
			     put sStatusMessage;
			     MainInitialization;
			     sAction:=formatstring("Completed %s,",first(year)) ;    ! Action message to tell NEMS I'v completed this year, iteration
			     write sAction to file NEMSMessageOutFile in replace mode;  
			     CountSleep:=0;   
			     sStatusMessage := "Monitoring NEMS message file("+sMessageInFile+") for "+formatstring("%s",CountSleep/2)+" seconds. Hit Ctrl+Shift+S to Stop this monitoring\n";
			     put sStatusMessage;
			     Delay(1);    ! give nems a chance to pick up status and create new monitor.in.txt file                
			   elseif sAction = "Quit" then ! NEMS says to exit aimms
			     CountSleep:=2000;
			   else
			     sStatusMessage := "Monitoring NEMS message file("+sMessageInFile+") for "+formatstring("%s",CountSleep)+" seconds. Hit Ctrl+Shift+S to Stop this monitoring\n";
			     Delay(.5);                  
			   endif;
			   dialogProgress(sStatusMessage,round(100*CountSleep/2000));
			   CountSleep += 1;
			
			endwhile;
			if CountSleep>=2001 then
			  put "Quit directive found in monitor.in.txt. Exiting AIMMS";
			else
			  put "Wait time exceeded. Exiting Aimms";
			endif;
			exitAimms; ! causes MainTermination to run and for aimms to exit. MainTermination sends message "Exited" back to nems.
		}
		Comment: {
			"This routines communicates with teh Fortran via monitor in/out message files. If the file
			is found, AIMMS reads it and re-invokes mainexecution if indicated, or closes the project.  
			After invoking mainExecution, it writes an output message file indicating completion.
			This routine then continues the sleep-wait cycle."
		}
	}
}
