## ams_version=1.0

Model Main_EMM_renewable {
	Section EMMRenewable_Structure {
		DeclarationSection ER_sets {
			Set tech1 {
				Definition: data { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,23,24,25 };
			}
			Set EmmRe_hour {
				SubsetOf: Hour;
				Index: hr;
			}
			Set MonFirstHour {
				SubsetOf: EmmRe_hour;
				Index: hr1;
				Comment: "First hour of the day";
			}
			Set MonLastHour {
				SubsetOf: EmmRe_hour;
				Index: hrl;
				Comment: "Last hour of the day";
			}
			Set Year {
				Index: y;
				OrderBy: val(y);
			}
			Set Month {
				Index: m;
				OrderBy: val(m);
				Definition: {
					{1..12};
				}
			}
			Set ECP_Hour {
				Index: h;
				OrderBy: val(h);
			}
			Set Hour {
				Index: hh;
				Definition: {
					{1..8760}
				}
			}
			Set DayType {
				Index: d;
			}
			Set LoadGroup {
				Index: loadgp;
				Definition: {
					{1,2,3,4,5,6}
				}
				Comment: "EMM Load Group - used for EFD Storage SR output";
			}
			Set LoadSegment {
				Index: loadseg;
				Definition: {
					{1,2,3,4,5,6}
				}
				Comment: "EMM Load Segment - used for EFD Storage SR output";
			}
			Set CPGroup {
				Index: cpgp;
				Definition: {
					{1,2,3,4,5,6}
				}
				Comment: "ECP Load Group - used for ECP Storage SR output";
			}
			Set CPSegment {
				Index: cpseg;
				Definition: {
					{1,2,3,4,5,6}
				}
				Comment: "ECP Load Segment - used for ECP Storage SR output";
			}
			Set EMMReg {
				Index: r;
				Definition: data { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,23,24,25 };
			}
			Set SubEMMReg {
				SubsetOf: EMMReg;
				Definition: {
					{1..25}
				}
			}
			Set Season {
				Index: s;
				Definition: {
					{1,2,3}
				}
			}
			Set ECPtype {
				Index: tech;
				Definition: {
					{1..80}
				}
			}
			Set Storage_technology {
				SubsetOf: ECPtype;
				Index: ts;
				Definition: data { 67, 68, 69 };
			}
			Set Conventional_technology {
				SubsetOf: ECPtype;
				Index: tc;
				Definition: {
					data 
					    { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
					      33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 79, 80 }
				}
			}
			Set Renewable_technology {
				SubsetOf: ECPtype;
				Index: tr;
				Definition: data { 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 78 };
			}
			Set Intermittent_technology {
				SubsetOf: ECPtype;
				Index: ti;
				Definition: data { 70, 71, 72, 73, 74, 75, 76, 77 };
			}
			Set Hydro_technology {
				SubsetOf: Renewable_technology;
				Index: th;
				Definition: data { 61, 62 };
			}
			Set NonHydroRenewable_technology {
				SubsetOf: Renewable_technology;
				Index: tnh;
				Definition: data { 56, 57, 58, 59, 60, 63, 64, 66 };
			}
			Set Technologycode {
				Index: Techcode;
			}
			Set DayPerMon {
				Index: dm;
				OrderBy: dm;
				Comment: "Number of days per month to solve the problem.";
			}
			Set GenSteps {
				Index: Steps;
				OrderBy: steps;
			}
		}
		DeclarationSection New_Group_Sets {
			Set Ecptechgroup {
				SubsetOf: Ecpgroup;
				Index: pt;
				Definition: data{1..23};
			}
			Set Storage_Group {
				SubsetOf: Ecptechgroup;
				Index: pts;
				Definition: data { 11, 13, 21 };
			}
			Set Storage_noPV_Group {
				SubsetOf: Storage_Group;
				Index: ptn;
				Definition: data { 11, 13};
			}
			Set PVBatt_Group {
				SubsetOf: Storage_Group;
				Index: ptpvb;
				Definition: data {21};
			}
			Set Conventional_Group {
				SubsetOf: Ecptechgroup;
				Index: ptc;
				Definition: data { 1, 2, 3, 4, 5, 6, 23 };
			}
			Set Renewable_Group {
				SubsetOf: Ecptechgroup;
				Index: ptr;
				Definition: data { 7, 8, 9, 10, 12, 22 };
			}
			Set Intermittent_Group {
				SubsetOf: Intermittent_PVBatt_Group;
				Index: pti;
				Definition: data { 14, 15, 16, 17, 18, 19, 20 };
			}
			Set Intermittent_PVBatt_Group {
				SubsetOf: Ecptechgroup;
				Index: ptipv;
				Definition: data { 14, 15, 16, 17, 18, 19, 20 ,21};
			}
			Set Solar_Group {
				SubsetOf: Intermittent_PVBatt_Group;
				Index: ptsol;
				Definition: data { 17, 18, 19, 20 ,21};
			}
			Set Solar_Group2 {
				SubsetOf: Solar_Group;
				Index: ptsol2;
				Definition: data { 17, 18, 19, 20 ,21};
			}
			Set Hydro_Group {
				SubsetOf: Renewable_Group;
				Index: pth;
				Definition: data {10 };
			}
			Set Ecpgroup {
				Index: pt_rep;
				Definition: data {1..23,Curtailment,Load,Unserved_Load};
			}
		}
		DeclarationSection ER_Mapping_Parameters {
			Parameter SW_OutputData;
			Parameter Map_ms {
				IndexDomain: (m,s);
				Comment: "Map Month to season";
			}
			Parameter Map_Daypattern {
				IndexDomain: (m,d,dm);
			}
			Parameter Map_MonthHour {
				IndexDomain: (m,hr);
			}
			Parameter Map_SeasonHour {
				IndexDomain: (s,hr);
			}
			Parameter Map_EcpHour_Emmhour {
				IndexDomain: (hr,h);
			}
			Parameter Map_Daytype_Hour {
				IndexDomain: (d,hr);
			}
			Parameter Map_DmHour {
				IndexDomain: (dm,hr);
			}
			Parameter DummyMonHour {
				IndexDomain: (r,y,m,hr);
			}
			Parameter Map_EcpGroup {
				IndexDomain: (tech,pt);
			}
			Parameter Map_PlantSteps {
				IndexDomain: (pt,Steps);
			}
			Parameter a;
			Parameter b;
			Parameter TotalHour;
			Parameter Idaytq {
				IndexDomain: (m,d);
			}
			Parameter Idaytq_orig {
				IndexDomain: (m,d);
			}
			Parameter EMMGroup {
				IndexDomain: (r,y,m,d,h);
				Comment: "Mapping from hour to EMM load group";
			}
			Parameter EMMSegment {
				IndexDomain: (r,y,m,d,h);
				Comment: "Mapping from hour to EMM load segment";
			}
			Parameter Group_ECP {
				IndexDomain: (r,y,m,d,h);
			}
			Parameter Segment_ECP {
				IndexDomain: (r,y,m,d,h);
			}
		}
		DeclarationSection ER_Model_Parameters {
			Parameter SolarCurtailment {
				IndexDomain: (r,y,hr);
				Text: "GW";
			}
			Parameter Load_EMMRen {
				IndexDomain: (r,y,hr);
				Text: "GW";
				Comment: "Hourly wholesale load demand in GW";
			}
			Parameter SolWinCapFactor_ER {
				IndexDomain: (r,y,hr,tech);
				Comment: "hourly solar and wind capacity factor";
			}
			Parameter HydroCapFactor {
				IndexDomain: (m,r);
				Comment: "Average capacity factor for hydro in month M";
			}
			Parameter ClipCapFactor_ER {
				IndexDomain: (r,y,hr,tech);
			}
			Parameter RampUp_Cost {
				IndexDomain: (ptc);
				Text: "$/MW";
				Comment: "Load change cost for increases for tech T in hour h in $/MW";
			}
			Parameter RampDown_Cost {
				IndexDomain: (ptc);
				Text: "$/MW";
				Comment: "Load change cost for decreases for tech T in hour h in $/MW";
			}
			Parameter Battery_ChargeCap {
				IndexDomain: (pts,r,y,Steps,hr);
				Text: "GW";
				Comment: "Charge capacity of storage technology TS in GW";
			}
			Parameter Battery_DischargeCap {
				IndexDomain: (pts,r,y,Steps,hr);
				Text: "GW";
				Comment: "Discharge capacity of storage technology TS in GW";
			}
			Parameter StartBatteryFrac {
				Comment: "Energy capacity of battery";
			}
			Parameter UNRGNS {
				Range: integer;
			}
			Parameter BatteryEfficiency {
				IndexDomain: pts;
				Comment: "Roundtrip efficiency of battery tech";
			}
			Parameter HourstoBuy;
			Parameter HourstoSell;
			Parameter RampRate {
				IndexDomain: (ptc);
				Comment: "Ramp rate of tech T";
			}
			Parameter DayPerMonth {
				IndexDomain: (m,d);
			}
			Parameter UnmetLoad_penalty {
				Text: "$/MW";
				Comment: "slack penalty";
			}
			Parameter lasthr;
			Parameter Dayweights {
				IndexDomain: hr;
			}
			Parameter SupplyPrice {
				IndexDomain: (r,s,pt,y,Steps);
				Text: "$/MWh";
			}
			Parameter SupplyCurve {
				IndexDomain: (r,s,pt,y,Steps);
				Text: "GW";
			}
			Parameter M864_LF {
				IndexDomain: (pt,Steps);
			}
			Parameter CapacityFactor {
				IndexDomain: (pt,y,r,Steps,hr);
			}
			Parameter HydroDispatchablePortion {
				IndexDomain: r;
				Text: "Hydro plant dispatchable part";
			}
			Parameter BatteryIncrement {
				IndexDomain: (y,r,pts);
			}
			Parameter Storagelvl_cost {
				Comment: "Prevent the storage lvl keep saving useless energy though the time.";
			}
			Parameter PVBatt_maxCF {
				IndexDomain: (y,reg,Steps,hr);
			}
			Parameter PVBattClipping {
				IndexDomain: (reg,y,hr);
				Text: "GW";
			}
			Parameter GenerationMaxTotal {
				IndexDomain: (ptpvb,y,reg,Steps,hr);
				Text: "GW";
			}
			StringParameter ReadinData;
			StringParameter OutputDir;
			ElementParameter NewStor {
				Range: Ecptechgroup;
			}
		}
		DeclarationSection ER_Variables {
			Variable RampUp {
				IndexDomain: (ptc,y,r,Steps,hr);
				Text: "GW";
				Range: nonnegative;
				Comment: "Operation increase GW of Tech T in hour h";
			}
			Variable RampDown {
				IndexDomain: (ptc,y,r,Steps,hr);
				Text: "GW";
				Range: nonnegative;
				Comment: "Operation decrease GW of Tech T in hour h";
			}
			Variable Storage_inflow {
				IndexDomain: (pts,y,r,Steps,hr);
				Text: "GW";
				Range: nonnegative;
				Comment: "Storage inflow in hour h in GW";
			}
			Variable Storage_outflow {
				IndexDomain: (pts,y,r,Steps,hr);
				Text: "GW";
				Range: nonnegative;
				Comment: "Storage outflow in hour h in GW";
			}
			Variable Storage_level {
				IndexDomain: (pts,y,r,Steps,hr);
				Text: "GWh";
				Range: nonnegative;
				Comment: "Energy level of storage tech T_S in hour h in GWh";
			}
			Variable Generation {
				IndexDomain: (pt,y,r,Steps,hr);
				Text: "GW";
				Range: nonnegative;
				Comment: "Operated capacity GW use of technology group T in hour h";
			}
			Variable unmet_Load {
				IndexDomain: (r,y,hr);
				Text: "GW";
				Range: nonnegative;
				Comment: "slack variable";
			}
		}
		DeclarationSection ER_Constraints {
			Variable Objectivefunction {
				Text: "1000$";
				Range: free;
				Definition: {
					
					sum((hr,reg),
					(sum((ptn,y,steps),0.5* sum(s| Map_SeasonHour(s, hr),SupplyPrice(reg, s, ptn, y, Steps))*(Storage_inflow(ptn, y, reg, Steps, hr)+Storage_outflow(ptn, y, reg, Steps, hr))
					+Storagelvl_cost*Storage_level(ptn, y, reg, Steps, hr))
					+sum((ptpvb,y,steps),1.0* sum(s| Map_SeasonHour(s, hr),SupplyPrice(reg, s, ptpvb, y, Steps))*(Storage_inflow(ptpvb, y, reg, Steps, hr)+Storage_outflow(ptpvb, y, reg, Steps, hr))
					+Storagelvl_cost*Storage_level(ptpvb, y, reg, Steps, hr))
					!using PV pricing for PV portion of PV+battery
					+ sum((ptc,y,steps), sum(s|Map_SeasonHour(s, hr),SupplyPrice(reg, s, ptc, y, Steps))*Generation(ptc, y, reg, Steps, hr))
					+ sum((ptr,y,steps), sum(s|Map_SeasonHour(s, hr),SupplyPrice(reg, s, ptr, y, Steps))*Generation(ptr, y, reg, Steps, hr))
					+ sum((ptipv,y,steps), sum(s|Map_SeasonHour(s, hr),SupplyPrice(reg, s, ptipv, y, Steps))*Generation(ptipv, y, reg, Steps, hr))
					+ sum((ptc,y,steps),RampUp_Cost(ptc)*RampUp(ptc, y, reg, Steps, hr)+ RampDown_Cost(ptc)*RampDown(ptc, y, reg, Steps, hr))
					+ sum((y),unmet_Load(reg, y, hr)*UnmetLoad_penalty))*Dayweights(hr))
				}
			}
			Constraint Demand_balance {
				IndexDomain: (reg, y, hr);
				Property: ShadowPrice;
				Definition: {
					Load_EMMRen(reg, y, hr) <= 
					sum((ptc,steps)|Map_PlantSteps(ptc, Steps),Generation(ptc, y, reg, Steps,hr))
					+sum((ptr,steps)|Map_PlantSteps(ptr, Steps),Generation(ptr, y, reg, Steps,hr))
					+sum((pti,steps)|Map_PlantSteps(pti, Steps),Generation(pti, y, reg, Steps,hr))
					+sum((ptn,steps)|Map_PlantSteps(ptn, Steps),Storage_outflow(ptn, y, reg, Steps, hr)-Storage_inflow(ptn, y, reg, Steps, hr))
					+sum((ptpvb,steps)|Map_PlantSteps(ptpvb, Steps),Generation(ptpvb, y, reg, Steps,hr)+ Storage_outflow(ptpvb, y, reg, Steps, hr) ) !grid charging inflow only
					+ unmet_Load(reg, y, hr)
				}
			}
			Constraint Gen_ramp {
				IndexDomain: (ptc, y, reg, m, Steps, hr)| NOT (Ord(hr,MonFirstHour) > 0) AND Map_MonthHour(m, hr);
				Definition: Generation(ptc, y, reg, Steps, hr)= (Generation(ptc, y, reg, Steps, hr-1)+ RampUp(ptc, y, reg,Steps, hr)- RampDown(ptc, y, reg, Steps, hr));
			}
			Constraint FirstHour_gen_ramp {
				IndexDomain: (ptc,y,reg,m,Steps,hr)| (Ord(hr,MonFirstHour) > 0) AND Map_MonthHour(m, hr);
				Definition: Generation(ptc, y, reg, Steps, hr)= (Generation(ptc, y, reg, Steps, hr+23)+ RampUp(ptc, y, reg,Steps, hr)- RampDown(ptc, y, reg, Steps, hr));
			}
			Constraint StorageBalance {
				IndexDomain: {
					(pts, y, reg, m, Steps, hr)
					| NOT (Ord(hr,MonFirstHour) > 0) AND Map_MonthHour(m, hr)
				}
				Definition: {
					Storage_level(pts, y, reg, Steps,hr) = 
					(Storage_level(pts, y, reg, Steps,hr-1)
					+ BatteryEfficiency(pts)*Storage_inflow(pts, y, reg, Steps,hr)
					- Storage_outflow(pts, y, reg, Steps,hr))
				}
			}
			Constraint FirstHourStorageBalance2 {
				IndexDomain: (pts, y, reg, Steps, hr)| (Ord(hr,MonFirstHour) > 0);
				Definition: {
					Storage_level(pts, y, reg, Steps,hr) = 
					Storage_level(pts, y, reg, Steps,hr+23)
					+ BatteryEfficiency(pts)*Storage_inflow(pts, y, reg, Steps,hr)
					- Storage_outflow(pts, y, reg, Steps,hr)
				}
			}
			Parameter Load {
				IndexDomain: (r,y,m,d,h);
				Text: "GW";
				Comment: "Hourly wholesale load demand GW from ECP";
			}
			Constraint Hydro_Gen_Cap {
				IndexDomain: (pth, y, reg, mm);
				Definition: {
					sum((hr,d)|Map_MonthHour(mm, hr) and Map_Daytype_Hour(d, hr),Generation(pth, y, reg, '1',hr)*Idaytq(mm, d)) <= 
					    sum(s|Map_ms(mm, s) ,HydroCapFactor(mm, reg)*SupplyCurve(reg, s, pth, y, '1'))*sum(d,Idaytq(mm, d))*24
				}
			}
			Constraint PVBattery_balance {
				IndexDomain: (y,reg,Steps,hr);
				Definition: {
					Generation('21', y, reg, Steps,hr)  + Storage_outflow('21', y, reg, Steps, hr) <= PVBatt_maxCF(y,reg,Steps,hr)  !max generation (inverter capacity)
					!kW PV to grid + kW batt to grid + kW grid to batt <= inverter capacity kW
				}
			}
			Constraint PVBattery_balance2 {
				IndexDomain: (y,reg,Steps,hr);
				Definition: {
					!kW PV to grid + kW PV to Batt <= PV available (unclipped by inverter)
					Generation('21', y, reg, Steps,hr) + (Storage_inflow('21', y, reg, Steps, hr))  <=  
					GenerationMaxTotal('21',y,reg,Steps,hr)
				}
			}
		}
		DeclarationSection ER_Model_Structure {
			MathematicalProgram EMM_renewable {
				Objective: Objectivefunction;
				Direction: minimize;
				Constraints: EMM_Constraints;
				Variables: EMM_Variables;
				Type: LP;
			}
			Set EMM_Constraints {
				SubsetOf: AllConstraints;
				InitialData: {
					data 
					    { Objectivefunction       , Demand_balance          , Gen_ramp                , StorageBalance          , 
					        Hydro_Gen_Cap           , FirstHourStorageBalance2, PVBattery_balance      , PVbattery_balance2 ,FirstHour_gen_ramp }
				}
			}
			Set EMM_Variables {
				SubsetOf: AllVariables;
				Definition: {
					data 
					    { RampUp           , RampDown         , Storage_inflow   , Storage_outflow  , Storage_level    , Generation       ,
					      unmet_Load       , Objectivefunction }
				}
			}
		}
	}
	Section Data_To_NEMS {
		DeclarationSection Rep_Parameters {
			Set Storage_rep {
				Index: Stor_rep;
				Definition: data {Charge,Discharge,Generation,Load};
			}
			Set StorageType {
				Index: Stor;
				Definition: data { Storage_In, Storage_Out };
			}
			Set SolveIndex {
				Index: k;
				Definition: data { 1, 2 };
			}
			Parameter SwitchSolve {
				IndexDomain: k;
				Definition: data { 2 : 1 };
			}
			Parameter Rep_Generation {
				IndexDomain: (y,pt,r,Steps,m,d,h,k);
				Text: "GW";
			}
			Parameter Rep_Curtailment {
				IndexDomain: (y,pt,r,m,d,h,k);
				Text: "GW";
			}
			Parameter Rep_MarginalPrices {
				IndexDomain: (y,r,m,d,h,k);
				Text: "87$/MWh";
			}
			Parameter Rep_Storage {
				IndexDomain: (y,pts,r,Steps,m,d,h,Stor);
				Text: "GW";
			}
			Parameter Rep_StorageLevel {
				IndexDomain: (y,pts,r,Steps,m,d,h);
			}
			Parameter Rep_umet_Load {
				IndexDomain: (y,r,m, d, h,k);
				Text: "GW";
				Range: nonnegative;
				Comment: "slack variable";
			}
			Parameter Rep_Generation_wos {
				IndexDomain: (y,pt,r,m,d,h);
				Text: "GW";
			}
			Parameter Rep_Curtailment_wos {
				IndexDomain: (y,pt,r,m,d,h);
				Text: "GW";
			}
			Parameter Rep_MarginalPirces_wos {
				IndexDomain: (y,r,m,d,h);
				Text: "87$/MWh";
			}
			Parameter Rep_Storage_wos {
				IndexDomain: (y,pts,r,Steps,m,d,h,Stor);
				Text: "GW";
			}
			Parameter Rep_Gen_slice {
				IndexDomain: (y,pt,r,Steps,loadgp,loadseg);
				Text: "GWh";
				Comment: "debug calculating generation by EMM slice for comparison to EFD";
			}
			Parameter Rep_Sto_slice {
				IndexDomain: (y,pts,r,Steps,loadgp,loadseg);
				Text: "GWh";
				Comment: "debug calculating net storage gen by EMM slice for comparison to EFD";
			}
			Parameter Rep_Hours_per_slice {
				IndexDomain: (y,r,loadgp,loadseg);
				Text: "hours";
				Comment: "hours per EMM load group/segment";
			}
			Parameter Rep_Hours_per_CPslice {
				IndexDomain: (y,r,cpgp,cpseg);
				Comment: "hours per ECP load group/segment";
			}
			Parameter Rep_DischargeCap {
				IndexDomain: (y,pts,r,Steps,m,d,h);
				Comment: "Storage capacity";
			}
			Parameter Rep_Storage_sr {
				IndexDomain: (y,pts,r,Steps,m,d,h);
				Comment: "Storage available for spinning reserves. Only output for debug (not read directly into EMM)";
			}
			Parameter Rep_Sto_sr_CPSlice_frac {
				IndexDomain: (y,pts,r,Steps,cpgp,cpseg);
				Comment: "Storage available for spinning reserves as a fraction of capacity mapped to ECP slices";
			}
			Parameter Rep_Sto_sr_Slice_frac {
				IndexDomain: (y,pts,r,Steps,loadgp,loadseg);
				Comment: "Storage available for spinning reserves as a fraction of capacity mapped to EMM (EFD) slices";
			}
			Parameter Rep_output_all {
				IndexDomain: (y,pt_rep,h,Stor_rep);
			}
			Parameter Rep_output_seasonal {
				IndexDomain: (y,pt_rep,s,h,Stor_rep);
			}
			Parameter Rep_PVBattClipping {
				IndexDomain: (y,r,m,d,h,k);
			}
			Set M1_ {
				SubsetOf: Integers;
				Index: M1;
				InitialData: {
					{1..0001}
				}
			}
			Parameter RESTCODE {
				IndexDomain: (M1);
				Text: "SolverStaus, ProgramStatus combination return code, 0 is success";
			}
			File RETURNCODE {
				Name: "fromAIMMS/RETURNCODE.txt";
				Device: Disk;
				Mode: replace;
			}
			StringParameter CSVExportDllName {
				Definition: {
					if AimmsStringConstants('Architecture') = 'x86' then
					        "CSVExport.dll"
					else
					        "CSVExport64.dll"
					endif
				}
			}
		}
	}
	Section Data_From_UECP {
		DeclarationSection DataFrom_UECP {
			Parameter DailyPeakLoad {
				IndexDomain: (r,y,m,d);
				Comment: "Hourly wholesale load demand from ECP";
			}
			Parameter SolWindCapFactor {
				IndexDomain: (r,y,m,d,h,tech);
				Comment: "Solar and wind capacity factor from ecp";
			}
			Parameter ClipCapFactor {
				IndexDomain: (r,y,m,d,h,tech);
			}
			Parameter Map_techs {
				IndexDomain: (tech,Techcode);
			}
			Parameter SR_MAX_LF {
				IndexDomain: (tech,Techcode);
			}
			Parameter M864_TEC {
				IndexDomain: (tech,Techcode);
			}
		}
	}
	Section DebugSetup {
		DeclarationSection sub_emm {
			Set AcitveEMMReg {
				SubsetOf: EMMReg;
				Index: reg;
				OrderBy: val(reg);
			}
			Set AcitveMonth {
				SubsetOf: Month;
				Index: mm;
				OrderBy: val(m);
				Definition: data { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 };
			}
		}
		DeclarationSection Debug_Parameters {
			ElementParameter yrselect {
				Range: Year;
			}
			ElementParameter grpselect {
				Range: GroupECP;
			}
			Set GroupECP {
				Index: techgro;
				Definition: data { Nuclear,Coal,Steam,CC,Biomass, Geother, MSW,FuelC, DistGen,Turbine,Hydro,Solar, Wind,OtherIn,P2,Storage_out };
			}
			Parameter Map_ptecpgroup {
				IndexDomain: (pt,techgro);
				Definition: {
					data 
					{ ( 1 , Coal    ) : 1,  ( 2 , Steam   ) : 1,  ( 3 , Turbine ) : 1,  ( 4 , CC      ) : 1,  ( 5 , FuelC   ) : 1,
					  ( 6 , Nuclear ) : 1,  ( 7 , Biomass ) : 1,  ( 8 , Geother ) : 1,  ( 9 , MSW     ) : 1,  ( 10, Hydro   ) : 1,
					  ( 12, P2      ) : 1,  ( 14, Wind    ) : 1,  ( 15, Wind    ) : 1,  ( 16, Wind    ) : 1,  ( 17, Solar   ) : 1,
					  ( 18, Solar   ) : 1,  ( 19, Solar   ) : 1,  ( 20, Solar   ) : 1,  ( 21, Solar   ) : 1,  ( 22, OtherIn ) : 1,
					  ( 23, DistGen ) : 1 }
				}
			}
			Parameter GenerationBy_ECPType {
				IndexDomain: (tech,y,hr,r);
			}
			Parameter GenerationBy_Group {
				IndexDomain: (techgro,y,hr,r);
			}
			Parameter HourlyShadowPrice {
				IndexDomain: (r,y,hr);
			}
			Parameter IntermittentCurtailment {
				IndexDomain: (pt,r,y,hr);
			}
			Parameter IntermittentCurtailment2 {
				IndexDomain: (pt,r,y,hr);
			}
			Parameter Tot_generation {
				IndexDomain: (pt,y,m,r,d);
			}
			Parameter Tot_Rep_Storage {
				IndexDomain: (y,pts,r,Steps,m,d,Stor);
				Text: "GW";
			}
			Parameter RE_Upperbound {
				IndexDomain: (pt,r,y,hr);
			}
			ElementParameter epselect {
				Range: SubEMMReg;
			}
		}
	}
	Procedure MainInitialization {
		Body: {
			Model_Prepare;
			!Solving_Model;
			Solve_Model_Fixed;
		}
	}
	Procedure Model_Prepare {
		Body: {
			empty Allparameters;
			! read data from NEMS
			!read in current year and input file
			read year from file "ECPYEAR.txt";
			ReadinData := "toAIMMS/ECPout_"+ first(year) +".txt";
			OutputDir := "fromAIMMS/Output_"+ first(year);
			if DirectoryExists(OutputDir) = 0 then
				DirectoryCreate(OutputDir);
			endif;
			
			read Map_MS,Map_PlantSteps,SolWindCapFactor,HydroCapFactor,EMMGroup,EMMSegment,Group_ECP,Segment_ECP,Load,HourstoBuy,HourstoSell,SupplyPrice, SupplyCurve,Idaytq,Map_techs,BatteryEfficiency,M864_LF,BatteryIncrement,UNRGNS,ClipCapFactor,SW_OutputData from file ReadinData;
			! read data from local files
			read Map_EcpGroup,RampRate,RampUp_Cost,RampDown_Cost,UnmetLoad_penalty,HydroDispatchablePortion from file "input/restprep.txt";
			AcitveEMMReg:= {r|val(r)<=UNRGNS};
			
			! do hour prep
			EmmRe_hour :={1..576};
			
			!calculate the total number of hours in this model
			lasthr:= val(last(hr));
			
			DayPerMon := {1 .. 2};
			DayType := {1 .. 3};
			
			! map hours depending on daytypes
			MonLastHour:= {24 .. lasthr by 24} ; 
			MonFirstHour:= {1 .. lasthr by 24} ; 
			
			Map_Daypattern(m,'1','2') := 1;
			Map_Daypattern(m,'2','1') := 1;
			
			!load shape calculation,solar and wind hourly capacity factors calculation,Mapping Month and hour
			a:=1;
			for (mm,dm,h) do
				Map_DmHour((dm,hr)|ord(hr)=a) := 1 ;
				Load_EMMRen((r, y, hr)|ord(hr)=a) :=sum(d,Load(r, y, mm, d, h)*Map_Daypattern( mm, d, dm));
				SolWinCapFactor_ER((r, y, hr, tech)|ord(hr)=a) :=sum(d,SolWindCapFactor(r, y, mm, d, h, tech)*Map_Daypattern( mm, d, dm));
				ClipCapFactor_ER((r, y, hr, tech)|ord(hr)=a) := sum(d,ClipCapFactor(r, y, mm, d, h, tech)*Map_Daypattern( mm, d, dm));
				DummyMonHour((r,y,mm,hr)|ord(hr)=a) :=sum(d,Load(r, y, mm, d, h)*Map_Daypattern( mm, d, dm));
				a:=a+1;
			endfor;
			
			Map_MonthHour((mm, hr)|DummyMonHour(first(r), first(y), mm, hr)) := 1;
			Map_SeasonHour(s, hr) := sum(m|Map_MonthHour(m, hr), Map_ms(m, s));
			Map_Daytype_Hour(d,hr):= sum((dm,mm)|Map_Daypattern( mm, d, dm), Map_MonthHour(mm,hr)*Map_DmHour(dm, hr));
			
			!This mostly avoids storage cycling to avoid curtailment of intermittents (since it's more expensive than ints)... probably reflects cycling costs anyway.
			SupplyPrice(r, s, ptpvb, y, '1'):=0.001;
			
			!Add an increment storage capacity, Now using storage steps=2 to represent the increment storage capacity and cost
			SupplyPrice(r, s, pts, y, '2'):=SupplyPrice(r, s, pts, y, '1');
			
			!Add a small variable cost for solar, hydro and wind, which is used for the curtialment sequence.
			SupplyPrice(r, s, pth, y, '1'):=0.003;
			SupplyPrice(r, s, pth, y, '2'):=0.003;
			SupplyPrice(r, s, '14', y,'1'):=0.002;
			SupplyPrice(r, s, '15', y,'1'):=0.002;
			SupplyPrice(r, s, '16', y,'1'):=0.002;
			SupplyPrice(r, s, '17', y, '1'):=0.001;
			SupplyPrice(r, s, '18', y, '1'):=0.001;
			SupplyPrice(r, s, '19', y, '1'):=0.001;
			SupplyPrice(r, s, '20', y, '1'):=0.001;
			!warning: PV part of PV+battery (21) also uses PV (20) supply price.
			
			Storagelvl_cost := 0.00000001;
			
			!Map ecp hour with emm renewable hour
			a:= 1;
			b:= 1;
			for hr do
				if a<=lasthr then
					if b = 25 then
						b:=1;           
						Map_EcpHour_Emmhour((hr, h)|val(hr) = a and val(h)= b):=1;
					else
						Map_EcpHour_Emmhour((hr, h)|val(hr) = a and val(h)= b):=1;
					endif;
				a := a+1;
				b := b+1;
				endif;
			endfor;
			
			!Add peak day dayweight to the weekday dayweight
			Idaytq_orig(m,d) := Idaytq(m,d);
			Idaytq(mm, '1') := Idaytq(mm, '1')+Idaytq(mm, '3');
			
			!Calculate day weights for each hr
			Dayweights(hr) := sum((mm,d),Idaytq(mm, d)*Map_MonthHour(mm, hr)*Map_Daytype_Hour(d, hr));
			
			!Daily conventional plants generation capacity factor
			DailyPeakLoad(r, y, m, d):=max(h,Load(r, y, m, d, h));
			CapacityFactor(pt, y, reg, Steps, hr):=sum((m,d,h)|Map_MonthHour(m, hr) and Map_Daytype_Hour(d, hr) and Map_PlantSteps(pt, Steps) and Map_EcpHour_Emmhour(hr, h),
			M864_LF(pt, Steps)+(1-M864_LF(pt, Steps))*Load(reg, y, m, d, h)/DailyPeakLoad(reg, y, m, d));
			
			!Add one more steps for hydro supply curve for flat dispatch
			SupplyCurve(r, s, '10', y, '2') := (1-HydroDispatchablePortion(r))*SupplyCurve(r, s, '10', y, '1');
			SupplyCurve(r, s, '10', y, '1') := HydroDispatchablePortion(r)*SupplyCurve(r, s, '10', y, '1');
		}
	}
	Procedure Solve_Model_Fixed {
		Body: {
			Empty Allvariables;
			option Bound_Tolerance := 1.0e-8;
			!option linear_presolve := off;
			!option postsolve_continuous_variables := "no_rounding";
			
			!Upper bound of all Units
			Generation(ptc, y, reg, Steps, hr).Upper := sum(s|Map_SeasonHour(s, hr),SupplyCurve(reg, s, ptc, y, Steps)*CapacityFactor(ptc, y, reg, Steps, hr));
			Generation(ptr, y, reg, Steps, hr).Upper := sum(s|Map_SeasonHour(s, hr),SupplyCurve(reg, s, ptr, y, Steps)*CapacityFactor(ptr, y, reg, Steps, hr));
			Generation(pth, y, reg, '2', hr).Upper := sum((s,mm)|Map_SeasonHour(s, hr) and Map_MonthHour(mm, hr) ,SupplyCurve(reg, s, pth, y, '2')*HydroCapFactor(mm, reg));
			Generation(ptipv, y, reg, Steps, hr).Upper := sum((s,tech)|Map_SeasonHour(s, hr) and Map_EcpGroup(tech, ptipv) ,SupplyCurve(reg, s, ptipv, y, Steps)*SolWinCapFactor_ER(reg, y, hr, tech));
			Generation(ptn, y, reg, Steps, hr).Upper := 0;
			
			!this is the unclipped by the inverter CF ... GenerationMaxTotal, adding clipped back in
			GenerationMaxTotal(ptpvb,y,reg,Steps,hr) := sum((s,tech)|Map_SeasonHour(s, hr) and Map_EcpGroup(tech, ptpvb),SupplyCurve(reg, s, ptpvb, y, Steps)*(ClipCapFactor_ER(reg, y, hr, tech)+SolWinCapFactor_ER(reg, y, hr, tech))) ;
			PVBatt_maxCF(y,reg,Steps,hr) := sum((s,ptpvb)|Map_SeasonHour(s, hr),SupplyCurve(reg, s, ptpvb, y, Steps));
			
			RampUp(ptc, y, reg, Steps, hr).Upper := RampRate(ptc)*sum(s|Map_SeasonHour(s, hr),SupplyCurve(reg, s, ptc, y, Steps));
			RampDown(ptc, y, reg, Steps, hr).Upper := RampRate(ptc)*sum(s|Map_SeasonHour(s, hr),SupplyCurve(reg, s, ptc, y, Steps));
			
			!Solving model without increment storage(switchsolve(k)=0)
			!Solving model with increment storage(switchsolve(k)=1)
			for k do
				if SwitchSolve(k) = 0 then                              
					SupplyCurve(r, s, pts, y, '2'):= 0;
					Battery_ChargeCap(ptn, r, y, Steps, hr) := sum(s|Map_SeasonHour(s, hr),SupplyCurve(r, s, ptn, y, Steps));
					Battery_DischargeCap(ptn, r, y, Steps, hr) := sum(s|Map_SeasonHour(s, hr),SupplyCurve(r, s, ptn, y, Steps));
					Battery_ChargeCap(ptpvb, r, y, Steps, hr) := sum(s|Map_SeasonHour(s, hr),SupplyCurve(r, s, ptpvb, y, Steps)) / 3; !3 is storage cap fraction of inverter
					Battery_DischargeCap(ptpvb, r, y, Steps, hr) := sum(s|Map_SeasonHour(s, hr),SupplyCurve(r, s, ptpvb, y, Steps)) / 3; !3 is storage cap fraction of inverter
			
					Storage_level('13', y, reg, Steps, hr).Upper := sum(s|Map_SeasonHour(s, hr),SupplyCurve(reg, s, '13', y, Steps))*HourstoBuy;
					Storage_level('11', y, reg, Steps, hr).Upper := sum(s|Map_SeasonHour(s, hr),SupplyCurve(reg, s, '11', y, Steps))*12;
					Storage_level(ptpvb, y, reg, Steps, hr).Upper := sum(s|Map_SeasonHour(s, hr),SupplyCurve(reg, s, ptpvb, y, Steps))*HourstoBuy / 3; !3 is storage cap fraction of inverter
			
					Storage_inflow(pts, y, reg, Steps, hr).Upper := Battery_ChargeCap(pts, reg, y, Steps, hr);
					Storage_outflow(pts, y, reg, Steps, hr).Upper := Battery_DischargeCap(pts, reg, y, Steps, hr);
			
					solve EMM_renewable;
					PostMainInitialization_wos;     
				else 
					option Bound_Tolerance := 1.0e-6;
					option postsolve_continuous_variables := 'Round to nearest bound';
			
					SupplyCurve(r, s, pts, y, '2'):= BatteryIncrement(y, r, pts);
					Battery_ChargeCap(ptn, r, y, Steps, hr) := sum(s|Map_SeasonHour(s, hr),SupplyCurve(r, s, ptn, y, Steps));
					Battery_DischargeCap(ptn, r, y, Steps, hr) := sum(s|Map_SeasonHour(s, hr),SupplyCurve(r, s, ptn, y, Steps));    
					Battery_ChargeCap(ptpvb, r, y, Steps, hr) := sum(s|Map_SeasonHour(s, hr),SupplyCurve(r, s, ptpvb, y, Steps)) / 3;
					Battery_DischargeCap(ptpvb, r, y, Steps, hr) := sum(s|Map_SeasonHour(s, hr),SupplyCurve(r, s, ptpvb, y, Steps)) / 3;
					Storage_level('13', y, reg, Steps, hr).Upper := sum(s|Map_SeasonHour(s, hr),SupplyCurve(reg, s, '13', y, Steps))*HourstoBuy;
					Storage_level('11', y, reg, Steps, hr).Upper := sum(s|Map_SeasonHour(s, hr),SupplyCurve(reg, s, '11', y, Steps))*12;
					Storage_level(ptpvb, y, reg, Steps, hr).Upper := sum(s|Map_SeasonHour(s, hr),SupplyCurve(reg, s, ptpvb, y, Steps))*HourstoBuy / 3;
					Storage_inflow(pts, y, reg, Steps, hr).Upper := Battery_ChargeCap(pts, reg, y, Steps, hr);
					Storage_outflow(pts, y, reg, Steps, hr).Upper := Battery_DischargeCap(pts, reg, y, Steps, hr);
					!Fixed existing storage dispatch
					Storage_inflow(pts, y, r, '1', hr).nonvar:=1;
					Storage_outflow(pts, y, r, '1', hr).nonvar:=1;
					Storage_level(pts, y, r, '1', hr).nonvar:=1;
					solve EMM_renewable;
					PostMainInitialization;         
				endif;
			endfor;
			
			!Output national summary data for chart library. Only first and last RESTORE years.
			if SW_OutputData = 1 then
				Rep_output_all(y,pts,h,'Discharge'):= sum((m,d,r), Rep_Storage(y,pts,r,'1',m,d,h,'Storage_Out')*IDAYTQ_orig(m,d)/1000);
				Rep_output_all(y,pts,h,'Charge'):= sum((m,d,r), Rep_Storage(y,pts,r,'1',m,d,h,'Storage_In')*IDAYTQ_orig(m,d)/1000);
				Rep_output_all(y,'Curtailment',h,'Generation'):= sum((m,d,pt,r),Rep_Curtailment(y, pt, r, m, d, h, '1')*IDAYTQ_orig(m,d)/1000);
				Rep_output_all(y,pt,h,'Generation'):= sum((m,d,Steps,r), Rep_Generation(y,pt,r,Steps,m,d,h,'1')*IDAYTQ_orig(m,d)/1000);
				Rep_output_all(y,'Load',h,'Load'):= sum((m,d,r),Load(r, y, m, d, h)*IDAYTQ_orig(m,d)/1000);
				Rep_output_all(y,'Unserved_Load',h,'Load'):= sum((m,d,r,hr), Rep_umet_Load(y, r, m, d, h,'1')*IDAYTQ_orig(m,d)/1000);
			
				Rep_output_seasonal(y,pts,s,h,'Discharge'):= sum((m,d,r)| Map_ms(m,s), Rep_Storage(y,pts,r,'1',m,d,h,'Storage_Out')*IDAYTQ_orig(m,d)/1000);
				Rep_output_seasonal(y,pts,s,h,'Charge'):= sum((m,d,r)| Map_ms(m,s), Rep_Storage(y,pts,r,'1',m,d,h,'Storage_In')*IDAYTQ_orig(m,d)/1000);
				Rep_output_seasonal(y,'Curtailment',s,h,'Generation'):= sum((m,d,pt,r)| Map_ms(m,s),Rep_Curtailment(y, pt, r, m, d, h, '1')*IDAYTQ_orig(m,d)/1000);
				Rep_output_seasonal(y,'Load',s,h,'Load'):= sum((m,d,r)| Map_ms(m,s), Load(r, y, m, d, h)*IDAYTQ_orig(m,d)/1000);
				Rep_output_seasonal(y,pt,s,h,'Generation'):= sum((m,d,Steps,r)| Map_ms(m,s), Rep_Generation(y,pt,r,Steps,m,d,h,'1')*IDAYTQ_orig(m,d)/1000);
				Rep_output_seasonal(y,'Unserved_Load',s,h,'Load'):= sum((m,d,r,hr) | Map_ms(m,s), Rep_umet_Load(y, r, m, d, h,'1')*IDAYTQ_orig(m,d)/1000);
			
			endif;
			
			Rep_Hours_per_slice(y,r,loadgp,loadseg):=sum((m,d,h)|EMMGroup(r,y,m,d,h)=ORD(loadgp) and EMMSegment(r,y,m,d,h)=ORD(loadseg),IDAYTQ_orig(m,d));
			Rep_Hours_per_CPslice(y,r,cpgp,cpseg) :=sum((m,d,h)|Group_ECP(r,y,m,d,h)=ORD(cpgp) and Segment_ECP(r,y,m,d,h)=ORD(cpseg),IDAYTQ_orig(m,d));
			
			!Storage capacity
			Rep_DischargeCap(y,pts,r,Steps,m,d,h) := sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr),
								Battery_DischargeCap(pts, r, y, Steps, hr));
			Rep_DischargeCap(y,pts,r,Steps,m,'3',h) := Rep_DischargeCap(y,pts,r,Steps,m,'1',h)	;
			
			!Available storage for spinning reserves
			Rep_Storage_sr(y,pts,r,Steps,m,d,h) := max(0,min(Rep_DischargeCap(y,pts,r,Steps,m,d,h),Rep_StorageLevel(y,pts,r,Steps,m,d,h) + Rep_Storage(y,pts,r,Steps,m,d,h,'Storage_In')*BatteryEfficiency(pts))
								- Rep_Storage(y,pts,r,Steps,m,d,h,'Storage_Out'));
			Rep_Storage_sr(y,ptpvb,r,'1',m,d,h) := min(Rep_DischargeCap(y,ptpvb,r,'1',m,d,h) * 3 - Rep_Generation(y, ptpvb, r, '1', m, d, h, '1'), Rep_Storage_sr(y,ptpvb,r,'1',m,d,h)) ;
			Rep_Storage_sr(y,ptpvb,r,'2',m,d,h) := min(Rep_DischargeCap(y,ptpvb,r,'1',m,d,h) * 3 - Rep_Generation(y, ptpvb, r, '1', m, d, h, '2'), Rep_Storage_sr(y,ptpvb,r,'1',m,d,h)) ;
			
			!these are temporary accounting for PV+battery (generation = generation (PV -> grid) + storage_out (Batt -> grid)
			Rep_Generation(y, ptpvb, r, '1', m, d, h, '1'):= Rep_Generation(y, ptpvb, r, '1', m, d, h, '1') + Rep_Storage(y, ptpvb, r,'1', m, d, h, 'Storage_Out');
			Rep_Generation(y, ptpvb, r, '1', m, d, h, '2'):= Rep_Generation(y, ptpvb, r, '1', m, d, h, '2') + Rep_Storage(y, ptpvb, r,'1', m, d, h, 'Storage_Out');
			
			Rep_Gen_Slice(y,pt,r,Steps,loadgp,loadseg):=sum((m,d,h)|EMMGroup(r,y,m,d,h)=ORD(loadgp) and EMMSegment(r,y,m,d,h)=ORD(loadseg),Rep_Generation(y,pt,r,Steps,m,d,h,'1')*IDAYTQ_orig(m,d));
			Rep_Sto_Slice(y,pts,r,Steps,loadgp,loadseg):=sum((m,d,h,Stor)|EMMGroup(r,y,m,d,h)=ORD(loadgp) and EMMSegment(r,y,m,d,h)=ORD(loadseg),Rep_Storage(y,pts,r,Steps,m,d,h,Stor)*IDAYTQ_orig(m,d));
			
			
			!Available storage for spinning reserves as a fraction of capacity mapped to slices
			Rep_Sto_sr_Slice_frac(y,pts,r,Steps,loadgp,loadseg):=sum((m,d,h)|EMMGroup(r,y,m,d,h)=ORD(loadgp) and EMMSegment(r,y,m,d,h)=ORD(loadseg) and (ORD(Steps) = 1 or ORD(Steps) = 2), Rep_Storage_sr(y,pts,r,Steps,m,d,h)*IDAYTQ_orig(m,d)/$Rep_DischargeCap(y,pts,r,Steps,m,d,h))/$Rep_Hours_per_slice(y,r,loadgp,loadseg) ;
			Rep_Sto_sr_CPSlice_frac(y,pts,r,Steps,cpgp,cpseg):=sum((m,d,h)|Group_ECP(r,y,m,d,h)=ORD(cpgp) and Segment_ECP(r,y,m,d,h)=ORD(cpseg) and (ORD(Steps) = 1 or ORD(Steps) = 2), Rep_Storage_sr(y,pts,r,Steps,m,d,h)*IDAYTQ_orig(m,d)/$Rep_DischargeCap(y,pts,r,Steps,m,d,h))/$Rep_Hours_per_CPslice(y,r,cpgp,cpseg) ;
			
			!correct for inverter capacity
			Rep_Sto_sr_Slice_frac(y,ptpvb,r,Steps,loadgp,loadseg):= Rep_Sto_sr_Slice_frac(y,ptpvb,r,Steps,loadgp,loadseg)/3.0; 
			Rep_Sto_sr_CPSlice_frac(y,ptpvb,r,Steps,cpgp,cpseg):= Rep_Sto_sr_CPSlice_frac(y,ptpvb,r,Steps,cpgp,cpseg)/3.0 ;
			
			ReportData;
		}
	}
	Procedure PostMainInitialization_wos {
		Body: {
			!Rep Curtailment    
			IntermittentCurtailment(pti, reg, y, hr) := 
			    sum((s,Steps,tech)|Map_SeasonHour(s, hr) and Map_EcpGroup(tech, pti),SupplyCurve(reg, s, pti, y, Steps)*SolWinCapFactor_ER(reg, y, hr, tech))
			    - sum(Steps,Generation(pti, y, reg, Steps, hr).Level);
			IntermittentCurtailment(pth, reg, y, hr) := 
			    sum((s,mm)|Map_SeasonHour(s, hr) and Map_MonthHour(mm, hr) ,SupplyCurve(reg, s, pth, y, '2')*HydroCapFactor(mm, reg))
			    - Generation(pth, y, reg, '2', hr).Level;
			!for PV+battery, we need to make sure we don't count inverter clipping as curtailment.
			IntermittentCurtailment(ptpvb, reg, y, hr) := 
			    sum((s,Steps,tech)|Map_SeasonHour(s, hr) and Map_EcpGroup(tech, ptpvb),SupplyCurve(reg, s, ptpvb, y, Steps)*SolWinCapFactor_ER(reg,y,  hr, tech))
			    - sum(Steps,Generation(ptpvb, y, reg, Steps, hr).Level) - Storage_inflow(ptpvb, y, reg, '1',hr);
			PVBattClipping(reg,y,hr) :=     sum(ptpvb,sum(Steps,GenerationMaxTotal(ptpvb,y,reg,Steps,hr))
			    - sum(Steps,Generation(ptpvb, y, reg, Steps, hr).Level) - Storage_inflow(ptpvb, y, reg, '1',hr) - IntermittentCurtailment(ptpvb, reg, y, hr)|(IntermittentCurtailment(ptpvb, reg, y, hr)>0.000000001)  );
			Rep_PVBattClipping(y,r,m,d,h,'1') := sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr),PVBattClipping(r,y,hr)|(PVBattClipping(r,y,hr)>0.000000001));
			Rep_PVBattClipping(y,r,m,'3',h,'1') := sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour('1', hr),PVBattClipping(r,y,hr)|(PVBattClipping(r,y,hr)>0.000000001));
			
			!adjusting curtailment and generation numbers to make it even among groups
			SolarCurtailment(reg, y, hr):= sum(ptsol,IntermittentCurtailment(ptsol, reg, y, hr)|(IntermittentCurtailment(ptsol, reg, y, hr)>0.000000001));
			
			IntermittentCurtailment2(ptsol, reg, y, hr) := SolarCurtailment(reg, y, hr) * 
			 sum((s,Steps,tech)|Map_SeasonHour(s, hr) and Map_EcpGroup(tech, ptsol),SupplyCurve(reg, s, ptsol, y, Steps)*SolWinCapFactor_ER(reg, y, hr, tech) - Storage_inflow(ptsol,y,reg,Steps,hr))/
			 $sum((s,Steps,tech,ptsol2)|Map_SeasonHour(s, hr) and Map_EcpGroup(tech, ptsol2),SupplyCurve(reg, s, ptsol2, y, Steps)*SolWinCapFactor_ER(reg, y, hr, tech) - Storage_inflow(ptsol2,y,reg,Steps,hr));
			
			Generation(ptsol, y, r, '1', hr).Level := Generation(ptsol, y, r, '1', hr).Level + IntermittentCurtailment(ptsol, r, y, hr) - max(0.0,IntermittentCurtailment2(ptsol, r, y, hr));
			
			IntermittentCurtailment(ptsol, reg, y, hr) := IntermittentCurtailment2(ptsol, reg, y, hr) ;
			
			Rep_Curtailment(y, ptipv, r, m, d, h, '1'):= sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr),IntermittentCurtailment(ptipv, r, y, hr)|(IntermittentCurtailment(ptipv, r, y, hr)>0.000000001));
			Rep_Curtailment(y, ptipv, r, m, '3', h, '1'):= sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour('1', hr),IntermittentCurtailment(ptipv, r, y, hr)|(IntermittentCurtailment(ptipv, r, y, hr)>0.000000001));
			
			Rep_Curtailment(y,pth,r,m,d,h,'1') :=sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr), IntermittentCurtailment(pth, r, y, hr)|(IntermittentCurtailment(pth, r, y, hr)>0.000000001));
			Rep_Curtailment(y,pth,r,m,'3',h,'1') :=sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour('1', hr), IntermittentCurtailment(pth, r, y, hr)|(IntermittentCurtailment(pth, r, y, hr)>0.000000001));
			
			!Report generation dispatch data
			!Rep Generation
			Rep_Generation(y, pt, r, Steps, m, d, h, '1'):= 
			    sum(hr| Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr),
			    Generation(pt, y, r, Steps, hr).Level);
			Rep_Generation(y, pt, r, Steps, m, '3', h, '1'):= 
			    sum(hr| Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour('1', hr),
			    Generation(pt, y, r, Steps, hr).Level);
			
			!Rep Shadow price
			HourlyShadowPrice(reg, y, hr) := -Demand_balance(reg, y, hr).ShadowPrice;
			HourlyShadowPrice(reg, y, hr) :=HourlyShadowPrice(reg, y, hr)/Dayweights(hr);
			Rep_MarginalPrices(y, r, m, d, h, '1'):= sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr),HourlyShadowPrice(r, y, hr));
			Rep_MarginalPrices(y, r, m, '3', h, '1'):= sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour('1', hr),HourlyShadowPrice(r, y, hr));
			!Rep unmet load
			Rep_umet_Load(y, r, m, d, h,'1'):=sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr), unmet_Load(r, y, hr).Level);
			Rep_umet_Load(y, r, m, '3', h,'1'):=sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour('1', hr), unmet_Load(r, y, hr).Level);
		}
	}
	Procedure PostMainInitialization {
		Body: {
			!Rep Curtailment    
			IntermittentCurtailment(pti, reg, y, hr) := 
			    sum((s,Steps,tech)|Map_SeasonHour(s, hr) and Map_EcpGroup(tech, pti),SupplyCurve(reg, s, pti, y, Steps)*SolWinCapFactor_ER(reg, y, hr, tech))
			    - sum(Steps,Generation(pti, y, reg, Steps, hr).Level);
			IntermittentCurtailment(pth, reg, y, hr) := 
			    sum((s,mm)|Map_SeasonHour(s, hr) and Map_MonthHour(mm, hr) ,SupplyCurve(reg, s, pth, y, '2')*HydroCapFactor(mm, reg))
			    - Generation(pth, y, reg, '2', hr).Level;
			!need to make sure PV+battery doesn't count inverter clipping as curtailment
			IntermittentCurtailment(ptpvb, reg, y, hr) := 
			    sum((s,Steps,tech)|Map_SeasonHour(s, hr) and Map_EcpGroup(tech, ptpvb),SupplyCurve(reg, s, ptpvb, y, Steps)*SolWinCapFactor_ER(reg, y, hr, tech))
			    - sum(Steps,Generation(ptpvb, y, reg, Steps, hr).Level) - Storage_inflow(ptpvb, y, reg, '1',hr);
			
			PVBattClipping(reg,y,hr) := sum(ptpvb,sum(Steps,GenerationMaxTotal(ptpvb,y,reg,Steps,hr))
			    - sum(Steps,Generation(ptpvb, y, reg, Steps, hr).Level) - Storage_inflow(ptpvb, y, reg, '1',hr) - IntermittentCurtailment(ptpvb, reg, y, hr)|(IntermittentCurtailment(ptpvb, reg, y, hr)>0.000000001));
			Rep_PVBattClipping(y,r,m,d,h,'2') := sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr),PVBattClipping(r,y,hr)|(PVBattClipping(r,y,hr)>0.000000001));
			Rep_PVBattClipping(y,r,m,'3',h,'2') := sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour('1', hr),PVBattClipping(r,y,hr)|(PVBattClipping(r,y,hr)>0.000000001));
			
			!adjusting curtailment and generation numbers to make it even among groups
			SolarCurtailment(reg, y, hr):= sum(ptsol,IntermittentCurtailment(ptsol, reg, y, hr)|(IntermittentCurtailment(ptsol, reg, y, hr)>0.000000001));
			
			IntermittentCurtailment2(ptsol, reg, y, hr) := SolarCurtailment(reg, y, hr) * 
			 sum((s,Steps,tech)|Map_SeasonHour(s, hr) and Map_EcpGroup(tech, ptsol),SupplyCurve(reg, s, ptsol, y, Steps)*SolWinCapFactor_ER(reg, y, hr, tech) - Storage_inflow(ptsol,y,reg,Steps,hr))/
			 $sum((s,Steps,tech,ptsol2)|Map_SeasonHour(s, hr) and Map_EcpGroup(tech, ptsol2),SupplyCurve(reg, s, ptsol2, y, Steps)*SolWinCapFactor_ER(reg, y, hr, tech) - Storage_inflow(ptsol2,y,reg,Steps,hr));
			
			Generation(ptsol, y, r, '1', hr).Level := Generation(ptsol, y, r, '1', hr).Level + IntermittentCurtailment(ptsol, r, y, hr) - max(0.0,IntermittentCurtailment2(ptsol, r, y, hr));
			
			IntermittentCurtailment(ptsol, reg, y, hr) := IntermittentCurtailment2(ptsol, reg, y, hr) ;
			Rep_Curtailment(y, ptipv, r, m, d, h, '2'):= sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr),IntermittentCurtailment(ptipv, r, y, hr)|(IntermittentCurtailment(ptipv, r, y, hr)>0.000000001));
			Rep_Curtailment(y, ptipv, r, m, '3', h, '2'):= sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour('1', hr),IntermittentCurtailment(ptipv, r, y, hr)|(IntermittentCurtailment(ptipv, r, y, hr)>0.000000001));
			Rep_Curtailment(y,pth,r,m,d,h,'2') :=sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr), IntermittentCurtailment(pth, r, y, hr)|(IntermittentCurtailment(pth, r, y, hr)>0.000000001));
			Rep_Curtailment(y,pth,r,m,'3',h,'2') :=sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour('1', hr), IntermittentCurtailment(pth, r, y, hr)|(IntermittentCurtailment(pth, r, y, hr)>0.000000001));
			
			!Rep Shadow price
			HourlyShadowPrice(reg, y, hr) := -Demand_balance(reg, y, hr).ShadowPrice;
			HourlyShadowPrice(reg, y, hr) :=HourlyShadowPrice(reg, y, hr)/Dayweights(hr);
			Rep_MarginalPrices(y, r, m, d, h, '2'):= sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr),HourlyShadowPrice(r, y, hr));
			Rep_MarginalPrices(y, r, m, '3', h, '2'):= sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour('1', hr),HourlyShadowPrice(r, y, hr));
			
			!Report generation dispatch data
			!Rep Generation
			Rep_Generation(y, pt, r, Steps, m, d, h, '2'):= 
			    sum(hr| Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr),
			    Generation(pt, y, r, Steps, hr).Level);
			Rep_Generation(y, pt, r, Steps, m, '3', h, '2'):= 
			    sum(hr| Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour('1', hr),
			    Generation(pt, y, r, Steps, hr).Level); 
			
			!Rep Storage!! Attention: Steps=2 is increment storage
			Rep_Storage(y, pts, r,Steps, m, d, h, 'Storage_Out'):= 
			sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr),
			    Storage_outflow(pts, y, r, Steps, hr));
			
			Rep_Storage(y, pts, r,Steps, m, d, h, 'Storage_In'):= 
			    -sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr),
			    Storage_inflow(pts, y, r, Steps, hr));  
			
			Rep_Storage(y, pts, r,Steps, m, '3', h, 'Storage_Out'):=
			    sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour('1', hr),Storage_outflow(pts, y, r, Steps, hr)); 
			Rep_Storage(y, pts, r,Steps, m, '3', h, 'Storage_In'):=
			    -sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour('1', hr),Storage_inflow(pts, y, r, Steps, hr));  
			
			Rep_StorageLevel(y, pts, r, Steps, m, d, h):= sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr),
			        Storage_level(pts, y, r, Steps, hr));     
			Rep_StorageLevel(y, pts, r, Steps, m, '3', h):= Rep_StorageLevel(y, pts, r, Steps, m, '1', h);                     
			
			!Rep unmet load
			Rep_umet_Load(y, r, m, d, h,'2'):=sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour(d, hr), unmet_Load(r, y, hr).Level);
			Rep_umet_Load(y, r, m, '3', h,'2'):=sum(hr|Map_MonthHour(m, hr) and Map_EcpHour_Emmhour(hr, h) and Map_Daytype_Hour('1', hr), unmet_Load(r, y, hr).Level);
		}
	}
	ExternalProcedure CSVExport {
		Arguments: (param,location);
		DllName: CSVExportDllName;
		BodyCall: {
			CSVExport(
			        scalar string : param,
			        scalar string : location
			        )
		}
		ElementParameter param {
			Range: AllIdentifiers;
			Property: Input;
		}
		StringParameter location {
			Default: ".";
			Property: Optional;
		}
	}
	Procedure ReportData {
		Body: {
			CSVExport('Rep_Generation',OutputDir);
			CSVExport('Rep_Curtailment',OutputDir);
			CSVExport('Rep_MarginalPrices',OutputDir);
			CSVExport('Rep_Storage',OutputDir);
			CSVExport('Rep_umet_Load',OutputDir);
			CSVExport('Rep_StorageLevel',OutputDir);
			CSVExport('Rep_Gen_Slice',OutputDir);
			CSVExport('Rep_Sto_Slice',OutputDir);
			CSVExport('Rep_Hours_per_slice',OutputDir);
			CSVExport('Rep_PVBattClipping',OutputDir);
			!CSVExport('Rep_Storage_sr',OutputDir);
			!CSVExport('Rep_DischargeCap',OutputDir);
			CSVExport('Rep_Sto_sr_Slice_frac',OutputDir);
			CSVExport('Rep_Sto_sr_CPSlice_frac',OutputDir);
			
			if SW_OutputData = 1 then
				CSVExport('Rep_output_all',OutputDir);
				CSVExport('Rep_output_seasonal',OutputDir);
			endif;
			
			! set return code
			if EMM_renewable.ProgramStatus = 'Optimal' and EMM_renewable.SolverStatus = 'NormalCompletion' then
				restcode(1) := 0;
			elseif EMM_renewable.ProgramStatus = 'Infeasible' then
			  	restcode(1) := 1;
			elseif EMM_renewable.ProgramStatus = 'Unbounded' then
				restcode(1) := 2;
			elseif EMM_renewable.SolverStatus = 'InternalSolverError' then
				restcode(1) := 3;
			elseif EMM_renewable.SolverStatus = 'SolverNotCalled' then
				restcode(1) := 4;
			elseif EMM_renewable.SolverStatus = 'SolverFailure' then
				restcode(1) := 5;
			elseif EMM_renewable.SolverStatus = 'SetupFailure' then
				restcode(1) := 6;
			elseif EMM_renewable.SolverStatus = 'PreprocessorError' then
				restcode(1) := 7;
			elseif EMM_renewable.SolverStatus = 'PostProcessorError' then
				restcode(1) := 8;
			elseif EMM_renewable.ProgramStatus = 'NoSolution' then
				restcode(1) := 9;
			else
			        restcode(1) :=10;  !See ResultsMessage(yr) for specific cause of error
			endif;
			put RETURNCODE;          ! opens file to hold return code
			display {RESTCODE(M1)};
			putclose;
		}
	}
	Procedure MainTermination {
		Body: {
			!return DataManagementExit();
			sAction:="Exited";    ! Action message for NEMS
			write sAction to file NEMSMessageOutFile in replace mode;  
			return 1;
		}
		Comment: {
			"Add termination statements here that do not require all libraries to be still alive.
			Return 1 to allow the termination sequence to continue.
			Return 0 if you want to cancel the termination sequence.
			It is recommended to only use the procedure PreMainTermination to cancel the termination sequence and let this procedure always return 1."
		}
	}
	Procedure DataVisualization {
		Body: {
			GenerationBy_Group(techgro, y, hr, r) :=sum((pt,steps)|Map_ptecpgroup(pt, techgro), Generation(pt, y, r, Steps, hr));
			GenerationBy_Group('Storage_out', y, hr, r) :=sum((pts,steps), Storage_outflow(pts, y, r, Steps, hr));
		}
	}
	DeclarationSection NEMS_Monitor_Identifiers {
		Parameter CountSleep;
		File NEMSMessageInFile {
			Name: sMessageInFile;
			Device: Disk;
			Mode: replace;
		}
		File NEMSMessageOutFile {
			Name: sMessageOutFile;
			Device: Disk;
			Mode: replace;
		}
		StringParameter sMessageInFile {
			Definition: "monitor.in.txt";
		}
		StringParameter sMessageOutFile {
			Definition: "monitor.out.txt";
		}
		StringParameter sAction;
		StringParameter sStatusMessage;
	}
	Procedure NEMS_Monitor {
		Body: {
			     ! an initial LoadGlobal would be required because this procedure is invoked from the command line, but restore seems not to save cases.
			     ! Aimms doesn't load case files automatically, as specified in the project settings, when a procedure is invoked from the command line.   
			     ! Also not doing Read of data; that gets done in MainInitialization called below.
			
			     ! the following allows the aimms project to be kept open (when keepopen=1) and to later Quit at direction of NEMS,
			     ! or to run and exit immediately. NEMS is set up to wait for 
			     ! an action message of "Exited" written by the MainTermination procedure right before aimms exits.
			     CountSleep := 0;
			     ! count sleep/wake cycles while waiting for direction from nems via sAction in the message file, monitor.in.txt
			     while ( CountSleep <= 2000 ) do
			        if fileexists(sMessageInFile) then
			        ! read sAction, current model year, and current iteration from sMessageInFile
			          sAction:=" ";
			          read from file sMessageInFile in merge mode;
			        else
			          put "the NEMS message file not found, CountSleep=",CountSleep," \n ";
			        endif;
			        if sAction = "MainExecution" then
			          sAction:="executing";    ! Action message to tell NEMS I'm executing
			          write sAction to file NEMSMessageOutFile in replace mode;  
			
			          dialogProgress(""); ! remove progress dialog
			          read year from file "ECPYEAR.txt";
			          sStatusMessage := formatstring("Invoking MainInitialization for %s",first(year));
			          put sStatusMessage;
			          MainInitialization;
			          sAction:=formatstring("Completed %s,",first(year)) ;    ! Action message to tell NEMS I'v completed this year, iteration
			          write sAction to file NEMSMessageOutFile in replace mode;  
			          CountSleep:=0;   
			          sStatusMessage := "Monitoring NEMS message file("+sMessageInFile+") for "+formatstring("%s",CountSleep/2)+" seconds. Hit Ctrl+Shift+S to Stop this monitoring\n";
			          put sStatusMessage;
			          Delay(1);    ! give nems a chance to pick up status and create new monitor.in.txt file                
			        elseif sAction = "Quit" then ! NEMS says to exit aimms
			          CountSleep:=2000;
			        else
			          sStatusMessage := "Monitoring NEMS message file("+sMessageInFile+") for "+formatstring("%s",CountSleep)+" seconds. Hit Ctrl+Shift+S to Stop this monitoring\n";
			          Delay(.5);                  
			        endif;
			        dialogProgress(sStatusMessage,round(100*CountSleep/2000));
			        CountSleep += 1;
			
			     endwhile;
			     if CountSleep>=2001 then
			       put "Quit directive found in monitor.in.txt. Exiting AIMMS";
			     else
			       put "Wait time exceeded. Exiting Aimms";
			     endif;
			     exitAimms; ! causes MainTermination to run and for aimms to exit. MainTermination sends message "Exited" back to nems.
		}
		Comment: {
			"This routines communicates with teh Fortran via monitor in/out message files. If the file
			is found, AIMMS reads it and re-invokes mainexecution if indicated, or closes the project.  
			After invoking mainExecution, it writes an output message file indicating completion.
			This routine then continues the sleep-wait cycle."
		}
	}
}
