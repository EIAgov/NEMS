! $Header: m:/default/source/RCS/renew.f,v 1.229 2020/10/19 16:54:06 CGA Exp $
!
module P_

       !NEMS include files
       INCLUDE 'parametr'
       INCLUDE 'NCNTRL'
       INCLUDE 'EMMPARM'
       INCLUDE 'WRENEW'
       INCLUDE 'WWDCOMON'
       include 'uefdout'

!!!POLYSYS variables
!use for lags -- when transferring code from UT must add this dimension to some variables for lags
! Note:  UT = University of Tennessee
  INTEGER :: NPT,NUMNPT,PSYEARS
  PARAMETER (NUMNPT=5)
  PARAMETER (PSYEARS=35)
  integer var1
  ! To change the number of poly regions, change npolyreg to 16 or 305 and uncomment correct mapping. No need to change PSSIM file in this version
  INTEGER :: NPOLYREG
 ! PARAMETER (NPOLYREG=305)
  PARAMETER (NPOLYREG=16)
  INTEGER :: NPOLYREG2
 ! PARAMETER (NPOLYREG2=3111) !use this to reduce the size of the baseline files from UT or when running with baseline files directly from UT
  PARAMETER (NPOLYREG2=16)
   INTEGER SHRINK_BASE
   PARAMETER (SHRINK_BASE=0) !set to zero for NEMS runs; set to 1 when shrinking baseline files from UT
   integer coal_map(npolyreg)
 !  data coal_map /1,3,3,3,1,1,1,3,3,3,3,3,1,1,2,2,& !16
 !     2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,&
 !      2,2,2,1,1,3,3,3,3,3,3,3,3,3,3,4,&
 !      4,4,4,4,4,4,4,8,8,8,8,8,8,8,8,8,&
 !      8,8,8,4,4,4,4,4,4,5,5,5,5,5,5,5,& !80
 !      5,5,5,5,5,5,9,9,9,9,9,9,12,12,12,& !95
 !      12,12,12,12,12,12,12,12,12,12,12,&  !106
 !      12,12,12,12,9,9,9,9,9,9,9,9,9,11,&  !120
 !      11,11,11,11,11,11,11,11,11,11,11,& !131
 !      11,11,11,11,11,11,7,7,7,7,7,7,7,& !144
 !      7,7,7,7,7,7,7,7,7,7,7,6,6,6,6,6,& !160
 !      6,6,6,6,11,11,11,11,11,11,11,11,& !172
 !      11,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,& !188
 !      7,7,7,10,10,10,10,10,10,10,10,10,& !200
 !      11,11,11,11,11,11,11,11,11,11,11,& !211
 !      11,11,11,11,11,11,11,11,11,11,11,& !222
 !      11,11,11,11,12,12,12,12,12,12,12,& !233
 !      12,12,12,12,12,12,12,12,12,12,12,& !244
 !      12,12,12,12,12,12,13,13,13,13,13,& !255
 !      13,13,13,13,13,13,13,13,13,13,13,& !266
 !      14,14,14,14,14,14,14,14,14,14,14,14,14,&  !279
 !      15,15,15,15,15,15,15,15,16,16,16,16,&  !291
 !      16,16,16,16,16,16,16,16,16,&  !300
 !      16,16,16,16,16/ !305

              data coal_map /1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16/

!      COMMON/NPTS/ NPT
! PSALWAYS
       REAL ::           FBCOF
      REAL ::            INFL(50,3,18),PPI(50)
      INTEGER ::         INDEX(200)
      INTEGER ::         K,I,L,STA,U,N,crdl,POLY,ILOOP,NITERATIONS
      INTEGER ::         POLYCURIYR,POLYFIRSTYR, KSAVE

      INTEGER ::         CTY,CNTY,T,PFFR,ALWAYSCNTY
      INTEGER ::         CRASHNUM,SEEDYR
      CHARACTER(4) ::    YEARNAME(PSYEARS)
   !   CHARACTER(3) ::    YEARS(PSYEARS)
      REAL YEARS
      CHARACTER(200) ::  WRKDIR

      CHARACTER(3) ::    EXTPRE
      CHARACTER(3) ::    EXTSUF
      CHARACTER(6) ::    EXTT
      CHARACTER(3) ::    BASEFILE
      CHARACTER(100) ::  USERDEFPATH
      CHARACTER(22) ::   CHAD
      CHARACTER(75) ::   CRASHYR,CRASHYROLD
      CHARACTER(12) ::   BASELINE,DEBUGFILE,BASEREG

!      COMMON/ALWAYSR/ FBCOF,INFL,PPI
!      COMMON/ALWAYS/K,I,L,STA,U,INDEX,N,crdl,POLY,ILOOP,NITERATIONS,POLYCURIYR,POLYFIRSTYR,CRASHNUM,SEEDYR,CTY,CNTY,PFFR,IYRNUM,KSAVE,ALWAYSCNTY
!      COMMON/ALWAYSC/WRKDIR,BASEFILE,YEARNAME,YEARS,BASELINE,DEBUGFILE,BASEREG,EXTPRE,EXTSUF,CRASHYR,CRASHYROLD,USERDEFPATH,CHAD,EXTT

! PSAGGREG
      ! AGGREGATE VARIABLES
       REAL A(NUMNPT,PSYEARS,41,3),AB(PSYEARS,41,3),XA(PSYEARS,10,2),XAB(PSYEARS,10,2) &
                 ,FCTRCP(7),YRPER(7),FCTRLV(7),PERFG(4),PERMET(2) &
                 ,PERPOL(3),PERLV(3),PERCP(4),PERALL(2),CONVSN(24)

! PSAVERAG
        REAL AVGC(PSYEARS,34,18),AVGX(PSYEARS,34,18),AVGS(PSYEARS,4,7) &
                  ,AVGXS(PSYEARS,3,7),AVGA(PSYEARS,41,3),AVGXA(PSYEARS,10,2)
!       COMMON /AVERAG/ AVGC,AVGX,AVGS,AVGXS,AVGA,AVGXA

 !PSCASH
      REAL :: CSCP(5,2,15)
      REAL :: CSLV(4,7)
      REAL :: BASECP(PSYEARS,10,15)
      REAL :: BASELV(PSYEARS,7)
      REAL :: SMCPYR(PSYEARS,15)
      REAL :: smc(PSYEARS,2,15)
      REAL :: SNT(2,32,305)

 !PSCRP
      REAL CRPPERCENT(18)

   !PSERSREG
       REAL,DIMENSION(8,15,7)          :: EEAC
       REAL,DIMENSION(3,15,7)          :: EAJR
 
 !PSELAST1
       REAL :: EAC(15,18),EGC(15,18),AJC(15,18),EGP(5,3),AJP(5,3),EGPN(3)
 
   !PSELAST2
        REAL :: EDML(8,7),EGL(10,7),AJL(4,7)
 
 !PSGAUSS
        INTEGER :: IGAUS1(5),IGAUS2(3),IGAUSP(3),ITERA(PSYEARS,3)

 
  !PSGRAIN
      REAL ::      C(NUMNPT,PSYEARS,50,20) !2021 update
      REAL ::      B(PSYEARS,50,20)  !2021 update
      REAL ::      X(PSYEARS,50,18)
      REAL ::      XB(PSYEARS,50,18)
      REAL ::      CFIXED(PSYEARS,50,20) !2021 update
      REAL ::      ARP(PSYEARS,18)
      REAL ::      ARPTEST(PSYEARS)
      REAL ::      PC(NUMNPT,PSYEARS,10,3)
      REAL ::      PB(PSYEARS,10,3)
      REAL ::      PX(PSYEARS,5,3)
      REAL ::      PXB(PSYEARS,5,3)
      REAL ::      CRMR(PSYEARS)
      REAL ::      CRMRB(PSYEARS)
      REAL ::      PCFIXED(PSYEARS,3,3)
      REAL ::      PNX(PSYEARS,4)
      REAL ::      PNXB(PSYEARS,4)
      REAL ::      PNC(PSYEARS,5)
      REAL ::      PNB(PSYEARS,5)
      REAL ::      SGC(PSYEARS,4)
      REAL ::      SGB(PSYEARS,4)
      REAL ::      SGX(PSYEARS,4)
      REAL ::      SGXB(PSYEARS,4)
      REAL ::      TEMPBX(18)
      REAL ::      TEMPBDF(18)
      REAL ::      TEMPBP(18)
      REAL ::      TEMPBDO(18)
      REAL ::      TEMPBDI(18)
      REAL ::      EN(NUMNPT,PSYEARS,20,18)
      REAL ::      ENB(PSYEARS,20,18)
      REAL ::      DRATEK(PSYEARS,18)
      REAL ::      FRATEK(PSYEARS,18)
      REAL ::      AFCTRK(PSYEARS,18)
      INTEGER ::   CRVPT
      INTEGER ::   CRVPTNUM


   ! PSLVSTK
       REAL :: SFIXED(PSYEARS,1,7),OLDS(PSYEARS,42,7),OLDSB(PSYEARS,42,7), &
                   OLDXS(PSYEARS,29,7),OLDXSB(PSYEARS,29,7)


   ! PSPASTPR
       REAL HISTPR(22,15)  !  First Index must be 10 plus the number of years in baseline.


   ! PSPRINT
      CHARACTER(72) :: TITLE1,TITLE2,BASEID
      REAL :: BGSTK(PSYEARS)


      !PSREGV1
      DOUBLE PRECISION :: CSX(15,50,10,15) &
                                          ,CSXB(15,50,10,15)
      DOUBLE PRECISION :: USAVCS(18),USTVCS(18),USTACR(18),USTPRD(18), &
                                           USYIELD(18),USTPLT(18), &
                                          USPLTB,USPLT
      DOUBLE PRECISION :: BLAVCS(PSYEARS,18), &
                                           BLTVCS(PSYEARS,18)
      DOUBLE PRECISION :: SMAVCS(PSYEARS,18),SMTVCS(PSYEARS,18)
      INTEGER :: IBASEFLAG,ICOUNTER
      REAL :: WCUR, WLST

 

    !PSREGV2
      REAL :: AdjFac(PSYEARS,6,18)
      REAL :: PRCOEF(2,18)
      CHARACTER(2) ::      STATE(305)


   ! PSMAXLP
      DOUBLE PRECISION ::  LPA(500,500),RHS(500),MINBIO(45,4)
      DOUBLE PRECISION ::  bb(147,273),pp(13,22),qq(22,47)
      INTEGER ::           NAME(500),BASELINEDONE,M,M1,M2,M3,RN,VN,KSORTED
      REAL :: tt


     ! PSLVAR
       CHARACTER(14) :: SK
       REAL :: LVP(81,6)
       REAL :: S(NUMNPT,PSYEARS,63,7),SB(PSYEARS,63,7),XS(NUMNPT,PSYEARS,33,7),XSB(PSYEARS,33,7), &
                    TM(PSYEARS),SAU(PSYEARS,13,3),SAUB(PSYEARS,13,3), &
                    XAG(PSYEARS,15),XAGB(PSYEARS,15),XCR(NUMNPT,PSYEARS,18),XCRB(PSYEARS,18), &
                    slast(42,7), &
                   SITERA,IDONE,IYR,FIRATIO,PATH,SIMUL, &
                   bigiter
       INTEGER  IYEAR(PSYEARS)



       ! PSGOVBUD
       REAl ::  GB(PSYEARS,20,18),GC(NUMNPT,PSYEARS,20,18),XGB(PSYEARS,8,18) &
                  ,XGC(PSYEARS,8,18),ADJLDP(18),AdESPL(18),EQ11(18) &
                  ,EQ12(18),CYL(18),CYY(18),CL(18),CLL(18) &
                  ,ESPLB(18),ESPLC(18),ESBLB(18),ESBLC(18) &
                  ,EQ13(18),AdESBL(18),EQ21(18),EQ22(18) &
                  ,WPB,WP,BCCP(18),CCP(18)
 
 

 ! PSBIOMASS
        REAL,DIMENSION(71,18,6)     :: HARVC
        REAL :: NEWPRC(NUMNPT,PSYEARS,3111),OLDPRC,CORRPRC,SAVNEW,BIOLOW,DRYGSUB
        REAL :: BF2BD(PSYEARS),FD2BD(PSYEARS),PL2BD(PSYEARS),BIOEF(PSYEARS,18)
        REAL :: BDFBF(PSYEARS),BDFFD(PSYEARS),BDFPL(PSYEARS),POPULATION(PSYEARS)
        REAL :: NUT(18,11)
        INTEGER :: INPV
        INTEGER DLOOP
        REAL REGBIODMD(PSYEARS,10,20), REGBIO(3111)
	REAL REGBIOSPLY(PSYEARS,10,20), REGPRC(PSYEARS,10), BIOCOSTADJ(PSYEARS,5)
         REAL REGFDSTK(PSYEARS,14,2,10), FDSTK(PSYEARS,14,10)

        REAL :: TOTALNPV(PSYEARS,18),ANPV(PSYEARS,18) &
                  ,BIOHRVST(50,305) &
                  ,BIOPRICE(80,305),DRATE,FRATE,BIOSUM &
                  ,BIOPRD(PSYEARS,63) &
                  ,ADJPRC,DIFFPRC,BIOITER,BIODONE &
                  ,BIOSPLY(PSYEARS,10),AVSTVR(PSYEARS,10),AVSTW(PSYEARS,10),AVSWTCH(PSYEARS,10) &
                  ,AVPOP(PSYEARS,10),AVWIL(PSYEARS,10),AVSWEET(PSYEARS,10),AVCRP(PSYEARS,10) &
                  ,AVMISCAN(PSYEARS,10),AVECANE(PSYEARS,10) &
                  ,BIODMND(PSYEARS,10),BIOCST(PSYEARS,5,10) &
                  ,AVWOOD(PSYEARS),WD(PSYEARS),POOP(PSYEARS,5) &
                  ,ELECTETH(PSYEARS),AVTHIN(PSYEARS,2)
  

! PSCOUNTY
       INTEGER ::   IRTLN(18)
        REAL :: NPV(NUMNPT,PSYEARS,18,4,NPOLYREG)
        REAL :: BIOPL(NUMNPT,PSYEARS,6,4,NPOLYREG)
        REAL :: PT(NUMNPT,PSYEARS,7,28,NPOLYREG)
        REAL :: APL(NUMNPT,PSYEARS,6,4,NPOLYREG)
        REAL :: PASTASS,MAXPRIC,RESETPRIC
        REAL :: YRRESID,YRHERB,YRWOODY,POPINCRES
        REAL :: PTTOTAL(PSYEARS)
        REAL, ALLOCATABLE :: CORNDOCK(:,:),SOYDOCK(:,:)
        REAL, ALLOCATABLE :: COTTONDOCK(:,:),SOYDOCKCT(:,:)
        REAL, ALLOCATABLE :: BSHIFT(:,:,:),PSHIFT(:,:,:)
        REAL, ALLOCATABLE :: NPVB(:,:,:,:),CY(:,:,:,:),CYB(:,:,:,:), LANDRENT(:,:),CYBACKUP(:,:,:)
        REAL, ALLOCATABLE :: CYX(:,:,:,:),CYXB(:,:,:,:)
        REAL, ALLOCATABLE :: PLACB(:,:,:,:),PLAC(:,:,:,:)
        REAL, ALLOCATABLE :: PRIC(:,:),YIELD(:,:,:)
        REAL, ALLOCATABLE :: COST(:,:,:)
        REAL, ALLOCATABLE :: CMX(:,:,:,:),HARVESTCOST(:,:)
        REAL, ALLOCATABLE :: AYL(:,:,:,:),WEST(:),EAST(:)
        REAL, ALLOCATABLE :: BIOAGE(:,:,:,:,:),PRDAGE(:,:,:,:,:)
        REAL, ALLOCATABLE :: CRN(:,:,:,:) ,TBMX(:,:,:)
        REAL, ALLOCATABLE :: PTB(:,:,:,:),PASTRENT(:,:)
        REAL, ALLOCATABLE :: PASTRETRN(:,:),BIGINDEX(:,:),RRR(:,:)

 

 ! PSCARBON
       REAL ::  INCENT(26,18,3,NPOLYREG)
       REAL, ALLOCATABLE :: BCARB(:,:,:)
       REAL :: CARBRATE(18,3),CARBTOT(PSYEARS,27),ENGY &
               ,BENERGY,CENT(PSYEARS,26),CARBINCT(PSYEARS),BRENTOIL
    

 ! PSBTRADE
      REAL :: BTRD(PSYEARS,10,18),BTRDB(PSYEARS,10,18),BTRDFIX(35,10,18)
      REAL :: TRDVAR(PSYEARS,10),TRDVARB(PSYEARS,10)


 !PSRESID
      REAL, ALLOCATABLE :: RCNTX(:,:,:,:),RCNT(:,:,:,:),MUTH(:,:,:,:,:)
      REAL :: RESEFF(PSYEARS,5,5) ,MSR,CLN
   

     !PSCOUNTY2
     REAL :: CYINEW(NUMNPT,PSYEARS,18,3,NPOLYREG)
   

      end module P_

!************************************************

      SUBROUTINE RENEW
      IMPLICIT NONE
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'control'
      include 'wrenew'
      include 'wrenio'
      include 'rencntl'
      include 'cogen'
      include 'uefdout'
      include 'dispinyr'

      INTEGER I,IT,IY,RN,No_rec

      INTEGER      RTOVALUE, FILE_MGR
      INTEGER      IYR, I_SUPt, CR, ICENSUS, IRG, ICNS
      CHARACTER*18 RENEWFILE
      EXTERNAL     RTOVALUE, FILE_MGR


!      if (unrgns .eq. 0) unrgns = mnumnr-3
!       WRITE(6,*)'unrgns inside renew ',UNRGNS,UESTYR,CURCALYR,EXE

      MP_BM_RS=0.0
      MP_BM_CM=0.0
      MP_BM_IN=0.0
      MP_BM_H2=1.0
      MP_BM_PW=1.0
      MP_BM_ET=1.0
      MP_BM_BT=1.0
!     MP_BM_ET(1:2)=0.0
!     MP_BM_ET(3:4)=1.0
!     MP_BM_BT(1)=1.0
!     MP_BM_BT(2)=0.0
!     MP_BM_BT(3:4)=1.0

!      Zero out quantity areas if the sector cannot use biomass supply type
!     DPVDISPATCH = .TRUE.   !change it to .FALSE. if the treatment for distributed PV capacity & generation needs to be turned off


       DO IYR = 1 , MNUMYR+ECP_D_FPH
          DO I_SUPt = 1 , MNUMFS
            IF (WDSUP_AVL(I_SUPt) .EQ. 1) THEN
               DO CR = 1 , NDREG

                  IF (MP_BM_RS(I_SUPt) .EQ. 0.0) THEN
                     QBMRSCL(I_SUPt,CR,CURIYR) = 0.0
                     QBMRSCL(I_SUPt,0,CURIYR) =  0.0
                     QBMRSCL(0,0,CURIYR) =  0.0
                  END IF

                  IF (MP_BM_CM(I_SUPt) .EQ. 0.0) THEN
                     QBMCMCL(I_SUPt,CR,CURIYR) = 0.0
                     QBMCMCL(I_SUPt,0,CURIYR) =  0.0
                     QBMCMCL(0,0,CURIYR) =  0.0
                  END IF

                  IF (MP_BM_IN(I_SUPt) .EQ. 0.0) THEN
                     QBMINCL(I_SUPt,CR,CURIYR) = 0.0
                     QBMINCL(I_SUPt,0,CURIYR) =  0.0
                     QBMINCL(0,0,CURIYR) =  0.0
                  END IF

                  IF (MP_BM_H2(I_SUPt) .EQ. 0.0) THEN
                     QBMH2CL(I_SUPt,CR,CURIYR) = 0.0
                     QBMH2CL(I_SUPt,0,CURIYR) =  0.0
                     QBMH2CL(0,0,CURIYR) =  0.0
                  END IF

                  IF (MP_BM_PW(I_SUPt) .EQ. 0.0) THEN
                     QBMPWCL(I_SUPt,CR,CURIYR) = 0.0
                     QBMPWCL(I_SUPt,0,CURIYR) =  0.0
                     QBMPWCL(0,0,CURIYR) =  0.0
                  END IF

                  IF (MP_BM_ET(I_SUPt) .EQ. 0.0) THEN
                     QBMETCL(I_SUPt,CR,CURIYR) = 0.0
                     QBMETCL(I_SUPt,0,CURIYR) =  0.0
                     QBMETCL(0,0,CURIYR) =  0.0
                  END IF

                  IF (MP_BM_BT(I_SUPt) .EQ. 0.0) THEN
                     QBMBTCL(I_SUPt,CR,CURIYR) = 0.0
                     QBMBTCL(I_SUPt,0,CURIYR) =  0.0
                     QBMBTCL(0,0,CURIYR) =  0.0
                  END IF
               END DO
            END IF
         END DO
      END DO

!******************************************************************
!               RFM TECHNOLOGY NUMBERING:
!
!
!                       ! 1.. HYDRO
!                       ! 2.. GEOTH FLASH
!                       ! 3.. GEOTH BINARY
!                       ! 4.. GEOTH PUMP
!                       ! 5.. MSW
!                       ! 6.. BIOMASS
!                       ! 7.. SOLAR THERMAL
!                       ! 8.. PV
                        ! 9.. PT
!                       ! 10.. Wind
!                       ! 11.. Low speed wind
!                       ! 12.. Offshore wind
!
! ------------------------------------------------------------------
      IF (UESTYR .EQ. 0) UESTYR=2009
      IF (CURCALYR .LT. UESTYR) RETURN

! ...... open RFM output files
      IF (CURCALYR.EQ.UESTYR.AND.CURITR.EQ.1) THEN
        RENEWFILE='WINDDBG'
        IORNREPT=FILE_MGR('O',RENEWFILE,.TRUE.)  !open Renewables report file
        RENEWFILE='WDUMP'
        IORNDUMP=FILE_MGR('O',RENEWFILE,.TRUE.) !open general RFM dump file
! ....... write the scenario and datekey as a header for the WDUMP file
        WRITE (IORNDUMP,'(" SCENARIO and DATEKEY: ",A)') trim(SCEN_DATE)

   IF (EXE .EQ. 1) THEN
! ....... Get floors for technologies
          CALL GETFLOORS(No_rec)
!         CALL PUTFLOORS(No_rec)
          IF (DPVDISPATCH .EQ. .TRUE. ) THEN
  !save distributed Solar PV capacity and geneartion values from the first cycle into DPV common block arrays
  ! for later cycle adjustments (backing them out for reporting) - calculate the values using the variables filled by resid/comm models 
              DPVTOTCAPNR = 0.0; DPVTOTGENNR = 0.0
              DO IYR =  1,MNUMYR
                      DO IRG = 1 , MNUMNR
                          DO ICNS = 1, MNUMCR - 2
                            DPVTOTCAPNR(IRG,IYR) = DPVTOTCAPNR(IRG,IYR) + MPCGCtoN(IRG,ICNS,10) * CGCOMMCAP(ICNS,IYR,8) +  MPCGCtoN(IRG,ICNS,10) * CGRESCAP(ICNS,IYR,8)
                            DPVTOTGENNR(IRG,IYR) = DPVTOTGENNR(IRG,IYR) + MPCGCtoN(IRG,ICNS,10) * (CGCOMMGEN(ICNS,IYR,8,1) + CGCOMMGEN(ICNS,IYR,8,2)) + &
                                MPCGCtoN(IRG,ICNS,10) * (CGRESGEN(ICNS,IYR,8,1) + CGRESGEN(ICNS,IYR,8,2)) 
                          ENDDO 

                          WRITE(22,7313) CURIRUN, CURCALYR, CURITR, IYR+1989, IRG, DPVTOTCAPNR(IRG,IYR),CGTOTCAPNR(IRG,IYR,10),DPVTOTGENNR(IRG,IYR),CGTOTGENNR(IRG,IYR,10,1),CGTOTGENNR(IRG,IYR,10,2)
 7313                     FORMAT(1X,"RENEW_PVTOTCAPNR_1",5(",",I5),5(",",F21.6))

                      ENDDO
                      DO ICENSUS = 1,MNUMCR
                          DPVCOMMGEN(ICENSUS,IYR) = CGCOMMGEN(ICENSUS,IYR,8,1) + CGCOMMGEN(ICENSUS,IYR,8,2)
                          DPVRESGEN(ICENSUS,IYR) = CGRESGEN(ICENSUS,IYR,8,1) + CGRESGEN(ICENSUS,IYR,8,2)
                      ENDDO
              ENDDO
              CALL GETSOLARDG(No_rec)
          ENDIF

! ...... Call the ELASTICITIES AND WBTECH assignments
          CALL GETCNTL
   ENDIF
      ENDIF
      CALL BIOMAS

      IF (EXE .EQ. 1) THEN
         IF (CURITR .EQ. 1) CALL GEO2000

!DSB***************************************************************
         IF (CURITR .EQ. 1) CALL Wind3
         CALL SOLAR
         IF (CURITR .EQ. 1) CALL SolarMisc
         IF (CURITR .EQ. 1) CALL SolarRept
         IF (CURITR .EQ. 1) CALL HYDRO


!   ..... Establish Elasticities
         IF (CURITR .EQ. 1) call WELAST
      ENDIF

      IF (EXE .EQ. 1 .AND. CURITR .EQ. 1) THEN
        CALL GETLFGCAPADDS(No_rec)    
        CALL PUTFLOORS(No_rec)
      ENDIF

      IY = CURIYR

      DO I = 1 , MNUMNR -1
        WCAHYEL(MNUMNR,IY) = WCAHYEL(MNUMNR,IY) + WCAHYEL(I,IY)
        WCAGPEL(MNUMNR,IY) = WCAGPEL(MNUMNR,IY) + WCAGPEL(I,IY)
        WNRGIEL(MNUMNR,IY) = WNRGIEL(MNUMNR,IY) + WNRGIEL(I,IY)
        WCAMSEL(MNUMNR,IY) = WCAMSEL(MNUMNR,IY) + WCAMSEL(I,IY)
        WCABMEL(MNUMNR,IY) = WCABMEL(MNUMNR,IY) + WCABMEL(I,IY)
        WCASTEL(MNUMNR,IY) = WCASTEL(MNUMNR,IY) + WCASTEL(I,IY)
        WCAPVEL(MNUMNR,IY) = WCAPVEL(MNUMNR,IY) + WCAPVEL(I,IY)
        WCAWIEL(MNUMNR,IY) = WCAWIEL(MNUMNR,IY) + WCAWIEL(I,IY)
      ENDDO

      IF ( WCAHYEL(MNUMNR,IY) .GT. 0.0 ) THEN
      WCAHYEL(MNUMNR,IY) = 0.
      WVCHYEL(MNUMNR,IY) = 0.
      WHRHYEL(MNUMNR,IY) = 0.
      ENDIF

      IF ( WCAGPEL(MNUMNR,IY) .GT. 0.0 ) THEN
      WCAGPEL(MNUMNR,IY) = 0.
      WVCGPEL(MNUMNR,IY) = 0.
      WHRGPEL(MNUMNR,IY) = 0.
      ENDIF

      IF ( WNRGIEL(MNUMNR,IY) .GT. 0.0 ) THEN
      WNRGIEL(MNUMNR,IY) = 0.
      WCFGIEL(MNUMNR,IY) = 0.
      WOCGIEL(MNUMNR,IY) = 0.
      WVCGIEL(MNUMNR,IY) = 0.
      ENDIF

      IF ( WCAMSEL(MNUMNR,IY) .GT. 0.0 ) THEN
      WCAMSEL(MNUMNR,IY) = 0.
      WCFMSEL(MNUMNR,IY) = 0.
      WVCMSEL(MNUMNR,IY) = 0.
      WHRMSEL(MNUMNR,IY) = 0.
      ENDIF

      IF ( WCABMEL(MNUMNR,IY) .GT. 0.0 ) THEN
      WCABMEL(MNUMNR,IY) = 0.
      WCFBMEL(MNUMNR,IY) = 0.
      WHRBMEL(MNUMNR,IY) = 0.
      ENDIF

      IF ( WCASTEL(MNUMNR,IY) .GT. 0.0 ) THEN
      WCASTEL(MNUMNR,IY) = 0.
      WVCSTEL(MNUMNR,IY) = 0.
      WHRSTEL(MNUMNR,IY) = 0.
      ENDIF

      IF ( WCAPVEL(MNUMNR,IY) .GT. 0.0 ) THEN
      WCAPVEL(MNUMNR,IY) = 0.
      WCAPTEL(MNUMNR,IY) = 0.
      WVCPVEL(MNUMNR,IY) = 0.
      WVCPTEL(MNUMNR,IY) = 0.
      WHRPVEL(MNUMNR,IY) = 0.
      WHRPTEL(MNUMNR,IY) = 0.
      ENDIF

      IF ( WCAWIEL(MNUMNR,IY) .GT. 0.0 ) THEN
      WCAWIEL(MNUMNR,IY) = 0.
      WCAWLEL(MNUMNR,IY) = 0.
      WVCWIEL(MNUMNR,IY) = 0.
      WVCWLEL(MNUMNR,IY) = 0.
      WHRWIEL(MNUMNR,IY) = 0.
      WHRWLEL(MNUMNR,IY) = 0.
      ENDIF

      DO I = 1 , MNUMNR - 1
         WCAHYEL(MNUMNR,IY) = WCAHYEL(MNUMNR,IY) + WCAHYEL(I,IY)
         WVCHYEL(MNUMNR,IY)=WVCHYEL(MNUMNR,IY)+WVCHYEL(I,IY)*WCAHYEL(I,IY)
         WHRHYEL(MNUMNR,IY)=WHRHYEL(MNUMNR,IY)+WHRHYEL(I,IY)*WCAHYEL(I,IY)

         WCAGPEL(MNUMNR,IY) = WCAGPEL(MNUMNR,IY) + WCAGPEL(I,IY)
         WCFGPEL(MNUMNR,IY)=WCFGPEL(MNUMNR,IY)+WCFGPEL(I,IY)*WCAGPEL(I,IY)
         WCCGPEL(MNUMNR,IY)=WCCGPEL(MNUMNR,IY)+WCCGPEL(I,IY)*WCAGPEL(I,IY)
         WOCGPEL(MNUMNR,IY)=WOCGPEL(MNUMNR,IY)+WOCGPEL(I,IY)*WCAGPEL(I,IY)
         WVCGPEL(MNUMNR,IY)=WVCGPEL(MNUMNR,IY)+WVCGPEL(I,IY)*WCAGPEL(I,IY)
         WHRGPEL(MNUMNR,IY)=WHRGPEL(MNUMNR,IY)+WHRGPEL(I,IY)*WCAGPEL(I,IY)

         WNRGIEL(MNUMNR,IY)=WNRGIEL(MNUMNR,IY)+WNRGIEL(I,IY)
         WCFGIEL(MNUMNR,IY)=WCFGIEL(MNUMNR,IY)+WCFGIEL(I,IY)*WNRGIEL(I,IY)
         WOCGIEL(MNUMNR,IY)=WOCGIEL(MNUMNR,IY)+WOCGIEL(I,IY)*WNRGIEL(I,IY)
         WVCGIEL(MNUMNR,IY)=WVCGIEL(MNUMNR,IY)+WVCGIEL(I,IY)*WNRGIEL(I,IY)

         WCAMSEL(MNUMNR,IY) = WCAMSEL(MNUMNR,IY) + WCAMSEL(I,IY)
         WCFMSEL(MNUMNR,IY)=WCFMSEL(MNUMNR,IY)+WCFMSEL(I,IY)*WCAMSEL(I,IY)
         WVCMSEL(MNUMNR,IY)=WVCMSEL(MNUMNR,IY)+WVCMSEL(I,IY)*WCAMSEL(I,IY)
         WHRMSEL(MNUMNR,IY)=WHRMSEL(MNUMNR,IY)+WHRMSEL(I,IY)*WCAMSEL(I,IY)
!           WRITE(6,*) 'WHRMSEL ',MNUMNR,I,IY,WHRMSEL(I,IY),WCAMSEL(I,IY),WCFMSEL(I,IY)

         WCABMEL(MNUMNR,IY) = WCABMEL(MNUMNR,IY) + WCABMEL(I,IY)
         WCFBMEL(MNUMNR,IY)=WCFBMEL(MNUMNR,IY)+WCFBMEL(I,IY)*WCABMEL(I,IY)
         WHRBMEL(MNUMNR,IY)=WHRBMEL(MNUMNR,IY)+WHRBMEL(I,IY)*WCABMEL(I,IY)

         WCASTEL(MNUMNR,IY) = WCASTEL(MNUMNR,IY) + WCASTEL(I,IY)
         WVCSTEL(MNUMNR,IY)=WVCSTEL(MNUMNR,IY)+WVCSTEL(I,IY)*WCASTEL(I,IY)
         WHRSTEL(MNUMNR,IY)=WHRSTEL(MNUMNR,IY)+WHRSTEL(I,IY)*WCASTEL(I,IY)

         WCAPVEL(MNUMNR,IY) = WCAPVEL(MNUMNR,IY) + WCAPVEL(I,IY)
         WVCPVEL(MNUMNR,IY)=WVCPVEL(MNUMNR,IY)+WVCPVEL(I,IY)*WCAPVEL(I,IY)
         WHRPVEL(MNUMNR,IY)=WHRPVEL(MNUMNR,IY)+WHRPVEL(I,IY)*WCAPVEL(I,IY)

         WCAWIEL(MNUMNR,IY) = WCAWIEL(MNUMNR,IY) + WCAWIEL(I,IY)
         WVCWIEL(MNUMNR,IY)=WVCWIEL(MNUMNR,IY)+WVCWIEL(I,IY)*WCAWIEL(I,IY)
         WHRWIEL(MNUMNR,IY)=WHRWIEL(MNUMNR,IY)+WHRWIEL(I,IY)*WCAWIEL(I,IY)

         WCAPTEL(MNUMNR,IY)=WCAPTEL(MNUMNR,IY)+WCAPTEL(I,IY)
         WVCPTEL(MNUMNR,IY)=WVCPTEL(MNUMNR,IY)+WVCPTEL(I,IY)*WCAPTEL(I,IY)
         WHRPTEL(MNUMNR,IY)=WHRPTEL(MNUMNR,IY)+WHRPTEL(I,IY)*WCAPTEL(I,IY)

         WCAWLEL(MNUMNR,IY)=WCAWLEL(MNUMNR,IY)+WCAWLEL(I,IY)
         WVCWLEL(MNUMNR,IY)=WVCWLEL(MNUMNR,IY)+WVCWLEL(I,IY)*WCAWLEL(I,IY)
         WHRWLEL(MNUMNR,IY)=WHRWLEL(MNUMNR,IY)+WHRWLEL(I,IY)*WCAWLEL(I,IY)
      ENDDO

      IF (WCAHYEL(MNUMNR,IY) .GT. 0.) THEN
         WVCHYEL(MNUMNR,IY) = WVCHYEL(MNUMNR,IY) / WCAHYEL(MNUMNR,IY)
         WHRHYEL(MNUMNR,IY) = WHRHYEL(MNUMNR,IY) / WCAHYEL(MNUMNR,IY)
      ENDIF
      IF (WCAGPEL(MNUMNR,IY) .GT. 0.) THEN
         WCFGPEL(MNUMNR,IY) = WCFGPEL(MNUMNR,IY) / WCAGPEL(MNUMNR,IY)
         WCCGPEL(MNUMNR,IY) = WCCGPEL(MNUMNR,IY) / WCAGPEL(MNUMNR,IY)
         WOCGPEL(MNUMNR,IY) = WOCGPEL(MNUMNR,IY) / WCAGPEL(MNUMNR,IY)
         WVCGPEL(MNUMNR,IY) = WVCGPEL(MNUMNR,IY) / WCAGPEL(MNUMNR,IY)
         WHRGPEL(MNUMNR,IY) = WHRGPEL(MNUMNR,IY) / WCAGPEL(MNUMNR,IY)
      ENDIF
      IF (WNRGIEL(MNUMNR,IY) .GT. 0.) THEN
         WCFGIEL(MNUMNR,IY) = WCFGIEL(MNUMNR,IY) / WNRGIEL(MNUMNR,IY)
         WOCGIEL(MNUMNR,IY) = WOCGIEL(MNUMNR,IY) / WNRGIEL(MNUMNR,IY)
         WVCGIEL(MNUMNR,IY) = WVCGIEL(MNUMNR,IY) / WNRGIEL(MNUMNR,IY)
      ENDIF
      IF (WCAMSEL(MNUMNR,IY) .GT. 0.) THEN
         WCFMSEL(MNUMNR,IY) = WCFMSEL(MNUMNR,IY) / WCAMSEL(MNUMNR,IY)
         WVCMSEL(MNUMNR,IY) = WVCMSEL(MNUMNR,IY) / WCAMSEL(MNUMNR,IY)
         WHRMSEL(MNUMNR,IY) = WHRMSEL(MNUMNR,IY) / WCAMSEL(MNUMNR,IY)
      ENDIF
      IF (WCABMEL(MNUMNR,IY) .GT. 0.) THEN
         WCFBMEL(MNUMNR,IY) = WCFBMEL(MNUMNR,IY) / WCABMEL(MNUMNR,IY)
         WHRBMEL(MNUMNR,IY) = WHRBMEL(MNUMNR,IY) / WCABMEL(MNUMNR,IY)
      ENDIF
      IF (WCASTEL(MNUMNR,IY) .GT. 0.) THEN
         WVCSTEL(MNUMNR,IY) = WVCSTEL(MNUMNR,IY) / WCASTEL(MNUMNR,IY)
         WHRSTEL(MNUMNR,IY) = WHRSTEL(MNUMNR,IY) / WCASTEL(MNUMNR,IY)
      ENDIF
      IF (WCAPVEL(MNUMNR,IY) .GT. 0.) THEN
         WVCPVEL(MNUMNR,IY) = WVCPVEL(MNUMNR,IY) / WCAPVEL(MNUMNR,IY)
         WHRPVEL(MNUMNR,IY) = WHRPVEL(MNUMNR,IY) / WCAPVEL(MNUMNR,IY)
      ENDIF
      IF (WCAPTEL(MNUMNR,IY) .GT. 0.) THEN
         WVCPTEL(MNUMNR,IY) = WVCPTEL(MNUMNR,IY) / WCAPTEL(MNUMNR,IY)
         WHRPTEL(MNUMNR,IY) = WHRPTEL(MNUMNR,IY) / WCAPTEL(MNUMNR,IY)
      ENDIF
      IF (WCAWIEL(MNUMNR,IY) .GT. 0.) THEN
         WVCWIEL(MNUMNR,IY) = WVCWIEL(MNUMNR,IY) / WCAWIEL(MNUMNR,IY)
         WHRWIEL(MNUMNR,IY) = WHRWIEL(MNUMNR,IY) / WCAWIEL(MNUMNR,IY)
      ENDIF
      IF (WCAWLEL(MNUMNR,IY) .GT. 0.) THEN
         WVCWLEL(MNUMNR,IY) = WVCWLEL(MNUMNR,IY) / WCAWLEL(MNUMNR,IY)
         WHRWLEL(MNUMNR,IY) = WHRWLEL(MNUMNR,IY) / WCAWLEL(MNUMNR,IY)
      ENDIF

! ..... get heat rates from EMM and assign to WHRxxel
   IF (EXE .EQ. 1) THEN
      CALL GETEMMVAL
   ENDIF
      RETURN
      END


! *********************************************************************
! Subroutine GETEMMVAL
! Reassigns the heat rates from EMM data structurs to WHRxxEL variables
!
! Numbering:   ECP technology #          Technology
!              -----------------         ----------
!                   WISO                  Solar Thermal
!                   WIWN                  Wind
!                   WIPV                  PV
!                   WIPT                  PV Tilt
!                   WIHY                  Hydro
!                   WIGT                  Geothermal
!                   WIWD                  Biomass
!                   WIMS                  MSW
!
!
! Written by: Michael Kintner-Meyer
! dated:      4/17/96
! ---------------------------------------------------------------------
      Subroutine GETEMMVAL
      implicit NONE
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'ecpcntl'
      include 'control'
      include 'wrenew'
      include 'bildin'
      include 'dispinyr'

      integer nr

      IF (((CURIYR + UHBSYR) .LE. UYR_OVER)     &
             .AND. ((CURIYR + UHBSYR) .GE. HSTYEAR)) THEN
         IF (USW_OVER .GT. 0) THEN
      do nr=1,MNUMNR
           WHRBMEL(nr,CURIYR) = HWODHR(CURIYR)
           WHRMSEL(nr,CURIYR) = HMSWHR(CURIYR)
!           WRITE(6,*) 'HMSWHR ',MNUMNR,nr,curiyr,curitr,WHRMSEL(nr,CURIYR), HMSWHR(CURIYR)
           WCFMSEL(nr,CURIYR) = UPMCF(WIMS)
 !          WRITE(6,*) 'UPMCF GETEMVAL ',MNUMNR,nr,curiyr,curitr, WCFMSEL(nr,CURIYR), UPMCF(WIMS)
!    AEO2025 update to use 3412 for renewable consumption reporting 
           WHRGPEL(nr,CURIYR) = 3412.00
           WHRHYEL(nr,CURIYR) = 3412.00
           WHRWIEL(nr,CURIYR) = 3412.00
           WHRWLEL(nr,CURIYR) = 3412.00
           WHRSTEL(nr,CURIYR) = 3412.00
           WHRPVEL(nr,CURIYR) = 3412.00
           WHRPTEL(nr,CURIYR) = 3412.00
      enddo
        ENDIF
      ELSE
          do nr=1,MNUMNR
           WHRBMEL(nr,CURIYR) = UPHTRT(WIWD)
           WHRMSEL(nr,CURIYR) = UPHTRT(WIMS)
         WCFMSEL(nr,CURIYR)=UPMCF(WIMS)
           WHRGPEL(nr,CURIYR) = EPHTRT_AER(WIGT)
           WHRHYEL(nr,CURIYR) = EPHTRT_AER(WIHY)
           WHRWIEL(nr,CURIYR) = EPHTRT_AER(WIWN)
           WHRWLEL(nr,CURIYR) = EPHTRT_AER(WIWL)
           WHRSTEL(nr,CURIYR) = EPHTRT_AER(WISO)
           WHRPVEL(nr,CURIYR) = EPHTRT_AER(WIPV)
           WHRPTEL(nr,CURIYR) = EPHTRT_AER(WIPT)
          enddo
      ENDIF

   write(6,*) ' ephtrt renew ',ephtrt_aer(wigt),ephtrt_aer(wihy)

      return
      end



      SUBROUTINE BIOMAS

      IMPLICIT NONE

      include 'parametr'
      include 'ncntrl'

      IF (EXE .EQ. 1) CALL WASTE

      CALL WOOD1

      RETURN
      END


!******************************************************************
!     Subroutine Wind3 is the Wind submodule

      subroutine Wind3

      implicit none
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'control'
      include 'wrenio'

      write(*,*)'WINDDBG - starting Wind3 ',scen_date

!     Open a wind debug file in first year and iteration.  Write a header to the debug file.
!     write(*,*)"in WIND3*****,curiyr,firsyr,curitr ",curiyr,firsyr,curitr

      write(IORNREPT,'(/,a,a,a,i4)') 'Wind Report for Scenario: ',trim(scen_date),', in Year ',curcalyr

!     **1. Read the three input files and interpolate the data as necessary.

      if (curcalyr.eq.uestyr.and.(curitr.eq.1.or.loopop.eq.2)) then
         call WindIn3
      end if

!     **2. Calculate cumulative builds and (remaining) land area. Determine the "best" wind class and
!     buffer zone. Calculate available capacity, calculate capacity factors by
!     time slice, determine the T&D costs. Calculate the maximum capacity available and the amount of
!     capacity currently used.

      if (curcalyr.ge.uestyr)  then
         call WindMisc3
         call WindMisc3_OFS
      endif

!     **3. Call the debug report.

      if (curcalyr.ge.uestyr) then
         call WindRept3
         call WindRept3_OFS
      endif

      return
      end

!******************************************************************
!     Subroutine WindIn3 reads  WesArea.txt.


      subroutine WindIn3

      implicit none
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'ecpcntl'
      include 'control'
      include 'dsmdimen'
      include 'dsmcaldr'
      include 'wrenew'
      include 'wwind'
      include 'wrenio'
      include 'bildin'
      include 'uefdout'

      integer file_mgr
      integer n,y,c,l,InUnit,i,j,nr,wc,yr,bf,ny,ECPWind,t,IJ,IX,IY,m,d,h
      INTEGER RD$TBL,RD$R1,RD$R2,RD$I1 , RD$I2   ! Table read functions.
      INTEGER RET_CD             ! Return code from table reads
      INTEGER tempyr,temphrs(1,24),tmpMonth(12),HrCols,numYrBlks,yblk
      INTEGER CFYRS(MNUMYR),k
      REAL TEMPDATCF(12,24)      ! Storage for capacity factor table data
      REAL CF24(24)
      real CInc,EInc,XTot,SwArea,PI
      parameter(PI=3.141593)
      CHARACTER*12 TABNAME       ! Storage for name of table to read
      character*18 name
      character*200 TextLine
      character*50 XDummy
      logical New/.false./



      Name='WESAREA'
      InUnit=File_Mgr('O',Name,NEW)

!     Read the amount of available land area for wind farm development.  This is by wind
!     classes 4,5,6, and by regions 1 to 16, and by buffer zones 1, 2, and 3.  The units
!     for area are square kilometers.  Everything starts off in year 1.

      yr=1

      read(InUnit,'(a)') TextLine
      do bf=1,mnumbf
         read(InUnit,'(/)')
         do nr=1,IJUMPEMRGN
            read(InUnit,*) (LdArea(nr,yr,wc,bf),wc=1,mnumcl)
         end do
         read(InUnit,*) (LdArea(mnumnr-2,yr,wc,bf),wc=1,mnumcl)
         read(InUnit,*) (LdArea(mnumnr-1,yr,wc,bf),wc=1,mnumcl)
         read(InUnit,*) (LdArea(mnumnr,yr,wc,bf),wc=1,mnumcl)
      end do

!     Read wind quality data - fraction of annual hours in each of 9 EMM slices.

      read(InUnit,'(//)')
      do nr=1,IJUMPEMRGN
         read(InUnit,*) (Slice(nr,j),j=1,mnumwi)
      end do
      read(InUnit,*) (Slice(mnumnr-2,j),j=1,mnumwi)
      read(InUnit,*) (Slice(mnumnr-1,j),j=1,mnumwi)

!     Read wind quality data - fraction of annual capacity in each of 9 EMM slices.

      read(InUnit,'(//)')
      do nr=1,IJUMPEMRGN
        read(InUnit,*) (SubPer(nr,j),j=1,mnumwi)
      end do
      read(InUnit,*) (SubPer(mnumnr-2,j),j=1,mnumwi)
      read(InUnit,*) (SubPer(mnumnr-1,j),j=1,mnumwi)

!     read in new capacity factors

      DO IJ=1,3
         IF (IJ.EQ.1) THEN
            IX = 1
            IY = IJUMPEMRGN
         ELSEIF (IJ .EQ. 2) THEN
            IF (IJUMPEMRGN.EQ.13) THEN
               IX=14
               IY=14
            ELSEIF (IJUMPEMRGN.EQ.22) THEN
               IX=23
               IY=23
            ELSEIF (IJUMPEMRGN.EQ.25) THEN
               IX=26
               IY=26
            ENDIF
         ELSEIF (IJ .EQ. 3) THEN
            IF (IJUMPEMRGN.EQ.13) THEN
               IX=15
               IY=15
            ELSEIF (IJUMPEMRGN.EQ.22) THEN
               IX=24
               IY=24
            ELSEIF (IJUMPEMRGN.EQ.25) THEN
               IX=27
               IY=27
            ENDIF
         ENDIF
         do nr=IX,IY                ! read for each region
            WRITE (TABNAME,'(A3,I1,I1,A7)') '%WI',NR/10,MOD(NR,10),'YEARS %'
            RET_CD = RD$TBL(InUnit,TABNAME,1,1,6)
            RET_CD = RD$I1(numYrBlks,1,1)         ! number of year blocks for this region's ST

            do yblk=1,numYrBlks
               WRITE (TABNAME,'(A3,I1,I1,A7)') '%WI',NR/10,MOD(NR,10),'PARAMS%'
               RET_CD = RD$TBL(InUnit,TABNAME ,1,1,6)
               RET_CD = RD$I1(tempyr,1,1)           ! year for data block
               RET_CD = RD$I1(HrCols,1,1)           ! number of hour columns
               CFYRS(yblk) = tempyr - 1989

!              read(iunit1,*)(temphrs(1,i),i=1,HrCols)

               WRITE (TABNAME,'(A3,I1,I1,A7)') '%WI',NR/10,MOD(NR,10),'HRS   %'
               RET_CD = RD$TBL (InUnit,TABNAME, 1,1,6)  ! Identify input table
               RET_CD = RD$I2(temphrs,1,1,HrCols,1,HrCols)           ! hours for data

               WRITE (TABNAME,'(A3,I1,I1)') '%WI',NR/10,MOD(NR,10)
               RET_CD = RD$TBL (InUnit, TABNAME, 12,1,6)  ! Identify input table
               RET_CD = RD$I1(tmpMonth,1,12)           ! month of data
               RET_CD = RD$R2 (TEMPDATCF,1,1,HrCols,12,HrCols)   ! Read the capacity factor table

!              if last hour column is not for hour 24, add a column for hr 24

               if (HrCols .lt. 24 .and. temphrs(1,HrCols) .ne. 24) then
                  HrCols = HrCols + 1
                  temphrs(1,HrCols) = 24
                  do j=1,12             !for each month
                     TEMPDATCF(j,HrCols) = TEMPDATCF(j,HrCols-1)
                  enddo
               endif

               do j=1,12         ! for each month

!                 fill in all 24 hours of data

                  do i=1,HrCols
                     CF24(temphrs(1,i)) = TEMPDATCF(j,i)
                     if (i .LT. HrCols) then
                        if (temphrs(1,i) .ge. temphrs(1,i+1)) then
                           write(*,*)'Error in WESAREA File - WI new cap factors, Rgn ',nr
                           stop
                        endif
                        if (temphrs(1,i) .lt. (temphrs(1,i+1)-1)) then
                           do k= temphrs(1,i)+1, temphrs(1,i+1)-1
                              CF24(k) = TEMPDATCF(j,i)
                           enddo
                        endif
                     endif
                  enddo    !HrCols

!                 write(*,'(a,24F9.4)')"RNW-WI-CF2: CF24:", (CF24(i),i=1,24)

!                 fill in for all 3 daytypes

                  ny=CFYRS(yblk)
                  do d=1,3
                     do k=1,24
                        WSFWIEL_CF(nr,ny,d,j,k) = CF24(k)
                     enddo

!                    write(*,'(a,4i5,24F9.4)')"RNW-WI-CF2: WSFWIEL,r,y,d,m:", &
!                       nr,tempyr,d,j,(WSFWIEL_CF(1,ny,d,j,i),i=1,24)

                  enddo    ! daytypes
               enddo               !  months
            enddo            !yr block

!           after all the year blocks have been read in  for WI in a region
!           back fill data from 1st year block to 1990, then, 'forward' fill in all other years

            if (CFYRS(1) .gt. 1) then
               do ny = CFYRS(1)-1, 1,  -1
                  do d=1,3
                     do j=1,12
                        do k=1,24
                           WSFWIEL_CF(nr,ny,d,j,k) =  WSFWIEL_CF(nr,CFYRS(1),d,j,k)
                        enddo
                     enddo
                  enddo
               enddo
            endif

            if (NumYrBlks .gt. 1) then
               do yblk = 1, NumYrBlks - 1
                  do ny = CFYRS(yblk), CFYRS(yblk+1) - 2
                     do d=1,3
                        do j=1,12
                           do k=1,24
                              WSFWIEL_CF(nr,ny+1,d,j,k) =  WSFWIEL_CF(nr,ny,d,j,k)
                           enddo
                        enddo
                     enddo
                  enddo
               enddo
            endif

!           if last year block was not MNUMYR, forward fill out to MNUMYR

            if (CFYRS(NumYrBlks) .ne. MNUMYR) then
               do ny = CFYRS(NumYrBlks)+1, MNUMYR
                  do d=1,3
                     do j=1,12
                        do k=1,24
                           WSFWIEL_CF(nr,ny,d,j,k) =  WSFWIEL_CF(nr,CFYRS(numYrBlks),d,j,k)
                        enddo
                     enddo
                  enddo
               enddo
            endif

!           debug

            do ny = 1, MNUMYR
               do d=1,1
                  do j=1,12

!                    write(*,'(a,4i5,24F9.4)')"RNW-WI-CF3: WSFWIEL,r,y,d,m:", &
!                       nr,ny+1989,d,j,(WSFWIEL_CF(nr,ny,d,j,i),i=1,24)

                  enddo
               enddo
            enddo

!           ny = 27
!           DO m = 1, 12
!              DO d = 1, 3
!                 WRITE(6,1518) CURIRUN, CURIYR+1989, ny+1989, nr, m, d, (WSFWIEL_CF(nr,ny,d,m,h),h=1,24)
!1518             FORMAT(1X,"CF_WN",6(":",I4),24(":",F6.3))
!              END DO
!           END DO

         enddo    ! nr region
      ENDDO !IJ

!     Now, compute Average Annual Wind Cap Factor based on Input data

      WindInputCF = 0.0
      do ny=1, mnumyr
         do nr=1,unrgns
            do m=1,12
               do d=1,3
                  do h=1,24
                     WindInputCF(nr,ny) = WindInputCF(nr,ny) + (WSFWIEL_CF(nr,ny,d,m,h) * IDAYTQ(d,m)) / 8760.0
                  enddo     !hr
               enddo        !daytype
            enddo           !month
         enddo             !region
      enddo              !year

!     debug
!     do ny = 1, MNUMYR
!        do nr=1,unrgns
!           write(*,'(a,2i5,24F9.4)')"RNW-WI-CF4: WindInputCF,y,r:", &
!              ny+1989,nr,WindInputCF(nr,ny)
!        enddo
!     enddo

!     Read capacity factors for wind classes 6,5,4 for 1990 to 2035 by 5 years.

      read(InUnit,'(//)')
      n=0
      do y=1990,ENDYR+5,5
         n=n+1
         read(InUnit,*) yr,(CFAnn(n,wc),wc=1,mnumcl)
      end do

!     Read rotor energy density for wind classes 6,5,4 for 1990 to 2030 by 5 years.
!     read(InUnit,'(//)')
!     do y=1,9
!        read(InUnit,*) yr,(EnArea(y,wc),wc=1,mnumcl)
!     end do

!     Interpolate the values for capacity factors

      do wc=1,mnumcl
         do i=1,n-1
            CInc=(CFAnn(i+1,wc)-CFAnn(i,wc))/5.0
            do ny=1,6
               y=(i-1)*5+ny
               CF(y,wc)=CFAnn(i,wc)+(ny-1)*CInc
            end do
         end do
      end do

!     Low Wind Speed Technology

      DO IJ=1,3
         IF (IJ.EQ.1) THEN
            IX = 1
            IY = IJUMPEMRGN
         ELSEIF (IJ .EQ. 2) THEN
            IF (IJUMPEMRGN.EQ.13) THEN
               IX=14
               IY=14
            ELSEIF (IJUMPEMRGN.EQ.22) THEN
               IX=23
               IY=23
            ELSEIF (IJUMPEMRGN.EQ.25) THEN
               IX=26
               IY=26
            ENDIF
         ELSEIF (IJ .EQ. 3) THEN
            IF (IJUMPEMRGN.EQ.13) THEN
               IX=15
               IY=15
            ELSEIF (IJUMPEMRGN.EQ.22) THEN
               IX=24
               IY=24
            ELSEIF (IJUMPEMRGN.EQ.25) THEN
               IX=27
               IY=27
            ENDIF
         ENDIF

         do nr=IX,IY                ! read for each region
            WRITE (TABNAME,'(A3,I1,I1,A7)') '%WL',NR/10,MOD(NR,10),'YEARS %'
            RET_CD = RD$TBL(InUnit,TABNAME,1,1,6)
            RET_CD = RD$I1(numYrBlks,1,1)         ! number of year blocks for this region's ST
            do yblk=1,numYrBlks
               WRITE (TABNAME,'(A3,I1,I1,A7)') '%WL',NR/10,MOD(NR,10),'PARAMS%'
               RET_CD = RD$TBL(InUnit,TABNAME ,1,1,6)
               RET_CD = RD$I1(tempyr,1,1)           ! year for data block
               RET_CD = RD$I1(HrCols,1,1)           ! number of hour columns
               CFYRS(yblk) = tempyr - 1989

!              read(iunit1,*)(temphrs(1,i),i=1,HrCols)

               WRITE (TABNAME,'(A3,I1,I1,A7)') '%WL',NR/10,MOD(NR,10),'HRS   %'
               RET_CD = RD$TBL (InUnit,TABNAME, 1,1,6)  ! Identify input table
               RET_CD = RD$I2(temphrs,1,1,HrCols,1,HrCols)           ! hours for data

               WRITE (TABNAME,'(A3,I1,I1)') '%WL',NR/10,MOD(NR,10)
               RET_CD = RD$TBL (InUnit, TABNAME, 12,1,6)  ! Identify input table
               RET_CD = RD$I1(tmpMonth,1,12)           ! month of data
               RET_CD = RD$R2 (TEMPDATCF,1,1,HrCols,12,HrCols)   ! Read the capacity factor table

!              if last hour column is not for hour 24, add a column for hr 24

               if (HrCols .lt. 24 .and. temphrs(1,HrCols) .ne. 24) then
                  HrCols = HrCols + 1
                  temphrs(1,HrCols) = 24
                  do j=1,12             !for each month
                     TEMPDATCF(j,HrCols) = TEMPDATCF(j,HrCols-1)
                  enddo
               endif

               do j=1,12         ! for each month

!                 fill in all 24 hours of data

                  do i=1,HrCols
                     CF24(temphrs(1,i)) = TEMPDATCF(j,i)
                     if (i .LT. HrCols) then
                        if (temphrs(1,i) .ge. temphrs(1,i+1)) then
                           write(*,*)'Error in WESAREA File - WON new cap factors, Rgn ',nr
                           stop
                        endif
                        if (temphrs(1,i) .lt. (temphrs(1,i+1)-1)) then
                           do k= temphrs(1,i)+1, temphrs(1,i+1)-1
                              CF24(k) = TEMPDATCF(j,i)
                           enddo
                        endif
                     endif
                  enddo    !HrCols

!                 write(*,'(a,24F9.4)')"RNW-WL-CF2: CF24:", (CF24(i),i=1,24)

!                 fill in for all 3 daytypes

                  ny=CFYRS(yblk)
                  do d=1,3
                     do k=1,24
                        WSFWLEL_CF(nr,ny,d,j,k) = CF24(k)
                     enddo

!                    write(*,'(a,4i5,24F9.4)')"RNW-L-CF2: WSFWLEL,r,y,d,m:", &
!                       nr,tempyr,d,j,(WSFWLEL_CF(1,ny,d,j,i),i=1,24)

                  enddo    ! daytypes
               enddo               !  months
            enddo            !yr block

!           after all the year blocks have been read in  for WL onshore in a region
!           back fill data from 1st year block to 1990, then, 'forward' fill in all other years

            if (CFYRS(1) .gt. 1) then
               do ny = CFYRS(1)-1, 1,  -1
                  do d=1,3
                     do j=1,12
                        do k=1,24
                           WSFWLEL_CF(nr,ny,d,j,k) =  WSFWLEL_CF(nr,CFYRS(1),d,j,k)
                        enddo
                     enddo
                  enddo
               enddo
            endif

            if (NumYrBlks .gt. 1) then
               do yblk = 1, NumYrBlks - 1
                  do ny = CFYRS(yblk), CFYRS(yblk+1) - 2
                     do d=1,3
                        do j=1,12
                           do k=1,24
                              WSFWLEL_CF(nr,ny+1,d,j,k) =  WSFWLEL_CF(nr,ny,d,j,k)
                           enddo
                        enddo
                     enddo
                  enddo
               enddo
            endif

!           if last year block was not MNUMYR, forward fill out to MNUMYR

            if (CFYRS(NumYrBlks) .ne. MNUMYR) then
               do ny = CFYRS(NumYrBlks)+1, MNUMYR
                  do d=1,3
                     do j=1,12
                        do k=1,24
                           WSFWLEL_CF(nr,ny,d,j,k) =  WSFWLEL_CF(nr,CFYRS(numYrBlks),d,j,k)
                        enddo
                     enddo
                  enddo
               enddo
            endif

!           ny = 27
!           DO m = 1, 12
!              DO d = 1, 3
!                 WRITE(6,1519) CURIRUN, CURIYR+1989, ny+1989, nr, m, d, (WSFWLEL_CF(nr,ny,d,m,h),h=1,24)
!1519             FORMAT(1X,"CF_WL",6(":",I4),24(":",F6.3))
!              END DO
!           END DO

         enddo    ! nr region
      ENDDO !IJ

      WindInputCF_WL = 0.0
      do ny=1, mnumyr
         do nr=1,unrgns
            do m=1,12
               do d=1,3
                  do h=1,24
                     WindInputCF_WL(nr,ny) = WindInputCF_WL(nr,ny) + (WSFWLEL_CF(nr,ny,d,m,h) * IDAYTQ(d,m)) / 8760.0
                  enddo     !hr
               enddo        !daytype
            enddo           !month
         enddo             !region
      enddo              !year

!     debug

      do ny=1, mnumyr
         do nr=1,unrgns
!            WRITE(18,5913) CURIRUN, CURIYR+1989, nr, curiyr+ny+1988, windinputCF(nr,ny), windinputCF_WL(nr,ny)
            WRITE(18,5913) CURIRUN, CURIYR+1989, nr, curiyr+ny+1988, windinputCF(nr,ny)
! 5913       FORMAT(1X,"RENEW_WindInputCF",4(":",I5),2(":",F21.6))
 5913       FORMAT(1X,"RENEW_WindInputCF",4(":",I5),1(":",F21.6))
         end do
      end do

      do ny = 1, MNUMYR
         do d=1,1
            do j=1,12

!             write(*,'(a,4i5,24F9.4)')"RNW-WI-CF3: WSFWLEL,r,y,d,m:", &
!                 nr,ny+1989,d,j,(WSFWLEL_CF(nr,ny,d,j,i),i=1,24)

            enddo
         enddo
      enddo

!     Read capacity factors for wind classes 6,5,4 for 1990 to 2035 by 5 years.

      read(InUnit,'(//)')
      n=0
      do y=1990,ENDYR+5,5
         n=n+1
         read(InUnit,*) yr,(CFAnn_WL(n,wc),wc=1,mnumcl)
      end do

!     Read rotor energy density for wind classes 6,5,4 for 1990 to 2030 by 5 years.
!     read(InUnit,'(//)')
!     do y=1,9
!        read(InUnit,*) yr,(EnArea(y,wc),wc=1,mnumcl)
!     end do

!     Interpolate the values for capacity factors

      do wc=1,mnumcl
         do i=1,n-1
            CInc=(CFAnn_WL(i+1,wc)-CFAnn_WL(i,wc))/5.0
            do ny=1,6
               y=(i-1)*5+ny
               CF_WL(y,wc)=CFAnn_WL(i,wc)+(ny-1)*CInc
            end do
         end do
      end do

!     Low Wind Speed Technology End

!     Read T&D costs by buffer zone and NERC region. Units are $1987/kw.

      read(InUnit,'(//)')
      do nr=1,IJUMPEMRGN
         read(InUnit,*) (WnTDBfcs(nr,bf),bf=1,mnumbf)
      end do

!     Read the incremental capital cost multipliers and their specification.

      read(InUnit,'(//)')
      read(InUnit,*) (ICCMeth(y),y=11,21),(ICCMeth(y),y=26,MNUMYR+5,5)
      read(InUnit,'(1x)')
      do wc=1,mnumcl
         read(InUnit,*) (ICCMult(wc,y),y=11,21),(ICCMult(wc,y),y=26,MNUMYR+5,5)
      end do
      ICCMeth_WL = ICCMeth
      ICCMult_WL = ICCMult

!     read in Percent Tolerance

      read(InUnit,'(a)') TextLine
      read(InUnit,*) PercentTOL

      write(*,*)'Percent Tolerance from windalt file = ',PercentTOL

!     Read the lowload input data.

      read(InUnit,'(8(/))')

!     Minimum coal and nuclear unit turndown by region.

      do nr=1,IJUMPEMRGN
         read(InUnit,*) CTurnDown(nr),NTurnDown(nr)
      end do
      read(InUnit,*) CTurnDown(mnumnr-2),NTurnDown(nr)
      read(InUnit,*) CTurnDown(mnumnr-1),NTurnDown(nr)
      read(InUnit,'(6(/))')

!     Intermittent standard deviations.

      do nr=1,IJUMPEMRGN
         read(InUnit,*) (IntStDdv(nr,j),j=1,ECP_D_INT)
      end do
      read(InUnit,*) (IntStDdv(mnumnr-2,j),j=1,ECP_D_INT)
      read(InUnit,*) (IntStDdv(mnumnr-1,j),j=1,ECP_D_INT)
      read(InUnit,'(6(/))')
      IntStDdv_WL = IntStDdv

!     Intermittent regional correlation coefficients.

      do nr=1,IJUMPEMRGN
         read(InUnit,*) (IntRegCrl(nr,j),j=1,ECP_D_INT)
      end do
      read(InUnit,*) (IntRegCrl(mnumnr-2,j),j=1,ECP_D_INT)
      read(InUnit,*) (IntRegCrl(mnumnr-1,j),j=1,ECP_D_INT)
      IntRegCrl_WL = IntRegCrl

!     Read in capacity factor learning parameters

      read(InUnit,'(7(/))')

!     Overrides old forced CFs (0=force CF, 1=use learning).

      read(InUnit,*) XDummy,OverRideCF
      read(InUnit,'(//)')

!     Ultimate capacity factors by wind class.

      read(InUnit,*) XDummy,(CFUlt(wc),wc=1,mnumcl)
      read(InUnit,'(//)')

!     Ultimate capacity factors by wind class for low speed technology.

      read(InUnit,*) XDummy,(CFUlt_WL(wc),wc=1,mnumcl)
      read(InUnit,'(/)')

!     Known capacity factor at specified capacity level (class 6).

      read(InUnit,*) XDummy,CFAtx
      read(InUnit,'(//)')

!     Capacity level (GW) at which CFAtx is specified.

      read(InUnit,*) XDummy,FixedX
      read(InUnit,'(//)')

!     Capacity level (GW) at which CFAtx is specified.

      read(InUnit,*) XDummy,WL_FixedX
      read(InUnit,'(//)')

!     Power density (MW/sq. km) of wind turbine.

      read(InUnit,*) XDummy,PwrDen

!     Interpolate  the capital cost multipliers after 2010.

      do wc=1,mnumcl
         do y=21,MNUMYR,5
            CInc=(ICCMult(wc,y+5)-ICCMult(wc,y))/5.0
            do ny=1,4
               ICCMult(wc,y+ny)=ICCMult(wc,y+ny-1)+CInc
            end do
         end do
      end do

!     Line up everything.  Put ICCMults into ICCCosts if the method is not 1.

      do y=1,10
         ICCMeth(y)=1
         do wc=1,mnumcl
            ICCMult(wc,y)=1.0
         end do
      end do
      do y=11,MNUMYR+5
         if(y.gt.21) ICCMeth(y)=ICCMeth(21)
         if(ICCMeth(y).ne.1) then
            do wc=1,mnumcl
               ICCCost(wc,y)=ICCMult(wc,y)
               ICCMult(wc,y)=0.0
            end do
         end if
      end do

!     Load cost and mult values and cap factors into 1 yr earlier than specified
!     so the ECP module will see the values in the correct year
!
     do y=1,36
!        write(*,'(a,3i6,2(4f8.2),4f8.4)')'WN ShiftEBGW1,y,meth,cost,mult,cf:',  &
!           y,y+1989,ICCMeth(y),(ICCCost(wc,y),wc=1,mnumcl),(ICCMult(wc,y),wc=1,mnumcl), &
!           (CF(y,wc),wc=1,mnumcl)
     enddo

      Do y=2,MNUMYR+5
         if(ICCMeth(y) .eq. 2) then
            ICCMeth(y-1)=ICCMeth(y)
            do wc=1,mnumcl
               ICCCost(wc,y-1)=ICCCost(wc,y)
               ICCMult(wc,y-1)=ICCMult(wc,y)
               if(y.le.MNUMYR) CF(y-1,wc)=CF(y,wc)
            enddo
         endif
      enddo

     do y=1,36
!        write(*,'(a,3i6,2(4f8.2),4f8.4)')'WN ShiftEBGW2,y,meth,cost,mult,cf:',  &
!           y,y+1989,ICCMeth(y),(ICCCost(wc,y),wc=1,mnumcl),(ICCMult(wc,y),wc=1,mnumcl),  &
!           (CF(y,wc),wc=1,mnumcl)
     enddo
!
!     Load cost and mult values into each region
!     first get index for wind in ECP

      ECPWind=0
      do t = 1, ECP_D_CAP
         if (UPLNTCD(t).eq.'WN') ECPWind=t
      enddo
      if (ECPWind.eq.0) then
         write(*,*)"ERROR:Can not find ecp wind index"
         stop
      endif
      do nr=1,unrgns
         if (nr.le.(unrgns)) Call GETBLD(1,nr)
         do wc=1,mnumcl
            do y=1,MNUMYR+5
               ICCMultR(nr,wc,y) = ICCMult(wc,y)

!              write(*,'(a,4i6,f10.2,2i6,4f10.4)')"WN ICCCost,wc,y,eprgm,epacm:",curiyr,y,curitr, nr, &
!                 ICCCost(wc,y),wc,y,EPRGM(ECPWind),EPACM(ECPWind), ICCMultR(nr,wc,y),ICCMult(wc,y)

               if (nr.le.(unrgns)) then
                  ICCCostR(nr,wc,y) = ICCCost(wc,y)*EPRGM(ECPWind)*EPACM(ECPWind)
               else
                  ICCCostR(nr,wc,y) = ICCCost(wc,y)
               endif
            enddo
         enddo
      enddo

!     Write out the multipliers to the debug file.

      write(IORNREPT,'(a3,1x,a7,<2*mnumcl>(a9,i1))'),'Yr','ICCMeth',(('ICCMult',7-wc),('ICCCost',7-wc),wc=1,mnumcl)
      do y=1,MNUMYR+5
         write(IORNREPT,'(i4,i6,<2*mnumcl>f10.1)') y+1989,ICCMeth(y),(ICCMult(wc,y),ICCCost(wc,y),wc=1,mnumcl)
      end do

!     Interpolate  the capital cost multipliers after 2010 WL

      do wc=1,mnumcl
         do y=21,MNUMYR,5
            CInc=(ICCMult_WL(wc,y+5)-ICCMult_WL(wc,y))/5.0
            do ny=1,4
               ICCMult_WL(wc,y+ny)=ICCMult_WL(wc,y+ny-1)+CInc
            end do
         end do
      end do

!     Line up everything.  Put ICCMults_WL into ICCCosts_WL if the method is not 1.

      do y=1,10
         ICCMeth_WL(y)=1
         do wc=1,mnumcl
            ICCMult_WL(wc,y)=1.0
         end do
      end do
      do y=11,MNUMYR+5
         if(y.gt.21) ICCMeth_WL(y)=ICCMeth_WL(21)
         if(ICCMeth_WL(y).ne.1) then
            do wc=1,mnumcl
               ICCCost_WL(wc,y)=ICCMult_WL(wc,y)
               ICCMult_WL(wc,y)=0.0
            end do
         end if
      end do

!     Load cost and mult values and cap factors into 1 yr earlier than specified
!     so the ECP module will see the values in the correct year
!
     do y=1,36
!        write(*,'(a,3i6,2(3f8.2),3f8.4)')'WL ShiftEBGW1,y,meth,cost,mult,cf:',  &
!           y,y+1989,ICCMeth_WL(y),(ICCCost_WL(wc,y),wc=1,mnumcl),(ICCMult_WL(wc,y),wc=1,mnumcl), &
!           (CF_WL(y,wc),wc=1,mnumcl)
     enddo

      Do y=2,MNUMYR+5
         if(ICCMeth_WL(y) .eq. 2) then
            ICCMeth_WL(y-1)=ICCMeth_WL(y)
            do wc=1,mnumcl
               ICCCost_WL(wc,y-1)=ICCCost_WL(wc,y)
               ICCMult_WL(wc,y-1)=ICCMult_WL(wc,y)
               if(y.le.MNUMYR) CF_WL(y-1,wc)=CF_WL(y,wc)
            enddo
         endif
      enddo

     do y=1,36
!        write(*,'(a,3i6,2(3f8.2),3f8.4)')'WL ShiftEBGW2,y,meth_WL,cost_WL,mult_WL,cf_WL:',  &
!           y,y+1989,ICCMeth_WL(y),(ICCCost_WL(wc,y),wc=1,mnumcl),(ICCMult_WL(wc,y),wc=1,mnumcl),  &
!           (CF_WL(y,wc),wc=1,mnumcl)
     enddo
!
!     Load cost and mult values into each region
!     first get index for wind in ECP

      ECPWind=0
      do t = 1, ECP_D_CAP
         if (UPLNTCD(t).eq.'WL') ECPWind=t
      enddo
      if (ECPWind.eq.0) then
         write(*,*)"ERROR:Can not find ecp wind index"
         stop
      endif
      do nr=1,unrgns
         if (nr.le.(unrgns)) Call GETBLD(1,nr)
         do wc=1,mnumcl
            do y=1,MNUMYR+5
               ICCMultR_WL(nr,wc,y) = ICCMult_WL(wc,y)

!              write(*,'(a,2i6,f10.2,2i6,2f10.4)')"ICCCost_WL,wc,y,eprgm,epacm:",curiyr,curitr,  &
!                 ICCCost_WL(wc,y),wc,y,EPRGM(ECPWind),EPACM(ECPWind)

               if (nr.le.(unrgns)) then
                  ICCCostR_WL(nr,wc,y) = ICCCost_WL(wc,y)*EPRGM(ECPWind)*EPACM(ECPWind)
               else
                  ICCCostR_WL(nr,wc,y) = ICCCost_WL(wc,y)
               endif
            enddo
         enddo
      enddo

!     Write out the multipliers to the debug file.

!      write(IORNREPT,'(a3,1x,a7,<2*mnumcl>(a9,i1))'),'Yr','ICCMeth_WL',(('ICCMult_WL',7-wc),('ICCCost_WL',7-wc),wc=1,mnumcl)
!      do y=1,MNUMYR+5
!         write(IORNREPT,'(i4,i6,<2*mnumcl>f10.1)') y+1989,ICCMeth_WL(y),(ICCMult_WL(wc,y),ICCCost_WL(wc,y),wc=1,mnumcl)
!      end do

!     Land area is constant in all years so copy it over the years (actually as waste of space).

      do nr=1,mnumnr
         do wc=1,mnumcl
            do bf=1,mnumbf
               do yr=2,MNUMYR
                  LdArea(nr,yr,wc,bf)=LdArea(nr,1,wc,bf)
               end do
            end do
         end do
      end do

!     Calculate the maximum potential capacity for all the years, in the first year put it into available capacity.

      do yr=1,MNUMYR
         do nr=1,mnumnr
            do wc=1,mnumcl
               do bf=1,mnumbf

!                 now (05-25-04)  using the simplified formula from aeo04
!                 if the aeo04 formulas with learning sw on and overrideCF sw on
!                 for AREA, SWAREA and WCAWIEL are expanded, and variables cancelled out, it becomes
!                 WCAWIEL = pwrden * LDAREA
!                 using the assumption of overriding CF for gpra runs

                  if (yr.le.UESTYR-UHBSYR) then
                     WCapMax(nr,yr,wc,bf)= PwrDen * LdArea(nr,yr,wc,bf)
                  else
                     WCapMax(nr,yr,wc,bf)=WCapMax(nr,(UESTYR-UHBSYR),wc,bf)
                  end if
                  ICapAvl(nr,yr,wc,bf)=WCapMax(nr,yr,wc,bf)
               end do
            end do
         end do
      end do

!     Fill in the rankings in the early years (we need lagged values) using the strict hierarchy.

      do yr=1,(UESTYR-UHBSYR)-1
         do nr=1,mnumnr
            n=0
            do wc=1,mnumcl
               do bf=1,mnumbf
                  n=n+1
                  Rwc(nr,n,yr)=wc
                  Rbf(nr,n,yr)=bf
                  Rwc_WL(nr,n,yr)=wc
                  Rbf_WL(nr,n,yr)=bf
               end do
            end do
         end do
      end do

      Call WindRank3
      Call WindRank3_WL

      write(*,*)'WINDDBG - calling WindIn3_OFS ',trim(scen_date),' ',curiyr,' ',InUnit

      Call WindIn3_OFS(InUnit)

      InUnit=File_Mgr('C',Name,NEW)

      return
      end

!******************************************************************
!     Subroutine WindMisc3 decrements the wind resources given the new planned capacity and
!     determines the new "best" wind class and buffer zone.  It also converts available swept land
!     area into megawatts of available capacity and calculates capacity factors by time slice.

      subroutine WindMisc3

      implicit none
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'ecpcntl'
      include 'control'
      include 'wrenew'
      include 'wwind'
      include 'wrenio'
      include 'rencntl'
      include 'dsmdimen'
      include 'dsmtfecp'
      include 'entcntl'
      include 'udatout'
      include 'uecpout'
      include 'uefdout'

      integer yr,nr,wc,wc_WL,bf,bf_WL,WTech,WTech_WL,s,stp,t,Numxc,Numnc,T_RNUM
      integer x,Done,Done_WL,lev,n,i,h,m,d
      real PI,XTot,YTot
      parameter(PI = 3.141593)
      real Ratio,Epsi,MaxDiff,AvlDiff
      real CapOut,CapOut_WL,ZLTElas,Ralph(mnumnr),CapTemp

!     real SuppCapMin,SuppCap,Value,CapFrac

      real SuppCap,Value,Value_WL,CapFrac

!     integer XSwitch

      real NatWnCap,NatWLCap,CFLrn,CFLrn_WL
      real BaseLdCap,WnProb,WnProb_WL,AllowWnCap,AllowWnCap_WL,ExcessWn,ExcessWn_WL,NWn,NWn_WL,FullWn,FullWn_WL,WnRegStd,WnRegStd_WL,BaseCF,BaseCF_WL,InstWind,InstWind_WL,AveWnCap,AveWnCap_WL, &
         CoalAvail,NucAvail,XCoalAvail,NCoalAvail
      integer JDoCFA,JDoCFB

      data Epsi / 0.000001 /
      WTech = 10   !Wind technology number. - Shouldn't I be determining this instead of hard - wired?
      WTech_WL = 11
      write( * , * )'WINDDBG - starting WindMisc3 ',trim(scen_date),' ',curiyr

!     If OverRideCF = 1 then overwrite the CFs at this point

      if (OverRideCF  .gt.  0) then

!        Calculate the slope factor CFLrn just once.

         CFLrn = FixedX * log(CFAtx / CFUlt(1))

         write( * ,'(a,3i4,7f12.2)')'WINDDBG4 - y,i,overrideCF,cflrn,fixedx,cfatx,cfult,log: ', &
            curiyr,curitr,OverRideCF,CFLrn,FixedX,CFAtx,CFUlt(1),log(CFAtx / CFUlt(1))

!        Calculate the capacity factor based upon the amount of installed capacity.

         NatWnCap = 0
         do nr = 1 , unrgns
            NatWnCap = NatWnCap + UCAPWNR(nr,curiyr) * 0.001
         end do
         NatWnCap = Max(NatWnCap , FixedX)

!        WRITE(6,3003) CURIRUN,CURIYR+1989,CURITR,(UCAPWNR(nr,curiyr),nr=1,mnumnr)
 3003    FORMAT(1X,"UCAPWNR",3(":",I5),<unrgns>(":",F12.3))
!        WRITE(6,3004) CURIRUN,CURIYR+1989,CURITR,(UCAPWNN(nr,curiyr) + UCAPWNU(nr,curiyr),nr=1,mnumnr)
 3004    FORMAT(1X,"UCAPWNU",3(":",I5),<unrgns>(":",F12.3))

!        Adjust the capacity factors and the land area (adjusts only for wind class 6).

         do wc = 1,mnumcl
            IF (NatWnCap .GT. 0.0) THEN
               CF(curiyr,wc) = CFUlt(wc) * exp(CFLrn / NatWnCap)
            ELSE

            write( * ,'(a,4(":",i4),4(":",f12.2))')'WINDDBG3 - y,i,c,CFult,CFlrn,natwncap: ',  &
               curirun,curiyr,curitr,wc,CFUlt(wc),CFLrn,NatWnCap,CF(curiyr,wc)

            END IF
         end do

!        Calculate the slope factor CFLrn_WL just once for new technology.

         CFLrn_WL = WL_FixedX * log(CFAtx / CFUlt_WL(1))

!         write( * ,'(a,3i4,7f12.2)')'WINDDBG4 - y,i,overrideCF,cflrn_WL,WL_FixedX,cfatx,CFUlt_WL,log: ', &
!            curiyr,curitr,OverRideCF,CFLrn_WL,WL_FixedX,CFAtx,CFUlt_WL(1),log(CFAtx / CFUlt_WL(1))

!        Calcualte the capacity factor based upon the amount of installed capacity for new technology.

         NatWLCap = 0
         do nr = 1 , unrgns
            NatWLCap = NatWLCap + UCAPWNR(nr,curiyr) * 0.001
         end do
         NatWLCap = Max(NatWLCap , WL_FixedX)

!        WRITE(6,4003) CURIRUN,CURIYR+1989,CURITR,(UCAPWLR(nr,curiyr),nr=1,mnumnr)
 4003    FORMAT(1X,"UCAPWLR",3(":",I5),<unrgns>(":",F12.3))
!        WRITE(6,4004) CURIRUN,CURIYR+1989,CURITR,(UCAPWLN(nr,curiyr) + UCAPWLU(nr,curiyr),nr=1,mnumnr)
 4004    FORMAT(1X,"UCAPWLU",3(":",I5),<unrgns>(":",F12.3))

!        Adjust the capacity factors and the land area (adjusts only for wind class 6) for new technology.

         do wc = 1,mnumcl
            IF (NatWLCap .GT. 0.0) THEN
               CF_WL(curiyr,wc) = CFUlt_WL(wc) * exp(CFLrn_WL / NatWLCap)
            ELSE

!               write( * ,'(a,4(":",i4),4(":",f12.2))')'WINDDBG3 - y,i,c,CFUlt_WL,CFlrn,NatWLCap: ',  &
!                  curirun,curiyr,curitr,wc,CFUlt_WL(wc),CFLrn,NatWLCap,CF_WL(curiyr,wc)

            END IF
         end do
      endif

!     NOTE - At first blush, the stuff at the end of the input subroutine should go here because we have
!     now modified CF and Area. But that would only change the amount of capacity from the fixed land
!     area in each year and are not sure we want to. The change in the CF will be used below this point
!     in subsequent routines, and that may be all we really need or want.

!     This accounting takes into account the years in which each piece of capacity is added.

      if (curcalyr .le. UESTYR ) then
         do yr = 1 , curiyr
            do nr = 1 , unrgns
               CapInstall(nr,yr) = 0.0
               CapCommit(nr,yr) = 0.0
               CapAdded(nr,yr) = 0.0
               CapNewBld(nr,yr) = 0.0
               CapPlnBld(nr,yr) = 0.0
               CapCmtTot(nr,yr) = 0.0
               CapIandC(nr,yr) = 0.0

               CapInstall_WL(nr,yr) = 0.0
               CapCommit_WL(nr,yr) = 0.0
               CapAdded_WL(nr,yr) = 0.0
               CapNewBld_WL(nr,yr) = 0.0
               CapPlnBld_WL(nr,yr) = 0.0
               CapCmtTot_WL(nr,yr) = 0.0
               CapIandC_WL(nr,yr) = 0.0
            end do
         end do
      end if


!     Do all the stock and flow accounting for each region.

      do nr = 1 , mnumnr
!        Get the installed capacity from the electricity model. It is the sum of utility and non - utility capacity.

         CapInstall(nr,curiyr) = amax1(0.0 , UCAPWNR(nr,curiyr))
         UTRSCU(nr,WTech) = CapInstall(nr,curiyr)

         CapInstall_WL(nr,curiyr) = amax1(0.0 , UCAPWLR(nr,curiyr))
         UTRSCU(nr,WTech_WL) = CapInstall_WL(nr,curiyr)

!        Get the committed capacity and the lead time from the elecctricity model.

         NLead = UPPLYR(WIWN)
         NLead_WL = UPPLYR(WIWL)


         CapCommit(nr,curiyr) = UADDWND(nr,curiyr + NLead)
         CapCommit_WL(nr,curiyr) = UADDWLD(nr,curiyr + NLead_WL)

!        Capacity added is the difference between the total capacity installed this year minus last year.

         CapAdded(nr,curiyr) = CapInstall(nr,curiyr) - CapInstall(nr,curiyr - 1)
         CapAdded_WL(nr,curiyr) = CapInstall_WL(nr,curiyr) - CapInstall_WL(nr,curiyr - 1)


!        New builds is equal to what was committed NLead number of years ago.

         CapNewBld(nr,curiyr) = CapCommit(nr,curiyr - NLead)
         CapNewBld_WL(nr,curiyr) = CapCommit_WL(nr,curiyr - NLead_WL)


!        Planned capacity is the difference between the capacity added and the new builds.

         CapPlnBld(nr,curiyr) = CapAdded(nr,curiyr) - CapNewBld(nr,curiyr)
         CapPlnBld_WL(nr,curiyr) = CapAdded_WL(nr,curiyr) - CapNewBld_WL(nr,curiyr)

!        Total capacity committed is the committed capacity in this year and in previous years not yet built.

         do i = 0,NLead - 1
            CapCmtTot(nr,curiyr) = CapCmtTot(nr,curiyr) + CapCommit(nr,curiyr - i)
         end do

         do i = 0,NLead_WL - 1
            CapCmtTot_WL(nr,curiyr) = CapCmtTot_WL(nr,curiyr) + CapCommit_WL(nr,curiyr - i)
         end do


!        Total capacity installed plus total capacity committed.

         CapIandC(nr,curiyr) = CapInstall(nr,curiyr) + CapCmtTot(nr,curiyr)
         CapIandC_WL(nr,curiyr) = CapInstall_WL(nr,curiyr) + CapCmtTot_WL(nr,curiyr)

         WRITE (18,3515) CURIRUN, CURIYR+1989, CURITR, nr, WIWN, WTECH, NLead, CapIandC(nr,curiyr), CapCmtTot(nr,curiyr), CapPlnBld(nr,curiyr), CapNewBld(nr,curiyr), &
            CapAdded (nr,curiyr), CapCommit(nr,curiyr), CapInstall(nr,curiyr), UCAPWNR(nr,curiyr-1), UCAPWNR(nr,curiyr), UADDWND(nr,curiyr), UADDWND(nr,curiyr+NLead)
 3515    FORMAT (1X, "WINDMISC3_Capacity",":WN",7(":",I5),11(":",F21.6))

 !        WRITE (18,3516) CURIRUN, CURIYR+1989, CURITR, nr, WIWL, WTECH_WL, NLead_WL, CapIandC_WL(nr,curiyr), CapCmtTot_WL(nr,curiyr), CapPlnBld_WL(nr,curiyr), CapNewBld_WL(nr,curiyr), &
 !           CapAdded_WL (nr,curiyr), CapCommit_WL(nr,curiyr), CapInstall_WL(nr,curiyr), UCAPWLR(nr,curiyr-1), UCAPWLR(nr,curiyr), UADDWLD(nr,curiyr), UADDWLD(nr,curiyr+NLead)
 3516    FORMAT (1X, "WINDMISC3_Capacity",":WL",7(":",I5),11(":",F21.6))


!        Increment the available, remaining capacity for the change ("growth") in original capacity. In general we
!        have constructed the model so original capacity is constant over time, so this doesn't usually matter.
!        However, if the growth in the original maximum is negative, then we need to be sure that if we have already
!        used some capacity in that category then we don't say there is a negative amount available.

         Do wc = 1,mnumcl
         Do bf = 1,mnumbf
            MaxDiff = WCapMax(nr,curiyr,wc,bf) - WCapMax(nr,curiyr - 1,wc,bf)
            if ((ICapAvl(nr,curiyr - 1,wc,bf) + MaxDiff) .gt. 0.0) then
               ICapAvl(nr,curiyr,wc,bf) = ICapAvl(nr,curiyr - 1,wc,bf) + MaxDiff
            else
               ICapAvl(nr,curiyr,wc,bf) = 0.0
            end if
            if ((WCapAvl(nr,curiyr - 1,wc,bf) + MaxDiff) .gt. 0.0) then
               WCapAvl(nr,curiyr,wc,bf) = WCapAvl(nr,curiyr - 1,wc,bf) + MaxDiff
            else
               WCapAvl(nr,curiyr,wc,bf) = 0.0
               AvlDiff = WCapAvl(nr,curiyr - 1,wc,bf)
               if (AvlDiff .gt. 0.0) then
                  WCapMax(nr,curiyr,wc,bf) = WCapMax(nr,curiyr - 1,wc,bf) - AvlDiff
               else
                  WCapMax(nr,curiyr,wc,bf) = WCapMax(nr,curiyr - 1,wc,bf)
               end if
            end if
         end do !bf
         end do !wc

!        Now I need to allocate the various capacities into the wind classes and transmission
!        buffer zones. These need to be allocated because the wind model only knows how much
!        overall capacity had been chosen by the electricity model - it has to work backwards
!        to determine which wind classes and buffer zones it all came out of. Moreover, it
!        has to pay attention to the yearly timing of each piece, because the ranking of the
!        wind classes and buffer zones can change over time.
!        A key thing to remember is that the builds from electricity are actually the previous year.
!        The total new installed (includes planned builds and previously committed that is now built)
!        was committed NLead number of years earlier plus one more year because they are only being
!        shown to us now. So it is allocated using the rankings from NLead + 1 number of years earlier.
!        These will be cumulated over time to get the overall total installed.
!        The new committed "this year" is allocated using the rankings last year. Committed in
!        previous years but not yet built is allocated using the rankings in the respective year.
!        These will be cumulated over time to get the overall total committed and then added to
!        the total installed to get the total installed plus committed.

!        Total New Installed. The new is in ICapInc, the cumulative is in ICapCum, and the available is in ICapAvl.
!        Clear out the totals.

         do wc = 1 , mnumcl
            do bf = 1 , mnumbf
               ICapInc(nr,curiyr,wc,bf) = 0.0
               ICapInc_WL(nr,curiyr,wc,bf) = 0.0
               ICapCum(nr,curiyr,wc,bf) = 0.0
               ICapCum_WL(nr,curiyr,wc,bf) = 0.0
            end do
         end do
         CapOut = CapAdded(nr,curiyr)
         CapOut_WL = CapAdded_WL(nr,curiyr)


         if (CapOut .ge. 0.0) then

!           Do this if the amount of new installed capacity is greater than zero.

            do n = 1,RNum
               wc = Rwc(nr,n,curiyr - (NLead + 1))
               bf = Rbf(nr,n,curiyr - (NLead + 1))
               AvlDiff = ICapAvl(nr,curiyr,wc,bf)
               if (ICapAvl(nr,curiyr,wc,bf) .gt. 0.0) then
                  if (ICapAvl(nr,curiyr,wc,bf) .ge. CapOut) then
                     ICapInc(nr,curiyr,wc,bf) = CapOut
                     ICapAvl(nr,curiyr,wc,bf) = ICapAvl(nr,curiyr,wc,bf) - CapOut
                     CapOut = 0.0
                  else
                     ICapInc(nr,curiyr,wc,bf) = ICapAvl(nr,curiyr,wc,bf)
                     CapOut = CapOut - ICapAvl(nr,curiyr,wc,bf)
                     ICapAvl(nr,curiyr,wc,bf) = 0.0
                  endif

                  WRITE(18,3517) CURIRUN, CURIYR+1989, CURITR, nr, WIWN, WTECH, n, 7-wc, bf, AvlDiff, CapAdded(nr,curiyr),CapOut, ICapAvl(nr,curiyr,wc,bf), ICapInc(nr,curiyr,wc,bf)
 3517             FORMAT (1X,"WINDMISC3_INCCAP",":WN",9(":",I5),5(":",F21.6))

               endif
            end do
         else

!           Do this if the amount of new installed capacity is negative (retirements?).

            do n = 1,RNum
               wc = Rwc(nr,n,curiyr - (NLead + 1))
               bf = Rbf(nr,n,curiyr - (NLead + 1))
               AvlDiff = ICapAvl (nr,curiyr,wc,bf)
               if (ICapAvl(nr,curiyr,wc,bf) .gt. 0.0) then
                  ICapInc(nr,curiyr,wc,bf) = CapOut
                  CapOut = 0.0
                  ICapAvl(nr,curiyr,wc,bf) = ICapAvl(nr,curiyr,wc,bf) - ICapInc(nr,curiyr,wc,bf)

                  WRITE(18,3517) CURIRUN, CURIYR+1989, CURITR, nr, WIWN, WTECH, n, 7-wc, bf, AvlDiff, CapAdded(nr,curiyr),CapOut, ICapAvl(nr,curiyr,wc,bf), ICapInc(nr,curiyr,wc,bf)

               endif
            end do
         endif

         if (CapOut_WL .ge. 0.0) then

!           Do this if the amount of new installed capacity is greater than zero.

            do n = 1 , RNum_WL
               wc = Rwc_WL(nr,n,curiyr - (NLead + 1))
               bf = Rbf_WL(nr,n,curiyr - (NLead + 1))
               AvlDiff = ICapAvl(nr,curiyr,wc,bf)
               if (ICapAvl(nr,curiyr,wc,bf) .gt. 0.0) then
                  if (ICapAvl(nr,curiyr,wc,bf) .ge. CapOut_WL) then
                     ICapInc_WL(nr,curiyr,wc,bf) = CapOut_WL
                     ICapAvl(nr,curiyr,wc,bf) = ICapAvl(nr,curiyr,wc,bf) - CapOut
                     CapOut_WL = 0.0
                  else
                     ICapInc_WL(nr,curiyr,wc,bf) = ICapAvl(nr,curiyr,wc,bf)
                     CapOut_WL = CapOut_WL - ICapAvl(nr,curiyr,wc,bf)
                     ICapAvl(nr,curiyr,wc,bf) = 0.0
                  endif

!                  WRITE(18,3518) CURIRUN, CURIYR+1989, CURITR, nr, WIWL, WTECH_WL, n, 7-wc, bf, AvlDiff, CapAdded_WL(nr,curiyr), CapOut_WL, ICapAvl(nr,curiyr,wc,bf), ICapInc_WL(nr,curiyr,wc,bf)
 3518             FORMAT (1X,"WINDMISC3_INCCAP",":WL",9(":",I5),5(":",F21.6))

               endif
            end do
         else

!           Do this if the amount of new installed capacity is negative (retirements?).

            do n = 1 , RNum_WL
               wc = Rwc(nr,n,curiyr - (NLead + 1))
               bf = Rbf(nr,n,curiyr - (NLead + 1))
               if (ICapAvl(nr,curiyr,wc,bf) .gt. 0.0) then
                  ICapInc(nr,curiyr,wc,bf) = CapOut_WL
                  CapOut_WL = 0.0
                  ICapAvl(nr,curiyr,wc,bf) = ICapAvl(nr,curiyr,wc,bf) - ICapInc_WL(nr,curiyr,wc,bf)

!                  WRITE(6,3518) CURIRUN, CURIYR+1989, CURITR, nr, WIWL, WTECH_WL, n, 7-wc, bf, AvlDiff, CapAdded_WL(nr,curiyr), CapOut_WL, ICapAvl(nr,curiyr,wc,bf), ICapInc_WL(nr,curiyr,wc,bf)

               endif
            end do
         endif

!        Add the increment to the cumulative running total over the years.

         do wc = 1 , mnumcl
            do bf = 1 , mnumbf
               ICapCum(nr,curiyr,wc,bf) = ICapCum(nr,curiyr - 1,wc,bf) + ICapInc(nr,curiyr,wc,bf)
               ICapCum_WL(nr,curiyr,wc,bf) = ICapCum_WL(nr,curiyr - 1,wc,bf) + ICapInc_WL(nr,curiyr,wc,bf)
            end do
         end do


!        Add in the committed capacity one at a time starting with the oldest.
!        The new is in WCapInc, the cumulative is in WCapCum, and the available is in WCapAvl.
!        Note that we use rankings one year back for the committments this year (because this
!        is really the beginning of the year - the committments are from last year even though
!        they are indexed for this year...). This is also convienent because we don't have
!        rankings for this year yet (it is the beginning of the year). This is also why the
!        subscripts for the committed capacity and the rankings are different by one year...
!        First put ICapAvl into WCapAvl so that we start from ICapAvl and add the increment.

         do wc = 1 , mnumcl
            do bf = 1 , mnumbf
               WCapAvl(nr,curiyr,wc,bf) = ICapAvl(nr,curiyr,wc,bf)
               WCapInc(nr,curiyr,wc,bf) = 0.0
            end do
         end do
         do i = NLead,1, - 1
            CapOut = CapCommit(nr,curiyr - (i - 1))
            do n = 1,RNum
               wc = Rwc(nr,n,curiyr - i)
               bf = Rbf(nr,n,curiyr - i)
               if (WCapAvl(nr,curiyr,wc,bf) .gt. 0.0) then
                  if (WCapAvl(nr,curiyr,wc,bf) .ge. CapOut) then
                     WCapInc(nr,curiyr,wc,bf) = WCapInc(nr,curiyr,wc,bf) + CapOut
                     WCapAvl(nr,curiyr,wc,bf) = WCapAvl(nr,curiyr,wc,bf) - CapOut
                     CapOut = 0.0
                  else
                     WCapInc(nr,curiyr,wc,bf) = WCapInc(nr,curiyr,wc,bf) + WCapAvl(nr,curiyr,wc,bf)
                     CapOut = CapOut - WCapAvl(nr,curiyr,wc,bf)
                     WCapAvl(nr,curiyr,wc,bf) = 0.0
                  endif
               endif
            end do
         end do

         ! do wc = 1 , mnumcl
            ! do bf = 1 , mnumbf
               ! WCapAvl(nr,curiyr,wc,bf) = ICapAvl(nr,curiyr,wc,bf)   ! mas (10/11/24) if we ever turn WL on, this will need to be fixed
               ! WCapInc_WL(nr,curiyr,wc,bf) = 0.0                     ! WCapAvl and ICapAvl here probably should be specific to WL
            ! end do                                                   ! As is now, it's resetting WCapAvl for WN, when then causes overbuilding
         ! end do
         do i = NLead_WL,1, - 1
            CapOut_WL = CapCommit_WL(nr,curiyr - (i - 1))
            do n = 1,RNum_WL
               wc = Rwc_WL(nr,n,curiyr - i)
               bf = Rbf_WL(nr,n,curiyr - i)
               if (WCapAvl(nr,curiyr,wc,bf) .gt. 0.0) then
                  if (WCapAvl(nr,curiyr,wc,bf) .ge. CapOut_WL) then
                     WCapInc_WL(nr,curiyr,wc,bf) = WCapInc_WL(nr,curiyr,wc,bf) + CapOut_WL
                     WCapAvl(nr,curiyr,wc,bf) = WCapAvl(nr,curiyr,wc,bf) - CapOut_WL
                     CapOut_WL = 0.0
                  else
                     WCapInc_WL(nr,curiyr,wc,bf) = WCapInc_WL(nr,curiyr,wc,bf) + WCapAvl(nr,curiyr,wc,bf)
                     CapOut_WL = CapOut_WL - WCapAvl(nr,curiyr,wc,bf)
                     WCapAvl(nr,curiyr,wc,bf) = 0.0
                  endif
               endif
            end do
         end do

!        Add the increment to the cumulative running total over the years.

         do wc = 1 , mnumcl
            do bf = 1 , mnumbf
               WCapCum(nr,curiyr,wc,bf) = ICapCum(nr,curiyr,wc,bf) + WCapInc(nr,curiyr,wc,bf)
               WCapCum_WL(nr,curiyr,wc,bf) = ICapCum_WL(nr,curiyr,wc,bf) + WCapInc_WL(nr,curiyr,wc,bf)
            end do
         end do


!        Sum up original (maximum) capacity, incremental capacity, and available capacity.

         CapOrig(nr,curiyr) = 0.0
         CapIncr(nr,curiyr) = 0.0
         CapAvail(nr,curiyr) = 0.0
         CapCumTot(nr,curiyr) = 0.0
         do wc = 1 , mnumcl
            do bf = 1 , mnumbf
               CapOrig(nr,curiyr) = CapOrig(nr,curiyr) + WCapMax(nr,curiyr,wc,bf)
               CapIncr(nr,curiyr) = CapIncr(nr,curiyr) + WCapInc(nr,curiyr,wc,bf)
               CapAvail(nr,curiyr) = CapAvail(nr,curiyr) + WCapAvl(nr,curiyr,wc,bf)
               CapCumTot(nr,curiyr) = CapCumTot(nr,curiyr) + WCapCum(nr,curiyr,wc,bf)
            end do
         end do

         CapIncr_WL(nr,curiyr) = 0.0
         CapCum_WL(nr,curiyr) = 0.0
         do wc = 1 , mnumcl
            do bf = 1 , mnumbf
               CapIncr_WL(nr,curiyr) = CapIncr_WL(nr,curiyr) + WCapInc_WL(nr,curiyr,wc,bf)
               CapCum_WL(nr,curiyr) = CapCum_WL(nr,curiyr) + WCapCum_WL(nr,curiyr,wc,bf)
            end do
         end do

      end do !       Regions

!     Sum all of these updated capacity categories over regions and classes and zones.

      CapInstall(mnumnr,curiyr) = 0.0
      CapAdded(mnumnr,curiyr) = 0.0
      CapCommit(mnumnr,curiyr) = 0.0
      CapNewBld(mnumnr,curiyr) = 0.0
      CapPlnBld(mnumnr,curiyr) = 0.0
      CapCmtTot(mnumnr,curiyr) = 0.0
      CapIandC(mnumnr,curiyr) = 0.0
      CapOrig(mnumnr,curiyr) = 0.0
      CapIncr(mnumnr,curiyr) = 0.0
      CapAvail(mnumnr,curiyr) = 0.0
      CapCumTot(mnumnr,curiyr) = 0.0
      WCapMax(mnumnr,curiyr,:,:) = 0.0
      WCapInc(mnumnr,curiyr,:,:) = 0.0
      WCapAvl(mnumnr,curiyr,:,:) = 0.0
      WCapCum(mnumnr,curiyr,:,:) = 0.0
      ICapInc(mnumnr,curiyr,:,:) = 0.0
      ICapAvl(mnumnr,curiyr,:,:) = 0.0
      ICapCum(mnumnr,curiyr,:,:) = 0.0
      do nr = 1 , mnumnr
         CapInstall(mnumnr,curiyr) = CapInstall(mnumnr,curiyr) + CapInstall(nr,curiyr)
         CapAdded(mnumnr,curiyr) = CapAdded(mnumnr,curiyr) + CapAdded(nr,curiyr)
         CapCommit(mnumnr,curiyr) = CapCommit(mnumnr,curiyr) + CapCommit(nr,curiyr)
         CapNewBld(mnumnr,curiyr) = CapNewBld(mnumnr,curiyr) + CapNewBld(nr,curiyr)
         CapPlnBld(mnumnr,curiyr) = CapPlnBld(mnumnr,curiyr) + CapPlnBld(nr,curiyr)
         CapCmtTot(mnumnr,curiyr) = CapCmtTot(mnumnr,curiyr) + CapCmtTot(nr,curiyr)
         CapIandC(mnumnr,curiyr) = CapIandC(mnumnr,curiyr) + CapIandC(nr,curiyr)
         CapOrig(mnumnr,curiyr) = CapOrig(mnumnr,curiyr) + CapOrig(nr,curiyr)
         CapIncr(mnumnr,curiyr) = CapIncr(mnumnr,curiyr) + CapIncr(nr,curiyr)
         CapAvail(mnumnr,curiyr) = CapAvail(mnumnr,curiyr) + CapAvail(nr,curiyr)
         CapCumTot(mnumnr,curiyr) = CapCumTot(mnumnr,curiyr) + CapCumTot(nr,curiyr)
         do wc = 1 , mnumcl
            do bf = 1 , mnumbf
               WCapMax(mnumnr,curiyr,wc,bf) = WCapMax(mnumnr,curiyr,wc,bf) + WCapMax(nr,curiyr,wc,bf)
               WCapInc(mnumnr,curiyr,wc,bf) = WCapInc(mnumnr,curiyr,wc,bf) + WCapInc(nr,curiyr,wc,bf)
               WCapAvl(mnumnr,curiyr,wc,bf) = WCapAvl(mnumnr,curiyr,wc,bf) + WCapAvl(nr,curiyr,wc,bf)
               WCapCum(mnumnr,curiyr,wc,bf) = WCapCum(mnumnr,curiyr,wc,bf) + WCapCum(nr,curiyr,wc,bf)
               ICapInc(mnumnr,curiyr,wc,bf) = ICapInc(mnumnr,curiyr,wc,bf) + ICapInc(nr,curiyr,wc,bf)
               ICapAvl(mnumnr,curiyr,wc,bf) = ICapAvl(mnumnr,curiyr,wc,bf) + ICapAvl(nr,curiyr,wc,bf)
               ICapCum(mnumnr,curiyr,wc,bf) = ICapCum(mnumnr,curiyr,wc,bf) + ICapCum(nr,curiyr,wc,bf)
            end do
         end do
      end do

      CapInstall_WL(mnumnr,curiyr) = 0.0
      CapAdded_WL(mnumnr,curiyr) = 0.0
      CapCommit_WL(mnumnr,curiyr) = 0.0
      CapNewBld_WL(mnumnr,curiyr) = 0.0
      CapPlnBld_WL(mnumnr,curiyr) = 0.0
      CapCmtTot_WL(mnumnr,curiyr) = 0.0
      CapIandC_WL(mnumnr,curiyr) = 0.0
      CapIncr_WL(mnumnr,curiyr) = 0.0
      CapCum_WL(mnumnr,curiyr) = 0.0
      WCapInc_WL(mnumnr,curiyr,:,:) = 0.0
      WCapCum_WL(mnumnr,curiyr,:,:) = 0.0
      ICapInc_WL(mnumnr,curiyr,:,:) = 0.0
      ICapCum_WL(mnumnr,curiyr,:,:) = 0.0
      do nr = 1 , mnumnr
         CapInstall_WL(mnumnr,curiyr) = CapInstall_WL(mnumnr,curiyr) + CapInstall_WL(nr,curiyr)
         CapAdded_WL(mnumnr,curiyr) = CapAdded_WL(mnumnr,curiyr) + CapAdded_WL(nr,curiyr)
         CapCommit_WL(mnumnr,curiyr) = CapCommit_WL(mnumnr,curiyr) + CapCommit_WL(nr,curiyr)
         CapNewBld_WL(mnumnr,curiyr) = CapNewBld_WL(mnumnr,curiyr) + CapNewBld_WL(nr,curiyr)
         CapPlnBld_WL(mnumnr,curiyr) = CapPlnBld_WL(mnumnr,curiyr) + CapPlnBld_WL(nr,curiyr)
         CapCmtTot_WL(mnumnr,curiyr) = CapCmtTot_WL(mnumnr,curiyr) + CapCmtTot_WL(nr,curiyr)
         CapIandC_WL(mnumnr,curiyr) = CapIandC_WL(mnumnr,curiyr) + CapIandC_WL(nr,curiyr)
         CapIncr_WL(mnumnr,curiyr) = CapIncr_WL(mnumnr,curiyr) + CapIncr_WL(nr,curiyr)
         CapCum_WL(mnumnr,curiyr) = CapCum_WL(mnumnr,curiyr) + CapCum_WL(nr,curiyr)
         do wc = 1 , mnumcl
            do bf = 1 , mnumbf
               WCapInc_WL(mnumnr,curiyr,wc,bf) = WCapInc_WL(mnumnr,curiyr,wc,bf) + WCapInc_WL(nr,curiyr,wc,bf)
               WCapCum_WL(mnumnr,curiyr,wc,bf) = WCapCum_WL(mnumnr,curiyr,wc,bf) + WCapCum_WL(nr,curiyr,wc,bf)
               ICapInc_WL(mnumnr,curiyr,wc,bf) = ICapInc_WL(mnumnr,curiyr,wc,bf) + ICapInc_WL(nr,curiyr,wc,bf)
               ICapCum_WL(mnumnr,curiyr,wc,bf) = ICapCum_WL(mnumnr,curiyr,wc,bf) + ICapCum_WL(nr,curiyr,wc,bf)
            end do
         end do
      end do

!     This is a new routine that does long - term elasticities within each wind class category.
!     It is done here because the results are used in the ranking of classes and zones.

      XSwitch = 1
      do nr = 1 , mnumnr
         do wc = 1,mnumcl

!           Sum over wind classes and then calculate the ratio of resource used to resource available.
!           XCapCum(nr,wc) = ICapCum(nr,curiyr,wc,1) + ICapCum(nr,curiyr,wc,2) + ICapCum(nr,curiyr,wc,mnumbf)

            XCapCum(nr,wc) = WCapCum_WL(nr,curiyr,wc,1) + WCapCum_WL(nr,curiyr,wc,2) + WCapCum_WL(nr,curiyr,wc,3)+WCapCum(nr,curiyr,wc,1) + WCapCum(nr,curiyr,wc,2) + WCapCum(nr,curiyr,wc,3)
            XCapMax(nr,wc) = WCapMax(nr,curiyr,wc,1) + WCapMax(nr,curiyr,wc,2) + WCapMax(nr,curiyr,wc,mnumbf)
            XRatio(nr,wc) = 0.0
            if (XCapMax(nr,wc) .ge. epsi) XRatio(nr,wc) = XCapCum(nr,wc) / XCapMax(nr,wc)

!           Look up the elasticity using a table of 5 levels, based upon the level of the ratio.

            XLTElas(nr,wc) = 1.0
            if (UTCSSW(WTech)  .gt.  1) then
               do lev = 1,MLPTMX
                  if (UTRSFC(nr,WTech,lev) .lt. XRatio(nr,wc)) then
                     XLTElas(nr,wc) = UTCSFC(nr,WTech,lev)
                  end if
               end do
            end if     !       utcssw gt 1   (i.e. no long term multipliers)



      !           Look up the elasticity using a table of 5 levels, based upon the level of the ratio.

                  XLTElas_WL(nr,wc) = 1.0
                  if (UTCSSW(WTech_WL)  .gt.  1) then
                     do lev = 1,MLPTMX
                        if (UTRSFC(nr,WTech_WL,lev) .lt. XRatio(nr,wc)) then
                           XLTElas_WL(nr,wc) = UTCSFC(nr,WTech_WL,lev)
                        end if
                     end do
                  end if     !       utcssw gt 1   (i.e. no long term multipliers)
         end do
      end do


      call WindRank3
      call WindRank3_WL

!     Start putting the supply curve together. Determine capacities and multipliers for each step.
!     Determine the total amount of capacity in the supply curve and for each of the three steps.

      SuppCapMin = 100.0

!     write( * , * )'SuppCapMin in WindMisc ',SuppCapMin
!     The overall supply curve capacity is the amount of existing capacity or the minimum of SuppCapMin.

      SuppCap = amax1((CapInstall(mnumnr,curiyr) + CapInstall_WL(mnumnr,curiyr)),SuppCapMin)

!     The capacity for each step is based upon input parameters if the short term elasticity is being
!     used. Otherwise the steps are evenly split within the total supply curve capacity.

      if (UTCSSW(WTech) .eq. 1 .or. UTCSSW(WTech) .eq. 3) then

!        The first step on the curve is the total times the value of USTTHR

         UTCACA(1) = SuppCap * USTTHR(WTech)


!        The remaining steps are evenly split within the total times the value of USTCAMX minus the first step.

         if (msptmx .gt. 1) then
            do stp = 2,msptmx
               UTCACA(stp) = (USTCAMX(WTech) * SuppCap - UTCACA(1)) / (msptmx - 1)
               UTCACA(stp) = amax1(UTCACA(stp),0.0)
            end do
         end if
      elseif (UTCSSW(WTech) .eq. 2) then

!        The steps are evenly split within the total supply curve capacity.
!        do stp = 1,msptmx
!           UTCACA(stp) = (USTCAMX(WTech) * SuppCap) / msptmx
!        end do
!        CRN - July 05, change capacity limit to match ECP short - term elast function.

         do stp = 1,ECP_D_SSTP

!           UTCACA(stp) = (ESTCPLIM(WIWN,stp) * suppcap * 0.001) / msptmx

            UTCACA(stp) = (ESTCPLIM(WIWN,stp)) / msptmx

!           UTCACA(stp) = 0

         end do
      end if

      if (UTCSSW(WTech_WL) .eq. 1 .or. UTCSSW(WTech_WL) .eq. 3) then

         UTCACA_WL(1) = SuppCap * USTTHR(WTech_WL)

         if (msptmx .gt. 1) then
            do stp = 2,msptmx
               UTCACA_WL(stp) = (USTCAMX(WTech_WL) * SuppCap - UTCACA_WL(1)) / (msptmx - 1)
               UTCACA_WL(stp) = amax1(UTCACA_WL(stp),0.0)
            end do
         end if
      elseif (UTCSSW(WTech_WL) .eq. 2) then

!        The steps are evenly split within the total supply curve capacity.
!        do stp = 1,msptmx
!           UTCACA_WL(stp) = (USTCAMX(WTech_WL) * SuppCap) / msptmx
!        end do
!        CRN - July 05, change capacity limit to match ECP short - term elast function.

         do stp = 1,ECP_D_SSTP

!           UTCACA_WL(stp) = (ESTCPLIM(WIWN,stp) * suppcap * 0.001) / msptmx

            UTCACA_WL(stp) = (ESTCPLIM(WIWL,stp)) / msptmx

!           UTCACA_WL(stp) = 0

         end do

      end if

!     Put the supply curve steps into a variable for the utility model

      do stp = 1,msptmx
         UTCAFN(WTech,stp) = UTCACA(stp)
      end do

      do stp = 1,msptmx
         UTCAFN(WTech_WL,stp) = UTCACA_WL(stp)
      end do

!     The short - term elasticities are evaluated based upon the midpoints of each step (cumulated), except
!     for the first step which is based on the full (threshold) amount of the step.

      Value = 0.0
      do stp = 1,msptmx
         UTCACS(stp) = Value + UTCACA(stp) / 2.0
         Value = Value + UTCACA(stp)
      end do
      UTCACS(1) = UTCACA(1)

       Value_WL = 0.0
            do stp = 1,msptmx
               UTCACS_WL(stp) = Value_WL + UTCACA_WL(stp) / 2.0
               Value_WL = Value_WL + UTCACA_WL(stp)
            end do
      UTCACS_WL(1) = UTCACA_WL(1)

!     Determine the short - term elasticities for each of the supply steps.

      do stp = 1,msptmx
         STElas(stp) = 0.0
         if (UTCSSW(WTech) .eq. 1 .or. UTCSSW(WTech) .eq. 3) then
            CapFrac = amax1(1.0,(UTCACS(stp) + SuppCap) / SuppCap)

!           If CapFrac is above a threshold level then calculate a short - term elasticity for this step.

            if ((CapFrac - 1.0) .le. USTTHR(WTech)) then
               STElas(stp) = 1.0
            else
               STElas(stp) = (CapFrac - USTTHR(WTech)) ** (alog(1.0 + USTICS(WTech)) / alog(1.0 + USTICA(WTech)))
            end if
         end if
      end do


      do stp = 1,msptmx
         STElas_WL(stp) = 0.0
         if (UTCSSW(WTech_WL) .eq. 1 .or. UTCSSW(WTech_WL) .eq. 3) then
            CapFrac = amax1(1.0,(UTCACS_WL(stp) + SuppCap) / SuppCap)

!           If CapFrac is above a threshold level then calculate a short - term elasticity for this step.

            if ((CapFrac - 1.0) .le. USTTHR(WTech_WL)) then
               STElas_WL(stp) = 1.0
            else
               STElas_WL(stp) = (CapFrac - USTTHR(WTech_WL)) ** (alog(1.0 + USTICS(WTech_WL)) / alog(1.0 + USTICA(WTech_WL)))
            end if
         end if
      end do

!     For reporting purposes, evaluate where supply curve steps fall in array of available
!     capacity by its ranking by region, wind classes, and buffer zones.

      do nr = 1 , mnumnr
         do n = 1,RNum
            wc = Rwc(nr,n,curiyr)
            bf = Rbf(nr,n,curiyr)
            IF (bf .eq. 0) THEN
               WRITE(6,2317) CURIRUN, CURIYR+1989, nr, n
 2317          FORMAT(1X,"RBF_OOPS",4(",",I5))
               Rbf(nr,n,curiyr) = 1
               bf = 1
            END IF
            IF (wc .eq. 0) THEN
               WRITE(6,3318) CURIRUN, CURIYR+1989, nr, n
 3318          FORMAT(1X,"RWC_OOPS",4(",",I5))
               Rwc(nr,n,curiyr) = 1
               WC = 1
            END IF
            SCapAvl(nr,wc,bf) = WCapAvl(nr,curiyr,wc,bf)
         end do
         do stp = 1,msptmx
            CapOut = UTCACA(stp)
            do n = 1,RNum
               wc = Rwc(nr,n,curiyr)
               bf = Rbf(nr,n,curiyr)
               SCapInc(stp,nr,wc,bf) = 0.0
               if (SCapAvl(nr,wc,bf) .gt. 0.0) then
                  if (SCapAvl(nr,wc,bf) .ge. CapOut) then
                     SCapInc(stp,nr,wc,bf) = CapOut
                     CapOut = 0.0
                     SCapAvl(nr,wc,bf) = SCapAvl(nr,wc,bf) - SCapInc(stp,nr,wc,bf)
                  else
                     SCapInc(stp,nr,wc,bf) = SCapAvl(nr,wc,bf)
                     CapOut = CapOut - SCapInc(stp,nr,wc,bf)
                     SCapAvl(nr,wc,bf) = 0.0
                  end if
               end if
            end do
         end do
      end do

      do nr = 1 , mnumnr
         do stp = 1,msptmx
            CapOut_WL = UTCACA_WL(stp)
            do n = 1 , RNum_WL
               wc = Rwc_WL(nr,n,curiyr)
               bf = Rbf_WL(nr,n,curiyr)
               IF (bf .eq. 0) THEN
                  WRITE(6,2318) CURIRUN, CURIYR+1989, nr, n
 2318             FORMAT(1X,"RBFWL_OOPS",4(",",I5))
                  Rbf_WL(nr,n,curiyr) = 1
                  bf = 1
               END IF
               SCapInc_WL(stp,nr,wc,bf) = 0.0
               if (SCapAvl(nr,wc,bf) .gt. 0.0) then
                  if (SCapAvl(nr,wc,bf) .ge. CapOut_WL) then
                     SCapInc_WL(stp,nr,wc,bf) = CapOut_WL
                     CapOut_WL = 0.0
                     SCapAvl(nr,wc,bf) = SCapAvl(nr,wc,bf) - SCapInc_WL(stp,nr,wc,bf)
                  else
                     SCapInc_WL(stp,nr,wc,bf) = SCapAvl(nr,wc,bf)
                     CapOut_WL = CapOut_WL - SCapInc_WL(stp,nr,wc,bf)
                     SCapAvl(nr,wc,bf) = 0.0
                  end if
               end if
            end do
         end do
      end do



!     Determine "best" wind class and buffer zone.  This is class and zone that is used for all the
!     current characteristics.  This has been modified so that it doesn't pick a class / zone with virtually
!     no capacity in it and set this up as the capacity constraint.  For this it picks a class / zone where
!     it has found at least a cumulative amount of 25 percent of the capacity increment in that region.
!     It then creates a weighted average LT cost, CC cost, Cap Fac and T&D Cost.

      do nr = 1 , mnumnr
         ConsTol(nr) = max(5.0,CapIncr(nr,curiyr) * PercentTOL)
         ConsNum(nr) = 0
         ConsCap(nr) = 0.0
         ConsLT(nr) = 0.0
         ConsCC(nr) = 0.0
         ConsCF(nr) = 0.0
         ConsTD(nr) = 0.0
         Done = 0

         do n = 1 , RNum
            wc = Rwc(nr,n,curiyr)
            bf = Rbf(nr,n,curiyr)
            if (Done .eq. 0) then
               if (WCapAvl(nr,curiyr,wc,bf) .gt. 0.0) then
                  ConsNum(nr) = ConsNum(nr) + 1
                  ConsCap(nr) = ConsCap(nr) + WCapAvl(nr,curiyr,wc,bf)
                  if (XSwitch .ne. 1) ConsLT(nr) = ConsLT(nr) + WCapAvl(nr,curiyr,wc,bf) * LTElas(nr)
                  if (XSwitch .eq. 1) ConsLT(nr) = ConsLT(nr) + WCapAvl(nr,curiyr,wc,bf) * XLTElas(nr,wc)
                  ConsCC(nr) = ConsCC(nr) + WCapAvl(nr,curiyr,wc,bf) * ICCMultR(nr,wc,curiyr)
                  ConsCF(nr) = ConsCF(nr) + WCapAvl(nr,curiyr,wc,bf) * CF(curiyr,wc)
                  ConsTD(nr) = ConsTD(nr) + WCapAvl(nr,curiyr,wc,bf) * WNTDBFCS(nr,bf)
                  WCurCl(nr,curiyr) = wc
                  WCurBf(nr,curiyr) = bf

                  WRITE(18,3520) CURIRUN, CURIYR+1989, CURITR, nr, n, 7-wc, 7-WCurCL(nr,curiyr), bf, WCurBF(nr,curiyr), Done, ConsNum(nr), XSwitch, &
                     ConsCap(nr), WCapAvl(nr,curiyr,wc,bf), ConsLT(nr), XLTElas(nr,wc), ConsCC(nr), ICCMultR(nr,wc,curiyr), ConsCF(nr), CF(curiyr,wc), ConsTD(nr), WNTDBFCS(nr,bf)
 3520             FORMAT(1X,"ConsCF",":WN",12(":",I4),10(":",F24.6))

               end if
               if (ConsCap(nr) .gt. ConsTol(nr) .or. n .eq. RNum) then
                  WCurCl(nr,curiyr) = wc
                  WCurBf(nr,curiyr) = bf
                  Done = 1
               end if
            end if
         end do
         if (ConsCap(nr) .gt. 0.0) then
            ConsLT(nr) = ConsLT(nr) / ConsCap(nr)
            ConsCC(nr) = ConsCC(nr) / ConsCap(nr)
            ConsCF(nr) = ConsCF(nr) / ConsCap(nr)
            ConsTD(nr) = ConsTD(nr) / ConsCap(nr)
         else
            if (XSwitch.ne.1) ConsLT(nr) = LTElas(nr)
            if (XSwitch .eq. 1) ConsLT(nr) = XLTElas(nr,3)
            ConsCC(nr) = ICCMultR(nr,mnumcl,curiyr)
            ConsCF(nr) = CF(curiyr,3)
            ConsTD(nr) = WNTDBFCS(nr,3)
         end if
      end do

      do nr = 1 , mnumnr
         ConsTol_WL(nr) = max(5.0,CapIncr(nr,curiyr) * PercentTOL)
         ConsNum_WL(nr) = 0
         ConsCap_WL(nr) = 0.0
         ConsLT_WL(nr) = 0.0
         ConsCC_WL(nr) = 0.0
         ConsCF_WL(nr) = 0.0
         ConsTD_WL(nr) = 0.0
         Done_WL = 0
         do n = 1,RNum_WL
            wc = Rwc_WL(nr,n,curiyr)
            bf = Rbf_WL(nr,n,curiyr)
            if (Done_WL .eq. 0) then
               if (WCapAvl(nr,curiyr,wc,bf) .gt. 0.0) then
                  ConsNum_WL(nr) = ConsNum_WL(nr) + 1
                  ConsCap_WL(nr) = ConsCap_WL(nr) + WCapAvl(nr,curiyr,wc,bf)
                  if (XSwitch.ne.1) ConsLT_WL(nr) = ConsLT_WL(nr) + WCapAvl(nr,curiyr,wc,bf) * LTElas(nr)
                  if (XSwitch .eq. 1) ConsLT_WL(nr) = ConsLT_WL(nr) + WCapAvl(nr,curiyr,wc,bf) * XLTElas(nr,wc)
                  ConsCC_WL(nr) = ConsCC_WL(nr) + WCapAvl(nr,curiyr,wc,bf) * ICCMultR_WL(nr,wc,curiyr)
                  ConsCF_WL(nr) = ConsCF_WL(nr) + WCapAvl(nr,curiyr,wc,bf) * CF_WL(curiyr,wc)
                  ConsTD_WL(nr) = ConsTD_WL(nr) + WCapAvl(nr,curiyr,wc,bf) * WNTDBFCS(nr,bf)
                  WCurCl_WL(nr,curiyr) = wc
                  WCurBf_WL(nr,curiyr) = bf

!                  WRITE(18,3521) CURIRUN, CURIYR+1989, CURITR, nr, n, 7-wc, 7-WCurCL_WL(nr,curiyr), bf, WCurBF_WL(nr,curiyr), Done_WL, ConsNum_WL(nr), XSwitch, &
!                     ConsCap_WL(nr), WCapAvl(nr,curiyr,wc,bf), ConsLT_WL(nr), XLTElas(nr,wc), ConsCC_WL(nr), ICCMultR_WL(nr,wc,curiyr), ConsCF_WL(nr), CF_WL(curiyr,wc), ConsTD_WL(nr), WNTDBFCS(nr,bf)
 3521             FORMAT(1X,"ConsCF",":WL",12(":",I4),10(":",F24.6))

               end if
               if (ConsCap_WL(nr) .gt. ConsTol_WL(nr) .or. n .eq. RNum) then
                  WCurCl_WL(nr,curiyr) = wc
                  WCurBf_WL(nr,curiyr) = bf
                  Done_WL = 1
               end if
            end if
         end do
         if (ConsCap_WL(nr) .gt. 0.0) then
            ConsLT_WL(nr) = ConsLT_WL(nr) / ConsCap_WL(nr)
            ConsCC_WL(nr) = ConsCC_WL(nr) / ConsCap_WL(nr)
            ConsCF_WL(nr) = ConsCF_WL(nr) / ConsCap_WL(nr)
            ConsTD_WL(nr) = ConsTD_WL(nr) / ConsCap_WL(nr)
         else
            if (XSwitch.ne.1) ConsLT_WL(nr) = LTElas(nr)
            if (XSwitch .eq. 1) ConsLT_WL(nr) = XLTElas(nr,3)
            ConsCC_WL(nr) = ICCMultR_WL(nr,mnumcl,curiyr)
            ConsCF_WL(nr) = CF_WL(curiyr,3)
            ConsTD_WL(nr) = WNTDBFCS(nr,3)
         end if
      end do

!     Fill in the total maximum capacity over all categories and the existing (chosen) capacity in each region.

      do nr = 1 , mnumnr

!        For some reason the previous model filled in UTRSMX only until year 8.

         if (curiyr .le. 8) THEN
            UTRSMX(nr,WTech) = CapOrig(nr,curiyr)
            UTRSMX(nr,WTech_WL) = CapOrig(nr,curiyr)
         END IF
         UTRSCU(nr,WTech) = CapInstall(nr,curiyr)
         UTRSCU(nr,WTech_WL) = CapInstall_WL(nr,curiyr)
      end do

!     Determine the long - term elasticities for the supply curve.
!     Note, this is only used if we are doing the origninal long - term elasticities over all wind classes and zones.

      do nr = 1 , mnumnr

!        Calculate the ratio of resource used to resource available - i.e., point on long term supply curve.

         Ratio = 0.0
         if (UTRSMX(nr,WTech) .ge. epsi) Ratio = (UTRSCU(nr,WTech) + UTRSCU(nr,WTech_WL)) / UTRSMX(nr,WTech)

!        Look up the elasticity using a table of 5 levels, based upon the level of the ratio.

         LTElas(nr) = 1.0
         do lev = 1,MLPTMX
            if (UTRSFC(nr,WTech,lev) .lt. Ratio) then
               LTElas(nr) = UTCSFC(nr,WTech,lev)
            end if
            if (UTRSFC(nr,WTech_WL,lev) .lt. Ratio) then
               LTElas_WL(nr) = UTCSFC(nr,WTech_WL,lev)
            end if
         end do
      end do

!     Combine as necessary and put the elasticities into the array used by the Utility Model

      do nr = 1 , mnumnr
         ZLTElas = ConsLT(nr)
         do stp = 1,msptmx

!           for aeo04, STELas is not being used

            if (UTCSSW(WTech) .eq. 2   .or.  UTCSSW(WTech) .eq. 3) then
               UTCSFN(nr,WTech,stp) = ZLTElas - 1.0
            else
               UTCSFN(nr,WTech,stp) = 0.0
            endif
!            Write(6,*)'WN utcsfn 1 ',nr,Wtech,stp,UTCSFN(nr,Wtech,stp)

            UTCSFN(nr,WTech,stp) = UTCSFN(nr,WTech,stp) * ConsCC(nr)
!            Write(6,*)'WN utcsfn 2 ',nr,Wtech,stp,UTCSFN(nr,Wtech,stp),ConsCC(nr)
         end do
      end do

      do nr = 1 , mnumnr
         ZLTElas = ConsLT_WL(nr)
         do stp = 1,msptmx

            if (UTCSSW(WTech_WL) .eq. 2   .or.  UTCSSW(WTech_WL) .eq. 3) then
               UTCSFN(nr,WTech_WL,stp) = ZLTElas - 1.0
            else
               UTCSFN(nr,WTech_WL,stp) = 0.0
            endif

            UTCSFN(nr,WTech_WL,stp) = UTCSFN(nr,WTech_WL,stp) * ConsCC_WL(nr)
         end do
      end do

!     Fill in some variables for the utility model (?)
!     WCAWIEL is the amount of available capacity in the "best" wind class and "best" buffer zone.

      do nr = 1 , mnumnr
         WCAWIEL(nr,curiyr) = ConsCap(nr)
         WOLDCN(nr,WTech) = WCAWIEL(nr,curiyr)

!        In the previous model it had been filled in for all years, maybe this is not necessary...

         do yr = curiyr + 1,MNUMYR
            WCAWIEL(nr,yr) = WCAWIEL(nr,curiyr)
         end do
      end do

      do nr = 1 , mnumnr
         WCAWLEL(nr,curiyr) = ConsCap_WL(nr)
         WOLDCN(nr,WTech_WL) = WCAWLEL(nr,curiyr)

!        In the previous model it had been filled in for all years, maybe this is not necessary...

         do yr = curiyr + 1,MNUMYR
            WCAWLEL(nr,yr) = WCAWLEL(nr,curiyr)
         end do
      end do

!     WSFWIEL has the capacity factors for each time slice for the "best" wind class category.

!     calculate wind capacity factors for each of 864 hrs

      do nr = 1 ,UNRGNS  !  maxnrg !mnumnr

!         WRITE(18,2515) CURIRUN, CURIYR+1989, CURITR, nr, ConsCF(nr), WindInputCF(nr,curiyr), ConsCF_WL(nr), WindInputCF_WL(nr,curiyr)
         WRITE(18,2515) CURIRUN, CURIYR+1989, CURITR, nr, ConsCF(nr), WindInputCF(nr,curiyr)
! 2515    FORMAT(1X,"RENEW_CONS_CF",4(":",I5),4(":",F21.6))
 2515    FORMAT(1X,"RENEW_CONS_CF",4(":",I5),2(":",F21.6))

         do m = 1,12
            do d = 1,3
               do h = 1,24
!                   Write(6,1043)'debug WSFWIEL_CFb4', nr,curiyr,d,m,h,WSFWIEL_CF(nr,curiyr,d,m,h) ,ConsCF(nr), WindInputCF(nr,curiyr)
                  WSFWIEL_CF(nr,curiyr,d,m,h) = WSFWIEL_CF(nr,curiyr,d,m,h) * ConsCF(nr) / WindInputCF(nr,curiyr)
!                  Write(6,1043)'debug WSFWIEL_CFaf', nr,curiyr,d,m,h,WSFWIEL_CF(nr,curiyr,d,m,h) ,ConsCF(nr), WindInputCF(nr,curiyr)
1043 Format(A30,1x,5(I4,1x),3(F8.3,1x))

                  WSFWLEL_CF(nr,curiyr,d,m,h) = WSFWLEL_CF(nr,curiyr,d,m,h) * ConsCF_WL(nr) / WindInputCF_WL(nr,curiyr)

!                 START of the wind curtailment algorithm
!                 Fixed Aug, 2011 to be consistent with the 864 hr approach to the load duration curve
!                 do nr = 1 , 22 !mnumnr-3 !MAXNRG !maxnrg=mnumnr-3, so presumably it doesn't include AK, HI, or US
!                 do s = 1,mnumwi

                  s=hrtoecpgrp(m,d,h) !this maps current slice to time period under consideration
                  wc = WCurCl(nr,curiyr)


!                 For debugging purposes, JDoCFB = 0 don't do this, JDoCFB = 1 do this.

                  JDoCFB = 0
                  if (JDoCFB .eq. 1) then

!                    New section by CRN (2 / 03) that backs off the capacity factor for overproduction.
!                    Note that capacity factors are transferred to ECP via the first wind class.
!                    Many of the variables used in this routine include:
!                    BaseLdCap - Capacity of thermal plants likely to be used as baseloaders.
!                    TurnDown - Minimum percent of nameplate at which plant can be run (an input).
!                    IntStddv(nerc,IntTech) - Standard deviation of a single wind site (an input).
!                    WnRegStd - Standard deviation of all wind sites in the region.
!                    IntRegCrl(nerc,IntTech) - Correlation coefficient for all wind sites in the region (an input).
!                    WindProb - Probability of excess wind production.
!                    AllowWindCap - Wind capacity that can operate before curtailment.
!                    ExcessWn - total kWh of excess (curtailed) wind.
!                    FullWn - Adjusted average wind available in the load slice (energy).
!                    AveWnCap - Average wind capacity available in the load slice.
!                    WnPlant - Size of the wind plant (use UPMSSIZ from ENTCNTL).
!                    NWn - Number of wind plants in a region.
!                    BaseCF - Fundamental wind capacity factor for region / slice, without curtailment.
!                    InstWind - Installed wind capacity (GW).
!                    CoalAvail - Average coal plant total availability.
!                    NucAvail - Average nuclear plant total availability.
!                    NumC - Number of coal plant types.
!                    First, determine the "baseload" installed capacity.
!                    (Should de - rate by maximum CF to get planned outages, probably in ECPDAT.)

                     BaseLdCap = UCAPCSN(nr,curiyr) + UCAPCSU(nr,curiyr) + UCAPIGN(nr,curiyr) + UCAPIGU(nr,curiyr) + UCAPISN(nr,curiyr) + UCAPISU(nr,curiyr)

!                    Calculate the standard deviation for all the wind sites in the region.

                     InstWind = UCAPWNR(nr,curiyr) * 0.001
                     InstWind_WL = UCAPWLR(nr,curiyr) * 0.001
                     NWn = InstWind / (UPMSSIZ(WIWN) / 1000.0)  !       Need to find a parameter for ECP wind index.
                     NWn_WL = InstWind_WL / (UPMSSIZ(WIWL) / 1000.0)  !       Need to find a parameter for ECP wind index.

                     if (NWn .lt. 1) NWn = 1

                     if (InstWind .gt. 0.0) then
                        WnRegStd = Sqrt((NWn + 2.0 * IntRegCrl(nr,UCPINTIS(WIWN)) * ((NWn ** 2.0 - NWn) / 2.0)) * (IntStddv(nr,UCPINTIS(WIWN)) * UPMSSIZ(WIWN) / 1000.0) ** 2.0)
                     else
                        WnRegStd = IntStddv(nr,UCPINTIS(WIWN))
                     endif

                     if (InstWind_WL .gt. 0.0) then
                        WnRegStd_WL = Sqrt((NWn_WL + 2.0 * IntRegCrl_WL(nr,UCPINTIS(WIWL)) * ((NWn_WL ** 2.0 - NWn_WL) / 2.0)) * (IntStddv_WL(nr,UCPINTIS(WIWL)) * UPMSSIZ(WIWL) / 1000.0) ** 2.0)
                     else
                        WnRegStd_WL = IntStddv_WL(nr,UCPINTIS(WIWL))
                     endif




!                    Determine the amount of allowable wind in the current load slice.
!                    Use UPTTYP(ECP_D_CAP) = NW_Coal or EX_Coal to ID coal plants.

                     CoalAvail = 0.0

!                    XCoalAvail = 0.0 !       This was not in the original code - should it be here?
!                    NCoalAvail = 0.0 !       This was not in the original code - should it be here?

                     Numxc = 0
                     Numnc = 0
                     do t = 1,ECP_D_CAP
                        if (UPTTYP(t) .le. EX_Coal) then
                           XCoalAvail = XCoalAvail + (UPPMRT(t) + UPFORT(t))
                           Numxc = Numxc + 1
                        elseif (UPTTYP(t) .le. NW_Coal) then
                           NCoalAvail = NCoalAvail + (UPPMRT(t) + UPFORT(t))
                           Numnc = Numnc + 1
                        endif
                     end do
                     XCoalAvail = XCoalAvail / Numxc
                     NCoalAvail = NCoalAvail / Numnc
                     if (BaseLdCap .gt. 0.0) then
                        CoalAvail = (XCoalAvail * (UCAPCSN(nr,curiyr) + UCAPCSU(nr,curiyr)) + &
                        NCoalAvail * (UCAPIGN(nr,curiyr) + UCAPIGU(nr,curiyr) + UCAPISN(nr,curiyr) + UCAPISU(nr,curiyr))) / BaseLdCap
                     else
                        CoalAvail = 0.0
                     endif
                     CoalAvail = 1.0 - CoalAvail
                     NucAvail = 1.0 - (((UPPMRT(WICN) + UPPMRT(WIAN)+ UPPMRT(WISM)) / 3.0) + ((UPFORT(WICN) + UPFORT(WIAN)+ UPFORT(WISM)) / 3.0))
                     AllowWnCap = ECPLDCBH(curiyr,nr,s) - NucAvail * NTurnDown(nr) * (UCAPNUN(nr,curiyr) + UCAPNUU(nr,curiyr)) - &
                        CoalAvail * CTurnDown(nr) * BaseLdCap

                     BaseCF = WSFWIEL_CF(nr,curiyr,d,m,h) !need to make sure this doesn't compound
                     AveWnCap = BaseCF * InstWind

                     BaseCF_WL = WSFWLEL_CF(nr,curiyr,d,m,h) !need to make sure this doesn't compound
                     AveWnCap_WL = BaseCF_WL * InstWind_WL

                     if (ECPLDCBH(curiyr,nr,s) .le. 0) then
                        WnProb = 0.0
                        WnProb_WL = 0.0
                     else
                        WnProb = (1.0 / Sqrt(2.0 * 3.141593 * WnRegStd)) * exp( - ((AllowWnCap - AveWnCap) ** 2.0) / (2.0 * WnRegStd ** 2.0))
                        WnProb_WL = (1.0 / Sqrt(2.0 * 3.141593 * WnRegStd_WL)) * exp( - ((AllowWnCap_WL - AveWnCap_WL) ** 2.0) / (2.0 * WnRegStd_WL ** 2.0))
                     endif

!                    Subtract out the excess energy from the time - slice capacity factor.

                     ExcessWn = WnProb * InstWind * ECPLDCBW(curiyr,nr,s) * 8760.0
                     FullWn = (AveWnCap * ECPLDCBW(curiyr,nr,s) * 8760.0) - ExcessWn
                     ExcessWn = WnProb * InstWind
                     FullWn = AveWnCap - ExcessWn
                     if (InstWind.le.0) then
                        WSFWIEL_CF(nr,curiyr,d,m,h) = BaseCF
                     else
                        WSFWIEL_CF(nr,curiyr,d,m,h)= FullWn/Instwind
                     endif

                     ExcessWn_WL = WnProb_WL * InstWind_WL * ECPLDCBW(curiyr,nr,s) * 8760.0
                     FullWn_WL = (AveWnCap_WL * ECPLDCBW(curiyr,nr,s) * 8760.0) - ExcessWn_WL
                     ExcessWn_WL = WnProb_WL * InstWind_WL
                     FullWn_WL = AveWnCap_WL - ExcessWn_WL
                     if (InstWind_WL.le.0) then
                        WSFWLEL_CF(nr,curiyr,d,m,h) = BaseCF_WL
                     else
                        WSFWLEL_CF(nr,curiyr,d,m,h)= FullWn_WL/Instwind_WL
                     endif
                  endif

!                 END of the wind curtailment algorithm
!                 if (curiyr .eq. 6 .and. nr .eq. 1) then
!                    write( * ,'(a,5i5,4f12.4)')'WI - COMPARE WSFWIEL,y,r,m,d,h,1st,2nd,ccf,wiCF: ',  &
!                       curiyr,nr,m,d,h,WSFWIEL_CF(nr,curiyr,d,m,h) * ConsCF(nr) / WindInputCF(nr,curiyr), &
!                       WSFWIEL_CF(nr,curiyr,d,m,h),ConsCF(nr),WindInputCF(nr,curiyr)
!                 endif

               enddo
            enddo
         enddo
      enddo

!     WWNTD is the level of T&D costs for the "best" buffer zone.

      do nr = 1 , mnumnr
         WWNTD(nr,curiyr) = ConsTD(nr)
         WWLTD(nr,curiyr) = ConsTD_WL(nr)

!        In the previous model it had been filled in for all years, maybe this is not necessary...

         do yr = curiyr + 1,MNUMYR
            WWNTD(nr,yr) = WWNTD(nr,curiyr)
            WWLTD(nr,yr) = WWLTD(nr,curiyr)
         end do

      end do



      return
      end



!******************************************************************
!     Subroutine WindRank3 determines the costs for each wind category and then ranks the categories
!     according to some criteria - typically lowest to highest cost.

      subroutine WindRank3

      implicit none
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'ecpcntl'
      include 'control'
      include 'wrenew'
      include 'wwind'
      include 'wrenio'
      include 'bildout'
      include 'entcntl'
      include 'enewtech'
      include 'bildin'
      include 'uefdout'
!
      INTEGER*4 RCAP
      INTEGER*4 GSYR1
      INTEGER*4 GSYRL
      INTEGER*4 ICAP
      INTEGER*4 IFPH2
      INTEGER*4 IP
      INTEGER*4 IS
      INTEGER*4 JYR
      INTEGER*4 OLYR
      INTEGER*4 YEAR
!
      REAL*4 CPR(ECP_D_LCP)
      REAL*4 EWGINT
      REAL*4 EWGROE
      REAL*4 EWGROR
!
      REAL*8 CAPLEV
      REAL*8 CAPNNSTL
      REAL*8 CAPNUG
      REAL*8 CRF
      REAL*8 FNBOOK
      REAL*8 ITCADJ
      REAL*8 OVRCST
      REAL*8 PRATIO
      REAL*8 PVGNP
      REAL*8 PWF
      REAL*8 TXBOOK
!
      integer nr,wc,bf,t,ECPWind,RankVer,Used(mnumcl,mnumbf),w,b,n
      real XCost

!     Get the index for wind in ECP.

      do t=1,ECP_D_CAP
         if (UPLNTCD(t).eq.'WN') ECPWind=t
      end do

!     Get costs for wind from the utility model.
!     Compute CapCost in regional loop now

      if (ECP_D_OVFX(ECPWind).eq.0) then
         OMFCost=UPFOM(ECPWind)
      else
         OMFCost=UPOVFX(ECPWind,curiyr)
      end if
      if (ECP_D_OVVR(ECPWind).eq.0) then
         OMVCost=UPVOM(ECPWind)
      else
         OMVCost=UPOVVR(ECPWind,curiyr)
      end if
!
      do nr=1,unrgns
         call GETBLD(1,nr)
         YEAR = 1
         IS = 1
         ICAP = ECPWind
         IP = UCPINTIS(ICAP)
         RCAP = UIRINTI(IP)
         OLYR = YEAR + UPPLYR(ICAP)
         GSYR1 = UPGSY1(ICAP) - UHBSYR
         GSYRL = UPGSYL(ICAP) - UHBSYR
         IFPH2 = UNFPH - OLYR + 1
         IF (EPDSCRT .LT. 0.09) EPDSCRT = 0.09
         IF (EPCCSUP(RCAP,IS) .LT. 0.09) EPCCSUP(RCAP,IS) = 0.09
         DO JYR = 1, ECP_D_LCP
            CPR(JYR) = UPCPRO(ICAP,JYR)
         END DO
         EWGROE = EPUCRE + UPNRPRM
         EWGINT = EPUIRT + UPNIPRM
         EWGROR = EWGROE * (1.0 - UPNFDT) + EWGINT * UPNFDT
         IF (UPGSUB(ICAP) .GT. 0.0 .AND. (CURIYR + OLYR - 1) .GE. GSYR1 .AND. (CURIYR + OLYR - 1) .LE. GSYRL) THEN
            ITCADJ = 1.0 - UPCSB(ICAP)
         ELSE
            ITCADJ = 1.0
         ENDIF
         OVRCST = (EPIROVR(RCAP)/ITCADJ) * UPLRPC(ICAP) * UPLROPT(ICAP) * UPLRLC(ICAP) * EPRGM(ICAP) * EPACM(ICAP) * EPCCSUP(RCAP,IS) * UPANNADJ(ICAP,CURIYR)
         CALL EPINCST(MNUMYR,ECP_D_XPH,ECP_D_FPH,ECP_D_LCP,UPCLYR(ICAP),UPPLYR(ICAP),CURIYR,YEAR,OVRCST,CPR,UPCAPD(1,ICAP),UPGNPD,EWGINT,UPNFDT,EWGROR,TXBOOK,FNBOOK)
         PRATIO = TXBOOK / FNBOOK
         CAPNNSTL = FNBOOK
         CALL EPCNBLD(DBLE(UPNFDT),PRATIO,DBLE(UPNRPRM),DBLE(UPNIPRM),DBLE(EPUCRE),DBLE(EPUIRT),DBLE(UPTXRT),UPTXLF(ICAP),UPNCLF(ICAP),UPNLLF(ICAP),CAPNUG)
         CALL EP$LGNP(OLYR,IFPH2,EPDSCRT,PVGNP)
         CAPLEV = (( CAPNNSTL * CAPNUG ) / CRF(DBLE(EPDSCRT - UPRSK(ICAP)),IFPH2) ) * PWF(DBLE(EPDSCRT - UPRSK(ICAP)),OLYR)
         CAPLEV = CAPLEV / PVGNP
         FixChg = CAPLEV / OVRCST
         if ( isnan(FixChg) ) then
            FixChg = 0.13

            WRITE(18,3333) CURIYR, CURITR, nr, ECP_D_FPH, ECP_D_LCP, ECP_D_XPH, ECPWind, GSYR1, GSYRL, ICAP, IFPH2, IP, IS, MNUMYR, OLYR, RCAP, UCPINTIS(ICAP), &
               UIRINTI(IP), UHBSYR, UNFPH, UPCLYR(ICAP), UPGSY1(ICAP), UPGSYL(ICAP), UPNCLF(ICAP), UPNLLF(ICAP), UPPLYR(ICAP), UPTXLF(ICAP), YEAR
 3333       FORMAT(1X,"EPLVFCF0:WN",28(":",I4))

            WRITE(18,3334) CURIYR, CURITR, nr, CAPLEV, CAPNNSTL, CAPNUG, EPACM(ICAP), EPCCSUP(RCAP,IS), EPDSCRT, EPIROVR(RCAP), &
               EPLVFCF(ICAP,2), EPRGM(ICAP), EPUCRE, EPUIRT, EWGINT, EWGROE, EWGROR, FNBOOK, ITCADJ, OVRCST, PRATIO, PVGNP, TXBOOK, UPCAPD(1,ICAP), &
               UPCSB(ICAP), UPGSUB(ICAP), UPLRLC(ICAP), UPLROPT(ICAP), UPLRPC(ICAP), UPNFDT, UPNIPRM, UPNRPRM, UPRSK(ICAP), UPTXRT,UPANNADJ(ICAP,CURIYR)
 3334       FORMAT(1X,"EPLVFCF1:WN",3(":",I4),36(":",E10.3))

            WRITE(18,3335) CURIYR, CURITR, nr, (UPCPRO(ICAP,JYR),JYR= 1, ECP_D_LCP)
 3335       FORMAT(1X,"EPLVFCF2:WN",3(":",I4),35(":",E10.3))

            WRITE(18,3336) CURIYR, CURITR, nr, (UPGNPD(JYR),JYR=1,MNUMYR)
 3336       FORMAT(1X,"EPLVFCF3:WN",3(":",I4),<MNUMYR>(":",E10.3))

         else

            WRITE(18,4334) CURIYR,CURITR,NR,FixChg,EPLVFCF(ICAP,2)
 4334       FORMAT(1X,"EPLVFCF4:WN",3(":",I4),2(":",E10.3))
         endif

         if (ECP_D_OVCC(ECPWind).eq.0) then
      CapCostR(nr) = UPOVR(ECPWind) * UPLRPC(ECPWind) * UPLROPT(ECPWind) *  &
                     UPLRLC(ECPWind) * EPRGM(ECPWind) * EPACM(ECPWind) * UPANNADJ(ICAP,CURIYR)
   else
      CapCostR(nr) = UPOVCC(ECPWind,curiyr) * UPLRPC(ECPWind) * UPLROPT(ECPWind) *  &
                     UPLRLC(ECPWind) * EPRGM(ECPWind) * EPACM(ECPWind) * UPANNADJ(ECPWind,CURIYR)
   endif

!  Use the input incremental capital cost multiplier to get capital costs by wind class.
   if(ICCMeth(curiyr).eq.1) then
     do wc=1,mnumcl
      ICCCostR(nr,wc,curiyr)=CapCostR(nr)*ICCMultR(nr,wc,curiyr)
     end do
   else
     do wc=1,mnumcl
      ICCMultR(nr,wc,curiyr)=ICCCostR(nr,wc,curiyr)/CapCostR(nr)
     end do
   end if
         do wc=1,mnumcl
!               Write(*,1032)'WN ICCMULTR inside windrank3 ',nr,wc,curiyr,ICCMultR(nr,wc,curiyr),ICCCostR(nr,wc,curiyr),CapCostR(nr)
         end do
1032  Format(A35,1x,3(I4,1x),3(F12.3))

!        Determine the annualized cost per kwh by region, year, wind class, and buffer zone.

         do wc=1,mnumcl
            do bf=1,mnumbf

!              If XSwitch is not 0 then use the long-term multiplier by wind class in the capital cost.

               if (XSwitch.eq.0) then
                  AnnCost(nr,curiyr,wc,bf)=(ICCCostR(nr,wc,curiyr)*FixChg+OMFCost+ WNTDBFCS(nr,bf)*FixChg)/(CF(curiyr,wc)*8760.0)+OMVCost/1000

                 WRITE(18,2003) CURIYR+1989,CURITR,nr,wc,bf, AnnCost(nr,curiyr,wc,bf), ICCCostR(nr,wc,curiyr), FixChg, OMFCost,  &
                    WNTDBFCS(nr,bf), CF(curiyr,wc), OMVCost

 2003             format(1X,"AnnCost:WN:0",5(":",I5),7(":",F15.6))
               else
                  AnnCost(nr,curiyr,wc,bf)=(ICCCostR(nr,wc,curiyr)*XLTElas(nr,wc)* FixChg+OMFCost+WNTDBFCS(nr,bf)*FixChg)/(CF(curiyr,wc)*8760.0)+OMVCost/1000

                 WRITE(18,2004) CURIYR+1989,CURITR,nr,wc,bf, AnnCost(nr,curiyr,wc,bf), ICCCostR(nr,wc,curiyr), XLTElas(nr,wc),  &
                    FixChg, OMFCost, WNTDBFCS(nr,bf), CF(curiyr,wc), OMVCost

 2004             format(1X,"AnnCost:WN:1",5(":",I5),8(":",F15.6))
               end if
            end do
         end do
      end do      !region loop

!     Choose the manner of ranking: 1=original, 2=by cost (note, that in the base they are the same)

      RankVer=2

      if (RankVer.eq.1) then

!        Rank the categories according to some criteria - probably lowest to highest cost.
!        For now, they are simply ranked in wind class, buffer zone order, as in the original model.

         do nr=1,mnumnr
            RNum=0
            do wc=1,mnumcl
               do bf=1,mnumbf
                  RNum=RNum+1
                  Rwc(nr,RNum,curiyr)=wc
                  Rbf(nr,RNum,curiyr)=bf
               end do
            end do
         end do
      elseif (RankVer.eq.2) then
         RNum= mnumcl * mnumbf
         do nr=1,mnumnr
            n=0
            do wc=1,mnumcl
               do bf=1,mnumbf
                  n=n+1
                  Used(wc,bf)=0
                  Rwc(nr,n,curiyr)=0
                  Rbf(nr,n,curiyr)=0
               end do
            end do
            n=0
            do wc=1,mnumcl
               do bf=1,mnumbf
                  n=n+1
                  XCost=999999.9
                  do w=1,mnumcl
                     do b=1,mnumbf
                        if (Used(w,b).eq.0.and.AnnCost(nr,curiyr,w,b).lt.XCost) then

                           WRITE(18,4817) CURIRUN, CURIYR+1989, nr, n, wc, w, bf, b, XCOST, AnnCost(nr,curiyr,w,b)
 4817                      FORMAT(1X,"Renew_windrank3:WN",8(":",I5),2(":",F21.6))

                           XCost=AnnCost(nr,curiyr,w,b)
                           Rwc(nr,n,curiyr)=w
                           Rbf(nr,n,curiyr)=b
                           Rank(nr,w,b)=n
                        end if
                     end do
                  end do
                  If (Rwc(nr,n,curiyr) .gt. 0 .and. Rbf(nr,n,curiyr) .gt. 0) then
                     Used(Rwc(nr,n,curiyr),Rbf(nr,n,curiyr))=1
                  else
                     do w=1,mnumcl
                        do b=1,mnumbf

                           WRITE(6,1003) curcalyr,nr,n,w,b,AnnCost(nr,curiyr,w,b)
 1003                      format(1X,"Oops_used",5(":",I4),":",F20.6)

                        end do
                     end do
                  end if
               end do
            end do
         end do
      end if

      return
      end

!******************************************************************
!     Subroutine WindRank3_WL determines the costs for each low speed wind category and then ranks
!     the categories according to some criteria - typically lowest to highest cost.

      subroutine WindRank3_WL

      implicit none
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'ecpcntl'
      include 'control'
      include 'wrenew'
      include 'wwind'
      include 'wrenio'
      include 'bildout'
      include 'entcntl'
      include 'enewtech'
      include 'bildin'
      include 'uefdout'
!
      INTEGER*4 RCAP
      INTEGER*4 GSYR1
      INTEGER*4 GSYRL
      INTEGER*4 ICAP
      INTEGER*4 IFPH2
      INTEGER*4 IP
      INTEGER*4 IS
      INTEGER*4 JYR
      INTEGER*4 OLYR
      INTEGER*4 YEAR
!
      REAL*4 CPR(ECP_D_LCP)
      REAL*4 EWGINT
      REAL*4 EWGROE
      REAL*4 EWGROR
!
      REAL*8 CAPLEV
      REAL*8 CAPNNSTL
      REAL*8 CAPNUG
      REAL*8 CRF
      REAL*8 FNBOOK
      REAL*8 ITCADJ
      REAL*8 OVRCST
      REAL*8 PRATIO
      REAL*8 PVGNP
      REAL*8 PWF
      REAL*8 TXBOOK
!
      integer nr,wc,bf,t,ECPWind,RankVer,Used(mnumcl,mnumbf),w,b,n
      real XCost

!     Get the index for wind in ECP.

      do t=1,ECP_D_CAP
         if (UPLNTCD(t).eq.'WL') ECPWind=t
      end do

!     Get costs for wind from the utility model.
!     Compute CapCost in regional loop now

      if (ECP_D_OVFX(ECPWind).eq.0) then
         OMFCost_WL=UPFOM(ECPWind)
      else
         OMFCost_WL=UPOVFX(ECPWind,curiyr)
      end if
      if (ECP_D_OVVR(ECPWind).eq.0) then
         OMVCost_WL=UPVOM(ECPWind)
      else
         OMVCost_WL=UPOVVR(ECPWind,curiyr)
      end if
!
      do nr=1,unrgns
         call GETBLD(1,nr)
         YEAR = 1
         IS = 1
         ICAP = ECPWind
         IP = UCPINTIS(ICAP)
         RCAP = UIRINTI(IP)
         OLYR = YEAR + UPPLYR(ICAP)
         GSYR1 = UPGSY1(ICAP) - UHBSYR
         GSYRL = UPGSYL(ICAP) - UHBSYR
         IFPH2 = UNFPH - OLYR + 1
         IF (EPDSCRT .LT. 0.09) EPDSCRT = 0.09
         IF (EPCCSUP(RCAP,IS) .LT. 0.09) EPCCSUP(RCAP,IS) = 0.09
         DO JYR = 1, ECP_D_LCP
            CPR(JYR) = UPCPRO(ICAP,JYR)
         END DO
         EWGROE = EPUCRE + UPNRPRM
         EWGINT = EPUIRT + UPNIPRM
         EWGROR = EWGROE * (1.0 - UPNFDT) + EWGINT * UPNFDT
         IF (UPGSUB(ICAP) .GT. 0.0 .AND. (CURIYR + OLYR - 1) .GE. GSYR1 .AND. (CURIYR + OLYR - 1) .LE. GSYRL) THEN
            ITCADJ = 1.0 - UPCSB(ICAP)
         ELSE
            ITCADJ = 1.0
         ENDIF
         OVRCST = (EPIROVR(RCAP)/ITCADJ) * UPLRPC(ICAP) * UPLROPT(ICAP) * UPLRLC(ICAP) * EPRGM(ICAP) * EPACM(ICAP) * EPCCSUP(RCAP,IS) * UPANNADJ(ICAP,CURIYR)
         CALL EPINCST(MNUMYR,ECP_D_XPH,ECP_D_FPH,ECP_D_LCP,UPCLYR(ICAP),UPPLYR(ICAP),CURIYR,YEAR,OVRCST,CPR,UPCAPD(1,ICAP),UPGNPD,EWGINT,UPNFDT,EWGROR,TXBOOK,FNBOOK)
         PRATIO = TXBOOK / FNBOOK
         CAPNNSTL = FNBOOK
         CALL EPCNBLD(DBLE(UPNFDT),PRATIO,DBLE(UPNRPRM),DBLE(UPNIPRM),DBLE(EPUCRE),DBLE(EPUIRT),DBLE(UPTXRT),UPTXLF(ICAP),UPNCLF(ICAP),UPNLLF(ICAP),CAPNUG)
         CALL EP$LGNP(OLYR,IFPH2,EPDSCRT,PVGNP)
         CAPLEV = (( CAPNNSTL * CAPNUG ) / CRF(DBLE(EPDSCRT - UPRSK(ICAP)),IFPH2) ) * PWF(DBLE(EPDSCRT - UPRSK(ICAP)),OLYR)
         CAPLEV = CAPLEV / PVGNP
         FixChg = CAPLEV / OVRCST
         if ( isnan(FixChg) ) then
            FixChg = 0.13

            WRITE(18,3333) CURIYR, CURITR, nr, ECP_D_FPH, ECP_D_LCP, ECP_D_XPH, ECPWind, GSYR1, GSYRL, ICAP, IFPH2, IP, IS, MNUMYR, OLYR, RCAP, UCPINTIS(ICAP), &
               UIRINTI(IP), UHBSYR, UNFPH, UPCLYR(ICAP), UPGSY1(ICAP), UPGSYL(ICAP), UPNCLF(ICAP), UPNLLF(ICAP), UPPLYR(ICAP), UPTXLF(ICAP), YEAR
 3333       FORMAT(1X,"EPLVFCF0:WN",28(":",I4))

            WRITE(18,3334) CURIYR, CURITR, nr, &
               CAPLEV, CAPNNSTL, CAPNUG, EPACM(ICAP), EPCCSUP(RCAP,IS), EPDSCRT, EPIROVR(RCAP), &
               EPLVFCF(ICAP,2), EPRGM(ICAP), EPUCRE, EPUIRT, EWGINT, EWGROE, EWGROR, FNBOOK, ITCADJ, OVRCST, PRATIO, PVGNP, TXBOOK, UPCAPD(1,ICAP), &
               UPCSB(ICAP), UPGSUB(ICAP), UPLRLC(ICAP), UPLROPT(ICAP), UPLRPC(ICAP), UPNFDT, UPNIPRM, UPNRPRM, UPRSK(ICAP), UPTXRT,UPANNADJ(ICAP,CURIYR)
 3334       FORMAT(1X,"EPLVFCF1:WN",3(":",I4),36(":",E10.3))

            WRITE(18,3335) CURIYR, CURITR, nr, (UPCPRO(ICAP,JYR),JYR= 1, ECP_D_LCP)
 3335       FORMAT(1X,"EPLVFCF2:WN",3(":",I4),35(":",E10.3))

            WRITE(18,3336) CURIYR, CURITR, nr, (UPGNPD(JYR),JYR=1,MNUMYR)
 3336       FORMAT(1X,"EPLVFCF3:WN",3(":",I4),<MNUMYR>(":",E10.3))

         else

            WRITE(18,4334) CURIYR,CURITR,NR,FixChg,EPLVFCF(ICAP,2)
 4334       FORMAT(1X,"EPLVFCF4:WN",3(":",I4),2(":",E10.3))

         endif

         if (ECP_D_OVCC(ECPWind).eq.0) then
            CapCostR_WL(nr) = UPOVR(ECPWind) * UPLRPC(ECPWind) * UPLROPT(ECPWind) * UPLRLC(ECPWind) * EPRGM(ECPWind) * EPACM(ECPWind) * UPANNADJ(ICAP,CURIYR)
         else
            CapCostR_WL(nr) = UPOVCC(ECPWind,curiyr) * UPLRPC(ECPWind) * UPLROPT(ECPWind) * UPLRLC(ECPWind) * EPRGM(ECPWind) * EPACM(ECPWind) * UPANNADJ(ECPWind,CURIYR)
         endif

!        Use the input incremental capital cost multiplier to get capital costs by wind class.

         if (ICCMeth_WL(curiyr).eq.1) then
            do wc=1,mnumcl
               ICCCostR_WL(nr,wc,curiyr)=CapCostR_WL(nr)*ICCMultR_WL(nr,wc,curiyr)
            end do
         else
            do wc=1,mnumcl
               ICCMultR_WL(nr,wc,curiyr)=ICCCostR_WL(nr,wc,curiyr) / CapCostR_WL(nr)
            end do
         end if

!        Determine the annualized cost per kwh by region, year, wind class, and buffer zone.

         do wc=1,mnumcl
            do bf=1,mnumbf

!              If XSwitch is not 0 then use the long-term multiplier by wind class in the capital cost.

               if (XSwitch.eq.0) then
                  AnnCost_WL(nr,curiyr,wc,bf)=(ICCCostR_WL(nr,wc,curiyr)*FixChg+OMFCost_WL+ WNTDBFCS(nr,bf)*FixChg)/(CF(curiyr,wc)*8760.0)+OMVCost_WL/1000

!                 WRITE(6,2003) CURIYR+1989,CURITR,nr,wc,bf, AnnCost_WL(nr,curiyr,wc,bf), ICCCostR_WL(nr,wc,curiyr), FixChg, OMFCost_WL,  &
!                    WNTDBFCS(nr,bf), CF_WL(curiyr,wc), OMVCost_WL
 2003             format(1X,"AnnCost:WL:0",5(":",I5),7(":",F15.6))

               else
                  AnnCost_WL(nr,curiyr,wc,bf) = (ICCCostR_WL(nr,wc,curiyr) * XLTElas(nr,wc) * FixChg + OMFCost + WNTDBFCS(nr,bf) * FixChg) / (CF_WL(curiyr,wc) * 8760.0) + OMVCost / 1000

!                 WRITE(6,2004) CURIYR+1989,CURITR,nr,wc,bf, AnnCost_WL(nr,curiyr,wc,bf), ICCCostR_WL(nr,wc,curiyr), XLTElas(nr,wc),  &
!                    FixChg, OMFCost_WL, WNTDBFCS(nr,bf), CF(curiyr,wc), OMVCost_WL
 2004             format(1X,"AnnCost:WN:1",5(":",I5),8(":",F15.6))

               end if
            end do
         end do
      end do      !region loop

!     Choose the manner of ranking: 1=original, 2=by cost (note, that in the base they are the same)

      RankVer=2
      if (RankVer.eq.1) then

!        Rank the categories according to some criteria - probably lowest to highest cost.
!        For now, they are simply ranked in wind class, buffer zone order, as in the original model.

         do nr=1,mnumnr
            RNum_WL=0
            do wc=1,mnumcl
               do bf=1,mnumbf
                  RNum_WL=RNum_WL+1
                  Rwc_WL(nr,RNum,curiyr)=wc
                  Rbf_WL(nr,RNum,curiyr)=bf
               end do
            end do
         end do
      elseif (RankVer.eq.2) then
         RNum_WL=mnumcl*mnumbf
         do nr=1,mnumnr
            n=0
            do wc=1,mnumcl
               do bf=1,mnumbf
                  n=n+1
                  Used(wc,bf)=0
                  Rwc_WL(nr,n,curiyr)=0
                  Rbf_WL(nr,n,curiyr)=0
               end do
            end do
            n=0
            do wc=1,mnumcl
               do bf=1,mnumbf
                  n=n+1
                  XCost=999999.9
                  do w=1,mnumcl
                     do b=1,mnumbf
                        if (Used(w,b).eq.0.and.AnnCost_WL(nr,curiyr,w,b).lt.XCost) then

!                           WRITE(18,4817) CURIRUN, CURIYR+1989, nr, n, wc, w, bf, b, XCOST, AnnCost_WL(nr,curiyr,w,b)
 4817                      FORMAT(1X,"Renew_windrank3:WL",8(":",I5),2(":",F21.6))

                           XCost=AnnCost_WL(nr,curiyr,w,b)
                           Rwc_WL(nr,n,curiyr)=w
                           Rbf_WL(nr,n,curiyr)=b
                           Rank_WL(nr,w,b)=n
                        end if
                     end do
                  end do
                  If (Rwc_WL(nr,n,curiyr) .gt. 0 .and. Rbf_WL(nr,n,curiyr) .gt. 0) then
                     Used(Rwc_WL(nr,n,curiyr),Rbf_WL(nr,n,curiyr))=1
                  else
                     do w=1,mnumcl
                        do b=1,mnumbf

!                           WRITE(6,1003) curcalyr,nr,n,w,b,AnnCost_WL(nr,curiyr,w,b)
 1003                      format(1X,"Oops_used",5(":",I4),":",F20.6)

                        end do
                     end do
                  end if
               end do
            end do
         end do
      end if

      return
      end

!     Subroutine WindRept3 writes out a number of things to a debug report.

      subroutine WindRept3

      implicit none
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'ecpcntl'
      include 'control'
      include 'wrenew'
      include 'wwind'
      include 'wrenio'
      include 'rencntl'
      include 'udatout'
      include 'uefdout'

      integer wc,bf,nr,yr,n,s,stp,WTech,WTech_WL,IDisp(mnumnr),i,FYR,ALASKA,HAWAII
      real XTot,YTot,RDisp(mnumnr)
      character*260 rept_head

      rept_head =  '     Regn1     Regn2     Regn3     Regn4     Regn5     Regn6     Regn7     Regn8     Regn9    Regn10    Regn11    Regn12    Regn13    Regn14    Regn15    Regn16    Regn17    Regn18    Regn19    Regn20    Regn21    Regn22    Regn23    Regn24    Regn25     Total'

        ALASKA = MNUMNR - 2
        HAWAII = MNUMNR - 1

      WTech = 10   !Wind technology number. - Shouldn't I be determining this instead of hard - wired?
      WTech_WL = 11

!     Write out the costs to the debug file.

      write(IORNREPT,'(1X,"WI",/,a,i4,a)') 'Wind Cost Variables for Year ',curcalyr,'   Note: 1 year lag in costs'
      write(IORNREPT,'(1X,"WI",a,f10.2)') 'O&M Cost:                        ',OMFCost
      write(IORNREPT,'(1X,"WI",a,f10.3)') 'Fixed Charge Factor:             ',FixChg
      write(IORNREPT,'(1X,"WI",a)') "Original EMM Capital Cost, Cost Multipliers by wind class, New Capital Costs by wind class"
      write(IORNREPT,'(1X,"WI",a4,a12,<mnumcl>(a5,i1),<mnumcl>(a9,i1))')"Rgn","OCC",('M',7-wc,wc=1,mnumcl),('NCC',7-wc,wc=1,mnumcl)

      do nr=1,unrgns
         write(IORNREPT,'(1X,"WN",1x,i3,2x,F10.2,<mnumcl>F6.2,<mnumcl>F10.2)') nr, CapCostR(nr), (ICCMultR(nr,wc,curiyr),wc=1,mnumcl), (ICCCostR(nr,wc,curiyr),wc=1,mnumcl)
      enddo

!      do nr=1,unrgns
!         write(IORNREPT,'(1X,"WL",1x,i3,2x,F10.2,<mnumcl>F6.2,<mnumcl>F10.2)') nr, CapCostR_WL(nr), (ICCMultR_WL(nr,wc,curiyr),wc=1,mnumcl), (ICCCostR_WL(nr,wc,curiyr),wc=1,mnumcl)
!      enddo

      write(IORNREPT,'(1X,"WI",/,a)') 'Cost of Electricity (with Cost Rank) (Annualized Cost per Kwh in $87)'
      write(IORNREPT,'(1X,"WI",5x,a)') rept_head

      do wc=1,mnumcl
 do bf=1,mnumbf
            IF (WCapMax(mnumnr,curiyr,wc,bf) .GT. 0.00001) &
               write(IORNREPT,'(1X,"WN",a1,i1,a1,i1,1x,<unrgns>(f10.4,i3))') 'C',7-wc,'Z',bf,(AnnCost(nr,curiyr,wc,bf),Rank(nr,wc,bf),nr=1,unrgns)
         end do
 end do

!      do wc=1,mnumcl
!         do bf=1,mnumbf
!            IF (WCapMax(mnumnr,curiyr,wc,bf) .GT. 0.00001) &
!               write(IORNREPT,'(1X,"WL",a1,i1,a1,i1,1x,<unrgns>(f10.4,i3))') 'C',7-wc,'Z',bf,(AnnCost_WL(nr,curiyr,wc,bf),Rank_WL(nr,wc,bf),nr=1,unrgns)
!         end do
!      end do

      write(IORNREPT,'(1X,"WI",/,a)') 'Current "Best" Wind Class and "Best" Buffer Zone'
      write(IORNREPT,'(1X,"WI",20x,a)') rept_head
      write(IORNREPT,'(1X,"WN",a,<unrgns>i10)') 'Best Wind Class       ',(7-WCurCl(nr,curiyr),nr=1,unrgns)
      write(IORNREPT,'(1X,"WN",a,<unrgns>i10)') 'Best Buffer Zone      ',(WCurBf(nr,curiyr),nr=1,unrgns)
!      write(IORNREPT,'(1X,"WL",a,<unrgns>i10)') 'Best Wind Class       ',(7-WCurCl_WL(nr,curiyr),nr=1,unrgns)
!      write(IORNREPT,'(1X,"WL",a,<unrgns>i10)') 'Best Buffer Zone      ',(WCurBf_WL(nr,curiyr),nr=1,unrgns)

!     if(curiyr.eq.6) then

      if (curiyr .eq. UESTYR-UHBSYR) then

!        Write out the first year of land area to the debug file.

         write(IORNREPT,'(1X,"WI",/,a,i2)') 'Land Area Available by Region, Class, and Zone'
         write(IORNREPT,'(1X,"WI",a4,1x,<mnumcl*mnumbf>(a5,i1,a1,i1),a10)') 'NERC', ((('C',7-wc,'Z',bf),bf=1,mnumbf),wc=1,mnumcl),'Total'

         do nr = 1,unrgns
            XTot = 0.0
            do wc = 1,mnumcl
               do bf = 1,mnumbf
                  XTot = XTot+LdArea(nr,UESTYR-UHBSYR,wc,bf)
               end do
            end do
            write(IORNREPT,'(1X,"WI",i4,2x,<mnumcl*mnumbf>f8.0,f10.0)') nr,((LdArea(nr,UESTYR-UHBSYR,wc,bf),bf=1,mnumbf),wc=1,mnumcl),XTot
         end do

!        Write out the maximum potential capacity for all years and one sample region to the debug file.

         ! nr=21

         ! write(IORNREPT,'(1X,"WI",/,a,i2)') 'Maximum Wind Capacity Available by Year, Class, and Zone, Region ',nr
         ! write(IORNREPT,'(1X,"WI",a4,1x,<mnumcl*mnumbf>(a7,i1,a1,i1),a10)') 'Year', ((('C',7-wc,'Z',bf),wc=1,mnumcl),bf=1,mnumbf),'Total'

         ! do yr=1,MNUMYR
            ! XTot=0.0
            ! do wc=1,mnumcl
               ! do bf=1,mnumbf
                  ! XTot=XTot+WCapMax(nr,yr,wc,bf)
               ! end do
            ! end do
            ! write(IORNREPT,'(1X,"WI",i4,2x,<mnumcl*mnumbf>f10.0,2x,f10.0)') yr+1989,((WCapMax(nr,yr,wc,bf),bf=1,mnumbf),wc=1,mnumcl),XTot
         ! end do

      else

         write(IORNREPT,'(1X,"WI",a,a)') 'Na>'
         write(IORNREPT,'(1X,"WI",a,a,i4)') 'Na>','Installed, Added, and Committed Capacity (MW) in the Current Year ',curcalyr
         write(IORNREPT,'(1X,"WI",a,20x,a,a)') 'Na>', rept_head
         write(IORNREPT,'(1X,"WI",a,a)') 'Na>','New Installed Capacity'
         write(IORNREPT,'(1X,"WN",a,a,<unrgns>f10.1,f11.1)') 'Na>','  Planned Builds      ',(CapPlnBld(nr,curiyr),nr=1,unrgns),CapPlnBld(mnumnr,curiyr)
         write(IORNREPT,'(1X,"WN",a,a,<unrgns>f10.1,f11.1)') 'Na>','  Committed-Now Built ',(CapNewBld(nr,curiyr),nr=1,unrgns),CapNewBld(mnumnr,curiyr)
         write(IORNREPT,'(1X,"WN",a,a,<unrgns>f10.1,f11.1)') 'Na>','  Total New           ',(CapAdded(nr,curiyr),nr=1,unrgns),CapAdded(mnumnr,curiyr)
!         write(IORNREPT,'(1X,"WL",a,a,<unrgns>f10.1,f11.1)') 'Na>','  Planned Builds      ',(CapPlnBld_WL(nr,curiyr),nr=1,unrgns),CapPlnBld_WL(mnumnr,curiyr)
!         write(IORNREPT,'(1X,"WL",a,a,<unrgns>f10.1,f11.1)') 'Na>','  Committed-Now Built ',(CapNewBld_WL(nr,curiyr),nr=1,unrgns),CapNewBld_WL(mnumnr,curiyr)
!         write(IORNREPT,'(1X,"WL",a,a,<unrgns>f10.1,f11.1)') 'Na>','  Total New           ',(CapAdded_WL(nr,curiyr),nr=1,unrgns),CapAdded_WL(mnumnr,curiyr)
         write(IORNREPT,'(1X,"WI",a,a)') 'Na>','Cumulative Installed Capacity'
         write(IORNREPT,'(1X,"WN",a,a,<unrgns>f10.1,f11.1)') 'Na>','  Total Cumulative    ',(CapInstall(nr,curiyr),nr=1,unrgns),CapInstall(mnumnr,curiyr)
!         write(IORNREPT,'(1X,"WL",a,a,<unrgns>f10.1,f11.1)') 'Na>','  Total Cumulative    ',(CapInstall_WL(nr,curiyr),nr=1,unrgns),CapInstall_WL(mnumnr,curiyr)
         write(IORNREPT,'(1X,"WI",a,a)') 'Na>','Committed Capacity'
         write(IORNREPT,'(1X,"WN",a,a,<unrgns>f10.1,f11.1)') 'Na>','  Committed This Year ',(CapCommit(nr,curiyr),nr=1,unrgns),CapCommit(mnumnr,curiyr)
!         write(IORNREPT,'(1X,"WL",a,a,<unrgns>f10.1,f11.1)') 'Na>','  Committed This Year ',(CapCommit_WL(nr,curiyr),nr=1,unrgns),CapCommit_WL(mnumnr,curiyr)
         do i=1,NLead-1
            write(IORNREPT,'(1X,"WN",a,a,i1,a,<unrgns>f10.1,f11.1)') 'Na>','  Committed Year-',i,'    ',(CapCommit(nr,curiyr-i),nr=1,unrgns),CapCommit(mnumnr,curiyr-i)
         end do
         write(IORNREPT,'(1X,"WN",a,a,<unrgns>f10.1,f11.1)') 'Na>','  Total Committed     ',(CapCmtTot(nr,curiyr),nr=1,unrgns),CapCmtTot(mnumnr,curiyr)
!         do i=1,NLead-1
!            write(IORNREPT,'(1X,"WL",a,a,i1,a,<unrgns>f10.1,f11.1)') 'Na>','  Committed Year-',i,'    ',(CapCommit_WL(nr,curiyr-i),nr=1,unrgns),CapCommit_WL(mnumnr,curiyr-i)
!         end do
!         write(IORNREPT,'(1X,"WL",a,a,<unrgns>f10.1,f11.1)') 'Na>','  Total Committed     ',(CapCmtTot_WL(nr,curiyr),nr=1,unrgns),CapCmtTot_WL(mnumnr,curiyr)
         write(IORNREPT,'(1X,"WI",a,a)') 'Na>','Cumulative Installed Plus Committed Capacity'
         write(IORNREPT,'(1X,"WN",a,a,<unrgns>f10.1,f11.1)') 'Na>','  Total               ',(CapIandC(nr,curiyr),nr=1,unrgns),CapIandC(mnumnr,curiyr)
!         write(IORNREPT,'(1X,"WL",a,a,<unrgns>f10.1,f11.1)') 'Na>','  Total               ',(CapIandC_WL(nr,curiyr),nr=1,unrgns),CapIandC_WL(mnumnr,curiyr)

         write(IORNREPT,'(1X,"WI",a,a)') 'Nc>'
         write(IORNREPT,'(1X,"WI",a,a,i4)') 'Nc>','Current Year Ranking by Cost (Rank) - Year ',curcalyr
         write(IORNREPT,'(1X,"WI",a,20x,a,a)') 'Nc>', rept_head

         do wc=1,mnumcl
            do bf=1,mnumbf
               IF (WCapMax(mnumnr,curiyr,wc,bf) .GT. 0.00001) &
                  write(IORNREPT,'(1X,"WN",a,2x,a,i1,a,i1,16x,<unrgns>i10)') 'Nc>','C',7-wc,'Z',bf,(Rank(nr,wc,bf),nr=1,unrgns)
            end do
         end do

!         do wc=1,mnumcl
!            do bf=1,mnumbf
!               IF (WCapMax(mnumnr,curiyr,wc,bf) .GT. 0.00001) &
!                  write(IORNREPT,'(1X,"WL",a,2x,a,i1,a,i1,16x,<unrgns>i10)') 'Nc>','C',7-wc,'Z',bf,(Rank_WL(nr,wc,bf),nr=1,unrgns)
!            end do
!         end do

         write(IORNREPT,'(1X,"WI",a,a)') 'Nb>'
         write(IORNREPT,'(1X,"WI",a,a,i4)') 'Nb>','Increment in Installed Capacity (ICapInc) - Year ',curcalyr
         write(IORNREPT,'(1X,"WI",a,20x,a,a)') 'Nb>', rept_head

         do nr=1,mnumnr
            RDisp(nr)=0.0
         end do
         do wc=1,mnumcl
            do bf=1,mnumbf
               IF (WCapMax(mnumnr,curiyr,wc,bf) .GT. 0.00001) &
                  write(IORNREPT,'(1X,"WN",a,2x,a,i1,a,i1,16x,<unrgns>f10.0,f11.0)') 'Nb>','C',7-wc,'Z',bf,(ICapInc(nr,curiyr,wc,bf),nr=1,unrgns),ICapInc(mnumnr,curiyr,wc,bf)
               do nr=1,mnumnr
                  RDisp(nr)=RDisp(nr)+ICapInc(nr,curiyr,wc,bf)
               end do
            end do
         end do

         write(IORNREPT,'(1X,"WN",a,2x,a,15x,14f8.1)') 'Nb>','Total',(RDisp(nr),nr=1,unrgns),RDisp(16)

         do nr=1,mnumnr
            RDisp(nr)=0.0
         end do
         do wc=1,mnumcl
            do bf=1,mnumbf
!               IF (WCapMax(mnumnr,curiyr,wc,bf) .GT. 0.00001) &
!                  write(IORNREPT,'(1X,"WL",a,2x,a,i1,a,i1,16x,<unrgns>f10.0,f11.0)') 'Nb>','C',7-wc,'Z',bf,(ICapInc_WL(nr,curiyr,wc,bf),nr=1,unrgns),ICapInc_WL(mnumnr,curiyr,wc,bf)
               do nr=1,mnumnr
                  RDisp(nr)=RDisp(nr)+ICapInc_WL(nr,curiyr,wc,bf)
               end do
            end do
         end do

!         write(IORNREPT,'(1X,"WL",a,2x,a,15x,<unrgns>f10.0,f11.0)') 'Nb>','Total',(RDisp(nr),nr=1,unrgns),RDisp(mnumnr)

         write(IORNREPT,'(1X,"WI",a,a)') 'Nb>'
         write(IORNREPT,'(1X,"WI",a,a,i4)') 'Nb>','Cumulative Installed Capacity (ICapCum) - Year ',curcalyr
         write(IORNREPT,'(1X,"WI",a,20x,a,a)') 'Nb>', rept_head

         do nr=1,mnumnr
            RDisp(nr)=0.0
         end do
         do wc=1,mnumcl
            do bf=1,mnumbf
               IF (WCapMax(mnumnr,curiyr,wc,bf) .GT. 0.00001) &
                  write(IORNREPT,'(1X,"WN",a,2x,a,i1,a,i1,16x,<unrgns>f10.0,f11.0)') 'Nb>','C',7-wc,'Z',bf,(ICapCum(nr,curiyr,wc,bf),nr=1,unrgns),ICapCum(mnumnr,curiyr,wc,bf)
               do nr=1,mnumnr
                  RDisp(nr)=RDisp(nr)+ICapCum(nr,curiyr,wc,bf)
               end do
            end do
         end do

         write(IORNREPT,'(1X,"WN",a,2x,a,15x,<unrgns>f10.0,f11.0)') 'Nb>','Total',(RDisp(nr),nr=1,unrgns),RDisp(mnumnr)

         do nr=1,mnumnr
            RDisp(nr)=0.0
         end do
         do wc=1,mnumcl
            do bf=1,mnumbf
!               IF (WCapMax(mnumnr,curiyr,wc,bf) .GT. 0.00001) &
!                  write(IORNREPT,'(1X,"WL",a,2x,a,i1,a,i1,16x,<unrgns>f10.0,f11.0)') 'Nb>','C',7-wc,'Z',bf,(ICapCum_WL(nr,curiyr,wc,bf),nr=1,unrgns),ICapCum_WL(mnumnr,curiyr,wc,bf)
               do nr=1,mnumnr
                  RDisp(nr)=RDisp(nr)+ICapCum_WL(nr,curiyr,wc,bf)
               end do
            end do
         end do

!         write(IORNREPT,'(1X,"WL",a,2x,a,15x,<unrgns>f10.0,f11.0)') 'Nb>','Total',(RDisp(nr),nr=1,unrgns),RDisp(mnumnr)

         write(IORNREPT,'(1X,"WI",a,a)') 'Nb>'
         write(IORNREPT,'(1X,"WI",a,a,i4)') 'Nb>','Capacity Available (Accounting for Installed Only) (ICapAvl) - Year ',curcalyr
         write(IORNREPT,'(1X,"WI",a,20x,a,a)') 'Nb>', rept_head

         do nr=1,mnumnr
            RDisp(nr)=0.0
         end do
         do wc=1,mnumcl
            do bf=1,mnumbf
               IF (WCapMax(mnumnr,curiyr,wc,bf) .GT. 0.00001) &
                  write(IORNREPT,'(1X,"WI",a,2x,a,i1,a,i1,16x,<unrgns>f10.0,f11.0)') 'Nb>','C',7-wc,'Z',bf,(ICapAvl(nr,curiyr,wc,bf),nr=1,unrgns),ICapAvl(mnumnr,curiyr,wc,bf)
               do nr=1,mnumnr
                  RDisp(nr)=RDisp(nr)+ICapAvl(nr,curiyr,wc,bf)
               end do
            end do
         end do

         write(IORNREPT,'(1X,"WI",a,2x,a,15x,<unrgns>f10.0,f11.0)') 'Nb>','Total',(RDisp(nr),nr=1,unrgns),RDisp(mnumnr)

         write(IORNREPT,'(1X,"WI",a,a)') 'Nb>'
         write(IORNREPT,'(1X,"WI",a,a,i4)') 'Nb>','Committed Capacity not yet Built (WCapInc) - Year ',curcalyr
         write(IORNREPT,'(1X,"WI",a,20x,a,a)') 'Nb>', rept_head

         do nr=1,mnumnr
            RDisp(nr)=0.0
         end do
         do wc=1,mnumcl
            do bf=1,mnumbf
               IF (WCapMax(mnumnr,curiyr,wc,bf) .GT. 0.00001) &
                  write(IORNREPT,'(1X,"WN",a,2x,a,i1,a,i1,16x,<unrgns>f10.0,f11.0)') 'Nb>','C',7-wc,'Z',bf,(WCapInc(nr,curiyr,wc,bf),nr=1,unrgns),WCapInc(mnumnr,curiyr,wc,bf)
               do nr=1,mnumnr
                  RDisp(nr)=RDisp(nr)+WCapInc(nr,curiyr,wc,bf)
               end do
            end do
         end do
         write(IORNREPT,'(1X,"WI",a,2x,a,15x,<unrgns>f10.0,f11.0)') 'Nb>','Total',(RDisp(nr),nr=1,unrgns),RDisp(mnumnr)

         do nr=1,mnumnr
            RDisp(nr)=0.0
         end do
         do wc=1,mnumcl
            do bf=1,mnumbf
!               IF (WCapMax(mnumnr,curiyr,wc,bf) .GT. 0.00001) &
!                  write(IORNREPT,'(1X,"WL",a,2x,a,i1,a,i1,16x,<unrgns>f10.0,f11.0)') 'Nb>','C',7-wc,'Z',bf,(WCapInc_WL(nr,curiyr,wc,bf),nr=1,unrgns),WCapInc_WL(mnumnr,curiyr,wc,bf)
               do nr=1,mnumnr
                  RDisp(nr)=RDisp(nr)+WCapInc_WL(nr,curiyr,wc,bf)
               end do
            end do
         end do
         write(IORNREPT,'(1X,"WI",a,2x,a,15x,<unrgns>f10.0,f11.0)') 'Nb>','Total',(RDisp(nr),nr=1,unrgns),RDisp(mnumnr)

         write(IORNREPT,'(1X,"WI",a,a)') 'Nb>'
         write(IORNREPT,'(1X,"WI",a,a,i4)') 'Nb>','Cumulative Installed Capacity Plus Committed not yet Built (WCapCum) - Year ',curcalyr
         write(IORNREPT,'(1X,"WI",a,20x,a,a)') 'Nb>', rept_head

         do nr=1,mnumnr
            RDisp(nr)=0.0
         end do
         do wc=1,mnumcl
            do bf=1,mnumbf
               IF (WCapMax(mnumnr,curiyr,wc,bf) .GT. 0.00001) &
                  write(IORNREPT,'(1X,"WN",a,2x,a,i1,a,i1,16x,<unrgns+2>f10.0)') 'Nb>','C',7-wc,'Z',bf,(WCapCum(nr,curiyr,wc,bf),nr=1,unrgns),WCapCum(mnumnr,curiyr,wc,bf),WCapCum(ALASKA,curiyr,wc,bf)+WCapCum(HAWAII,curiyr,wc,bf)
               do nr=1,mnumnr
                  RDisp(nr)=RDisp(nr)+WCapCum(nr,curiyr,wc,bf)
               end do
            end do
         end do
         write(IORNREPT,'(1X,"WN",a,2x,a,15x,<unrgns>f10.1,f11.1)') 'Nb>','Total',(RDisp(nr),nr=1,unrgns),RDisp(mnumnr)

         do nr=1,mnumnr
            RDisp(nr)=0.0
         end do
         do wc=1,mnumcl
            do bf=1,mnumbf
!               IF (WCapMax(mnumnr,curiyr,wc,bf) .GT. 0.00001) &
!                  write(IORNREPT,'(1X,"WL",a,2x,a,i1,a,i1,16x,<unrgns>f10.0,f11.0)') 'Nb>','C',7-wc,'Z',bf,(WCapCum_WL(nr,curiyr,wc,bf),nr=1,unrgns),WCapCum_WL(mnumnr,curiyr,wc,bf)
               do nr=1,mnumnr
                  RDisp(nr)=RDisp(nr)+WCapCum_WL(nr,curiyr,wc,bf)
               end do
            end do
         end do
!         write(IORNREPT,'(1X,"WL",a,2x,a,15x,<unrgns>f10.0,f11.0)') 'Nb>','Total',(RDisp(nr),nr=1,unrgns),RDisp(mnumnr)

         write(IORNREPT,'(1X,"WI",a,a)') 'Nb>'
         write(IORNREPT,'(1X,"WI",a,a,i4)') 'Nb>','Capacity Available (Accounting for Installed Plus Committed) (WCapAvl) - Year ',curcalyr
         write(IORNREPT,'(1X,"WI",a,20x,a,a)') 'Nb>', rept_head

         do nr=1,mnumnr
            RDisp(nr)=0.0
         end do
         do wc=1,mnumcl
            do bf=1,mnumbf
               IF (WCapMax(mnumnr,curiyr,wc,bf) .GT. 0.00001) &
                  write(IORNREPT,'(1X,"WI",a,2x,a,i1,a,i1,16x,<unrgns>f10.0,f11.0)') 'Nb>','C',7-wc,'Z',bf,(WCapAvl(nr,curiyr,wc,bf),nr=1,unrgns),WCapAvl(mnumnr,curiyr,wc,bf)
               do nr=1,mnumnr
                  RDisp(nr)=RDisp(nr)+WCapAvl(nr,curiyr,wc,bf)
               end do
            end do
         end do
         write(IORNREPT,'(1X,"WI",a,2x,a,15x,<unrgns>f10.0,f11.0)') 'Nb>','Total',(RDisp(nr),nr=1,unrgns),RDisp(mnumnr)

         write(IORNREPT,'(1X,"WI",a,a)') 'Nb>'
         write(IORNREPT,'(1X,"WI",a,a,i4)') 'Nb>','Original Maximum Capacity Available (WCapMax) - Year ',curcalyr
         write(IORNREPT,'(1X,"WI",a,20x,a,a)') 'Nb>', rept_head

         do nr=1,mnumnr
            RDisp(nr)=0.0
         end do
         do wc=1,mnumcl
            do bf=1,mnumbf
               IF (WCapMax(mnumnr,curiyr,wc,bf) .GT. 0.00001) &
                  write(IORNREPT,'(1X,"WI",a,2x,a,i1,a,i1,16x,<unrgns>f10.0,f11.0)') 'Nb>','C',7-wc,'Z',bf,(WCapMax(nr,curiyr,wc,bf),nr=1,unrgns),WCapMax(mnumnr,curiyr,wc,bf)
               do nr=1,mnumnr
                  RDisp(nr)=RDisp(nr)+WCapMax(nr,curiyr,wc,bf)
               end do
            end do
         end do
         write(IORNREPT,'(1X,"WI",a,2x,a,15x,<unrgns>f10.0,f11.0)') 'Nb>','Total',(RDisp(nr),nr=1,unrgns),RDisp(mnumnr)

         write(IORNREPT,'(1X,"WI",/,a)') 'Current "Best" Wind Class & Buffer Zone, Capacity Increment, and Category Tolerance'
         write(IORNREPT,'(1X,"WI",20x,a)') rept_head
         write(IORNREPT,'(1X,"WN",a,<unrgns>i10)') 'Best Wind Class       ',(7-WCurCl(nr,curiyr),nr=1,unrgns)
         write(IORNREPT,'(1X,"WN",a,<unrgns>i10)') 'Best Buffer Zone      ',(WCurBf(nr,curiyr),nr=1,unrgns)
         write(IORNREPT,'(1X,"WN",a,<unrgns>f10.1)') 'Capacity Increment    ',(CapIncr(nr,curiyr),nr=1,unrgns)
         write(IORNREPT,'(1X,"WN",a,<unrgns>f10.1)') 'Category Tolerance    ',(ConsTol(nr),nr=1,unrgns)

!         write(IORNREPT,'(1X,"WL",a,<unrgns>i10)') 'Best Wind Class       ',(7-WCurCl_WL(nr,curiyr),nr=1,unrgns)
!         write(IORNREPT,'(1X,"WL",a,<unrgns>i10)') 'Best Buffer Zone      ',(WCurBf_WL(nr,curiyr),nr=1,unrgns)
!         write(IORNREPT,'(1X,"WL",a,<unrgns>f10.1)') 'Capacity Increment    ',(CapIncr_WL(nr,curiyr),nr=1,unrgns)
!         write(IORNREPT,'(1X,"WL",a,<unrgns>f10.1)') 'Category Tolerance    ',(ConsTol_WL(nr),nr=1,unrgns)

         write(IORNREPT,'(1X,"WI",/,a)') 'Potential Category Weighting - Available Capacity, Weighted Average Costs and CFs'
         write(IORNREPT,'(1X,"WI",20x,a)') rept_head
         write(IORNREPT,'(1X,"WN",a,<unrgns>i10)') 'Number of Categories  ',(ConsNum(nr),nr=1,unrgns)
         write(IORNREPT,'(1X,"WN",a,<unrgns>f10.1)') 'Available Capacity    ',(ConsCap(nr),nr=1,unrgns)
         write(IORNREPT,'(1X,"WN",a,<unrgns>f10.3)') 'WgtAvg LT Multiplier  ',(ConsLT(nr),nr=1,unrgns)
         write(IORNREPT,'(1X,"WN",a,<unrgns>f10.3)') 'WgtAvg CC Multiplier  ',(ConsCC(nr),nr=1,unrgns)
         write(IORNREPT,'(1X,"WN",a,<unrgns>f10.3)') 'WgtAvg Capacity Factor',(ConsCF(nr),nr=1,unrgns)
         write(IORNREPT,'(1X,"WN",a,<unrgns>f10.2)') 'WgtAvg T&D Cost       ',(ConsTD(nr),nr=1,unrgns)

!         write(IORNREPT,'(1X,"WL",a,<unrgns>i10)') 'Number of Categories  ',(ConsNum_WL(nr),nr=1,unrgns)
!         write(IORNREPT,'(1X,"WL",a,<unrgns>f10.1)') 'Available Capacity    ',(ConsCap_WL(nr),nr=1,unrgns)
!         write(IORNREPT,'(1X,"WL",a,<unrgns>f10.3)') 'WgtAvg LT Multiplier  ',(ConsLT_WL(nr),nr=1,unrgns)
!         write(IORNREPT,'(1X,"WL",a,<unrgns>f10.3)') 'WgtAvg CC Multiplier  ',(ConsCC_WL(nr),nr=1,unrgns)
!         write(IORNREPT,'(1X,"WL",a,<unrgns>f10.3)') 'WgtAvg Capacity Factor',(ConsCF_WL(nr),nr=1,unrgns)
!         write(IORNREPT,'(1X,"WL",a,<unrgns>f10.2)') 'WgtAvg T&D Cost       ',(ConsTD_WL(nr),nr=1,unrgns)

!        Write the long term elasticities by wind class.

         if(XSwitch.ne.0) then
            write(IORNREPT,'(1X,"WI",/,a,i4)') 'Long-Term Elasticities/Multipliers by Wind Class in year ',curcalyr
            write(IORNREPT,'(1X,"WI",20x,a)') rept_head
            do wc=1,mnumcl
               write(IORNREPT,'(1X,"WI",a,i1)') 'Wind Class ',7-wc
               write(IORNREPT,'(1X,"WI",a,<unrgns>f10.1)') ' Committed Capacity   ',(XCapCum(nr,wc),nr=1,unrgns)
               write(IORNREPT,'(1X,"WI",a,<unrgns>f10.0)') ' Maximum Capacity     ',(XCapMax(nr,wc),nr=1,unrgns)
               write(IORNREPT,'(1X,"WI",a,<unrgns>f10.3)') ' Ratio                ',(XRatio(nr,wc),nr=1,unrgns)
               write(IORNREPT,'(1X,"WN",a,<unrgns>f10.3)') ' LT Elasticity        ',(XLTElas(nr,wc),nr=1,unrgns)
!               write(IORNREPT,'(1X,"WL",a,<unrgns>f10.3)') ' LT Elasticity        ',(XLTElas_WL(nr,wc),nr=1,unrgns)
            end do
         end if

!        Write the supply curve capacities.

         write(IORNREPT,'(1X,"WI",/,a,i4)') 'Supply Curve Capacity Steps (MW) for ',curcalyr
         write(IORNREPT,'(1X,"WI",20x,a)') rept_head
         write(IORNREPT,'(1X,"WN",a,<unrgns>f10.1)') 'Step 1                ',(UTCACA(1),nr=1,unrgns)
         write(IORNREPT,'(1X,"WN",a,<unrgns>f10.1)') 'Step 2                ',(UTCACA(2),nr=1,unrgns)
         write(IORNREPT,'(1X,"WN",a,<unrgns>f10.1)') 'Step 3                ',(UTCACA(3),nr=1,unrgns)
         write(IORNREPT,'(1X,"WN",a,<unrgns>f10.1)') 'Total                 ',(UTCACA(1)+UTCACA(2)+UTCACA(3),nr=1,unrgns)

!         write(IORNREPT,'(1X,"WL",a,<unrgns>f10.1)') 'Step 1                ',(UTCACA_WL(1),nr=1,unrgns)
!         write(IORNREPT,'(1X,"WL",a,<unrgns>f10.1)') 'Step 2                ',(UTCACA_WL(2),nr=1,unrgns)
!         write(IORNREPT,'(1X,"WL",a,<unrgns>f10.1)') 'Step 3                ',(UTCACA_WL(3),nr=1,unrgns)
!         write(IORNREPT,'(1X,"WL",a,<unrgns>f10.1)') 'Total                 ',(UTCACA_WL(1)+UTCACA_WL(2)+UTCACA_WL(3),nr=1,unrgns)

!        Preserve      this year's long term multiplier for "Sx" report

         if (XSwitch.eq.0) then
            do nr=1,unrgns
               LTMult(nr,curiyr) = LTElas(nr)
               LTMult_WL(nr,curiyr) = LTElas_WL(nr)
            enddo
         else
            do nr=1,unrgns
               LTMult(nr,curiyr) = XLTElas(nr,WCurCl(nr,curiyr))
               LTMult_WL(nr,curiyr) = XLTElas_WL(nr,WCurCl_WL(nr,curiyr))
            enddo
         endif

!        Combining of all the multipliers.

         write(IORNREPT,'(1X,"WI",/,a,i4)') 'Combining of Long-Term, Capital Cost, and Short-Term Multipliers for ',curcalyr
         write(IORNREPT,'(1X,"WI",20x,a)') rept_head
         write(IORNREPT,'(1X,"WI",a)') 'Long-Term Multipliers for "Best" Wind Class'
         if(XSwitch.eq.0) then
            write(IORNREPT,'(1X,"WN",a,<unrgns>f10.3)') 'Long-Term Multiplier  ',(LTElas(nr),nr=1,unrgns)
!            write(IORNREPT,'(1X,"WL",a,<unrgns>f10.3)') 'Long-Term Multiplier  ',(LTElas_WL(nr),nr=1,unrgns)
         else
            write(IORNREPT,'(1X,"WN",a,<unrgns>f10.3)') 'Long-Term Multiplier  ',(XLTElas(nr,WCurCl(nr,curiyr)),nr=1,unrgns)
!            write(IORNREPT,'(1X,"WL",a,<unrgns>f10.3)') 'Long-Term Multiplier  ',(XLTElas_WL(nr,WCurCl_WL(nr,curiyr)),nr=1,unrgns)
         end if
         write(IORNREPT,'(1X,"WI",a)') 'Capital Cost Multipliers for "Best" Wind Class'
         write(IORNREPT,'(1X,"WN",a,<unrgns>f10.3)') 'Capital Cost Mult.    ',(ICCMultR(nr,WCurCl(nr,curiyr),curiyr),nr=1,unrgns)
!         write(IORNREPT,'(1X,"WL",a,<unrgns>f10.3)') 'Capital Cost Mult.    ',(ICCMultR_WL(nr,WCurCl_WL(nr,curiyr),curiyr),nr=1,unrgns)

         write(IORNREPT,'(1X,"WI",a)') 'Short-Term Multipliers by Supply Curve Step'
         write(IORNREPT,'(1X,"WN",a,<unrgns>f10.3)') 'Short-Term, Step 1    ',(STElas(1),nr=1,unrgns)
         write(IORNREPT,'(1X,"WN",a,<unrgns>f10.3)') 'Short-Term, Step 2    ',(STElas(2),nr=1,unrgns)
         write(IORNREPT,'(1X,"WN",a,<unrgns>f10.3)') 'Short-Term, Step 3    ',(STElas(3),nr=1,unrgns)

!         write(IORNREPT,'(1X,"WL",a,<unrgns>f10.3)') 'Short-Term, Step 1    ',(STElas_WL(1),nr=1,unrgns)
!         write(IORNREPT,'(1X,"WL",a,<unrgns>f10.3)') 'Short-Term, Step 2    ',(STElas_WL(2),nr=1,unrgns)
!         write(IORNREPT,'(1X,"WL",a,<unrgns>f10.3)') 'Short-Term, Step 3    ',(STElas_WL(3),nr=1,unrgns)

         write(IORNREPT,'(1X,"WI",a)') 'Resulting, Combined Multipliers for "Best" Wind Class and by Supply Curve Step'
         write(IORNREPT,'(1X,"WN",a,<unrgns>f10.3)') 'Combined, Step 1      ',(UTCSFN(nr,WTech,1),nr=1,unrgns)
         write(IORNREPT,'(1X,"WN",a,<unrgns>f10.3)') 'Combined, Step 2      ',(UTCSFN(nr,WTech,2),nr=1,unrgns)
         write(IORNREPT,'(1X,"WN",a,<unrgns>f10.3)') 'Combined, Step 3      ',(UTCSFN(nr,WTech,3),nr=1,unrgns)

!         write(IORNREPT,'(1X,"WL",a,<unrgns>f10.3)') 'Combined, Step 1      ',(UTCSFN(nr,WTech_WL,1),nr=1,unrgns)
!         write(IORNREPT,'(1X,"WL",a,<unrgns>f10.3)') 'Combined, Step 2      ',(UTCSFN(nr,WTech_WL,2),nr=1,unrgns)
!         write(IORNREPT,'(1X,"WL",a,<unrgns>f10.3)') 'Combined, Step 3      ',(UTCSFN(nr,WTech_WL,3),nr=1,unrgns)

!        Write out where (which wind classes and buffer zones) the supply curve capacities come from.

         write(IORNREPT,'(1X,"WI",/,a,i4)') 'Sources for Supply Curve Capacity (MW) for ',curcalyr
         do stp=1,msptmx
            write(IORNREPT,'(1X,"WI",a,i4)') 'Source of Capacity (with Cost Rank by Wind Class and Buffer Zone) for Step ',stp
            write(IORNREPT,'(1X,"WI",5x,a)') rept_head
            do wc=1,mnumcl
               do bf=1,mnumbf
                  IF (WCapMax(mnumnr,curiyr,wc,bf) .GT. 0.00001) &
                     write(IORNREPT,'(1X,"WN",a1,i1,a1,i1,1x,<unrgns>(f10.0,i3))') 'C',7-wc,'Z',bf,(SCapInc(stp,nr,wc,bf),Rank(nr,wc,bf),nr=1,unrgns)
               end do
            end do

            do wc=1,mnumcl
               do bf=1,mnumbf
!                  IF (WCapMax(mnumnr,curiyr,wc,bf) .GT. 0.00001) &
!                     write(IORNREPT,'(1X,"WL",a1,i1,a1,i1,1x,<unrgns>(f10.0,i3))') 'C',7-wc,'Z',bf,(SCapInc_WL(stp,nr,wc,bf),Rank_WL(nr,wc,bf),nr=1,unrgns)
               end do
            end do
         end do
         write(IORNREPT,'(1X,"WI",/,a,i4)') 'Miscellaneous Wind Variables by Region for ',curcalyr
         write(IORNREPT,'(1X,"WI",/,a)') 'Transmission & Distribution Costs in "Best" Buffer Zone'
         write(IORNREPT,'(1X,"WI",20x,a)') rept_head
         write(IORNREPT,'(1X,"WN",a,<unrgns>f10.2)') 'T&D Costs             ',(WWNTD(nr,curiyr),nr=1,unrgns)
!         write(IORNREPT,'(1X,"WL",a,<unrgns>f10.2)') 'T&D Costs             ',(WWLTD(nr,curiyr),nr=1,unrgns)


      end if

      if (curiyr.eq.LASTYR) then
         FYR = UESTYR-UHBSYR
         do nr=1,mnumnr
            if(nr.ne.ALASKA.and.nr.ne.HAWAII) then
               write(IORNREPT,'(1X,"WI",a)') 'Sx>'
               write(IORNREPT,'(1X,"WI",a,a,i2,13x,<LASTYR-FYR+1>(6x,i4))') 'Sx>','Region ',nr,(yr+1989,yr=FYR,LASTYR)
               if(nr.le.unrgns) then
                  write(IORNREPT,'(1X,"WN",a,a,<LASTYR-FYR+1>i10)') 'Sx>',  'Best Wind Class                   ',(7-WCurCl(nr,yr),yr=FYR,LASTYR)
                  write(IORNREPT,'(1X,"WN",a,a,<LASTYR-FYR+1>i10)')'Sx>',   'Best Buff Zone                    ',(WCurBf(nr,yr),yr=FYR,LASTYR)
                  write(IORNREPT,'(1X,"WN",a,a,<LASTYR-FYR+1>f10.4)') 'Sx>','Cost Of Electricity               ',(AnnCost(nr,yr,WCurCl(nr,yr),WCurBf(nr,yr)),yr=FYR,LASTYR)
                  write(IORNREPT,'(1X,"WN",a,a,<LASTYR-FYR+1>f10.0)') 'Sx>','Cap Seen by ECP                   ',(WCAWIEL(nr,yr),yr=FYR,LASTYR)
                  write(IORNREPT,'(1X,"WN",a,a,<LASTYR-FYR+1>f10.4)') 'Sx>','Long-Term Mult                    ',(LTMult(nr,yr),yr=FYR,LASTYR)
               endif
               write(IORNREPT,'(1X,"WN",a,a)') 'Sx>','New Installed Capacity'
               write(IORNREPT,'(1X,"WN",a,a,<LASTYR-FYR+1>f10.1)') 'Sx>','  Planned Builds      ',(CapPlnBld(nr,yr),yr=FYR,LASTYR)
               write(IORNREPT,'(1X,"WN",a,a,<LASTYR-FYR+1>f10.1)') 'Sx>','  Committed-Now Built ',(CapNewBld(nr,yr),yr=FYR,LASTYR)
               write(IORNREPT,'(1X,"WN",a,a,<LASTYR-FYR+1>f10.1)') 'Sx>','  Total New           ',(CapAdded(nr,yr),yr=FYR,LASTYR)
               write(IORNREPT,'(1X,"WN",a,a)') 'Sx>','Cumulative Installed Capacity'
               write(IORNREPT,'(1X,"WN",a,a,<LASTYR-FYR+1>f10.1)') 'Sx>','  Total Cumulative    ',(CapInstall(nr,yr),yr=FYR,LASTYR)
               write(IORNREPT,'(1X,"WN",a,a)') 'Sx>','Committed Capacity'
               write(IORNREPT,'(1X,"WN",a,a,<LASTYR-FYR+1>f10.1)') 'Sx>','  Committed This Year ',(CapCommit(nr,yr),yr=FYR,LASTYR)
               do i=1,NLead-1
                  write(IORNREPT,'(1X,"WN",a,a,i1,a,<LASTYR-FYR+1>f10.1)') 'Sx>','  Committed Year-',i,'    ',(CapCommit(nr,yr-i),yr=FYR,LASTYR)
               end do
               write(IORNREPT,'(1X,"WN",a,a,<LASTYR-FYR+1>f10.1)') 'Sx>','  Total Committed     ',(CapCmtTot(nr,yr),yr=FYR,LASTYR)
               write(IORNREPT,'(1X,"WN",a,a)') 'Sx>','Cumulative Installed Plus Committed Capacity'
               write(IORNREPT,'(1X,"WN",a,a,<LASTYR-FYR+1>f10.1)') 'Sx>','  Total               ',(CapIandC(nr,yr),yr=FYR,LASTYR)
            endif
         end do
         ! do nr=1,mnumnr
            ! if(nr.ne.ALASKA.and.nr.ne.HAWAII) then
               ! if(nr.le.unrgns) then
                  ! write(IORNREPT,'(1X,"WL",a,a,<LASTYR-FYR+1>i10)') 'Sx>',  'Best Wind Class                   ',(7-WCurCl_WL(nr,yr),yr=FYR,LASTYR)
                  ! write(IORNREPT,'(1X,"WL",a,a,<LASTYR-FYR+1>i10)')'Sx>',   'Best Buff Zone                    ',(WCurBf_WL(nr,yr),yr=FYR,LASTYR)
                  ! write(IORNREPT,'(1X,"WL",a,a,<LASTYR-FYR+1>f10.4)') 'Sx>','Cost Of Electricity               ',(AnnCost_WL(nr,yr,WCurCl(nr,yr),WCurBf(nr,yr)),yr=FYR,LASTYR)
                  ! write(IORNREPT,'(1X,"WL",a,a,<LASTYR-FYR+1>f10.0)') 'Sx>','Cap Seen by ECP                   ',(WCAWLEL(nr,yr),yr=FYR,LASTYR)
                  ! write(IORNREPT,'(1X,"WL",a,a,<LASTYR-FYR+1>f10.4)') 'Sx>','Long-Term Mult                    ',(LTMult_WL(nr,yr),yr=FYR,LASTYR)
               ! endif
               ! write(IORNREPT,'(1X,"WL",a,a)') 'Sx>','New Installed Capacity'
               ! write(IORNREPT,'(1X,"WL",a,a,<LASTYR-FYR+1>f10.1)') 'Sx>','  Planned Builds      ',(CapPlnBld_WL(nr,yr),yr=FYR,LASTYR)
               ! write(IORNREPT,'(1X,"WL",a,a,<LASTYR-FYR+1>f10.1)') 'Sx>','  Committed-Now Built ',(CapNewBld_WL(nr,yr),yr=FYR,LASTYR)
               ! write(IORNREPT,'(1X,"WL",a,a,<LASTYR-FYR+1>f10.1)') 'Sx>','  Total New           ',(CapAdded_WL(nr,yr),yr=FYR,LASTYR)
               ! write(IORNREPT,'(1X,"WL",a,a)') 'Sx>','Cumulative Installed Capacity'
               ! write(IORNREPT,'(1X,"WL",a,a,<LASTYR-FYR+1>f10.1)') 'Sx>','  Total Cumulative    ',(CapInstall_WL(nr,yr),yr=FYR,LASTYR)
               ! write(IORNREPT,'(1X,"WL",a,a)') 'Sx>','Committed Capacity'
               ! write(IORNREPT,'(1X,"WL",a,a,<LASTYR-FYR+1>f10.1)') 'Sx>','  Committed This Year ',(CapCommit_WL(nr,yr),yr=FYR,LASTYR)
               ! do i=1,NLead-1
                  ! write(IORNREPT,'(1X,"WL",a,a,i1,a,<LASTYR-FYR+1>f10.1)') 'Sx>','  Committed Year-',i,'    ',(CapCommit_WL(nr,yr-i),yr=FYR,LASTYR)
               ! end do
               ! write(IORNREPT,'(1X,"WL",a,a,<LASTYR-FYR+1>f10.1)') 'Sx>','  Total Committed     ',(CapCmtTot_WL(nr,yr),yr=FYR,LASTYR)
               ! write(IORNREPT,'(1X,"WL",a,a)') 'Sx>','Cumulative Installed Plus Committed Capacity'
               ! write(IORNREPT,'(1X,"WL",a,a,<LASTYR-FYR+1>f10.1)') 'Sx>','  Total               ',(CapIandC_WL(nr,yr),yr=FYR,LASTYR)
            ! endif
         ! end do

         do nr=1,mnumnr
            if(nr.ne.ALASKA.and.nr.ne.HAWAII) then
               write(IORNREPT,'(1X,"WI",a)') 'Nd>'
               write(IORNREPT,'(1X,"WI",a,a,i2)') 'Nd>','Cumulative Installed Capacity (ICapCum)  Region ',nr
               write(IORNREPT,'(1X,"WI",a,a,i2,13x,<LASTYR-FYR+1>(6x,i4))') 'Nd>','Region ',nr,(yr+1989,yr=FYR,LASTYR)
               do wc=1,mnumcl
                  do bf=1,mnumbf
                     IF (WCapMax(mnumnr,curiyr,wc,bf) .GT. 0.00001) &
                        write(IORNREPT,'(1X,"WN",a,2x,a,i1,a,i1,16x,<LASTYR-FYR+1>f10.1)') 'Nd>','C',7-wc,'Z',bf,(ICapCum(nr,yr,wc,bf),yr=FYR,LASTYR)
                  end do
               end do
               write(IORNREPT,'(1X,"WN",a,2x,a,i2,3x,<LASTYR-FYR+1>f10.1)') 'Nd>','Total - Region ',nr,(CapInstall(nr,yr),yr=FYR,LASTYR)

               ! do wc=1,mnumcl
                  ! do bf=1,mnumbf
                     ! IF (WCapMax(mnumnr,curiyr,wc,bf) .GT. 0.00001) &
                        ! write(IORNREPT,'(1X,"WL",a,2x,a,i1,a,i1,16x,<LASTYR-FYR+1>f10.1)') 'Nd>','C',7-wc,'Z',bf,(ICapCum_WL(nr,yr,wc,bf),yr=FYR,LASTYR)
                  ! end do
               ! end do
               ! write(IORNREPT,'(1X,"WL",a,2x,a,i2,3x,<LASTYR-FYR+1>f10.1)') 'Nd>','Total - Region ',nr,(CapInstall_WL(nr,yr),yr=FYR,LASTYR)
            endif   !not rgns Alaska and Hawaii
         end do   ! nr loop
      end if

      return
      end


!******************************************************************
!     Subroutine SolarMisc decrements the wind resources given the new planned capacity and
!     determines the new "best" wind class and buffer zone.  It also converts available swept land
!     area into megawatts of available capacity and calculates capacity factors by time slice.

      subroutine SolarMisc

      implicit none
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'ecpcntl'
      include 'control'
      include 'wrenew'
      include 'wwind'
      include 'wrenio'
      include 'rencntl'
      include 'dsmdimen'
      include 'dsmtfecp'
      include 'entcntl'
      include 'udatout'
      include 'uecpout'
      include 'uefdout'

      integer yr,nr,wc,wc_SO,WTech,WTech_SO,WTech_PV,WTech_PT,s,stp,t,Numxc,Numnc,T_RNUM
      integer x,Done,Done_SO,Done_PV,Done_PT,lev,n,i,h,m,d
      real PI,XTot,YTot
      parameter(PI = 3.141593)
      real Ratio,Epsi,MaxDiff,AvlDiff
      real CapOut,CapOut_SO,CapOut_PV,CapOut_PT,ZLTElas_SO,ZLTElas_PV,ZLTElas_PT,Ralph(mnumnr),CapTemp

!     real SuppCapMin,SuppCap,Value,CapFrac

      real SuppCap,Value,Value_SO,CapFrac,tmpcf


!     integer XSwitch

      real NatWnCap,NatSOCap,CFLrn,CFLrn_SO
      real BaseLdCap,WnProb,WnProb_SO,AllowWnCap,AllowWnCap_SO,ExcessWn,ExcessWn_SO,NWn,NWn_SO,FullWn,FullWn_SO,WnRegStd,WnRegStd_SO,BaseCF,BaseCF_SO,InstWind,InstWind_SO,AveWnCap,AveWnCap_SO, &
         CoalAvail,NucAvail,XCoalAvail,NCoalAvail
      integer JDoCFA,JDoCFB

      data Epsi / 0.000001 /
!      WTech = 10   !Wind technology number. - Shouldn't I be determining this instead of hard - wired?
      WTech_SO = 7
      Wtech_PV = 8
      Wtech_PT = 9
      write( * , * )'WINDDBG - starting solarmisc3 ',trim(scen_date),' ',curiyr


!     NOTE - At first blush, the stuff at the end of the input subroutine should go here because we have
!     now modified CF and Area. But that would only change the amount of capacity from the fixed land
!     area in each year and am not sure want to do that. The change in the CF will be used below this point
!     in subsequent routines, and that may be all we really need or want.

!     This is new accounting that takes into account the years in which each piece of capacity is added.
!     This was changed in August 2004.

      if (curcalyr  .le. UESTYR ) then
         do yr = 1 , curiyr
            do nr = 1 , unrgns
            end do
         end do
      end if

      if (curcalyr .le. UESTYR ) then
         do yr = 1 , curiyr
               CapInstall_SO(:,yr) = 0.0
               CapCommit_SO(:,yr) = 0.0
               CapAdded_SO(:,yr) = 0.0
               CapNewBld_SO(:,yr) = 0.0
               CapPlnBld_SO(:,yr) = 0.0
               CapCmtTot_SO(:,yr) = 0.0
               CapIandC_SO(:,yr) = 0.0

               CapInstall_PV(:,yr) = 0.0
               CapCommit_PV(:,yr) = 0.0
               CapAdded_PV(:,yr) = 0.0
               CapNewBld_PV(:,yr) = 0.0
               CapPlnBld_PV(:,yr) = 0.0
               CapCmtTot_PV(:,yr) = 0.0
               CapIandC_PV(:,yr) = 0.0

               CapInstall_PT(:,yr) = 0.0
               CapCommit_PT(:,yr) = 0.0
               CapAdded_PT(:,yr) = 0.0
               CapNewBld_PT(:,yr) = 0.0
               CapPlnBld_PT(:,yr) = 0.0
               CapCmtTot_PT(:,yr) = 0.0
               CapIandC_PT(:,yr) = 0.0
         end do
      end if

!     Do all the stock and flow accounting for each region.

      do nr = 1 , mnumnr
!        Get the installed capacity from the electricity model. It is the sum of utility and non - utility capacity.

         CapInstall_SO(nr,curiyr) = amax1(0.0 , (UCAPSTU(nr,curiyr)+UCAPSTN(nr,curiyr))*1000)
         UTRSCU(nr,WTech_SO) = CapInstall_SO(nr,curiyr)

         CapInstall_PV(nr,curiyr) = amax1(0.0 ,  (UCAPPVU(nr,curiyr)+UCAPPVN(nr,curiyr))*1000)
         UTRSCU(nr,WTech_PV) = CapInstall_PV(nr,curiyr)

         CapInstall_PT(nr,curiyr) = amax1(0.0 ,  (UCAPPTU(nr,curiyr)+UCAPPTN(nr,curiyr))*1000)
         UTRSCU(nr,WTech_PT) = CapInstall_PT(nr,curiyr)

!        Get the committed capacity and the lead time from the elecctricity model.

         NLead_SO = UPPLYR(WISO)
         NLead_PV = UPPLYR(WIPV)
         NLead_PT = UPPLYR(WIPT)

         CapCommit_SO(nr,curiyr) = UADDSTD(nr,curiyr + NLead_SO)
         CapCommit_PV(nr,curiyr) = UADDSTD(nr,curiyr + NLead_PV)
         CapCommit_PT(nr,curiyr) = UADDSTD(nr,curiyr + NLead_PT)

!        Capacity added is the difference between the total capacity installed this year minus last year.

         CapAdded_SO(nr,curiyr) = CapInstall_SO(nr,curiyr) - CapInstall_SO(nr,curiyr - 1)
         CapAdded_PV(nr,curiyr) = CapInstall_PV(nr,curiyr) - CapInstall_PV(nr,curiyr - 1)
         CapAdded_PT(nr,curiyr) = CapInstall_PT(nr,curiyr) - CapInstall_PT(nr,curiyr - 1)


!        New builds is equal to what was committed NLead number of years ago.

         CapNewBld_SO(nr,curiyr) = CapCommit_SO(nr,curiyr - NLead_SO)
         CapNewBld_PV(nr,curiyr) = CapCommit_PV(nr,curiyr - NLead_PV)
         CapNewBld_PT(nr,curiyr) = CapCommit_PT(nr,curiyr - NLead_PT)

!        Planned capacity is the difference between the capacity added and the new builds.

         CapPlnBld_SO(nr,curiyr) = CapAdded_SO(nr,curiyr) - CapNewBld_SO(nr,curiyr)
         CapPlnBld_PV(nr,curiyr) = CapAdded_PV(nr,curiyr) - CapNewBld_PV(nr,curiyr)
         CapPlnBld_PT(nr,curiyr) = CapAdded_PT(nr,curiyr) - CapNewBld_PT(nr,curiyr)

!        Total capacity committed is the committed capacity in this year and in previous years not yet built.


         do i = 0,NLead_SO - 1
            CapCmtTot_SO(nr,curiyr) = CapCmtTot_SO(nr,curiyr) + CapCommit_SO(nr,curiyr - i)
         end do
         do i = 0,NLead_PV - 1
             CapCmtTot_PV(nr,curiyr) = CapCmtTot_PV(nr,curiyr) + CapCommit_PV(nr,curiyr - i)
         end do
         do i = 0,NLead_PT - 1
             CapCmtTot_PT(nr,curiyr) = CapCmtTot_PT(nr,curiyr) + CapCommit_PT(nr,curiyr - i)
         end do

!        Total capacity installed plus total capacity committed.

         CapIandC_SO(nr,curiyr) = CapInstall_SO(nr,curiyr) + CapCmtTot_SO(nr,curiyr)
         CapIandC_PV(nr,curiyr) = CapInstall_PV(nr,curiyr) + CapCmtTot_PV(nr,curiyr)
         CapIandC_PT(nr,curiyr) = CapInstall_PT(nr,curiyr) + CapCmtTot_PT(nr,curiyr)

         WRITE (18,3516) CURIRUN, CURIYR+1989, CURITR, nr, WISO, WTECH_SO, NLead_SO, CapIandC_SO(nr,curiyr), CapCmtTot_SO(nr,curiyr), CapPlnBld_SO(nr,curiyr), CapNewBld_SO(nr,curiyr), &
            CapAdded_SO (nr,curiyr), CapCommit_SO(nr,curiyr), CapInstall_SO(nr,curiyr), UCAPSTU(nr,curiyr-1), UCAPSTU(nr,curiyr), UADDSTD(nr,curiyr), UADDSTD(nr,curiyr+NLead)
 3516    FORMAT (1X, "solarmisc3_Capacity",":SO",7(":",I5),11(":",F21.6))

         WRITE (18,3517) CURIRUN, CURIYR+1989, CURITR, nr, WIPV, WTECH_PV, NLead_PV, CapIandC_PV(nr,curiyr), CapCmtTot_PV(nr,curiyr), CapPlnBld_PV(nr,curiyr), CapNewBld_PV(nr,curiyr), &
             CapAdded_PV (nr,curiyr), CapCommit_PV(nr,curiyr), CapInstall_PV(nr,curiyr), UCAPPVU(nr,curiyr-1), UCAPPVU(nr,curiyr), UADDPVD(nr,curiyr), UADDPVD(nr,curiyr+NLead)
 3517    FORMAT (1X, "solarmisc3_Capacity",":PV",7(":",I5),11(":",F21.6))

         WRITE (18,3518) CURIRUN, CURIYR+1989, CURITR, nr, WIPT, WTECH_PT, NLead_PT, CapIandC_PT(nr,curiyr), CapCmtTot_PT(nr,curiyr), CapPlnBld_PT(nr,curiyr), CapNewBld_PT(nr,curiyr), &
             CapAdded_PT (nr,curiyr), CapCommit_PT(nr,curiyr), CapInstall_PT(nr,curiyr), UCAPPTU(nr,curiyr-1), UCAPPTU(nr,curiyr), UADDPTD(nr,curiyr), UADDPTD(nr,curiyr+NLead)
 3518    FORMAT (1X, "solarmisc3_Capacity",":PT",7(":",I5),11(":",F21.6))

!        Increment the available, remaining capacity for the change ("growth") in original capacity. In general we
!        have constructed the model so original capacity is constant over time, so this doesn't usually matter.
!        However, if the growth in the original maximum is negative, then we need to be sure that if we have already
!        used some capacity in that category then we don't say there is a negative amount available.

          Do   wc = 1,mnumsl

            MaxDiff = Sopower(nr,curiyr,wc) - Sopower(nr,curiyr - 1,wc)                        !landarea
            if ((ICapAvl_SO(nr,curiyr - 1,wc) + MaxDiff) .gt. 0.0) then
               ICapAvl_SO(nr,curiyr,wc) = ICapAvl_SO(nr,curiyr - 1,wc) + MaxDiff               !landarea
            else
               ICapAvl_SO(nr,curiyr,wc) = 0.0
            end if
            if ((WCapAvl_SO(nr,curiyr - 1,wc) + MaxDiff) .gt. 0.0) then
               WCapAvl_SO(nr,curiyr,wc) = WCapAvl_SO(nr,curiyr - 1,wc) + MaxDiff               !lsndarea
            else
               WCapAvl_SO(nr,curiyr,wc) = 0.0
               AvlDiff = WCapAvl_SO(nr,curiyr - 1,wc)
               if (AvlDiff .gt. 0.0) then
                  Sopower(nr,curiyr,wc) = Sopower(nr,curiyr - 1,wc) - AvlDiff
               else
                  Sopower(nr,curiyr,wc) = Sopower(nr,curiyr - 1,wc)
               end if
            end if
         end do !wc

!        Now I need to allocate the various capacities into the wind classes and transmission
!        buffer zones. These need to be allocated because the wind model only knows how much
!        overall capacity had been chosen by the electricity model - it has to work backwards
!        to determine which wind classes and buffer zones it all came out of. Moreover, it
!        has to pay attention to the yearly timing of each piece, because the ranking of the
!        wind classes and buffer zones can change over time.
!        A key thing to remember is that the builds from electricity are actually the previous year.
!        The total new installed (includes planned builds and previously committed that is now built)
!        was committed NLead number of years earlier plus one more year because they are only being
!        shown to us now. So it is allocated using the rankings from NLead + 1 number of years earlier.
!        These will be cumulated over time to get the overall total installed.
!        The new committed "this year" is allocated using the rankings last year. Committed in
!        previous years but not yet built is allocated using the rankings in the respective year.
!        These will be cumulated over time to get the overall total committed and then added to
!        the total installed to get the total installed plus committed.

!        Total New Installed. The new is in ICapInc, the cumulative is in ICapCum, and the available is in ICapAvl.
!        Clear out the totals.

           do wc = 1 , mnumsl
              ICapInc_SO(nr,curiyr,wc) = 0.0
           end do
           CapOut_SO = CapAdded_SO(nr,curiyr)

           do wc = 1 , mnumsl
             ICapInc_PV(nr,curiyr,wc) = 0.0
           end do
           CapOut_PV = CapAdded_PV(nr,curiyr)

           do wc = 1 , mnumsl
              ICapInc_PT(nr,curiyr,wc) = 0.0
           end do
           CapOut_PT = CapAdded_PT(nr,curiyr)

         if (CapOut_SO .ge. 0.0) then

!           Do this if the amount of new installed capacity is greater than zero.

            do n = 1 , RNum_SO
               wc = Rwc_SO(nr,n,curiyr - (NLead + 1))
               IF (wc.ne.0) THEN
                 AvlDiff = ICapAvl_SO(nr,curiyr,wc)
                 if (ICapAvl_SO(nr,curiyr,wc) .gt. 0.0) then
                    if (ICapAvl_SO(nr,curiyr,wc) .ge. CapOut_SO/Pwrden_ST) then
                       ICapInc_SO(nr,curiyr,wc) = CapOut_SO                                                 !capacity
                       ICapAvl_SO(nr,curiyr,wc) = ICapAvl_SO(nr,curiyr,wc) - CapOut_SO / Pwrden_ST          !landarea
                       CapOut_SO = 0.0
                    else
                       ICapInc_SO(nr,curiyr,wc) = ICapAvl_SO(nr,curiyr,wc) * Pwrden_ST                       !capacity
                       CapOut_SO = CapOut_SO - ICapAvl_SO(nr,curiyr,wc) * Pwrden_ST                         !capacity
                       ICapAvl_SO(nr,curiyr,wc) = 0.0
                    endif

                  WRITE(18,3519) CURIRUN, CURIYR+1989, CURITR, nr, WISO, WTECH_SO, n, 7-wc, 1, AvlDiff, CapAdded_SO(nr,curiyr), CapOut_SO, ICapAvl_SO(nr,curiyr,wc), ICapInc_SO(nr,curiyr,wc)
 3519             FORMAT (1X,"solarMISC3_INCCAP",":SO",9(":",I5),5(":",F21.6))

                 endif
               ENDIF
            end do
         else

!           Do this if the amount of new installed capacity is negative (retirements?).

            do n = 1 , RNum_SO
               wc = Rwc_SO(nr,n,curiyr - (NLead + 1))
               IF (wc.ne.0) THEN
                 if (ICapAvl_SO(nr,curiyr,wc) .gt. 0.0) then
                    ICapInc_SO(nr,curiyr,wc) = CapOut_SO                                                   !capacity
                    CapOut_SO = 0.0
                    ICapAvl_SO(nr,curiyr,wc) = ICapAvl_SO(nr,curiyr,wc) - ICapInc_SO(nr,curiyr,wc) * Pwrden_ST !landarea

                    WRITE(18,3519) CURIRUN, CURIYR+1989, CURITR, nr, WISO, WTECH_SO, n, 7-wc, 1, AvlDiff, CapAdded_SO(nr,curiyr), CapOut_SO, ICapAvl_SO(nr,curiyr,wc), ICapInc_SO(nr,curiyr,wc)

                 endif
               ENDIF
            end do
         endif

         if (CapOut_PV .ge. 0.0) then

         !           Do this if the amount of new installed capacity is greater than zero.

             do n = 1 , RNum_PV
                wc = Rwc_PV(nr,n,curiyr - (NLead + 1))
                IF (wc.ne.0) THEN
                  AvlDiff = ICapAvl_SO(nr,curiyr,wc)
                  if (ICapAvl_SO(nr,curiyr,wc) .gt. 0.0) then
                     if (ICapAvl_SO(nr,curiyr,wc) .ge. CapOut_PV/Pwrden_PV) then
                        ICapInc_PV(nr,curiyr,wc) = CapOut_PV                                           !capacity
                        ICapAvl_SO(nr,curiyr,wc) = ICapAvl_SO(nr,curiyr,wc) - CapOut_PV /  Pwrden_PV  ! landarear
                        CapOut_PV = 0.0
                     else
                        ICapInc_PV(nr,curiyr,wc) = ICapAvl_SO(nr,curiyr,wc) * Pwrden_PV                !capacity
                        CapOut_PV = CapOut_PV - ICapAvl_SO(nr,curiyr,wc)* Pwrden_PV                    !capacity
                        ICapAvl_SO(nr,curiyr,wc) = 0.0
                     endif

                   WRITE(18,3520) CURIRUN, CURIYR+1989, CURITR, nr, WIPV, WTECH_PV, n, 7-wc, 1, AvlDiff, CapAdded_PV(nr,curiyr), CapOut_PV, ICapAvl_SO(nr,curiyr,wc), ICapInc_PV(nr,curiyr,wc)
  3520             FORMAT (1X,"solarmisc3_INCCAP",":PV",9(":",I5),5(":",F21.6))

                  endif
                ENDIF
             end do
          else

     !           Do this if the amount of new installed capacity is negative (retirements?).

             do n = 1 , RNum_PV
                wc = Rwc_PV(nr,n,curiyr - (NLead + 1))
                IF (wc.ne.0) THEN
                  if (ICapAvl_SO(nr,curiyr,wc) .gt. 0.0) then
                     ICapInc_PV(nr,curiyr,wc) = CapOut_PV                                                       !capacity
                     CapOut_PV = 0.0
                     ICapAvl_SO(nr,curiyr,wc) = ICapAvl_SO(nr,curiyr,wc) - ICapInc_PV(nr,curiyr,wc) * Pwrden_PV !landarea

                     WRITE(18,3520) CURIRUN, CURIYR+1989, CURITR, nr, WIPV, WTECH_PV, n, 7-wc, 1, AvlDiff, CapAdded_PV(nr,curiyr), CapOut_PV, ICapAvl_SO(nr,curiyr,wc), ICapInc_PV(nr,curiyr,wc)

                  endif
                ENDIF
             end do
         endif

         if (CapOut_PT .ge. 0.0) then

         !           Do this if the amount of new installed capacity is greater than zero.

             do n = 1 , RNum_PT
                wc = Rwc_PT(nr,n,curiyr - (NLead + 1))
                IF (wc.ne.0) THEN
                  AvlDiff = ICapAvl_SO(nr,curiyr,wc)
                  if (ICapAvl_SO(nr,curiyr,wc) .gt. 0.0) then
                     if (ICapAvl_SO(nr,curiyr,wc) .ge. CapOut_PT) then
                        ICapInc_PT(nr,curiyr,wc) = CapOut_PT                                                      !capacity
                        ICapAvl_SO(nr,curiyr,wc) = ICapAvl_SO(nr,curiyr,wc) - CapOut_PT /  Pwrden_PT              !landarea
                        CapOut_PT = 0.0
                     else
                        ICapInc_PT(nr,curiyr,wc) = ICapAvl_SO(nr,curiyr,wc) * Pwrden_PT                           !capacity
                        CapOut_PT = CapOut_PT - ICapAvl_SO(nr,curiyr,wc) * Pwrden_PT                              !capacity
                        ICapAvl_SO(nr,curiyr,wc) = 0.0
                     endif
                             WRITE(18,3521) CURIRUN, CURIYR+1989, CURITR, nr, WIPT, WTECH_PT, n, 7-wc, 1, AvlDiff, CapAdded_PT(nr,curiyr), CapOut_PT, ICapAvl_SO(nr,curiyr,wc), ICapInc_PT(nr,curiyr,wc)
  3521             FORMAT (1X,"solarmisc3_INCCAP",":PT",9(":",I5),5(":",F21.6))

                  endif
                ENDIF
             end do
          else

         !           Do this if the amount of new installed capacity is negative (retirements?).

             do n = 1 , RNum_PT
                wc = Rwc_PT(nr,n,curiyr - (NLead + 1))
                IF (wc.ne.0) THEN
                  if (ICapAvl_SO(nr,curiyr,wc) .gt. 0.0) then
                     ICapInc_PT(nr,curiyr,wc) = CapOut_PT                                                          !capacity
                     CapOut_PT = 0.0
                     ICapAvl_SO(nr,curiyr,wc) = ICapAvl_SO(nr,curiyr,wc) - ICapInc_PT(nr,curiyr,wc) * Pwrden_PT    !landarea

                             WRITE(18,3521) CURIRUN, CURIYR+1989, CURITR, nr, WIPT, WTECH_PT, n, 7-wc, 1, AvlDiff, CapAdded_PT(nr,curiyr), CapOut_PT, ICapAvl_SO(nr,curiyr,wc), ICapInc_PT(nr,curiyr,wc)

                  endif
                ENDIF
             end do
         endif

!        Add the increment to the cumulative running total over the years for the new technology.

         do wc = 1 , mnumsl
            ICapCum_SO(nr,curiyr,wc) = ICapCum_SO(nr,curiyr - 1,wc) + ICapInc_SO(nr,curiyr,wc)       !capacity
         end do

         do wc = 1 , mnumsl
            ICapCum_PV(nr,curiyr,wc) = ICapCum_PV(nr,curiyr - 1,wc) + ICapInc_PV(nr,curiyr,wc)      !capacity
         end do

         do wc = 1 , mnumsl
            ICapCum_PT(nr,curiyr,wc) = ICapCum_PT(nr,curiyr - 1,wc) + ICapInc_PT(nr,curiyr,wc)      !capacity
         end do

!        Add in the committed capacity one at a time starting with the oldest.
!        The new is in WCapInc, the cumulative is in WCapCum, and the available is in WCapAvl.
!        Note that we use rankings one year back for the committments this year (because this
!        is really the beginning of the year - the committments are from last year even though
!        they are indexed for this year...). This is also convienent because we don't have
!        rankings for this year yet (it is the beginning of the year). This is also why the
!        subscripts for the committed capacity and the rankings are different by one year...
!        First put ICapAvl into WCapAvl so that we start from ICapAvl and add the increment.

         do wc = 1 , mnumsl
            WCapAvl_SO(nr,curiyr,wc) = ICapAvl_SO(nr,curiyr,wc)   !landarea
            WCapInc_SO(nr,curiyr,wc) = 0.0
         end do

         do i = NLead_SO,1, - 1
            CapOut_SO = CapCommit_SO(nr,curiyr - (i - 1))          !capacity
            do n = 1,RNum_SO

               wc = Rwc_SO(nr,n,curiyr - i)
               IF (wc.ne.0) THEN
                 if (WCapAvl_SO(nr,curiyr,wc) .gt. 0.0) then
                    if (WCapAvl_SO(nr,curiyr,wc) .ge. CapOut_SO/Pwrden_ST)  then                                  !landarea
                       WCapInc_SO(nr,curiyr,wc) = WCapInc_SO(nr,curiyr,wc) + CapOut_SO                            !capacity
                       WCapAvl_SO(nr,curiyr,wc) = WCapAvl_SO(nr,curiyr,wc) - CapOut_SO/Pwrden_ST                  !landarea
                       CapOut_SO = 0.0
                    else
                       WCapInc_SO(nr,curiyr,wc) = WCapInc_SO(nr,curiyr,wc) + WCapAvl_SO(nr,curiyr,wc) * Pwrden_ST  !capacity
                       CapOut_SO = CapOut_SO - WCapAvl_SO(nr,curiyr,wc)* Pwrden_ST                                 !capcity
                       WCapAvl_SO(nr,curiyr,wc) = 0.0
                    endif
                 endif
               ENDIF
            end do
         end do

         do wc = 1 , mnumsl
            WCapAvl_SO(nr,curiyr,wc) = ICapAvl_SO(nr,curiyr,wc)      !landarea
            WCapInc_PV(nr,curiyr,wc) = 0.0
         end do

         do i = NLead_PV,1, - 1
            CapOut_PV = CapCommit_PV(nr,curiyr - (i - 1))
            do n = 1,RNum_PV

               wc = Rwc_PV(nr,n,curiyr - i)
               IF (wc.ne.0) THEN
                 if (WCapAvl_SO(nr,curiyr,wc) .gt. 0.0) then
                    if (WCapAvl_SO(nr,curiyr,wc) .ge. CapOut_PV/Pwrden_PV ) then                                 !landarea
                       WCapInc_PV(nr,curiyr,wc) = WCapInc_PV(nr,curiyr,wc) + CapOut_PV                           !capacity
                       WCapAvl_SO(nr,curiyr,wc) = WCapAvl_SO(nr,curiyr,wc) - CapOut_PV/Pwrden_PV                 !landarea
                       CapOut_PV = 0.0
                    else
                       WCapInc_PV(nr,curiyr,wc) = WCapInc_PV(nr,curiyr,wc) + WCapAvl_SO(nr,curiyr,wc)*Pwrden_PV  !capacity
                       CapOut_PV = CapOut_PV - WCapAvl_SO(nr,curiyr,wc)*Pwrden_PV                                !capacity
                       WCapAvl_SO(nr,curiyr,wc) = 0.0
                    endif
                 endif
               ENDIF
            end do
         end do

!        Add the increment to the cumulative running total over the years for new technology.

         do wc = 1 , mnumsl
            WCapAvl_SO(nr,curiyr,wc) = ICapAvl_SO(nr,curiyr,wc)        !landarea
            WCapInc_PT(nr,curiyr,wc) = 0.0
         end do

         do i = NLead_PT,1, - 1
            CapOut_PT = CapCommit_PT(nr,curiyr - (i - 1))
            do n = 1,RNum_PT

               wc = Rwc_PT(nr,n,curiyr - i)
               IF (wc.ne.0) THEN
                 if (WCapAvl_SO(nr,curiyr,wc) .gt. 0.0) then
                    if (WCapAvl_SO(nr,curiyr,wc) .ge. CapOut_PT/Pwrden_PT) then                                 !landarea
                       WCapInc_PT(nr,curiyr,wc) = WCapInc_PT(nr,curiyr,wc) + CapOut_PT                          !capacity
                       WCapAvl_SO(nr,curiyr,wc) = WCapAvl_SO(nr,curiyr,wc) - CapOut_PT/Pwrden_PT                !landarea
                       CapOut_PT = 0.0
                    else
                       WCapInc_PT(nr,curiyr,wc) = WCapInc_PT(nr,curiyr,wc) + WCapAvl_SO(nr,curiyr,wc)*Pwrden_PT !capacity
                       CapOut_PT = CapOut_PT - WCapAvl_SO(nr,curiyr,wc)*Pwrden_PT                               !capacity
                       WCapAvl_SO(nr,curiyr,wc) = 0.0
                    endif
                 endif
               ENDIF
            end do
         end do


!        Add the increment to the cumulative running total over the years for new technology.

         do wc = 1 , mnumsl
            WCapCum_SO(nr,curiyr,wc) = ICapCum_SO(nr,curiyr,wc) + WCapInc_SO(nr,curiyr,wc)
         end do

         do wc = 1 , mnumsl
            WCapCum_PV(nr,curiyr,wc) = ICapCum_PV(nr,curiyr,wc) + WCapInc_PV(nr,curiyr,wc)
         end do

         do wc = 1 , mnumsl
            WCapCum_PT(nr,curiyr,wc) = ICapCum_PT(nr,curiyr,wc) + WCapInc_PT(nr,curiyr,wc)
         end do

!        Sum up original (maximum) capacity, incremental capacity, and available capacity.

         CapOrig_SO(nr,curiyr) = 0.0
         CapIncr_SO(nr,curiyr) = 0.0
         CapAvail_SO(nr,curiyr) = 0.0
         CapCum_SO(nr,curiyr) = 0.0
         do wc = 1 , mnumsl
            CapOrig_SO(nr,curiyr) = CapOrig_SO(nr,curiyr) + SoPower(nr,curiyr,wc) * Pwrden_ST
            CapIncr_SO(nr,curiyr) = CapIncr_SO(nr,curiyr) + WCapInc_SO(nr,curiyr,wc)
            CapAvail_SO(nr,curiyr) = CapAvail_SO(nr,curiyr) + WCapAvl_SO(nr,curiyr,wc) * Pwrden_ST
            CapCum_SO(nr,curiyr) = CapCum_SO(nr,curiyr) + WCapCum_SO(nr,curiyr,wc)
         end do

         do wc = 1 , mnumsl
            CapIncr_PV(nr,curiyr) = CapIncr_PV(nr,curiyr) + WCapInc_PV(nr,curiyr,wc)
            CapCum_PV(nr,curiyr) = CapCum_PV(nr,curiyr) + WCapCum_PV(nr,curiyr,wc)
         end do

         do wc = 1 , mnumsl
            CapIncr_PT(nr,curiyr) = CapIncr_PT(nr,curiyr) + WCapInc_PT(nr,curiyr,wc)
            CapCum_PT(nr,curiyr) = CapCum_PT(nr,curiyr) + WCapCum_PT(nr,curiyr,wc)
         end do

      end do !       Regions

!     Sum all of these updated capacity categories over regions and classes and zones.

      CapInstall_SO(mnumnr,curiyr) = 0.0
      CapAdded_SO(mnumnr,curiyr)   = 0.0
      CapCommit_SO(mnumnr,curiyr)  = 0.0
      CapNewBld_SO(mnumnr,curiyr)  = 0.0
      CapPlnBld_SO(mnumnr,curiyr)  = 0.0
      CapCmtTot_SO(mnumnr,curiyr)  = 0.0
      CapIandC_SO(mnumnr,curiyr)   = 0.0
      CapIncr_SO(mnumnr,curiyr)    = 0.0
      CapCum_SO(mnumnr,curiyr)     = 0.0
      CapOrig_SO(mnumnr,curiyr)    = 0.0
      CapAvail_SO(mnumnr,curiyr)   = 0.0
      do wc = 1 , mnumsl
         WCapMax_SO(mnumnr,curiyr,wc)  = 0.0
         WCapAvl_SO(mnumnr,curiyr,wc)  = 0.0
         ICapAvl_SO(mnumnr,curiyr,wc)  = 0.0
         WCapInc_SO(mnumnr,curiyr,wc)  = 0.0
         WCapCum_SO(mnumnr,curiyr,wc)  = 0.0
         ICapInc_SO(mnumnr,curiyr,wc)  = 0.0
         ICapCum_SO(mnumnr,curiyr,wc)  = 0.0
      enddo
      do nr = 1 , mnumnr
         CapInstall_SO(mnumnr,curiyr) = CapInstall_SO(mnumnr,curiyr) + CapInstall_SO(nr,curiyr)
         CapAdded_SO(mnumnr,curiyr)   = CapAdded_SO(mnumnr,curiyr)   + CapAdded_SO(nr,curiyr)
         CapCommit_SO(mnumnr,curiyr)  = CapCommit_SO(mnumnr,curiyr)  + CapCommit_SO(nr,curiyr)
         CapNewBld_SO(mnumnr,curiyr)  = CapNewBld_SO(mnumnr,curiyr)  + CapNewBld_SO(nr,curiyr)
         CapPlnBld_SO(mnumnr,curiyr)  = CapPlnBld_SO(mnumnr,curiyr)  + CapPlnBld_SO(nr,curiyr)
         CapCmtTot_SO(mnumnr,curiyr)  = CapCmtTot_SO(mnumnr,curiyr)  + CapCmtTot_SO(nr,curiyr)
         CapIandC_SO(mnumnr,curiyr)   = CapIandC_SO(mnumnr,curiyr)   + CapIandC_SO(nr,curiyr)
         CapIncr_SO(mnumnr,curiyr)    = CapIncr_SO(mnumnr,curiyr)    + CapIncr_SO(nr,curiyr)
         CapCum_SO(mnumnr,curiyr)     = CapCum_SO(mnumnr,curiyr)     + CapCum_SO(nr,curiyr)
         CapOrig_SO(mnumnr,curiyr)    = CapOrig_SO(mnumnr,curiyr)    + CapOrig_SO(nr,curiyr)
         CapAvail_SO(mnumnr,curiyr)   = CapAvail_SO(mnumnr,curiyr)   + CapAvail_SO(nr,curiyr)
         do wc = 1 , mnumsl
            WCapMax_SO(mnumnr,curiyr,wc) = WCapMax_SO(mnumnr,curiyr,wc) + WCapMax_SO(nr,curiyr,wc)
            WCapAvl_SO(mnumnr,curiyr,wc) = WCapAvl_SO(mnumnr,curiyr,wc) + WCapAvl_SO(nr,curiyr,wc)
            ICapAvl_SO(mnumnr,curiyr,wc) = ICapAvl_SO(mnumnr,curiyr,wc) + ICapAvl_SO(nr,curiyr,wc)
            WCapInc_SO(mnumnr,curiyr,wc) = WCapInc_SO(mnumnr,curiyr,wc) + WCapInc_SO(nr,curiyr,wc)
            WCapCum_SO(mnumnr,curiyr,wc) = WCapCum_SO(mnumnr,curiyr,wc) + WCapCum_SO(nr,curiyr,wc)
            ICapInc_SO(mnumnr,curiyr,wc) = ICapInc_SO(mnumnr,curiyr,wc) + ICapInc_SO(nr,curiyr,wc)
            ICapCum_SO(mnumnr,curiyr,wc) = ICapCum_SO(mnumnr,curiyr,wc) + ICapCum_SO(nr,curiyr,wc)
         end do
      end do

      CapInstall_PV(mnumnr,curiyr) = 0.0
      CapAdded_PV(mnumnr,curiyr) = 0.0
      CapCommit_PV(mnumnr,curiyr) = 0.0
      CapNewBld_PV(mnumnr,curiyr) = 0.0
      CapPlnBld_PV(mnumnr,curiyr) = 0.0
      CapCmtTot_PV(mnumnr,curiyr) = 0.0
      CapIandC_PV(mnumnr,curiyr) = 0.0
      CapIncr_PV(mnumnr,curiyr) = 0.0
      CapCum_PV(mnumnr,curiyr) = 0.0
      do wc = 1 , mnumcl
         WCapInc_PV(mnumnr,curiyr,wc) = 0.0
         WCapCum_PV(mnumnr,curiyr,wc) = 0.0
         ICapInc_PV(mnumnr,curiyr,wc) = 0.0
         ICapCum_PV(mnumnr,curiyr,wc) = 0.0
      end do
      do nr = 1 , mnumnr
         CapInstall_PV(mnumnr,curiyr) = CapInstall_PV(mnumnr,curiyr) + CapInstall_PV(nr,curiyr)
         CapAdded_PV(mnumnr,curiyr) = CapAdded_PV(mnumnr,curiyr) + CapAdded_PV(nr,curiyr)
         CapCommit_PV(mnumnr,curiyr) = CapCommit_PV(mnumnr,curiyr) + CapCommit_PV(nr,curiyr)
         CapNewBld_PV(mnumnr,curiyr) = CapNewBld_PV(mnumnr,curiyr) + CapNewBld_PV(nr,curiyr)
         CapPlnBld_PV(mnumnr,curiyr) = CapPlnBld_PV(mnumnr,curiyr) + CapPlnBld_PV(nr,curiyr)
         CapCmtTot_PV(mnumnr,curiyr) = CapCmtTot_PV(mnumnr,curiyr) + CapCmtTot_PV(nr,curiyr)
         CapIandC_PV(mnumnr,curiyr) = CapIandC_PV(mnumnr,curiyr) + CapIandC_PV(nr,curiyr)
         CapIncr_PV(mnumnr,curiyr) = CapIncr_PV(mnumnr,curiyr) + CapIncr_PV(nr,curiyr)
         CapCum_PV(mnumnr,curiyr) = CapCum_PV(mnumnr,curiyr) + CapCum_PV(nr,curiyr)
         do wc = 1 , mnumcl
            WCapInc_PV(mnumnr,curiyr,wc) = WCapInc_PV(mnumnr,curiyr,wc) + WCapInc_PV(nr,curiyr,wc)
            WCapCum_PV(mnumnr,curiyr,wc) = WCapCum_PV(mnumnr,curiyr,wc) + WCapCum_PV(nr,curiyr,wc)
            ICapInc_PV(mnumnr,curiyr,wc) = ICapInc_PV(mnumnr,curiyr,wc) + ICapInc_PV(nr,curiyr,wc)
            ICapCum_PV(mnumnr,curiyr,wc) = ICapCum_PV(mnumnr,curiyr,wc) + ICapCum_PV(nr,curiyr,wc)
         end do
      end do

      CapInstall_PT(mnumnr,curiyr) = 0.0
      CapAdded_PT(mnumnr,curiyr) = 0.0
      CapCommit_PT(mnumnr,curiyr) = 0.0
      CapNewBld_PT(mnumnr,curiyr) = 0.0
      CapPlnBld_PT(mnumnr,curiyr) = 0.0
      CapCmtTot_PT(mnumnr,curiyr) = 0.0
      CapIandC_PT(mnumnr,curiyr) = 0.0
      CapIncr_PT(mnumnr,curiyr) = 0.0
      CapCum_PT(mnumnr,curiyr) = 0.0
      do wc = 1 , mnumcl
         WCapInc_PT(mnumnr,curiyr,wc) = 0.0
         WCapCum_PT(mnumnr,curiyr,wc) = 0.0
         ICapInc_PT(mnumnr,curiyr,wc) = 0.0
         ICapCum_PT(mnumnr,curiyr,wc) = 0.0
      end do
      do nr = 1 , mnumnr
         CapInstall_PT(mnumnr,curiyr) = CapInstall_PT(mnumnr,curiyr) + CapInstall_PT(nr,curiyr)
         CapAdded_PT(mnumnr,curiyr) = CapAdded_PT(mnumnr,curiyr) + CapAdded_PT(nr,curiyr)
         CapCommit_PT(mnumnr,curiyr) = CapCommit_PT(mnumnr,curiyr) + CapCommit_PT(nr,curiyr)
         CapNewBld_PT(mnumnr,curiyr) = CapNewBld_PT(mnumnr,curiyr) + CapNewBld_PT(nr,curiyr)
         CapPlnBld_PT(mnumnr,curiyr) = CapPlnBld_PT(mnumnr,curiyr) + CapPlnBld_PT(nr,curiyr)
         CapCmtTot_PT(mnumnr,curiyr) = CapCmtTot_PT(mnumnr,curiyr) + CapCmtTot_PT(nr,curiyr)
         CapIandC_PT(mnumnr,curiyr) = CapIandC_PT(mnumnr,curiyr) + CapIandC_PT(nr,curiyr)
         CapIncr_PT(mnumnr,curiyr) = CapIncr_PT(mnumnr,curiyr) + CapIncr_PT(nr,curiyr)
         CapCum_PT(mnumnr,curiyr) = CapCum_PT(mnumnr,curiyr) + CapCum_PT(nr,curiyr)
         do wc = 1 , mnumcl
            WCapInc_PT(mnumnr,curiyr,wc) = WCapInc_PT(mnumnr,curiyr,wc) + WCapInc_PT(nr,curiyr,wc)
            WCapCum_PT(mnumnr,curiyr,wc) = WCapCum_PT(mnumnr,curiyr,wc) + WCapCum_PT(nr,curiyr,wc)
            ICapInc_PT(mnumnr,curiyr,wc) = ICapInc_PT(mnumnr,curiyr,wc) + ICapInc_PT(nr,curiyr,wc)
            ICapCum_PT(mnumnr,curiyr,wc) = ICapCum_PT(mnumnr,curiyr,wc) + ICapCum_PT(nr,curiyr,wc)
         end do
      end do

!     This is a new routine that does long - term elasticities within each class category.
!     It is done here because the results are used in the ranking of classes and zones.

      XSwitch = 1
      do nr = 1 , mnumnr
         do wc = 1,mnumsl

!           Sum over classes and then calculate the ratio of resource used to resource available.
!           XCapCum_SO(nr,wc) = ICapCum_SO(nr,curiyr,wc)

            XCapCum_SO(nr,wc) = WCapCum_SO(nr,curiyr,wc)  + WCapCum_PV(nr,curiyr,wc) +  WCapCum_PT(nr,curiyr,wc)
            XCapMax_SO(nr,wc) = SoPower(nr,curiyr,wc) * Pwrden_ST                                                    !capacity
            XRatio_SO(nr,wc) = 0.0
            if (XCapMax_SO(nr,wc) .ge. epsi) XRatio_SO(nr,wc) = XCapCum_SO(nr,wc) / XCapMax_SO(nr,wc)

   !           Look up the elasticity using a table of 5 levels, based upon the level of the ratio.

               XLTElas_SO(nr,wc) = 1.0
               if (UTCSSW(WTech_SO)  .gt.  1) then
                  do lev = 1,MLPTMX
                     if (UTRSFC(nr,WTech_SO,lev) .lt. XRatio_SO(nr,wc)) then
                        XLTElas_SO(nr,wc) = UTCSFC(nr,WTech_SO,lev)
                     end if
                  end do
               end if     !       utcssw gt 1   (i.e. no long term multipliers)

   !           Look up the elasticity using a table of 5 levels, based upon the level of the ratio.

               XLTElas_PV(nr,wc) = 1.0
               if (UTCSSW(WTech_PV)  .gt.  1) then
                  do lev = 1,MLPTMX
                     if (UTRSFC(nr,WTech_PV,lev) .lt. XRatio_PV(nr,wc)) then
                        XLTElas_PV(nr,wc) = UTCSFC(nr,WTech_PV,lev)
                     end if
                  end do
               end if     !       utcssw gt 1   (i.e. no long term multipliers)

    !           Look up the elasticity using a table of 5 levels, based upon the level of the ratio.

               XLTElas_PT(nr,wc) = 1.0
               if (UTCSSW(WTech_PT)  .gt.  1) then
                  do lev = 1,MLPTMX
                     if (UTRSFC(nr,WTech_PT,lev) .lt. XRatio_PT(nr,wc)) then
                        XLTElas_PT(nr,wc) = UTCSFC(nr,WTech_PT,lev)
                     end if
                  end do
               end if     !       utcssw gt 1   (i.e. no long term multipliers)

         end do
      end do

      Call SolarRank
      Call SolarRank_PT
      Call SolarRank_PV

!     Start putting the supply curve together. Determine capacities and multipliers for each step.
!     Determine the total amount of capacity in the supply curve and for each of the three steps.

      SuppCapMin = 100.0

!     The overall supply curve capacity is the amount of existing capacity or the minimum of SuppCapMin.

      SuppCap = amax1( CapInstall_SO(mnumnr,curiyr)+CapInstall_PV(mnumnr,curiyr)+CapInstall_PT(mnumnr,curiyr),SuppCapMin)

!     The capacity for each step is based upon input parameters if the short term elasticity is being
!     used. Otherwise the steps are evenly split within the total supply curve capacity.

      if (UTCSSW(WTech_SO) .eq. 1 .or. UTCSSW(WTech_SO) .eq. 3) then

!        The first step on the curve is the total times the value of USTTHR

         UTCACA_SO(1) = SuppCap * USTTHR(WTech_SO)

!        The remaining steps are evenly split within the total times the value of USTCAMX minus the first step.

         if (msptmx .gt. 1) then
            do stp = 2,msptmx
               UTCACA_SO(stp) = (USTCAMX(WTech_SO) * SuppCap - UTCACA_SO(1)) / (msptmx - 1)
               UTCACA_SO(stp) = amax1(UTCACA_SO(stp),0.0)
            end do
         end if
      elseif (UTCSSW(WTech_SO) .eq. 2) then

!        The steps are evenly split within the total supply curve capacity.
!        do stp = 1,msptmx
!           UTCACA(stp) = (USTCAMX(WTech) * SuppCap) / msptmx
!        end do
!        CRN - July 05, change capacity limit to match ECP short - term elast function.

         do stp = 1,ECP_D_SSTP

!           UTCACA(stp) = (ESTCPLIM(WIWN,stp) * suppcap * 0.001) / msptmx

            UTCACA_SO(stp) = (ESTCPLIM(WISO,stp)) / msptmx

!           UTCACA(stp) = 0

         end do
      end if

      if (UTCSSW(WTech_PV) .eq. 1 .or. UTCSSW(WTech_PV) .eq. 3) then

          UTCACA_PV(1) = SuppCap * USTTHR(WTech_PV)

          if (msptmx .gt. 1) then
             do stp = 2,msptmx
                UTCACA_PV(stp) = (USTCAMX(WTech_PV) * SuppCap - UTCACA_PV(1)) / (msptmx - 1)
                UTCACA_PV(stp) = amax1(UTCACA_PV(stp),0.0)
             end do
          end if
       elseif (UTCSSW(WTech_PV) .eq. 2) then

 !        The steps are evenly split within the total supply curve capacity.
 !        do stp = 1,msptmx
 !           UTCACA_PV(stp) = (USTCAMX(WTech_PV) * SuppCap) / msptmx
 !        end do
 !        CRN - July 05, change capacity limit to match ECP short - term elast function.

          do stp = 1,ECP_D_SSTP

 !           UTCACA_PV(stp) = (ESTCPLIM(WIPV,stp) * suppcap * 0.001) / msptmx

             UTCACA_PV(stp) = (ESTCPLIM(WIPV,stp)) / msptmx

 !           UTCACA_PV(stp) = 0

          end do
      end if

      if (UTCSSW(WTech_PT) .eq. 1 .or. UTCSSW(WTech_PT) .eq. 3) then

         UTCACA_PT(1) = SuppCap * USTTHR(WTech_PT)

         if (msptmx .gt. 1) then
            do stp = 2,msptmx
               UTCACA_PT(stp) = (USTCAMX(WTech_PT) * SuppCap - UTCACA_PT(1)) / (msptmx - 1)
               UTCACA_PT(stp) = amax1(UTCACA_PT(stp),0.0)
            end do
         end if
      elseif (UTCSSW(WTech_PT) .eq. 2) then

!        The steps are evenly split within the total supply curve capacity.
!        do stp = 1,msptmx
!           UTCACA_PT(stp) = (USTCAMX(WTech_PT) * SuppCap) / msptmx
!        end do
!        CRN - July 05, change capacity limit to match ECP short - term elast function.

         do stp = 1,ECP_D_SSTP

!           UTCACA_PT(stp) = (ESTCPLIM(WIPT,stp) * suppcap * 0.001) / msptmx

            UTCACA_PT(stp) = (ESTCPLIM(WIPT,stp)) / msptmx

!           UTCACA_PT(stp) = 0
         end do
     end if

!     Put the supply curve steps into a variable for the utility model

      do stp = 1,msptmx
         UTCAFN(WTech_SO,stp) = UTCACA_SO(stp)
      end do

      do stp = 1,msptmx
         UTCAFN(WTech_PV,stp) = UTCACA_PV(stp)
      end do

      do stp = 1,msptmx
         UTCAFN(WTech_PT,stp) = UTCACA_PT(stp)
      end do

!     For reporting purposes, evaluate where supply curve steps fall in array of available
!     capacity by its ranking by region, wind classes, and buffer zones.


      do nr = 1 , mnumnr
         do n = 1,RNum_SO
             wc = Rwc_SO(nr,n,curiyr)
              IF (wc.ne.0) THEN
                 SCapAvl_SO(nr,wc) = WCapAvl_SO(nr,curiyr,wc)             !landarea
              ENDIF
         end do
         do stp = 1,msptmx
            CapOut_SO = UTCACA_SO(stp)
            do n = 1 , RNum_SO
               wc = Rwc_SO(nr,n,curiyr)
               IF (wc.ne.0) THEN
                 SCapInc_SO(stp,nr,wc) = 0.0
                 if (SCapAvl_SO(nr,wc) .gt. 0.0) then
                    if (SCapAvl_SO(nr,wc) .ge. CapOut_SO/Pwrden_ST) then             !landarea
                       SCapInc_SO(stp,nr,wc) = CapOut_SO                             !capacity
                       CapOut_SO = 0.0
                       SCapAvl_SO(nr,wc) = SCapAvl_SO(nr,wc) - SCapInc_SO(stp,nr,wc)/Pwrden_ST !landarea
                    else
                       SCapInc_SO(stp,nr,wc) = SCapAvl_SO(nr,wc)*Pwrden_ST           !capacity
                       CapOut_SO = CapOut_SO - SCapInc_SO(stp,nr,wc)                 !capacity
                       SCapAvl_SO(nr,wc) = 0.0
                    end if
                 end if
               ENDIF
            end do
         end do

         do stp = 1,msptmx
            CapOut_PV = UTCACA_PV(stp)
            do n = 1 , RNum_PV
               wc = Rwc_PV(nr,n,curiyr)
               SCapInc_PV(stp,nr,wc) = 0.0
               if (SCapAvl_SO(nr,wc) .gt. 0.0) then
                  if (SCapAvl_SO(nr,wc) .ge. CapOut_PV/Pwrden_PV) then                !landarea
                     SCapInc_PV(stp,nr,wc) = CapOut_PV                                !capacity
                     CapOut_PV = 0.0
                     SCapAvl_SO(nr,wc) = SCapAvl_SO(nr,wc) - SCapInc_PV(stp,nr,wc)/Pwrden_PV     !landarea
                  else
                     SCapInc_PV(stp,nr,wc) = SCapAvl_SO(nr,wc)*Pwrden_PV              !capacity
                     CapOut_PV = CapOut_PV - SCapInc_PV(stp,nr,wc)                    !capacity
                     SCapAvl_SO(nr,wc) = 0.0
                   end if
               end if
            end do
         end do
 1743     Format(A20,1x,5(I4,1x),3(F18.3,1x))

         do stp = 1,msptmx
            CapOut_PT = UTCACA_PT(stp)
            do n = 1 , RNum_PT
               wc = Rwc_PT(nr,n,curiyr)
               SCapInc_PT(stp,nr,wc) = 0.0
               if (SCapAvl_SO(nr,wc) .gt. 0.0) then
                  if (SCapAvl_SO(nr,wc) .ge. CapOut_PT/Pwrden_PT) then               !landarea
                     SCapInc_PT(stp,nr,wc) = CapOut_PT                               !capacity
                     CapOut_PT = 0.0
                     SCapAvl_SO(nr,wc) = SCapAvl_SO(nr,wc) - SCapInc_PT(stp,nr,wc)/Pwrden_PT     !landarea
                  else
                     SCapInc_PT(stp,nr,wc) = SCapAvl_SO(nr,wc)*Pwrden_PT              !capacity
                     CapOut_PT = CapOut_PT - SCapInc_PT(stp,nr,wc)                    !capacity
                     SCapAvl_SO(nr,wc) = 0.0
                  end if
               end if
            end do
         end do
      end do

!     Determine "best" wind class and buffer zone.  This is class and zone that is used for all the
!     current characteristics.  This has been modified so that it doesn't pick a class / zone with virtually
!     no capacity in it and set this up as the capacity constraint.  For this it picks a class / zone where
!     it has found at least a cumulative amount of 25 percent of the capacity increment in that region.
!     It then creates a weighted average LT cost, CC cost, Cap Fac and T&D Cost.

      do nr = 1 , mnumnr
         ConsTol_SO(nr) = max(5.0,CapIncr_SO(nr,curiyr) * PercentTOL)
         ConsNum_SO(nr) = 0
         ConsCap_SO(nr) = 0.0
         ConsLT_SO(nr) = 0.0
         ConsCC_SO(nr) = 0.0
         ConsCF_SO(nr) = 0.0
         ConsTD_SO(nr) = 0.0
         Done_SO = 0
         do n = 1,RNum_SO
            wc = Rwc_SO(nr,n,curiyr)
            IF (wc.ne.0) THEN
              if (Done_SO .eq. 0) then
               if (WCapAvl_SO(nr,curiyr,wc) .gt. 0.0) then
                  ConsNum_SO(nr) = ConsNum_SO(nr) + 1
                  ConsCap_SO(nr) = ConsCap_SO(nr) + WCapAvl_SO(nr,curiyr,wc) *Pwrden_ST                                      !capacity
                  if (XSwitch.ne.1) ConsLT_SO(nr) = ConsLT_SO(nr) + WCapAvl_SO(nr,curiyr,wc)*Pwrden_ST * LTElas_SO(nr)       !capacity
                  if (XSwitch .eq. 1) ConsLT_SO(nr) = ConsLT_SO(nr) + WCapAvl_SO(nr,curiyr,wc)*Pwrden_ST * XLTElas_SO(nr,wc) !capacity
                  ConsCC_SO(nr) = ConsCC_SO(nr) + WCapAvl_SO(nr,curiyr,wc) *Pwrden_ST                                        !capacity
                  ConsCF_SO(nr) = ConsCF_SO(nr) + WCapAvl_SO(nr,curiyr,wc) *Pwrden_ST * CF_SO(curiyr,wc)
                  WCurCl_SO(nr,curiyr) = wc

                  WRITE(18,3522) CURIRUN, CURIYR+1989, CURITR, nr, n, 7-wc, 7-WCurCL_SO(nr,curiyr), 1, WCurBF_SO(nr,curiyr), Done_SO, ConsNum_SO(nr), XSwitch, &
                     ConsCap_SO(nr), WCapAvl_SO(nr,curiyr,wc), ConsLT_SO(nr), XLTElas_SO(nr,wc), ConsCC_SO(nr), ConsCF_SO(nr), CF_SO(curiyr,wc), ConsTD_SO(nr)
 3522             FORMAT(1X,"ConsCF",":SO",12(":",I4),10(":",F24.6))

               end if
               if (ConsCap_SO(nr) .gt. ConsTol_SO(nr) .or. n .eq. RNum_SO) then
                  WCurCl_SO(nr,curiyr) = wc

                  Done_SO = 1
               end if
              end if
            ENDIF
         end do
         if (ConsCap_SO(nr) .gt. 0.0) then
            ConsLT_SO(nr) = ConsLT_SO(nr) / ConsCap_SO(nr)
            ConsCC_SO(nr) = ConsCC_SO(nr) / ConsCap_SO(nr)
            ConsCF_SO(nr) = ConsCF_SO(nr) / ConsCap_SO(nr)
         else
            if (XSwitch.ne.1) ConsLT_SO(nr) = LTElas_SO(nr)
            if (XSwitch .eq. 1) ConsLT_SO(nr) = XLTElas_SO(nr,3)
            ConsCF_SO(nr) = CF_SO(curiyr,3)
         end if

               ConsTol_PV(nr) = max(5.0,CapIncr_PV(nr,curiyr) * PercentTOL)
               ConsNum_PV(nr) = 0
               ConsCap_PV(nr) = 0.0
               ConsLT_PV(nr) = 0.0
               ConsCC_PV(nr) = 0.0
               ConsCF_PV(nr) = 0.0
               ConsTD_PV(nr) = 0.0
               Done_PV = 0
               do n = 1,RNum_PV
                  wc = Rwc_PV(nr,n,curiyr)
                  IF (wc.ne.0) THEN
                    if (Done_PV .eq. 0) then
                     if (WCapAvl_SO(nr,curiyr,wc) .gt. 0.0) then
                        ConsNum_PV(nr) = ConsNum_PV(nr) + 1
                        ConsCap_PV(nr) = ConsCap_PV(nr) + WCapAvl_SO(nr,curiyr,wc)*Pwrden_PV                                           !capacity
                        if (XSwitch.ne.1) ConsLT_PV(nr) = ConsLT_PV(nr) + WCapAvl_SO(nr,curiyr,wc)*Pwrden_PV * LTElas_PV(nr)           !capacity
                        if (XSwitch .eq. 1) ConsLT_PV(nr) = ConsLT_PV(nr) + WCapAvl_SO(nr,curiyr,wc)*Pwrden_PV * XLTElas_PV(nr,wc)     !capacity
                        ConsCC_PV(nr) = ConsCC_PV(nr) + WCapAvl_SO(nr,curiyr,wc)*Pwrden_PV                                             !capacity
                        ConsCF_PV(nr) = ConsCF_PV(nr) + WCapAvl_SO(nr,curiyr,wc) *Pwrden_PV * CF_PV(curiyr,wc)
                        WCurCl_PV(nr,curiyr) = wc


                        WRITE(18,3523) CURIRUN, CURIYR+1989, CURITR, nr, n, 7-wc, 7-WCurCL_PV(nr,curiyr), 1, WCurBF_PV(nr,curiyr), Done_PV, ConsNum_PV(nr), XSwitch, &
                           ConsCap_PV(nr), WCapAvl_SO(nr,curiyr,wc), ConsLT_PV(nr), XLTElas_PV(nr,wc), ConsCC_PV(nr), ConsCF_PV(nr), CF_PV(curiyr,wc), ConsTD_PV(nr)
       3523             FORMAT(1X,"ConsCF",":PV",12(":",I4),10(":",F24.6))

                     end if
                     if (ConsCap_PV(nr) .gt. ConsTol_PV(nr) .or. n .eq. RNum_PV) then
                        WCurCl_PV(nr,curiyr) = wc

                        Done_PV = 1
                     end if
                    end if
                  ENDIF
               end do
               if (ConsCap_PV(nr) .gt. 0.0) then
                  ConsLT_PV(nr) = ConsLT_PV(nr) / ConsCap_PV(nr)
                  ConsCC_PV(nr) = ConsCC_PV(nr) / ConsCap_PV(nr)
                  ConsCF_PV(nr) = ConsCF_PV(nr) / ConsCap_PV(nr)
               else
                  if (XSwitch.ne.1) ConsLT_PV(nr) = LTElas_PV(nr)
                  if (XSwitch .eq. 1) ConsLT_PV(nr) = XLTElas_PV(nr,3)
                  ConsCF_PV(nr) = CF_PV(curiyr,3)
                end if

                     ConsTol_PT(nr) = max(5.0,CapIncr_PT(nr,curiyr) * PercentTOL)
                     ConsNum_PT(nr) = 0
                     ConsCap_PT(nr) = 0.0
                     ConsLT_PT(nr) = 0.0
                     ConsCC_PT(nr) = 0.0
                     ConsCF_PT(nr) = 0.0
                     ConsTD_PT(nr) = 0.0
                     Done_PT = 0
                     do n = 1,RNum_PT
                        wc = Rwc_PT(nr,n,curiyr)
                        IF (wc.ne.0) THEN
                          if (Done_PT .eq. 0) then
                           if (WCapAvl_SO(nr,curiyr,wc) .gt. 0.0) then
                              ConsNum_PT(nr) = ConsNum_PT(nr) + 1
                              ConsCap_PT(nr) = ConsCap_PT(nr) + WCapAvl_SO(nr,curiyr,wc)*Pwrden_PT                                             !capacity
                              if (XSwitch.ne.1) ConsLT_PT(nr) = ConsLT_PT(nr) + WCapAvl_SO(nr,curiyr,wc)*Pwrden_PT * LTElas_PT(nr)             !capacity
                              if (XSwitch .eq. 1) ConsLT_PT(nr) = ConsLT_PT(nr) + WCapAvl_SO(nr,curiyr,wc)*Pwrden_PT * XLTElas_PT(nr,wc)       !capacity
                              ConsCC_PT(nr) = ConsCC_PT(nr) + WCapAvl_SO(nr,curiyr,wc) *Pwrden_PT                                              !capacity
                              ConsCF_PT(nr) = ConsCF_PT(nr) + WCapAvl_SO(nr,curiyr,wc)*Pwrden_PT * CF_PT(curiyr,wc)
                              WCurCl_PT(nr,curiyr) = wc


                              WRITE(18,3524) CURIRUN, CURIYR+1989, CURITR, nr, n, 7-wc, 7-WCurCL_PT(nr,curiyr), 1, WCurBF_PT(nr,curiyr), Done_PT, ConsNum_PT(nr), XSwitch, &
                                 ConsCap_PT(nr), WCapAvl_SO(nr,curiyr,wc), ConsLT_PT(nr), XLTElas_PT(nr,wc), ConsCC_PT(nr),  ConsCF_PT(nr), CF_PT(curiyr,wc), ConsTD_PT(nr)
             3524             FORMAT(1X,"ConsCF",":PT",12(":",I4),10(":",F24.6))

                           end if
                           if (ConsCap_PT(nr) .gt. ConsTol_PT(nr) .or. n .eq. RNum_PT) then
                              WCurCl_PT(nr,curiyr) = wc

                              Done_PT = 1
                           end if
                          end if
                        ENDIF
                     end do
                     if (ConsCap_PT(nr) .gt. 0.0) then
                        ConsLT_PT(nr) = ConsLT_PT(nr) / ConsCap_PT(nr)
                        ConsCC_PT(nr) = ConsCC_PT(nr) / ConsCap_PT(nr)
                        ConsCF_PT(nr) = ConsCF_PT(nr) / ConsCap_PT(nr)
                     else
                        if (XSwitch.ne.1) ConsLT_PT(nr) = LTElas_PT(nr)
                        if (XSwitch .eq. 1) ConsLT_PT(nr) = XLTElas_PT(nr,3)
                        ConsCF_PT(nr) = CF_PT(curiyr,3)
                      end if
      end do

!     Fill in the total maximum capacity over all categories and the existing (chosen) capacity in each region.

      do nr = 1 , mnumnr

!        For some reason the previous model filled in UTRSMX only until year 8.

         if (curiyr .le. 8) THEN

            UTRSMX(nr,WTech_SO) = CapOrig_SO(nr,curiyr)
            UTRSMX(nr,WTech_PV) = CapOrig_PV(nr,curiyr)
            UTRSMX(nr,WTech_PT) = CapOrig_PT(nr,curiyr)
         END IF

         UTRSCU(nr,WTech_SO) = CapInstall_SO(nr,curiyr)
         UTRSCU(nr,WTech_PV) = CapInstall_PV(nr,curiyr)
         UTRSCU(nr,WTech_PT) = CapInstall_PT(nr,curiyr)

      end do

!     Determine the long - term elasticities for the supply curve.
!     Note, this is only used if we are doing the origninal long - term elasticities over all wind classes and zones.

      do nr = 1 , mnumnr

!        Calculate the ratio of resource used to resource available - i.e., point on long term supply curve.

         Ratio = 0.0
         if (UTRSMX(nr,WTech_SO) .ge. epsi) Ratio = (UTRSCU(nr,WTech_SO) + UTRSCU(nr,WTech_PV)+ UTRSCU(nr,WTech_PT)) / UTRSMX(nr,WTech_SO)

!        Look up the elasticity using a table of 5 levels, based upon the level of the ratio.

         LTElas_SO(nr) = 1.0
         do lev = 1,MLPTMX
            if (UTRSFC(nr,WTech_SO,lev) .lt. Ratio) then
               LTElas_SO(nr) = UTCSFC(nr,WTech_SO,lev)
            end if
            if (UTRSFC(nr,WTech_PV,lev) .lt. Ratio) then
               LTElas_PV(nr) = UTCSFC(nr,WTech_PV,lev)
            end if
             if (UTRSFC(nr,WTech_PT,lev) .lt. Ratio) then
               LTElas_PT(nr) = UTCSFC(nr,WTech_PT,lev)
            end if
         end do
      end do

!     Combine as necessary and put the elasticities into the array used by the Utility Model

      do nr = 1 , mnumnr
         ZLTElas_SO = ConsLT_SO(nr)
         do stp = 1,msptmx

!           for aeo04, STELas is not being used

            if (UTCSSW(WTech_SO) .eq. 2   .or.  UTCSSW(WTech_SO) .eq. 3) then
               UTCSFN(nr,WTech_SO,stp) = ZLTElas_SO - 1.0
            else
               UTCSFN(nr,WTech_SO,stp) = 0.0
            endif

            UTCSFN(nr,WTech_SO,stp) = UTCSFN(nr,WTech_SO,stp) * ConsCC_SO(nr)
         end do
      end do

      do nr = 1 , mnumnr
         ZLTElas_PV = ConsLT_PV(nr)
         do stp = 1,msptmx

            if (UTCSSW(WTech_PV) .eq. 2   .or.  UTCSSW(WTech_PV) .eq. 3) then
               UTCSFN(nr,WTech_PV,stp) = ZLTElas_PV - 1.0
            else
               UTCSFN(nr,WTech_PV,stp) = 0.0
            endif

            UTCSFN(nr,WTech_PV,stp) = UTCSFN(nr,WTech_PV,stp) * ConsCC_PV(nr)
         end do
      end do

     do nr = 1 , mnumnr
               ZLTElas_PT = ConsLT_PT(nr)
               do stp = 1,msptmx

                  if (UTCSSW(WTech_PT) .eq. 2   .or.  UTCSSW(WTech_PT) .eq. 3) then
                     UTCSFN(nr,WTech_PT,stp) = ZLTElas_PT - 1.0
                  else
                     UTCSFN(nr,WTech_PT,stp) = 0.0
                  endif

                  UTCSFN(nr,WTech_PT,stp) = UTCSFN(nr,WTech_PT,stp) * ConsCC_PT(nr)
               end do
      end do

!     Fill in some variables for the utility model (?)
!     WCAWIEL is the amount of available capacity in the "best" wind class and "best" buffer zone.

      do nr = 1 , mnumnr
         WCASTEL(nr,curiyr) = ConsCap_SO(nr)
         WOLDCN(nr,WTech_SO) = WCASTEL(nr,curiyr)

!        In the previous model it had been filled in for all years, maybe this is not necessary...

         do yr = curiyr + 1,MNUMYR
            WCASTEL(nr,yr) = WCASTEL(nr,curiyr)
         end do
      end do

      do nr = 1 , mnumnr
         WCAPVEL(nr,curiyr) = ConsCap_PV(nr)
         WOLDCN(nr,WTech_PV) = WCAPVEL(nr,curiyr)

!        In the previous model it had been filled in for all years, maybe this is not necessary...

         do yr = curiyr + 1,MNUMYR
            WCAPVEL(nr,yr) = WCAPVEL(nr,curiyr)
         end do
      end do

      do nr = 1 , mnumnr
         WCAPTEL(nr,curiyr) = ConsCap_PT(nr)
         WOLDCN(nr,WTech_PT) = WCAPTEL(nr,curiyr)

!        In the previous model it had been filled in for all years, maybe this is not necessary...

         do yr = curiyr + 1,MNUMYR
            WCAPTEL(nr,yr) = WCAPTEL(nr,curiyr)
         end do
      end do

       do nr=1,mnumnr
			WRITE(18,3714) CURIRUN, CURIYR+1989, nr, ConsCF_PV(nr), PVInputCF(nr,curiyr), ConsCF_PT(nr), PTInputCF(nr,curiyr),ConsCF_PV(nr)/PVInputCF(nr,curiyr),ConsCF_PT(nr)/PTInputCF(nr,curiyr)
 3714       FORMAT(1X,"WSSPVPTEL_CF_ADJ",3(",",I5),6(",",F21.6))
           do m=1,12
               do d=1,3
                  do h=1,24
                       If(SolarInputCF(nr,curiyr) .gt. 0) Then
                         tmpcf=ConsCF_SO(nr)/SolarInputCF(nr,curiyr)
                       Else
                         tmpcf=1.0
                       Endif
                       WSSSTEL_CF(nr,curiyr,d,m,h) = WSSSTEL_CF(nr,curiyr,d,m,h) * tmpcf
                       if (WSSSTEL_CF(nr,curiyr,d,m,h).gt.1.00)WSSSTEL_CF(nr,curiyr,d,m,h)= 1.0

                          If(PVInputCF(nr,curiyr) .gt. 0) Then
                          tmpcf=ConsCF_PV(nr)/PVInputCF(nr,curiyr)
                        Else
                          tmpcf=1.0
                       Endif
                  IF (CURIYR+1989 .EQ. 2020) &
                     WRITE(18,3713) CURIRUN, CURIYR+1989, nr, d, m, h, tmpcf, ConsCF_PV(nr), PVInputCF(nr,curiyr), WSSPVEL_CF(nr,curiyr,d,m,h), WSSPVEL_CF(nr,curiyr,d,m,h) * tmpcf
 3713             FORMAT(1X,"WSSPVEL_CF_ADJ",6(",",I5),5(",",F21.6))
                       WSSPVEL_CF(nr,curiyr,d,m,h) = WSSPVEL_CF(nr,curiyr,d,m,h) * tmpcf
                       if (WSSPVEL_CF(nr,curiyr,d,m,h).gt.1.00)WSSPVEL_CF(nr,curiyr,d,m,h)= 1.0

                       If(PTInputCF(nr,curiyr) .gt. 0) Then
                         tmpcf=ConsCF_PT(nr)/PTInputCF(nr,curiyr)
                       Else
                         tmpcf=1.0
                       Endif
                       WSSPTEL_CF_CLIP(nr,curiyr,d,m,h) = WSSPTEL_CF_CLIP(nr,curiyr,d,m,h) * tmpcf
					   WSSPTEL_CF(nr,curiyr,d,m,h) = WSSPTEL_CF(nr,curiyr,d,m,h) * tmpcf
                       if (WSSPTEL_CF(nr,curiyr,d,m,h).gt.1.00)WSSPTEL_CF(nr,curiyr,d,m,h)= 1.0

                  enddo     !hr
               enddo        !daytype
            enddo           !month
        enddo             !region

      return
      end


!******************************************************************
!     Subroutine SolarRank determines the costs for each wind category and then ranks the categories
!     according to some criteria - typically lowest to highest cost.

      subroutine SolarRank

      implicit none
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'ecpcntl'
      include 'control'
      include 'wrenew'
      include 'wwind'
      include 'wrenio'
      include 'bildout'
      include 'entcntl'
      include 'enewtech'
      include 'bildin'
      include 'uefdout'
!
      INTEGER*4 RCAP
      INTEGER*4 GSYR1
      INTEGER*4 GSYRL
      INTEGER*4 ICAP
      INTEGER*4 IFPH2
      INTEGER*4 IP
      INTEGER*4 IS
      INTEGER*4 JYR
      INTEGER*4 OLYR
      INTEGER*4 YEAR
!
      REAL*4 CPR(ECP_D_LCP)
      REAL*4 EWGINT
      REAL*4 EWGROE
      REAL*4 EWGROR
!
      REAL*8 CAPLEV
      REAL*8 CAPNNSTL
      REAL*8 CAPNUG
      REAL*8 CRF
      REAL*8 FNBOOK
      REAL*8 ITCADJ
      REAL*8 OVRCST
      REAL*8 PRATIO
      REAL*8 PVGNP
      REAL*8 PWF
      REAL*8 TXBOOK
!
      integer nr,wc,t,ECPSolar,RankVer,Used_SO(mnumsl),w,b,n
      real XCost

!     Get the index for solar in ECP.

      do t=1,ECP_D_CAP
         if (UPLNTCD(t).eq.'SO') ECPSolar=t
      end do

!     Get costs for wind from the utility model.
!     Compute CapCost in regional loop now

      if (ECP_D_OVFX(ECPSolar).eq.0) then
         OMFCost_SO=UPFOM(ECPSolar)
      else
         OMFCost_SO=UPOVFX(ECPSolar,curiyr)
      end if
      if (ECP_D_OVVR(ECPSolar).eq.0) then
         OMVCost_SO=UPVOM(ECPSolar)
      else
         OMVCost_SO=UPOVVR(ECPSolar,curiyr)
      end if
!
      do nr=1,unrgns
         call GETBLD(1,nr)
         YEAR = 1
         IS = 1
         ICAP = ECPSolar
         IP = UCPINTIS(ICAP)
         RCAP = UIRINTI(IP)
         OLYR = YEAR + UPPLYR(ICAP)
         GSYR1 = UPGSY1(ICAP) - UHBSYR
         GSYRL = UPGSYL(ICAP) - UHBSYR
         IFPH2 = UNFPH - OLYR + 1
         IF (EPDSCRT .LT. 0.09) EPDSCRT = 0.09
         IF (EPCCSUP(RCAP,IS) .LT. 0.09) EPCCSUP(RCAP,IS) = 0.09
         DO JYR = 1, ECP_D_LCP
            CPR(JYR) = UPCPRO(ICAP,JYR)
         END DO
         EWGROE = EPUCRE + UPNRPRM
         EWGINT = EPUIRT + UPNIPRM
         EWGROR = EWGROE * (1.0 - UPNFDT) + EWGINT * UPNFDT
         IF (UPGSUB(ICAP) .GT. 0.0 .AND. (CURIYR + OLYR - 1) .GE. GSYR1 .AND. (CURIYR + OLYR - 1) .LE. GSYRL) THEN
            ITCADJ = 1.0 - UPCSB(ICAP)
         ELSE
            ITCADJ = 1.0
         ENDIF
         OVRCST = (EPIROVR(RCAP)/ITCADJ) * UPLRPC(ICAP) * UPLROPT(ICAP) * UPLRLC(ICAP) * EPRGM(ICAP) * EPACM(ICAP) * EPCCSUP(RCAP,IS) * UPANNADJ(ICAP,CURIYR)
         CALL EPINCST(MNUMYR,ECP_D_XPH,ECP_D_FPH,ECP_D_LCP,UPCLYR(ICAP),UPPLYR(ICAP),CURIYR,YEAR,OVRCST,CPR,UPCAPD(1,ICAP),UPGNPD,EWGINT,UPNFDT,EWGROR,TXBOOK,FNBOOK)
         PRATIO = TXBOOK / FNBOOK
         CAPNNSTL = FNBOOK
         CALL EPCNBLD(DBLE(UPNFDT),PRATIO,DBLE(UPNRPRM),DBLE(UPNIPRM),DBLE(EPUCRE),DBLE(EPUIRT),DBLE(UPTXRT),UPTXLF(ICAP),UPNCLF(ICAP),UPNLLF(ICAP),CAPNUG)
         CALL EP$LGNP(OLYR,IFPH2,EPDSCRT,PVGNP)
         CAPLEV = (( CAPNNSTL * CAPNUG ) / CRF(DBLE(EPDSCRT - UPRSK(ICAP)),IFPH2) ) * PWF(DBLE(EPDSCRT - UPRSK(ICAP)),OLYR)
         CAPLEV = CAPLEV / PVGNP
         FixChg_SO = CAPLEV / OVRCST
         if ( isnan(FixChg_SO) ) then
            FixChg_SO = 0.13

            WRITE(18,3333) CURIYR, CURITR, nr, ECP_D_FPH, ECP_D_LCP, ECP_D_XPH, ECPSolar, GSYR1, GSYRL, ICAP, IFPH2, IP, IS, MNUMYR, OLYR, RCAP, UCPINTIS(ICAP), &
               UIRINTI(IP), UHBSYR, UNFPH, UPCLYR(ICAP), UPGSY1(ICAP), UPGSYL(ICAP), UPNCLF(ICAP), UPNLLF(ICAP), UPPLYR(ICAP), UPTXLF(ICAP), YEAR
 3333       FORMAT(1X,"EPLVFCF0:SO",28(":",I4))

            WRITE(18,3334) CURIYR, CURITR, nr, &
               CAPLEV, CAPNNSTL, CAPNUG, EPACM(ICAP), EPCCSUP(RCAP,IS), EPDSCRT, EPIROVR(RCAP), &
               EPLVFCF(ICAP,2), EPRGM(ICAP), EPUCRE, EPUIRT, EWGINT, EWGROE, EWGROR, FNBOOK, ITCADJ, OVRCST, PRATIO, PVGNP, TXBOOK, UPCAPD(1,ICAP), &
               UPCSB(ICAP), UPGSUB(ICAP), UPLRLC(ICAP), UPLROPT(ICAP), UPLRPC(ICAP), UPNFDT, UPNIPRM, UPNRPRM, UPRSK(ICAP), UPTXRT,UPANNADJ(ICAP,CURIYR)
 3334       FORMAT(1X,"EPLVFCF1:SO",3(":",I4),36(":",E10.3))

            WRITE(18,3335) CURIYR, CURITR, nr, (UPCPRO(ICAP,JYR),JYR= 1, ECP_D_LCP)
 3335       FORMAT(1X,"EPLVFCF2:SO",3(":",I4),35(":",E10.3))

            WRITE(18,3336) CURIYR, CURITR, nr, (UPGNPD(JYR),JYR=1,MNUMYR)
 3336       FORMAT(1X,"EPLVFCF3:SO",3(":",I4),<MNUMYR>(":",E10.3))

         else

            WRITE(18,4334) CURIYR,CURITR,NR,FixChg_SO,EPLVFCF(ICAP,2)
 4334       FORMAT(1X,"EPLVFCF4:SO",3(":",I4),2(":",E10.3))

         endif

         if (ECP_D_OVCC(ECPSolar).eq.0) then
            CapCostR_SO(nr) = UPOVR(ECPSolar) * UPLRPC(ECPSolar) * UPLROPT(ECPSolar) * UPLRLC(ECPSolar) * EPRGM(ECPSolar) * EPACM(ECPSolar) * UPANNADJ(ICAP,CURIYR)
         else
            CapCostR_SO(nr) = UPOVCC(ECPSolar,curiyr) * UPLRPC(ECPSolar) * UPLROPT(ECPSolar) * UPLRLC(ECPSolar) * EPRGM(ECPSolar) * EPACM(ECPSolar) * UPANNADJ(ECPSolar,CURIYR)
         endif


!        Determine the annualized cost per kwh by region, year, wind class, and buffer zone.

         do wc=1,mnumsl
               ICCCostR_SO(nr,wc,curiyr)=CapCostR_SO(nr)

!              If XSwitch is not 0 then use the long-term multiplier by wind class in the capital cost.

               if (XSwitch.eq.0) then
                  AnnCost_SO(nr,curiyr,wc)=(ICCCostR_SO(nr,wc,curiyr)*FixChg_SO+OMFCost_SO+ WNTDBFCS(nr,1)*FixChg_SO)/(CF_SO(curiyr,wc)*8760.0)+OMVCost_SO/1000

                 WRITE(18,2003) CURIYR+1989,CURITR,nr,wc,0, AnnCost_SO(nr,curiyr,wc), ICCCostR_SO(nr,wc,curiyr), FixChg_SO, OMFCost_SO,  &
                    WNTDBFCS(nr,1), CF_SO(curiyr,wc), OMVCost_SO
 2003             format(1X,"AnnCost:SO:0",5(":",I5),7(":",F15.6))

               else
                  AnnCost_SO(nr,curiyr,wc) = (ICCCostR_SO(nr,wc,curiyr) * XLTElas_SO(nr,wc) * FixChg_SO + OMFCost_SO + WNTDBFCS(nr,1) * FixChg_SO) / (CF_SO(curiyr,wc) * 8760.0) + OMVCost_SO / 1000

                 WRITE(18,2004) CURIYR+1989,CURITR,nr,wc, 1,AnnCost_SO(nr,curiyr,wc), ICCCostR_SO(nr,wc,curiyr), XLTElas_SO(nr,wc),  &
                    FixChg_SO, OMFCost_SO, WNTDBFCS(nr,1), CF_SO(curiyr,wc), OMVCost_SO
 2004             format(1X,"AnnCost:SO:1",5(":",I5),8(":",F15.6))

               end if

         end do
      end do      !region loop

!     Choose the manner of ranking: 1=original, 2=by cost (note, that in the base they are the same)

      RankVer=1
      if (RankVer.eq.1) then

!        Rank the categories according to some criteria - probably lowest to highest cost.
!        For now, they are simply ranked in wind class, buffer zone order, as in the original model.

         do nr=1,mnumnr
            RNum_SO=0
            do wc=1,mnumsl
                  RNum_SO=RNum_SO+1
                  Rwc_SO(nr,RNum_SO,curiyr)=wc
                  Rank_SO(nr,wc)=wc
            end do
         end do
      elseif (RankVer.eq.2) then
         RNum_SO=mnumsl
         do nr=1,mnumnr
            n=0
            do wc=1,mnumsl

                  n=n+1
                  Used_SO(wc)=0
                  Rwc_SO(nr,n,curiyr)=0

            end do
            n=0
            do wc=1,mnumsl

               n=n+1
               XCost=999999.9
               do w=1,mnumsl

                  if (Used_SO(w).eq.0.and.AnnCost_SO(nr,curiyr,w).lt.XCost) then

                     WRITE(18,4817) CURIRUN, CURIYR+1989, nr, n, wc,1, w, b, XCOST, AnnCost_SO(nr,curiyr,w)
 4817                FORMAT(1X,"Renew_windrank3:SO",8(":",I5),2(":",F21.6))

                     XCost=AnnCost_SO(nr,curiyr,w)
                     Rwc_SO(nr,n,curiyr)=w

                     Rank_SO(nr,w)=n
                  end if
               end do
            end do
            If (Rwc_SO(nr,n,curiyr) .gt. 0 ) then
               Used_SO(Rwc_SO(nr,n,curiyr))=1
            else
               do w=1,mnumsl
                  WRITE(18,1003) curcalyr,nr,n,w,AnnCost_SO(nr,curiyr,w)
 1003             format(1X,"Oops_used",5(":",I4),":",F20.6)
               end do
            end if
         end do

      end if

      return
      end

!     Subroutine SolarRank_PV determines the costs for each wind category and then ranks the categories
!     according to some criteria - typically lowest to highest cost.

      subroutine SolarRank_PV

      implicit none
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'ecpcntl'
      include 'control'
      include 'wrenew'
      include 'wwind'
      include 'wrenio'
      include 'bildout'
      include 'entcntl'
      include 'enewtech'
      include 'bildin'
      include 'uefdout'
!
      INTEGER*4 RCAP
      INTEGER*4 GSYR1
      INTEGER*4 GSYRL
      INTEGER*4 ICAP
      INTEGER*4 IFPH2
      INTEGER*4 IP
      INTEGER*4 IS
      INTEGER*4 JYR
      INTEGER*4 OLYR
      INTEGER*4 YEAR
!
      REAL*4 CPR(ECP_D_LCP)
      REAL*4 EWGINT
      REAL*4 EWGROE
      REAL*4 EWGROR
!
      REAL*8 CAPLEV
      REAL*8 CAPNNSTL
      REAL*8 CAPNUG
      REAL*8 CRF
      REAL*8 FNBOOK
      REAL*8 ITCADJ
      REAL*8 OVRCST
      REAL*8 PRATIO
      REAL*8 PVGNP
      REAL*8 PWF
      REAL*8 TXBOOK
!
      integer nr,wc,t,ECPSolar,RankVer,Used_PV(mnumsl),w,b,n
      real XCost

!     Get the index for solar in ECP.

      do t=1,ECP_D_CAP
         if (UPLNTCD(t).eq.'PV') ECPSolar=t
      end do

!     Get costs for wind from the utility model.
!     Compute CapCost in regional loop now

      if (ECP_D_OVFX(ECPSolar).eq.0) then
         OMFCost_PV=UPFOM(ECPSolar)
      else
         OMFCost_PV=UPOVFX(ECPSolar,curiyr)
      end if
      if (ECP_D_OVVR(ECPSolar).eq.0) then
         OMVCost_PV=UPVOM(ECPSolar)
      else
         OMVCost_PV=UPOVVR(ECPSolar,curiyr)
      end if
!
      do nr=1,unrgns
         call GETBLD(1,nr)
         YEAR = 1
         IS = 1
         ICAP = ECPSolar
         IP = UCPINTIS(ICAP)
         RCAP = UIRINTI(IP)
         OLYR = YEAR + UPPLYR(ICAP)
         GSYR1 = UPGSY1(ICAP) - UHBSYR
         GSYRL = UPGSYL(ICAP) - UHBSYR
         IFPH2 = UNFPH - OLYR + 1
         IF (EPDSCRT .LT. 0.09) EPDSCRT = 0.09
         IF (EPCCSUP(RCAP,IS) .LT. 0.09) EPCCSUP(RCAP,IS) = 0.09
         DO JYR = 1, ECP_D_LCP
            CPR(JYR) = UPCPRO(ICAP,JYR)
         END DO
         EWGROE = EPUCRE + UPNRPRM
         EWGINT = EPUIRT + UPNIPRM
         EWGROR = EWGROE * (1.0 - UPNFDT) + EWGINT * UPNFDT
         IF (UPGSUB(ICAP) .GT. 0.0 .AND. (CURIYR + OLYR - 1) .GE. GSYR1 .AND. (CURIYR + OLYR - 1) .LE. GSYRL) THEN
            ITCADJ = 1.0 - UPCSB(ICAP)
         ELSE
            ITCADJ = 1.0
         ENDIF
         OVRCST = (EPIROVR(RCAP)/ITCADJ) * UPLRPC(ICAP) * UPLROPT(ICAP) * UPLRLC(ICAP) * EPRGM(ICAP) * EPACM(ICAP) * EPCCSUP(RCAP,IS) * UPANNADJ(ICAP,CURIYR)
         CALL EPINCST(MNUMYR,ECP_D_XPH,ECP_D_FPH,ECP_D_LCP,UPCLYR(ICAP),UPPLYR(ICAP),CURIYR,YEAR,OVRCST,CPR,UPCAPD(1,ICAP),UPGNPD,EWGINT,UPNFDT,EWGROR,TXBOOK,FNBOOK)
         PRATIO = TXBOOK / FNBOOK
         CAPNNSTL = FNBOOK
         CALL EPCNBLD(DBLE(UPNFDT),PRATIO,DBLE(UPNRPRM),DBLE(UPNIPRM),DBLE(EPUCRE),DBLE(EPUIRT),DBLE(UPTXRT),UPTXLF(ICAP),UPNCLF(ICAP),UPNLLF(ICAP),CAPNUG)
         CALL EP$LGNP(OLYR,IFPH2,EPDSCRT,PVGNP)
         CAPLEV = (( CAPNNSTL * CAPNUG ) / CRF(DBLE(EPDSCRT - UPRSK(ICAP)),IFPH2) ) * PWF(DBLE(EPDSCRT - UPRSK(ICAP)),OLYR)
         CAPLEV = CAPLEV / PVGNP
         FixChg_PV = CAPLEV / OVRCST
         if ( isnan(FixChg_PV) ) then
            FixChg_PV = 0.13

            WRITE(18,3333) CURIYR, CURITR, nr, ECP_D_FPH, ECP_D_LCP, ECP_D_XPH, ECPSolar, GSYR1, GSYRL, ICAP, IFPH2, IP, IS, MNUMYR, OLYR, RCAP, UCPINTIS(ICAP), &
               UIRINTI(IP), UHBSYR, UNFPH, UPCLYR(ICAP), UPGSY1(ICAP), UPGSYL(ICAP), UPNCLF(ICAP), UPNLLF(ICAP), UPPLYR(ICAP), UPTXLF(ICAP), YEAR
 3333       FORMAT(1X,"EPLVFCF0:PV",28(":",I4))

            WRITE(18,3334) CURIYR, CURITR, nr, &
               CAPLEV, CAPNNSTL, CAPNUG, EPACM(ICAP), EPCCSUP(RCAP,IS), EPDSCRT, EPIROVR(RCAP), &
               EPLVFCF(ICAP,2), EPRGM(ICAP), EPUCRE, EPUIRT, EWGINT, EWGROE, EWGROR, FNBOOK, ITCADJ, OVRCST, PRATIO, PVGNP, TXBOOK, UPCAPD(1,ICAP), &
               UPCSB(ICAP), UPGSUB(ICAP), UPLRLC(ICAP), UPLROPT(ICAP), UPLRPC(ICAP), UPNFDT, UPNIPRM, UPNRPRM, UPRSK(ICAP), UPTXRT,UPANNADJ(ICAP,CURIYR)
 3334       FORMAT(1X,"EPLVFCF1:PV",3(":",I4),36(":",E10.3))

            WRITE(18,3335) CURIYR, CURITR, nr, (UPCPRO(ICAP,JYR),JYR= 1, ECP_D_LCP)
 3335       FORMAT(1X,"EPLVFCF2:PV",3(":",I4),35(":",E10.3))

            WRITE(18,3336) CURIYR, CURITR, nr, (UPGNPD(JYR),JYR=1,MNUMYR)
 3336       FORMAT(1X,"EPLVFCF3:PV",3(":",I4),<MNUMYR>(":",E10.3))

         else

            WRITE(18,4334) CURIYR,CURITR,NR,FixChg_SO,EPLVFCF(ICAP,2)
 4334       FORMAT(1X,"EPLVFCF4:PV",3(":",I4),2(":",E10.3))

         endif

         if (ECP_D_OVCC(ECPSolar).eq.0) then
            CapCostR_PV(nr) = UPOVR(ECPSolar) * UPLRPC(ECPSolar) * UPLROPT(ECPSolar) * UPLRLC(ECPSolar) * EPRGM(ECPSolar) * EPACM(ECPSolar) * UPANNADJ(ICAP,CURIYR)
         else
            CapCostR_PV(nr) = UPOVCC(ECPSolar,curiyr) * UPLRPC(ECPSolar) * UPLROPT(ECPSolar) * UPLRLC(ECPSolar) * EPRGM(ECPSolar) * EPACM(ECPSolar) * UPANNADJ(ECPSolar,CURIYR)
         endif

!        Determine the annualized cost per kwh by region, year, wind class, and buffer zone.

         do wc=1,mnumsl

               ICCCostR_PV(nr,wc,curiyr)=CapCostR_PV(nr)

!              If XSwitch is not 0 then use the long-term multiplier by wind class in the capital cost.

               if (XSwitch.eq.0) then
                  AnnCost_PV(nr,curiyr,wc)=(ICCCostR_PV(nr,wc,curiyr)*FixChg_PV+OMFCost_PV+ WNTDBFCS(nr,1)*FixChg_PV)/(CF_PV(curiyr,wc)*8760.0)+OMVCost_PV/1000

                 WRITE(18,2003) CURIYR+1989,CURITR,nr,wc,0, AnnCost_PV(nr,curiyr,wc), ICCCostR_PV(nr,wc,curiyr), FixChg_PV, OMFCost_PV,  &
                    WNTDBFCS(nr,1), CF_PV(curiyr,wc), OMVCost_PV
 2003             format(1X,"AnnCost:PV:0",5(":",I5),7(":",F15.6))

               else
                  AnnCost_PV(nr,curiyr,wc) = (ICCCostR_PV(nr,wc,curiyr) * XLTElas_PV(nr,wc) * FixChg_PV + OMFCost_PV + WNTDBFCS(nr,1) * FixChg_PV) / (CF_PV(curiyr,wc) * 8760.0) + OMVCost_PV / 1000

                 WRITE(18,2004) CURIYR+1989,CURITR,nr,wc,1, AnnCost_PV(nr,curiyr,wc), ICCCostR_PV(nr,wc,curiyr), XLTElas_PV(nr,wc),  &
                    FixChg_PV, OMFCost_PV, WNTDBFCS(nr,1), CF_SO(curiyr,wc), OMVCost_PV
 2004             format(1X,"AnnCost:PV:1",5(":",I5),8(":",F15.6))

               end if

         end do
      end do      !region loop

!     Choose the manner of ranking: 1=original, 2=by cost (note, that in the base they are the same)

      RankVer=1
      if (RankVer.eq.1) then

!        Rank the categories according to some criteria - probably lowest to highest cost.
!        For now, they are simply ranked in wind class, buffer zone order, as in the original model.

         do nr=1,mnumnr
            RNum_PV=0
            do wc=1,mnumsl
               RNum_PV=RNum_PV+1
               Rwc_PV(nr,RNum_PV,curiyr)=wc
               Rank_PV(nr,wc)=wc
            end do
         end do
      elseif (RankVer.eq.2) then
         RNum_PV=mnumsl
         do nr=1,mnumnr
            n=0
            do wc=1,mnumsl

               n=n+1
               Used_PV(wc)=0
               Rwc_PV(nr,n,curiyr)=0

            end do
            n=0
            do wc=1,mnumsl

               n=n+1
               XCost=999999.9
               do w=1,mnumsl

                  if (Used_PV(w).eq.0.and.AnnCost_PV(nr,curiyr,w).lt.XCost) then

                     WRITE(18,4817) CURIRUN, CURIYR+1989, nr, n, wc, w, b,1, XCOST, AnnCost_PV(nr,curiyr,w)
 4817                      FORMAT(1X,"Renew_windrank3:PV",8(":",I5),2(":",F21.6))

                     XCost=AnnCost_PV(nr,curiyr,w)
                     Rwc_PV(nr,n,curiyr)=w

                     Rank_PV(nr,w)=n
                  end if
               end do
            end do
            If (Rwc_PV(nr,n,curiyr) .gt. 0 ) then
               Used_PV(Rwc_PV(nr,n,curiyr))=1
            else
               do w=1,mnumsl
                  WRITE(18,1003) curcalyr,nr,n,w,AnnCost_PV(nr,curiyr,w)
 1003             format(1X,"Oops_used",5(":",I4),":",F20.6)
               end do
            end if
         end do

      end if

      return
      end

!     Subroutine SolarRank_PT determines the costs for each wind category and then ranks the categories
!     according to some criteria - typically lowest to highest cost.

      subroutine SolarRank_PT

      implicit none
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'ecpcntl'
      include 'control'
      include 'wrenew'
      include 'wwind'
      include 'wrenio'
      include 'bildout'
      include 'entcntl'
      include 'enewtech'
      include 'bildin'
      include 'uefdout'
!
      INTEGER*4 RCAP
      INTEGER*4 GSYR1
      INTEGER*4 GSYRL
      INTEGER*4 ICAP
      INTEGER*4 IFPH2
      INTEGER*4 IP
      INTEGER*4 IS
      INTEGER*4 JYR
      INTEGER*4 OLYR
      INTEGER*4 YEAR
!
      REAL*4 CPR(ECP_D_LCP)
      REAL*4 EWGINT
      REAL*4 EWGROE
      REAL*4 EWGROR
!
      REAL*8 CAPLEV
      REAL*8 CAPNNSTL
      REAL*8 CAPNUG
      REAL*8 CRF
      REAL*8 FNBOOK
      REAL*8 ITCADJ
      REAL*8 OVRCST
      REAL*8 PRATIO
      REAL*8 PVGNP
      REAL*8 PWF
      REAL*8 TXBOOK
!
      integer nr,wc,t,ECPSolar,RankVer,Used_PT(mnumsl),w,b,n
      real XCost

!     Get the index for solar in ECP.

      do t=1,ECP_D_CAP
         if (UPLNTCD(t).eq.'PT') ECPSolar=t
      end do

!     Get costs for wind from the utility model.
!     Compute CapCost in regional loop now

      if (ECP_D_OVFX(ECPSolar).eq.0) then
         OMFCost_PT=UPFOM(ECPSolar)
      else
         OMFCost_PT=UPOVFX(ECPSolar,curiyr)
      end if
      if (ECP_D_OVVR(ECPSolar).eq.0) then
         OMVCost_PT=UPVOM(ECPSolar)
      else
         OMVCost_PT=UPOVVR(ECPSolar,curiyr)
      end if
!
      do nr=1,unrgns
         call GETBLD(1,nr)
         YEAR = 1
         IS = 1
         ICAP = ECPSolar
         IP = UCPINTIS(ICAP)
         RCAP = UIRINTI(IP)
         OLYR = YEAR + UPPLYR(ICAP)
         GSYR1 = UPGSY1(ICAP) - UHBSYR
         GSYRL = UPGSYL(ICAP) - UHBSYR
         IFPH2 = UNFPH - OLYR + 1
         IF (EPDSCRT .LT. 0.09) EPDSCRT = 0.09
         IF (EPCCSUP(RCAP,IS) .LT. 0.09) EPCCSUP(RCAP,IS) = 0.09
         DO JYR = 1, ECP_D_LCP
            CPR(JYR) = UPCPRO(ICAP,JYR)
         END DO
         EWGROE = EPUCRE + UPNRPRM
         EWGINT = EPUIRT + UPNIPRM
         EWGROR = EWGROE * (1.0 - UPNFDT) + EWGINT * UPNFDT
         IF (UPGSUB(ICAP) .GT. 0.0 .AND. (CURIYR + OLYR - 1) .GE. GSYR1 .AND. (CURIYR + OLYR - 1) .LE. GSYRL) THEN
            ITCADJ = 1.0 - UPCSB(ICAP)
         ELSE
            ITCADJ = 1.0
         ENDIF
         OVRCST = (EPIROVR(RCAP)/ITCADJ) * UPLRPC(ICAP) * UPLROPT(ICAP) * UPLRLC(ICAP) * EPRGM(ICAP) * EPACM(ICAP) * EPCCSUP(RCAP,IS) * UPANNADJ(ICAP,CURIYR)
         CALL EPINCST(MNUMYR,ECP_D_XPH,ECP_D_FPH,ECP_D_LCP,UPCLYR(ICAP),UPPLYR(ICAP),CURIYR,YEAR,OVRCST,CPR,UPCAPD(1,ICAP),UPGNPD,EWGINT,UPNFDT,EWGROR,TXBOOK,FNBOOK)
         PRATIO = TXBOOK / FNBOOK
         CAPNNSTL = FNBOOK
         CALL EPCNBLD(DBLE(UPNFDT),PRATIO,DBLE(UPNRPRM),DBLE(UPNIPRM),DBLE(EPUCRE),DBLE(EPUIRT),DBLE(UPTXRT),UPTXLF(ICAP),UPNCLF(ICAP),UPNLLF(ICAP),CAPNUG)
         CALL EP$LGNP(OLYR,IFPH2,EPDSCRT,PVGNP)
         CAPLEV = (( CAPNNSTL * CAPNUG ) / CRF(DBLE(EPDSCRT - UPRSK(ICAP)),IFPH2) ) * PWF(DBLE(EPDSCRT - UPRSK(ICAP)),OLYR)
         CAPLEV = CAPLEV / PVGNP
         FixChg_PT = CAPLEV / OVRCST
         if ( isnan(FixChg_PT) ) then
            FixChg_PT = 0.13

            WRITE(18,3333) CURIYR, CURITR, nr, ECP_D_FPH, ECP_D_LCP, ECP_D_XPH, ECPSolar, GSYR1, GSYRL, ICAP, IFPH2, IP, IS, MNUMYR, OLYR, RCAP, UCPINTIS(ICAP), &
               UIRINTI(IP), UHBSYR, UNFPH, UPCLYR(ICAP), UPGSY1(ICAP), UPGSYL(ICAP), UPNCLF(ICAP), UPNLLF(ICAP), UPPLYR(ICAP), UPTXLF(ICAP), YEAR
 3333       FORMAT(1X,"EPLVFCF0:PT",28(":",I4))

            WRITE(18,3334) CURIYR, CURITR, nr, &
               CAPLEV, CAPNNSTL, CAPNUG, EPACM(ICAP), EPCCSUP(RCAP,IS), EPDSCRT, EPIROVR(RCAP), &
               EPLVFCF(ICAP,2), EPRGM(ICAP), EPUCRE, EPUIRT, EWGINT, EWGROE, EWGROR, FNBOOK, ITCADJ, OVRCST, PRATIO, PVGNP, TXBOOK, UPCAPD(1,ICAP), &
               UPCSB(ICAP), UPGSUB(ICAP), UPLRLC(ICAP), UPLROPT(ICAP), UPLRPC(ICAP), UPNFDT, UPNIPRM, UPNRPRM, UPRSK(ICAP), UPTXRT,UPANNADJ(ICAP,CURIYR)
 3334       FORMAT(1X,"EPLVFCF1:PT",3(":",I4),36(":",E10.3))

            WRITE(18,3335) CURIYR, CURITR, nr, (UPCPRO(ICAP,JYR),JYR= 1, ECP_D_LCP)
 3335       FORMAT(1X,"EPLVFCF2:PT",3(":",I4),35(":",E10.3))

            WRITE(18,3336) CURIYR, CURITR, nr, (UPGNPD(JYR),JYR=1,MNUMYR)
 3336       FORMAT(1X,"EPLVFCF3:PT",3(":",I4),<MNUMYR>(":",E10.3))

         else

            WRITE(18,4334) CURIYR,CURITR,NR,FixChg_SO,EPLVFCF(ICAP,2)
 4334       FORMAT(1X,"EPLVFCF4:PT",3(":",I4),2(":",E10.3))

         endif

         if (ECP_D_OVCC(ECPSolar).eq.0) then
            CapCostR_PT(nr) = UPOVR(ECPSolar) * UPLRPC(ECPSolar) * UPLROPT(ECPSolar) * UPLRLC(ECPSolar) * EPRGM(ECPSolar) * EPACM(ECPSolar) * UPANNADJ(ICAP,CURIYR)
         else
            CapCostR_PT(nr) = UPOVCC(ECPSolar,curiyr) * UPLRPC(ECPSolar) * UPLROPT(ECPSolar) * UPLRLC(ECPSolar) * EPRGM(ECPSolar) * EPACM(ECPSolar) * UPANNADJ(ECPSolar,CURIYR)
         endif

!        Determine the annualized cost per kwh by region, year, wind class, and buffer zone.

         do wc=1,mnumsl

               ICCCostR_PT(nr,wc,curiyr)=CapCostR_PT(nr)

!              If XSwitch is not 0 then use the long-term multiplier by wind class in the capital cost.

               if (XSwitch.eq.0) then
                  AnnCost_PT(nr,curiyr,wc)=(ICCCostR_PT(nr,wc,curiyr)*FixChg_PT+OMFCost_PT+ WNTDBFCS(nr,1)*FixChg_PT)/(CF_PT(curiyr,wc)*8760.0)+OMVCost_PT/1000

!                 WRITE(18,2003) CURIYR+1989,CURITR,nr,wc, AnnCost_PT(nr,curiyr,wc), ICCCostR_PT(nr,wc,curiyr), FixChg_PT, OMFCost_PT,  &
!                    WNTDBFCS(nr), CF_PT(curiyr,wc), OMVCost_PT
 2003             format(1X,"AnnCost:PT:0",5(":",I5),7(":",F15.6))

               else
                  AnnCost_PT(nr,curiyr,wc) = (ICCCostR_PT(nr,wc,curiyr) * XLTElas_PT(nr,wc) * FixChg_PT + OMFCost_PT + WNTDBFCS(nr,1) * FixChg_PT) / (CF_PT(curiyr,wc) * 8760.0) + OMVCost_PT / 1000

!                 WRITE(18,2004) CURIYR+1989,CURITR,nr,wc, AnnCost_PT(nr,curiyr,wc), ICCCostR_PT(nr,wc,curiyr), XLTElas_PT(nr,wc),  &
!                    FixChg_PT, OMFCost_PT, WNTDBFCS(nr), CF_PT(curiyr,wc), OMVCost_PT
 2004             format(1X,"AnnCost:PT:1",5(":",I5),8(":",F15.6))

               end if

         end do
      end do      !region loop

!     Choose the manner of ranking: 1=original, 2=by cost (note, that in the base they are the same)

      RankVer=1
      if (RankVer.eq.1) then

!        Rank the categories according to some criteria - probably lowest to highest cost.
!        For now, they are simply ranked in wind class, buffer zone order, as in the original model.

         do nr=1,mnumnr
            RNum_PT=0
            do wc=1,mnumsl
                  RNum_PT=RNum_PT+1
                  Rwc_PT(nr,RNum_PT,curiyr)=wc
                  Rank_PT(nr,wc)=wc
            end do
         end do
      elseif (RankVer.eq.2) then
         RNum_PT=mnumsl
         do nr=1,mnumnr
            n=0
            do wc=1,mnumsl

                  n=n+1
                  Used_PT(wc)=0
                  Rwc_PT(nr,n,curiyr)=0

            end do
            n=0
            do wc=1,mnumsl

               n=n+1
               XCost=999999.9
               do w=1,mnumsl

                  if (Used_PT(w).eq.0.and.AnnCost_PT(nr,curiyr,w).lt.XCost) then

                     WRITE(18,4817) CURIRUN, CURIYR+1989, nr, n, wc, w, b, XCOST, AnnCost_PT(nr,curiyr,w)
 4817                FORMAT(1X,"Renew_windrank3:PT",8(":",I5),2(":",F21.6))

                     XCost=AnnCost_PT(nr,curiyr,w)
                     Rwc_PT(nr,n,curiyr)=w

                     Rank_PT(nr,w)=n
                  end if
               end do
            end do
            If (Rwc_PT(nr,n,curiyr) .gt. 0 ) then
               Used_PT(Rwc_SO(nr,n,curiyr))=1
            else
               do w=1,mnumsl

                  WRITE(18,1003) curcalyr,nr,n,w,AnnCost_PT(nr,curiyr,w)
 1003             format(1X,"Oops_used",5(":",I4),":",F20.6)

               end do

            end if
         end do

      end if

      return
      end


      subroutine SolarRept

      implicit none
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'ecpcntl'
      include 'control'
      include 'wrenew'
      include 'wwind'
      include 'wrenio'
      include 'rencntl'
      include 'udatout'
      include 'uefdout'

      integer wc,nr,yr,n,s,stp,WTech,WTech_SO,WTech_PV,WTech_PT,IDisp(mnumnr),i,FYR,ALASKA,HAWAII
      real XTot,YTot,RDisp_SO(mnumnr),RDisp_PV(mnumnr),RDisp_PT(mnumnr)
      character*260 rept_head

      rept_head =  '     Regn1     Regn2     Regn3     Regn4     Regn5     Regn6     Regn7     Regn8     Regn9    Regn10    Regn11    Regn12    Regn13    Regn14    Regn15    Regn16    Regn17    Regn18    Regn19    Regn20    Regn21    Regn22    Regn23    Regn24    Regn25     Total'

        ALASKA = MNUMNR - 2
        HAWAII = MNUMNR - 1

!      WTech = 10   !Solar technology number. - Shouldn't I be determining this instead of hard - wired?
      WTech_SO = 7


!     Write out the costs to the debug file.

      write(IORNREPT,'(1X,"SO",/,a,i4,a)') 'Solar Cost Variables for Year ',curcalyr,'   Note: 1 year lag in costs'
      write(IORNREPT,'(1X,"SO",a,f10.2)') 'O&M Cost:                        ',OMFCost_SO
      write(IORNREPT,'(1X,"SO",a,f10.3)') 'Fixed Charge Factor:             ',FixChg_SO

      write(IORNREPT,'(1X,"SO",a)') "Original EMM Capital Cost, Cost Multipliers by solar class, New Capital Costs by solar class"
      write(IORNREPT,'(1X,"SO",a4,a12,<mnumsl>(a5,i1),<mnumsl>(a9,i1))')"Rgn","OCC",('M',7-wc,wc=1,mnumsl),('NCC',7-wc,wc=1,mnumsl)

      do nr=1,unrgns
         write(IORNREPT,'(1X,"SO",1x,i3,2x,F10.2,<mnumsl>F6.2,<mnumsl>F10.2)') nr, CapCostR_SO(nr), (ICCMultR_SO(nr,wc,curiyr),wc=1,mnumsl), (ICCCostR_SO(nr,wc,curiyr),wc=1,mnumsl)
      enddo

      write(IORNREPT,'(1X,"SO",/,a)') 'Cost of Electricity (with Cost Rank) (Annualized Cost per Kwh in $87)'

      write(IORNREPT,'(1X,"SO",5x,a)') rept_head

      do wc=1,mnumsl

         IF (WCapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
            write(IORNREPT,'(1X,"SO",a1,i1,a1,i1,1x,<unrgns>(f10.4,i3))') 'C',7-wc,'Z',1,(AnnCost_SO(nr,curiyr,wc),Rank_SO(nr,wc),nr=1,unrgns)
      end do

      write(IORNREPT,'(1X,"SO",/,a)') 'Current "Best" Solar Class and "Best" Buffer Zone'
      write(IORNREPT,'(1X,"SO",20x,a)') rept_head

      write(IORNREPT,'(1X,"SO",a,<unrgns>i10)') 'Best Solar Class       ',(7-WCurCl_SO(nr,curiyr),nr=1,unrgns)

      if (curiyr.eq.UESTYR-UHBSYR) then

!        Write out the first year of land area to the debug file.
         write(IORNREPT,'(1X,"SO",/,a,i2)') 'Land Area Available by Region, Class, and Zone'
         write(IORNREPT,'(1X,"SO",a4,1x,<mnumsl*1>(a5,i1,a1,i1),a10)') 'NERC', (('C',7-wc,'Z',1),wc=1,mnumsl),'Total'

         do nr=1,unrgns
            XTot=0.0
            do wc=1,mnumsl
                  XTot=XTot+SoPower(nr,6,wc)
            end do
            write(IORNREPT,'(1X,"SO",i4,2x,<mnumsl>f8.0,f10.0)') nr,((SoPower(nr,6,wc)),wc=1,mnumsl),XTot
         end do

!        Write out the maximum potential capacity for all years and one sample region to the debug file.

         nr=21

         write(IORNREPT,'(1X,"SO",/,a,i2)') 'Maximum Solar Capacity Available by Year, Class, and Zone, Region ',nr

         write(IORNREPT,'(1X,"SO",a4,1x,<mnumsl>(a7,i1,a1,i1),a10)') 'Year', (('C',7-wc,'Z',1),wc=1,mnumsl),'Total'

         do yr=1,MNUMYR
            XTot=0.0
            do wc=1,mnumsl
               XTot=XTot+WCapMax_SO(nr,yr,wc)
            end do
            write(IORNREPT,'(1X,"SO",i4,2x,<mnumsl*mnumbf>f10.0,2x,f10.0)') yr+1989,((WCapMax_SO(nr,yr,wc)),wc=1,mnumsl),XTot
         end do

       else

         write(IORNREPT,'(1X,"SO",a,a)') 'Na>'
         write(IORNREPT,'(1X,"SO",a,a,i4)') 'Na>','Installed, Added, and Committed Capacity (MW) in the Current Year ',curcalyr
         write(IORNREPT,'(1X,"SO",a,20x,a,a)') 'Na>', rept_head
         write(IORNREPT,'(1X,"SO",a,a)') 'Na>','New Installed Capacity'
         write(IORNREPT,'(1X,"SO",a,a,<unrgns>f10.1,f11.1)') 'Na>','  Planned Builds      ',(CapPlnBld_SO(nr,curiyr),nr=1,unrgns),CapPlnBld_SO(mnumnr,curiyr)
         write(IORNREPT,'(1X,"SO",a,a,<unrgns>f10.1,f11.1)') 'Na>','  Committed-Now Built ',(CapNewBld_SO(nr,curiyr),nr=1,unrgns),CapNewBld_SO(mnumnr,curiyr)
         write(IORNREPT,'(1X,"SO",a,a,<unrgns>f10.1,f11.1)') 'Na>','  Total New           ',(CapAdded_SO(nr,curiyr),nr=1,unrgns),CapAdded_SO(mnumnr,curiyr)
         write(IORNREPT,'(1X,"SO",a,a)') 'Na>','Cumulative Installed Capacity'
         write(IORNREPT,'(1X,"SO",a,a,<unrgns>f10.1,f11.1)') 'Na>','  Total Cumulative    ',(CapInstall_SO(nr,curiyr),nr=1,unrgns),CapInstall_SO(mnumnr,curiyr)
         write(IORNREPT,'(1X,"SO",a,a)') 'Na>','Committed Capacity'
         write(IORNREPT,'(1X,"SO",a,a,<unrgns>f10.1,f11.1)') 'Na>','  Committed This Year ',(CapCommit_SO(nr,curiyr),nr=1,unrgns),CapCommit_SO(mnumnr,curiyr)
         do i=1,NLead-1
            write(IORNREPT,'(1X,"SO",a,a,i1,a,<unrgns>f10.1,f11.1)') 'Na>','  Committed Year-',i,'    ',(CapCommit_SO(nr,curiyr-i),nr=1,unrgns),CapCommit_SO(mnumnr,curiyr-i)
         end do

         write(IORNREPT,'(1X,"SO",a,a,<unrgns>f10.0,f11.0)') 'Na>','  Total Committed     ',(CapCmtTot_SO(nr,curiyr),nr=1,unrgns),CapCmtTot_SO(mnumnr,curiyr)

         write(IORNREPT,'(1X,"SO",a,a)') 'Na>','Cumulative Installed Plus Committed Capacity'
         write(IORNREPT,'(1X,"SO",a,a,<unrgns>f10.0,f11.0)') 'Na>','  Total               ',(CapIandC_SO(nr,curiyr),nr=1,unrgns),CapIandC_SO(mnumnr,curiyr)

         write(IORNREPT,'(1X,"SO",a,a)') 'Nc>'
         write(IORNREPT,'(1X,"SO",a,a,i4)') 'Nc>','Current Year Ranking by Cost (Rank) - Year ',curcalyr
         write(IORNREPT,'(1X,"SO",a,20x,a,a)') 'Nc>', rept_head

         do wc=1,mnumsl
            IF (WCapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
               write(IORNREPT,'(1X,"SO",a,2x,a,i1,a,i1,16x,<unrgns>i10)') 'Nc>','C',7-wc,'Z',1,(Rank_SO(nr,wc),nr=1,unrgns)
         end do


         write(IORNREPT,'(1X,"SO",a,a)') 'Nb>'
         write(IORNREPT,'(1X,"SO",a,a,i4)') 'Nb>','Increment in Installed Capacity (ICapInc) - Year ',curcalyr
         write(IORNREPT,'(1X,"SO",a,20x,a,a)') 'Nb>', rept_head

         do nr=1,mnumnr
            RDisp_SO(nr)=0.0
         end do
         do wc=1,mnumsl

            IF (WCapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
               write(IORNREPT,'(1X,"SO",a,2x,a,i1,a,i1,16x,<unrgns>f10.0,f11.0)') 'Nb>','C',7-wc,'Z',1,(ICapInc_SO(nr,curiyr,wc),nr=1,unrgns),ICapInc_SO(mnumnr,curiyr,wc)
            do nr=1,mnumnr
               RDisp_SO(nr)=RDisp_SO(nr)+ICapInc_SO(nr,curiyr,wc)
            end do

         end do
         write(IORNREPT,'(1X,"SO",a,2x,a,15x,<unrgns>f10.1,f11.1)') 'Nb>','Total',(RDisp_SO(nr),nr=1,unrgns),RDisp_SO(mnumcr)

         write(IORNREPT,'(1X,"SO",a,a)') 'Nb>'
         write(IORNREPT,'(1X,"SO",a,a,i4)') 'Nb>','Cumulative Installed Capacity (ICapCum) - Year ',curcalyr
         write(IORNREPT,'(1X,"SO",a,20x,a,a)') 'Nb>', rept_head

         do nr=1,mnumnr
            RDisp_SO(nr)=0.0
         end do
         do wc=1,mnumsl

            IF (WCapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
               write(IORNREPT,'(1X,"SO",a,2x,a,i1,a,i1,16x,<unrgns>f10.0,f11.0)') 'Nb>','C',7-wc,'Z',1,(ICapCum_SO(nr,curiyr,wc),nr=1,unrgns),ICapCum_SO(mnumnr,curiyr,wc)
            do nr=1,mnumnr
               RDisp_SO(nr)=RDisp_SO(nr)+ICapCum_SO(nr,curiyr,wc)
            end do
         end do

         write(IORNREPT,'(1X,"SO",a,2x,a,15x,<unrgns>f10.0,f11.0)') 'Nb>','Total',(RDisp_SO(nr),nr=1,unrgns),RDisp_SO(mnumnr)

         write(IORNREPT,'(1X,"SO",a,a)') 'Nb>'
         write(IORNREPT,'(1X,"SO",a,a,i4)') 'Nb>','Capacity Available (Accounting for Installed Only) (ICapAvl) - Year ',curcalyr
         write(IORNREPT,'(1X,"SO",a,20x,a,a)') 'Nb>', rept_head

         do nr=1,mnumnr
            RDisp_SO(nr)=0.0
         end do
         do wc=1,mnumsl

            IF (WCapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
               write(IORNREPT,'(1X,"SO",a,2x,a,i1,a,i1,16x,<unrgns>f10.0,f11.0)') 'Nb>','C',7-wc,'Z',1,(ICapAvl_SO(nr,curiyr,wc),nr=1,unrgns),ICapAvl_SO(mnumnr,curiyr,wc)
            do nr=1,mnumnr
               RDisp_SO(nr)=RDisp_SO(nr)+ICapAvl_SO(nr,curiyr,wc)
            end do
         end do

         write(IORNREPT,'(1X,"SO",a,2x,a,15x,<unrgns>f10.0,f11.0)') 'Nb>','Total',(RDisp_SO(nr),nr=1,unrgns),RDisp_SO(mnumnr)

         write(IORNREPT,'(1X,"SO",a,a)') 'Nb>'
         write(IORNREPT,'(1X,"SO",a,a,i4)') 'Nb>','Committed Capacity not yet Built (WCapInc) - Year ',curcalyr
         write(IORNREPT,'(1X,"SO",a,20x,a,a)') 'Nb>', rept_head

         do nr=1,mnumnr
            RDisp_SO(nr)=0.0
         end do
         do wc=1,mnumsl

            IF (WCapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
               write(IORNREPT,'(1X,"SO",a,2x,a,i1,a,i1,16x,<unrgns>f10.0,f11.0)') 'Nb>','C',7-wc,'Z',1,(WCapInc_SO(nr,curiyr,wc),nr=1,unrgns),WCapInc_SO(mnumnr,curiyr,wc)
            do nr=1,mnumnr
               RDisp_SO(nr)=RDisp_SO(nr)+WCapInc_SO(nr,curiyr,wc)
            end do

         end do

         write(IORNREPT,'(1X,"SO",a,2x,a,15x,<unrgns>f10.0,f11.0)') 'Nb>','Total',(RDisp_SO(nr),nr=1,unrgns),RDisp_SO(mnumnr)

         write(IORNREPT,'(1X,"SO",a,a)') 'Nb>'
         write(IORNREPT,'(1X,"SO",a,a,i4)') 'Nb>','Cumulative Installed Capacity Plus Committed not yet Built (WCapCum) - Year ',curcalyr
         write(IORNREPT,'(1X,"SO",a,20x,a,a)') 'Nb>', rept_head

         do nr=1,mnumnr
            RDisp_SO(nr)=0.0
         end do
         do wc=1,mnumsl

            IF (WCapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
               write(IORNREPT,'(1X,"SO",a,2x,a,i1,a,i1,16x,<unrgns>f10.0,f11.0)') 'Nb>','C',7-wc,'Z',1,(WCapCum_SO(nr,curiyr,wc),nr=1,unrgns),WCapCum_SO(mnumnr,curiyr,wc)
            do nr=1,mnumnr
               RDisp_SO(nr)=RDisp_SO(nr)+WCapCum_SO(nr,curiyr,wc)
            end do
         end do

         write(IORNREPT,'(1X,"SO",a,a)') 'Nb>'
         write(IORNREPT,'(1X,"SO",a,a,i4)') 'Nb>','Capacity Available (Accounting for Installed Plus Committed) (WCapAvl) - Year ',curcalyr
         write(IORNREPT,'(1X,"SO",a,20x,a,a)') 'Nb>', rept_head

         do nr=1,mnumnr
            RDisp_SO(nr)=0.0
         end do
         do wc=1,mnumsl

            IF (WCapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
               write(IORNREPT,'(1X,"SO",a,2x,a,i1,a,i1,16x,<unrgns>f10.0,f11.0)') 'Nb>','C',7-wc,'Z',1,(WCapAvl_SO(nr,curiyr,wc),nr=1,unrgns),WCapAvl_SO(mnumnr,curiyr,wc)
            do nr=1,mnumnr
               RDisp_SO(nr)=RDisp_SO(nr)+WCapAvl_SO(nr,curiyr,wc)
            end do

         end do
         write(IORNREPT,'(1X,"SO",a,2x,a,15x,<unrgns>f10.0,f11.0)') 'Nb>','Total',(RDisp_SO(nr),nr=1,unrgns),RDisp_SO(mnumnr)

         write(IORNREPT,'(1X,"SO",a,a)') 'Nb>'
         write(IORNREPT,'(1X,"SO",a,a,i4)') 'Nb>','Original Maximum Capacity Available (WCapMax) - Year ',curcalyr
         write(IORNREPT,'(1X,"SO",a,20x,a,a)') 'Nb>', rept_head

         do nr=1,mnumnr
            RDisp_SO(nr)=0.0
         end do
         do wc=1,mnumsl

            IF (WCapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
               write(IORNREPT,'(1X,"SO",a,2x,a,i1,a,i1,16x,<unrgns>f10.0,f11.0)') 'Nb>','C',7-wc,'Z',1,(WCapMax_SO(nr,curiyr,wc),nr=1,unrgns),WCapMax_SO(mnumnr,curiyr,wc)
            do nr=1,mnumnr
               RDisp_SO(nr)=RDisp_SO(nr)+WCapMax_SO(nr,curiyr,wc)
            end do
         end do
         write(IORNREPT,'(1X,"SO",a,2x,a,15x,<unrgns>f10.0,f12.0)') 'Nb>','Total',(RDisp_SO(nr),nr=1,unrgns),RDisp_SO(mnumnr)

         write(IORNREPT,'(1X,"SO",/,a)') 'Current "Best" Solar Class & Buffer Zone, Capacity Increment, and Category Tolerance'
         write(IORNREPT,'(1X,"SO",20x,a)') rept_head

         write(IORNREPT,'(1X,"SO",a,<unrgns>i8)') 'Best Solar Class       ',(7-WCurCl_SO(nr,curiyr),nr=1,unrgns)
         write(IORNREPT,'(1X,"SO",a,<unrgns>f10.1)') 'Capacity Increment    ',(CapIncr_SO(nr,curiyr),nr=1,unrgns)
         write(IORNREPT,'(1X,"SO",a,<unrgns>f10.1)') 'Category Tolerance    ',(ConsTol_SO(nr),nr=1,unrgns)

         write(IORNREPT,'(1X,"SO",/,a)') 'Potential Category Weighting - Available Capacity, Weighted Average Costs and CFs'
         write(IORNREPT,'(1X,"SO",20x,a)') rept_head

         write(IORNREPT,'(1X,"SO",a,<unrgns>i10)') 'Number of Categories  ',(ConsNum_SO(nr),nr=1,unrgns)
         write(IORNREPT,'(1X,"SO",a,<unrgns>f10.1)') 'Available Capacity    ',(ConsCap_SO(nr),nr=1,unrgns)
         write(IORNREPT,'(1X,"SO",a,<unrgns>f10.3)') 'WgtAvg LT Multiplier  ',(ConsLT_SO(nr),nr=1,unrgns)
         write(IORNREPT,'(1X,"SO",a,<unrgns>f10.3)') 'WgtAvg CC Multiplier  ',(ConsCC_SO(nr),nr=1,unrgns)
         write(IORNREPT,'(1X,"SO",a,<unrgns>f10.3)') 'WgtAvg Capacity Factor',(ConsCF_SO(nr),nr=1,unrgns)
         write(IORNREPT,'(1X,"SO",a,<unrgns>f10.2)') 'WgtAvg T&D Cost       ',(ConsTD_SO(nr),nr=1,unrgns)

!        Write the long term elasticities by solar class.

         if (XSwitch.ne.0) then
            write(IORNREPT,'(1X,"SO",/,a,i4)') 'Long-Term Elasticities/Multipliers by Solar Class in year ',curcalyr
            write(IORNREPT,'(1X,"SO",20x,a)') rept_head

            do wc=1,mnumsl
               write(IORNREPT,'(1X,"SO",a,i1)') 'Solar Class ',7-wc
               write(IORNREPT,'(1X,"SO",a,<unrgns>f10.1)') ' Committed Capacity   ',(XCapCum_SO(nr,wc),nr=1,unrgns)
               write(IORNREPT,'(1X,"SO",a,<unrgns>f10.0)') ' Maximum Capacity     ',(XCapMax_SO(nr,wc),nr=1,unrgns)
               write(IORNREPT,'(1X,"SO",a,<unrgns>f10.3)') ' Ratio                ',(XRatio_SO(nr,wc),nr=1,unrgns)
            end do
         end if

!        Write the supply curve capacities.

         write(IORNREPT,'(1X,"SO",/,a,i4)') 'Supply Curve Capacity Steps (MW) for ',curcalyr
         write(IORNREPT,'(1X,"SO",20x,a)')  rept_head

         write(IORNREPT,'(1X,"SO",a,<unrgns>f10.0)') 'Step 1                ',(UTCACA_SO(1),nr=1,unrgns)
         write(IORNREPT,'(1X,"SO",a,<unrgns>f10.0)') 'Step 2                ',(UTCACA_SO(2),nr=1,unrgns)
         write(IORNREPT,'(1X,"SO",a,<unrgns>f10.0)') 'Step 3                ',(UTCACA_SO(3),nr=1,unrgns)
         write(IORNREPT,'(1X,"SO",a,<unrgns>f10.0)') 'Total                 ',(UTCACA_SO(1)+UTCACA_SO(2)+UTCACA_SO(3),nr=1,unrgns)

!        Preserve      this year's long term multiplier for "Sx" report

         if (XSwitch.eq.0) then
            do nr=1,unrgns
               LTMult_SO(nr,curiyr) = LTElas_SO(nr)
            enddo
         else
            do nr=1,unrgns
               IF (WCurCl_SO(nr,curiyr).eq.0)WCurCl_SO(nr,curiyr)=1
               LTMult_SO(nr,curiyr) = XLTElas_SO(nr,WCurCl_SO(nr,curiyr))
            enddo
         endif

!        Combining of all the multipliers.

         write(IORNREPT,'(1X,"SO",/,a,i4)') 'Combining of Long-Term, Capital Cost, and Short-Term Multipliers for ',curcalyr
         write(IORNREPT,'(1X,"SO",20x,a)') rept_head
         write(IORNREPT,'(1X,"SO",a)') 'Long-Term Multipliers for "Best" Solar Class'

         if (XSwitch.eq.0) then
            write(IORNREPT,'(1X,"SO",a,<unrgns>f10.3)') 'Long-Term Multiplier  ',(LTElas_SO(nr),nr=1,unrgns)
         else
            write(IORNREPT,'(1X,"SO",a,<unrgns>f10.3)') 'Long-Term Multiplier  ',(XLTElas_SO(nr,WCurCl_SO(nr,curiyr)),nr=1,unrgns)

         end if
         write(IORNREPT,'(1X,"SO",a)') 'Capital Cost Multipliers for "Best" Solar Class'
         write(IORNREPT,'(1X,"SO",a,<unrgns>f10.3)') 'Capital Cost Mult.    ',(ICCMultR_SO(nr,WCurCl_SO(nr,curiyr),curiyr),nr=1,unrgns)

         write(IORNREPT,'(1X,"SO",a)') 'Short-Term Multipliers by Supply Curve Step'
         write(IORNREPT,'(1X,"SO",a,<unrgns>f10.3)') 'Short-Term, Step 1    ',(STElas_SO(1),nr=1,unrgns)
         write(IORNREPT,'(1X,"SO",a,<unrgns>f10.3)') 'Short-Term, Step 2    ',(STElas_SO(2),nr=1,unrgns)
         write(IORNREPT,'(1X,"SO",a,<unrgns>f10.3)') 'Short-Term, Step 3    ',(STElas_SO(3),nr=1,unrgns)

         write(IORNREPT,'(1X,"SO",a)') 'Resulting, Combined Multipliers for "Best" Solar Class and by Supply Curve Step'
         write(IORNREPT,'(1X,"SO",a,<unrgns>f10.3)') 'Combined, Step 1      ',(UTCSFN(nr,WTech_SO,1),nr=1,unrgns)
         write(IORNREPT,'(1X,"SO",a,<unrgns>f10.3)') 'Combined, Step 2      ',(UTCSFN(nr,WTech_SO,2),nr=1,unrgns)
         write(IORNREPT,'(1X,"SO",a,<unrgns>f10.3)') 'Combined, Step 3      ',(UTCSFN(nr,WTech_SO,3),nr=1,unrgns)


!        Write out where (which solar classes and buffer zones) the supply curve capacities come from.

         write(IORNREPT,'(1X,"SO",/,a,i4)') 'Sources for Supply Curve Capacity (MW) for ',curcalyr
         do stp=1,msptmx
            write(IORNREPT,'(1X,"SO",a,i4)') 'Source of Capacity (with Cost Rank by Solar Class and Buffer Zone) for Step ',stp
            write(IORNREPT,'(1X,"SO",5x,a)') rept_head

            do wc=1,mnumsl
               IF (WCapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
                  write(IORNREPT,'(1X,"SO",a1,i1,a1,i1,1x,<unrgns>(f10.1,i3))') 'C',7-wc,'Z',1,(SCapInc_SO(stp,nr,wc),Rank_SO(nr,wc),nr=1,unrgns)
            end do

         end do
         write(IORNREPT,'(1X,"SO",/,a,i4)') 'Miscellaneous Solar Variables by Region for ',curcalyr

      end if

      if (curiyr.eq.LASTYR)      then
         FYR = UESTYR-UHBSYR
         do nr=1,mnumnr
            if (nr.ne.ALASKA.and.nr.ne.HAWAII) then
               if (nr.le.unrgns) then
                  write(IORNREPT,'(1X,"SO",a,a,<LASTYR-FYR+1>i10)') 'SOx>',  'Best Solar Class                   ',(7-WCurCl_SO(nr,yr),yr=FYR,LASTYR)
                  write(IORNREPT,'(1X,"SO",a,a,<LASTYR-FYR+1>f10.4)') 'SOx>','Cost Of Electricity               ',(AnnCost_SO(nr,yr,WCurCl(nr,yr)),yr=FYR,LASTYR)
                  write(IORNREPT,'(1X,"SO",a,a,<LASTYR-FYR+1>f10.0)') 'SOx>','Cap Seen by ECP                   ',(WCASTEL(nr,yr),yr=FYR,LASTYR)
                  write(IORNREPT,'(1X,"SO",a,a,<LASTYR-FYR+1>f10.4)') 'SOx>','Long-Term Mult                    ',(LTMult_SO(nr,yr),yr=FYR,LASTYR)
                endif
                write(IORNREPT,'(1X,"SO",a,a)') 'SOx>','New Installed Capacity'
                write(IORNREPT,'(1X,"SO",a,a,<LASTYR-FYR+1>f10.1)') 'SOx>','  Planned Builds      ',(CapPlnBld_SO(nr,yr),yr=FYR,LASTYR)
                write(IORNREPT,'(1X,"SO",a,a,<LASTYR-FYR+1>f10.1)') 'SOx>','  Committed-Now Built ',(CapNewBld_SO(nr,yr),yr=FYR,LASTYR)
                write(IORNREPT,'(1X,"SO",a,a,<LASTYR-FYR+1>f10.1)') 'SOx>','  Total New           ',(CapAdded_SO(nr,yr),yr=FYR,LASTYR)
                write(IORNREPT,'(1X,"SO",a,a)') 'SOx>','Cumulative Installed Capacity'
                write(IORNREPT,'(1X,"SO",a,a,<LASTYR-FYR+1>f10.1)') 'SOx>','  Total Cumulative    ',(CapInstall_SO(nr,yr),yr=FYR,LASTYR)
                write(IORNREPT,'(1X,"SO",a,a)') 'SOx>','Committed Capacity'
                write(IORNREPT,'(1X,"SO",a,a,<LASTYR-FYR+1>f10.1)') 'SOx>','  Committed This Year ',(CapCommit_SO(nr,yr),yr=FYR,LASTYR)
                do i=1,NLead-1
                   write(IORNREPT,'(1X,"SO",a,a,i1,a,<LASTYR-FYR+1>f10.1)') 'SOx>','  Committed Year-',i,'    ',(CapCommit_SO(nr,yr-i),yr=FYR,LASTYR)
                end do
                write(IORNREPT,'(1X,"SO",a,a,<LASTYR-FYR+1>f10.1)') 'SOx>','  Total Committed     ',(CapCmtTot_SO(nr,yr),yr=FYR,LASTYR)
                write(IORNREPT,'(1X,"SO",a,a)') 'SOx>','Cumulative Installed Plus Committed Capacity'
                write(IORNREPT,'(1X,"SO",a,a,<LASTYR-FYR+1>f10.1)') 'SOx>','  Total               ',(CapIandC_SO(nr,yr),yr=FYR,LASTYR)
             endif
          end do

          do nr=1,mnumnr
             if (nr.ne.ALASKA.and.nr.ne.HAWAII) then
                write(IORNREPT,'(1X,"SO",a)') 'Nd>'
                write(IORNREPT,'(1X,"SO",a,a,i2)') 'Nd>','Cumulative Installed Capacity (ICapCum)  Region ',nr
                write(IORNREPT,'(1X,"SO",a,a,i2,13x,<LASTYR-FYR+1>(6x,i4))') 'Nd>','Region ',nr,(yr+1989,yr=FYR,LASTYR)
                do wc=1,mnumsl

                   IF (WCapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
                      write(IORNREPT,'(1X,"SO",a,2x,a,i1,a,i1,16x,<LASTYR-FYR+1>f10.1)') 'Nd>','C',7-wc,'Z',1,(ICapCum_SO(nr,yr,wc),yr=FYR,LASTYR)

                end do
                write(IORNREPT,'(1X,"SO",a,2x,a,i2,3x,<LASTYR-FYR+1>f10.1)') 'Nd>','Total - Region ',nr,(CapInstall_SO(nr,yr),yr=FYR,LASTYR)
             endif   !not rgns Alaska and Hawaii
          end do   !rgns 1-13,16
       endif

      call SolarReptPV
      call SolarReptPT

      return
      end

      subroutine SolarReptPV

      implicit none
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'ecpcntl'
      include 'control'
      include 'wrenew'
      include 'wwind'
      include 'wrenio'
      include 'rencntl'
      include 'udatout'
      include 'uefdout'

      integer wc,nr,yr,n,s,stp,WTech,WTech_SO,WTech_PV,WTech_PT,IDisp(mnumnr),i,FYR,ALASKA,HAWAII
      real XTot,YTot,RDisp_SO(mnumnr),RDisp_PV(mnumnr),RDisp_PT(mnumnr)
      character*260 rept_head

      rept_head =  '     Regn1     Regn2     Regn3     Regn4     Regn5     Regn6     Regn7     Regn8     Regn9    Regn10    Regn11    Regn12    Regn13    Regn14    Regn15    Regn16    Regn17    Regn18    Regn19    Regn20    Regn21    Regn22    Regn23    Regn24    Regn25     Total'

        ALASKA = MNUMNR - 2
        HAWAII = MNUMNR - 1

!      WTech = 10   !Solar technology number. - Shouldn't I be determining this instead of hard - wired?
      WTech_SO = 7

   ! PV start************************

       WTech_PV = 8


!     Write out the costs to the debug file.

       write(IORNREPT,'(1X,"PV",/,a,i4,a)') 'PV Cost Variables for Year ',curcalyr,'   Note: 1 year lag in costs'
       write(IORNREPT,'(1X,"PV",a,f10.2)') 'O&M Cost:                        ',OMFCost_PV
       write(IORNREPT,'(1X,"PV",a,f10.3)') 'Fixed Charge Factor:             ',FixChg_PV

       write(IORNREPT,'(1X,"PV",a)') "Original EMM Capital Cost, Cost Multipliers by PV class, New Capital Costs by PV class"
       write(IORNREPT,'(1X,"PV",a4,a12,<mnumsl>(a5,i1),<mnumsl>(a9,i1))')"Rgn","OCC",('M',7-wc,wc=1,mnumsl),('NCC',7-wc,wc=1,mnumsl)

       do nr=1,unrgns
          write(IORNREPT,'(1X,"PV",1x,i3,2x,F10.2,<mnumsl>F6.2,<mnumsl>F10.2)') nr, CapCostR_PV(nr), (ICCMultR_PV(nr,wc,curiyr),wc=1,mnumsl), (ICCCostR_PV(nr,wc,curiyr),wc=1,mnumsl)
       enddo

       write(IORNREPT,'(1X,"PV",/,a)') 'Cost of Electricity (with Cost Rank) (Annualized Cost per Kwh in $87)'
       write(IORNREPT,'(1X,"PV",5x,a,a)') rept_head

       do wc=1,mnumsl
          IF (WCapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
             write(IORNREPT,'(1X,"PV",a1,i1,a1,i1,1x,<unrgns>(f10.4,i3))') 'C',7-wc,'Z',1,(AnnCost_PV(nr,curiyr,wc),Rank_PV(nr,wc),nr=1,unrgns)
       end do

       write(IORNREPT,'(1X,"PV",/,a)') 'Current "Best" PV Class and "Best" Buffer Zone'
       write(IORNREPT,'(1X,"PV",20x,a)') rept_head

       write(IORNREPT,'(1X,"PV",a,<unrgns>i10)') 'Best Solar Class       ',(7-WCurCl_PV(nr,curiyr),nr=1,unrgns)

       if (curiyr.eq.UESTYR-UHBSYR) then

 !        Write out the first year of land area to the debug file.

          write(IORNREPT,'(1X,"PV",/,a,i2)') 'Land Area Available by Region, Class, and Zone'
          write(IORNREPT,'(1X,"PV",a4,1x,<mnumsl*1>(a7,i1,a1,i1),a10)') 'NERC', (('C',7-wc,'Z',1),wc=1,mnumsl),'Total'
          do nr=1,unrgns
             XTot=0.0
             do wc=1,mnumsl
                XTot=XTot+SOPower(nr,6,wc)
             end do
             write(IORNREPT,'(1X,"PV",i4,2x,<mnumsl>f10.0,2x,f10.0)') nr,((SOPower(nr,6,wc)),wc=1,mnumsl),XTot
          end do

 !        Write out the maximum potential capacity for all years and one sample region to the debug file.

          nr=21

          write(IORNREPT,'(1X,"PV",/,a,i2)') 'Maximum PV Capacity Available by Year, Class, and Zone, Region ',nr
          write(IORNREPT,'(1X,"PV",a4,1x,<mnumsl>(a7,i1,a1,i1),a10)') 'Year', (('C',7-wc,'Z',1),wc=1,mnumsl),'Total'

          do yr=1,MNUMYR
             XTot=0.0
             do wc=1,mnumsl
                XTot=XTot+WCapMax_SO(nr,yr,wc)
             end do
             write(IORNREPT,'(1X,"PV",i4,2x,<mnumsl*mnumbf>f10.0,2x,f10.0)') yr+1989,((WCapMax_SO(nr,yr,wc)),wc=1,mnumsl),XTot
          end do

       else

          write(IORNREPT,'(1X,"PV",a,a)') 'Na>'
          write(IORNREPT,'(1X,"PV",a,a,i4)') 'Na>', &
                   'Installed, Added, and Committed Capacity (MW) in the Current Year ',curcalyr
          write(IORNREPT,'(1X,"PV",a,20x,a,a)') 'Na>', rept_head

           write(IORNREPT,'(1X,"PV",a,a)') 'Na>','New Installed Capacity'
           write(IORNREPT,'(1X,"PV",a,a,<unrgns>f10.1,f11.1)') 'Na>','  Planned Builds      ',(CapPlnBld_PV(nr,curiyr),nr=1,unrgns),CapPlnBld_PV(mnumnr,curiyr)
           write(IORNREPT,'(1X,"PV",a,a,<unrgns>f10.1,f11.1)') 'Na>','  Committed-Now Built ',(CapNewBld_PV(nr,curiyr),nr=1,unrgns),CapNewBld_PV(mnumnr,curiyr)
           write(IORNREPT,'(1X,"PV",a,a,<unrgns>f10.1,f11.1)') 'Na>','  Total New           ',(CapAdded_PV(nr,curiyr),nr=1,unrgns),CapAdded_PV(mnumnr,curiyr)
           write(IORNREPT,'(1X,"PV",a,a)') 'Na>','Cumulative Installed Capacity'
           write(IORNREPT,'(1X,"PV",a,a,<unrgns>f10.1,f11.1)') 'Na>','  Total Cumulative    ',(CapInstall_PV(nr,curiyr),nr=1,unrgns),CapInstall_PV(mnumnr,curiyr)
           write(IORNREPT,'(1X,"PV",a,a)') 'Na>','Committed Capacity'
           write(IORNREPT,'(1X,"PV",a,a,<unrgns>f10.1,f11.1)') 'Na>','  Committed This Year ',(CapCommit_PV(nr,curiyr),nr=1,unrgns),CapCommit_PV(mnumnr,curiyr)

           do i=1,NLead-1
                     write(IORNREPT,'(1X,"PV",a,a,i1,a,<unrgns>f10.1,f11.1)') 'Na>','  Committed Year-',i,'    ',(CapCommit_PV(nr,curiyr-i),nr=1,unrgns),CapCommit_PV(mnumnr,curiyr-i)
           end do

           write(IORNREPT,'(1X,"PV",a,a,<unrgns>f10.1,f11.1)') 'Na>','  Total Committed     ',(CapCmtTot_PV(nr,curiyr),nr=1,unrgns),CapCmtTot_PV(mnumnr,curiyr)
           write(IORNREPT,'(1X,"PV",a,a)') 'Na>','Cumulative Installed Plus Committed Capacity'
           write(IORNREPT,'(1X,"PV",a,a,<unrgns>f10.0,f11.0)') 'Na>','  Total               ',(CapIandC_PV(nr,curiyr),nr=1,unrgns),CapIandC_PV(mnumnr,curiyr)


           write(IORNREPT,'(1X,"PV",a,a)') 'Nc>'
           write(IORNREPT,'(1X,"PV",a,a,i4)') 'Nc>', &
                   'Current Year Ranking by Cost (Rank) - Year ',curcalyr
           write(IORNREPT,'(1X,"PV",a,20x,a,a)') 'Nc>', rept_head
           do wc=1,mnumsl
              IF (WCapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
                 write(IORNREPT,'(1X,"PV",a,2x,a,i1,a,i1,16x,<unrgns>i8)') 'Nc>','C',7-wc,'Z',1,(Rank_PV(nr,wc),nr=1,unrgns)
           end do



           write(IORNREPT,'(1X,"PV",a,a)') 'Nb>'
           write(IORNREPT,'(1X,"PV",a,a,i4)') 'Nb>', &
                   'Increment in Installed Capacity (ICapInc) - Year ',curcalyr
           write(IORNREPT,'(1X,"PV",a,20x,a,a)') 'Nb>', rept_head

           do nr=1,mnumnr
              RDisp_PV(nr)=0.0
           end do
           do wc=1,mnumsl

              IF (WcapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
                 write(IORNREPT,'(1X,"PV",a,2x,a,i1,a,i1,16x,<unrgns>f10.0,f11.0)') 'Nb>','C',7-wc,'Z',1,(ICapInc_PV(nr,curiyr,wc),nr=1,unrgns),ICapInc_PV(mnumnr,curiyr,wc)
              do nr=1,mnumnr
                 RDisp_PV(nr)=RDisp_PV(nr)+ICapInc_PV(nr,curiyr,wc)
              end do
           end do

           write(IORNREPT,'(1X,"PV",a,a)') 'Nb>'
           write(IORNREPT,'(1X,"PV",a,a,i4)') 'Nb>', &
                   'Cumulative Installed Capacity (ICapCum) - Year ',curcalyr
           write(IORNREPT,'(1X,"PV",a,20x,a,a)') 'Nb>', rept_head

           do nr=1,mnumnr
              RDisp_PV(nr)=0.0
           end do
           do wc=1,mnumsl

              IF (WCapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
                 write(IORNREPT,'(1X,"PV",a,2x,a,i1,a,i1,16x,<unrgns>f10.1,f11.1)') 'Nb>','C',7-wc,'Z',1,(ICapCum_PV(nr,curiyr,wc),nr=1,unrgns),ICapCum_PV(mnumnr,curiyr,wc)
              do nr=1,mnumnr
                 RDisp_PV(nr)=RDisp_PV(nr)+ICapCum_PV(nr,curiyr,wc)
              end do
           end do

           write(IORNREPT,'(1X,"PV",a,2x,a,15x,<unrgns>f10.1,f11.1)') 'Nb>','Total',(RDisp_PV(nr),nr=1,unrgns),RDisp_PV(mnumnr)

           write(IORNREPT,'(1X,"PV",a,a)') 'Nb>'
           write(IORNREPT,'(1X,"PV",a,a,i4)') 'Nb>', &
                   'Capacity Available (Accounting for Installed Only) (ICapAvl) - Year ',curcalyr
           write(IORNREPT,'(1X,"PV",a,20x,a,a)') 'Nb>', rept_head

           do nr=1,mnumnr
              RDisp_PV(nr)=0.0
           end do
           do wc=1,mnumsl

              IF (WCapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
                 write(IORNREPT,'(1X,"PV",a,2x,a,i1,a,i1,16x,<unrgns>f10.0,f11.0)') 'Nb>','C',7-wc,'Z',1,(ICapAvl_SO(nr,curiyr,wc),nr=1,unrgns),ICapAvl_SO(mnumnr,curiyr,wc)
              do nr=1,mnumnr
                 RDisp_PV(nr)=RDisp_PV(nr)+ICapAvl_SO(nr,curiyr,wc)
              end do

           end do

           write(IORNREPT,'(1X,"PV",a,2x,a,15x,<unrgns>f10.0,f11.0)') 'Nb>','Total',(RDisp_PV(nr),nr=1,unrgns),RDisp_PV(mnumnr)

           write(IORNREPT,'(1X,"PV",a,a)') 'Nb>'
           write(IORNREPT,'(1X,"PV",a,a,i4)') 'Nb>', &
                   'Committed Capacity not yet Built (WCapInc) - Year ',curcalyr
           write(IORNREPT,'(1X,"PV",a,20x,a,a)') 'Nb>', rept_head

           do nr=1,mnumnr
              RDisp_PV(nr)=0.0
           end do
           do wc=1,mnumsl
              IF (WcapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
                 write(IORNREPT,'(1X,"PV",a,2x,a,i1,a,i1,16x,<unrgns>f10.1,f11.1)') 'Nb>','C',7-wc,'Z',1,(WCapInc_PV(nr,curiyr,wc),nr=1,unrgns),WCapInc_PV(mnumnr,curiyr,wc)
              do nr=1,mnumnr
                 RDisp_PV(nr)=RDisp_PV(nr)+WCapInc_PV(nr,curiyr,wc)
              end do
           end do

           write(IORNREPT,'(1X,"PV",a,2x,a,15x,<unrgns>f10.1,f11.1)') 'Nb>','Total',(RDisp_PV(nr),nr=1,unrgns),RDisp_PV(mnumnr)

           write(IORNREPT,'(1X,"PV",a,a)') 'Nb>'
           write(IORNREPT,'(1X,"PV",a,a,i4)') 'Nb>', &
                   'Cumulative Installed Capacity Plus Committed not yet Built (WCapCum) - Year ',curcalyr
           write(IORNREPT,'(1X,"PV",a,20x,a,a)') 'Nb>', rept_head
           do nr=1,mnumnr
              RDisp_PV(nr)=0.0
           end do
           do wc=1,mnumsl

              IF (WcapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
                 write(IORNREPT,'(1X,"PV",a,2x,a,i1,a,i1,16x,<unrgns>f10.1,f11.1)') 'Nb>','C',7-wc,'Z',1,(WCapCum_PV(nr,curiyr,wc),nr=1,unrgns),WCapCum_PV(mnumnr,curiyr,wc)
              do nr=1,mnumnr
                 RDisp_PV(nr)=RDisp_PV(nr)+WCapCum_PV(nr,curiyr,wc)
              end do

           end do
           write(IORNREPT,'(1X,"PV",a,2x,a,15x,<unrgns>f10.1,f11.1)') 'Nb>','Total',(RDisp_PV(nr),nr=1,unrgns),RDisp_PV(mnumnr)

           write(IORNREPT,'(1X,"PV",a,a)') 'Nb>'
           write(IORNREPT,'(1X,"PV",a,a,i4)') 'Nb>', &
                   'Capacity Available (Accounting for Installed Plus Committed) (WCapAvl) - Year ',curcalyr
           write(IORNREPT,'(1X,"PV",a,20x,a,a)') 'Nb>', rept_head

           do nr=1,mnumnr
              RDisp_PV(nr)=0.0
           end do
           do wc=1,mnumsl

              IF (WcapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
                 write(IORNREPT,'(1X,"PV",a,2x,a,i1,a,i1,16x,<unrgns>f10.0,f11.0)') 'Nb>','C',7-wc,'Z',1,(WCapAvl_SO(nr,curiyr,wc),nr=1,unrgns),WCapAvl_SO(mnumnr,curiyr,wc)
              do nr=1,mnumnr
                 RDisp_PV(nr)=RDisp_PV(nr)+WCapAvl_SO(nr,curiyr,wc)
              end do
           end do
           write(IORNREPT,'(1X,"PV",a,2x,a,15x,<unrgns>f10.0,f11.0)') 'Nb>','Total',(RDisp_PV(nr),nr=1,unrgns),RDisp_PV(mnumnr)

           write(IORNREPT,'(1X,"PV",a,a)') 'Nb>'
           write(IORNREPT,'(1X,"PV",a,a,i4)') 'Nb>', &
                   'Original Maximum Capacity Available (WCapMax) - Year ',curcalyr
           write(IORNREPT,'(1X,"PV",a,20x,a,a)') 'Nb>', rept_head

           do nr=1,mnumnr
              RDisp_PV(nr)=0.0
           end do
           do wc=1,mnumsl

              IF (WcapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
                 write(IORNREPT,'(1X,"PV",a,2x,a,i1,a,i1,16x,<unrgns>f10.0,f11.0)') 'Nb>','C',7-wc,'Z',1,(WcapMax_SO(nr,curiyr,wc),nr=1,unrgns),WcapMax_SO(mnumnr,curiyr,wc)
              do nr=1,mnumnr
                 RDisp_PV(nr)=RDisp_PV(nr)+WcapMax_SO(nr,curiyr,wc)
              end do
           end do
           write(IORNREPT,'(1X,"PV",a,2x,a,15x,<unrgns>f10.0,f11.0)') 'Nb>','Total',(RDisp_PV(nr),nr=1,unrgns),RDisp_PV(mnumnr)

           write(IORNREPT,'(1X,"PV",/,a)') 'Current "Best" PV Class & Buffer Zone, Capacity Increment, and Category Tolerance'
           write(IORNREPT,'(1X,"PV",20x,a)') rept_head

           write(IORNREPT,'(1X,"PV",a,<unrgns>i10)') 'Best Solar Class       ',(7-WCurCl_PV(nr,curiyr),nr=1,unrgns)
           write(IORNREPT,'(1X,"PV",a,<unrgns>f10.1)') 'Capacity Increment    ',(CapIncr_PV(nr,curiyr),nr=1,unrgns)
           write(IORNREPT,'(1X,"PV",a,<unrgns>f10.1)') 'Category Tolerance    ',(ConsTol_PV(nr),nr=1,unrgns)


           write(IORNREPT,'(1X,"PV",/,a)') 'Potential Category Weighting - Available Capacity, Weighted Average Costs and CFs'
           write(IORNREPT,'(1X,"PV",20x,a)') rept_head

           write(IORNREPT,'(1X,"PV",a,<unrgns>i10)') 'Number of Categories  ',(ConsNum_PV(nr),nr=1,unrgns)
           write(IORNREPT,'(1X,"PV",a,<unrgns>f10.1)') 'Available Capacity    ',(ConsCap_PV(nr),nr=1,unrgns)
           write(IORNREPT,'(1X,"PV",a,<unrgns>f10.3)') 'WgtAvg LT Multiplier  ',(ConsLT_PV(nr),nr=1,unrgns)
           write(IORNREPT,'(1X,"PV",a,<unrgns>f10.3)') 'WgtAvg CC Multiplier  ',(ConsCC_PV(nr),nr=1,unrgns)
           write(IORNREPT,'(1X,"PV",a,<unrgns>f10.3)') 'WgtAvg Capacity Factor',(ConsCF_PV(nr),nr=1,unrgns)
           write(IORNREPT,'(1X,"PV",a,<unrgns>f10.2)') 'WgtAvg T&D Cost       ',(ConsTD_PV(nr),nr=1,unrgns)


  !        Write the long term elasticities by PV class.

           if (XSwitch.ne.0) then
              write(IORNREPT,'(1X,"PV",/,a,i4)') 'Long-Term Elasticities/Multipliers by PV Class in year ',curcalyr
              write(IORNREPT,'(1X,"PV",20x,a)') rept_head
              do wc=1,mnumsl
                 write(IORNREPT,'(1X,"PV",a,i1)') 'PV Class ',7-wc
                 write(IORNREPT,'(1X,"PV",a,<unrgns>f10.1)') ' Committed Capacity   ',(XCapCum_SO(nr,wc),nr=1,unrgns)
                 write(IORNREPT,'(1X,"PV",a,<unrgns>f10.0)') ' Maximum Capacity     ',(XCapMax_SO(nr,wc),nr=1,unrgns)
                 write(IORNREPT,'(1X,"PV",a,<unrgns>f10.3)') ' Ratio                ',(XRatio_PV(nr,wc),nr=1,unrgns)
              end do
           end if

  !        Write the supply curve capacities.

           write(IORNREPT,'(1X,"PV",/,a,i4)') 'Supply Curve Capacity Steps (MW) for ',curcalyr
           write(IORNREPT,'(1X,"PV",20x,a)') rept_head

           write(IORNREPT,'(1X,"PV",a,<unrgns>f10.0)') 'Step 1                ',(UTCACA_PV(1),nr=1,unrgns)
           write(IORNREPT,'(1X,"PV",a,<unrgns>f10.0)') 'Step 2                ',(UTCACA_PV(2),nr=1,unrgns)
           write(IORNREPT,'(1X,"PV",a,<unrgns>f10.0)') 'Step 3                ',(UTCACA_PV(3),nr=1,unrgns)
           write(IORNREPT,'(1X,"PV",a,<unrgns>f10.0)') 'Total                 ',(UTCACA_PV(1)+UTCACA_PV(2)+UTCACA_PV(3),nr=1,unrgns)

  !        Preserve      this year's long term multiplier for "Sx" report

           if (XSwitch.eq.0) then
              do nr=1,unrgns
                 LTMult_PV(nr,curiyr) = LTElas_PV(nr)
              enddo
           else
              do nr=1,unrgns
                 IF (WCurCl_PV(nr,curiyr).eq.0) WCurCl_PV(nr,curiyr)=1
                 LTMult_PV(nr,curiyr) = XLTElas_PV(nr,WCurCl_PV(nr,curiyr))
              enddo
           endif

  !        Combining of all the multipliers.

           write(IORNREPT,'(1X,"PV",/,a,i4)') 'Combining of Long-Term, Capital Cost, and Short-Term Multipliers for ',curcalyr
           write(IORNREPT,'(1X,"PV",20x,a)') rept_head
           write(IORNREPT,'(1X,"PV",a)') 'Long-Term Multipliers for "Best" PV Class'

           if (XSwitch.eq.0) then
              write(IORNREPT,'(1X,"PV",a,<unrgns>f10.3)') 'Long-Term Multiplier  ',(LTElas_PV(nr),nr=1,unrgns)
           else
              write(IORNREPT,'(1X,"PV",a,<unrgns>f10.3)') 'Long-Term Multiplier  ',(XLTElas_PV(nr,WCurCl_PV(nr,curiyr)),nr=1,unrgns)
           end if
           write(IORNREPT,'(1X,"PV",a)') 'Capital Cost Multipliers for "Best" PV Class'
           write(IORNREPT,'(1X,"PV",a,<unrgns>f10.3)') 'Capital Cost Mult.    ',(ICCMultR_PV(nr,WCurCl_PV(nr,curiyr),curiyr),nr=1,unrgns)

           write(IORNREPT,'(1X,"PV",a)') 'Short-Term Multipliers by Supply Curve Step'
           write(IORNREPT,'(1X,"PV",a)') 'Resulting, Combined Multipliers for "Best" PV Class and by Supply Curve Step'

  !        Write out where (which PV classes and buffer zones) the supply curve capacities come from.

           write(IORNREPT,'(1X,"PV",/,a,i4)') 'PVurces for Supply Curve Capacity (MW) for ',curcalyr
           do stp=1,msptmx
              write(IORNREPT,'(1X,"PV",a,i4)') 'PVurce of Capacity (with Cost Rank by PV Class and Buffer Zone) for Step ',stp
              write(IORNREPT,'(1X,"PV",5x,a)') rept_head

              do wc=1,mnumsl
                 IF (WcapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
                    write(IORNREPT,'(1X,"PV",a1,i1,a1,i1,1x,<unrgns>(f10.1,i3))') 'C',7-wc,'Z',1,(SCapInc_PV(stp,nr,wc),Rank_PV(nr,wc),nr=1,unrgns)
              end do
           end do
           write(IORNREPT,'(1X,"PV",/,a,i4)') 'Miscellaneous PV Variables by Region for ',curcalyr

        end if

        if (curiyr.eq.LASTYR)      then
           FYR = UESTYR-UHBSYR
           do nr=1,mnumnr
              if (nr.ne.ALASKA.and.nr.ne.HAWAII) then
                 if (nr.le.unrgns) then
                    write(IORNREPT,'(1X,"PV",a,a,<LASTYR-FYR+1>i10)') 'PVx>',  'Best PV Class                   ',(7-WCurCl_PV(nr,yr),yr=FYR,LASTYR)
                    write(IORNREPT,'(1X,"PV",a,a,<LASTYR-FYR+1>f10.4)') 'PVx>','Cost Of Electricity               ',(AnnCost_PV(nr,yr,WCurCl(nr,yr)),yr=FYR,LASTYR)
                    write(IORNREPT,'(1X,"PV",a,a,<LASTYR-FYR+1>f10.0)') 'PVx>','Cap Seen by ECP                   ',(WCASTEL(nr,yr),yr=FYR,LASTYR)
                    write(IORNREPT,'(1X,"PV",a,a,<LASTYR-FYR+1>f10.4)') 'PVx>','Long-Term Mult                    ',(LTMult_PV(nr,yr),yr=FYR,LASTYR)
                 endif
                 write(IORNREPT,'(1X,"PV",a,a)') 'PVx>','New Installed Capacity'
                 write(IORNREPT,'(1X,"PV",a,a,<LASTYR-FYR+1>f10.1)') 'PVx>','  Planned Builds      ',(CapPlnBld_PV(nr,yr),yr=FYR,LASTYR)
                 write(IORNREPT,'(1X,"PV",a,a,<LASTYR-FYR+1>f10.1)') 'PVx>','  Committed-Now Built ',(CapNewBld_PV(nr,yr),yr=FYR,LASTYR)
!!                 write(IORNREPT,'(1X,"PV",a,a,<LASTYR-FYR+1>f10.1)') 'PVx>','  Total New           ',(CapAdded_PV(nr,yr),yr=FYR,LASTYR)
!!                 write(IORNREPT,'(1X,"PV",a,a)') 'PVx>','Cumulative Installed Capacity'
!!                 write(IORNREPT,'(1X,"PV",a,a,<LASTYR-FYR+1>f10.1)') 'PVx>','  Total Cumulative    ',(CapInstall_PV(nr,yr),yr=FYR,LASTYR)
!!                 write(IORNREPT,'(1X,"PV",a,a)') 'PVx>','Committed Capacity'
!!                 write(IORNREPT,'(1X,"PV",a,a,<LASTYR-FYR+1>f10.1)') 'PVx>','  Committed This Year ',(CapCommit_PV(nr,yr),yr=FYR,LASTYR)
!!                 do i=1,NLead-1
!!                    write(IORNREPT,'(1X,"PV",a,a,i1,a,<LASTYR-FYR+1>f10.1)') 'PVx>','  Committed Year-',i,'    ',(CapCommit_PV(nr,yr-i),yr=FYR,LASTYR)
!!                 end do
!!                 write(IORNREPT,'(1X,"PV",a,a,<LASTYR-FYR+1>f10.1)') 'PVx>','  Total Committed     ',(CapCmtTot_PV(nr,yr),yr=FYR,LASTYR)
!!                 write(IORNREPT,'(1X,"PV",a,a)') 'PVx>','Cumulative Installed Plus Committed Capacity'
!!                 write(IORNREPT,'(1X,"PV",a,a,<LASTYR-FYR+1>f10.1)') 'PVx>','  Total               ',(CapIandC_PV(nr,yr),yr=FYR,LASTYR)
              endif
           end do

!!           do nr=1,mnumnr
!!              if (nr.ne.ALASKA.and.nr.ne.HAWAII) then
!!                 write(IORNREPT,'(1X,"PV",a)') 'Nd>'
!!                 write(IORNREPT,'(1X,"PV",a,a,i2)') 'Nd>','Cumulative Installed Capacity (ICapCum)  Region ',nr
!!                 write(IORNREPT,'(1X,"PV",a,a,i2,13x,<LASTYR-FYR+1>(4x,i4))') 'Nd>','Region ',nr,(yr+1989,yr=FYR,LASTYR)
!!                 do wc=1,mnumsl
!!
!!                    IF (WCapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
!!                       write(IORNREPT,'(1X,"PV",a,2x,a,i1,a,i1,16x,<LASTYR-FYR+1>f10.1)') 'Nd>','C',7-wc,'Z',1,(ICapCum_PV(nr,yr,wc),yr=FYR,LASTYR)
!!
!!                 end do
!!                 write(IORNREPT,'(1X,"PV",a,2x,a,i2,3x,<LASTYR-FYR+1>f8.1)') 'Nd>','Total - Region ',nr,(CapInstall_PV(nr,yr),yr=FYR,LASTYR)
!!              endif   !not rgns Alaska and Hawaii
!!           end do   !rgns 1-13,16
        end if


      ! PV end************************

      return
      end

      subroutine SolarReptPT

      implicit none
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'ecpcntl'
      include 'control'
      include 'wrenew'
      include 'wwind'
      include 'wrenio'
      include 'rencntl'
      include 'udatout'
      include 'uefdout'

      integer wc,nr,yr,n,s,stp,WTech,WTech_SO,WTech_PV,WTech_PT,IDisp(mnumnr),i,FYR,ALASKA,HAWAII
      real XTot,YTot,RDisp_SO(mnumnr),RDisp_PV(mnumnr),RDisp_PT(mnumnr)
      character*260 rept_head

      rept_head =  '     Regn1     Regn2     Regn3     Regn4     Regn5     Regn6     Regn7     Regn8     Regn9    Regn10    Regn11    Regn12    Regn13    Regn14    Regn15    Regn16    Regn17    Regn18    Regn19    Regn20    Regn21    Regn22    Regn23    Regn24    Regn25     Total'

        ALASKA = MNUMNR - 2
        HAWAII = MNUMNR - 1

!      WTech = 10   !Solar technology number. - Shouldn't I be determining this instead of hard - wired?
      WTech_SO = 7


      ! PT start *****************

      WTech_PT = 9

!     Write out the costs to the debug file.

      write(IORNREPT,'(1X,"PT",/,a,i4,a)') 'PT Cost Variables for Year ',curcalyr,'   Note: 1 year lag in costs'
      write(IORNREPT,'(1X,"PT",a,f10.2)') 'O&M Cost:                        ',OMFCost_PT
      write(IORNREPT,'(1X,"PT",a,f10.3)') 'Fixed Charge Factor:             ',FixChg_PT
      write(IORNREPT,'(1X,"PT",a)') "Original EMM Capital Cost, Cost Multipliers by PT class, New Capital Costs by PT class"

!     write(IORNREPT,'(1X,"PT",a,9x,a)')"Rgn","OCC         M6        M5        M4      NCC6      NCC5      NCC4"

      write(IORNREPT,'(1X,"PT",a4,a12,<mnumsl>(a5,i1),<mnumsl>(a9,i1))')"Rgn","OCC",('M',7-wc,wc=1,mnumsl),('NCC',7-wc,wc=1,mnumsl)

      do nr=1,unrgns
         write(IORNREPT,'(1X,"PT",1x,i3,2x,F10.2,<mnumsl>F6.2,<mnumsl>F10.2)') nr, CapCostR_PT(nr), (ICCMultR_PT(nr,wc,curiyr),wc=1,mnumsl), (ICCCostR_PT(nr,wc,curiyr),wc=1,mnumsl)
      enddo

      write(IORNREPT,'(1X,"PT",/,a)') &
                  'Cost of Electricity (with Cost Rank) (Annualized Cost per Kwh in $87)'
      write(IORNREPT,'(1X,"PT",5x,a)') rept_head

      do wc=1,mnumsl
         IF (WcapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
            write(IORNREPT,'(1X,"PT",a1,i1,a1,i1,1x,<unrgns>(f10.4,i3))') 'C',7-wc,'Z',1,(AnnCost_PT(nr,curiyr,wc),Rank_PT(nr,wc),nr=1,unrgns)

      end do

      write(IORNREPT,'(1X,"PT",/,a)') 'Current "Best" PT Class and "Best" Buffer Zone'
      write(IORNREPT,'(1X,"PT",20x,a)') rept_head

      write(IORNREPT,'(1X,"PT",a,<unrgns>i10)') 'Best Solar Class       ',(7-WCurCl_PT(nr,curiyr),nr=1,unrgns)

!     if(curiyr.eq.6) then

      if (curiyr.eq.UESTYR-UHBSYR) then

!        Write out the first year of land area to the debug file.

         write(IORNREPT,'(1X,"PT",/,a,i2)') 'Land Area Available by Region, Class, and Zone'

!        write(IORNREPT,'(1X,"PT",a)') 'NERC    C1-Z1   C1-Z2   C1-Z3   C2-Z1   C2-Z2   C2-Z3   C3-Z1   C3-Z2   C3-Z3     Total'

         write(IORNREPT,'(1X,"PT",a4,1x,<mnumsl*1>(a5,i1,a1,i1),a10)') 'NERC', (('C',7-wc,'Z',1),wc=1,mnumsl),'Total'
         do nr=1,unrgns
            XTot=0.0
            do wc=1,mnumsl
               XTot=XTot+SOPower(nr,6,wc)
            end do
            write(IORNREPT,'(1X,"PT",i4,2x,<mnumsl>f8.0,f10.0)') nr,((SOPower(nr,6,wc)),wc=1,mnumsl),XTot
         end do

!        Write out the maximum potential capacity for all years and one sample region to the debug file.

         nr=21

         write(IORNREPT,'(1X,"PT",/,a,i2)') 'Maximum PT Capacity Available by Year, Class, and Zone, Region ',nr
         write(IORNREPT,'(1X,"PT",a4,1x,<mnumsl*1>(a7,i1,a1,i1),a10)') 'Year', (('C',7-wc,'Z',1),wc=1,mnumsl),'Total'

         do yr=1,MNUMYR
            XTot=0.0
            do wc=1,mnumsl
               XTot=XTot+WcapMax_SO(nr,yr,wc)
            end do
            write(IORNREPT,'(1X,"PT",i4,2x,<mnumsl*mnumbf>f10.0,2x,f10.0)') yr+1989,((WcapMax_SO(nr,yr,wc)),wc=1,mnumsl),XTot
         end do

      else

         write(IORNREPT,'(1X,"PT",a,a)') 'Na>'
         write(IORNREPT,'(1X,"PT",a,a,i4)') 'Na>', &
                   'Installed, Added, and Committed Capacity (MW) in the Current Year ',curcalyr
         write(IORNREPT,'(1X,"PT",a,20x,a,a)') 'Na>', rept_head

         write(IORNREPT,'(1X,"PT",a,a)') 'Na>','New Installed Capacity'
         write(IORNREPT,'(1X,"PT",a,a,<unrgns>f10.1,f11.1)') 'Na>','  Planned Builds      ',(CapPlnBld_PT(nr,curiyr),nr=1,unrgns),CapPlnBld_PT(mnumnr,curiyr)
         write(IORNREPT,'(1X,"PT",a,a,<unrgns>f10.1,f11.1)') 'Na>','  Committed-Now Built ',(CapNewBld_PT(nr,curiyr),nr=1,unrgns),CapNewBld_PT(mnumnr,curiyr)
         write(IORNREPT,'(1X,"PT",a,a,<unrgns>f10.1,f11.1)') 'Na>','  Total New           ',(CapAdded_PT(nr,curiyr),nr=1,unrgns),CapAdded_PT(mnumnr,curiyr)
         write(IORNREPT,'(1X,"PT",a,a)') 'Na>','Cumulative Installed Capacity'
         write(IORNREPT,'(1X,"PT",a,a,<unrgns>f10.1,f11.1)') 'Na>','  Total Cumulative    ',(CapInstall_PT(nr,curiyr),nr=1,unrgns),CapInstall_PT(mnumnr,curiyr)
         write(IORNREPT,'(1X,"PT",a,a)') 'Na>','Committed Capacity'
         write(IORNREPT,'(1X,"PT",a,a,<unrgns>f10.1,f11.1)') 'Na>','  Committed This Year ',(CapCommit_PT(nr,curiyr),nr=1,unrgns),CapCommit_PT(mnumnr,curiyr)

         do i=1,NLead-1
            write(IORNREPT,'(1X,"PT",a,a,i1,a,<unrgns>f10.0,f11.1)') 'Na>','  Committed Year-',i,'    ',(CapCommit_PT(nr,curiyr-i),nr=1,unrgns),CapCommit_PT(mnumnr,curiyr-i)
         end do

         write(IORNREPT,'(1X,"PT",a,a,<unrgns>f10.1,f11.1)') 'Na>','  Total Committed     ',(CapCmtTot_PT(nr,curiyr),nr=1,unrgns),CapCmtTot_PT(mnumnr,curiyr)
         write(IORNREPT,'(1X,"PT",a,a)') 'Na>','Cumulative Installed Plus Committed Capacity'
         write(IORNREPT,'(1X,"PT",a,a,<unrgns>f10.0,f11.1)') 'Na>','  Total               ',(CapIandC_PT(nr,curiyr),nr=1,unrgns),CapIandC_PT(mnumnr,curiyr)

         write(IORNREPT,'(1X,"PT",a,a)') 'Nc>'
         write(IORNREPT,'(1X,"PT",a,a,i4)') 'Nc>', &
                   'Current Year Ranking by Cost (Rank) - Year ',curcalyr
         write(IORNREPT,'(1X,"PT",a,20x,a,a)') 'Nc>', rept_head
         do wc=1,mnumsl
            IF (WcapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
               write(IORNREPT,'(1X,"PT",a,2x,a,i1,a,i1,16x,<unrgns>i10)') 'Nc>','C',7-wc,'Z',1,(Rank_PT(nr,wc),nr=1,unrgns)
         end do

         write(IORNREPT,'(1X,"PT",a,a)') 'Nb>'
         write(IORNREPT,'(1X,"PT",a,a,i4)') 'Nb>', &
                   'Increment in Installed Capacity (ICapInc) - Year ',curcalyr
         write(IORNREPT,'(1X,"PT",a,20x,a,a)') 'Nb>', rept_head

         do nr=1,mnumnr
            RDisp_PT(nr)=0.0
         end do

         do wc=1,mnumsl
            IF (WcapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
               write(IORNREPT,'(1X,"PT",a,2x,a,i1,a,i1,16x,<unrgns>f10.1,f11.1)') 'Nb>','C',7-wc,'Z',1,(ICapInc_PT(nr,curiyr,wc),nr=1,unrgns),ICapInc_PT(mnumnr,curiyr,wc)
            do nr=1,mnumnr
               RDisp_PT(nr)=RDisp_PT(nr)+ICapInc_PT(nr,curiyr,wc)
            end do
         end do

         write(IORNREPT,'(1X,"PT",a,a)') 'Nb>'
         write(IORNREPT,'(1X,"PT",a,a,i4)') 'Nb>', &
                   'Cumulative Installed Capacity (ICapCum) - Year ',curcalyr
         write(IORNREPT,'(1X,"PT",a,20x,a,a)') 'Nb>', rept_head

         do nr=1,mnumnr
            RDisp_PT(nr)=0.0
         end do

         do wc=1,mnumsl
            IF (WcapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
               write(IORNREPT,'(1X,"PT",a,2x,a,i1,a,i1,16x,<unrgns>f10.1,f11.1)') 'Nb>','C',7-wc,'Z',1,(ICapCum_PT(nr,curiyr,wc),nr=1,unrgns),ICapCum_PT(mnumnr,curiyr,wc)
            do nr=1,mnumnr
               RDisp_PT(nr)=RDisp_PT(nr)+ICapCum_PT(nr,curiyr,wc)
            end do
         end do

         write(IORNREPT,'(1X,"PT",a,2x,a,15x,<unrgns>f10.1,f11.1)') &
                   'Nb>','Total',(RDisp_PT(nr),nr=1,unrgns),RDisp_PT(mnumnr)

         write(IORNREPT,'(1X,"PT",a,a)') 'Nb>'
         write(IORNREPT,'(1X,"PT",a,a,i4)') 'Nb>', &
                   'Capacity Available (Accounting for Installed Only) (ICapAvl) - Year ',curcalyr
         write(IORNREPT,'(1X,"PT",a,20x,a,a)') 'Nb>', rept_head

         do nr=1,mnumnr
            RDisp_PT(nr)=0.0
         end do

         do wc=1,mnumsl
            IF (WcapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
               write(IORNREPT,'(1X,"PT",a,2x,a,i1,a,i1,16x,<unrgns>f10.0,f11.0)') 'Nb>','C',7-wc,'Z',1,(ICapAvl_SO(nr,curiyr,wc),nr=1,unrgns),ICapAvl_SO(mnumnr,curiyr,wc)
            do nr=1,mnumnr
               RDisp_PT(nr)=RDisp_PT(nr)+ICapAvl_SO(nr,curiyr,wc)
            end do
         end do

         write(IORNREPT,'(1X,"PT",a,2x,a,15x,<unrgns>f10.0,f11.0)') 'Nb>','Total',(RDisp_PT(nr),nr=1,unrgns),RDisp_PT(mnumnr)

         write(IORNREPT,'(1X,"PT",a,a)') 'Nb>'
         write(IORNREPT,'(1X,"PT",a,a,i4)') 'Nb>', &
                   'Committed Capacity not yet Built (WCapInc) - Year ',curcalyr
         write(IORNREPT,'(1X,"PT",a,20x,a,a)') 'Nb>', rept_head

         do nr=1,mnumnr
            RDisp_PT(nr)=0.0
         end do
         do wc=1,mnumsl
            IF (WcapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
               write(IORNREPT,'(1X,"PT",a,2x,a,i1,a,i1,16x,<unrgns>f10.1,f11.1)') 'Nb>','C',7-wc,'Z',1,(WCapInc_PT(nr,curiyr,wc),nr=1,unrgns),WCapInc_PT(mnumnr,curiyr,wc)
            do nr=1,mnumnr
               RDisp_PT(nr)=RDisp_PT(nr)+WCapInc_PT(nr,curiyr,wc)
            end do
         end do

         write(IORNREPT,'(1X,"PT",a,2x,a,15x,<unrgns>f10.0,f11.0)') 'Nb>','Total',(RDisp_PT(nr),nr=1,unrgns),RDisp_PT(mnumnr)

         write(IORNREPT,'(1X,"PT",a,a)') 'Nb>'
         write(IORNREPT,'(1X,"PT",a,a,i4)') 'Nb>','Cumulative Installed Capacity Plus Committed not yet Built (WCapCum) - Year ',curcalyr
         write(IORNREPT,'(1X,"PT",a,20x,a,a)') 'Nb>', rept_head
         do nr=1,mnumnr
            RDisp_PT(nr)=0.0
         end do

         do wc=1,mnumsl
            IF (WcapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
               write(IORNREPT,'(1X,"PT",a,2x,a,i1,a,i1,16x,<unrgns>f10.0,f11.0)') 'Nb>','C',7-wc,'Z',1,(WCapCum_PT(nr,curiyr,wc),nr=1,unrgns),WCapCum_PT(mnumnr,curiyr,wc)
            do nr=1,mnumnr
               RDisp_PV(nr)=RDisp_PT(nr)+WCapCum_PT(nr,curiyr,wc)
            end do
         end do
         write(IORNREPT,'(1X,"PT",a,2x,a,15x,<unrgns>f10.0,f11.0)') 'Nb>','Total',(RDisp_PV(nr),nr=1,unrgns),RDisp_PV(mnumnr)
         write(IORNREPT,'(1X,"PT",a,a)') 'Nb>'
         write(IORNREPT,'(1X,"PT",a,a,i4)') 'Nb>', &
               'Capacity Available (Accounting for Installed Plus Committed) (WCapAvl) - Year ',curcalyr
         write(IORNREPT,'(1X,"PT",a,20x,a,a)') 'Nb>', rept_head

         do nr=1,mnumnr
            RDisp_PT(nr)=0.0
         end do

         do wc=1,mnumsl
            IF (WcapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
               write(IORNREPT,'(1X,"PT",a,2x,a,i1,a,i1,16x,<unrgns>f10.0,f11.0)') 'Nb>','C',7-wc,'Z',1,(WCapAvl_SO(nr,curiyr,wc),nr=1,unrgns),WCapAvl_SO(mnumnr,curiyr,wc)
            do nr=1,mnumnr
               RDisp_PT(nr)=RDisp_PT(nr)+WCapAvl_SO(nr,curiyr,wc)
            end do
         end do
         write(IORNREPT,'(1X,"PT",a,2x,a,15x,<unrgns>f10.0,f11.0)') 'Nb>','Total',(RDisp_PT(nr),nr=1,unrgns),RDisp_PT(mnumnr)

         write(IORNREPT,'(1X,"PT",a,a)') 'Nb>'
         write(IORNREPT,'(1X,"PT",a,a,i4)') 'Nb>', &
                   'Original Maximum Capacity Available (WCapMax) - Year ',curcalyr
         write(IORNREPT,'(1X,"PT",a,20x,a,a)') 'Nb>', rept_head

         do nr=1,mnumnr
            RDisp_PT(nr)=0.0
         end do

         do wc=1,mnumsl
            IF (WcapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
               write(IORNREPT,'(1X,"PT",a,2x,a,i1,a,i1,16x,<unrgns>f10.0,f11.0)') 'Nb>','C',7-wc,'Z',1,(WcapMax_SO(nr,curiyr,wc),nr=1,unrgns),WcapMax_SO(mnumnr,curiyr,wc)
            do nr=1,mnumnr
               RDisp_PT(nr)=RDisp_PT(nr)+WcapMax_SO(nr,curiyr,wc)
            end do
         end do
         write(IORNREPT,'(1X,"PT",a,2x,a,15x,<unrgns>f10.0,f11.0)') 'Nb>','Total',(RDisp_PT(nr),nr=1,unrgns),RDisp_PT(mnumnr)

         write(IORNREPT,'(1X,"PT",/,a)') &
                   'Current "Best" PT Class & Buffer Zone, Capacity Increment, and Category Tolerance'
         write(IORNREPT,'(1X,"PT",20x,a)') rept_head
         write(IORNREPT,'(1X,"PT",a,<unrgns>i10)') 'Best Solar Class       ',(7-WCurCl_PT(nr,curiyr),nr=1,unrgns)
         write(IORNREPT,'(1X,"PT",a,<unrgns>f10.1)') 'Capacity Increment    ',(CapIncr_PT(nr,curiyr),nr=1,unrgns)
         write(IORNREPT,'(1X,"PT",a,<unrgns>f10.1)') 'Category Tolerance    ',(ConsTol_PT(nr),nr=1,unrgns)

         write(IORNREPT,'(1X,"PT",/,a)') &
                   'Potential Category Weighting - Available Capacity, Weighted Average Costs and CFs'
         write(IORNREPT,'(1X,"PT",20x,a)') rept_head

         write(IORNREPT,'(1X,"PT",a,<unrgns>i10)') 'Number of Categories  ',(ConsNum_PV(nr),nr=1,unrgns)
         write(IORNREPT,'(1X,"PT",a,<unrgns>f10.1)') 'Available Capacity    ',(ConsCap_PT(nr),nr=1,unrgns)
         write(IORNREPT,'(1X,"PT",a,<unrgns>f10.3)') 'WgtAvg LT Multiplier  ',(ConsLT_PT(nr),nr=1,unrgns)
         write(IORNREPT,'(1X,"PT",a,<unrgns>f10.3)') 'WgtAvg CC Multiplier  ',(ConsCC_PT(nr),nr=1,unrgns)
         write(IORNREPT,'(1X,"PT",a,<unrgns>f10.3)') 'WgtAvg Capacity Factor',(ConsCF_PT(nr),nr=1,unrgns)
         write(IORNREPT,'(1X,"PT",a,<unrgns>f10.2)') 'WgtAvg T&D Cost       ',(ConsTD_PT(nr),nr=1,unrgns)


!        Write the long term elasticities by PT class.

         if(XSwitch.ne.0) then
            write(IORNREPT,'(1X,"PT",/,a,i4)') &
                   'Long-Term Elasticities/Multipliers by PT Class in year ',curcalyr
            write(IORNREPT,'(1X,"PT",20x,a)') rept_head
            do wc=1,mnumsl
               write(IORNREPT,'(1X,"PT",a,i1)') 'PT Class ',7-wc
               write(IORNREPT,'(1X,"PT",a,<unrgns>f10.1)') ' Committed Capacity   ',(XCapCum_SO(nr,wc),nr=1,unrgns)
               write(IORNREPT,'(1X,"PT",a,<unrgns>f10.0)') ' Maximum Capacity     ',(XCapMax_SO(nr,wc),nr=1,unrgns)
               write(IORNREPT,'(1X,"PT",a,<unrgns>f10.3)') ' Ratio                ',(XRatio_PT(nr,wc),nr=1,unrgns)
            end do
         end if

!        Write the supply curve capacities.

         write(IORNREPT,'(1X,"PT",/,a,i4)') &
                   'Supply Curve Capacity Steps (MW) for ',curcalyr
         write(IORNREPT,'(1X,"PT",20x,a)') rept_head

         write(IORNREPT,'(1X,"PT",a,<unrgns>f10.0)') 'Step 1                ',(UTCACA_PT(1),nr=1,unrgns)
         write(IORNREPT,'(1X,"PT",a,<unrgns>f10.0)') 'Step 2                ',(UTCACA_PT(2),nr=1,unrgns)
         write(IORNREPT,'(1X,"PT",a,<unrgns>f10.0)') 'Step 3                ',(UTCACA_PT(3),nr=1,unrgns)
         write(IORNREPT,'(1X,"PT",a,<unrgns>f10.0)') 'Total                 ',(UTCACA_PT(1)+UTCACA_PT(2)+UTCACA_PT(3),nr=1,unrgns)

!        Preserve      this year's long term multiplier for "Sx" report

         if (XSwitch.eq.0) then
            do nr=1,unrgns
               LTMult_PT(nr,curiyr) = LTElas_PT(nr)
            enddo
         else
            do nr=1,unrgns
               IF (WCurCl_PT(nr,curiyr).eq.0)WCurCl_PT(nr,curiyr)=1
               LTMult_PT(nr,curiyr) = XLTElas_PT(nr,WCurCl_PT(nr,curiyr))
            enddo
         endif

!        Combining of all the multipliers.

         write(IORNREPT,'(1X,"PT",/,a,i4)') &
                   'Combining of Long-Term, Capital Cost, and Short-Term Multipliers for ',curcalyr
         write(IORNREPT,'(1X,"PT",20x,a)') rept_head
         write(IORNREPT,'(1X,"PT",a)') 'Long-Term Multipliers for "Best" PT Class'

         if (XSwitch.eq.0) then
            write(IORNREPT,'(1X,"PT",a,<unrgns>f10.3)') 'Long-Term Multiplier  ',(LTElas_PT(nr),nr=1,unrgns)
         else
            write(IORNREPT,'(1X,"PT",a,<unrgns>f10.3)') 'Long-Term Multiplier  ',(XLTElas_PT(nr,WCurCl_PT(nr,curiyr)),nr=1,unrgns)

         end if
         write(IORNREPT,'(1X,"PT",a)') 'Capital Cost Multipliers for "Best" PT Class'
         write(IORNREPT,'(1X,"PT",a,<unrgns>f10.3)') 'Capital Cost Mult.    ',(ICCMultR_PT(nr,WCurCl_PT(nr,curiyr),curiyr),nr=1,unrgns)

         write(IORNREPT,'(1X,"PT",a)') 'Short-Term Multipliers by Supply Curve Step'

         write(IORNREPT,'(1X,"PT",a)') 'Resulting, Combined Multipliers for "Best" PT Class and by Supply Curve Step'


!        Write out where (which PT classes and buffer zones) the supply curve capacities come from.

         write(IORNREPT,'(1X,"PT",/,a,i4)') &
                   'PTurces for Supply Curve Capacity (MW) for ',curcalyr
         do stp=1,msptmx
            write(IORNREPT,'(1X,"PT",a,i4)') &
                   'PTurce of Capacity (with Cost Rank by PT Class and Buffer Zone) for Step ',stp
            write(IORNREPT,'(1X,"PT",5x,a)') rept_head

            do wc=1,mnumsl
               IF (WcapMax_SO(mnumnr,curiyr,wc) .GT. 0.00001) &
                  write(IORNREPT,'(1X,"PT",a1,i1,a1,i1,1x,<unrgns>(f10.0,i3))') 'C',7-wc,'Z',1,(SCapInc_PT(stp,nr,wc),Rank_PT(nr,wc),nr=1,unrgns)
            end do
         end do

         write(IORNREPT,'(1X,"PT",/,a,i4)') 'Miscellaneous PT Variables by Region for ',curcalyr

      end if

      ! PT end ********************

      return
      end


!******************************************************************


!Subroutine WindIn3_OFS reads the offshore section of the windalt file

subroutine WindIn3_OFS(InUnit)
implicit none
include 'parametr'
include 'ncntrl'
include 'emmparm'
include 'ecpcntl'
include 'control'
include 'dsmdimen'
include 'dsmcaldr'
include 'wrenew'
include 'wwind'
include 'wrenio'
include 'bildin'
include 'uefdout'

integer file_mgr
integer n,y,c,l,InUnit,i,j,nr,wc,yr,bf,ny,ECPWindOFS,t,IJ,IX,IY
      INTEGER RD$TBL,RD$R1,RD$R2,RD$I1 , RD$I2   ! Table read functions.
      INTEGER RET_CD             ! Return code from table reads
      INTEGER tempyr,temphrs(1,24),tmpMonth(12),HrCols,numYrBlks,yblk
      INTEGER CFYRS(MNUMYR),k,d,m,h
      REAL TEMPDATCF(12,24)      ! Storage for capacity factor table data
      REAL CF24(24)
      CHARACTER*12 TABNAME       ! Storage for name of table to read
real FCInc,FEInc,FXTot,FSwArea,PI
parameter(PI=3.141593)
character*18 name
character*200 FTextLine
character*50 XDummy
logical New/.false./
write(*,*)'WINDDBG - starting WindIn3_OFS ',trim(scen_date),' ',curiyr
!
!         Read in the OFf Shore section of the windalt file
!
 read(InUnit,'(////)')

!Read the amount of available land area for wind farm development.  This is by wind
!classes 4,5,6, and by regions 1 to 16, and by buffer zones 1, 2, and 3.  The units
!for area are square kilometers.  Everything starts off in year 1.
yr=1

read(InUnit,'(a)') FTextLine
!   write(*,*)FTextline
do bf=1,mnumbf
 read(InUnit,'(/)')
 do nr=1,IJUMPEMRGN
  read(InUnit,*) (FLdArea(nr,yr,wc,bf),wc=1,mnumcl)
! write(*,3334)'F_LdArea,r,y,bf ',nr,yr,bf,(FLdArea(nr,yr,wc,bf),wc=1,mnumcl)
3334 format(1x,a,3i4,3f10.0)
 end do
  read(InUnit,*) (FLdArea(mnumnr-2,yr,wc,bf),wc=1,mnumcl)
  read(InUnit,*) (FLdArea(mnumnr-1,yr,wc,bf),wc=1,mnumcl)
  read(InUnit,*) (FLdArea(mnumnr,yr,wc,bf),wc=1,mnumcl)
end do

!Read wind quality data - fraction of annual hours in each of 9 EMM slices.
read(InUnit,'(//)')
do nr=1,IJUMPEMRGN
 read(InUnit,*) (FSlice(nr,j),j=1,mnumwi)
end do
 read(InUnit,*) (FSlice(mnumnr-2,j),j=1,mnumwi)
 read(InUnit,*) (FSlice(mnumnr-1,j),j=1,mnumwi)

!Read wind quality data - fraction of annual capacity in each of 9 EMM slices.
read(InUnit,'(//)')
do nr=1,IJUMPEMRGN
 read(InUnit,*) (FSubPer(nr,j),j=1,mnumwi)
end do
 read(InUnit,*) (FSubPer(mnumnr-1,j),j=1,mnumwi)
 read(InUnit,*) (FSubPer(mnumnr-1,j),j=1,mnumwi)

! -------- read in new capacity factors
      DO IJ=1,3
         IF (IJ.EQ.1) THEN
            IX = 1
            IY = IJUMPEMRGN
         ELSEIF (IJ .EQ. 2) THEN
            IF (IJUMPEMRGN.EQ.13) THEN
               IX=14
               IY=14
            ELSEIF (IJUMPEMRGN.EQ.22) THEN
               IX=23
               IY=23
            ELSEIF (IJUMPEMRGN.EQ.25) THEN
               IX=26
               IY=26
            ENDIF
         ELSEIF (IJ .EQ. 3) THEN
            IF (IJUMPEMRGN.EQ.13) THEN
               IX=15
               IY=15
            ELSEIF (IJUMPEMRGN.EQ.22) THEN
               IX=24
               IY=24
            ELSEIF (IJUMPEMRGN.EQ.25) THEN
               IX=27
               IY=27
            ENDIF
         ENDIF

         do nr=IX,IY                ! read for each region
            WRITE (TABNAME,'(A3,I1,I1,A7)') '%WF',NR/10,MOD(NR,10),'YEARS %'
            RET_CD = RD$TBL(InUnit,TABNAME,1,1,6)
            RET_CD = RD$I1(numYrBlks,1,1)         ! number of year blocks for this region's ST
           do yblk=1,numYrBlks
            WRITE (TABNAME,'(A3,I1,I1,A7)') '%WF',NR/10,MOD(NR,10),'PARAMS%'
            RET_CD = RD$TBL(InUnit,TABNAME ,1,1,6)
            RET_CD = RD$I1(tempyr,1,1)           ! year for data block
            RET_CD = RD$I1(HrCols,1,1)           ! number of hour columns
            CFYRS(yblk) = tempyr - 1989

           !read(iunit1,*)(temphrs(1,i),i=1,HrCols)
            WRITE (TABNAME,'(A3,I1,I1,A7)') '%WF',NR/10,MOD(NR,10),'HRS   %'
            RET_CD = RD$TBL (InUnit,TABNAME, 1,1,6)  ! Identify input table
            RET_CD = RD$I2(temphrs,1,1,HrCols,1,HrCols)           ! hours for data

            WRITE (TABNAME,'(A3,I1,I1)') '%WF',NR/10,MOD(NR,10)
            RET_CD = RD$TBL (InUnit, TABNAME, 12,1,6)  ! Identify input table
            RET_CD = RD$I1(tmpMonth,1,12)           ! month of data
            RET_CD = RD$R2 (TEMPDATCF,1,1,HrCols,12,HrCols)   ! Read the capacity factor table
 !
 !          if last hour column is not for hour 24, add a column for hr 24
 !
            if (HrCols .lt. 24 .and. temphrs(1,HrCols) .ne. 24) then
               HrCols = HrCols + 1
               temphrs(1,HrCols) = 24
               do j=1,12             !for each month
                  TEMPDATCF(j,HrCols) = TEMPDATCF(j,HrCols-1)
               enddo
            endif
!
           do j=1,12         ! for each month
!
!            fill in all 24 hours of data
!
             do i=1,HrCols
                CF24(temphrs(1,i)) = TEMPDATCF(j,i)
                if (i .LT. HrCols) then
                  if (temphrs(1,i) .ge. temphrs(1,i+1)) then
                     write(*,*)'Error in WESAREA File - WF new cap factors, Rgn ',nr
                     stop
                  endif
                  if (temphrs(1,i) .lt. (temphrs(1,i+1)-1)) then
                     do k= temphrs(1,i)+1, temphrs(1,i+1)-1
                        CF24(k) = TEMPDATCF(j,i)
                     enddo
                  endif
                endif
             enddo    !HrCols
             !write(*,'(a,24F9.4)')"RNW-WF-CF2: CF24:", (CF24(i),i=1,24)
!
!            fill in for all 3 daytypes
!
            ny=CFYRS(yblk)
            do d=1,3
               do k=1,24
                  WSFWFEL_CF(nr,ny,d,j,k) = CF24(k)
               enddo
!             write(*,'(a,4i5,24F9.4)')"RNW-WF-CF2: WSFWIEL,r,y,d,m:", &
!                 nr,tempyr,d,j,(WSFWFEL_CF(1,ny,d,j,i),i=1,24)
            enddo    ! daytypes

           enddo               !  months
         enddo            !yr block
!
!        after all the year blocks have been read in  for WF in a region
!        back fill data from 1st year block to 1990, then, 'forward' fill in all other years
!
        if (CFYRS(1) .gt. 1) then
         do ny = CFYRS(1)-1, 1,  -1
            do d=1,3
              do j=1,12
               do k=1,24
                  WSFWFEL_CF(nr,ny,d,j,k) =  WSFWFEL_CF(nr,CFYRS(1),d,j,k)
               enddo
              enddo
            enddo
         enddo
        endif
!
        if (NumYrBlks .gt. 1) then
         do yblk = 1, NumYrBlks - 1
            do ny = CFYRS(yblk), CFYRS(yblk+1) - 2
             do d=1,3
              do j=1,12
               do k=1,24
                  WSFWFEL_CF(nr,ny+1,d,j,k) =  WSFWFEL_CF(nr,ny,d,j,k)
               enddo
              enddo
            enddo
          enddo
         enddo
        endif
!
!      if last year block was not MNUMYR, forward fill out to MNUMYR
!
         if (CFYRS(NumYrBlks) .ne. MNUMYR) then
          do ny = CFYRS(NumYrBlks)+1, MNUMYR
            do d=1,3
              do j=1,12
               do k=1,24
                  WSFWFEL_CF(nr,ny,d,j,k) =  WSFWFEL_CF(nr,CFYRS(numYrBlks),d,j,k)
               enddo
              enddo
            enddo
          enddo
         endif

!
  enddo    ! nr region
        ENDDO !IJ
!
!  Now, compute Average Annual Wind Cap Factor based on Input data
!
do ny=1, mnumyr
 do nr=1,unrgns
   do m=1,12
      do d=1,3
         do h=1,24
           FWindInputCF(nr,ny) = FWindInputCF(nr,ny) + (WSFWFEL_CF(nr,ny,d,m,h) * IDAYTQ(d,m)) / 8760.0
         enddo     !hr
      enddo        !daytype
   enddo           !month
 enddo             !region
enddo              !year


!Read capacity factors for wind classes 6,5,4 for 1990 to 2035 by 5 years.
read(InUnit,'(//)')
n=0
do y=1990,ENDYR+5,5
 n=n+1
 read(InUnit,*) yr,(FCFAnn(n,wc),wc=1,mnumcl)
end do
!
!Interpolate the values for capacity factors and for rotor energy.
!
do wc=1,mnumcl
 do i=1,n-1
  FCInc=(FCFAnn(i+1,wc)-FCFAnn(i,wc))/5.0
  do ny=1,6
   y=(i-1)*5+ny
   FCF(y,wc)=FCFAnn(i,wc)+(ny-1)*FCInc
  end do
 end do
end do
!do wc=1,mnumcl
! do i=1,8-1
!  FEInc=(FEnArea(i+1,wc)-FEnArea(i,wc))/5.0
!  do ny=1,6
!   y=(i-1)*5+ny
!   FArea(y,wc)=FEnArea(i,wc)+(ny-1)*FEInc
!  end do
! end do
!end do


!Read rotor energy density for wind classes 6,5,4 for 1990 to 2030 by 5 years.
!read(InUnit,'(//)')
!do y=1,9
! read(InUnit,*) yr,(FEnArea(y,wc),wc=1,mnumcl)
!end do

!Read T&D costs by buffer zone and NERC region. Units are $1987/kw.
read(InUnit,'(//)')
do nr=1,IJUMPEMRGN
 read(InUnit,*) (FWnTDBfcs(nr,bf),bf=1,mnumbf)
end do

!Read the incremental capital cost multipliers and their specification.
read(InUnit,'(//)')
read(InUnit,*) (FICCMeth(y),y=11,21),(FICCMeth(y),y=26,MNUMYR+5,5)
read(InUnit,'(1x)')
do wc=1,mnumcl
 do bf=1,mnumbf
  read(InUnit,*) (FICCMult(wc,bf,y),y=11,21),(FICCMult(wc,bf,y),y=26,MNUMYR+5,5)
 end do
end do
!Interpolate after 2010.
do wc=1,mnumcl
 do bf=1,mnumbf
  do y=21,MNUMYR,5
   FCInc=(FICCMult(wc,bf,y+5)-FICCMult(wc,bf,y))/5.0
   do ny=1,4
    FICCMult(wc,bf,y+ny)=FICCMult(wc,bf,y+ny-1)+FCInc
   end do
  end do
 end do
end do
!Line up everything.  Put ICCMults into ICCCosts if the method is not 1.
do y=1,10
 FICCMeth(y)=1
 do wc=1,mnumcl
  do bf=1,mnumbf
   FICCMult(wc,bf,y)=1.0
  end do
 end do
end do
do y=11,MNUMYR+5
 if(y.gt.21) FICCMeth(y)=FICCMeth(21)
 if(FICCMeth(y).ne.1) then
  do wc=1,mnumcl
   do bf=1,mnumbf
    FICCCost(wc,bf,y)=FICCMult(wc,bf,y)
    FICCMult(wc,bf,y)=0.0
   end do
  end do
 end if
end do
!
!Load cost and mult values and cap factors into 1 yr earlier than specified
!  so the ECP module will see the values in the correct year
!
!  do y=1,36
!   write(*,'(a,3i6,2(3f8.2),3f8.4)')'ShiftEBGF1,y,meth,cost,mult,cf:',  &
!      y,y+1989,FICCMeth(y),(FICCCost(wc,1,y),wc=1,mnumcl),(FICCMult(wc,1,y),wc=1,mnumcl),  &
!     (FCF(y,wc),wc=1,mnumcl)
!  enddo
 Do y=2,MNUMYR+5
  if (FICCMeth(y) .eq. 2) then
   FICCMeth(y-1)=FICCMeth(y)
   do wc=1,mnumcl
    if(y.le.MNUMYR)  THEN
       FCF(y-1,wc)=FCF(y,wc)
    END IF
    do bf=1,mnumbf
     FICCCost(wc,bf,y-1)=FICCCost(wc,bf,y)
     FICCMult(wc,bf,y-1)=FICCMult(wc,bf,y)
    enddo
   enddo
  endif
 enddo
!  do y=1,36
!   write(*,'(a,3i6,2(3f8.2),3f8.4)')'ShiftEBGF2,y,meth,cost,mult,cf:',  &
!      y,y+1989,FICCMeth(y),(FICCCost(wc,1,y),wc=1,mnumcl),(FICCMult(wc,1,y),wc=1,mnumcl),  &
!     (FCF(y,wc),wc=1,mnumcl)
!  enddo
!

!Load cost and mult values into each region
!
! do nr=1,mnumnr
!  do wc=1,mnumcl
!   do bf=1,mnumbf
!    do y=1,MNUMYR
!     FICCMultR(nr,wc,bf,y) = FICCMult(wc,bf,y)
!     FICCCostR(nr,wc,bf,y) = FICCCost(wc,bf,y)
!    end do
!   enddo
!  enddo
! enddo
!
!Load cost and mult values into each region
!  first get index for wind in ECP
!
 ECPWindOFS=0
 do t = 1, ECP_D_CAP
    if (UPLNTCD(t).eq.'WF') ECPWindOFS=t
 enddo
 if(ECPWindOFS.eq.0) then
    write(*,*)"ERROR:Can not find ecp offshore-wind index"
    stop
 endif
 do nr=1,unrgns
  if (nr.le.(unrgns)) Call GETBLD(1,nr)
  do wc=1,mnumcl
   do bf=1,mnumbf
    do y=1,MNUMYR+5
      FICCMultR(nr,wc,bf,y) = FICCMult(wc,bf,y)
    !  write(*,'(a,2i6,f10.2,2i6,2f10.4)')"FICCCost,wc,bf,y,eprgm,epacm:",curiyr,curitr,  &
    !      FICCCost(wc,bf,y),wc,bf,y,EPRGM(ECPWindOFS),EPACM(ECPWindOFS)
      if (nr.le.(unrgns)) then
          FICCCostR(nr,wc,bf,y) = FICCCost(wc,bf,y)*EPRGM(ECPWindOFS)*EPACM(ECPWindOFS)
      else
          FICCCostR(nr,wc,bf,y) = FICCCost(wc,bf,y)
      endif
    enddo
  enddo
 enddo
enddo
!

!
!read in Cap Minimum for short term multiplier (OFFSHORE)
!
read(InUnit,'(a)') FTextLine
 ! write(*,*)FTextline
read(InUnit,*) FSuppCapMin
  write(*,'(a,f10.1)')'Capacity Minimum for Short Term Multiplier (OFFSHORE)',  &
               FSuppCapMin

!Read the lowload input data.
read(InUnit,'(8(/))')
!Minimum coal and nuclear unit turndown by region.
do nr=1,IJUMPEMRGN
 read(InUnit,*) FCTurnDown(nr),FNTurnDown(nr)
end do
 read(InUnit,*) FCTurnDown(mnumnr-2),FNTurnDown(nr)
 read(InUnit,*) FCTurnDown(mnumnr-1),FNTurnDown(nr)
read(InUnit,'(6(/))')
!Intermittent standard deviations.
do nr=1,IJUMPEMRGN
 read(InUnit,*) (FIntStDdv(nr,j),j=1,ECP_D_INT)
end do
 read(InUnit,*) (FIntStDdv(mnumnr-2,j),j=1,ECP_D_INT)
 read(InUnit,*) (FIntStDdv(mnumnr-1,j),j=1,ECP_D_INT)
read(InUnit,'(6(/))')
!Intermittent regional correlation coefficients.
do nr=1,IJUMPEMRGN
 read(InUnit,*) (FIntRegCrl(nr,j),j=1,ECP_D_INT)
end do
 read(InUnit,*) (FIntRegCrl(mnumnr-2,j),j=1,ECP_D_INT)
 read(InUnit,*) (FIntRegCrl(mnumnr-1,j),j=1,ECP_D_INT)

!Read in capacity factor learning parameters
read(InUnit,'(7(/))')
!Overrides old forced CFs (0=force CF, 1=use learning).
read(InUnit,*) XDummy,FOverRideCF
read(InUnit,'(//)')
!Ultimate capacity factors by wind class.
read(InUnit,*) XDummy,(FCFUlt(wc),wc=1,mnumcl)
read(InUnit,'(/)')
!Known capacity factor at specified capacity level (class 6).
read(InUnit,*) XDummy,FCFAtx
read(InUnit,'(//)')
!Capacity level (GW) at which FCFAtx is specified.
read(InUnit,*) XDummy,FFixedX
read(InUnit,'(//)')
!Power density (MW/sq. km) of wind turbine.
read(InUnit,*) XDummy,FPwrDen

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!         Read in the section with variables for both ON and OFFshore
!
!read in Percent Tolerance used for both ONshore and OFF shore
!
!read(InUnit,'(////)')
!read(InUnit,'(a)') FTextLine
!  write(*,*)FTextline
!read(InUnit,*) PercentTOL
!  write(*,*)'Percent Tolerance from windalt file = ',PercentTOL

Name="WESAREA"
InUnit=File_Mgr('C',Name,NEW)
!close(InUnit)

!Land area is constant in all years so copy it over the years (actually as waste of space).
do nr=1,mnumnr
 do wc=1,mnumcl
  do bf=1,mnumbf
   do yr=2,MNUMYR
    FLdArea(nr,yr,wc,bf)=FLdArea(nr,1,wc,bf)
   end do
  end do
 end do
end do

!Calculate the maximum potential capacity for all the years, in the first year put it into available capacity.
do yr=1,MNUMYR
 do nr=1,mnumnr
  do wc=1,mnumcl
   do bf=1,mnumbf
    !First determine the swept area based upon a 5x10 turbine spacing.
    !FSwArea=(PI*FLdArea(nr,yr,wc,bf)*1000000.0)/(4.0*5.0*10.0)
    !!Then calculate the capacity (8760 converts hours to years, 1000 converts kw to mw).
    !WCapMax(nr,yr,wc,bf)=(Area(yr,wc)*SwArea)/(CF(yr,wc)*1000.0*8760.0)
    !We are going to assume that the Energy (Area) and the Capacity Factor (CF) grow at the same but
    !opposite rates each year and therefore cancel each other out.  WCapMax stays constant at its
    !first year value.
    if(yr.le.UESTYR-UHBSYR) then
      FWCapMax(nr,yr,wc,bf)= FPwrDen * FLdArea(nr,yr,wc,bf)
    else
     FWCapMax(nr,yr,wc,bf)=FWCapMax(nr,(UESTYR-UHBSYR),wc,bf)
    end if
    !if(yr.eq.5 .or. yr.eq.6) then
     !FWCapAvl(nr,yr,wc,bf)=FWCapMax(nr,yr,wc,bf)
     FICapAvl(nr,yr,wc,bf)=FWCapMax(nr,yr,wc,bf)
    !end if
   end do
  end do
 end do
end do

!Fill in the rankings in the early years (we need lagged values) using the strict hierarchy.
do yr=1,(UESTYR-UHBSYR)-1
 do nr=1,unrgns
  n=0
  do wc=1,mnumcl
   do bf=1,mnumbf
    n=n+1
    FRwc(nr,n,yr)=wc
    FRbf(nr,n,yr)=bf
   end do
  end do
 end do
end do

write(*,*)'WINDDBG - calling WinRank3_OFS ',trim(scen_date),' ',curiyr
Call WindRank3_OFS

return
end

!******************************************************************
!Subroutine WindMisc3_OFS decrements the offshore wind resources given the new planned capacity and
!determines the new "best" wind class and buffer zone.  It also converts available swept land
!area into megawatts of available capacity and calculates capacity factors by time slice.

subroutine WindMisc3_OFS
implicit none
include 'parametr'
include 'ncntrl'
include 'emmparm'
include 'ecpcntl'
include 'control'
include 'wrenew'
include 'wwind'
include 'wrenio'
include 'rencntl'
include 'udatout'
include 'uecpout'
include 'dsmdimen'
include 'dsmtfecp'
include 'entcntl'
include 'uefdout'

integer yr,nr,wc,bf,WTech,s,stp
integer t,FNumxc,FNumnc
integer x,Done,lev,n,i,h,m,d
real PI,XTot,YTot
parameter(PI=3.141593)
real FRatio,FEpsi,FMaxDiff,FAvlDiff
real FCapOut,FZLTElas,FRalph(mnumnr),FCapTemp
real FSuppCap,FValue,FCapFrac
real FNatWnCap,FCFLrn
real FBaseLdCap,FWnProb,FAllowWnCap,FExcessWn,FNWn,FFullWn,FWnRegStd,FBaseCF,FInstWind,FAveWnCap, &
 FCoalAvail,FNucAvail,FXCoalAvail,FNCoalAvail
integer JDoCFA,JDoCFB

data FEpsi/0.000001/
write(*,'(a,a,a,i4)')'WINDDBG - starting WindMisc3_OFS ',trim(scen_date),' ',curiyr
WTech=12   !Offshore Wind technology number.

!If OverRideCF=1 then overwrite the CFs at this point
if(FOverRideCF.gt.0) then
 !Calculate the slope factor CFLrn just once.
 FCFLrn=FFixedX*log(FCFAtx/FCFUlt(1))
 !Calcualte the capacity factor based upon the amount of installed capacity.
 FNatWnCap=0
 do nr=1,unrgns
  FNatWnCap = FNatWnCap+UCAPWFR(nr,curiyr)*0.001
 end do
 FNatWnCap = MAX(FFixedX , FNatWnCap)
 if (FNatWnCap .gt. 0) then
    !Adjust the capacity factors
    do wc=1,mnumcl
     FCF(curiyr,wc)=FCFUlt(wc)*exp(FCFLrn/FNatWnCap)
     !write(IORNDUMP,1010) curiyr,7-wc,CF(curiyr,wc),Area(curiyr,wc),CFLrn,CFUlt(wc),NatWnCap,trim(scen_date)
     !1010 Format('wn_CF_Learned_Performance:',i2,':',i2,':',f10.6,':',f10.1,':',3(f5.1,':'),a)
    end do
 endif
endif

!This is new accounting that takes into account the years in which each piece of capacity is added.
!This was changed in August 2004.
if(curiyr.lt.6) then
 do nr=1,unrgns
  FCapInstall(nr,curiyr)=0.0
  FCapCommit(nr,curiyr)=0.0
  FCapAdded(nr,curiyr)=0.0
  FCapNewBld(nr,curiyr)=0.0
  FCapPlnBld(nr,curiyr)=0.0
  FCapCmtTot(nr,curiyr)=0.0
  FCapIandC(nr,curiyr)=0.0
 end do
end if
!Do all the stock and flow accounting for each region.
do nr=1,unrgns
 !Get the installed capacity from the electricity model. It is the sum of utility and non-utility capacity.
 FCapInstall(nr,curiyr)=amax1(0.0,UCAPWFR(nr,curiyr))
 UTRSCU(nr,WTech)=FCapInstall(nr,curiyr)
 !Get the committed capacity and the lead time from the elecctricity model.
 FCapCommit(nr,curiyr)=UAddWFd(nr,curiyr+FNLead)
 !NLead=UPCLYR(WIWN)
 FNLead=UPPLYR(WIWF)
 FCapCommit(nr,curiyr)=UAddWFt(nr,curiyr+FNLead)
 !Capacity added is the difference between the total capacity installed this year minus last year.
 FCapAdded(nr,curiyr)=FCapInstall(nr,curiyr)-FCapInstall(nr,curiyr-1)
 !New builds is equal to what was committed FNLead number of years ago.
 FCapNewBld(nr,curiyr)=FCapCommit(nr,curiyr-FNLead)
 !Planned capacity is the difference between the capacity added and the new builds.
 FCapPlnBld(nr,curiyr)=FCapAdded(nr,curiyr)-FCapNewBld(nr,curiyr)
 !Total capacity committed is the committed capacity in this year and in previous years not yet built.
 do i=0,FNLead-1
  FCapCmtTot(nr,curiyr)=FCapCmtTot(nr,curiyr)+FCapCommit(nr,curiyr-i)
 end do
 !Total capacity installed plus total capacity committed.
 FCapIandC(nr,curiyr)=FCapInstall(nr,curiyr)+FCapCmtTot(nr,curiyr)

 !Increment the available, remaining capacity for the change ("growth") in original capacity. In general we
 !have constructed the model so original capacity is constant over time, so this doesn't usually matter.
 !However, if the growth in the original maximum is negative, then we need to be sure that if we have already
 !used some capacity in that category then we don't say there is a negative amount available.
 do n=1,FRNum
  wc=FRwc(nr,n,curiyr-1)
  bf=FRbf(nr,n,curiyr-1)
  FMaxDiff=FWCapMax(nr,curiyr,wc,bf)-FWCapMax(nr,curiyr-1,wc,bf)
  if((FICapAvl(nr,curiyr-1,wc,bf)+FMaxDiff).gt.0.0) then
   FICapAvl(nr,curiyr,wc,bf)=FICapAvl(nr,curiyr-1,wc,bf)+FMaxDiff
  else
   FICapAvl(nr,curiyr,wc,bf)=0.0
  end if
  if((FWCapAvl(nr,curiyr-1,wc,bf)+FMaxDiff).gt.0.0) then
   FWCapAvl(nr,curiyr,wc,bf)=FWCapAvl(nr,curiyr-1,wc,bf)+FMaxDiff
  else
   FWCapAvl(nr,curiyr,wc,bf)=0.0
   FAvlDiff=FWCapAvl(nr,curiyr-1,wc,bf)
   if(FAvlDiff.gt.0.0) then
    FWCapMax(nr,curiyr,wc,bf)=FWCapMax(nr,curiyr-1,wc,bf)-FAvlDiff
   else
    FWCapMax(nr,curiyr,wc,bf)=FWCapMax(nr,curiyr-1,wc,bf)
   end if
  end if
 end do

 !Now I need to allocate the various capacities into the wind classes and transmission
 !buffer zones. These need to be allocated because the wind model only knows how much
 !overall capacity had been chosen by the electricity model - it has to work backwards
 !to determine which wind classes and buffer zones it all came out of. Moreover, it
 !has to pay attention to the yearly timing of each piece, because the ranking of the
 !wind classes and buffer zones can change over time.
 !A key thing to remember is that the builds from electricity are actually the previous year.
 !The total new installed (includes planned builds and previously committed that is now built)
 !was committed NLead number of years earlier plus one more year because they are only being
 !shown to us now. So it is allocated using the rankings from NLead+1 number of years earlier.
 !These will be cumulated over time to get the overall total installed.
 !The new committed "this year" is allocated using the rankings last year. Committed in
 !previous years but not yet built is allocated using the rankings in the respective year.
 !These will be cumulated over time to get the overall total committed and then added to
 !the total installed to get the total installed plus committed.

 !Total New Installed. The new is in ICapInc, the cumulative is in ICapCum, and the available is in ICapAvl.
 !Clear out the totals.
 do wc=1,mnumcl
  do bf=1,mnumbf
   FICapInc(nr,curiyr,wc,bf)=0.0
  end do
 end do
 FCapOut=FCapAdded(nr,curiyr)
 if(FCapOut.ge.0.0) then
  !Do this if the amount of new installed capacity is greater than zero.
  do n=1,FRNum
   wc=FRwc(nr,n,curiyr-(FNLead+1))
   bf=FRbf(nr,n,curiyr-(FNLead+1))
   if(FICapAvl(nr,curiyr,wc,bf).gt.0.0) then
    if(FICapAvl(nr,curiyr,wc,bf).ge.FCapOut) then
     FICapInc(nr,curiyr,wc,bf)=FCapOut
     FICapAvl(nr,curiyr,wc,bf)=FICapAvl(nr,curiyr,wc,bf)-FCapOut
     FCapOut=0.0
    else
     FICapInc(nr,curiyr,wc,bf)=FICapAvl(nr,curiyr,wc,bf)
     FCapOut=FCapOut-FICapAvl(nr,curiyr,wc,bf)
     FICapAvl(nr,curiyr,wc,bf)=0.0
    endif
   endif
  end do
 else
  !Do this if the amount of new installed capacity is negative (retirements?).
  do n=1,FRNum
   wc=FRwc(nr,n,curiyr-(FNLead+1))
   bf=FRbf(nr,n,curiyr-(FNLead+1))
   if(FICapAvl(nr,curiyr,wc,bf).gt.0.0) then
    FICapInc(nr,curiyr,wc,bf)=FCapOut
    FCapOut=0.0
    FICapAvl(nr,curiyr,wc,bf)=FICapAvl(nr,curiyr,wc,bf)-FICapInc(nr,curiyr,wc,bf)
   endif
  end do
 endif
 !Add the increment to the cumulative running total over the years.
 do wc=1,mnumcl
  do bf=1,mnumbf
   FICapCum(nr,curiyr,wc,bf)=FICapCum(nr,curiyr-1,wc,bf)+FICapInc(nr,curiyr,wc,bf)
 end do
end do

 !Add in the committed capacity one at a time starting with the oldest.
 !The new is in WCapInc, the cumulative is in WCapCum, and the available is in WCapAvl.
 !Note that we use rankings one year back for the committments this year (because this
 !is really the beginning of the year - the committments are from last year even though
 !they are indexed for this year...). This is also convienent because we don't have
 !rankings for this year yet (it is the beginning of the year). This is also why the
 !subscripts for the committed capacity and the rankings are different by one year...
 !First put ICapAvl into WCapAvl so that we start from ICapAvl and add the increment.
 do wc=1,mnumcl
  do bf=1,mnumbf
   FWCapAvl(nr,curiyr,wc,bf)=FICapAvl(nr,curiyr,wc,bf)
   FWCapInc(nr,curiyr,wc,bf)=0.0
  end do
 end do
 do i=FNLead,1,-1
  FCapOut=FCapCommit(nr,curiyr-(i-1))
  do n=1,FRNum
   wc=FRwc(nr,n,curiyr-i)
   bf=FRbf(nr,n,curiyr-i)
   if(FWCapAvl(nr,curiyr,wc,bf).gt.0.0) then
    if(FWCapAvl(nr,curiyr,wc,bf).ge.FCapOut) then
     FWCapInc(nr,curiyr,wc,bf)=FWCapInc(nr,curiyr,wc,bf)+FCapOut
     FWCapAvl(nr,curiyr,wc,bf)=FWCapAvl(nr,curiyr,wc,bf)-FCapOut
     FCapOut=0.0
    else
     FWCapInc(nr,curiyr,wc,bf)=FWCapInc(nr,curiyr,wc,bf)+FWCapAvl(nr,curiyr,wc,bf)
     FCapOut=FCapOut-FWCapAvl(nr,curiyr,wc,bf)
     FWCapAvl(nr,curiyr,wc,bf)=0.0
    endif
   endif
  end do
 end do
 !Add the increment to the cumulative running total over the years.
 do wc=1,mnumcl
  do bf=1,mnumbf
   FWCapCum(nr,curiyr,wc,bf)=FICapCum(nr,curiyr,wc,bf)+FWCapInc(nr,curiyr,wc,bf)
 end do
end do

 !Sum up original (maximum) capacity, incremental capacity, and available capacity.
 FCapOrig(nr,curiyr)=0.0
 FCapIncr(nr,curiyr)=0.0
 FCapAvail(nr,curiyr)=0.0
 FCapCum(nr,curiyr)=0.0
 do wc=1,mnumcl
  do bf=1,mnumbf
   FCapOrig(nr,curiyr)=FCapOrig(nr,curiyr)+FWCapMax(nr,curiyr,wc,bf)
   FCapIncr(nr,curiyr)=FCapIncr(nr,curiyr)+FWCapInc(nr,curiyr,wc,bf)
   FCapAvail(nr,curiyr)=FCapAvail(nr,curiyr)+FWCapAvl(nr,curiyr,wc,bf)
   FCapCum(nr,curiyr)=FCapCum(nr,curiyr)+FWCapCum(nr,curiyr,wc,bf)
 end do
end do
end do  !Regions

!Sum all of these updated capacity categories over regions and classes and zones.
do nr=1,unrgns
 FCapInstall(unrgns,curiyr)=FCapInstall(unrgns,curiyr)+FCapInstall(nr,curiyr)
 FCapAdded(unrgns,curiyr)=FCapAdded(unrgns,curiyr)+FCapAdded(nr,curiyr)
 FCapCommit(unrgns,curiyr)=FCapCommit(unrgns,curiyr)+FCapCommit(nr,curiyr)
 FCapNewBld(unrgns,curiyr)=FCapNewBld(unrgns,curiyr)+FCapNewBld(nr,curiyr)
 FCapPlnBld(unrgns,curiyr)=FCapPlnBld(unrgns,curiyr)+FCapPlnBld(nr,curiyr)
 FCapCmtTot(unrgns,curiyr)=FCapCmtTot(unrgns,curiyr)+FCapCmtTot(nr,curiyr)
 FCapIandC(unrgns,curiyr)=FCapIandC(unrgns,curiyr)+FCapIandC(nr,curiyr)
 FCapOrig(unrgns,curiyr)=FCapOrig(unrgns,curiyr)+FCapOrig(nr,curiyr)
 FCapIncr(unrgns,curiyr)=FCapIncr(unrgns,curiyr)+FCapIncr(nr,curiyr)
 FCapAvail(unrgns,curiyr)=FCapAvail(unrgns,curiyr)+FCapAvail(nr,curiyr)
 FCapCum(unrgns,curiyr)=FCapCum(unrgns,curiyr)+FCapCum(nr,curiyr)
 do wc=1,mnumcl
  do bf=1,mnumbf
   FWCapMax(unrgns,curiyr,wc,bf)=FWCapMax(unrgns,curiyr,wc,bf)+FWCapMax(nr,curiyr,wc,bf)
   FWCapInc(unrgns,curiyr,wc,bf)=FWCapInc(unrgns,curiyr,wc,bf)+FWCapInc(nr,curiyr,wc,bf)
   FWCapAvl(unrgns,curiyr,wc,bf)=FWCapAvl(unrgns,curiyr,wc,bf)+FWCapAvl(nr,curiyr,wc,bf)
   FWCapCum(unrgns,curiyr,wc,bf)=FWCapCum(unrgns,curiyr,wc,bf)+FWCapCum(nr,curiyr,wc,bf)
   FICapInc(unrgns,curiyr,wc,bf)=FICapInc(unrgns,curiyr,wc,bf)+FICapInc(nr,curiyr,wc,bf)
   FICapAvl(unrgns,curiyr,wc,bf)=FICapAvl(unrgns,curiyr,wc,bf)+FICapAvl(nr,curiyr,wc,bf)
   FICapCum(unrgns,curiyr,wc,bf)=FICapCum(unrgns,curiyr,wc,bf)+FICapCum(nr,curiyr,wc,bf)
  end do
 end do
end do

!This is a new routine that does long-term elasticities within each wind class category.
!It is done here because the results are used in the ranking of classes and zones.
FXSwitch=1
do nr=1,unrgns
 do wc=1,mnumcl
  !Sum over wind classes and then calculate the ratio of resource used to resource available.
  !XCapCum(nr,wc)=ICapCum(nr,curiyr,wc,1)+ICapCum(nr,curiyr,wc,2)+ICapCum(nr,curiyr,wc,3)
  FXCapCum(nr,wc)=FWCapCum(nr,curiyr,wc,1)+FWCapCum(nr,curiyr,wc,2)+FWCapCum(nr,curiyr,wc,3)
  FXCapMax(nr,wc)=FWCapMax(nr,curiyr,wc,1)+FWCapMax(nr,curiyr,wc,2)+FWCapMax(nr,curiyr,wc,3)
  FXRatio(nr,wc)=0.0
  if(FXCapMax(nr,wc).ge.Fepsi) FXRatio(nr,wc)=FXCapCum(nr,wc)/FXCapMax(nr,wc)
  !Look up the elasticity using a table of 5 levels, based upon the level of the ratio.
  FXLTElas(nr,wc)=1.0
  if (UTCSSW(Wtech) .gt. 1) then
    do lev=1,5
!     write(*,'(a,6i6,3f12.2)')'wdbg3Wb1,y,i,r,wc,wtech,lev,FXLTElas,UTRSFC,FXRatio',  &
!      curiyr,curitr,nr,wc,WTech,lev,  &
!     FXLTElas(nr,wc),UTRSFC(nr,WTech,lev),FXRatio(nr,wc)
     if(UTRSFC(nr,WTech,lev).lt.FXRatio(nr,wc)) then
      FXLTElas(nr,wc)=UTCSFC(nr,WTech,lev)
!        write(*,'(a,6i6,2f12.2)')'wdbg3Wb2,y,i,r,wc,wtech,lev',  &
!            curcalyr,curitr,nr,wc,WTech,lev,  &
!            UTCSFC(nr,WTech,lev),XLTElas(nr,wc)
      end if
     end do  !levels  (steps)
  end if    !utcssw gt 1  (i.e. no long term multipliers)
 end do   !wind classes
end do    !regions

call WindRank3_OFS

!Start putting the supply curve together. Determine capacities and multipliers for each step.
!Determine the total amount of capacity in the supply curve and for each of the three steps.
!FSuppCapMin=100.0    this value now read in windalt(WESAREA) file
!write(*,*)'FSuppCap in WindMisc',FSuppCapMin
!The overall supply curve capacity is the amount of existing capacity or the minimum of SuppCapMin.
FSuppCap=amax1(FCapInstall(unrgns,curiyr),FSuppCapMin)
!The capacity for each step is based upon input parameters if the short term elasticity is being
!used. Otherwise the steps are evenly split within the total supply curve capacity.
if(UTCSSW(WTech).eq.1.or.UTCSSW(WTech).eq.3) then
 !The first step on the curve is the total times the value of USTTHR
 FUTCACA(1)=FSuppCap*USTTHR(WTech)
 !The remaining steps are evenly split within the total times the value of USTCAMX minus the first step.
 if(msptmx.gt.1) then
  do stp=2,msptmx
   FUTCACA(stp)=(USTCAMX(WTech)*FSuppCap-FUTCACA(1))/(msptmx-1)
   FUTCACA(stp)=amax1(FUTCACA(stp),0.0)
  end do
 end if
elseif(UTCSSW(WTech).eq.2) then
 !The steps are evenly split within the total supply curve capacity.
 !do stp=1,msptmx
 ! FUTCACA(stp)=(USTCAMX(WTech)*FSuppCap)/msptmx
 !end do
  !CRN - July 05, change capacity limit to match ECP short-term elast function.
 do stp=1,ECP_D_SSTP
    FUTCACA(stp)=(ESTCPLIM(WIWF,stp))/msptmx
 enddo
end if
!Put the supply curve steps into a variable for the utility model
do stp=1,msptmx
 UTCAFN(WTech,stp)=FUTCACA(stp)
end do

!The short-term elasticities are evaluated based upon the midpoints of each step (cumulated), except
!for the first step which is based on the full (threshold) amount of the step.
FValue=0.0
do stp=1,msptmx
 FUTCACS(stp)=FValue+FUTCACA(stp)/2.0
 FValue=FValue+FUTCACA(stp)
end do
FUTCACS(1)=FUTCACA(1)
!Determine the short-term elasticities for each of the supply steps.
do stp=1,msptmx
 FSTElas(stp)=0.0
 if(UTCSSW(WTech).eq.1.or.UTCSSW(WTech).eq.3) then
  FCapFrac=amax1(1.0,(FUTCACS(stp)+FSuppCap)/FSuppCap)
  !If CapFrac is above a threshold level then calculate a short-term elasticity for this step.
  if((FCapFrac-1.0).le.USTTHR(WTech)) then
   FSTElas(stp)=1.0
  else
   FSTElas(stp)=(FCapFrac-USTTHR(WTech))**(alog(1.0+USTICS(WTech))/alog(1.0+USTICA(WTech)))
  end if
 end if
end do

!  For reporting purposes, evaluate where supply curve steps fall in array of available
!  capacity by its ranking by region, wind classes, and buffer zones.

   do nr=1,unrgns
      do n=1,FRNum
         wc=FRwc(nr,n,curiyr)
         bf=FRbf(nr,n,curiyr)
                         if(wc .ne. 0 .and. bf .ne. 0) then
         FSCapAvl(nr,wc,bf)=FWCapAvl(nr,curiyr,wc,bf)
                         else
write(6,'("potential subscript trouble in ",5I4)') nr,wc,bf,n,FRNum
                         endif
      end do
      do stp=1,msptmx
         FCapOut=FUTCACA(stp)
         do n=1,FRNum
            wc=FRwc(nr,n,curiyr)
            bf=FRbf(nr,n,curiyr)
                         if(wc .ne. 0 .and. bf .ne. 0) then
            FSCapInc(stp,nr,wc,bf)=0.0
            if(FSCapAvl(nr,wc,bf).gt.0.0) then
               if(FSCapAvl(nr,wc,bf).ge.FCapOut) then
                  FSCapInc(stp,nr,wc,bf)=FCapOut
                  FCapOut=0.0
                  FSCapAvl(nr,wc,bf)=FSCapAvl(nr,wc,bf)-FSCapInc(stp,nr,wc,bf)
               else
                  FSCapInc(stp,nr,wc,bf)=FSCapAvl(nr,wc,bf)
                  FCapOut=FCapOut-FSCapInc(stp,nr,wc,bf)
                  FSCapAvl(nr,wc,bf)=0.0
               end if
            end if
                         else
write(6,'("    ditto subscript trouble in ",5I4)') nr,wc,bf,n,FRNum
                         endif
         end do
      end do
   end do

!Determine "best" wind class and buffer zone.  This is class and zone that is used for all the
!current characteristics.  This has been modified so that it doesn't pick a class/zone with virtually
!no capacity in it and set this up as the capacity constraint.  For this it picks a class/zone where
!it has found at least an amount equal to the percent tolerance times the capacity increment from the prior year
!in that region.  It then creates a weighted average LT cost, CC cost, Cap Fac and T&D Cost.
!do nr=1,unrgns
! Done=0
! do n=1,RNum
!  wc=Rwc(nr,n,curiyr)
!  bf=Rbf(nr,n,curiyr)
!  if(Done.eq.0) then
!   if(WCapAvl(nr,curiyr,wc,bf).gt.0.or.n.eq.RNum) then
!    WCurCl(nr,curiyr)=wc
!    WCurBf(nr,curiyr)=bf
!    Done=1
!   end if
!  end if
! end do
!end do
do nr=1,unrgns
 !CapTemp=UTCACA(1)*0.05
! FConsTol(nr)=FCapIncr(nr,curiyr)*PercentTOL
 FConsTol(nr)=max(5.0,FCapIncr(nr,curiyr)*PercentTOL)
   ! write(*,'(a,4i6,3f12.1)')'WFMisc3,y,i,r,Wtech,pcttol,capincr,constol',  &
   !     curiyr,curitr,nr,WTech,PercentTOL,FCapIncr(nr,curiyr),FConsTol(nr)
 FConsNum(nr)=0
 FConsCap(nr)=0.0
 FConsLT(nr)=0.0
 FConsCC(nr)=0.0
 FConsCF(nr)=0.0
 FConsTD(nr)=0.0
 Done=0
 do n=1,FRNum
  wc=FRwc(nr,n,curiyr)
  bf=FRbf(nr,n,curiyr)
  if(Done.eq.0) then

      IF (FRwc(nr,n,curiyr) .eq. 0 .OR. FRbf(nr,n,curiyr) .eq. 0) THEN
         WRITE(6,3237) CURIYR+1989,CURITR,NR,N,FRwc(nr,n,curiyr),FRbf(nr,n,curiyr)
 3237    FORMAT(1X,"FWCapAvl",6(":",I4))
      END IF

   if(FWCapAvl(nr,curiyr,wc,bf).gt.0.0) then
    FConsNum(nr)=FConsNum(nr)+1
    FConsCap(nr)=FConsCap(nr)+FWCapAvl(nr,curiyr,wc,bf)
    if(FXSwitch.ne.1) FConsLT(nr)=FConsLT(nr)+FWCapAvl(nr,curiyr,wc,bf)*FLTElas(nr)
    if(FXSwitch.eq.1) FConsLT(nr)=FConsLT(nr)+FWCapAvl(nr,curiyr,wc,bf)*FXLTElas(nr,wc)
    FConsCC(nr)=FConsCC(nr)+FWCapAvl(nr,curiyr,wc,bf)*FICCMultR(nr,wc,bf,curiyr)
!    if (nr.eq.4) then
!      write(*,'(a,5i6,F10.3)')'wdbg3-inMisc3,y,i,r,wc,bf,FICCMultR',curcalyr,curitr,nr,wc,bf,  &
!          FICCMultR(nr,wc,bf,curiyr)
!    endif
    ! write(*,'(a,5i6,6f10.2)')'wdbg3FConsCF1,y,i,r,wc,bf,conscf,wcapavl,CF,newConsCF ',  &
    !     curcalyr,curitr,nr,wc,bf, &
    !     FConsCF(nr),FWCapAvl(nr,curiyr,wc,bf),FCF(curiyr,wc),  &
    !    FConsCF(nr)+FWCapAvl(nr,curiyr,wc,bf)*FCF(curiyr,wc)
    FConsCF(nr)=FConsCF(nr)+FWCapAvl(nr,curiyr,wc,bf)*FCF(curiyr,wc)
    FConsTD(nr)=FConsTD(nr)+FWCapAvl(nr,curiyr,wc,bf)*FWNTDBFCS(nr,bf)
   end if
   if(FConsCap(nr).gt.FConsTol(nr).or.n.eq.FRNum) then
    FWCurCl(nr,curiyr)=wc
    FWCurBf(nr,curiyr)=bf
    Done=1
   end if
  end if
 end do
 if(FConsCap(nr).gt.0.0) then
  FConsLT(nr)=FConsLT(nr)/FConsCap(nr)
  FConsCC(nr)=FConsCC(nr)/FConsCap(nr)
  !write(*,'(a,3i6,3f10.2)')'wdbg3FConsCF2,y,i,r,ConsCap,ConsCF,newConsCF',  &
  ! curcalyr,curitr,nr,FConsCap(nr),FConsCF(nr),FConsCF(nr)/FConsCap(nr)
  FConsCF(nr)=FConsCF(nr)/FConsCap(nr)
  FConsTD(nr)=FConsTD(nr)/FConsCap(nr)
 else
  if(FXSwitch.ne.1) FConsLT(nr)=FLTElas(nr)
  if(FXSwitch.eq.1) FConsLT(nr)=FXLTElas(nr,3)
  FConsCC(nr)=FICCMultR(nr,3,3,curiyr)
  FConsCF(nr)=FCF(curiyr,3)
  FConsTD(nr)=FWNTDBFCS(nr,3)
 end if
end do

!Fill in the total maximum capacity over all categories and the existing (chosen) capacity in each region.
do nr=1,unrgns
 !For some reason the previous model filled in UTRSMX only until year 8.
 if(curiyr.le.8) UTRSMX(nr,WTech)=FCapOrig(nr,curiyr)
 UTRSCU(nr,WTech)=FCapInstall(nr,curiyr)
end do

!Determine the long-term elasticities for the supply curve.
!Note, this is only used if we are doing the origninal long-term elasticities over all wind classes and zones.
do nr=1,unrgns
 !Calculate the ratio of resource used to resource available - i.e., point on long term supply curve.
 FRatio=0.0
 if(UTRSMX(nr,WTech).ge.Fepsi) FRatio=UTRSCU(nr,WTech)/UTRSMX(nr,WTech)
 !Look up the elasticity using a table of 5 levels, based upon the level of the ratio.
 FLTElas(nr)=1.0
 do lev=1,5
  if(UTRSFC(nr,WTech,lev).lt.FRatio) then
   FLTElas(nr)=UTCSFC(nr,WTech,lev)
  end if
 end do
end do

!Combine as necessary and put the elasticities into the array used by the Utility Model
do nr=1,unrgns
 FZLTElas=FConsLT(nr)
 do stp=1,msptmx
!  if(UTCSSW(WTech).eq.1) then   !Short-term only.
!   UTCSFN(nr,WTech,stp)=FSTElas(stp)
!  elseif(UTCSSW(WTech).eq.2) then   !Long-term only.
!   UTCSFN(nr,WTech,stp)=FZLTElas
!  elseif(UTCSSW(WTech).eq.3) then   !Both short-term and long-term combined.
!   UTCSFN(nr,WTech,stp)=FSTElas(stp)+(FZLTElas-1.0)
!  end if
!
!for aeo04, STELas is not being used
!
 !write(*,'(a,6i6,5f10.2)')'wdbg3F1,y,i,r,tech,stp,utcssw,utcsfn,fzltelas',curcalyr,curitr,nr,wtech,stp,utcssw(Wtech),  &
 !    utcsfn(nr,wtech,stp),FZLTElas
  if(UTCSSW(WTech).eq.2  .or. UTCSSW(WTech).eq.3) then
     UTCSFN(nr,WTech,stp)=FZLTElas*FConsCC(nr)-1.0
  else
     UTCSFN(nr,WTech,stp)=FConsCC(nr)-1.0
  endif
 !write(*,'(a,6i6,5f10.2)')'wdbg3F2,y,i,r,tech,stp,utcssw,utcsfn,fzltelas,fconscc',curcalyr,curitr,nr,wtech,stp,utcssw(Wtech),  &
 !    utcsfn(nr,wtech,stp),FZLTElas,FConsCC(nr)

 !Add in the input incremental capital cost multiplier by wind class, for the best wind class.
!  UTCSFN(nr,WTech,stp)=UTCSFN(nr,WTech,stp)*FConsCC(nr)
 !write(*,'(a,5i6,5f10.2)')'wdbg3F,y,i,r,tech,stp,utcsfn,fconscc',curcalyr,curitr,nr,wtech,stp,  &
 !    utcsfn(nr,wtech,stp),FConsCC(nr)
 end do
end do

!Fill in some variables for the utility model (?)
!WCAWFEL is the amount of available capacity in the "best" wind class and "best" buffer zone.
do nr=1,unrgns
 !The method for determing the best class/zone was changed and the capacity constraint was calculated there.
 WCAWFEL(nr,curiyr)=FConsCap(nr)
 WOLDCN(nr,WTech)=WCAWFEL(nr,curiyr)
 !In the previous model it had been filled in for all years, maybe this is not necessary...
 do yr=curiyr+1,MNUMYR
  WCAWFEL(nr,yr)=WCAWFEL(nr,curiyr)
 end do
end do

!WSFWFEL has the capacity factors for each time slice for the "best" wind class category.

!  calculate wind capacity factors for each of 864 hrs
   do nr=1,unrgns
     do m=1,12
       do d=1,3
         do h=1,24
            IF (FWindInputCF(nr,curiyr) .NE. 0.0) &     ! if this is 0, WSFWFEL_CF(nr,curiyr,d,m,h) was 0 from above
            WSFWFEL_CF(nr,curiyr,d,m,h) =WSFWFEL_CF(nr,curiyr,d,m,h) * FConsCF(nr) / FWindInputCF(nr,curiyr)
! start the wind curtailment algorithm
!do nr=1,unrgns
! do s=1,mnumwi
s=hrtoecpgrp(m,d,h) !this maps current slice to time period under consideration
  wc=FWCurCl(nr,curiyr)
  !WSFWFEL(nr,curiyr,1,s)=FSubPer(nr,s)/FSlice(nr,s)*FConsCF(nr)
!  write(*,'(a,4i6,4f12.4)')'WSFWFEL,y,i,r,s,fsubper,fslice,fconscf,wsfwfel:',  &
!    curiyr,curitr,nr,s,fsubper(nr,s),fslice(nr,s),fconscf(nr),WSFWFEL(nr,curiyr,1,s)
  !For debugging purposes, JDoCFB=0 don't do this, JDoCFB=1 do this.
  JDoCFB=0
  if(JDoCFB.eq.1) then
  !New section by CRN (2/03) that backs off the capacity factor for overproduction.
  !Note that capacity factors are transferred to ECP via the first wind class.
  !Many of the variables used in this routine include:
  !BaseLdCap - Capacity of thermal plants likely to be used as baseloaders.
  !TurnDown - Minimum percent of nameplate at which plant can be run (an input).
  !IntStddv(nerc,IntTech) - Standard deviation of a single wind site (an input).
  !WnRegStd - Standard deviation of all wind sites in the region.
  !IntRegCrl(nerc,IntTech) - Correlation coefficient for all wind sites in the region (an input).
  !WindProb - Probability of excess wind production.
  !AllowWindCap - Wind capacity that can operate before curtailment.
  !ExcessWn - total kWh of excess (curtailed) wind.
  !FullWn - Adjusted average wind available in the load slice (energy).
  !AveWnCap - Average wind capacity available in the load slice.
  !WnPlant - Size of the wind plant (use UPMSSIZ from ENTCNTL).
  !NWn - Number of wind plants in a region.
  !BaseCF - Fundamental wind capacity factor for region/slice, without curtailment.
  !InstWind - Installed wind capacity (GW).
  !CoalAvail - Average coal plant total availability.
  !NucAvail - Average nuclear plant total availability.
  !NumC - Number of coal plant types.
  !First, determine the "baseload" installed capacity.
  !(Should de-rate by maximum CF to get planned outages, probably in ECPDAT.)
  FBaseLdCap=UCAPCSN(nr,curiyr)+UCAPCSU(nr,curiyr)+UCAPIGN(nr,curiyr)+UCAPIGU(nr,curiyr)+UCAPISN(nr,curiyr)+UCAPISU(nr,curiyr)
  !Calculate the standard deviation for all the wind sites in the region.
  FInstWind=UCAPWFR(nr,curiyr)*0.001
  FNWn=FInstWind/(UPMSSIZ(WIWF)/1000.0)   !Need to find a parameter for ECP wind index.
  if(FNWn.lt.1) FNWn=1
  if(FInstWind.gt.0.0) then
   FWnRegStd=Sqrt((FNWn+2.0*FIntRegCrl(nr,UCPINTIS(WIWF))*((FNWn**2.0-FNWn)/2.0)) &
    *(FIntStddv(nr,UCPINTIS(WIWF))*UPMSSIZ(WIWF)/1000.0)**2.0)
  else
   FWnRegStd=FIntStddv(nr,UCPINTIS(WIWF))
  endif
  !Determine the amount of allowable wind in the current load slice.
  !Use UPTTYP(ECP_D_CAP)=NW_Coal or EX_Coal to ID coal plants.
  FCoalAvail=0.0
  !XCoalAvail=0.0  !This was not in the original code - should it be here?
  !NCoalAvail=0.0  !This was not in the original code - should it be here?
  FNumxc=0
  FNumnc=0
  do t=1,ECP_D_CAP
   if(UPTTYP(t).le.EX_Coal) then
    FXCoalAvail=FXCoalAvail+(UPPMRT(t)+UPFORT(t))
    FNumxc=FNumxc+1
   elseif (UPTTYP(t).le.NW_Coal) then
    FNCoalAvail=FNCoalAvail+(UPPMRT(t)+UPFORT(t))
    FNumnc=FNumnc+1
   endif
  end do
  FXCoalAvail=FXCoalAvail/FNumxc
  FNCoalAvail=FNCoalAvail/FNumnc
  if(FBaseLdCap.gt.0.0) then
   FCoalAvail=(FXCoalAvail*(UCAPCSN(nr,curiyr)+UCAPCSU(nr,curiyr))+ &
    FNCoalAvail*(UCAPIGN(nr,curiyr)+UCAPIGU(nr,curiyr)+UCAPISN(nr,curiyr)+UCAPISU(nr,curiyr)))/FBaseLdCap
  else
   FCoalAvail=0.0
  endif
  FCoalAvail=1.0-FCoalAvail
  FNucAvail=1.0-(((UPPMRT(WICN)+UPPMRT(WIAN)+UPPMRT(WISM))/3.0)+((UPFORT(WICN)+UPFORT(WIAN)+UPFORT(WISM))/3.0))
  FAllowWnCap=ECPLDCBH(curiyr,nr,s)-FNucAvail*NTurnDown(nr)*(UCAPNUN(nr,curiyr)+UCAPNUU(nr,curiyr))- &
   FCoalAvail*FCTurnDown(nr)*FBaseLdCap
 ! FBaseCF=FSUBPER(nr,s)/FSLICE(nr,s)*FCF(curiyr,wc)
  FBaseCF = WSFWFEL_CF(nr,curiyr,d,m,h)
  FAveWnCap=FBaseCF*FInstWind
  if(ECPLDCBH(curiyr,nr,s).le.0) then
   FWnProb=0.0
  else
   FWnProb=(1.0/Sqrt(2.0*3.141593*FWnRegStd))*exp(-((FAllowWnCap-FAveWnCap)**2.0)/(2.0*FWnRegStd**2.0))
  endif
  !Subtract out the excess energy from the time-slice capacity factor.
  !FExcessWn=FWnProb*FInstWind*ECPLDCBW(curiyr,nr,s)*8760.0
  !FFullWn=(FAveWnCap*ECPLDCBW(curiyr,nr,s)*8760.0)-FExcessWn
  FExcessWn=FWnProb*FInstWind
  FFullWn=FAveWnCap - FExcessWn
  !if((FInstWind.le.0).or.(ECPLDCBW(curiyr,nr,s).le.0)) then
  if(FInstWind.le.0) then
   WSFWFEL_CF(nr,curiyr,d,m,h)=FBaseCF
  else
   !WSFWFEL_CF(nr,curiyr,d,m,h)=FFullWn/(FInstWind*ECPLDCBW(curiyr,nr,s)*8760.0)
   WSFWFEL_CF(nr,curiyr,d,m,h)=FFullWn/FInstWind
  endif
  endif


! end the wind curtailment algorithm

         enddo
       enddo
     enddo
   enddo

!WWFTD is the level of T&D costs for the "best" buffer zone.
do nr=1,unrgns
 !bf=WCurBf(nr,curiyr)
 WWFTD(nr,curiyr)=FConsTD(nr)
 !In the previous model it had been filled in for all years, maybe this is not necessary...
 do yr=curiyr+1,MNUMYR
  WWFTD(nr,yr)=WWFTD(nr,curiyr)
 end do
end do

return
end
!******************************************************************
! Subroutine WindRank3_OFS determines the costs for each offshore wind category and then
! ranks the categories according to some criteria - typically lowest to highest cost.

subroutine WindRank3_OFS
implicit none
include 'parametr'
include 'ncntrl'
include 'emmparm'
include 'ecpcntl'
include 'control'
include 'wrenew'
include 'wwind'
include 'wrenio'
include 'bildout'
include 'entcntl'
include 'enewtech'
include 'bildin'
include 'uefdout'
!
      INTEGER*4 RCAP
      INTEGER*4 GSYR1
      INTEGER*4 GSYRL
      INTEGER*4 ICAP
      INTEGER*4 IFPH2
      INTEGER*4 IP
      INTEGER*4 IS
      INTEGER*4 JYR
      INTEGER*4 OLYR
      INTEGER*4 YEAR
!
      REAL*4 CPR(ECP_D_LCP)
      REAL*4 EWGINT
      REAL*4 EWGROE
      REAL*4 EWGROR
!
      REAL*8 CAPLEV
      REAL*8 CAPNNSTL
      REAL*8 CAPNUG
      REAL*8 CRF
      REAL*8 FNBOOK
      REAL*8 ITCADJ
      REAL*8 OVRCST
      REAL*8 PRATIO
      REAL*8 PVGNP
      REAL*8 PWF
      REAL*8 TXBOOK
!
integer nr,wc,bf,t,ECPWind,FRankVer,FUsed(mnumcl,mnumbf),w,b,n
integer WTech
real FXCost
data ordinal/'st','nd','rd'/
character*2 ordinal(3)
WTech = 12

write(*,'(a,a,a,i4)')'WINDDBG - starting WindRank3_OFS ',trim(scen_date),' ',curiyr
!Get costs for wind from the utility model.
!Get the index for wind in ECP.
do t=1,ECP_D_CAP
 if(UPLNTCD(t).eq.'WF') ECPWind=t
end do
if(ECP_D_OVFX(ECPWind).eq.0) then
 FOMFCost=UPFOM(ECPWind)
else
 FOMFCost=UPOVFX(ECPWind,curiyr)
end if
if(ECP_D_OVVR(ECPWind).eq.0) then
 FOMVCost=UPVOM(ECPWind)
else
 FOMVCost=UPOVVR(ECPWind,curiyr)
end if
!if(curcalyr.ge.UPSTYR) then
! FFixChg=EPLVFCF(ECPWind,2)
!else
! FFixChg=0.13
!end if

do nr=1,unrgns
   call GETBLD(1,nr)
      YEAR = 1
      IS = 1
      ICAP = ECPWind
      IP = UCPINTIS(ICAP)
      RCAP = UIRINTI(IP)
      OLYR = YEAR + UPPLYR(ICAP)
      GSYR1 = UPGSY1(ICAP) - UHBSYR
      GSYRL = UPGSYL(ICAP) - UHBSYR
      IFPH2 = UNFPH - OLYR + 1
      IF (EPDSCRT .LT. 0.09) EPDSCRT = 0.09
      IF (EPCCSUP(RCAP,IS) .LT. 0.09) EPCCSUP(RCAP,IS) = 0.09
      DO JYR = 1, ECP_D_LCP
         CPR(JYR) = UPCPRO(ICAP,JYR)
      END DO
      EWGROE = EPUCRE + UPNRPRM
      EWGINT = EPUIRT + UPNIPRM
      EWGROR = EWGROE * (1.0 - UPNFDT) + EWGINT * UPNFDT
      IF (UPGSUB(ICAP) .GT. 0.0 .AND. (CURIYR + OLYR - 1) .GE. GSYR1 .AND. (CURIYR + OLYR - 1) .LE. GSYRL) THEN
         ITCADJ = 1.0 - UPCSB(ICAP)
      ELSE
         ITCADJ = 1.0
      ENDIF
      OVRCST = (EPIROVR(RCAP)/ITCADJ) * UPLRPC(ICAP) * UPLROPT(ICAP) * UPLRLC(ICAP) * EPRGM(ICAP) * EPACM(ICAP) * EPCCSUP(RCAP,IS) * UPANNADJ(ICAP,CURIYR)
      CALL EPINCST(MNUMYR,ECP_D_XPH,ECP_D_FPH,ECP_D_LCP,UPCLYR(ICAP),UPPLYR(ICAP),CURIYR,YEAR,OVRCST,CPR,UPCAPD(1,ICAP),UPGNPD,EWGINT,UPNFDT,EWGROR,TXBOOK,FNBOOK)
      PRATIO = TXBOOK / FNBOOK
      CAPNNSTL = FNBOOK
      CALL EPCNBLD(DBLE(UPNFDT),PRATIO,DBLE(UPNRPRM),DBLE(UPNIPRM),DBLE(EPUCRE),DBLE(EPUIRT),DBLE(UPTXRT),UPTXLF(ICAP),UPNCLF(ICAP),UPNLLF(ICAP),CAPNUG)
      CALL EP$LGNP(OLYR,IFPH2,EPDSCRT,PVGNP)
      CAPLEV = (( CAPNNSTL * CAPNUG ) / CRF(DBLE(EPDSCRT - UPRSK(ICAP)),IFPH2) ) * PWF(DBLE(EPDSCRT - UPRSK(ICAP)),OLYR)
      CAPLEV = CAPLEV / PVGNP
      FFixChg = CAPLEV / OVRCST
      if ( isnan(FFixChg) ) then
         FFixChg = 0.13
         WRITE(18,3333) CURIYR, CURITR, nr, &
            ECP_D_FPH, ECP_D_LCP, ECP_D_XPH, ECPWind, GSYR1, GSYRL, ICAP, IFPH2, IP, IS, MNUMYR, OLYR, RCAP, UCPINTIS(ICAP), &
            UIRINTI(IP), UHBSYR, UNFPH, UPCLYR(ICAP), UPGSY1(ICAP), UPGSYL(ICAP), UPNCLF(ICAP), UPNLLF(ICAP), UPPLYR(ICAP), UPTXLF(ICAP), YEAR
         WRITE(18,3334) CURIYR, CURITR, nr, &
            CAPLEV, CAPNNSTL, CAPNUG, EPACM(ICAP), EPCCSUP(RCAP,IS), EPDSCRT, EPIROVR(RCAP), &
            EPLVFCF(ICAP,2), EPRGM(ICAP), EPUCRE, EPUIRT, EWGINT, EWGROE, EWGROR, FNBOOK, ITCADJ, OVRCST, PRATIO, PVGNP, TXBOOK, UPCAPD(1,ICAP), &
            UPCSB(ICAP), UPGSUB(ICAP), UPLRLC(ICAP), UPLROPT(ICAP), UPLRPC(ICAP), UPNFDT, UPNIPRM, UPNRPRM, UPRSK(ICAP), UPTXRT, UPANNADJ(ICAP,CURIYR)
         WRITE(18,3335) CURIYR, CURITR, nr, (UPCPRO(ICAP,JYR),JYR= 1, ECP_D_LCP)
         WRITE(18,3336) CURIYR, CURITR, nr, (UPGNPD(JYR),JYR=1,MNUMYR)
 3333    FORMAT(1X,"EPLVFCF0:WF",28(":",I4))
 3334    FORMAT(1X,"EPLVFCF1:WF",3(":",I4),36(":",E10.3))
 3335    FORMAT(1X,"EPLVFCF2:WF",3(":",I4),35(":",E10.3))
 3336    FORMAT(1X,"EPLVFCF3:WF",3(":",I4),35(":",E10.3))
      else
         WRITE(18,4334) CURIYR,CURITR,NR,FFixChg,EPLVFCF(ICAP,2)
 4334    FORMAT(1X,"EPLVFCF4:WF",3(":",I4),2(":",E10.3))
      endif

   if(ECP_D_OVCC(ECPWind).eq.0) then
      FCapCostR(nr) = UPOVR(ECPWind) * UPLRPC(ECPWind) * UPLROPT(ECPWind) *  &
                     UPLRLC(ECPWind) * EPRGM(ECPWind) * EPACM(ECPWind) * UPANNADJ(ECPWind,CURIYR)
   else
      FCapCostR(nr) = UPOVCC(ECPWind,curiyr) * UPLRPC(ECPWind) * UPLROPT(ECPWind) *  &
                     UPLRLC(ECPWind) * EPRGM(ECPWind) * EPACM(ECPWind) * UPANNADJ(ECPWind,CURIYR)
   endif

!  Use the input incremental capital cost multiplier to get capital costs by wind class.
   if(FICCMeth(curiyr).eq.1) then
     do wc=1,mnumcl
      do bf=1,mnumbf
       FICCCostR(nr,wc,bf,curiyr)=FCapCostR(nr)*FICCMultR(nr,wc,bf,curiyr)
!      write(*,'(a,6i6,5f10.2)')'wdbg3CCF,y,i,r,tech,wc-Meth1',  &
!        curcalyr,curitr,nr,wtech,wc,  &
!        FICCMeth(curiyr),FCapCostR(nr),FICCMultR(nr,wc,bf,curiyr),FICCCostR(nr,wc,bf,curiyr)
      end do
     end do
   else
     do wc=1,mnumcl
      do bf=1,mnumbf
       FICCMultR(nr,wc,bf,curiyr)=FICCCostR(nr,wc,bf,curiyr)/FCapCostR(nr)
      end do
     end do
   end if

!Determine the annualized cost per kwh by region, year, wind class, and buffer zone.
!!!do nr=1,unrgns
 do wc=1,mnumcl
  do bf=1,mnumbf
!   AnnCost(nr,curiyr,wc,bf)=(CapCost*FixChg+OMFCost+WNTDBFCS(nr,bf)*FixChg)/(CF(curiyr,wc)*8760.0)+FOMVCost/1000
   !If XSwitch is not 0 then use the long-term multiplier by wind class in the capital cost.
   if(FXSwitch.eq.0) then
      FAnnCost(nr,curiyr,wc,bf) = (FICCCostR(nr,wc,bf,curiyr) * FFixChg + FOMFCost +  FWNTDBFCS(nr,bf) * FFixChg) / (FCF(curiyr,wc) * 8760.0) + FOMVCost / 1000.0

      IF (ISNAN(FAnnCost(nr,curiyr,wc,bf)) .OR. ABS(FAnnCost(nr,curiyr,wc,bf)) .GT. HUGE(FAnnCost(nr,curiyr,wc,bf))) THEN   ! check for NaNQ this way
         WRITE(6,3337) CURIYR+1989, CURITR, NR, WC, BF, FAnnCost(nr,curiyr,wc,bf), FICCCostR(nr,wc,bf,curiyr), FFixChg, FOMFCost, FWNTDBFCS(nr,bf), FCF(curiyr,wc), FOMVCost
 3337    FORMAT(1X,"FAnnCost0",5(":",I4),7(":",F15.4))
         FAnnCost(nr,curiyr,wc,bf) = 9999.9
      END IF

   else
      FAnnCost(nr,curiyr,wc,bf) = (FICCCostR(nr,wc,bf,curiyr) * FXLTElas(nr,wc) * FFixChg + FOMFCost + FWNTDBFCS(nr,bf) * FFixChg) / (FCF(curiyr,wc) * 8760.0) + FOMVCost / 1000.0

      IF (ISNAN(FAnnCost(nr,curiyr,wc,bf)) .OR. ABS(FAnnCost(nr,curiyr,wc,bf)) .GT. HUGE(FAnnCost(nr,curiyr,wc,bf))) THEN   ! check for NaNQ this way
         WRITE(6,3339) CURIYR+1989, CURITR, NR, WC, BF, FAnnCost(nr,curiyr,wc,bf), FXLTElas(nr,wc), FFixChg, FOMFCost, FWNTDBFCS(nr,bf), FCF(curiyr,wc), FOMVCost
 3339    FORMAT(1X,"FAnnCost1",5(":",I4),7(":",F12.4))
         FAnnCost(nr,curiyr,wc,bf) = 9999.9
      END IF

    end if
   end do
  end do
end do      !region loop

!Choose the manner of ranking: 1=original, 2=by cost (note, that in the base they are the same)
FRankVer=2
if(FRankVer.eq.1) then
 !Rank the categories according to some criteria - probably lowest to highest cost.
 !For now, they are simply ranked in wind class, buffer zone order, as in the original model.
 do nr=1,mnumnr
  FRNum=0
  do wc=1,mnumcl
   do bf=1,mnumbf
    FRNum=FRNum+1
    FRwc(nr,FRNum,curiyr)=wc
    FRbf(nr,FRNum,curiyr)=bf
   end do
  end do
 end do
elseif(FRankVer.eq.2) then
 FRNum=mnumcl*mnumbf
 do nr=1,mnumnr
  n=0
  do wc=1,mnumcl
   do bf=1,mnumbf
    n=n+1
    FUsed(wc,bf)=0
    FRwc(nr,n,curiyr)=0
    FRbf(nr,n,curiyr)=0
   end do
  end do
  n=0
  do wc=1,mnumcl
   do bf=1,mnumbf
    n=n+1
    FXCost=999999.9
    do w=1,mnumcl
     do b=1,mnumbf
      if(FUsed(w,b).eq.0.and.FAnnCost(nr,curiyr,w,b).lt.FXCost) then
       FXCost=FAnnCost(nr,curiyr,w,b)
       FRwc(nr,n,curiyr)=w
       FRbf(nr,n,curiyr)=b

!      WRITE(6,3437) CURIYR+1989,CURITR,NR,WC,BF,N,W,B,FRwc(NR,N,CURIYR),FRbf(NR,N,CURIYR),FRank(NR,W,B),FUsed(w,b),FAnnCost(NR,CURIYR,W,B),FXCost
 3437  FORMAT(1X,"Rank_Ranking",12(":",I4),2(":",F15.6))

       FRank(nr,w,b)=n
      end if
     end do
    end do
    IF (FRwc(nr,n,curiyr) .GT. 0 .AND. FRbf(nr,n,curiyr) .GT. 0) FUsed(FRwc(nr,n,curiyr),FRbf(nr,n,curiyr))=1
   end do
  end do
 end do
end if

return
end

!******************************************************************
!Subroutine WindRept3_OFS writes out a number of offshore wind things to a debug report.

subroutine WindRept3_OFS
implicit none
include 'parametr'
include 'ncntrl'
include 'emmparm'
include 'ecpcntl'
include 'control'
include 'wrenew'
include 'wwind'
include 'wrenio'
include 'rencntl'
include 'udatout'
include 'uefdout'

integer wc,bf,nr,yr,n,s,stp,WTech,FIDisp(mnumnr),i,FYR,ALASKA,HAWAII
real FXTot,FYTot,FRDisp(mnumnr)
      character*260 rept_head

      rept_head =  '     Regn1     Regn2     Regn3     Regn4     Regn5     Regn6     Regn7     Regn8     Regn9    Regn10    Regn11    Regn12    Regn13    Regn14    Regn15    Regn16    Regn17    Regn18    Regn19    Regn20    Regn21    Regn22    Regn23    Regn24    Regn25     Total'


        ALASKA = MNUMNR - 2
        HAWAII = MNUMNR - 1

write(*,*)'WINDDBG - starting WindRept3_OFS ',trim(scen_date),' ',curiyr
WTech=12  !Technology number for off shore wind.

write(IORNREPT,'(/,a,a,a,i4,a)') 'OffShore Wind Report for Scenario: ',trim(scen_date),', in Year ',curcalyr,'   Note: 1 year lag in costs'
!Write out the costs to the debug file.
write(IORNREPT,'(/,a,i4)') 'Offshore Wind Cost Variables for Year ',curcalyr
write(IORNREPT,'(a,f10.2)') 'Fixed O&M Cost:             ',FOMFCost,'Var O&M      ',FOMVCost
write(IORNREPT,'(a,f10.3)') 'Fixed Charge Factor:             ',FFixChg
!do wc=1,mnumcl
! do bf=1,mnumbf
!  write(IORNREPT,'(a,4i6,f10.3)')'FICCMULTR for rgn 4 ,y,r,c,b ',curcalyr,4,wc,bf,FICCMultR(4,wc,bf,curiyr)
! enddo
!enddo
do bf=1,mnumbf
 write(IORNREPT,'(a,i1,a)') "Orig EMM Cap Cost, Cost Mult by offshore wind class, New Cap Cost by wind class (Buffer Zone ",bf,")"
write(IORNREPT,'(a4,a12,<mnumcl>(a5,i1),<mnumcl>(a9,i1))')"Rgn","OCC",('M',7-wc,wc=1,mnumcl),('NCC',7-wc,wc=1,mnumcl)
 do nr=1,unrgns
   write(IORNREPT,'(1x,i3,2x,F10.2,<mnumcl>F6.2,<mnumcl>F10.2)')nr,FCapCostR(nr),(FICCMultR(nr,wc,bf,curiyr),wc=1,mnumcl),  &
                     (FICCCostR(nr,wc,bf,curiyr),wc=1,mnumcl)
 enddo
enddo
write(IORNREPT,'(/,a)') 'Cost of Electricity from Offshore Wind (with Cost FRank) (Annualized Cost per Kwh in $87)'
write(IORNREPT,'(5x,a)') rept_head
do wc=1,mnumcl
 do bf=1,mnumbf
  write(IORNREPT,'(a1,i1,a1,i1,1x,<unrgns>(f10.4,i3))') 'C',7-wc,'Z',bf,(FAnnCost(nr,curiyr,wc,bf),FRank(nr,wc,bf),nr=1,unrgns)
 end do
end do

write(IORNREPT,'(/,a)') 'Current "Best" Offshore Wind Class and "Best" Buffer Zone'
write(IORNREPT,'(20x,a)') rept_head
write(IORNREPT,'(a,<unrgns>i8)') 'Best Wind Class       ',(7-FWCurCl(nr,curiyr),nr=1,unrgns)
write(IORNREPT,'(a,<unrgns>i8)') 'Best Buffer Zone      ',(FWCurBf(nr,curiyr),nr=1,unrgns)

if(curiyr.eq.6) then

 !Write out the first year of land area to the debug file.
 write(IORNREPT,'(/,a,i2)') 'Offshore Land Area Available by Region, Class, and Zone'
 write(IORNREPT,'(a4,1x,<mnumcl*mnumbf>(a5,i1,a1,i1),a10)') 'NERC', ((('C',7-wc,'Z',bf),wc=1,mnumcl),bf=1,mnumbf),'Total'
 do nr=1,unrgns
 FXTot=0.0
  do wc=1,mnumcl
   do bf=1,mnumbf
    FXTot=FXTot+FLdArea(nr,6,wc,bf)
   end do
  end do
  write(IORNREPT,'(i4,2x,<mnumcl*mnumbf>f8.0,f10.0)') nr,((FLdArea(nr,6,wc,bf),bf=1,mnumbf),wc=1,mnumcl),FXTot
 end do

 !Write out the maximum potential capacity for all years and one sample region to the debug file.
 nr=11
 write(IORNREPT,'(/,a,i2)') 'Maximum Offshore Wind Capacity Available by Year, Class, and Zone, Region ',nr
 write(IORNREPT,'(a4,1x,<mnumcl*mnumbf>(a7,i1,a1,i1),a10)') 'Year', ((('C',7-wc,'Z',bf),wc=1,mnumcl),bf=1,mnumbf),'Total'
 do yr=1,MNUMYR
  FXTot=0.0
  do wc=1,mnumcl
   do bf=1,mnumbf
    FXTot=FXTot+FWCapMax(nr,yr,wc,bf)
   end do
  end do
  write(IORNREPT,'(i4,2x,<mnumcl*mnumbf>f10.0,f11.0)') yr+1989,((FWCapMax(nr,yr,wc,bf),bf=1,mnumbf),wc=1,mnumcl),FXTot
 end do

else

 write(IORNREPT,'(a,a)') 'Fa>'
 write(IORNREPT,'(a,a,i4)') 'Fa>','Installed, Added, and Committed Capacity (MW) in the Current Year ',curcalyr
 write(IORNREPT,'(a,20x,a)') 'Fa>',rept_head
 write(IORNREPT,'(a,a)') 'Fa>','New Installed Capacity'
 write(IORNREPT,'(a,a,<unrgns>f10.1,f11.1)') 'Fa>','  Planned Builds      ',(FCapPlnBld(nr,curiyr),nr=1,unrgns),FCapPlnBld(mnumnr,curiyr)
 write(IORNREPT,'(a,a,<unrgns>f10.1,f11.1)') 'Fa>','  Committed-Now Built ',(FCapNewBld(nr,curiyr),nr=1,unrgns),FCapNewBld(mnumnr,curiyr)
 write(IORNREPT,'(a,a,<unrgns>f10.1,f11.1)') 'Fa>','  Total New           ',(FCapAdded(nr,curiyr),nr=1,unrgns),FCapAdded(mnumnr,curiyr)
 write(IORNREPT,'(a,a)') 'Fa>','Cumulative Installed Capacity'
 write(IORNREPT,'(a,a,<unrgns>f10.1,f11.1)') 'Fa>','  Total Cumulative    ',(FCapInstall(nr,curiyr),nr=1,unrgns),FCapInstall(mnumnr,curiyr)
 write(IORNREPT,'(a,a)') 'Fa>','Committed Capacity'
 write(IORNREPT,'(a,a,<unrgns>f10.1,f11.1)') 'Fa>','  Committed This Year ',(FCapCommit(nr,curiyr),nr=1,unrgns),FCapCommit(mnumnr,curiyr)
 do i=1,FNLead-1
  write(IORNREPT,'(a,a,i1,a,<unrgns>f10.1,f11.1)') 'Fa>','  Committed Year-',i,'    ',(FCapCommit(nr,curiyr-i),nr=1,unrgns),FCapCommit(mnumnr,curiyr-i)
 end do
 write(IORNREPT,'(a,a,<unrgns>f10.1,f11.1)') 'Fa>','  Total Committed     ',(FCapCmtTot(nr,curiyr),nr=1,unrgns),FCapCmtTot(mnumnr,curiyr)
 write(IORNREPT,'(a,a)') 'Fa>','Cumulative Installed Plus Committed Capacity'
 write(IORNREPT,'(a,a,<unrgns>f10.1,f11.1)') 'Fa>','  Total               ',(FCapIandC(nr,curiyr),nr=1,unrgns),FCapIandC(mnumnr,curiyr)

 write(IORNREPT,'(a,a)') 'Fc>'
 write(IORNREPT,'(a,a,i4)') 'Fc>','Current Year Ranking by Cost (Rank) - Year ',curcalyr
 write(IORNREPT,'(a,20x,a)') 'Fc>',rept_head
 do wc=1,mnumcl
  do bf=1,mnumbf
   write(IORNREPT,'(a,2x,a,i1,a,i1,16x,<unrgns>i10)') 'Fc>','C',7-wc,'Z',bf,(FRank(nr,wc,bf),nr=1,unrgns)
  end do
 end do

 write(IORNREPT,'(a,a)') 'Fb>'
 write(IORNREPT,'(a,a,i4)') 'Fb>','Increment in Installed Capacity (FICapInc) - Year ',curcalyr
 write(IORNREPT,'(a,20x,a)') 'Fb>',rept_head
 do nr=1,mnumnr
  FRDisp(nr)=0.0
 end do
 do wc=1,mnumcl
  do bf=1,mnumbf
   write(IORNREPT,'(a,2x,a,i1,a,i1,16x,<unrgns>f10.1,f11.1)') 'Fb>','C',7-wc,'Z',bf,(FICapInc(nr,curiyr,wc,bf),nr=1,unrgns),FICapInc(mnumnr,curiyr,wc,bf)
   do nr=1,mnumnr
    FRDisp(nr)=FRDisp(nr)+FICapInc(nr,curiyr,wc,bf)
   end do
  end do
 end do
 write(IORNREPT,'(a,2x,a,15x,<unrgns>f10.1,f11.1)') 'Fb>','Total',(FRDisp(nr),nr=1,unrgns),FRDisp(mnumnr)

 write(IORNREPT,'(a,a)') 'Fb>'
 write(IORNREPT,'(a,a,i4)') 'Fb>','Cumulative Installed Capacity (ICapCum)  Year ',curcalyr
 write(IORNREPT,'(a,20x,a)') 'Fb>',rept_head
 do nr=1,mnumnr
  FRDisp(nr)=0.0
 end do
 do wc=1,mnumcl
  do bf=1,mnumbf
   write(IORNREPT,'(a,2x,a,i1,a,i1,16x,<unrgns>f10.1,f11.1)') 'Fb>','C',7-wc,'Z',bf,(FICapCum(nr,curiyr,wc,bf),nr=1,unrgns),FICapCum(mnumnr,curiyr,wc,bf)
   do nr=1,mnumnr
    FRDisp(nr)=FRDisp(nr)+FICapCum(nr,curiyr,wc,bf)
   end do
  end do
 end do
 write(IORNREPT,'(a,2x,a,15x,<unrgns>f10.1,f11.1)') 'Fb>','Total',(FRDisp(nr),nr=1,unrgns),FRDisp(mnumnr)

 write(IORNREPT,'(a,a)') 'Fb>'
 write(IORNREPT,'(a,a,i4)') 'Fb>','Capacity Available (Accounting for Installed Only) (ICapAvl) - Year ',curcalyr
 write(IORNREPT,'(a,20x,a)') 'Fb>',rept_head
 do nr=1,mnumnr
  FRDisp(nr)=0.0
 end do
 do wc=1,mnumcl
  do bf=1,mnumbf
   write(IORNREPT,'(a,2x,a,i1,a,i1,16x,<unrgns>f10.0,f11.0)') 'Fb>','C',7-wc,'Z',bf,(FICapAvl(nr,curiyr,wc,bf),nr=1,unrgns),FICapAvl(mnumnr,curiyr,wc,bf)
   do nr=1,mnumnr
    FRDisp(nr)=FRDisp(nr)+FICapAvl(nr,curiyr,wc,bf)
   end do
  end do
 end do
 write(IORNREPT,'(a,2x,a,15x,<unrgns>f10.0,f11.0)') 'Fb>','Total',(FRDisp(nr),nr=1,unrgns),FRDisp(mnumnr)

 write(IORNREPT,'(a,a)') 'Fb>'
 write(IORNREPT,'(a,a,i4)') 'Fb>','Committed Capacity not yet Built (WCapInc) - Year ',curcalyr
 write(IORNREPT,'(a,20x,a)') 'Fb>',rept_head
 do nr=1,mnumnr
  FRDisp(nr)=0.0
 end do
 do wc=1,mnumcl
  do bf=1,mnumbf
   write(IORNREPT,'(a,2x,a,i1,a,i1,16x,<unrgns>f10.1,f11.1)') 'Fb>','C',7-wc,'Z',bf,(FWCapInc(nr,curiyr,wc,bf),nr=1,unrgns),FWCapInc(mnumnr,curiyr,wc,bf)
   do nr=1,mnumnr
    FRDisp(nr)=FRDisp(nr)+FWCapInc(nr,curiyr,wc,bf)
   end do
  end do
 end do
 write(IORNREPT,'(a,2x,a,15x,<unrgns>f10.1,f11.1)') 'Fb>','Total',(FRDisp(nr),nr=1,unrgns),FRDisp(mnumnr)

 write(IORNREPT,'(a,a)') 'Fb>'
 write(IORNREPT,'(a,a,i4)') 'Fb>','Cumulative Installed Capacity Plus Committed not yet Built (WCapCum) - Year ',curcalyr
 write(IORNREPT,'(a,20x,a)') 'Fb>',rept_head
 do nr=1,mnumnr
  FRDisp(nr)=0.0
 end do
 do wc=1,mnumcl
  do bf=1,mnumbf
   write(IORNREPT,'(a,2x,a,i1,a,i1,16x,<unrgns>f10.1,f11.1)') 'Fb>','C',7-wc,'Z',bf,(FWCapCum(nr,curiyr,wc,bf),nr=1,unrgns),FWCapCum(mnumnr,curiyr,wc,bf)
   do nr=1,mnumnr
    FRDisp(nr)=FRDisp(nr)+FWCapCum(nr,curiyr,wc,bf)
   end do
  end do
 end do
 write(IORNREPT,'(a,2x,a,15x,<unrgns>f10.1,f11.1)') 'Fb>','Total',(FRDisp(nr),nr=1,unrgns),FRDisp(mnumnr)

 write(IORNREPT,'(a,a)') 'Fb>'
 write(IORNREPT,'(a,a,i4)') 'Fb>','Capacity Available (Accounting for Installed Plus Committed) (WCapAvl) - Year ',curcalyr
 write(IORNREPT,'(a,20x,a)') 'Fb>',rept_head
 do nr=1,mnumnr
  FRDisp(nr)=0.0
 end do
 do wc=1,mnumcl
  do bf=1,mnumbf
   write(IORNREPT,'(a,2x,a,i1,a,i1,16x,<unrgns>f10.0,f11.0)') 'Fb>','C',7-wc,'Z',bf,(FWCapAvl(nr,curiyr,wc,bf),nr=1,unrgns),FWCapAvl(mnumnr,curiyr,wc,bf)
   do nr=1,mnumnr
    FRDisp(nr)=FRDisp(nr)+FWCapAvl(nr,curiyr,wc,bf)
   end do
  end do
 end do
 write(IORNREPT,'(a,2x,a,15x,<unrgns>f10.0,f11.0)') 'Fb>','Total',(FRDisp(nr),nr=1,unrgns),FRDisp(mnumnr)

 write(IORNREPT,'(a,a)') 'Fb>'
 write(IORNREPT,'(a,a,i4)') 'Fb>','Original Maximum Capacity Available (WCapMax) - Year ',curcalyr
 write(IORNREPT,'(a,20x,a)') 'Fb>',rept_head
 do nr=1,mnumnr
  FRDisp(nr)=0.0
 end do
 do wc=1,mnumcl
  do bf=1,mnumbf
   write(IORNREPT,'(a,2x,a,i1,a,i1,16x,<unrgns>f10.0,f11.0)') 'Fb>','C',7-wc,'Z',bf,(FWCapMax(nr,curiyr,wc,bf),nr=1,unrgns),FWCapMax(mnumnr,curiyr,wc,bf)
   do nr=1,mnumnr
    FRDisp(nr)=FRDisp(nr)+FWCapMax(nr,curiyr,wc,bf)
   end do
  end do
 end do
 write(IORNREPT,'(a,2x,a,15x,<unrgns>f10.0,f11.0)') 'Fb>','Total',(FRDisp(nr),nr=1,unrgns),FRDisp(mnumnr)

 write(IORNREPT,'(/,a)') 'Current "Best" Offshore Wind Class & Buffer Zone, Capacity Increment, and Category Tolerance'
 write(IORNREPT,'(20x,a)') rept_head
 write(IORNREPT,'(a,<unrgns>i10)') 'Best Wind Class       ',(7-FWCurCl(nr,curiyr),nr=1,unrgns)
 write(IORNREPT,'(a,<unrgns>i10)') 'Best Buffer Zone      ',(FWCurBf(nr,curiyr),nr=1,unrgns)
 write(IORNREPT,'(a,<unrgns>f10.1)') 'Capacity Increment    ',(FCapIncr(nr,curiyr),nr=1,unrgns)
 write(IORNREPT,'(a,<unrgns>f10.1)') 'Category Tolerance    ',(FConsTol(nr),nr=1,unrgns)
 write(IORNREPT,'(/,a)') 'Potential Offshore Wind Category Weighting - Available Capacity, Weighted Average Costs and CFs'
 write(IORNREPT,'(20x,a)') rept_head
 write(IORNREPT,'(a,<unrgns>i10)') 'Number of Categories  ',(FConsNum(nr),nr=1,unrgns)
 write(IORNREPT,'(a,<unrgns>f10.1)') 'Available Capacity    ',(FConsCap(nr),nr=1,unrgns)
 write(IORNREPT,'(a,<unrgns>f10.3)') 'WgtAvg LT Multiplier  ',(FConsLT(nr),nr=1,unrgns)
 write(IORNREPT,'(a,<unrgns>f10.3)') 'WgtAvg CC Multiplier  ',(FConsCC(nr),nr=1,unrgns)
 write(IORNREPT,'(a,<unrgns>f10.3)') 'WgtAvg Capacity Factor',(FConsCF(nr),nr=1,unrgns)
 write(IORNREPT,'(a,<unrgns>f10.2)') 'WgtAvg T&D Cost       ',(FConsTD(nr),nr=1,unrgns)

 !Write the long term elasticities by wind class.
 if(FXSwitch.ne.0) then
  write(IORNREPT,'(/,a,i4)') 'Long-Term Offshore Wind Elasticities/Multipliers by Wind Class in year ',curcalyr
  write(IORNREPT,'(20x,a)') rept_head
  do wc=1,mnumcl
   write(IORNREPT,'(a,i1)') 'Offshore Wind Class ',7-wc
   write(IORNREPT,'(a,<unrgns>f10.1)') ' Committed Capacity   ',(FXCapCum(nr,wc),nr=1,unrgns)
   write(IORNREPT,'(a,<unrgns>f10.0)') ' Maximum Capacity     ',(FXCapMax(nr,wc),nr=1,unrgns)
   write(IORNREPT,'(a,<unrgns>f10.3)') ' Ratio                ',(FXRatio(nr,wc),nr=1,unrgns)
   write(IORNREPT,'(a,<unrgns>f10.3)') ' LT Elasticity        ',(FXLTElas(nr,wc),nr=1,unrgns)
  end do
 end if

 !Write the supply curve capacities.
 write(IORNREPT,'(/,a,i4,15x,"OFS")') 'Offshore Wind Supply Curve Capacity Steps (MW) for ',curcalyr
 write(IORNREPT,'(20x,a)') rept_head
 write(IORNREPT,'(a,<unrgns>f10.1)') 'Step 1                ',(FUTCACA(1),nr=1,unrgns)
 write(IORNREPT,'(a,<unrgns>f10.1)') 'Step 2                ',(FUTCACA(2),nr=1,unrgns)
 write(IORNREPT,'(a,<unrgns>f10.1)') 'Step 3                ',(FUTCACA(3),nr=1,unrgns)
 write(IORNREPT,'(a,<unrgns>f10.1)') 'Total                 ',(FUTCACA(1)+FUTCACA(2)+FUTCACA(3),nr=1,unrgns)

!Preserve this year's long term multiplier for "SFx" report
  if(FXSwitch.eq.0) then
    do nr=1,unrgns
     FLTMult(nr,curiyr) = FLTElas(nr)
    enddo
  else
    do nr=1,unrgns
     FLTMult(nr,curiyr) = FXLTElas(nr,FWCurCl(nr,curiyr))
    enddo
  endif

 !Combining of all the multipliers.
 write(IORNREPT,'(/,a,i4)') 'Combining of Offshore Wind Long-Term, Capital Cost, and Short-Term Multipliers for ',curcalyr
 write(IORNREPT,'(20x,a)') rept_head
 write(IORNREPT,'(a)') 'Long-Term Multipliers for "Best" Offshore Wind Class'
  if(FXSwitch.eq.0) then
   write(IORNREPT,'(a,<unrgns>f10.3)') 'Long-Term Multiplier  ',(FLTElas(nr),nr=1,unrgns)
  else
   write(IORNREPT,'(a,<unrgns>f10.3)') 'Long-Term Multiplier  ',(FXLTElas(nr,FWCurCl(nr,curiyr)),nr=1,unrgns)
  end if
 write(IORNREPT,'(a)') 'Capital Cost Multipliers for "Best" Offshore Wind Class'
 write(IORNREPT,'(a,<unrgns>f10.3)') 'Capital Cost Mult.    ',(FICCMultR(nr,FWCurCl(nr,curiyr),FWCurBf(nr,curiyr),curiyr),nr=1,unrgns)
 write(IORNREPT,'(a)') 'Short-Term Multipliers by Supply Curve Step'
 write(IORNREPT,'(a,<unrgns>f10.3)') 'Short-Term, Step 1    ',(FSTElas(1),nr=1,unrgns)
 write(IORNREPT,'(a,<unrgns>f10.3)') 'Short-Term, Step 2    ',(FSTElas(2),nr=1,unrgns)
 write(IORNREPT,'(a,<unrgns>f10.3)') 'Short-Term, Step 3    ',(FSTElas(3),nr=1,unrgns)
 write(IORNREPT,'(a)') 'Resulting, Combined Multipliers for "Best" Offshore Wind Class and by Supply Curve Step'
 write(IORNREPT,'(a,<unrgns>f10.3)') 'Combined, Step 1      ',(UTCSFN(nr,WTech,1),nr=1,unrgns)
 write(IORNREPT,'(a,<unrgns>f10.3)') 'Combined, Step 2      ',(UTCSFN(nr,WTech,2),nr=1,unrgns)
 write(IORNREPT,'(a,<unrgns>f10.3)') 'Combined, Step 3      ',(UTCSFN(nr,WTech,3),nr=1,unrgns)

 !Write out where (which wind classes and buffer zones) the supply curve capacities come from.
 write(IORNREPT,'(/,a,i4)') 'Sources for Offshore Wind Supply Curve Capacity (MW) for ',curcalyr
 do stp=1,msptmx
  write(IORNREPT,'(a,i4)') 'Source of Offshore Wind Capacity (with Cost Rank by Class and Buffer Zone) for Step ',stp
  write(IORNREPT,'(5x,a)') rept_head
  do wc=1,mnumcl
   do bf=1,mnumbf
    write(IORNREPT,'(a1,i1,a1,i1,1x,<unrgns>(f10.1,i3))') 'C',7-wc,'Z',bf,(FSCapInc(stp,nr,wc,bf),FRank(nr,wc,bf),nr=1,unrgns)
   end do
  end do
 end do

 write(IORNREPT,'(/,a,i4)') 'Miscellaneous Wind Variables by Region for ',curcalyr
 write(IORNREPT,'(/,a)') 'Transmission & Distribution Costs in "Best" Offshore Wind Buffer Zone'
 write(IORNREPT,'(20x,a)') rept_head
 write(IORNREPT,'(a,<unrgns>f10.2)') 'T&D Costs             ',(WWFTD(nr,curiyr),nr=1,unrgns)

end if

FYR = UESTYR-UHBSYR

if(curiyr.eq.LASTYR) then
 do nr=1,mnumnr
  if(nr.ne.ALASKA.and.nr.ne.HAWAII) then
  write(IORNREPT,'(a)') 'SFx>'
  write(IORNREPT,'(a,a,i2,13x,12x,<LASTYR-FYR+1>(4x,i4))') 'SFx>','Region ',nr,(yr+1989,yr=FYR,LASTYR)
   if(nr.le.unrgns) then
    write(IORNREPT,'(a,a,<LASTYR-FYR+1>i8)') 'SFx>',  'Best Offshore Wind Class          ',(7-FWCurCl(nr,yr),yr=FYR,LASTYR)
    write(IORNREPT,'(a,a,<LASTYR-FYR+1>i8)')'SFx>',   'Best Buff Zone                    ',(FWCurBf(nr,yr),yr=FYR,LASTYR)
    write(IORNREPT,'(a,a,<LASTYR-FYR+1>f8.4)') 'SFx>','Cost Of Electricity               ',(FAnnCost(nr,yr,FWCurCl(nr,yr),FWCurBf(nr,yr)),yr=FYR,LASTYR)
    write(IORNREPT,'(a,a,<LASTYR-FYR+1>f8.0)') 'SFx>','Cap Seen by ECP                   ',(WCAWFEL(nr,yr),yr=FYR,LASTYR)
    write(IORNREPT,'(a,a,<LASTYR-FYR+1>f8.4)') 'SFx>','Long-Term Mult                    ',(FLTMult(nr,yr),yr=FYR,LASTYR)
   endif
FCapPlnBld(nr,curiyr)=FCapAdded(nr,curiyr)-FCapNewBld(nr,curiyr)
  write(IORNREPT,'(a,a,<LASTYR-FYR+1>f8.1)') 'SFx>',  'Planned Builds - Install this yr  ',(FCapPlnBld(nr,yr),yr=FYR,LASTYR)
  write(IORNREPT,'(a,a,<LASTYR-FYR+1>f8.1)') 'SFx>',  'Prev ECP Builds - Install this yr ',(FCapNewBld(nr,yr),yr=FYR,LASTYR)
  write(IORNREPT,'(a,a,<LASTYR-FYR+1>f8.1)') 'SFx>',  'Total Installed this yr           ',(FCapAdded(nr,yr),yr=FYR,LASTYR)
  write(IORNREPT,'(a,a,<LASTYR-FYR+1>f8.1)') 'SFx>',  'Total Cumulative Installed Cap    ',(FCapInstall(nr,yr),yr=FYR,LASTYR)
  write(IORNREPT,'(a,a,<LASTYR-FYR+1>f8.1)') 'SFx>',  'ECP Chosen This Year              ',(FCapCommit(nr,yr),yr=FYR,LASTYR)
  do i=1,FNLead-1
   write(IORNREPT,'(a,a,i1,a,<LASTYR-FYR+1>f8.1)') 'SFx>','ECP Chosen Year-',i,'                 ',(FCapCommit(nr,yr-i),yr=FYR,LASTYR)
  end do
  write(IORNREPT,'(a,a,<LASTYR-FYR+1>f8.1)') 'SFx>','Total Committed but not Installed ',(FCapCmtTot(nr,yr),yr=FYR,LASTYR)
  write(IORNREPT,'(a,a,<LASTYR-FYR+1>f8.1)') 'SFx>','Total Committed and Installed     ',(FCapIandC(nr,yr),yr=FYR,LASTYR)

  endif   !not Alaska or Hawaii
 end do   !regions

 do nr=1,mnumnr
  if(nr.ne.ALASKA.and.nr.ne.HAWAII) then
    write(IORNREPT,'(a)') 'Fd>'
    write(IORNREPT,'(a,a,i2)') 'Fd>','Cumulative Offshore Wind Installed Capacity (ICapCum)  Region ',nr
    write(IORNREPT,'(a,a,i2,13x,<LASTYR-FYR+1>(4x,i4))') 'Fd>','Region ',nr,(yr+1989,yr=FYR,LASTYR)
       do wc=1,mnumcl
        do bf=1,mnumbf
         write(IORNREPT,'(a,2x,a,i1,a,i1,16x,<LASTYR-FYR+1>f8.1)') 'Fd>','C',7-wc,'Z',bf,(FICapCum(nr,yr,wc,bf),yr=FYR,LASTYR)
        end do
       end do
       write(IORNREPT,'(a,2x,a,i2,3x,<LASTYR-FYR+1>f8.1)') 'Fd>','Total - Region ',nr,(FCapInstall(nr,yr),yr=FYR,LASTYR)
  endif   !not Alaska or Hawaii
 end do   !regions
end if    !Lastyr


return
end




! ********************************************************************
!
!   #    #   ####   #    #
!   ##  ##  #       #    #
!   # ## #   ####   #    #
!   #    #       #  # ## #
!   #    #  #    #  ##  ##
!   #    #   ####   #    #
! ********************************************************************
!
!  Subroutine WASTE
!
! This subroutine uses a regression approach to determine the projected
! capacity stemming from MSW. There are two components contributing to
! the capacity estimation: (1) capacity combusting of MSW, (2) capacity
! combusting methane from landfills.
!
! Inputs:
!    Common: MACOUT:
!            MC_GDP      : GDP in [10^9]
!            mc_n   : Population incl. overseas armed forces in [10^6]
!
!
! Output:
!   general cost and performance characteristics in (wrenew)
!
!
! Local variables:
!
!  COMMON WMSW
!
!    Real
!       clb_ton  : conversion factore lb -> ton
!       QNAT     : national Waste stream  by NERC in [10^6 ton]
!       Q        : energy produced from combusting waste  [10^6 BTU]
!       Capgarb  : capacity of direct garbage combustion [MW]
!       CapLfil  : capacity from land fill [MW]
!       WCAP     ! Capacity in [MW]
!       WHR      ! Heat rate
!       WCAPF    ! Capacity factor [%]
!
!
!
!    Integer:
!        nr      : region counter
!         i      : generic counter
!        WECP    ! ECP type   (MSW:WIMS)
!        WEFD    ! EFD type   (MSW:UIMSW)
!        WOWN    ! Ownership  (MSW:2 for Non-util)
!
!
!
! written by: Michael Kintner-Meyer
! date:  8-4-95
! ---------------------------------------------------------------------
      
      module LFG_
      
      INCLUDE 'parametr'
      INCLUDE 'NCNTRL'
      INCLUDE 'MACOUT'
      INCLUDE 'WMSCOMON'
   
      integer*4 num_yrs_in_expansion_periods
      PARAMETER (num_yrs_in_expansion_periods=5)
   
      integer*4 num_emm_lfg_region
      PARAMETER (num_emm_lfg_region=25)
     
      real Landfill_cap_expand_project_pct
      integer lfg_param_file_unit
      integer lfg_forecast_file_unit
 
      integer First_AEO_forecast_year 
      integer Last_AEO_forecast_year !  Note:  This parameter is equal to the value of the parameter above, which is read in
      integer Last_historical_data_year
      integer Num_AEO_forecast_years

      real Elec_cap_per_landfill_cap_multiple_projects,   &
           Elec_cap_per_landfill_cap_single_project,      &
           Future_expansion_capacity_base_fraction,       &
           GDP_AEO_forecast_growth_rate_compound_ann_pct, & 
           GDP_hist_growth_rate_compound_ann_pct,         &
           Landfill_cap_ann_growth_rate,                  &
           Landfill_cap_single_project_pct,               &
           Landfill_Cap_tot_for_LFG_last_hist_yr,         &
           LFG_GDP_ratio_reference_case  ,                &
           Pct_of_potential_LFG_Cap_for_Elec 
                           

    
      real Fraction_of_capacity_that_expands_by_future_5yr_periods(9)
      real GDP_AEO_forecast_growth_rate_year_pct(MNUMYR) 
      real Elec_cap_expand_original(MNUMYR) 
      integer interim_calculation_file_unit
 
      real weight_lfg_landfill_annual(MNUMYR),                       &
           fraction_lfg_landfill_annual(MNUMYR),                     &
           Landfill_Capacity_annual_for_LFG_Elec_reference(MNUMYR),  &
           WIP_Cap_no_expansion_reference(MNUMYR),                   &
           Cumulative_WIP_CAPACITY_expansion_only(MNUMYR),           &
           Elec_cap_no_expand_candidate(MNUMYR),                     &
           Elec_cap_expand_candidate(MNUMYR),                        &
           Elec_cap_additions_TOTAL(MNUMYR)  

      real weight_lfg_landfill_cum,          &
           growth_ratio_from_hist_yr,        &
		   GDP_AEO_GROWTH_RATE_CURRENT_YR,   &                                
           GDP_HIST_AEO_DIFF_FOR_LFG,        &
           LFG_AEO_HIST_GDP_RATIO_reference
                                 

      integer*4  LFG_development_periods_num, &
               year_forecast, y_f,              &                
               NUM_YEARS_IN_FORECAST,           &
               forecast_interval,               &
               emm_region,                      &
               Num_EMM_LFG_REGIONS,             &
               WIP_EXPANSION_PERIOD,            & 
               j ,K 

      integer*4 num_yrs_in_period, leftover_years
      integer*4 period_subtraction
 !     real Elec_cap_additions_total_emm_reg(MNUMYR,MNUMNR) !num_emm_lfg_region)
             
      end module LFG_

      Subroutine WASTE
      use LFG_
      implicit none

      include 'emmparm'
      include 'ecpcntl'
      include 'control'
      include 'wrenew'
      include 'cogen'
      include 'wrenio'
      include 'dispinyr'
      include 'udatout'     ! UDAT output variables
      include 'uecpout'     ! UECP output variables
      include 'uefpout'     ! UEFP output variables
      include 'uefdout'     ! EFD output variables
      include 'uldsmout'    ! LDSM output variables
      include 'uettout'     ! UETT output variables

      real QNAT, Q,Capgarb,CapLfil
      integer IRG,ISTP,nr,iyr,OLYR,ITECHNO,LHYEAR
      integer STRTYR,YEAR,IYLD,ILF,STRYR,EYR,PRDYR,NUMHYR,NUMYEARS

      integer WECP      ! ECP type   (MSW:WIMS)
      integer WEFD      ! EFD type   (MSW:UIMSW)
      integer WOWN      ! Ownership  (MSW:2 for Non-util)
      data WOWN /2/
      data ITECHNO/ 5/                ! MSW is technology no 5

      real*8 WCAP       ! Capacity in [MW]
      real*8 WWHR        ! Heat rate
      real*8 WCAPF      ! Capacity factor [%]
      real   WTotcap     ! total capacity [MW] evaluated from regression
      real   WTotadd     ! total additions [MW]
      real   MSWADD      ! total additions [MW]
      real   Wtotexis    ! Total existing [MW]
      REAL  DECOMP_STR,DECOMP_YIELD,HIS_YRYLD
      REAL  HCALC_LFILL(NUM_YEARS),CALC_LFILL(MNUMYR)
      REAL  HIS_YRLY_YIELD(NUM_YEARS,NUM_YEARS)
      REAL  HIS_TOTCUFT(NUM_YEARS)
      REAL  TOTCUFT,TOTPOUNDS,TOTMETTONS,YRYLD
      REAL  GROSS_SUPPLY,NET_SUPPLY,REGSUPP(WRGLF_TYP,MNUMNR)
      REAL  WASTE_STREAM,REC,FLARE,EQMW_GROSS,EQMW_NET,GRHGAS
      REAL  HIS_YRYLDTOT(NUM_YEARS,YLD_TYP,NUM_YEARS),DUMMY
      REAL  TOTCUFTYLD(YLD_TYP)
      REAL  HIS_TOTCUFTYLD(YLD_TYP,NUM_YEARS)

      GRHGAS=138
      DUMMY=0.0
      WTotcap=0.
      WTotadd=0.
      WTotexis=0.
      WECP = WIMS
      WEFD = UIMSW
      WHRMSEL(:,CURIYR) = UPHTRT(WIMS)

! ....... Read in input data and initialize
      if ((CURCALYR.eq.UESTYR) .and. (CURITR.eq.1))then
         call WMSWREAD
         Call EMM_MSW !subroutine in uesql.f90

!   PROCESS NON-BIO MSW NUMBERS READ IN FROM REGION TOOL
         LHYEAR = UYR_HIST - UHBSYR
 
!        Set forecast years emm region nonbio msw equal to average of last three historical years
         DO IRG = 1 , MNUMNR - 1
          DO IYR = LHYEAR + 1 , MNUMYR
           WNGMSEL(IYR,IRG) = (WNGMSEL(LHYEAR,IRG) + WNGMSEL(LHYEAR-1,IRG) + WNGMSEL(LHYEAR-2,IRG)) / 3.0
           WNCMSELN(IYR,IRG) = (WNCMSELN(LHYEAR,IRG) + WNCMSELN(LHYEAR-1,IRG) + WNCMSELN(LHYEAR-2,IRG)) / 3.0
         ENDDO
         ENDDO

!        Set 10 years prior to first historical year equal to first historical year value
         DO IYR = HSTYEAR - UHBSYR - 10, HSTYEAR - UHBSYR - 1
           WNGMSEL(IYR,:) = WNGMSEL(HSTYEAR-UHBSYR,:)
           WNCMSELN(IYR,:) = WNCMSELN(HSTYEAR-UHBSYR,:)
         ENDDO

!        Set forecast years census region nonbio msw equal to average of last three historical years
         DO IRG = 1 , MNUMCR - 1
          DO IYR = LHYEAR + 1 , MNUMYR
           WNGMSELC(IYR,IRG) = (WNGMSELC(LHYEAR,IRG) + WNGMSELC(LHYEAR-1,IRG) + WNGMSELC(LHYEAR-2,IRG)) / 3.0
           WNCMSEL(IYR,IRG) = (WNCMSEL(LHYEAR,IRG) + WNCMSEL(LHYEAR-1,IRG) + WNCMSEL(LHYEAR-2,IRG)) / 3.0
          ENDDO
         ENDDO

!        Set 10 years prior to first historical year equal to first historical year value
         DO IYR = HSTYEAR - UHBSYR - 10, HSTYEAR - UHBSYR - 1
           WNGMSELC(IYR,:) = WNGMSELC(HSTYEAR-UHBSYR,:)
           WNCMSEL(IYR,:) = WNCMSEL(HSTYEAR-UHBSYR,:)
         ENDDO
!
!       sum emmreg national nonbio msw numbers 
!
        DO IYR = 1 , MNUMYR
         WNGMSEL(IYR,MNUMNR) = 0.0
         WNCMSELN(IYR,MNUMNR) = 0.0
         DO IRG = 1 , unrgns   
          WNGMSEL(IYR,MNUMNR) = WNGMSEL(IYR,MNUMNR) + WNGMSEL(IYR,IRG)
          WNCMSELN(IYR,MNUMNR) = WNCMSELN(IYR,MNUMNR) + WNCMSELN(IYR,IRG)
         ENDDO
        ENDDO
!
!       sum cenreg national nonbio msw numbers 
!
        DO IYR = 1 , MNUMYR
         WNGMSELC(IYR,MNUMCR) = 0.0
         WNCMSEL(IYR,MNUMCR) = 0.0
         DO IRG = 1 , MNUMCR-1 
          WNGMSELC(IYR,MNUMCR) = WNGMSELC(IYR,MNUMCR) + WNGMSELC(IYR,IRG)
          WNCMSEL(IYR,MNUMCR) = WNCMSEL(IYR,MNUMCR) + WNCMSEL(IYR,IRG)
         ENDDO
        ENDDO
!
      ENDIF

      OLYR=CURIYR+UPPLYR(WIMS)

! .......... Run only for the first iteration and CURyr-leadtime<MNUMYR......
      if (CURITR .EQ. 1) THEN

! ..... Store into real*8 variables)

       IF (WHRMSEL(1,CURIYR).gt.0) THEN
         WWHR =DBLE(WHRMSEL(1,CURIYR))
       ELSE
         WWHR =DBLE(WHRMSEL(1,CURIYR-1))          !DGR this is a patch for now
         IF (CURIYR.LE.20)WWHR = 16538
         WRITE(6,*)'WWHR ',CURIYR,WWHR ,WHRMSEL(1,CURIYR)
       ENDIF
       IF (WCFMSEL(1,CURIYR).gt.0) THEN
         WCAPF=DBLE(WCFMSEL(1,CURIYR))
       ELSE
         WCAPF=DBLE(WCFMSEL(1,CURIYR-1))          !DGR this is a patch for now
         IF (CURIYR.LE.20) WCAPF=0.90
         WRITE(6,*)'WCAPF ',CURIYR,WCAPF,WCFMSEL(1,CURIYR)
       ENDIF

! (First iteration only!!, first year only)
      IF ((CURCALYR.EQ.UESTYR) .AND. (CURITR.EQ.1)) THEN
!
        STRTYR = LFGFHYR
        NUMHYR = LFGLHYR - STRTYR + 1
        NUMYEARS = MNUMYR + ( 1989 - STRTYR ) + 1
        HIS_YRYLDTOT = 0.0
        HIS_YRLY_YIELD = 0.0
        HIS_TOTCUFT = 0.0
        HIS_TOTCUFTYLD = 0.0
        YRYLDTOT = 0.0
        YRLY_YIELD = 0.0
!
!   Calculate landfill amounts for historical years, lfgfhyr to lfglhyr
         DO IYR = 1 , NUMHYR
           YEAR = STRTYR - 1 + IYR
!  Add greenhouse gas to 96-98 franklin landfill numbers    (USED??)
           IF ((YEAR .GE. 1996) .AND. (YEAR .LE. 1998)) THEN
             FRANKLIN_LFILL(IYR) = FRANKLIN_LFILL(IYR-1) + GRHGAS
           ENDIF
           IF (YEAR .LE. 1988) THEN
             HCALC_LFILL(IYR) = FRANKLIN_LFILL(IYR) * FRANKLIN_RATIO(IYR)
           ELSE
             HCALC_LFILL(IYR) = BIOCYCLE_LFILL(IYR) * UNKNOWN_RATIO(IYR)
           ENDIF
!
!  Calculate yearly projected Methane yield by landfill type and yield type for historical years
!
           DO IYLD = 1 , YLD_TYP
             DO ILF = 1 , WLF_TYP
               DECOMP_STR = HCALC_LFILL(IYR) * DECOMP_FRAC(ILF,IYLD) * WIP_RATE(IYLD) * 2000000
               DECOMP_YIELD = DECOMP_STR * YLD_RATE(ILF,IYLD) / 1000000000
               HIS_YRYLD = DECOMP_YIELD / PROD_LIMIT(ILF,IYLD)
               STRYR = IYR + LAG(ILF,IYLD)
               EYR = STRYR + PROD_LIMIT(ILF,IYLD) - 1
               EYR = MIN(EYR,NUMYEARS)
               DO PRDYR = STRYR , EYR
                 HIS_YRYLDTOT(IYR,IYLD,PRDYR) = HIS_YRYLDTOT(IYR,IYLD,PRDYR) + HIS_YRYLD
                 HIS_YRLY_YIELD(IYR,PRDYR) = HIS_YRLY_YIELD(IYR,PRDYR) + HIS_YRYLD
               ENDDO
             ENDDO
           ENDDO
         ENDDO
!
        DO PRDYR = 1 , NUMYEARS
          DO IYR = 1 , NUMHYR
            HIS_TOTCUFT(PRDYR) = HIS_TOTCUFT(PRDYR) + HIS_YRLY_YIELD(IYR,PRDYR)
            DO IYLD = 1 , YLD_TYP
              HIS_TOTCUFTYLD(IYLD,PRDYR) = HIS_TOTCUFTYLD(IYLD,PRDYR) + HIS_YRYLDTOT(IYR,IYLD,PRDYR)
            ENDDO
          ENDDO
          IF (PRDYR .LE. NUMHYR) THEN
            TOTPOUNDS = HIS_TOTCUFT(PRDYR) / 1000 * 42.28
            TOTMETTONS = TOTPOUNDS / 1000000 / CLB_TON
            GROSS_SUPPLY = HIS_TOTCUFT(PRDYR) / 2
            REC = RECOVERY_FCTR(PRDYR) * CLB_TON / 42.28
            FLARE = FLARE_FCTR(PRDYR) * CLB_TON / 42.28
            NET_SUPPLY = GROSS_SUPPLY - REC - FLARE
!
!   convert msw supply to equivalent MW
!
            EQMW_GROSS =( (GROSS_SUPPLY * WHC(CURIYR)) / (WWHR * 8760 * WCAPF) ) * 10**9/1000
            EQMW_NET =( (NET_SUPPLY * WHC(CURIYR)) / (WWHR * 8760 * WCAPF) ) * 10**9/1000
            write(IORNDUMP,1700) PRDYR+STRTYR-1,DUMMY,HCALC_LFILL(PRDYR),DUMMY,   &
              (HIS_TOTCUFTYLD(IYLD,PRDYR),IYLD=1,4),   &
              GROSS_SUPPLY,REC,FLARE,  &
              NET_SUPPLY,EQMW_NET,EQMW_GROSS
          ENDIF
        ENDDO
1700    FORMAT(' MSWDBG ',I4,1x,2(2X,F10.0),9(2X,F12.5),2(2X,F10.0))
!
!       PUT HISTORICAL YEAR TOTALS INTO NEMS YEARS (1990 to 2020)
!
        DO PRDYR =  BASEYR - STRTYR + 1 , NUMYEARS
          HIS_TOTYLD(PRDYR - (BASEYR-STRTYR)) = HIS_TOTCUFT(PRDYR)
          DO IYLD = 1 , YLD_TYP
            HIS_TOTYLDS(IYLD,PRDYR-(BASEYR-STRTYR)) = HIS_TOTCUFTYLD(IYLD,PRDYR)
          ENDDO
        ENDDO
!
!  Calculate % of waste recycled for years 1998 to 2020
!
       DO IYR = 9 , MNUMYR
         IF (IYR .EQ. 9) THEN
           PERCENT_RECYCLE(IYR) = LANDFILL_1998
         ELSEIF (IYR .EQ. 16) THEN
           PERCENT_RECYCLE(IYR) = LANDFILL_2005
         ELSEIF (IYR .EQ. 21) THEN
           PERCENT_RECYCLE(IYR) = LANDFILL_2010
         ELSEIF (IYR .EQ. 26) THEN
           PERCENT_RECYCLE(IYR) = LANDFILL_2015
         ELSEIF (IYR .EQ. 31) THEN
           PERCENT_RECYCLE(IYR) = LANDFILL_2020
         ELSEIF (IYR .EQ. 36) THEN
           PERCENT_RECYCLE(IYR) = LANDFILL_2025
         ELSEIF (IYR .EQ. 41) THEN
           PERCENT_RECYCLE(IYR) = LANDFILL_2030
         ELSEIF ((IYR .GE. 10) .AND. (IYR .LT. 16)) THEN
           PERCENT_RECYCLE(IYR) = ((LANDFILL_2005 - LANDFILL_1998)/7)  &
                                + PERCENT_RECYCLE(IYR-1)
         ELSEIF ((IYR .GE. 17) .AND. (IYR .LT. 21)) THEN
           PERCENT_RECYCLE(IYR) = ((LANDFILL_2010 - LANDFILL_2005)/5)  &
                                + PERCENT_RECYCLE(IYR-1)
         ELSEIF ((IYR .GE. 22) .AND. (IYR .LT. 26)) THEN
           PERCENT_RECYCLE(IYR) = ((LANDFILL_2015 - LANDFILL_2010)/5)  &
                                + PERCENT_RECYCLE(IYR-1)
         ELSEIF ((IYR .GE. 27) .AND. (IYR .LT. 31)) THEN
           PERCENT_RECYCLE(IYR) = ((LANDFILL_2020 - LANDFILL_2015)/5)  &
                                + PERCENT_RECYCLE(IYR-1)
         ELSEIF ((IYR .GE. 32) .AND. (IYR .LT. 36)) THEN
           PERCENT_RECYCLE(IYR) = ((LANDFILL_2025 - LANDFILL_2020)/5)  &
                                + PERCENT_RECYCLE(IYR-1)
         ELSEIF ((IYR .GE. 37) .AND. (IYR .LT. 41)) THEN
           PERCENT_RECYCLE(IYR) = ((LANDFILL_2030 - LANDFILL_2025)/5)  &
                                + PERCENT_RECYCLE(IYR-1)
         ELSEIF (IYR.GT.41) THEN
           PERCENT_RECYCLE(IYR) = PERCENT_RECYCLE(41)
         ENDIF
       ENDDO
!
! End first iteration, first year only.
     ENDIF
!
!  Calculate waste stream for curiyr if forecast year
!
     IF ( CURIYR .GE. (LFGLHYR - 1989 + 1))  THEN
       WASTE_STREAM = (A1*MC_GDPR(CURIYR) +  &
          A2*MC_NP(MNUMCR,CURIYR)) * (1-(CURIYR+15)*SR)*alpha*1000
!       WASTE_STREAM = (A1*MSWGDP(CURIYR+49) +  &
!           A2*MSWPOP(CURIYR+49)) * (1-(CURIYR+15)*SR)*alpha*1000
!
!  Calculate landfill for curiyr
!
        CALC_LFILL(CURIYR) = (1.0 - PERCENT_RECYCLE(CURIYR)) * WASTE_STREAM
!
!  Calculate yearly projected Methane yield by landfill type and yield type for current year
!
        DO IYLD = 1 , YLD_TYP
          DO ILF = 1 , WLF_TYP
            DECOMP_STR = CALC_LFILL(CURIYR) *  &
                    DECOMP_FRAC(ILF,IYLD) * WIP_RATE(IYLD) * 2000000
            DECOMP_YIELD = DECOMP_STR *  &
                    YLD_RATE(ILF,IYLD) / 1000000000
            YRYLD =  DECOMP_YIELD / PROD_LIMIT(ILF,IYLD)
            STRYR = CURIYR + LAG(ILF,IYLD)
            EYR = STRYR + PROD_LIMIT(ILF,IYLD) - 1
            EYR = MIN(EYR,MNUMYR)
            DO PRDYR = STRYR , EYR
              YRYLDTOT(CURIYR,IYLD,PRDYR) =  &
                       YRYLDTOT(CURIYR,IYLD,PRDYR) + YRYLD
              YRLY_YIELD(CURIYR,PRDYR) = &
                       YRLY_YIELD(CURIYR,PRDYR) + YRYLD
            ENDDO
          ENDDO
        ENDDO
!
! calculate msw supply up to current year, including historical supply
!
          TOTCUFT = 0.0
          TOTCUFTYLD=0.0
          DO IYR = 1 , CURIYR
            TOTCUFT = TOTCUFT + YRLY_YIELD(IYR,CURIYR)
            DO IYLD = 1 , YLD_TYP
              TOTCUFTYLD(IYLD) = TOTCUFTYLD(IYLD) +   &
                          YRYLDTOT(IYR,IYLD,CURIYR)
            ENDDO
          ENDDO
          DO IYLD = 1 , YLD_TYP
            TOTCUFTYLD(IYLD) = TOTCUFTYLD(IYLD) + HIS_TOTYLDS(IYLD,CURIYR)
          ENDDO
          TOTCUFT = TOTCUFT + HIS_TOTYLD(CURIYR)
          TOTPOUNDS = TOTCUFT / 1000 * 42.28
          TOTMETTONS = TOTPOUNDS / 1000000 / CLB_TON
          GROSS_SUPPLY = TOTCUFT / 2
          REC = RECOVERY_FCTR(CURIYR+(BASEYR-STRTYR)) * CLB_TON / 42.28
          FLARE = FLARE_FCTR(CURIYR+(BASEYR-STRTYR)) * CLB_TON / 42.28
          NET_SUPPLY = GROSS_SUPPLY - REC - FLARE
!
!   convert msw supply to equivalent MW
!
       write(IORNDUMP,*) ' before adj grs net ',CURIYR,EQMW_GROSS,EQMW_NET,WWHR,WCAPF
 EQMW_GROSS =( (GROSS_SUPPLY * WHC(CURIYR)) /  &
              (WWHR * 8760 * WCAPF) ) * 10**9/1000
        EQMW_NET =( (NET_SUPPLY * WHC(CURIYR)) /  &
              (WWHR * 8760 * WCAPF) ) * 10**9/1000

!
!  Multiply MSW supply by .9 in first forecast year growing to 1.0 in last year (currently 2030)
!
        EQMW_GROSS = EQMW_GROSS *  &
            ( .90 + ((CURIYR - (LFGLHYR - 1989 + 1)) * ((1.0 - .90)/((MNUMYR + 1989) - (LFGLHYR + 1) ))))
        EQMW_NET   = EQMW_NET *  &
            ( .90 + ((CURIYR - (LFGLHYR - 1989 + 1)) * ((1.0 - .90)/((MNUMYR + 1989) - (LFGLHYR + 1) ))))
        write(IORNDUMP,*) ' after adj grs net ',EQMW_GROSS,EQMW_NET
!
!   allocate supply to NERC regions
!
        DO ILF = 1 , WRGLF_TYP
          DO IRG = 1 , unrgns
            REGSUPP(ILF,IRG) = EQMW_GROSS * YIELD_RATIOS(IRG,ILF) / 100
          ENDDO
        ENDDO

! ...... Put MSW available capacity variables into variables dimensioned by technology
        DO IRG = 1 , unrgns
        DO ISTP = 1 , MSPTMX
          UTCAFNR(IRG,ITECHNO,ISTP) = REGSUPP(ISTP,IRG)
        ENDDO
      ENDDO

         DO IRG = 1 , unrgns
           write(IORNDUMP,*) ' new utcafnr irg B4 decr', &
                    (UTCAFNR(IRG,ITECHNO,ISTP),ISTP=1,MSPTMX)
         ENDDO
! decrement supply curve available capacities by ECP builds and msw supplemental build
         DO IRG = 1 , unrgns
           MSWADD = 0.0
           DO IYR = 1 , MNUMYR
             MSWADD = MSWADD + MSWSUPPADD(IYR,IRG)
           ENDDO
           write(IORNDUMP,*) ' mswadd suppadd ',mswadd
           DO IYR = 1 , OLYR
             MSWADD = MSWADD + UADDMST(IRG,IYR)
           ENDDO
           write(IORNDUMP,*) ' mswadd ',CURIYR,IRG,MSWADD
           IF (MSWADD .NE. 0.0) THEN
             DO ISTP = 1 , MSPTMX
               IF (UTCAFNR(IRG,ITECHNO,ISTP) .NE. 0.0) THEN
                 IF (MSWADD .GE. UTCAFNR(IRG,ITECHNO,ISTP)) THEN
                   MSWADD = MSWADD - UTCAFNR(IRG,ITECHNO,ISTP)
                   UTCAFNR(IRG,ITECHNO,ISTP) = 0.0
                   IF (UADDMST(IRG,OLYR) .NE. 0.0) THEN
                     WRITE(IORNDUMP,1800)  ISTP,IRG,CURIYR
                   ENDIF
                 ELSE
                   UTCAFNR(IRG,ITECHNO,ISTP) =  &
                        UTCAFNR(IRG,ITECHNO,ISTP) - MSWADD
                   MSWADD = 0.0
                 ENDIF
               ENDIF
             ENDDO
           ENDIF
         ENDDO

1800    FORMAT('****** WARNING: ALL MSW SUPPLY USED IN SUPPLY STEP '      &
                   ,I2,' IN REGION ',I2,' IN YEAR ',I4)
         DO IRG = 1 , unrgns
           write(IORNDUMP,*) ' new utcafnr irg ', &
                    (UTCAFNR(IRG,ITECHNO,ISTP),ISTP=1,MSPTMX)
         ENDDO
! end if curiyr ge 10
     ENDIF
     ENDIF
!
!
!**********************
! use UPSTYR which is currently 2019

! new LFG model
    if ((CURCALYR.eq.UESTYR) .and. (CURITR.eq.1)) call read_lfg_inputs !only need to read it once
    if ((curiyr .ge. UPSTYR-1989-1 ) .and.(curitr.eq.1))  call calculate_lfg                 ! 1st iteration only ???
    if ((curiyr.eq.lastyr) .and.(curitr.eq.1))  call print_lfg_capacity            ! 1st iteration only ???
!*********************
     return
     END
!***************************************************************
      subroutine read_lfg_inputs
      use LFG_
      IMPLICIT NONE
      INCLUDE 'EMMPARM'
      INCLUDE 'CONTROL'
      INCLUDE 'UEFDOUT'
      INTEGER   FILE_MGR
      EXTERNAL  FILE_MGR
      CHARACTER*18 FNAME
      LOGICAL NEW
      character*30 sheet
    
   
!  OPEN PARAMETER FILE AND READ INPUT FROM NAMED RANGES
      FNAME = 'LFG_PARAMETERS'
      NEW=.FALSE.
      lfg_param_file_unit = FILE_MGR('O',FNAME,NEW)
      SHEET='params'
      call readRngXLSX(lfg_param_file_unit,trim(sheet))  !read input file 
      lfg_param_file_unit = FILE_MGR('C',FNAME,NEW) ! close input file 
   
  
  ! set to mnumyr to be consistant with NEMS-tdm
      Last_AEO_forecast_year=mnumyr+1989
      First_AEO_forecast_year = UPSTYR - 1   
      Last_historical_data_year = UPSTYR - 2       
      Num_AEO_forecast_years  =  Last_AEO_forecast_year - First_AEO_forecast_year +1
     
      call getrngi4('L_d_p_n         ',LFG_development_periods_num,1,1,1)
      call  getrngr('E_c_p_l_c_m_p   ',Elec_cap_per_landfill_cap_multiple_projects,1,1,1)
      call  getrngr('E_c_p_l_c_s_p   ',Elec_cap_per_landfill_cap_single_project,1,1,1)
      call  getrngr('F_e_c_b_f       ',Future_expansion_capacity_base_fraction,1,1,1)
      call  getrngr('L_c_a_g_r       ',Landfill_cap_ann_growth_rate,1,1,1)
      call  getrngr('L_c_s_p_p       ',Landfill_cap_single_project_pct,1,1,1)
      call  getrngr('L_C_t_f_L_l_h_y ',Landfill_Cap_tot_for_LFG_last_hist_yr,1,1,1)
      call  getrngr('L_G_r_r_c       ',LFG_GDP_ratio_reference_case,1,1,1)
      call  getrngr('P_o_p_L_C_f_E   ',Pct_of_potential_LFG_Cap_for_Elec,1,1,1)
      call  getrngr('F_o_c_t_e_b_f_5p',Fraction_of_capacity_that_expands_by_future_5yr_periods,9,1,1)
      call  getrngr('E_c_e_o         ',Elec_cap_expand_original(First_AEO_forecast_year-1989:Last_AEO_forecast_year-1989),Num_AEO_forecast_years,1,1)
      call  getrngr('G_h_g_r_c_a_p   ',GDP_hist_growth_rate_compound_ann_pct,1,1,1)
   
    return
    end subroutine read_lfg_inputs
!**************************************************************************
      SUBROUTINE CALCULATE_LFG
      use LFG_
      IMPLICIT NONE
      INCLUDE 'EMMPARM'
      INCLUDE 'CONTROL'
      INCLUDE 'UEFDOUT'
   
!  BEGIN Create U.S. total and EMM regional LFG electrical capacity additions

      num_yrs_in_period        = num_aeo_forecast_years/lfg_development_periods_num + 1
      leftover_years           = mod(num_aeo_forecast_years, LFG_development_periods_num)
      weight_lfg_landfill_cum = num_yrs_in_period*(lfg_development_periods_num)*((lfg_development_periods_num+1))/2       &
                             - (num_yrs_in_period -  leftover_years)

      y_f = curiyr !!year_forecast - first_AEO_forecast_year + 1
      period_subtraction = (curiyr-(First_AEO_forecast_year-1989)+1)/num_yrs_in_period !y_f/num_yrs_in_period
      weight_lfg_landfill_annual(y_f) = num_yrs_in_period  -  period_subtraction
      fraction_lfg_landfill_annual(y_f) = weight_lfg_landfill_annual(y_f)/weight_lfg_landfill_cum
  
  
        ! replaced with NEMS value -tdm
       
      GDP_AEO_GROWTH_RATE_CURRENT_YR = (1.0-(MC_GDPR(curiyr-1)/MC_GDPR(curiyr)))*100.0
    
      GDP_HIST_AEO_DIFF_FOR_LFG = LFG_GDP_ratio_reference_case*(GDP_AEO_GROWTH_RATE_CURRENT_YR - GDP_hist_growth_rate_compound_ann_pct)
                                        
      LFG_AEO_HIST_GDP_RATIO_reference = (GDP_AEO_GROWTH_RATE_CURRENT_YR -GDP_HIST_AEO_DIFF_FOR_LFG)/GDP_hist_growth_rate_compound_ann_pct
      growth_ratio_from_hist_yr = Landfill_cap_ann_growth_rate**((curiyr+1989)-Last_historical_data_year)
   
      Landfill_Capacity_annual_for_LFG_Elec_reference(y_f) = LFG_AEO_HIST_GDP_RATIO_reference* &
                                                             fraction_lfg_landfill_annual(y_f)*Pct_of_potential_LFG_Cap_for_Elec* &
                                                             Landfill_Cap_tot_for_LFG_last_hist_yr*growth_ratio_from_hist_yr 
                                                             
           
      WIP_Cap_no_expansion_reference(Y_F) = Landfill_Capacity_annual_for_LFG_Elec_reference(y_f)*Landfill_cap_single_project_pct
   
      Cumulative_WIP_CAPACITY_expansion_only(Y_F) = 0.
      Landfill_cap_expand_project_pct = 1. - Landfill_cap_single_project_pct
      DO J = 1,  curiyr-(First_AEO_forecast_year-1989) +1 !y_F 
         WIP_EXPANSION_PERIOD = J/NUM_YRS_IN_EXPANSION_PERIODS + 1
         Cumulative_WIP_CAPACITY_expansion_only(Y_F) = Cumulative_WIP_CAPACITY_expansion_only(Y_F) + &
                                                   Landfill_Capacity_annual_for_LFG_Elec_reference(Y_F)* &
                                                   Landfill_cap_expand_project_pct*Future_expansion_capacity_base_fraction* &
                                                   Fraction_of_capacity_that_expands_by_future_5yr_periods(WIP_EXPANSION_PERIOD)   !good                                    
      END DO
                                                              
      Elec_cap_no_expand_candidate(y_f) = WIP_Cap_no_expansion_reference(Y_F)*(Elec_cap_per_landfill_cap_single_project/10)
      Elec_cap_expand_candidate(y_f) = Cumulative_WIP_CAPACITY_expansion_only(Y_F)*(Elec_cap_per_landfill_cap_multiple_projects/10)
      Elec_cap_additions_TOTAL(Y_F) = Elec_cap_expand_original(Y_F) + Elec_cap_expand_candidate(y_f) + Elec_cap_no_expand_candidate(y_f)
    
! EMM regional lfg capacity additions
      DO emm_region = 1, UNRGNS                 
        LFGCAPNR(EMM_REGION,curiyr)=Elec_cap_additions_TOTAL(Y_F)*WIPSHR(emm_region)
      enddo
return
END SUBROUTINE CALCULATE_LFG
!**********************************************************************
      SUBROUTINE PRINT_LFG_CAPACITY
      use LFG_
      IMPLICIT NONE
      INCLUDE 'EMMPARM'
      INCLUDE 'CONTROL'
      INCLUDE 'UEFDOUT'
   
      INTEGER   FILE_MGR
      EXTERNAL  FILE_MGR
      CHARACTER*18 FNAME
      LOGICAL NEW
    
      integer iyr,rgn  !loop controls for year and region on output file
       
 !  Open OUTPUT file for annual U.S. and EMM region LFG electricity capacity forecasts (Mw)
      FNAME = 'LFG_CAPACITY'
      lfg_forecast_file_unit = FILE_MGR('O',FNAME,.true.)
   
   !  WRITE HEADERS TO FORECAST OUTPUT FILE
      write(lfg_forecast_file_unit,'("  FORECASTS OF LFG ELECTRICAL CAPACITY (MW)")') !lfg_elec_capacity_units 
      WRITE(LFG_FORECAST_FILE_UNIT,10) 'YEAR,U.S. TOTAL,',(URGNME(K)(1:4),',', K = 1, UNRGNS)
10 FORMAT (A16,25(A10,A1))

!  WRITE FORECASTS TO OUTPUT FILE
      DO year_forecast = First_AEO_forecast_year, Last_AEO_forecast_year
        iyr=year_forecast-1989
        WRITE(LFG_FORECAST_FILE_UNIT,20) YEAR_FORECAST,',', Elec_cap_additions_TOTAL(iyr),',', (LFGCAPNR(rgn,iyr),',', rgn = 1, UNRGNS)
      ENDDO   
20    FORMAT (I4,A1,F6.2,A1,25(F6.2,A1))
      LFG_FORECAST_FILE_UNIt = FILE_MGR('C',FNAME,.false.)
return
END SUBROUTINE PRINT_LFG_CAPACITY

! *********************************************************************
! Subroutine: WMSWREAD
!
! Reads in cost and performance characteristics as well as input data
! for evaluating intermediate variables.
!
!
! Input:
!
! Output:
!   COMMON : wrenew:
!          WCLT(5)     : lead time for MSW  [year]
!          WLIMSEL     : Life cycle time  [year]
!
! Local variables:
!    Real:
!       WdumAR1  : dummy array dim (MNUMYR)
!       WdumAR2  : dummy array dim MNPOLLT
!
!    Integer:
!       ITECHNO  : technology counter MSW is number 5
!       IWCLTMS  : integer number for lead time
!       i,j      : generic counters
!
!
! written by: Michael Kintner-Meyer
! date :  8/4/95
! ---------------------------------------------------------------------
      Subroutine WMSWREAD
      implicit none
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'control'
      include 'wrenew'
      include 'wmscomon'
      include 'uefdout'

      integer iyr,yr,i,IUNIT,MSiodbg,j,numyears
      integer ITECHNO,IWCLTMS,IRG,ISTP,IPOL
      integer RD$C1,RD$TBL,RD$R1,RD$R2,RD$I1,RET_CD
      INTEGER*4    DMSZ
      PARAMETER (DMSZ = 150)
      CHARACTER*40 DUMMY(DMSZ)             ! DUMMY COLUMN IN DATA TABLES
      CHARACTER*150 DUMMY2
      INTEGER*4    IDUMMY(DMSZ)                    ! SCALAR DUMMY COLUMN
      integer FILE_MGR
      external FILE_MGR

      Real WdumAR1(MNUMYR),WdumAR2(MNPOLLUT)
      Real AVCAP(MNUMNR,MSPTMX),CCOSTM(MNUMNR,MSPTMX)
      Real FCOSTM(MNUMNR,MSPTMX),VCOSTM(MNUMNR,MSPTMX)

      data ITECHNO/ 5/                ! MSW is technology no 5


      MSiodbg=6

      IUNIT=FILE_MGR('O','MSWDAT            ',.FALSE.)

! ........ Variable O&M cost
      RET_CD=RD$TBL(IUNIT,'%WMSW_VAROM%',1,MSiodbg,6)
      RET_CD=RD$R1(WVC,1,1)

! ........ Tipping Fee [$/ton]
      RET_CD=RD$TBL(IUNIT,'%WMSW_TIPPF%',9,MSiodbg,6)
      RET_CD=RD$R1(MSTIPPCR,1,MNUMCR)

! ........ Heat Content in [BTU/lb]
      RET_CD=RD$TBL(IUNIT,'%WMSW_HEATC%',MNUMYR,MSiodbg,6)
      RET_CD=RD$R1(Wdumar1,1,MNUMYR)
      RET_CD=RD$R1(WHC,1,MNUMYR)

! ....... Regression coeff.
      RET_CD=RD$TBL(IUNIT,'%REGRESCOEF%',1,MSiodbg,6)
      RET_CD=RD$R1(a1,1,1)
      RET_CD=RD$R1(a2,1,1)

! ....... Source reduction factor
      RET_CD=RD$TBL(IUNIT,'%SOURCEREDF%',1,MSiodbg,6)
      RET_CD=RD$R1(SR,1,1)

! ....... Adjustment factor for waste stream evaluation
      RET_CD=RD$TBL(IUNIT,'%WASTEREDFA%',1,MSiodbg,6)
      RET_CD=RD$R1(alpha,1,1)

! ....... Total national Landfill capacity by years
      RET_CD=RD$TBL(IUNIT,'%TFLCAPACIT%',MNUMYR,MSiodbg,6)
      RET_CD=RD$R1(TLFCAP,1,MNUMYR)

! ....... Emmission factors in [lb/MMBTU]
      RET_CD=RD$TBL(IUNIT,'%WMSEMSEL  %',1,MSiodbg,6)
      RET_CD=RD$R2(WEMMSEL,1,1,1,MNPOLLUT,MNUMYR)
      RET_CD=RD$R2(WEMMSEL,2,1,1,MNPOLLUT,MNUMYR)
      RET_CD=RD$R2(WEMMSEL,3,1,1,MNPOLLUT,MNUMYR)
      RET_CD=RD$R2(WEMMSEL,4,1,1,MNPOLLUT,MNUMYR)
      RET_CD=RD$R2(WEMMSEL,5,1,1,MNPOLLUT,MNUMYR)
      RET_CD=RD$R2(WEMMSEL,6,1,1,MNPOLLUT,MNUMYR)
      RET_CD=RD$R2(WEMMSEL,7,1,1,MNPOLLUT,MNUMYR)
      RET_CD=RD$R2(WEMMSEL,8,1,1,MNPOLLUT,MNUMYR)

!        WRITE(6,*)'wemmsel ',2,1,WEMMSEL(2,1)

      do yr=1,MNUMYR

! ...... assign emmission factors of year 1 to all years
         do ipol=1,MNPOLLUT
            WEMMSEL(ipol,yr)=WEMMSEL(ipol,1)
         enddo
      enddo

! ...... Read in Fraction Decomposed by decomposition type and yield type
      RET_CD=RD$TBL(IUNIT,'%FRDECOMP  %',WLF_TYP,MSiodbg,6)
      RET_CD=RD$C1(DUMMY,1,DMSZ)
      RET_CD=RD$R2(DECOMP_FRAC,1,1,YLD_TYP,WLF_TYP,YLD_TYP)

! ...... Read in Rate of Methane Yield by decomposition type and yield type
      RET_CD=RD$TBL(IUNIT,'%METHYLD   %',WLF_TYP,MSiodbg,6)
      RET_CD=RD$C1(DUMMY,1,DMSZ)
      RET_CD=RD$R2(YLD_RATE,1,1,YLD_TYP,WLF_TYP,YLD_TYP)

! ...... Read in Lag for Methane Generation by decomposition type and yield type
      RET_CD=RD$TBL(IUNIT,'%METHLAG   %',WLF_TYP,MSiodbg,6)
      RET_CD=RD$C1(DUMMY,1,DMSZ)
      RET_CD=RD$R2(LAG,1,1,YLD_TYP,WLF_TYP,YLD_TYP)

! ...... Read in Production Limit by decomposition type and yield type
      RET_CD=RD$TBL(IUNIT,'%PRODLIM   %',WLF_TYP,MSiodbg,6)
      RET_CD=RD$C1(DUMMY,1,DMSZ)
      RET_CD=RD$R2(PROD_LIMIT,1,1,YLD_TYP,WLF_TYP,YLD_TYP)

! ...... Read in Fraction of Waste in Place by yield type
      RET_CD=RD$TBL(IUNIT,'%FRACWAS   %',YLD_TYP,MSiodbg,6)
      RET_CD=RD$C1(DUMMY,1,DMSZ)
      RET_CD=RD$R1(WIP_RATE,1,YLD_TYP)
      RET_CD=RD$R1(WLF_HRZN,1,YLD_TYP)

! ...... Read in Percent of Total Waste Recycled by Year
      RET_CD=RD$TBL(IUNIT,'%METHPROJ  %',1,MSiodbg,6)
      RET_CD=RD$C1(DUMMY,1,DMSZ)
      RET_CD=RD$R1(LANDFILL_1998,1,1)
      RET_CD=RD$R1(LANDFILL_2005,1,1)
      RET_CD=RD$R1(LANDFILL_2010,1,1)
      RET_CD=RD$R1(LANDFILL_2015,1,1)
      RET_CD=RD$R1(LANDFILL_2020,1,1)
      RET_CD=RD$R1(LANDFILL_2025,1,1)
      RET_CD=RD$R1(LANDFILL_2030,1,1)

! ....... First and Last MSW Historical Years
      RET_CD=RD$TBL(IUNIT,'%HISTYEARS %',1,MSiodbg,6)
      RET_CD=RD$I1(LFGFHYR,1,1)
      RET_CD=RD$I1(LFGLHYR,1,1)
      NUMYEARS = MNUMYR + ( 1989 - LFGFHYR ) + 1

! ...... Read in Methane Recovery and Flare Factors by Year
      RET_CD=RD$TBL(IUNIT,'%RECFLARE  %',NUMYEARS,MSiodbg,6)
      RET_CD=RD$I1(IDUMMY,1,DMSZ)
      RET_CD=RD$R1(RECOVERY_FCTR,1,NUM_YEARS)
      RET_CD=RD$R1(FLARE_FCTR,1,NUM_YEARS)

! ...... Read in GG Report Parameters by Year
      RET_CD=RD$TBL(IUNIT,'%GGREPPAR  %',NUMYEARS,MSiodbg,6)
      RET_CD=RD$I1(IDUMMY,1,DMSZ)
      RET_CD=RD$R1(FRANKLIN_LFILL,1,NUM_YEARS)
      RET_CD=RD$R1(BIOCYCLE_LFILL,1,NUM_YEARS)
      RET_CD=RD$R1(FRANKLIN_RATIO,1,NUM_YEARS)
      RET_CD=RD$R1(UNKNOWN_RATIO,1,NUM_YEARS)

! ...... Read in Historical Population and GDP numbers
      RET_CD=RD$TBL(IUNIT,'%GDPPOP    %',NUMYEARS,MSiodbg,6)
      RET_CD=RD$I1(IDUMMY,1,DMSZ)
      RET_CD=RD$R1(MSWPOP,1,NUM_YEARS)
      RET_CD=RD$R1(MSWGDP,1,NUM_YEARS)


      IUNIT=FILE_MGR('C','MSWDAT            ',.FALSE.)

      return
      end



! ********************************************************************
!
!
!               #     # ####### ####### ######
!               #  #  # #     # #     # #     #
!               #  #  # #     # #     # #     #
!               #  #  # #     # #     # #     #
!               #  #  # #     # #     # #     #
!               #  #  # #     # #     # #     #
!                ## ##  ####### ####### ######
!
!
!
!  The Objective of the WOOD supply model is to provide to the EMM cost
!  and performance characteristics of the following biomass burning
!  technologies:   1. Biomass IGCC.
!
!  The model uses regional supply curves for biomass. The supply curves
!  represent a mix of the following biomass components:
!
!  Standing Forests: 1. hardwood and softwood chips
!                    2. hard and softwood logging residue
!                    3. course/fine mill residue and bark
!                    4. other wood
!  Dedicated biomass
!  crops:            1. poplar
!                    2. willows
!                    3. switch grass (majority)
!
!  The model determines the maximal available capacity for the represented
!  technology(ies) in each region using the maximal quantity of each regional
!  supply curve. The model tracks EMM's cumulative builds in order to from
!  the total available biomass resource (i.e. total available capacity).
!  The consumption from the commercial,industrial (only non-captive markets)
!  and the electricity sectors is used to determine the current price. The
!  fuel price is converted and then added to the variable cost of the re-
!  presented technology.
!
! written by: Michael Kintner-Meyer
! date:       7/8/95
!
! --------------------------------------------------------------------

      Subroutine Wood1
      implicit none

      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'control'
      include 'wrenew'
      include 'wwdcomon'
      include 'wrenio'

! ..... Declaration of local variables
      integer INUNIT,i,j,k,l,f,RN,WDDBG
      character*2  fstock
      logical WDinit

      INTEGER RTOVALUE
      EXTERNAL RTOVALUE

! ..... Assign Debug parameter 0=off, 1=on (writes to OUTPUT FILE)
      WDDBG=1

      WDinit=(CURCALYR .eq. UESTYR .and. CURITR .eq.1)
      if (WDinit) then

!   set wesup r variables equal to restart values for use in relaxing.
         wdsup_qr = WDSUP_Q
         wdsup_pr = WDSUP_P
  write(iorndump,*) ' test rq init ', wdsup_q(47,6,43,3),wdsup_qr(47,6,43,3)
  write(iorndump,*) ' test rp init ', wdsup_p(47,6,43,3),wdsup_pr(47,6,43,3)

         Call Wdinitial               ! Initialize Variables
         Call WDreadin(WDDBG)         ! Read in "wodtech, wodsupp" input
         Call Wdvalass                ! Assign values for all years+NERC
      endif
!
!   Write out supply schedules for some years for testing
!         write out supply schedules

     IF  (CURIYR .GE. 41) THEN
            do f = 1 , mnumfs
              if ((f .eq. 1 ) .or. (f .eq. 3) )  THEN
              fstock = BM_TYP_CD(f)
              write(IORNDUMP,1000) ' test prints of supply before ',curcalyr,fstock
              do i = 1 , MNUMYR + ECP_D_FPH !years
               do j = 1 , NWDSUPQ                    !supply tranches
                  write(IORNDUMP,1001) ' bef ',curcalyr,i,j, (WDSUP_P(j,k,i,f),k=1,16)
                  write(IORNDUMP,1003) ' bef ',curcalyr,i,j, (WDSUP_Q(j,k,i,f),k=1,16)
               enddo !j
             enddo !i
             endif
            enddo !f
!
              write(IORNDUMP,1010) ' test prints of supply _UM before ',curcalyr
              do i = 1 , MNUMYR + ECP_D_FPH !years
                  do j = 1 , NWDSUPQ                    !supply tranches
                    write(IORNDUMP,1011) ' bef ',curcalyr,i,j, (WDSUP_P_UM(j,k,i),k=1,16)
                    write(IORNDUMP,1013) ' bef ',curcalyr,i,j, (WDSUP_Q_UM(j,k,i),k=1,16)
                  enddo !j
              enddo !i
      ENDIF

      call Biomass_Supply             ! Evaluate the supply and avail. cap.

      IF (EXE .EQ. 1) THEN
         call WDSMOOTH                ! Smoothing the Biomass growth
      END IF

!  call polysys here after above filled, if first iteration, polys_sw and poly_year
!  get polysys run time switch value
!
      WDPOLYSW = RTOVALUE('RUNPOLY ',0)
     write(6,*) ' runpoly rtovalue ',wdpolysw
!
      IF ( CURITR .EQ. 1 ) THEN
       IF ( ( WDPOLYSW .NE. 0 ) .AND. (CURIYR .GE. (WDPOLYYR - BASEYR + 1)) ) THEN
          CALL WDPOLY
        ENDIF
      ENDIF
!
!
!   SINCE UM values change each year due to industrial output adjustment
!       overwrite remaining years including fph years with latest values
!
!
!      DO I = 1 , NWDSUPQ
!        DO J = 1,16
!           DO K = CURIYR + 1, MNUMYR + ECP_D_FPH
!               WDSUP_Q(I,J,K,1) = WDSUP_Q(I,J,CURIYR,1)
!               WDSUP_P(I,J,K,1) = WDSUP_P(I,J,CURIYR,1)
!           ENDDO
!        ENDDO
!      ENDDO
!
     IF (( CURIYR .EQ. LASTYR ) .AND. ( CURITR .EQ. MAXITR+1)) THEN
!   SINCE UM values change each year due to industrial output adjustment
!       overwrite remaining years including fph years with latest values
! TEST DOING ONLY IN LASTYR!!!
       DO I = 1 , NWDSUPQ
         DO J = 1,16
            DO K = CURIYR + 1, MNUMYR + ECP_D_FPH
                WDSUP_Q(I,J,K,1) = WDSUP_Q(I,J,CURIYR,1)
                WDSUP_P(I,J,K,1) = WDSUP_P(I,J,CURIYR,1)
            ENDDO
         ENDDO
       ENDDO

! if use polysys restart file is on relax restart values for AG sector
!  TEST RELAXING UM ALSO
 IF ( WDRDWDSUP .NE. 0 ) THEN
  write(iorndump,*) ' test rq bef ', wdsup_q(47,6,43,3),wdsup_qr(47,6,43,3)
  write(iorndump,*) ' test rp bef ', wdsup_p(47,6,43,3),wdsup_pr(47,6,43,3)
       DO I = 1 , NWDSUPQ
         DO J = 1,16
           DO K = 1 , MNUMYR + ECP_D_FPH
!           DO L = 1 , MNUMFS
              WDSUP_P(i,j,k,3) = ( WDSUP_P(i,j,k,3) + WDSUP_PR(i,j,k,3) ) / 2
              WDSUP_Q(i,j,k,3) = ( WDSUP_Q(i,j,k,3) + WDSUP_QR(i,j,k,3) ) / 2
              WDSUP_P(i,j,k,1) = ( WDSUP_P(i,j,k,1) + WDSUP_PR(i,j,k,1) ) / 2
              WDSUP_Q(i,j,k,1) = ( WDSUP_Q(i,j,k,1) + WDSUP_QR(i,j,k,1) ) / 2
!          ENDDO
          ENDDO
        ENDDO
      ENDDO
  write(iorndump,*) ' test rq aft ', wdsup_q(47,6,43,3),wdsup_qr(47,6,43,3)
  write(iorndump,*) ' test rp aft ', wdsup_p(47,6,43,3),wdsup_pr(47,6,43,3)
  ENDIF
!
!  test overwriting wdsup_q_ag variables for restartin file
!
       DO I = 1 , NWDSUPQ
         DO J = 1,16
           DO K = 1 , MNUMYR + ECP_D_FPH
            WDSUP_P_UM(i,j,k) = WDSUP_P(i,j,k,1)
            WDSUP_Q_UM(i,j,k) = WDSUP_Q(i,j,k,1)
            WDSUP_P_FR(i,j,k) = WDSUP_P(i,j,k,2)
            WDSUP_Q_FR(i,j,k) = WDSUP_Q(i,j,k,2)
            WDSUP_P_AG(i,j,k) = WDSUP_P(i,j,k,3)
            WDSUP_Q_AG(i,j,k) = WDSUP_Q(i,j,k,3)
            WDSUP_P_EC(i,j,k) = WDSUP_P(i,j,k,4)
            WDSUP_Q_EC(i,j,k) = WDSUP_Q(i,j,k,4)
          ENDDO
        ENDDO
      ENDDO
!
!  write values for epa and assumptions documents
!
      write(IORNDUMP,1010) ' EPA-ASSUMP print of AG and UM   ',curcalyr
      do f = 1 , mnumfs
       if ((f .eq. 1 ) .or. (f .eq. 3) )  THEN
        fstock = BM_TYP_CD(f)
        do i = 21 , MNUMYR
          do j = 1 , NWDSUPQ                    !supply tranches
            write(IORNDUMP,1011) ' EPA-ASSUMP '//fstock,curcalyr,i+baseyr,j,(WDSUP_P(j,k,i,f),k=1,16)
            write(IORNDUMP,1013) ' EPA-ASSUMP '//fstock,curcalyr,i+baseyr,j,(WDSUP_Q(j,k,i,f),k=1,16)
          enddo !j
        enddo !i
       endif
      enddo

     ENDIF     ! end lastyr lastitr
!
!   Write out supply schedules for some years for testing
!         write out supply schedules

     IF  (CURIYR .GE. 41)  THEN
            do f = 1 , mnumfs
              if ((f .eq. 1 ) .or. (f .eq. 3) )  THEN
              fstock = BM_TYP_CD(f)
              write(IORNDUMP,1000) ' test prints of supply after ',curiyr,fstock
              do i = 1 , MNUMYR + ECP_D_FPH !years
               do j = 1 , NWDSUPQ                    !supply tranches
                  write(IORNDUMP,1001) ' aft ',curcalyr,i,j, (WDSUP_P(j,k,i,f),k=1,16)
                  write(IORNDUMP,1003) ' aft ',curcalyr,i,j, (WDSUP_Q(j,k,i,f),k=1,16)
               enddo !j
             enddo !i
             endif
            enddo !f
      ENDIF

1000  format(//,A,' Year=',I4,' for feedstock ',A2)
1001  format(1x,' Step Prices     ',A,I6,2(I4),16(F10.3))
1003  format(1x,' Step Quantities ',A,I6,2(I4),16(F10.3))
1010  format(//,A,' Year=',I4)
1011  format(1x,A,I6,' Prices     ',2(I5),16(F10.3))
1013  format(1x,A,I6,' Quantities ',2(I5),16(F10.3))

      return
      end



!     Subroutine: Biomass_Supply

      SUBROUTINE Biomass_Supply

      IMPLICIT NONE
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'ecpcntl'
      include 'control'
      include 'wrenew'
      include 'entcntl'
      include 'qblk'
      include 'mpblk'
      include 'wwdcomon'
      include 'wrenio'
      include 'rencntl'
      include 'cdsparms'
      include 'uso2grp'
      include 'indout'
      include 'udatout'
      include 'uecpout'
      include 'uefdout'

!     Declaration of local variables

      REAL*4 SM_QBMRSCL(0:MNUMFS,0:NDREG)                 ! Smoothed Biomass Demand in Residential Sector
      REAL*4 SM_QBMCMCL(0:MNUMFS,0:NDREG)                 ! Smoothed Biomass Demand in Commercial Sector
      REAL*4 SM_QBMINCL(0:MNUMFS,0:NDREG)                 ! Smoothed Biomass Demand in Non-Refinery Industrial Sector
      REAL*4 SM_QBMH2CL(0:MNUMFS,0:NDREG)                 ! Smoothed Biomass Demand in Hydrogen Production Sector
      REAL*4 SM_QBMPWCL(0:MNUMFS,0:NDREG)                 ! Smoothed Biomass Demand in Electric Power Sector
      REAL*4 SM_QBMETCL(0:MNUMFS,0:NDREG)                 ! Smoothed Biomass Demand in Cellulosic Ethanol Demand
      REAL*4 SM_QBMBTCL(0:MNUMFS,0:NDREG)                 ! Smoothed Biomass Demand in Biomass to Liquids Demand

      REAL*8 GROW_RATE

      INTEGER*4 I_YR, N_YR, BASE_YEAR, I_PRINT, I_SUPt, I_STP, CR, I_TST, rnw, TheYear, le_year, CL, NLead, T_YR
      CHARACTER*6 Label_2, Label_3
      CHARACTER*2 SEC_CD, TYP_CD
      INTEGER nr                                          ! NERC Region counter
      INTEGER nc                                          ! Census Region counter
      INTEGER ierror                                      ! Error flag used after interpolating price
      INTEGER i,j,k,l,q                                   ! General counting variables
      INTEGER OLYR                                        ! Online year for biomass
      INTEGER yrpl                                        ! planning year counter

      REAL*8 ADDWD

      REAL wdqcnrs(MNUMCR,1),wdqclrs(NDREG,1)             ! Residential consumption of biomass
      REAL wdqcncm(MNUMCR,1),wdqclcm(NDREG,1)             ! Commercial consumption of biomass
      REAL wdqcnin(MNUMCR,1),wdqclin(NDREG,1)             ! Industrial consumption of biomass

      REAL WDSUPQt(NDREG,MNUMYR+ECP_D_FPH,NWDSUPQ)          ! holds the combined power&eth supply quantities
      REAL WDSUPPt(NDREG,MNUMYR+ECP_D_FPH,NWDSUPP)          ! holds the combined power&eth supply prices

      REAL MaxSupply(MNUMNR)                              ! Stores maximum supply for the emm region
      REAL MaxSupply_cl(NDREG)                            ! Stores maximum supply for the coal region

      REAL Max_Value                                      ! Function that returns maximum biomass supply available for the region

      REAL MWINR1, MWINR2, MWINR3, MWINR4                 ! Holding variables for regional industrial mill waste, by census division
      REAL MWINR1py, MWINR2py, MWINR3py, MWINR4py         ! Holding variables for previous years regional industrial mill waste, by census division

      INTEGER itech                                       ! Biomass technology in WNTECH arrays
      data itech /6/                                      ! Biomass index

!     Logical Switch to indicate the first time through this Subroutine

      LOGICAL        ONCE/.TRUE./

!     Store Map from Census Division to Coal Region in an Array that is Stored in the Restart

      DO i = 1 , NDREG
         DO j = 1 , MNUMCR
            MAP_CD_TO_CL(i,j) = CDTOCL(i,j)
         END DO
      END DO

      SM_BM_RS = 1.0
      SM_BM_CM = 1.0
      SM_BM_IN = 1.0
      SM_BM_H2 = 0.9
      SM_BM_PW = 0.9
      SM_BM_ET = 0.9
      SM_BM_BT = 0.9

!     Share Census Division Residential, Commercial and Industrial Consumption to Coal Regions

      DO nc = 1 , MNUMCR
         wdqcnrs(nc,1) = QBMRS(nc,CURIYR)
         wdqcncm(nc,1) = QBMCM(nc,CURIYR)
         wdqcnin(nc,1) = NoCapIN * QBMIN(nc,CURIYR)
      END DO

      CALL MapCtoN(CDTOCL,NDREG,MNUMCR,wdqcnrs,wdqclrs,1)
      CALL MapCtoN(CDTOCL,NDREG,MNUMCR,wdqcncm,wdqclcm,1)
      CALL MapCtoN(CDTOCL,NDREG,MNUMCR,wdqcnin,wdqclin,1)

!     Then Share Demands by Supply Type (RS, CM, and IN) for all Use Smoothing Constants to Yield Expected Biomass Demand

      IF (CURITR .EQ. 1) THEN
         DO I_SUPt = 1 , MNUMFS
            IF (WDSUP_AVL(I_SUPt) .EQ. 1) THEN
               DO CR = 1 , NDREG
                  QBMRSCL(I_SUPt,CR,CURIYR) = wdqclrs(CR,1) * MP_BM_RS(I_SUPt)
                  QBMCMCL(I_SUPt,CR,CURIYR) = wdqclcm(CR,1) * MP_BM_CM(I_SUPt)
                  QBMINCL(I_SUPt,CR,CURIYR) = wdqclin(CR,1) * MP_BM_IN(I_SUPt)
               END DO
            END IF
         END DO
      ELSE
         DO I_SUPt = 1 , MNUMFS
            IF (WDSUP_AVL(I_SUPt) .EQ. 1) THEN
               DO CR = 1 , NDREG
                  QBMRSCL(I_SUPt,CR,CURIYR) = wdqclrs(CR,1) * MP_BM_RS(I_SUPt)
                  QBMCMCL(I_SUPt,CR,CURIYR) = wdqclcm(CR,1) * MP_BM_CM(I_SUPt)
                  QBMINCL(I_SUPt,CR,CURIYR) = wdqclin(CR,1) * MP_BM_IN(I_SUPt)
               END DO
            END IF
         END DO
      END IF

!     Before Smoothing:
!        Fill in Totals Across Regions, Supply Types, and Sectors
!        Get Prices for Combined Sector Demands by Supply Type and Region
!        Calculate Average Marginal Prices for Combined Sector Demand

      QBMASCL(0,0,CURIYR) = 0.0
      QBMRSCL(0,0,CURIYR) = 0.0
      QBMCMCL(0,0,CURIYR) = 0.0
      QBMINCL(0,0,CURIYR) = 0.0
      QBMH2CL(0,0,CURIYR) = 0.0
      QBMPWCL(0,0,CURIYR) = 0.0
      QBMETCL(0,0,CURIYR) = 0.0
      QBMBTCL(0,0,CURIYR) = 0.0

      DO I_SUPt = 1 , MNUMFS
         IF (WDSUP_AVL(I_SUPt) .EQ. 1) THEN
            DO CR = 1 , NDREG
               QBMASCL(I_SUPt,CR,CURIYR) = 0.0
            END DO
            QBMASCL(I_SUPt,0,CURIYR) = 0.0
            QBMRSCL(I_SUPt,0,CURIYR) = 0.0
            QBMCMCL(I_SUPt,0,CURIYR) = 0.0
            QBMINCL(I_SUPt,0,CURIYR) = 0.0
            QBMH2CL(I_SUPt,0,CURIYR) = 0.0
            QBMPWCL(I_SUPt,0,CURIYR) = 0.0
            QBMETCL(I_SUPt,0,CURIYR) = 0.0
            QBMBTCL(I_SUPt,0,CURIYR) = 0.0
            DO CR = 1 , NDREG

               IF (MP_BM_RS(I_SUPt) .GT. 0.0) THEN
                  QBMRSCL(I_SUPt,0,CURIYR) = QBMRSCL(I_SUPt,0,CURIYR) + QBMRSCL(I_SUPt,CR,CURIYR)
                  QBMRSCL(0,0,CURIYR) = QBMRSCL(0,0,CURIYR) + QBMRSCL(I_SUPt,CR,CURIYR)
                  QBMASCL(I_SUPt,CR,CURIYR) = QBMASCL(I_SUPt,CR,CURIYR) + QBMRSCL(I_SUPt,CR,CURIYR)
               END IF

               IF (MP_BM_CM(I_SUPt) .GT. 0.0) THEN
                  QBMCMCL(I_SUPt,0,CURIYR) = QBMCMCL(I_SUPt,0,CURIYR) + QBMCMCL(I_SUPt,CR,CURIYR)
                  QBMCMCL(0,0,CURIYR) = QBMCMCL(0,0,CURIYR) + QBMCMCL(I_SUPt,CR,CURIYR)
                  QBMASCL(I_SUPt,CR,CURIYR) = QBMASCL(I_SUPt,CR,CURIYR) + QBMCMCL(I_SUPt,CR,CURIYR)
               END IF

               IF (MP_BM_IN(I_SUPt) .GT. 0.0) THEN
                  QBMINCL(I_SUPt,0,CURIYR) = QBMINCL(I_SUPt,0,CURIYR) + QBMINCL(I_SUPt,CR,CURIYR)
                  QBMINCL(0,0,CURIYR) = QBMINCL(0,0,CURIYR) + QBMINCL(I_SUPt,CR,CURIYR)
                  QBMASCL(I_SUPt,CR,CURIYR) = QBMASCL(I_SUPt,CR,CURIYR) + QBMINCL(I_SUPt,CR,CURIYR)
               END IF

               IF (MP_BM_H2(I_SUPt) .GT. 0.0) THEN
                  QBMH2CL(I_SUPt,0,CURIYR) = QBMH2CL(I_SUPt,0,CURIYR) + QBMH2CL(I_SUPt,CR,CURIYR)
                  QBMH2CL(0,0,CURIYR) = QBMH2CL(0,0,CURIYR) + QBMH2CL(I_SUPt,CR,CURIYR)
                  QBMASCL(I_SUPt,CR,CURIYR) = QBMASCL(I_SUPt,CR,CURIYR) + QBMH2CL(I_SUPt,CR,CURIYR)
               END IF

               IF (MP_BM_PW(I_SUPt) .GT. 0.0) THEN
                  QBMPWCL(I_SUPt,0,CURIYR) = QBMPWCL(I_SUPt,0,CURIYR) + QBMPWCL(I_SUPt,CR,CURIYR)
                  QBMPWCL(0,0,CURIYR) = QBMPWCL(0,0,CURIYR) + QBMPWCL(I_SUPt,CR,CURIYR)
                  QBMASCL(I_SUPt,CR,CURIYR) = QBMASCL(I_SUPt,CR,CURIYR) + QBMPWCL(I_SUPt,CR,CURIYR)
               END IF

               IF (MP_BM_ET(I_SUPt) .GT. 0.0) THEN
                  QBMETCL(I_SUPt,0,CURIYR) = QBMETCL(I_SUPt,0,CURIYR) + QBMETCL(I_SUPt,CR,CURIYR)
                  QBMETCL(0,0,CURIYR) = QBMETCL(0,0,CURIYR) + QBMETCL(I_SUPt,CR,CURIYR)
                  QBMASCL(I_SUPt,CR,CURIYR) = QBMASCL(I_SUPt,CR,CURIYR) + QBMETCL(I_SUPt,CR,CURIYR)
               END IF

               IF (MP_BM_BT(I_SUPt) .GT. 0.0) THEN
                  QBMBTCL(I_SUPt,0,CURIYR) = QBMBTCL(I_SUPt,0,CURIYR) + QBMBTCL(I_SUPt,CR,CURIYR)
                  QBMBTCL(0,0,CURIYR) = QBMBTCL(0,0,CURIYR) + QBMBTCL(I_SUPt,CR,CURIYR)
                  QBMASCL(I_SUPt,CR,CURIYR) = QBMASCL(I_SUPt,CR,CURIYR) + QBMBTCL(I_SUPt,CR,CURIYR)
               END IF

               QBMASCL(I_SUPt,0,CURIYR) = QBMASCL(I_SUPt,0,CURIYR) + QBMASCL(I_SUPt,CR,CURIYR)
               QBMASCL(0,0,CURIYR) = QBMASCL(0,0,CURIYR) + QBMASCL(I_SUPt,CR,CURIYR)
            END DO
         END IF
      END DO

      DO CR = 1 , NDREG
         QBMASCL(0,CR,CURIYR) = 0.0
         QBMRSCL(0,CR,CURIYR) = 0.0
         QBMCMCL(0,CR,CURIYR) = 0.0
         QBMINCL(0,CR,CURIYR) = 0.0
         QBMH2CL(0,CR,CURIYR) = 0.0
         QBMPWCL(0,CR,CURIYR) = 0.0
         QBMETCL(0,CR,CURIYR) = 0.0
         QBMBTCL(0,CR,CURIYR) = 0.0
         DO I_SUPt = 1 , MNUMFS
            IF (WDSUP_AVL(I_SUPt) .EQ. 1) THEN

               IF (MP_BM_RS(I_SUPt) .GT. 0.0) THEN
                  QBMRSCL(0,CR,CURIYR) = QBMRSCL(0,CR,CURIYR) + QBMRSCL(I_SUPt,CR,CURIYR)
               END IF

               IF (MP_BM_CM(I_SUPt) .GT. 0.0) THEN
                  QBMCMCL(0,CR,CURIYR) = QBMCMCL(0,CR,CURIYR) + QBMCMCL(I_SUPt,CR,CURIYR)
               END IF

               IF (MP_BM_IN(I_SUPt) .GT. 0.0) THEN
                  QBMINCL(0,CR,CURIYR) = QBMINCL(0,CR,CURIYR) + QBMINCL(I_SUPt,CR,CURIYR)
               END IF

               IF (MP_BM_H2(I_SUPt) .GT. 0.0) THEN
                  QBMH2CL(0,CR,CURIYR) = QBMH2CL(0,CR,CURIYR) + QBMH2CL(I_SUPt,CR,CURIYR)
               END IF

               IF (MP_BM_PW(I_SUPt) .GT. 0.0) THEN
                  QBMPWCL(0,CR,CURIYR) = QBMPWCL(0,CR,CURIYR) + QBMPWCL(I_SUPt,CR,CURIYR)
               END IF

               IF (MP_BM_ET(I_SUPt) .GT. 0.0) THEN
                  QBMETCL(0,CR,CURIYR) = QBMETCL(0,CR,CURIYR) + QBMETCL(I_SUPt,CR,CURIYR)
               END IF

               IF (MP_BM_BT(I_SUPt) .GT. 0.0) THEN
                  QBMBTCL(0,CR,CURIYR) = QBMBTCL(0,CR,CURIYR) + QBMBTCL(I_SUPt,CR,CURIYR)
               END IF

               QBMASCL(0,CR,CURIYR) = QBMASCL(0,CR,CURIYR) + QBMASCL(I_SUPt,CR,CURIYR)
            END IF
         END DO
      END DO

      PBMASCL(0,0,CURIYR) =  0.0
      PBMRSCL(0,0,CURIYR) =  0.0
      PBMCMCL(0,0,CURIYR) =  0.0
      PBMINCL(0,0,CURIYR) =  0.0
      PBMH2CL(0,0,CURIYR) =  0.0
      PBMPWCL(0,0,CURIYR) =  0.0
      PBMETCL(0,0,CURIYR) =  0.0
      PBMBTCL(0,0,CURIYR) =  0.0

      DO I_SUPt = 1 , MNUMFS
         IF (WDSUP_AVL(I_SUPt) .EQ. 1) THEN

            PBMASCL(I_SUPt,0,CURIYR) =  0.0
            PBMRSCL(I_SUPt,0,CURIYR) =  0.0
            PBMCMCL(I_SUPt,0,CURIYR) =  0.0
            PBMINCL(I_SUPt,0,CURIYR) =  0.0
            PBMH2CL(I_SUPt,0,CURIYR) =  0.0
            PBMPWCL(I_SUPt,0,CURIYR) =  0.0
            PBMETCL(I_SUPt,0,CURIYR) =  0.0
            PBMBTCL(I_SUPt,0,CURIYR) =  0.0


!!   MOVE THIS BELOW WITH q to get regional prices
!            DO I_STP = 1 , NM_BM_SUP_STP
!               WDSUPPt(CURIYR,I_STP) = WDSUP_P(I_STP,NDREG,CURIYR,I_SUPt)
!            END DO

            DO CR = 1 , NDREG

               DO I_STP = 1 , NM_BM_SUP_STP
                  if ((I_STP .gt. 1).and.(BM_TYP_CD(I_SUPt) .eq. 'UM').and.(CURITR .eq. 1)) then
                        MWINR1=mwin(1,curiyr)
                        mwinr2=mwin(2,curiyr)
                        mwinr3=mwin(3,curiyr)
                        mwinr4=mwin(4,curiyr)


              write(iorndump,*) ' curcalyr uestyr ',curcalyr,uestyr
                     iF (CURCALYR .EQ. UESTYR) THEN
                   write(iorndump,*) ' inside min 0 '
                        MWINR1py=0.0
                        mwinr2py=0.0
                        mwinr3py=0.0
                        mwinr4py=0.0
                     ELSE
                        MWINR1py=mwin(1,curiyr-1)
                        mwinr2py=mwin(2,curiyr-1)
                        mwinr3py=mwin(3,curiyr-1)
                        mwinr4py=mwin(4,curiyr-1)
                     ENDIF

                       WRITE(IORNDUMP,5057) CURIRUN,CURIYR+1989,CURITR,MWIN(1, CURIYR),MWIN(2, CURIYR), MWIN(3,CURIYR), MWIN(4, CURIYR)
                       WRITE(IORNDUMP,5061) CURIRUN,CURIYR+1989,CURITR,WDSUP_Q(20,6, CURIYR, I_SUPt),WDSUP_Q(20,7, CURIYR, I_SUPt), WDSUP_Q(20,8, CURIYR, I_SUPt), WDSUP_Q(20,9, CURIYR, I_SUPt)
5057      FORMAT(1X,"wodsup_q by run, year, iteration, and coal region at step 20beforeb2",3(":",I4),4(":",F12.3))
                     Select Case(CR)
                     case(1)
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr1 ,"bf"
                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) + MAX(0.,(0.5*0.5*MWINr1)-(0.5*0.5*MWINR1py))
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr1
                     case(2)
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr1,"bf"
                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) + MAX(0.,(0.5*0.5*MWINr1)-(0.5*0.5*MWINr1py))
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr1
                     case(3)
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr3,"bf"
                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) + MAX(0.,(0.5*0.167*MWINr3)-(0.5*0.167*MWINr3py))
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr3
                     case(4)
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr3,"bf"
                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) + MAX(0.,(0.5*0.167*MWINr3)-(0.5*0.167*MWINr3py))
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr3
                     case(5)
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr3,"bf"
                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) + MAX(0.,(0.5*0.167*MWINr3)-(0.5*0.167*MWINr3py))
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr3
                     case(6)
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr2,"bf"
                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) + MAX(0.,(0.5*0.25*MWINr2)-(0.5*0.25*MWINr2py))
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr2
                     case(7)
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr2,"bf"
                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) + MAX(0.,(0.5*0.25*MWINr2)-(0.5*0.25*MWINr2py))
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr2
                     case(8)
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr3,"bf"
                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) + MAX(0.,(0.5*0.167*MWINr3)-(0.5*0.167*MWINr3py))
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr3
                     case(9)
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr3,"bf"
                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) + MAX(0.,(0.5*0.167*MWINr3)-(0.5*0.167*MWINr3py))
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr3
                     case(10)
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr4,"bf"
                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) + MAX(0.,(0.5*0.25*MWINr2)-(0.5*0.25*MWINr2py))
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr4
                     case(11)
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr2,"bf"
                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) + MAX(0.,(0.5*0.25*MWINr2)-(0.5*0.25*MWINr2py))
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr2
                     case(12)
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr3,"bf"
                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) + MAX(0.,(0.5*0.167*MWINr3)-(0.5*0.167*MWINr3py))
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr3
                     case(13)
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr4,"bf"
                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) + MAX(0.,(0.5*0.25*MWINr4)-(0.5*0.25*MWINr4py))
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr4
                     case(14)
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr4,"bf"
                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) + MAX(0.,(0.5*0.25*MWINr4)-(0.5*0.25*MWINr4py))
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr4
                     case(15)
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr4,"bf"
                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) + MAX(0.,(0.5*0.25*MWINr4)-(0.5*0.25*MWINr4py))
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr4
                     case(16)
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr4,"bf"
                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) + MAX(0.,(0.5*0.25*MWINr4)-(0.5*0.25*MWINr4py))
                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr4
                     case default
                        WRITE (IORNDUMP,5064) CR, CURIYR, I_SUPt, I_STP
                     end select
                      ! WRITE(IORNDUMP,5057) CURIRUN,CURIYR+1989,CURITR,MWIN(1, CURIYR),MWIN(2, CURIYR), MWIN(3,CURIYR), MWIN(4, CURIYR)
                        WRITE(IORNDUMP,5059) CURIRUN,CURIYR+1989,CURITR,WDSUP_Q(20,6, CURIYR, I_SUPt),WDSUP_Q(20,7, CURIYR, I_SUPt), WDSUP_Q(20,8, CURIYR, I_SUPt), WDSUP_Q(20,9, CURIYR, I_SUPt)
                  5059      FORMAT(1X,"wodsup_q by run, year, iteration, and coal region at step 20after",3(":",I4),4(":",F12.3))
                endif
!!
!! move price to here since by regions

                  WDSUPQt(CR,CURIYR,I_STP) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt)
                  WDSUPPt(CR,CURIYR,I_STP) = WDSUP_P(I_STP,CR,CURIYR,I_SUPt)
               END DO

               CALL GetPrice(WDSUPQt, WDSUPPt, QBMASCL(I_SUPt,CR,CURIYR), PBMASCL(I_SUPt,CR,CURIYR), ierror, CR, CURIYR)

               PBMRSCL(I_SUPt,CR,CURIYR) = PBMASCL(I_SUPt,CR,CURIYR)
               PBMCMCL(I_SUPt,CR,CURIYR) = PBMASCL(I_SUPt,CR,CURIYR)
               PBMINCL(I_SUPt,CR,CURIYR) = PBMASCL(I_SUPt,CR,CURIYR)

               PBMASCL(0,0,CURIYR) = PBMASCL(0,0,CURIYR) + PBMASCL(I_SUPt,CR,CURIYR) * QBMASCL(I_SUPt,CR,CURIYR)
               PBMRSCL(0,0,CURIYR) = PBMRSCL(0,0,CURIYR) + PBMRSCL(I_SUPt,CR,CURIYR) * QBMRSCL(I_SUPt,CR,CURIYR)
               PBMCMCL(0,0,CURIYR) = PBMCMCL(0,0,CURIYR) + PBMCMCL(I_SUPt,CR,CURIYR) * QBMCMCL(I_SUPt,CR,CURIYR)
               PBMINCL(0,0,CURIYR) = PBMINCL(0,0,CURIYR) + PBMINCL(I_SUPt,CR,CURIYR) * QBMINCL(I_SUPt,CR,CURIYR)
               PBMH2CL(0,0,CURIYR) = PBMH2CL(0,0,CURIYR) + PBMH2CL(I_SUPt,CR,CURIYR) * QBMH2CL(I_SUPt,CR,CURIYR)
               PBMPWCL(0,0,CURIYR) = PBMPWCL(0,0,CURIYR) + PBMPWCL(I_SUPt,CR,CURIYR) * QBMPWCL(I_SUPt,CR,CURIYR)
               PBMETCL(0,0,CURIYR) = PBMETCL(0,0,CURIYR) + PBMETCL(I_SUPt,CR,CURIYR) * QBMETCL(I_SUPt,CR,CURIYR)
               PBMBTCL(0,0,CURIYR) = PBMBTCL(0,0,CURIYR) + PBMBTCL(I_SUPt,CR,CURIYR) * QBMBTCL(I_SUPt,CR,CURIYR)

               PBMASCL(I_SUPt,0,CURIYR) = PBMASCL(I_SUPt,0,CURIYR) + PBMASCL(I_SUPt,CR,CURIYR) * QBMASCL(I_SUPt,CR,CURIYR)
               PBMRSCL(I_SUPt,0,CURIYR) = PBMRSCL(I_SUPt,0,CURIYR) + PBMRSCL(I_SUPt,CR,CURIYR) * QBMRSCL(I_SUPt,CR,CURIYR)
               PBMCMCL(I_SUPt,0,CURIYR) = PBMCMCL(I_SUPt,0,CURIYR) + PBMCMCL(I_SUPt,CR,CURIYR) * QBMCMCL(I_SUPt,CR,CURIYR)
               PBMINCL(I_SUPt,0,CURIYR) = PBMINCL(I_SUPt,0,CURIYR) + PBMINCL(I_SUPt,CR,CURIYR) * QBMINCL(I_SUPt,CR,CURIYR)
               PBMH2CL(I_SUPt,0,CURIYR) = PBMH2CL(I_SUPt,0,CURIYR) + PBMH2CL(I_SUPt,CR,CURIYR) * QBMH2CL(I_SUPt,CR,CURIYR)
               PBMPWCL(I_SUPt,0,CURIYR) = PBMPWCL(I_SUPt,0,CURIYR) + PBMPWCL(I_SUPt,CR,CURIYR) * QBMPWCL(I_SUPt,CR,CURIYR)
               PBMETCL(I_SUPt,0,CURIYR) = PBMETCL(I_SUPt,0,CURIYR) + PBMETCL(I_SUPt,CR,CURIYR) * QBMETCL(I_SUPt,CR,CURIYR)
               PBMBTCL(I_SUPt,0,CURIYR) = PBMBTCL(I_SUPt,0,CURIYR) + PBMBTCL(I_SUPt,CR,CURIYR) * QBMBTCL(I_SUPt,CR,CURIYR)
            END DO
         END IF
      END DO

      DO CR = 1 , NDREG
         PBMASCL(0,CR,CURIYR) =  0.0
         PBMRSCL(0,CR,CURIYR) =  0.0
         PBMCMCL(0,CR,CURIYR) =  0.0
         PBMINCL(0,CR,CURIYR) =  0.0

         DO I_SUPt = 1 , MNUMFS
            IF (WDSUP_AVL(I_SUPt) .EQ. 1) THEN
               PBMASCL(0,CR,CURIYR) = PBMASCL(0,CR,CURIYR) + PBMASCL(I_SUPt,CR,CURIYR) * QBMASCL(I_SUPt,CR,CURIYR)
               PBMRSCL(0,CR,CURIYR) = PBMRSCL(0,CR,CURIYR) + PBMRSCL(I_SUPt,CR,CURIYR) * QBMRSCL(I_SUPt,CR,CURIYR)
               PBMCMCL(0,CR,CURIYR) = PBMCMCL(0,CR,CURIYR) + PBMCMCL(I_SUPt,CR,CURIYR) * QBMCMCL(I_SUPt,CR,CURIYR)
               PBMINCL(0,CR,CURIYR) = PBMINCL(0,CR,CURIYR) + PBMINCL(I_SUPt,CR,CURIYR) * QBMINCL(I_SUPt,CR,CURIYR)
            END IF
         END DO
      END DO

      IF (QBMASCL(0,0,CURIYR) .GT. 0.0) THEN
         PBMASCL(0,0,CURIYR) = PBMASCL(0,0,CURIYR) / QBMASCL(0,0,CURIYR)
      ELSE
         PBMASCL(0,0,CURIYR) = 0.001
      END IF

      IF (QBMRSCL(0,0,CURIYR) .GT. 0.0) THEN
         PBMRSCL(0,0,CURIYR) = PBMRSCL(0,0,CURIYR) / QBMRSCL(0,0,CURIYR)
      ELSE
         PBMRSCL(0,0,CURIYR) = PBMASCL(0,0,CURIYR)
      END IF

      IF (QBMCMCL(0,0,CURIYR) .GT. 0.0) THEN
         PBMCMCL(0,0,CURIYR) = PBMCMCL(0,0,CURIYR) / QBMCMCL(0,0,CURIYR)
      ELSE
         PBMCMCL(0,0,CURIYR) = PBMASCL(0,0,CURIYR)
      END IF

      IF (QBMINCL(0,0,CURIYR) .GT. 0.0) THEN
         PBMINCL(0,0,CURIYR) = PBMINCL(0,0,CURIYR) / QBMINCL(0,0,CURIYR)
      ELSE
         PBMINCL(0,0,CURIYR) = PBMASCL(0,0,CURIYR)
      END IF

      IF (QBMH2CL(0,0,CURIYR) .GT. 0.0) THEN
         PBMH2CL(0,0,CURIYR) = PBMH2CL(0,0,CURIYR) / QBMH2CL(0,0,CURIYR)
      ELSE
         PBMH2CL(0,0,CURIYR) = PBMASCL(0,0,CURIYR)
      END IF

      IF (QBMPWCL(0,0,CURIYR) .GT. 0.0) THEN
         PBMPWCL(0,0,CURIYR) = PBMPWCL(0,0,CURIYR) / QBMPWCL(0,0,CURIYR)
      ELSE
         PBMPWCL(0,0,CURIYR) = PBMASCL(0,0,CURIYR)
      END IF

      IF (QBMETCL(0,0,CURIYR) .GT. 0.0) THEN
         PBMETCL(0,0,CURIYR) = PBMETCL(0,0,CURIYR) / QBMETCL(0,0,CURIYR)
      ELSE
         PBMETCL(0,0,CURIYR) = PBMASCL(0,0,CURIYR)
      END IF

      IF (QBMBTCL(0,0,CURIYR) .GT. 0.0) THEN
         PBMBTCL(0,0,CURIYR) = PBMBTCL(0,0,CURIYR) / QBMBTCL(0,0,CURIYR)
      ELSE
         PBMBTCL(0,0,CURIYR) = PBMASCL(0,0,CURIYR)
      END IF

      DO I_SUPt = 1 , MNUMFS
         IF (WDSUP_AVL(I_SUPt) .EQ. 1) THEN

            IF (QBMASCL(I_SUPt,0,CURIYR) .GT. 0.0) THEN
               PBMASCL(I_SUPt,0,CURIYR) = PBMASCL(I_SUPt,0,CURIYR) / QBMASCL(I_SUPt,0,CURIYR)
            ELSE
               PBMASCL(I_SUPt,0,CURIYR) = PBMASCL(0,0,CURIYR)
            END IF

            IF (QBMRSCL(I_SUPt,0,CURIYR) .GT. 0.0) THEN
               PBMRSCL(I_SUPt,0,CURIYR) = PBMRSCL(I_SUPt,0,CURIYR) / QBMRSCL(I_SUPt,0,CURIYR)
            ELSE
               PBMRSCL(I_SUPt,0,CURIYR) = PBMASCL(I_SUPt,0,CURIYR)
            END IF

            IF (QBMCMCL(I_SUPt,0,CURIYR) .GT. 0.0) THEN
               PBMCMCL(I_SUPt,0,CURIYR) = PBMCMCL(I_SUPt,0,CURIYR) / QBMCMCL(I_SUPt,0,CURIYR)
            ELSE
               PBMCMCL(I_SUPt,0,CURIYR) = PBMASCL(I_SUPt,0,CURIYR)
            END IF

            IF (QBMINCL(I_SUPt,0,CURIYR) .GT. 0.0) THEN
               PBMINCL(I_SUPt,0,CURIYR) = PBMINCL(I_SUPt,0,CURIYR) / QBMINCL(I_SUPt,0,CURIYR)
            ELSE
               PBMINCL(I_SUPt,0,CURIYR) = PBMASCL(I_SUPt,0,CURIYR)
            END IF

            IF (QBMH2CL(I_SUPt,0,CURIYR) .GT. 0.0) THEN
               PBMH2CL(I_SUPt,0,CURIYR) = PBMH2CL(I_SUPt,0,CURIYR) / QBMH2CL(I_SUPt,0,CURIYR)
            ELSE
               PBMH2CL(I_SUPt,0,CURIYR) = PBMASCL(I_SUPt,0,CURIYR)
            END IF

            IF (QBMPWCL(I_SUPt,0,CURIYR) .GT. 0.0) THEN
               PBMPWCL(I_SUPt,0,CURIYR) = PBMPWCL(I_SUPt,0,CURIYR) / QBMPWCL(I_SUPt,0,CURIYR)
            ELSE
               PBMPWCL(I_SUPt,0,CURIYR) = PBMASCL(I_SUPt,0,CURIYR)
            END IF

            IF (QBMETCL(I_SUPt,0,CURIYR) .GT. 0.0) THEN
               PBMETCL(I_SUPt,0,CURIYR) = PBMETCL(I_SUPt,0,CURIYR) / QBMETCL(I_SUPt,0,CURIYR)
            ELSE
               PBMETCL(I_SUPt,0,CURIYR) = PBMASCL(I_SUPt,0,CURIYR)
            END IF

            IF (QBMBTCL(I_SUPt,0,CURIYR) .GT. 0.0) THEN
               PBMBTCL(I_SUPt,0,CURIYR) = PBMBTCL(I_SUPt,0,CURIYR) / QBMBTCL(I_SUPt,0,CURIYR)
            ELSE
               PBMBTCL(I_SUPt,0,CURIYR) = PBMASCL(I_SUPt,0,CURIYR)
            END IF
         END IF
      END DO

      DO CR = 1 , NDREG
         IF (QBMASCL(0,CR,CURIYR) .GT. 0.0) THEN
            PBMASCL(0,CR,CURIYR) = PBMASCL(0,CR,CURIYR) / QBMASCL(0,CR,CURIYR)
         ELSE
            PBMASCL(0,CR,CURIYR) = PBMASCL(0,0,CURIYR)
         END IF

         IF (QBMRSCL(0,CR,CURIYR) .GT. 0.0) THEN
            PBMRSCL(0,CR,CURIYR) = PBMRSCL(0,CR,CURIYR) / QBMRSCL(0,CR,CURIYR)
         ELSE
            PBMRSCL(0,CR,CURIYR) = PBMASCL(0,CR,CURIYR)
         END IF

         IF (QBMCMCL(0,CR,CURIYR) .GT. 0.0) THEN
            PBMCMCL(0,CR,CURIYR) = PBMCMCL(0,CR,CURIYR) / QBMCMCL(0,CR,CURIYR)
         ELSE
            PBMCMCL(0,CR,CURIYR) = PBMASCL(0,CR,CURIYR)
         END IF

         IF (QBMINCL(0,CR,CURIYR) .GT. 0.0) THEN
            PBMINCL(0,CR,CURIYR) = PBMINCL(0,CR,CURIYR) / QBMINCL(0,CR,CURIYR)
         ELSE
            PBMINCL(0,CR,CURIYR) = PBMASCL(0,CR,CURIYR)
         END IF

      END DO

!     For Now Output Price and Qunatity Info to the NOHUP.OUT File

      I_PRINT = IORNDUMP
      Label_2 = "BEFORE"

 5555 FORMAT(1X,"BM_PQ_INFO",2(":",A6),":",A2,5(":",I4),8(":",F15.3))

      DO CR = 0 , NDREG
         I_TST = 1
         DO I_SUPt = 0 , MNUMFS
            IF (I_SUPt .GT. 0) I_TST = WDSUP_AVL(I_SUPt)
            IF (I_TST .EQ. 1) THEN
               IF (I_SUPt .EQ. 0) THEN
                  SEC_CD = "TL"
               ELSE
                  SEC_CD = BM_TYP_CD(I_SUPt)
               END IF

               LABEL_3 = "DEMAND"
               WRITE(I_PRINT,5555) Label_2, Label_3, SEC_CD, CURIRUN, CURIYR+1989, CURITR, CR, I_SUPt, &
                  QBMASCL(I_SUPt,CR,CURIYR), QBMBTCL(I_SUPt,CR,CURIYR), QBMETCL(I_SUPt,CR,CURIYR), QBMPWCL(I_SUPt,CR,CURIYR),  &
                  QBMH2CL(I_SUPt,CR,CURIYR), QBMINCL(I_SUPt,CR,CURIYR), QBMCMCL(I_SUPt,CR,CURIYR), QBMRSCL(I_SUPt,CR,CURIYR)

               LABEL_3 = "PRICE "
               WRITE(I_PRINT,5555) Label_2, Label_3, SEC_CD, CURIRUN, CURIYR+1989, CURITR, CR, I_SUPt, &
                  PBMASCL(I_SUPt,CR,CURIYR), PBMBTCL(I_SUPt,CR,CURIYR), PBMETCL(I_SUPt,CR,CURIYR), PBMPWCL(I_SUPt,CR,CURIYR),  &
                  PBMH2CL(I_SUPt,CR,CURIYR), PBMINCL(I_SUPt,CR,CURIYR), PBMCMCL(I_SUPt,CR,CURIYR), PBMRSCL(I_SUPt,CR,CURIYR)
            END IF
         END DO
      END DO

!     For All BiomRSs Demand Sectors use the Smoothing Constants to Yield Expected BiomRSs Demand

      IF (CURITR .GT. 1) THEN
         DO I_SUPt = 1 , MNUMFS
            IF (WDSUP_AVL(I_SUPt) .EQ. 1) THEN
               DO CR = 1 , NDREG
                  QBMRSCL(I_SUPt,CR,CURIYR) = (1.0 - SM_BM_RS) * SM_QBMRSCL(I_SUPt,CR) + SM_BM_RS * QBMRSCL(I_SUPt,CR,CURIYR)
                  QBMCMCL(I_SUPt,CR,CURIYR) = (1.0 - SM_BM_CM) * SM_QBMCMCL(I_SUPt,CR) + SM_BM_CM * QBMCMCL(I_SUPt,CR,CURIYR)
                  QBMINCL(I_SUPt,CR,CURIYR) = (1.0 - SM_BM_IN) * SM_QBMINCL(I_SUPt,CR) + SM_BM_IN * QBMINCL(I_SUPt,CR,CURIYR)
                  QBMH2CL(I_SUPt,CR,CURIYR) = (1.0 - SM_BM_H2) * SM_QBMH2CL(I_SUPt,CR) + SM_BM_H2 * QBMH2CL(I_SUPt,CR,CURIYR)
                  QBMPWCL(I_SUPt,CR,CURIYR) = (1.0 - SM_BM_PW) * SM_QBMPWCL(I_SUPt,CR) + SM_BM_PW * QBMPWCL(I_SUPt,CR,CURIYR)
                  QBMETCL(I_SUPt,CR,CURIYR) = (1.0 - SM_BM_ET) * SM_QBMETCL(I_SUPt,CR) + SM_BM_ET * QBMETCL(I_SUPt,CR,CURIYR)
                  QBMBTCL(I_SUPt,CR,CURIYR) = (1.0 - SM_BM_BT) * SM_QBMBTCL(I_SUPt,CR) + SM_BM_BT * QBMBTCL(I_SUPt,CR,CURIYR)
               END DO
            END IF
         END DO
      ELSE
         SM_QBMRSCL = 0.0
         SM_QBMCMCL = 0.0
         SM_QBMINCL = 0.0
         SM_QBMH2CL = 0.0
         SM_QBMPWCL = 0.0
         SM_QBMETCL = 0.0
         SM_QBMBTCL = 0.0
      END IF

      DO I_SUPt = 1 , MNUMFS
         IF (WDSUP_AVL(I_SUPt) .EQ. 1) THEN
            DO CR = 1 , NDREG
               SM_QBMRSCL(I_SUPt,CR) = QBMRSCL(I_SUPt,CR,CURIYR)
               SM_QBMCMCL(I_SUPt,CR) = QBMCMCL(I_SUPt,CR,CURIYR)
               SM_QBMINCL(I_SUPt,CR) = QBMINCL(I_SUPt,CR,CURIYR)
               SM_QBMH2CL(I_SUPt,CR) = QBMH2CL(I_SUPt,CR,CURIYR)
               SM_QBMPWCL(I_SUPt,CR) = QBMPWCL(I_SUPt,CR,CURIYR)
               SM_QBMETCL(I_SUPt,CR) = QBMETCL(I_SUPt,CR,CURIYR)
               SM_QBMBTCL(I_SUPt,CR) = QBMBTCL(I_SUPt,CR,CURIYR)
            END DO
         END IF
      END DO

!     After Smoothing:
!        Fill in Totals Across Regions, Supply Types, and Sectors
!        Get Prices for Combined Sector Demands by Supply Type and Region
!        Calculate Average Marginal Prices for Combined Sector Demand

      QBMASCL(0,0,CURIYR) = 0.0
      QBMRSCL(0,0,CURIYR) = 0.0
      QBMCMCL(0,0,CURIYR) = 0.0
      QBMINCL(0,0,CURIYR) = 0.0
      QBMH2CL(0,0,CURIYR) = 0.0
      QBMPWCL(0,0,CURIYR) = 0.0
      QBMETCL(0,0,CURIYR) = 0.0
      QBMBTCL(0,0,CURIYR) = 0.0

      DO I_SUPt = 1 , MNUMFS
         IF (WDSUP_AVL(I_SUPt) .EQ. 1) THEN
            DO CR = 1 , NDREG
               QBMASCL(I_SUPt,CR,CURIYR) = 0.0
            END DO
            QBMASCL(I_SUPt,0,CURIYR) = 0.0
            QBMRSCL(I_SUPt,0,CURIYR) = 0.0
            QBMCMCL(I_SUPt,0,CURIYR) = 0.0
            QBMINCL(I_SUPt,0,CURIYR) = 0.0
            QBMH2CL(I_SUPt,0,CURIYR) = 0.0
            QBMPWCL(I_SUPt,0,CURIYR) = 0.0
            QBMETCL(I_SUPt,0,CURIYR) = 0.0
            QBMBTCL(I_SUPt,0,CURIYR) = 0.0
            DO CR = 1 , NDREG

               IF (MP_BM_RS(I_SUPt) .GT. 0.0) THEN
                  QBMRSCL(I_SUPt,0,CURIYR) = QBMRSCL(I_SUPt,0,CURIYR) + QBMRSCL(I_SUPt,CR,CURIYR)
                  QBMRSCL(0,0,CURIYR) = QBMRSCL(0,0,CURIYR) + QBMRSCL(I_SUPt,CR,CURIYR)
                  QBMASCL(I_SUPt,CR,CURIYR) = QBMASCL(I_SUPt,CR,CURIYR) + QBMRSCL(I_SUPt,CR,CURIYR)
               END IF

               IF (MP_BM_CM(I_SUPt) .GT. 0.0) THEN
                  QBMCMCL(I_SUPt,0,CURIYR) = QBMCMCL(I_SUPt,0,CURIYR) + QBMCMCL(I_SUPt,CR,CURIYR)
                  QBMCMCL(0,0,CURIYR) = QBMCMCL(0,0,CURIYR) + QBMCMCL(I_SUPt,CR,CURIYR)
                  QBMASCL(I_SUPt,CR,CURIYR) = QBMASCL(I_SUPt,CR,CURIYR) + QBMCMCL(I_SUPt,CR,CURIYR)
               END IF

               IF (MP_BM_IN(I_SUPt) .GT. 0.0) THEN
                  QBMINCL(I_SUPt,0,CURIYR) = QBMINCL(I_SUPt,0,CURIYR) + QBMINCL(I_SUPt,CR,CURIYR)
                  QBMINCL(0,0,CURIYR) = QBMINCL(0,0,CURIYR) + QBMINCL(I_SUPt,CR,CURIYR)
                  QBMASCL(I_SUPt,CR,CURIYR) = QBMASCL(I_SUPt,CR,CURIYR) + QBMINCL(I_SUPt,CR,CURIYR)
               END IF

               IF (MP_BM_H2(I_SUPt) .GT. 0.0) THEN
                  QBMH2CL(I_SUPt,0,CURIYR) = QBMH2CL(I_SUPt,0,CURIYR) + QBMH2CL(I_SUPt,CR,CURIYR)
                  QBMH2CL(0,0,CURIYR) = QBMH2CL(0,0,CURIYR) + QBMH2CL(I_SUPt,CR,CURIYR)
                  QBMASCL(I_SUPt,CR,CURIYR) = QBMASCL(I_SUPt,CR,CURIYR) + QBMH2CL(I_SUPt,CR,CURIYR)
               END IF

               IF (MP_BM_PW(I_SUPt) .GT. 0.0) THEN
                  QBMPWCL(I_SUPt,0,CURIYR) = QBMPWCL(I_SUPt,0,CURIYR) + QBMPWCL(I_SUPt,CR,CURIYR)
                  QBMPWCL(0,0,CURIYR) = QBMPWCL(0,0,CURIYR) + QBMPWCL(I_SUPt,CR,CURIYR)
                  QBMASCL(I_SUPt,CR,CURIYR) = QBMASCL(I_SUPt,CR,CURIYR) + QBMPWCL(I_SUPt,CR,CURIYR)
               END IF

               IF (MP_BM_ET(I_SUPt) .GT. 0.0) THEN
                  QBMETCL(I_SUPt,0,CURIYR) = QBMETCL(I_SUPt,0,CURIYR) + QBMETCL(I_SUPt,CR,CURIYR)
                  QBMETCL(0,0,CURIYR) = QBMETCL(0,0,CURIYR) + QBMETCL(I_SUPt,CR,CURIYR)
                  QBMASCL(I_SUPt,CR,CURIYR) = QBMASCL(I_SUPt,CR,CURIYR) + QBMETCL(I_SUPt,CR,CURIYR)
               END IF

               IF (MP_BM_BT(I_SUPt) .GT. 0.0) THEN
                  QBMBTCL(I_SUPt,0,CURIYR) = QBMBTCL(I_SUPt,0,CURIYR) + QBMBTCL(I_SUPt,CR,CURIYR)
                  QBMBTCL(0,0,CURIYR) = QBMBTCL(0,0,CURIYR) + QBMBTCL(I_SUPt,CR,CURIYR)
                  QBMASCL(I_SUPt,CR,CURIYR) = QBMASCL(I_SUPt,CR,CURIYR) + QBMBTCL(I_SUPt,CR,CURIYR)
               END IF

               QBMASCL(I_SUPt,0,CURIYR) = QBMASCL(I_SUPt,0,CURIYR) + QBMASCL(I_SUPt,CR,CURIYR)
               QBMASCL(0,0,CURIYR) = QBMASCL(0,0,CURIYR) + QBMASCL(I_SUPt,CR,CURIYR)
            END DO
         END IF
      END DO

      DO CR = 1 , NDREG
         QBMASCL(0,CR,CURIYR) = 0.0
         QBMRSCL(0,CR,CURIYR) = 0.0
         QBMCMCL(0,CR,CURIYR) = 0.0
         QBMINCL(0,CR,CURIYR) = 0.0
         QBMH2CL(0,CR,CURIYR) = 0.0
         QBMPWCL(0,CR,CURIYR) = 0.0
         QBMETCL(0,CR,CURIYR) = 0.0
         QBMBTCL(0,CR,CURIYR) = 0.0
         DO I_SUPt = 1 , MNUMFS
            IF (WDSUP_AVL(I_SUPt) .EQ. 1) THEN

               IF (MP_BM_RS(I_SUPt) .GT. 0.0) THEN
                  QBMRSCL(0,CR,CURIYR) = QBMRSCL(0,CR,CURIYR) + QBMRSCL(I_SUPt,CR,CURIYR)
               END IF

               IF (MP_BM_CM(I_SUPt) .GT. 0.0) THEN
                  QBMCMCL(0,CR,CURIYR) = QBMCMCL(0,CR,CURIYR) + QBMCMCL(I_SUPt,CR,CURIYR)
               END IF

               IF (MP_BM_IN(I_SUPt) .GT. 0.0) THEN
                  QBMINCL(0,CR,CURIYR) = QBMINCL(0,CR,CURIYR) + QBMINCL(I_SUPt,CR,CURIYR)
               END IF

               IF (MP_BM_H2(I_SUPt) .GT. 0.0) THEN
                  QBMH2CL(0,CR,CURIYR) = QBMH2CL(0,CR,CURIYR) + QBMH2CL(I_SUPt,CR,CURIYR)
               END IF

               IF (MP_BM_PW(I_SUPt) .GT. 0.0) THEN
                  QBMPWCL(0,CR,CURIYR) = QBMPWCL(0,CR,CURIYR) + QBMPWCL(I_SUPt,CR,CURIYR)
               END IF

               IF (MP_BM_ET(I_SUPt) .GT. 0.0) THEN
                  QBMETCL(0,CR,CURIYR) = QBMETCL(0,CR,CURIYR) + QBMETCL(I_SUPt,CR,CURIYR)
               END IF

               IF (MP_BM_BT(I_SUPt) .GT. 0.0) THEN
                  QBMBTCL(0,CR,CURIYR) = QBMBTCL(0,CR,CURIYR) + QBMBTCL(I_SUPt,CR,CURIYR)
               END IF

               QBMASCL(0,CR,CURIYR) = QBMASCL(0,CR,CURIYR) + QBMASCL(I_SUPt,CR,CURIYR)
            END IF
         END DO
      END DO

      PBMASCL(0,0,CURIYR) =  0.0
      PBMRSCL(0,0,CURIYR) =  0.0
      PBMCMCL(0,0,CURIYR) =  0.0
      PBMINCL(0,0,CURIYR) =  0.0
      PBMH2CL(0,0,CURIYR) =  0.0
      PBMPWCL(0,0,CURIYR) =  0.0
      PBMETCL(0,0,CURIYR) =  0.0
      PBMBTCL(0,0,CURIYR) =  0.0

      DO I_SUPt = 1 , MNUMFS
         IF (WDSUP_AVL(I_SUPt) .EQ. 1) THEN

            PBMASCL(I_SUPt,0,CURIYR) =  0.0
            PBMRSCL(I_SUPt,0,CURIYR) =  0.0
            PBMCMCL(I_SUPt,0,CURIYR) =  0.0
            PBMINCL(I_SUPt,0,CURIYR) =  0.0
            PBMH2CL(I_SUPt,0,CURIYR) =  0.0
            PBMPWCL(I_SUPt,0,CURIYR) =  0.0
            PBMETCL(I_SUPt,0,CURIYR) =  0.0
            PBMBTCL(I_SUPt,0,CURIYR) =  0.0

!           DO I_STP = 1 , NM_BM_SUP_STP
!              WDSUPPt(CURIYR,I_STP) = WDSUP_P(I_STP,NDREG,CURIYR,I_SUPt)
!           END DO

            DO CR = 1 , NDREG

               DO I_STP = 1 , NM_BM_SUP_STP
!                 if ((I_STP .gt. 1).and.(BM_TYP_CD(I_SUPt) .eq. 'UM').and. (CURITR .eq. 1)) then
                  ! if ((BM_TYP_CD(I_SUPt) .eq. 'UM')) then

!               MWINR1=mwin(1,curiyr)
!               mwinr2=mwin(2,curiyr)
!               mwinr3=mwin(3,curiyr)
!               mwinr4=mwin(4,curiyr)
!               MWINR1py=mwin(1,curiyr-1)
!               mwinr2py=mwin(2,curiyr-1)
!               mwinr3py=mwin(3,curiyr-1)
!               mwinr4py=mwin(4,curiyr-1)
!               WRITE(IORNDUMP,5061) CURIRUN,CURIYR+1989,CURITR,WDSUP_Q(20,6, CURIYR, I_SUPt),WDSUP_Q(20,7, CURIYR, I_SUPt), WDSUP_Q(20,8, CURIYR, I_SUPt), WDSUP_Q(20,9, CURIYR, I_SUPt)
!                               Select Case(CR)
!                                       case(1)
!                                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr1 ,"bf"
!                                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt)+0.5*0.5*MWINr1 - (0.5*0.5*MWINr1py)
!                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr1
!                                       case(2)
!                                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr1,"bf"
!                                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt)+0.5*0.5*MWINr1 - (0.5*0.5*MWINr1py)
!                                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr1
!                                       case(3)
!                                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr3,"bf"
!                                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt)+0.5*0.167*MWINr3 - (0.5*0.167*MWINr3py)
!                                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr3
!                                       case(4)
!                                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr3,"bf"
!                                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt)+0.5*0.167*MWINr3 - (0.5*0.167*MWINr3py)
!                                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr3
!                                       case(5)
!                                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr3,"bf"
!                                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt)+0.5*0.167*MWINr3 - (0.5*0.167*MWINr3py)
!                                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr3
!                                       case(6)
!                                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr2,"bf"
!                                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt)+0.5*0.25*MWINr2 - (0.5*0.25*MWINr2py)
!                                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr2
!                                       case(7)
!                                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr2,"bf"
!                                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt)+0.5*0.25*MWINr2 - (0.5*0.25*MWINr2py)
!                                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr2
!                                       case(8)
!                                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr3,"bf"
!                                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt)+0.5*0.167*MWINr3 - (0.5*0.167*MWINr3py)
!                                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr3
!                                       case(9)
!                                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr3,"bf"
!                                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt)+0.5*0.167*MWINr3 - (0.5*0.167*MWINr3py)
!                                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr3
!                                       case(10)
!                                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr4,"bf"
!                                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt)+0.5*0.25*MWINr2 - (0.5*0.25*MWINr2py)
!                                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr4
!                                       case(11)
!                                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr2,"bf"
!                                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt)+0.5*0.25*MWINr2 - (0.5*0.25*MWINr2py)
!                                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr2
!                                       case(12)
!                                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr3,"bf"
!                                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt)+0.5*0.167*MWINr3 - (0.5*0.167*MWINr3py)
!                                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr3
!                                       case(13)
!                                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr4,"bf"
!                                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt)+0.5*0.25*MWINr4 - (0.5*0.25*MWINr4py)
!                                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr4
!                                       case(14)
!                                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr4,"bf"
!                                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt)+0.5*0.25*MWINr4 - (0.5*0.25*MWINr4py)
!                                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr4
!                                       case(15)
!                                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr4,"bf"
!                                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt)+0.5*0.25*MWINr4 - (0.5*0.25*MWINr4py)
!                                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr4
!                                       case(16)
!                                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr4,"bf"
!                                       WDSUP_Q(I_STP,CR,CURIYR,I_SUPt) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt)+0.5*0.25*MWINr4 - (0.5*0.25*MWINr4py)
!                                       WRITE (IORNDUMP,5065) CR, CURIYR, I_SUPt, I_STP,wdsup_q(i_stp,cr,curiyr,i_supt), mwinr4
!                                       case default
!                                       WRITE (IORNDUMP,5064) CR, CURIYR, I_SUPt, I_STP
!                               end select
!                   WRITE(IORNDUMP,5063) CURIRUN,CURIYR+1989,CURITR,MWIN(1, CURIYR),MWIN(2, CURIYR), MWIN(3,CURIYR), MWIN(4, CURIYR)
!                   WRITE(IORNDUMP,5062) CURIRUN,CURIYR+1989,CURITR,WDSUP_Q(20,6, CURIYR, I_SUPt),WDSUP_Q(20,7, CURIYR, I_SUPt), WDSUP_Q(20,8, CURIYR, I_SUPt), WDSUP_Q(20,9, CURIYR, I_SUPt)
!       endif
                  WDSUPQt(CR,CURIYR,I_STP) = WDSUP_Q(I_STP,CR,CURIYR,I_SUPt)
                  WDSUPPt(CR,CURIYR,I_STP) = WDSUP_P(I_STP,CR,CURIYR,I_SUPt)
               END DO
 5061      FORMAT(1X,"wodsup_q by run, year, iteration, and coal region at step 20beforeb2",3(":",I4),4(":",F12.3))
 5062      FORMAT(1X,"wodsup_q by run, year, iteration, and coal region at step 20afterb2",3(":",I4),4(":",F12.3))
 5063      FORMAT(1X,"mwin by run, year, iteration, and coal region",3(":",I4),4(":",F12.3))
 5064           FORMAT ("defcase coal region, year, fuel type, step ",4(":",I4))
 5065           FORMAT ("ncase coal region, year, fuel type, step ",4(":",I4),2(":",F12.3),(":",A2))

               CALL GetPrice(WDSUPQt, WDSUPPt, QBMASCL(I_SUPt,CR,CURIYR), PBMASCL(I_SUPt,CR,CURIYR), ierror, CR, CURIYR)

               PBMRSCL(I_SUPt,CR,CURIYR) = PBMASCL(I_SUPt,CR,CURIYR)
               PBMCMCL(I_SUPt,CR,CURIYR) = PBMASCL(I_SUPt,CR,CURIYR)
               PBMINCL(I_SUPt,CR,CURIYR) = PBMASCL(I_SUPt,CR,CURIYR)
               PBMH2CL(I_SUPt,CR,CURIYR) = PBMASCL(I_SUPt,CR,CURIYR)
               PBMPWCL(I_SUPt,CR,CURIYR) = PBMASCL(I_SUPt,CR,CURIYR)
               PBMETCL(I_SUPt,CR,CURIYR) = PBMASCL(I_SUPt,CR,CURIYR)
               PBMBTCL(I_SUPt,CR,CURIYR) = PBMASCL(I_SUPt,CR,CURIYR)

               PBMASCL(0,0,CURIYR) = PBMASCL(0,0,CURIYR) + PBMASCL(I_SUPt,CR,CURIYR) * QBMASCL(I_SUPt,CR,CURIYR)
               PBMRSCL(0,0,CURIYR) = PBMRSCL(0,0,CURIYR) + PBMRSCL(I_SUPt,CR,CURIYR) * QBMRSCL(I_SUPt,CR,CURIYR)
               PBMCMCL(0,0,CURIYR) = PBMCMCL(0,0,CURIYR) + PBMCMCL(I_SUPt,CR,CURIYR) * QBMCMCL(I_SUPt,CR,CURIYR)
               PBMINCL(0,0,CURIYR) = PBMINCL(0,0,CURIYR) + PBMINCL(I_SUPt,CR,CURIYR) * QBMINCL(I_SUPt,CR,CURIYR)
               PBMH2CL(0,0,CURIYR) = PBMH2CL(0,0,CURIYR) + PBMH2CL(I_SUPt,CR,CURIYR) * QBMH2CL(I_SUPt,CR,CURIYR)
               PBMPWCL(0,0,CURIYR) = PBMPWCL(0,0,CURIYR) + PBMPWCL(I_SUPt,CR,CURIYR) * QBMPWCL(I_SUPt,CR,CURIYR)
               PBMETCL(0,0,CURIYR) = PBMETCL(0,0,CURIYR) + PBMETCL(I_SUPt,CR,CURIYR) * QBMETCL(I_SUPt,CR,CURIYR)
               PBMBTCL(0,0,CURIYR) = PBMBTCL(0,0,CURIYR) + PBMBTCL(I_SUPt,CR,CURIYR) * QBMBTCL(I_SUPt,CR,CURIYR)

               PBMASCL(I_SUPt,0,CURIYR) = PBMASCL(I_SUPt,0,CURIYR) + PBMASCL(I_SUPt,CR,CURIYR) * QBMASCL(I_SUPt,CR,CURIYR)
               PBMRSCL(I_SUPt,0,CURIYR) = PBMRSCL(I_SUPt,0,CURIYR) + PBMRSCL(I_SUPt,CR,CURIYR) * QBMRSCL(I_SUPt,CR,CURIYR)
               PBMCMCL(I_SUPt,0,CURIYR) = PBMCMCL(I_SUPt,0,CURIYR) + PBMCMCL(I_SUPt,CR,CURIYR) * QBMCMCL(I_SUPt,CR,CURIYR)
               PBMINCL(I_SUPt,0,CURIYR) = PBMINCL(I_SUPt,0,CURIYR) + PBMINCL(I_SUPt,CR,CURIYR) * QBMINCL(I_SUPt,CR,CURIYR)
               PBMH2CL(I_SUPt,0,CURIYR) = PBMH2CL(I_SUPt,0,CURIYR) + PBMH2CL(I_SUPt,CR,CURIYR) * QBMH2CL(I_SUPt,CR,CURIYR)
               PBMPWCL(I_SUPt,0,CURIYR) = PBMPWCL(I_SUPt,0,CURIYR) + PBMPWCL(I_SUPt,CR,CURIYR) * QBMPWCL(I_SUPt,CR,CURIYR)
               PBMETCL(I_SUPt,0,CURIYR) = PBMETCL(I_SUPt,0,CURIYR) + PBMETCL(I_SUPt,CR,CURIYR) * QBMETCL(I_SUPt,CR,CURIYR)
               PBMBTCL(I_SUPt,0,CURIYR) = PBMBTCL(I_SUPt,0,CURIYR) + PBMBTCL(I_SUPt,CR,CURIYR) * QBMBTCL(I_SUPt,CR,CURIYR)
            END DO
         END IF
      END DO

      DO CR = 1 , NDREG
         PBMASCL(0,CR,CURIYR) =  0.0
         PBMRSCL(0,CR,CURIYR) =  0.0
         PBMCMCL(0,CR,CURIYR) =  0.0
         PBMINCL(0,CR,CURIYR) =  0.0
         PBMH2CL(0,CR,CURIYR) =  0.0
         PBMPWCL(0,CR,CURIYR) =  0.0
         PBMETCL(0,CR,CURIYR) =  0.0
         PBMBTCL(0,CR,CURIYR) =  0.0

         DO I_SUPt = 1 , MNUMFS
            IF (WDSUP_AVL(I_SUPt) .EQ. 1) THEN
               PBMASCL(0,CR,CURIYR) = PBMASCL(0,CR,CURIYR) + PBMASCL(I_SUPt,CR,CURIYR) * QBMASCL(I_SUPt,CR,CURIYR)
               PBMRSCL(0,CR,CURIYR) = PBMRSCL(0,CR,CURIYR) + PBMRSCL(I_SUPt,CR,CURIYR) * QBMRSCL(I_SUPt,CR,CURIYR)
               PBMCMCL(0,CR,CURIYR) = PBMCMCL(0,CR,CURIYR) + PBMCMCL(I_SUPt,CR,CURIYR) * QBMCMCL(I_SUPt,CR,CURIYR)
               PBMINCL(0,CR,CURIYR) = PBMINCL(0,CR,CURIYR) + PBMINCL(I_SUPt,CR,CURIYR) * QBMINCL(I_SUPt,CR,CURIYR)
               PBMH2CL(0,CR,CURIYR) = PBMH2CL(0,CR,CURIYR) + PBMH2CL(I_SUPt,CR,CURIYR) * QBMH2CL(I_SUPt,CR,CURIYR)
               PBMPWCL(0,CR,CURIYR) = PBMPWCL(0,CR,CURIYR) + PBMPWCL(I_SUPt,CR,CURIYR) * QBMPWCL(I_SUPt,CR,CURIYR)
               PBMETCL(0,CR,CURIYR) = PBMETCL(0,CR,CURIYR) + PBMETCL(I_SUPt,CR,CURIYR) * QBMETCL(I_SUPt,CR,CURIYR)
               PBMBTCL(0,CR,CURIYR) = PBMBTCL(0,CR,CURIYR) + PBMBTCL(I_SUPt,CR,CURIYR) * QBMBTCL(I_SUPt,CR,CURIYR)
            END IF
         END DO
      END DO

      IF (QBMASCL(0,0,CURIYR) .GT. 0.0) THEN
         PBMASCL(0,0,CURIYR) = PBMASCL(0,0,CURIYR) / QBMASCL(0,0,CURIYR)
      ELSE
         PBMASCL(0,0,CURIYR) =  0.001
      END IF

      IF (QBMRSCL(0,0,CURIYR) .GT. 0.0) THEN
         PBMRSCL(0,0,CURIYR) = PBMRSCL(0,0,CURIYR) / QBMRSCL(0,0,CURIYR)
      ELSE
         PBMRSCL(0,0,CURIYR) = PBMASCL(0,0,CURIYR)
      END IF

      IF (QBMCMCL(0,0,CURIYR) .GT. 0.0) THEN
         PBMCMCL(0,0,CURIYR) = PBMCMCL(0,0,CURIYR) / QBMCMCL(0,0,CURIYR)
      ELSE
         PBMCMCL(0,0,CURIYR) = PBMASCL(0,0,CURIYR)
      END IF

      IF (QBMINCL(0,0,CURIYR) .GT. 0.0) THEN
         PBMINCL(0,0,CURIYR) = PBMINCL(0,0,CURIYR) / QBMINCL(0,0,CURIYR)
      ELSE
         PBMINCL(0,0,CURIYR) = PBMASCL(0,0,CURIYR)
      END IF

      IF (QBMH2CL(0,0,CURIYR) .GT. 0.0) THEN
         PBMH2CL(0,0,CURIYR) = PBMH2CL(0,0,CURIYR) / QBMH2CL(0,0,CURIYR)
      ELSE
         PBMH2CL(0,0,CURIYR) = PBMASCL(0,0,CURIYR)
      END IF

      IF (QBMPWCL(0,0,CURIYR) .GT. 0.0) THEN
         PBMPWCL(0,0,CURIYR) = PBMPWCL(0,0,CURIYR) / QBMPWCL(0,0,CURIYR)
      ELSE
         PBMPWCL(0,0,CURIYR) = PBMASCL(0,0,CURIYR)
      END IF

      IF (QBMETCL(0,0,CURIYR) .GT. 0.0) THEN
         PBMETCL(0,0,CURIYR) = PBMETCL(0,0,CURIYR) / QBMETCL(0,0,CURIYR)
      ELSE
         PBMETCL(0,0,CURIYR) = PBMASCL(0,0,CURIYR)
      END IF

      IF (QBMBTCL(0,0,CURIYR) .GT. 0.0) THEN
         PBMBTCL(0,0,CURIYR) = PBMBTCL(0,0,CURIYR) / QBMBTCL(0,0,CURIYR)
      ELSE
         PBMBTCL(0,0,CURIYR) = PBMASCL(0,0,CURIYR)
      END IF

      DO I_SUPt = 1 , MNUMFS
         IF (WDSUP_AVL(I_SUPt) .EQ. 1) THEN

            IF (QBMASCL(I_SUPt,0,CURIYR) .GT. 0.0) THEN
               PBMASCL(I_SUPt,0,CURIYR) = PBMASCL(I_SUPt,0,CURIYR) / QBMASCL(I_SUPt,0,CURIYR)
            ELSE
               PBMASCL(I_SUPt,0,CURIYR) = PBMASCL(0,0,CURIYR)
            END IF

            IF (QBMRSCL(I_SUPt,0,CURIYR) .GT. 0.0) THEN
               PBMRSCL(I_SUPt,0,CURIYR) = PBMRSCL(I_SUPt,0,CURIYR) / QBMRSCL(I_SUPt,0,CURIYR)
            ELSE
               PBMRSCL(I_SUPt,0,CURIYR) = PBMASCL(I_SUPt,0,CURIYR)
            END IF

            IF (QBMCMCL(I_SUPt,0,CURIYR) .GT. 0.0) THEN
               PBMCMCL(I_SUPt,0,CURIYR) = PBMCMCL(I_SUPt,0,CURIYR) / QBMCMCL(I_SUPt,0,CURIYR)
            ELSE
               PBMCMCL(I_SUPt,0,CURIYR) = PBMASCL(I_SUPt,0,CURIYR)
            END IF

            IF (QBMINCL(I_SUPt,0,CURIYR) .GT. 0.0) THEN
               PBMINCL(I_SUPt,0,CURIYR) = PBMINCL(I_SUPt,0,CURIYR) / QBMINCL(I_SUPt,0,CURIYR)
            ELSE
               PBMINCL(I_SUPt,0,CURIYR) = PBMASCL(I_SUPt,0,CURIYR)
            END IF

            IF (QBMH2CL(I_SUPt,0,CURIYR) .GT. 0.0) THEN
               PBMH2CL(I_SUPt,0,CURIYR) = PBMH2CL(I_SUPt,0,CURIYR) / QBMH2CL(I_SUPt,0,CURIYR)
            ELSE
               PBMH2CL(I_SUPt,0,CURIYR) = PBMASCL(I_SUPt,0,CURIYR)
            END IF

            IF (QBMPWCL(I_SUPt,0,CURIYR) .GT. 0.0) THEN
               PBMPWCL(I_SUPt,0,CURIYR) = PBMPWCL(I_SUPt,0,CURIYR) / QBMPWCL(I_SUPt,0,CURIYR)
            ELSE
               PBMPWCL(I_SUPt,0,CURIYR) = PBMASCL(I_SUPt,0,CURIYR)
            END IF

            IF (QBMETCL(I_SUPt,0,CURIYR) .GT. 0.0) THEN
               PBMETCL(I_SUPt,0,CURIYR) = PBMETCL(I_SUPt,0,CURIYR) / QBMETCL(I_SUPt,0,CURIYR)
            ELSE
               PBMETCL(I_SUPt,0,CURIYR) = PBMASCL(I_SUPt,0,CURIYR)
            END IF

            IF (QBMBTCL(I_SUPt,0,CURIYR) .GT. 0.0) THEN
               PBMBTCL(I_SUPt,0,CURIYR) = PBMBTCL(I_SUPt,0,CURIYR) / QBMBTCL(I_SUPt,0,CURIYR)
            ELSE
               PBMBTCL(I_SUPt,0,CURIYR) = PBMASCL(I_SUPt,0,CURIYR)
            END IF
         END IF
      END DO

      DO CR = 1 , NDREG
         IF (QBMASCL(0,CR,CURIYR) .GT. 0.0) THEN
            PBMASCL(0,CR,CURIYR) = PBMASCL(0,CR,CURIYR) / QBMASCL(0,CR,CURIYR)
         ELSE
            PBMASCL(0,CR,CURIYR) = PBMASCL(0,0,CURIYR)
         END IF

         IF (QBMRSCL(0,CR,CURIYR) .GT. 0.0) THEN
            PBMRSCL(0,CR,CURIYR) = PBMRSCL(0,CR,CURIYR) / QBMRSCL(0,CR,CURIYR)
         ELSE
            PBMRSCL(0,CR,CURIYR) = PBMASCL(0,CR,CURIYR)
         END IF

         IF (QBMCMCL(0,CR,CURIYR) .GT. 0.0) THEN
            PBMCMCL(0,CR,CURIYR) = PBMCMCL(0,CR,CURIYR) / QBMCMCL(0,CR,CURIYR)
         ELSE
            PBMCMCL(0,CR,CURIYR) = PBMASCL(0,CR,CURIYR)
         END IF

         IF (QBMINCL(0,CR,CURIYR) .GT. 0.0) THEN
            PBMINCL(0,CR,CURIYR) = PBMINCL(0,CR,CURIYR) / QBMINCL(0,CR,CURIYR)
         ELSE
            PBMINCL(0,CR,CURIYR) = PBMASCL(0,CR,CURIYR)
         END IF

         IF (QBMH2CL(0,CR,CURIYR) .GT. 0.0) THEN
            PBMH2CL(0,CR,CURIYR) = PBMH2CL(0,CR,CURIYR) / QBMH2CL(0,CR,CURIYR)
         ELSE
            PBMH2CL(0,CR,CURIYR) = PBMASCL(0,CR,CURIYR)
         END IF

         IF (QBMPWCL(0,CR,CURIYR) .GT. 0.0) THEN
            PBMPWCL(0,CR,CURIYR) = PBMPWCL(0,CR,CURIYR) / QBMPWCL(0,CR,CURIYR)
         ELSE
            PBMPWCL(0,CR,CURIYR) = PBMASCL(0,CR,CURIYR)
         END IF

         IF (QBMETCL(0,CR,CURIYR) .GT. 0.0) THEN
            PBMETCL(0,CR,CURIYR) = PBMETCL(0,CR,CURIYR) / QBMETCL(0,CR,CURIYR)
         ELSE
            PBMETCL(0,CR,CURIYR) = PBMASCL(0,CR,CURIYR)
         END IF

         IF (QBMBTCL(0,CR,CURIYR) .GT. 0.0) THEN
            PBMBTCL(0,CR,CURIYR) = PBMBTCL(0,CR,CURIYR) / QBMBTCL(0,CR,CURIYR)
         ELSE
            PBMBTCL(0,CR,CURIYR) = PBMASCL(0,CR,CURIYR)
         END IF
      END DO

!     For Now Output Price and Qunatity Info to the NOHUP.OUT File

      I_PRINT = IORNDUMP
      Label_2 = "AFTER "

      DO CR = 0 , NDREG
         I_TST = 1
         DO I_SUPt = 0 , MNUMFS
            IF (I_SUPt .GT. 0) I_TST = WDSUP_AVL(I_SUPt)
            IF (I_TST .EQ. 1) THEN
               IF (I_SUPt .EQ. 0) THEN
                  SEC_CD = "TL"
               ELSE
                  SEC_CD = BM_TYP_CD(I_SUPt)
               END IF

               LABEL_3 = "DEMAND"
               WRITE(I_PRINT,5555) Label_2, Label_3, SEC_CD, CURIRUN, CURIYR+1989, CURITR, CR, I_SUPt, &
                  QBMASCL(I_SUPt,CR,CURIYR), QBMBTCL(I_SUPt,CR,CURIYR), QBMETCL(I_SUPt,CR,CURIYR), QBMPWCL(I_SUPt,CR,CURIYR),  &
                  QBMH2CL(I_SUPt,CR,CURIYR), QBMINCL(I_SUPt,CR,CURIYR), QBMCMCL(I_SUPt,CR,CURIYR), QBMRSCL(I_SUPt,CR,CURIYR)

               LABEL_3 = "PRICE "
               WRITE(I_PRINT,5555) Label_2, Label_3, SEC_CD, CURIRUN, CURIYR+1989, CURITR, CR, I_SUPt, &
                  PBMASCL(I_SUPt,CR,CURIYR), PBMBTCL(I_SUPt,CR,CURIYR), PBMETCL(I_SUPt,CR,CURIYR), PBMPWCL(I_SUPt,CR,CURIYR),  &
                  PBMH2CL(I_SUPt,CR,CURIYR), PBMINCL(I_SUPt,CR,CURIYR), PBMCMCL(I_SUPt,CR,CURIYR), PBMRSCL(I_SUPt,CR,CURIYR)
            END IF
         END DO
      END DO

!     First Time Through Reset Demand Expectations

      IF (ONCE) THEN

3133     FORMAT(1X,"EXPECTED_BM_DEMAND",7(":",I4),2(":",A2),4(":",F15.3))

         BASE_YEAR = 1989
         N_YR = 5
         IF (BM_FS_SW .EQ. 0 .OR. CURIRUN .GT. 1) THEN
            DO I_SUPt = 1 , MNUMFS
               DO CR = 1 , NDREG

!                 Residential - RS

                  IF (MP_BM_RS(I_SUPt) .EQ. 1) THEN
                     IF (QBMRSCL(I_SUPt,CR,LASTYR-N_YR) .GT. 0.0) THEN
                        GROW_RATE = (QBMRSCL(I_SUPt,CR,LASTYR) / QBMRSCL(I_SUPt,CR,LASTYR-N_YR))**(1.0/DBLE(N_YR))
                        GROW_RATE = MAX( 1.0 , GROW_RATE )
                        GROW_RATE = MIN( 1.1 , GROW_RATE )
                     ELSE
                        GROW_RATE = 1.0
                     END IF

                     SEC_CD = "RS"

                     DO I_YR = LASTYR + 1 , MNUMYR + ECP_D_FPH
                        QBMRSCL(I_SUPt,CR,I_YR) = QBMRSCL(I_SUPt,CR,I_YR-1) * GROW_RATE
                     END DO

                     WRITE(I_PRINT,3133) CURIRUN, CURIYR+1989, CURITR, LASTYR, I_SUPt, CR, BM_FS_SW, BM_TYP_CD(I_SUPt), SEC_CD, &
                        GROW_RATE, QBMRSCL(I_SUPt,CR,LASTYR), QBMRSCL(I_SUPt,CR,LASTYR+1), QBMRSCL(I_SUPt,CR,MNUMYR+ECP_D_FPH)

                  END IF

!                 Commercial - CM

                  IF (MP_BM_CM(I_SUPt) .EQ. 1) THEN
                     IF (QBMCMCL(I_SUPt,CR,LASTYR-N_YR) .GT. 0.0) THEN
                        GROW_RATE = (QBMCMCL(I_SUPt,CR,LASTYR) / QBMCMCL(I_SUPt,CR,LASTYR-N_YR))**(1.0/DBLE(N_YR))
                        GROW_RATE = MAX( 1.0 , GROW_RATE )
                        GROW_RATE = MIN( 1.1 , GROW_RATE )
                     ELSE
                        GROW_RATE = 1.0
                     END IF

                     SEC_CD = "CM"

                     DO I_YR = LASTYR + 1 , MNUMYR + ECP_D_FPH
                        QBMCMCL(I_SUPt,CR,I_YR) = QBMCMCL(I_SUPt,CR,I_YR-1) * GROW_RATE
                     END DO

                     WRITE(I_PRINT,3133) CURIRUN, CURIYR+1989, CURITR, LASTYR, I_SUPt, CR, BM_FS_SW, BM_TYP_CD(I_SUPt), SEC_CD, &
                        GROW_RATE, QBMCMCL(I_SUPt,CR,LASTYR), QBMCMCL(I_SUPt,CR,LASTYR+1), QBMCMCL(I_SUPt,CR,MNUMYR+ECP_D_FPH)

                  END IF

!                 Industrial - IN

                  IF (MP_BM_IN(I_SUPt) .EQ. 1) THEN
                     IF (QBMINCL(I_SUPt,CR,LASTYR-N_YR) .GT. 0.0) THEN
                        GROW_RATE = (QBMINCL(I_SUPt,CR,LASTYR) / QBMINCL(I_SUPt,CR,LASTYR-N_YR))**(1.0/DBLE(N_YR))
                        GROW_RATE = MAX( 1.0 , GROW_RATE )
                        GROW_RATE = MIN( 1.1 , GROW_RATE )
                     ELSE
                        GROW_RATE = 1.0
                     END IF

                     SEC_CD = "IN"

                     DO I_YR = LASTYR + 1 , MNUMYR + ECP_D_FPH
                        QBMINCL(I_SUPt,CR,I_YR) = QBMINCL(I_SUPt,CR,I_YR-1) * GROW_RATE
                     END DO

                     WRITE(I_PRINT,3133) CURIRUN, CURIYR+1989, CURITR, LASTYR, I_SUPt, CR, BM_FS_SW, BM_TYP_CD(I_SUPt), SEC_CD, &
                        GROW_RATE, QBMINCL(I_SUPt,CR,LASTYR), QBMINCL(I_SUPt,CR,LASTYR+1), QBMINCL(I_SUPt,CR,MNUMYR+ECP_D_FPH)

                  END IF

!                 Hydrogen Supply - H2

                  IF (MP_BM_H2(I_SUPt) .EQ. 1) THEN
                     IF (QBMH2CL(I_SUPt,CR,LASTYR-N_YR) .GT. 0.0) THEN
                        GROW_RATE = (QBMH2CL(I_SUPt,CR,LASTYR) / QBMH2CL(I_SUPt,CR,LASTYR-N_YR))**(1.0/DBLE(N_YR))
                        GROW_RATE = MAX( 1.0 , GROW_RATE )
                        GROW_RATE = MIN( 1.1 , GROW_RATE )
                     ELSE
                        GROW_RATE = 1.0
                     END IF

                     SEC_CD = "H2"

                     DO I_YR = LASTYR + 1 , MNUMYR + ECP_D_FPH
                        QBMH2CL(I_SUPt,CR,I_YR) = QBMH2CL(I_SUPt,CR,I_YR-1) * GROW_RATE
                     END DO

                     WRITE(I_PRINT,3133) CURIRUN, CURIYR+1989, CURITR, LASTYR, I_SUPt, CR, BM_FS_SW, BM_TYP_CD(I_SUPt), SEC_CD, &
                        GROW_RATE, QBMH2CL(I_SUPt,CR,LASTYR), QBMH2CL(I_SUPt,CR,LASTYR+1), QBMH2CL(I_SUPt,CR,MNUMYR+ECP_D_FPH)

                  END IF

!                 Electric Power - PW

                  IF (MP_BM_PW(I_SUPt) .EQ. 1) THEN
                     IF (QBMPWCL(I_SUPt,CR,LASTYR-N_YR) .GT. 0.0) THEN
                        GROW_RATE = (QBMPWCL(I_SUPt,CR,LASTYR) / QBMPWCL(I_SUPt,CR,LASTYR-N_YR))**(1.0/DBLE(N_YR))
                        GROW_RATE = MAX( 1.0 , GROW_RATE )
                        GROW_RATE = MIN( 1.1 , GROW_RATE )
                     ELSE
                        GROW_RATE = 1.0
                     END IF

                     SEC_CD = "PW"

                     DO I_YR = LASTYR + 1 , MNUMYR + ECP_D_FPH
                        QBMPWCL(I_SUPt,CR,I_YR) = QBMPWCL(I_SUPt,CR,I_YR-1) * GROW_RATE
                     END DO

                     WRITE(I_PRINT,3133) CURIRUN, CURIYR+1989, CURITR, LASTYR, I_SUPt, CR, BM_FS_SW, BM_TYP_CD(I_SUPt), SEC_CD, &
                        GROW_RATE, QBMPWCL(I_SUPt,CR,LASTYR), QBMPWCL(I_SUPt,CR,LASTYR+1), QBMPWCL(I_SUPt,CR,MNUMYR+ECP_D_FPH)

                  END IF

!                 Cellulosic Ethanol - ET

                  IF (MP_BM_ET(I_SUPt) .EQ. 1) THEN
                     IF (QBMETCL(I_SUPt,CR,LASTYR-N_YR) .GT. 0.0) THEN
                        GROW_RATE = (QBMETCL(I_SUPt,CR,LASTYR) / QBMETCL(I_SUPt,CR,LASTYR-N_YR))**(1.0/DBLE(N_YR))
                        GROW_RATE = MAX( 1.0 , GROW_RATE )
                        GROW_RATE = MIN( 1.1 , GROW_RATE )
                     ELSE
                        GROW_RATE = 1.0
                     END IF

                     SEC_CD = "ET"

                     DO I_YR = LASTYR + 1 , MNUMYR + ECP_D_FPH
                        QBMETCL(I_SUPt,CR,I_YR) = QBMETCL(I_SUPt,CR,I_YR-1) * GROW_RATE
                     END DO

                     WRITE(I_PRINT,3133) CURIRUN, CURIYR+1989, CURITR, LASTYR, I_SUPt, CR, BM_FS_SW, BM_TYP_CD(I_SUPt), SEC_CD, &
                        GROW_RATE, QBMETCL(I_SUPt,CR,LASTYR), QBMETCL(I_SUPt,CR,LASTYR+1), QBMETCL(I_SUPt,CR,MNUMYR+ECP_D_FPH)

                  END IF

!                 Biomass to Liquids - BT

                  IF (MP_BM_BT(I_SUPt) .EQ. 1) THEN
                     IF (QBMBTCL(I_SUPt,CR,LASTYR-N_YR) .GT. 0.0) THEN
                        GROW_RATE = (QBMBTCL(I_SUPt,CR,LASTYR) / QBMBTCL(I_SUPt,CR,LASTYR-N_YR))**(1.0/DBLE(N_YR))
                        GROW_RATE = MAX( 1.0 , GROW_RATE )
                        GROW_RATE = MIN( 1.1 , GROW_RATE )
                     ELSE
                        GROW_RATE = 1.0
                     END IF

                     SEC_CD = "BT"

                     DO I_YR = LASTYR + 1 , MNUMYR + ECP_D_FPH
                        QBMBTCL(I_SUPt,CR,I_YR) = QBMBTCL(I_SUPt,CR,I_YR-1) * GROW_RATE
                     END DO

                     WRITE(I_PRINT,3133) CURIRUN, CURIYR+1989, CURITR, LASTYR, I_SUPt, CR, BM_FS_SW, BM_TYP_CD(I_SUPt), SEC_CD, &
                        GROW_RATE, QBMBTCL(I_SUPt,CR,LASTYR), QBMBTCL(I_SUPt,CR,LASTYR+1), QBMBTCL(I_SUPt,CR,MNUMYR+ECP_D_FPH)

                  END IF
               END DO
            END DO
         ELSE
            QBMBTCL = 0.0
            QBMETCL = 0.0
            QBMPWCL = 0.0
            QBMH2CL = 0.0
            QBMINCL = 0.0
            QBMCMCL = 0.0
            QBMRSCL = 0.0
            PBMBTCL = 0.1
            PBMETCL = 0.1
            PBMPWCL = 0.1
            PBMH2CL = 0.1
            PBMINCL = 0.1
            PBMCMCL = 0.1
            PBMRSCL = 0.1
         END IF
         IF (CURIRUN .GT. 1) BM_FS_SW = 0
         ONCE = .FALSE.
      END IF

      IF (EXE .EQ. 1) THEN
         NLead = MIN(UPPLYR(WIWD) + 1 , ECP_D_XPH)
      ELSE
         NLead = 2
         UNYEAR = MNUMYR
      END IF

      DO I_SUPt = 1 , MNUMFS
         IF (WDSUP_AVL(I_SUPt) .EQ. 1 .AND. MP_BM_PW(I_SUPt) .GT. 0.0) THEN
            DO CR = 1 , NDREG
               DO theYear = CURIYR, CURIYR + ECP_D_FPH

                  IF (BM_FS_SW .EQ. 0) THEN
                     le_year = TheYear
                  ELSE
                     IF (TheYear .LE. LASTYR) THEN
                        le_year = TheYear
                     ELSE
                        le_year = LASTYR
                     END IF
                  END IF

                  DO I_STP = 1 , NM_BM_SUP_STP
                     WDSUPQt(CR,le_year,I_STP) = WDSUPQt(CR,le_year,I_STP) + WDSUP_Q(I_STP,CR,le_year,I_SUPt) - &
                        QBMETCL(I_SUPt,CR,le_year) - &
                        QBMBTCL(I_SUPt,CR,le_year) - &
                        QBMH2CL(I_SUPt,CR,le_year) - &
                        QBMINCL(I_SUPt,CR,le_year) - &
                        QBMCMCL(I_SUPt,CR,le_year) - &
                        QBMRSCL(I_SUPt,CR,le_year)
                  END DO
               END DO
            END DO
         END IF
      END DO

!     Get maximum regional supply of biomass for all years out to life cycle horizon

      DO cl = 1 , NDREG
         Maxsupply_cl(cl) = 0.0
         DO theYear = CURIYR, CURIYR + ECP_D_FPH
            Maxsupply_cl(cl) = MAX(Maxsupply_cl(cl) , Max_Value(WDSUPQt,cl,theYear,NWDSUPQ))

!           WRITE(6,5559) CURIRUN, CURIYR+1989, curitr, cl, theYear+1989, maxsupply_cl(cl)
 5559       FORMAT(1X,"MaxSupply_CL",5(":",I4),":",F15.3)

         ENDDO !theyear
      ENDDO !cl

      DO nr = 1 , MNUMNR
         MaxSupply(nr) = 0.0
         DO cl = 1 , NDREG
            IF (C_EMM_CDS(nr,cl) .GT. 0) THEN
               MaxSupply(nr) = MaxSupply(nr) + MaxSupply_cl(cl)

!              WRITE(6,5558) CURIRUN, CURIYR+1989, curitr, nr, cl, C_EMM_CDS(nr,cl), maxsupply_cl(cl), maxsupply(nr)
 5558          FORMAT(1X,"MaxSupply_NR_CL",6(":",I4),2(":",F15.3))

            END IF
         END DO

         IF (EXE .EQ. 1) THEN
            UTRSMX(nr,itech) = Maxsupply(nr) / (WHRIGCC(CURIYR) * UPMCF(WIWD) *8760.0) * 1.E9
         ELSE
            UTRSMX(nr,itech) = Maxsupply(nr) / (WHRIGCC(CURIYR) * 0.80 *8760.0) * 1.E9
         END IF
         UTRSCU(nr,itech) = (UCAPWDU(nr,CURIYR)+UCAPWDN(nr,CURIYR)) * 1000. + UADDWDT(nr,CURIYR+Nlead)

!        Decrement the new builds from the available capacity only at 1st iter

         IF (CURITR.EQ.1) THEN
            CumWdBld(nr,CURIYR) = CumWdBld(nr,CURIYR) + UADDWDT(nr,CURIYR+Nlead)
         ENDIF
      ENDDO   !Loop over NERC regions

!     Write out consumption and capacity of planned units to the WDUMP file.

      IF (EXE .EQ. 1) THEN
         NLead = MIN(UPPLYR(WIWD) + 1 , ECP_D_XPH)
      ELSE
         NLead = 2
         UNYEAR = MNUMYR
      END IF
      OLYR  = CURIYR + Nlead

      IF ((CURITR.gt.MAXITR) .OR. (FCRL.EQ.1)) THEN
         DO yrpl = CURIYR +1, OLYR
            DO nr = 1, unrgns
               WRITE(IORNDUMP,2032) CURIYR+1989,CURITR,nr,yrpl,UADDWDT(nr,yrpl),trim(scen_date)
            ENDDO
         ENDDO
      ENDIF
 2032 FORMAT('wd_Planned_Capacity:',I4,':',I2,':',I2,':',I2,':',F12.3,':',A)

!     Store biomass unit size

      IF (EXE .EQ. 1) THEN
         DO rnw = 1 , ECP_D_RNW
            IF (UCPRNWI(rnw) .GT. 0) THEN
               IF (UPLNTCD(UCPRNWI(rnw)) .eq. 'WD') THEN
                  addwd = UPMSSIZ(UCPRNWI(rnw))
               ENDIF
            ENDIF
         ENDDO
      ELSE
         addwd = 50.0
      END IF

!     Write out variables that are indexed by year to the WDUMP file.

      IF (CURITR.eq.1 .AND. EXE .EQ. 1) THEN
         WRITE(IORNDUMP,2006) CURIYR+1989,CURITR,WHRIGCC(CURIYR),WDVCADD(CURIYR),UPCLYR(WIWD),addwd,UPMCF(WIWD),itech,OLYR,FSTPMX,ECP_D_FPH,trim(scen_date)
      ENDIF
 2006 FORMAT('wd_Annual_Parameters:',I4,':',I2,':',F12.3,':',F12.3,':',I2,':',F15.3,':',F5.3,':',I2,':',I2,':',I2,':',I2,':',A)

      IF (CURITR.eq.1) THEN
         DO nr = 1, 13
            WRITE(IORNDUMP,2018) CURIYR+1989,CURITR,nr,CumWdBld(nr,CURIYR),trim(scen_date)
         ENDDO
      ENDIF
 2018 FORMAT('wd_Cumulative_Builds:',I4,':',I2,':',I2,':',F12.3,':',A)

      RETURN
      END

! *********************************************************************
! Subroutine WDSMOOTH
!
! Routine constraints the growth of biomass GCC. Since it is a new
! technology it assumed that the development of new plants will be
! first sporadic such that experiences with new capacities are gained
! before new plants are built.
!
!
! Input:
!   wwdcomon:
!     WDTHRES    : Threshold
!     WDNEWBLD   : logical array for testing if new builds are allowed
!     WDNOTBLDT  : no build period
!   UECPOUT
!     UADDWDT    : new builds for biomass [MW]
!
!  Output:
!    wrenew:
!      WCABMEL   : available capacity
!
!  Local variable:
!    Integer
!       nr       : region counter
!       yr       : year counter
!       yyr      : year counter
!       Nlead    : lead time
!
!
! written by: Michael Kintner-Meyer
! revised:    7/26/95
! --------------------------------------------------------------------
      Subroutine WDSMOOTH
      implicit none
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'ecpcntl'
      include 'control'
      include 'wrenew'
      include 'wwdcomon'
      include 'wrenio'
      include 'uecpout'
      include 'uefdout'

      integer nr,yr,yyr,Nlead

! ...... reassign global lead time to local integer variable
! ...... Use ECP's variable for technology # WIWD
      Nlead=UPPLYR(WIWD)

      DO nr = 1, unrgns
         if ((UADDWDT(nr,CURIYR+Nlead).gt. 0.0) .and. &
               (.not. WDNEWBLD(nr,MAX0(1,CURIYR-1)))) then
           WRITE(IORNDUMP,*)'  ^^^^^ problem in WDSMOOTH'
         endif

         IF (.not. WDNEWBLD(nr,CURIYR)) then
            WCABMEL(nr,CURIYR)=0.0
         ELSE
            IF (UADDWDT(nr,CURIYR+Nlead).gt.WDTHRES) then
               WCABMEL(nr,CURIYR)=0.
               DO yr=CURIYR,CURIYR+WDNOTBLDT-1
                  yyr=MIN0(yr,MNUMYR)
                  WDNEWBLD(nr,yyr)=.false.
               ENDDO
            ENDIF
         ENDIF
      ENDDO

!DSB      IF ((CURITR.GT.MAXITR) .OR. (FCRL.EQ.1)) THEN
!DSB       DO nr = 1, unrgns
!DSB        DO yr = CURIYR, CURIYR+WDNOTBLDT-1
!DSB         WRITE(IORNDUMP,1000) CURIYR,CURIYR+WDNOTBLDT-1,WDTHRES,
!DSB     &      WCABMEL(nr,CURIYR),WDNEWBLD(nr,yr),WDNOTBLDT,SCEN1

!DSB        ENDDO
!DSB       ENDDO
!DSB      ENDIF
!DSB 1000  FORMAT ('wd_Smoothing:',I2,':',I2,':',F15.3,':',F12.3,':',I2,
!DSB     &           ':',I2,':',A18)

      RETURN
       END

! *********************************************************************
! Subroutine WDPOLY
!
! Calculate biomass demand points to send to polsys model.  Recieve prices
! back from polysys and overwrite woodsup values with polysys values. what values
!  for first iteration? what values for forecast years?
! --------------------------------------------------------------------
      Subroutine WDPOLY

      implicit none
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'ecpcntl'
      include 'control'
      include 'wrenew'
      include 'wwdcomon'
      include 'wrenio'
      include 'macout'
      include 'intout'
      include 'uecpout'
      INCLUDE 'MCDETAIL'

      integer iyr,istp,ipt,midpt,intpoints,scpoint,intpt,istep,ir,done
      INTEGER*4 BASE_YEAR
      INTEGER*4 BASE_YR
      REAL*8    DIST_CST,totbiomass
      REAL*8    PRCNT_OIL,WDPOLYCM,POLYADJ
      REAL*8    CNV_FACT,C2,TRANADD,TRANADD1,TRANADD2
      REAL*8    CST_87_MMBtu
      integer jj

      INTEGER RTOVALUE
      EXTERNAL RTOVALUE

      WDPOLYCM = RTOVALUE('POLYCOST',0) / 100.0
!    write(6,*) ' wdpolycm rtovalue ',wdpolycm

!!POLYSYS  FILL IN VALUES FROM LAST POLYSYS STEP TO LAST WODSUPP
!!POLYSYS  STEP WITH LAST VALUE. WILL ONLY HAVE ONE YEARS VALUE SO ONLY OVERWRITE CURRENT YEAR, WHAT TO DO ABOUT
!!POLYSYS  FORECAST YEARS????
!
      POLYPTQ(:,:,curiyr) = 0.0
      POLYPTP(:,:,curiyr) = 0.0
      CRNSUP_TOT_Q(:,:,CURIYR) = 0.0
      CRNSUP_P(:,:,CURIYR) = 0.0
      CRNSUP_ETH_Q(:,:,CURIYR) = 0.0
      SOYSUP_P(:,:,CURIYR) = 0.0
      SOYSUP_TOT_Q(:,:,CURIYR) = 0.0
      SOYOILSUP_BIOD_Q(:,:,CURIYR) = 0.0
      SOYOILSUP_TOT_Q(:,:,CURIYR) = 0.0
      SOYOILSUP_P(:,:,CURIYR) = 0.0
!
!     set up number of points and values here.
!     set midpoint of points equal to NEMS value
!  CAN ALSO SET MIDPOINT BY WHICH ONE HAS VALUE OF 1 IF %  0 IF VALUE
      MIDPT = (WDPOLYPT/2.) +.5
      write(IORNDUMP,*) ' wdpolypt midpt ',wdpolypt,midpt
      DO IR = 0 , NDREG       ! for when regional polysys ready
!     DO IR = 0 , 0
!         write(IORNDUMP,*) ' curiyr,irg,qbmascl ',curiyr,ir,qbmascl(3,ir,curiyr)
!         totbiomass = MAX(qbmascl(3,ir,curiyr),0.1)
!         POLYPTQ(MIDPT,IR) = totbiomass
!  Note that polysys will be using national price only along with regional multipliers
!  send price to polysys that doesnt' include transportation costs

        !  POLYPTP(MIDPT,IR,CURIYR) = PBMASCL(3,IR,CURIYR)-WDTRANSADD(CURIYR-1)
         ! POLYPRMULT(IR) = POLYPTP(MIDPT,IR,CURIYR)/POLYPTP(MIDPT,0,CURIYR)
        !  POLYPTP(MIDPT,IR,CURIYR) = MAX(PBMASCL(3,IR,CURIYR)-WDTRANSADD(CURIYR-1),2.0)   !! If we remove the 2.0 then we need to make sure the lower 2 price points aren't negative
          POLYPTP(MIDPT,IR,CURIYR) = MAX(PBMASCL(3,IR,CURIYR)-WDTRANSADD(CURIYR-1),1.0) !1.2

         !write(666,*) 'NEMS polyprice',curcalyr,IR,PBMASCL(3,IR,CURIYR)-WDTRANSADD(CURIYR-1)
!         POLYPTP(MIDPT,IR,CURIYR) = PBMASCL(3,IR,CURIYR)-WDTRANSADD(CURIYR-1)
!         POLYPTP(MIDPT,IR) = PBMASCL(3,IR,CURIYR)
       !  POLYPRMULT(IR) = PBMASCL(3,IR,CURIYR)/PBMASCL(3,0,CURIYR)
         !write(666,*) 'debug polymult',POLYPRMULT(IR),ir,curcalyr

          POLYPRMULT(IR) = POLYPTP(MIDPT,IR,CURIYR)/POLYPTP(MIDPT,0,CURIYR)
          If (QBMASCL(3,IR,CURIYR) .eq. 0) POLYPRMULT(IR) = 1.0   !! use national price if Q is zero
          ! write(666,*) 'debug polymult',POLYPRMULT(IR),ir,curcalyr
         !  POLYPRMULT(IR) = 1.0
   write(iorndump,2869) ' yr,rg,polyptp,pbmascl,zero,mult ',curiyr,ir,pbmascl(3,ir,curiyr),pbmascl(3,0,curiyr),polyptp(midpt,ir,curiyr),polyprmult(ir),wdtransadd(curiyr-1)
   2869 Format(A,2I4,5(2x,F15.4))

!         IF ( POLYPTQ(MIDPT,IR) .GE. 1000.0 ) THEN
!           WDPSCCALC = 2
!           WDPSCCVAL(1) = - 200.0
!           WDPSCCVAL(2) = 0.0
!           WDPSCCVAL(3) = 150.0
!           WDPSCCVAL(4) = 300.0
!           WDPSCCVAL(5) = 450.0
!         ELSEIF ( POLYPTQ(MIDPT,IR) .LT. 1000.0 ) THEN
!           WDPSCCALC = 1
!           WDPSCCVAL(1) = - .20
!           WDPSCCVAL(2) = 0.0
!           WDPSCCVAL(3) = .20
!           WDPSCCVAL(4) = .40
!           WDPSCCVAL(5) = .70
!         ENDIF
!
          DO IPT = 1 , WDPOLYPT
            IF ( WDPSCCALC .EQ. 1 ) THEN
              IF ( IPT .NE. MIDPT ) THEN
                POLYPTP(IPT,IR,CURIYR) = POLYPTP(MIDPT,IR,CURIYR) + ( POLYPTP(MIDPT,IR,CURIYR) * WDPSCCVAL(IPT) )
              ENDIF
            ELSEIF ( WDPSCCALC .EQ. 2 ) THEN
              IF ( IPT .NE. MIDPT ) THEN
                POLYPTP(IPT,IR,CURIYR) = POLYPTP(MIDPT,IR,CURIYR) +  WDPSCCVAL(IPT)
              ENDIF
            ENDIF
          ENDDO
        !  write(666,*) ' ir polyptp ',curcalyr,ir,(polyptp(ipt,ir,CURIYR),ipt=1,wdpolypt)
       ENDDO
!
!                CALL GETPOLYCURVE  call polysys to run 5 times will send back 5 prices.
!        polysys will run number of points time using biomass quantity demand values from polyptq.
!       maybe a return code for each point????
!
!********** call to POLYSYS
      !**************************************************************** TDTDTDTD take out
        !WDPOLYYR=2016

       IF ( CURIYR .GE. (WDPOLYYR - BASEYR + 1) ) THEN
      !write(*,*) 'calling polysys',curcalyr,curitr
           call polysys
       ENDIF

!        IF (( ( CURITR .EQ. 1 ) .AND. (CURIRUN .EQ. 1)) .OR. (QBMASCL(3,0,CURIYR) .le. 30.0)) THEN
!!????FILL THIS SECTION WITH A MINIMUM PRICE????
!        IF (QBMASCL(3,0,CURIYR) .le. 30.0) THEN
!          POLYPTQ(1,:) = 10.0
!          POLYPTQ(2,:) = 24.0
!          POLYPTQ(3,:) = 35.0
!          POLYPTQ(4,:) = 45.0
!          POLYPTQ(5,:) = 60.0
!          plysupp_pt(1,:) = 0.97
!          plysupp_pt(2,:) = 0.98
!          plysupp_pt(3,:) = 1.00
!          plysupp_pt(4,:) = 1.15
!          plysupp_pt(5,:) = 1.20
!        ENDIF
!
!***********


          polyret = 0   ! set to 0 for testing
!set test values for polsys return prices  $87/MMBTU
!          plysupq_pt(1,:) = 10
!          plysupq_pt(2,:) = 24
!          plysupq_pt(3,:) = 35
!          plysupq_pt(4,:) = 45
!          plysupq_pt(5,:) = 60
!
!     apply cost multiplier for side cases to polysys prices
!
!           write(iorndump,*) ' poly price before mult ',plysupp_pt(3,ndreg)
           write(iorndump,2113)  ' POLYDBG PRICES FROM NEMS     ',CURIRUN,CURIYR,CURITR,'0',(polyptp(ipt,0,curiyr),ipt=1,5)
          
        !   write(666,*) ' POLYDBG PRICES FROM NEMS     ',CURIRUN,CURIYR,CURITR,'0',polyptp(3,0,curiyr)*15.4*  (MC_DETAIL(100,curiyr)/(MC_DETAIL(100,1)*0.97))
           DO IR = 0 , NDREG
            write(iorndump,2117) ' POLYDBG QUANTITIES FROM POLY ',CURIRUN,CURIYR,CURITR,IR,(plysupq_pt(ipt,ir,curiyr),ipt=1,5),polyprmult(ir)
           enddo
 2113  format(a,3(I3),A3,5(1x,F10.5))
 2117  format(a,4(I3),5(1x,F10.2),F8.5)
          DO IPT = 1 , WDPOLYPT
            POLYPTP(IPT,:,CURIYR) = POLYPTP(IPT,:,CURIYR) * WDPOLYCM
          ENDDO
            write(iorndump,2114) ' poly prices after mult ',(polyptp(ipt,0,CURIYR),ipt=1,5)
 2114  format(a,5(1x,F10.5))
!
          IF ( POLYRET .NE. 0 ) THEN
            WDPOLYSW = 0
            write(6,*)  ' polysys return code ne 0 ',curiyr,curitr,ir
          ELSE
!     linear interpolation between points to get full supply curves
!     calculate number of interpolation points between actual points, for now close as possible to 25 points.
            DONE = 0
            DO IPT = 1 , MAXPOLYPT
              IF ( DONE .EQ. 0 ) THEN
                INTPOINTS = (WDPOLYPT * (IPT+1))
                IF (INTPOINTS .EQ. 30 ) THEN
                  DONE = 1
                  INTPOINTS = IPT
                ELSEIF (INTPOINTS .GT. 30) THEN
                  DONE = 1
                  INTPOINTS = IPT - 1
                ENDIF
              ENDIF
              write(IORNDUMP,*) ' done ipt intpoints maxpolypt ',done,ipt,intpoints,maxpolypt
            ENDDO
            write(IORNDUMP,*) ' intpoints ',wdpolypt,intpoints

!
!      fill supply curve values with actual and interpolated point values  leave 1 step as 0
!
         PLYSUP_Q_AG(1,:,CURIYR) = 0.0
         PLYSUP_P_AG(1,:,CURIYR) = 0.0
!
         DO IR = 0 , NDREG       ! for when regional polysys ready
            DO IPT = 1 , WDPOLYPT
             SCPOINT = IPT + (IPT * INTPOINTS ) + 1
             PLYSUP_Q_AG(SCPOINT,IR,CURIYR) = PLYSUPQ_PT(IPT,IR,curiyr)
             PLYSUP_P_AG(SCPOINT,IR,CURIYR) = POLYPTP(IPT,0,CURIYR) * POLYPRMULT(IR)
             DO INTPT = 1 , INTPOINTS
                PLYSUP_Q_AG(SCPOINT - INTPOINTS + INTPT - 1,IR,CURIYR) = PLYSUP_Q_AG(SCPOINT-(INTPOINTS+1),IR,CURIYR) +      &
               ((PLYSUP_Q_AG(SCPOINT,IR,CURIYR) - PLYSUP_Q_AG(SCPOINT-(INTPOINTS+1),IR,CURIYR))/(INTPOINTS+1)) * INTPT
               PLYSUP_P_AG(SCPOINT - INTPOINTS + INTPT - 1,IR,CURIYR) = PLYSUP_P_AG(SCPOINT-(INTPOINTS+1),IR,CURIYR) +      &
               ((PLYSUP_P_AG(SCPOINT,IR,CURIYR) - PLYSUP_P_AG(SCPOINT-(INTPOINTS+1),IR,CURIYR))/(INTPOINTS+1)) * INTPT
             ENDDO
             NM_POLY_SUP_STP = SCPOINT
             write(IORNDUMP,*)  ' nm_poly_sup_stp scpoint ',nm_poly_sup_stp
            ENDDO
!
!           IF (IR .eq. 0) then
             DO ISTP = 1 , 35
         write(IORNDUMP,1022) ' curiyr irg step qty price ',curiyr,ir,istp,plysup_q_ag(istp,ir,curiyr),plysup_p_ag(istp,ir,curiyr)
             ENDDO
!           ENDIF

!           if (IR.gt.0) then
!            DO ISTP = 1 , 30
!!  FOR NOW SETTING REGIONAL QUANTITIES TO NATIONAL TOTAL * REGIONAL % LIMITS
!             PLYSUP_Q_AG(ISTP,IR,CURIYR) = PLYSUP_Q_AG(ISTP,0,CURIYR) * WDPYRGLIM(IR)/100.0
!             PLYSUP_P_AG(ISTP,IR,CURIYR) = PLYSUP_P_AG(ISTP,0,CURIYR)
!        write(IORNDUMP,1022) ' curiyr irg step qty price ',curiyr,ir,istp,plysup_q_ag(istp,ir,curiyr),plysup_p_ag(istp,ir,curiyr)
!            ENDDO
!           endif
!
1022   format(1x,A,3(i5,2x),2(f15.6,2x))
!         overwrite curiyr wdsup values with polysys values.  leave step one at zero.
!  ??remove region and year index from polysup variables???
!  store values in next year since renew runs after emm
  if (curiyr.gt.(wdpolyyr-1989)) then !don't overwrite first poly year
          IF ( IR .NE. 0 ) THEN
             DO ISTEP = 1 , NM_POLY_SUP_STP
               WDSUP_Q(ISTEP,IR,CURIYR,3) = PLYSUP_Q_AG(ISTEP,IR,CURIYR)
               WDSUP_P(ISTEP,IR,CURIYR,3) = PLYSUP_P_AG(ISTEP,IR,CURIYR)
               WDSUP_Q(ISTEP,IR,CURIYR+1,3) = PLYSUP_Q_AG(ISTEP,IR,CURIYR)
               WDSUP_P(ISTEP,IR,CURIYR+1,3) = PLYSUP_P_AG(ISTEP,IR,CURIYR)
             ENDDO
!           fill in steps between last polysys step and last wodsupp step with last polysys step values
            DO ISTEP = NM_POLY_SUP_STP + 1 , NM_BM_SUP_STP
              WDSUP_Q(ISTEP,IR,CURIYR,3) = WDSUP_Q(NM_POLY_SUP_STP,IR,CURIYR,3)
              WDSUP_P(ISTEP,IR,CURIYR,3) = WDSUP_P(NM_POLY_SUP_STP,IR,CURIYR,3)
              WDSUP_Q(ISTEP,IR,CURIYR+1,3) = WDSUP_Q(NM_POLY_SUP_STP,IR,CURIYR,3)
              WDSUP_P(ISTEP,IR,CURIYR+1,3) = WDSUP_P(NM_POLY_SUP_STP,IR,CURIYR,3)
            ENDDO


!
!!
           BASE_YEAR = 2008
           BASE_YR = 2008 - 1989
           DIST_CST = 12.0         ! 2008 $ / Ton
           PRCNT_OIL = 0.5         ! Percent of Distribution Cost Indexed by Oil Price
           CNV_FACT = 17.2         ! MMBtu / Ton
           C2 = (DIST_CST / MC_JPGDP(BASE_YR)) / CNV_FACT
           CST_87_MMBtu = (DIST_CST / MC_JPGDP(BASE_YR) * PRCNT_OIL) / CNV_FACT
!          write(iorndump,*) ' c2 ',c2
!
!          write(iorndump,*) ' adding transportation costs to polsys costs '
           DO ISTP = 1 , NM_BM_SUP_STP
!            write(iorndump,*) ' before trans add ',curiyr,ir,istp,wdsup_p(ISTP,ir,curiyr,3),cst_87_mmbtu,        &
!                                          brent_price(curiyr),brent_price(base_yr)
               WDTRANSADD(CURIYR) = (C2 * (1 - PRCNT_OIL)) + (C2 * PRCNT_OIL *       &
                                        (BRENT_PRICE(curiyr) / BRENT_PRICE(base_yr)) )
               TRANADD1 = CST_87_MMBtu *      &
                                          (BRENT_PRICE(curiyr) / BRENT_PRICE(BASE_YR))
               TRANADD2 = CST_87_MMBtu *      &
                                       ((BRENT_PRICE(curiyr) / BRENT_PRICE(base_yr)) - 1.0)
               IF (WDSUP_P(ISTP,IR,CURIYR,3) .NE. 0.0 ) THEN
                 WDSUP_P(ISTP,IR,CURIYR,3) = WDSUP_P(ISTP,IR,CURIYR,3) + WDTRANSADD(CURIYR)
                 WDSUP_P(ISTP,IR,CURIYR+1,3) = WDSUP_P(ISTP,IR,CURIYR,3) + WDTRANSADD(CURIYR)
               ENDIF

!            write(iorndump,*) ' after trans add ',curiyr,ir,ISTP,wdsup_p(ISTP,ir,curiyr,3),wdtransadd,tranadd1,tranadd2
           END DO
!         ALWAYS OVERWRITE FPH YEARS IF LASTYR TO KEEP UPDATED WITH POLYSYS VALUES
!
           IF ( CURIYR .EQ. LASTYR )  THEN
             DO IYR = CURIYR + 1, MNUMYR + ECP_D_FPH
               DO ISTP = 1 , NM_BM_SUP_STP
                 WDSUP_Q(ISTP,IR,IYR,3) = WDSUP_Q(ISTP,IR,CURIYR,3)
                 WDSUP_P(ISTP,IR,IYR,3) = WDSUP_P(ISTP,IR,CURIYR,3)
               ENDDO
             ENDDO
           ENDIF
!         endif
      endif      !end don't overwrire first poly year


         ENDIF                     ! end if irg ne 0
       ENDDO                       ! end region loop

!    adding transportation costs to corn and soy prices
!    corn and soybean prices in $/bushel so first convert back to $/tons and then to $/bushel
!      35.71 bushels shelled corn per ton, 33.33 bushels soybean per ton  conversions from USDA standards.
!    soybean oil in dollars per pound
!
        DO IR = 1 , NDREG+1
          DO IPT = 1 , WDPOLYPT
            CRNSUP_P(IPT,IR,CURIYR) = CRNSUP_P(IPT,IR,CURIYR) + (WDTRANSADD(CURIYR) * CNV_FACT / 35.71)
            SOYSUP_P(IPT,IR,CURIYR) = SOYSUP_P(IPT,IR,CURIYR) + (WDTRANSADD(CURIYR) * CNV_FACT / 33.33)
            SOYOILSUP_P(IPT,IR,CURIYR) = SOYOILSUP_P(IPT,IR,CURIYR) + (WDTRANSADD(CURIYR)  * CNV_FACT / 2000.0)
          ENDDO
        ENDDO
! write(iorndump,3892) ' trans add b c s so ',curiyr,wdtransadd(curiyr),crnsup_P(3,1,curiyr),(wdtransadd(curiyr) * cnv_fact / 35.71),    &
!            soysup_p(3,1,curiyr),wdtransadd(curiyr) * cnv_fact / 33.33, soyoilsup_p(3,17,curiyr),wdtransadd(curiyr) * cnv_fact / 2000.0
! 3892 format(a,i4,7(F10.4,1x))

       IF ( CURIYR .EQ. LASTYR )  THEN
         DO IYR = CURIYR + 1, MNUMYR + ECP_D_FPH
           DO IR = 1 , NDREG+1
             DO IPT = 1 , WDPOLYPT
               CRNSUP_TOT_Q(IPT,IR,IYR) = CRNSUP_TOT_Q(IPT,IR,CURIYR)
               CRNSUP_P(IPT,IR,IYR) = CRNSUP_P(IPT,IR,CURIYR)
               CRNSUP_ETH_Q(IPT,IR,IYR) = CRNSUP_ETH_Q(IPT,IR,CURIYR)
               SOYSUP_P(IPT,IR,IYR) = SOYSUP_P(IPT,IR,CURIYR)
               SOYSUP_TOT_Q(IPT,IR,IYR) = SOYSUP_TOT_Q(IPT,IR,CURIYR)
               SOYOILSUP_BIOD_Q(IPT,IR,IYR) = SOYOILSUP_BIOD_Q(IPT,IR,CURIYR)
               SOYOILSUP_TOT_Q(IPT,IR,IYR) = SOYOILSUP_TOT_Q(IPT,IR,CURIYR)
               SOYOILSUP_P(IPT,IR,IYR) = SOYOILSUP_P(IPT,IR,CURIYR)
             ENDDO
           ENDDO
         ENDDO
       ENDIF
!
!         write out supply schedules
!
!         if (WDDBG .eq. 1) Then
!           do iyr =  1 , MNUMYR + ecp$FPH !years
           write(IORNDUMP,1000) 1989+curiyr
             do istp = 1 , NWDSUPQ                    !supply tranches
               write(IORNDUMP,1001) curiyr,istp, (WDSUP_P(istp,IR,curiyr,3),IR = 1 , ndreg)
               write(IORNDUMP,1003) curiyr,istp, (WDSUP_Q(istp,IR,curiyr,3),IR = 1 , ndreg)
             enddo !  istp
!          enddo !  iyr

      ENDIF                      ! end polysw return code is 0
!
!         write out supply schedules ag variables
!
!         if (WDDBG .eq. 1) Then
!           do iyr =  1 , MNUMYR + ecp$FPH !years
           write(IORNDUMP,1010) 1989+curiyr
             do istp = 1 , NWDSUPQ                    !supply tranches
               write(IORNDUMP,1011) curiyr,istp, (WDSUP_P_AG(istp,IR,curiyr),IR = 1 , ndreg)
               write(IORNDUMP,1013) curiyr,istp, (WDSUP_Q_AG(istp,IR,curiyr),IR = 1 , ndreg)
             enddo !  istp
!          enddo !  iyr
!
!  test overwriting wdsup_q_ag variables for restartin file
!
!        IF (CURIYR .EQ. LASTYR) THEN
            WDSUP_P_AG(:,:,:) = WDSUP_P(:,:,:,3)
            WDSUP_Q_AG(:,:,:) = WDSUP_Q(:,:,:,3)
!        ENDIF

1000  format(//,'POLY AG ',' Year=',I6)
1010  format(//,'POLY _AG',' Year=',I6)
1001  format(1x,' POLY AG Step Prices     ',2I3,16(F13.6))
1011  format(1x,' POLY _AG Step Prices     ',2I3,16(F13.6))
1003  format(1x,' POLY AG Step Quantities ',2I3,16(F13.6))
1013  format(1x,' POLY _AG Step Quantities ',2I3,16(F13.6))
!
     RETURN
     END

! *********************************************************************
! Subroutine WDREADIN
!
! Reads in two input files containing all information on the wood
! technology.
!
! 1. input file: contains all data on cost/performance and resource
!                availability, except for the supply schedules
! 2. input file: contains the regional supply schedule for wood.
!
! Input variables:
!  Integer:
!      WDDBG      : Wood debug flag.
!                    if WDDBG=1 then   write input data to standart output
!                    if WDDBG=0 then   No reporting
!
! Local Variables:
!   Integer:
!     INUNIT      : Fortran Unit no for input file
!     WDiodbg     : unit no for debug file
!     ITECHNO     : Technology no of RFM as defined in wrenew
!                   Wood is technology No 6
!     RET_CD      : io variable (suregate)
!     RD$TBL      :\
!     RD$R2       :  io functions
!     RD$R1       :/
!     IWCLTWD     : Integer Lead time
!     i           : local counter
!     j           : local counter
!     k           : local counter
!     NCST        : Starting No of column for readin
!     NCEN      : Ending No of column for readin
!     NRow        : No of Rows
!     IYread      : Current to be read in
!
!   Real:
!     SWAPAR      : SWAPAR(MNUMYR,MNUMNR) for easy read in of all variables that
!                   are defined A(MNUMNR,MNUMYR) (i.e. Matrix transverse)
!     SWAPAR2   : SWAP array (NWDSUPP) for read in of quantities
!                   and prices
!     SWAPAR3     : SWAP array (NWDSUPP,MNUMNR) for read in of quantities
!
!   Character:
!    NAME1       : char(18) Name of input file WOODTECH
!      NAME2       : char(18) Name of input file WOODSUPPLY
!
!
! written by: Michael Kintner-Meyer
! revised:  6/6/95
! --------------------------------------------------------------------
      Subroutine WDREADIN(WDDBG)
      implicit none
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'ecpcntl'
      include 'control'
      include 'wrenew'
      include 'wwdcomon'
      include 'wrenio'
      include 'macout'
      include 'intout'
      include 'uefdout'

! ....Decleration of local variables
      REAL*8 TOT
      Integer INUNIT,WDDBG,WDIODBG,ITECHNO,i,j,k,IWCLTWD,NCST
      Integer NCEN,NRow,IYread, I_First, I_Last
      integer RET_CD,RD$TBL,RD$R2,RD$R1,RD$I1,RD$C1
      Integer FILE_MGR
      External FILE_MGR
      Real SWAPAR(MNUMYR,MNUMNR),SWAPAR2(NWDSUPP)
      Real SWAPAR3(NWDSUPP,MNUMNR)
      Character *18 NAME1,NAME2
      INTEGER*4    DMSZ
      PARAMETER (DMSZ = 300)
      CHARACTER*40 DUMMY(DMSZ)             ! DUMMY COLUMN IN DATA TABLES

      INTEGER*4 BASE_YEAR
      INTEGER*4 BASE_YR
      REAL*8    DIST_CST
      REAL*8    PRCNT_OIL
      REAL*8    CNV_FACT
      REAL*8    CST_87_MMBtu
      REAL*8    transadd,tranadd1,tranadd2,c2

      INTEGER      RTOVALUE
      EXTERNAL     RTOVALUE

      integer OLYR
      integer MEMMYR
      parameter (MEMMYR=MNUMYR+10)
      real tempar(MEMMYR,MNUMNR)! temporary variable for readin bounds
      integer fsource
      character *6 tname1
      character *4 tname2
      character *12 tabname
      character *2 fstock
      !cna - change tname1 from a fixed wdsup to a variable name agsup frsup etc.
      data tname1 /'SUP'/

      integer nemsyr,polyres,ipt,ir

      data NAME1,NAME2/'WODTECH','WODSUPP'/
      data ITECHNO /6/

! ...... Debug File assignment
      if(WDDBG.eq.1) Then
         WDiodbg=6
      else
         WDiodbg=0
      endif

      INUNIT=FILE_MGR('O',NAME1,.FALSE.)

! ...... Read in Fuel adjustment switch
      RET_CD=RD$TBL(INUNIT,'%WDSWITCH_1%',1,WDiodbg,6)
      RET_CD=RD$I1(WOODSW1,1,1)

! ...... Read in Fuel adjustment coefficient
      RET_CD=RD$TBL(INUNIT,'%WDADJCOEFF%',1,WDiodbg,6)
      RET_CD=RD$R1(WFUELAdj,1,1)

! ...... Read in Variable O&M cost into WDVADD(1,year)
      RET_CD=RD$TBL(INUNIT,'%WDTECHIN_8%',MNUMYR,WDiodbg,6)
      RET_CD=RD$R2(SWAPAR,1,1,2,MNUMYR,MNUMNR)
! ...... Swap Arrays SWAPAR -> WDVCALL
      do j=1,MNUMYR
          WDVCADD(j)  =SWAPAR(j,2)
          WVCBMEL(j) = WDVCADD(j)
!         WRITE(6,1010) CURIRUN,CURIYR+1989,CURITR,J+1989, WDVCADD(j),SWAPAR(j,2), WVCBMEL(j), WDVCADD(j)
!1010     FORMAT(1X,"WDTECHIN_8",4(":",I4),4(":",F12.3))
      enddo


! ...... Read in Heat Rate into WHRBMEL(1,year)
      RET_CD=RD$TBL(INUNIT,'%WDTECHIN_9%',MNUMYR,WDiodbg,6)
      RET_CD=RD$R2(SWAPAR,1,1,3,MNUMYR,MNUMNR)
! ...... Swap Arrays SWAPAR -> WHRBMEL
      do j=1,MNUMYR
!mkm          WHRBMEL(1,j)=SWAPAR(j,2)
          WHRIGCC(j)  =SWAPAR(j,3)
!         WRITE(6,1011) CURIRUN,CURIYR+1989,CURITR,J+1989, WHRIGCC(j), SWAPAR(j,3)
!1011     FORMAT(1X,"WDTECHIN_9",4(":",I4),2(":",F12.3))
      enddo

! ...... Read in Mapping Matrix to map Census into NERC
      RET_CD=RD$TBL(INUNIT,'%CDTOCLWDT1%',NDREG,WDiodbg,6)
      RET_CD=RD$R2(CDTOCL,1,1,MNUMCR,NDREG,MNUMCR)

! ...... Read in Capacity bound
      RET_CD=RD$TBL(INUNIT,'%WDTECHIN11%',MNUMYR+5,WDiodbg,6)
      RET_CD=RD$R2(TEMPAR,1,1,unrgns,MEMMYR,MNUMNR)
! ...... Swap Arrays TEMPAR -> WCABMEL
      do j=1,MNUMYR
! ...... use ECP's variable for leadtime (BM= WIWD technology)
         IF (EXE .EQ. 1) THEN
            OLYR=j+UPPLYR(WIWD)+1
         ELSE
            OLYR = 1
         END IF
         do i=1,unrgns
          WDCAP(i,j)=TEMPAR(OLYR,i)
         enddo
!         WRITE(6,1012) CURIRUN,CURIYR+1989,CURITR,J+1989, OLYR,( WDCAP(i,j),i=1,unrgns)
!1012     FORMAT(1X,"WDTECHIN_11",5(":",I4),13(":",F12.3))
      enddo

! ...... Read in Fraction repr. NON-CAPTIVE markets in industrial Sec.
      RET_CD=RD$TBL(INUNIT,'%WDTECHIN12%',1,WDiodbg,6)
      RET_CD=RD$R1(NoCapIN,1,1)

! ...... Read in Threshold for invoking no buid period
      RET_CD=RD$TBL(INUNIT,'%WDTECHIN13%',1,WDiodbg,6)
      RET_CD=RD$R1(WDTHRES,1,1)

! ...... Read in no build period duration
      RET_CD=RD$TBL(INUNIT,'%WDTECHIN14%',1,WDiodbg,6)
      RET_CD=RD$I1(WDNOTBLDT,1,1)

! ...... Read last yr of phase-in period for biomass cofiring
      RET_CD=RD$TBL(INUNIT,'%WDCOFPHS  %',1,WDiodbg,6)
      RET_CD=RD$I1(WDCFPHS,1,1)

! ...... Read first yr,last yr and amount of prod. subsidy for biomass cofiring
      RET_CD=RD$TBL(INUNIT,'%WDCOFSUB  %',MNUMYR,WDiodbg,6)
      RET_CD=RD$R2(SWAPAR,1,1,2,MNUMYR,MNUMNR)
! ...... Swap Arrays SWAPAR -> WDVCALL
      do j=1,MNUMYR
          WDCFSUB(j)  =SWAPAR(j,2)
!         WRITE(6,1013) CURIRUN,CURIYR+1989,CURITR,J+1989,WDCFSUB(J),SWAPAR(J,2)
!1013     FORMAT(1X,"WDCFSUB",4(":",I4),2(":",F12.3))
      enddo

! ...... Read in Cofiring Hurdle Cost into WDCFHUR(year)
      RET_CD=RD$TBL(INUNIT,'%WDCOFHURDL%',MNUMYR,WDiodbg,6)
      RET_CD=RD$R2(SWAPAR,1,1,2,MNUMYR,MNUMNR)
! ...... Swap Arrays SWAPAR -> WDVCALL
      do j=1,MNUMYR
          WDCFHUR(j)  =SWAPAR(j,2)
      enddo
!
! ...... Read in Polysys parameters
!
      RET_CD=RD$TBL(INUNIT,'%WD POLY SW%',1,WDiodbg,6)
      RET_CD = RD$C1(DUMMY,1,DMSZ)
!     RET_CD = RD$I1(WDPOLYSW,1,1)    ! Polysys run switch  This switch is now a runtime switch 'runpoly'
      RET_CD = RD$I1(WDRDWDSUP,1,1)   ! Polysys restart values switch
      RET_CD = RD$I1(WDPOLYYR,1,1)    ! Year to start running polysys
      RET_CD = RD$I1(WDPOLYPT,1,1)    ! Number of time to run polysys
      RET_CD = RD$I1(WDPSCCALC,1,1)   ! Calculation method for points around initial polysys point
!     RET_CD = RD$I1(WDPOLYCM,1,1)    ! Price cost multiplier for side cases, default 1
!
!    SET WDPOLYR TO UESTYR
!     WDPOLYYR = UESTYR
!      write(IORNDUMP,*) ' polyrestart polyyr polypt scalc ',wdrdwdsup,wdpolyyr,wdpolypt,wdpsccalc
!
      RET_CD=RD$TBL(INUNIT,'%WDPOLYSCCVAL%',1,WDiodbg,6)
      RET_CD = RD$C1(DUMMY,1,DMSZ)
      RET_CD = RD$R2(WDPSCCVAL,1,1,WDPOLYPT,1,WDPOLYPT)         ! polysys point calculation values
!      write(6,*) ' wdpsccval ',(wdpsccval(ipt),ipt=1,wdpolypt)
!
      RET_CD=RD$TBL(INUNIT,'%WDPOLYRGLIM%',NDREG,WDiodbg,6)
      RET_CD = RD$C1(DUMMY,1,DMSZ)
      RET_CD = RD$R1(WDPYRGLIM,1,NDREG)         ! regional percentage limits of supply curve quantitie
!      do i = 1 , ndreg
!      write(6,*) ' wdpyrglim ',i,wdpyrglim(i)
!     enddo

!
      INUNIT=FILE_MGR('C',NAME1,.FALSE.)

! .....................................................................
! ...... Read in wood supply .

      INUNIT=FILE_MGR('O',NAME2,.FALSE.)
!
      WDPOLYSW = RTOVALUE('RUNPOLY ',0)
!    write(6,*) ' runpoly rtovalue ',wdpolysw

!     Read in Biomass Supply Schedules - 1990
!     cna - need to cycle through 4 supply schedules here
!     Create Variables which Determine First Year and Last Year of Schedules in WODSUP file
!     IF using polysys values from restart file do not overwrite wdsup AG variables with wodsup.txt values
!     IF not first run of cycle for a polysys run set polysys restart file switch to 1

      IF ( ( CURIRUN .NE. 1 ) .AND. ( WDPOLYSW .NE. 0 ) ) WDRDWDSUP = 1
         write(IORNDUMP,*) ' curirun wdpolysw wdrdwdsup polyres ',curirun,wdpolysw,wdrdwdsup,polyres

      IF ( WDRDWDSUP .EQ. 0 ) THEN
         WDSUP_Q = 0.0
         WDSUP_P = 99.999
      ELSE
         WDSUP_Q(:,:,:,1) = 0.0
         WDSUP_P(:,:,:,1) = 99.999
         WDSUP_Q(:,:,:,2) = 0.0
         WDSUP_P(:,:,:,2) = 99.999
         WDSUP_Q(:,:,:,4) = 0.0
         WDSUP_P(:,:,:,4) = 99.999
      ENDIF

      RET_CD = RD$TBL(INUNIT,'%BM Supply %',1,WDiodbg,6)
      RET_CD = RD$I1(I_First,1,1)
      RET_CD = RD$I1(I_Last,1,1)
      RET_CD = RD$I1(NCST,1,1)
      RET_CD = RD$I1(NCEN,1,1)
      RET_CD = RD$I1(NRow,1,1)
      RET_CD = RD$I1(BM_FS_SW,1,1)

      NM_BM_SUP_STP = NRow

      do fsource = 1,mnumfs
         POLYRES = 0
         IYread = 1
         fstock = BM_TYP_CD(fsource)
         tabname='%'//fstock//'SUP1990 %'

         IF ( ( fstock .eq. 'AG') .and. ( WDRDWDSUP .eq. 1 ) .AND. ( WDPOLYSW .eq. 1 ) ) polyres = 1
!        IF ( ( fstock .eq. 'UM') .and. ( WDRDWDSUP .eq. 1 ) ) polyres = 1
            write(IORNDUMP,*) ' curirun wdpolysw wdrdwdsup polyres ',fstock,curirun,wdpolysw,wdrdwdsup,polyres

         RET_CD = RD$TBL(INUNIT,tabname,NRow,WDiodbg,6)
         RET_CD = RD$R1(SWAPAR2,1,NWDSUPP)
         RET_CD = RD$R2(SWAPAR3,1,NCST,NCEN-NCST+1,NWDSUPP,NDREG)   ! Read in for 16 Coal regions
!
         IF ( POLYRES .EQ. 0 ) THEN
            write(iorndump,*) ' inside woodsup overwrite if curirun wdpolysw wdrdwdsup ',fstock,curirun,wdpolysw,wdrdwdsup
            do j = NCST , NDREG
               do i = 1 , NRow
                  WDSUP_Q(i,j,IYread,fsource) = SWAPAR3(i,j)
                  WDSUP_P(i,j,IYread,fsource) = SWAPAR2(i)
               enddo !i
            enddo !j

!          Fill up the Supply arrays for the years 1991 - 2009 with 1990 values
!          cna - cycle through supply shedules here (outer loop)
            do i = 2 , I_First - 1
               do j = 1,NWDSUPP
                  do k = NCST , NCEN
                     WDSUP_P(j,k,i,fsource) = WDSUP_P(j,k,1,fsource)
                  enddo !k
               enddo !j
               do j = 1,NWDSUPQ
                  do k = NCST , NCEN
                     WDSUP_Q(j,k,i,fsource) = WDSUP_Q(j,k,1,fsource)
                  enddo !k
               enddo !j
            enddo !i
         ENDIF                               ! end polysys restart file if

!        Read in NERC supply schedule from I_First and I_Last as defined in WODSUPP.txt
         do IYread = I_First , I_Last
            nemsyr = 1989 + IYread
            write(tname2,'(I4)')nemsyr
            tabname='%'//fstock//'SUP'//tname2//' %'
            RET_CD = RD$TBL(INUNIT,tabname,NRow,WDiodbg,6)
            RET_CD = RD$R1(SWAPAR2,1,NWDSUPP)
            RET_CD = RD$R2(SWAPAR3,1,NCST,NCEN-NCST+1,NWDSUPP,NDREG)

!         IF using polysys values from restart file do not overwrite wdsup AG variables with wodsup.txt values
            IF ( POLYRES .EQ. 0 ) THEN
               do j = NCST , NDREG
                  do i = 1 , NRow
                     WDSUP_Q(i,j,IYread,fsource) = SWAPAR3(i,j)
                     WDSUP_P(i,j,IYread,fsource) = SWAPAR2(i)
                  enddo
               enddo
            ENDIF                               ! end polysys restart file if
         enddo

!         Fill up supply arrays for years after I_Last
!         IF using polysys values from restart file do not overwrite wdsup AG variables with wodsup.txt values
         IF ( POLYRES .EQ. 0 ) THEN
            DO I = I_Last , MNUMYR + ECP_D_FPH
               DO J = 1 , NRow
                  DO K = NCST , NCEN
                     WDSUP_Q(J,K,I,fsource) = WDSUP_Q(j,k,I_Last,fsource)
                     WDSUP_P(J,K,I,fsource) = WDSUP_P(J,k,I_Last,fsource)
                  ENDDO
               ENDDO
            ENDDO

!           Revise Supply Price as Function of World Oil Price
            BASE_YEAR = 2008
            BASE_YR = 2008 - 1989
            DIST_CST = 12.0         ! 2008 $ / Ton
            PRCNT_OIL = 0.5         ! Percent of Distribution Cost Indexed by Oil Price
            CNV_FACT = 17.2         ! MMBtu / Ton
            C2 = (DIST_CST / MC_JPGDP(BASE_YR)) / CNV_FACT
            CST_87_MMBtu = (DIST_CST / MC_JPGDP(BASE_YR) * PRCNT_OIL) / CNV_FACT
!          write(iorndump,*) ' c2 ',c2
!          write(iorndump,*) ' adding transportation costs to all biomass supply costs '
            DO I = BASE_YR + 1 , MNUMYR
               DO J = 1 , NRow
                  DO K = NCST , NCEN
!            write(iorndump,*) ' before trans add ',i,k,j,wdsup_p(j,k,i,fsource),cst_87_mmbtu,c2,     &
!                                          brent_price(i),brent_price(base_yr)
                     TRANSADD = (C2 * (1 - PRCNT_OIL)) + (C2 * PRCNT_OIL *       &
                                        (BRENT_PRICE(I) / BRENT_PRICE(base_yr)) )
                     TRANADD1 = CST_87_MMBtu *      &
                                          (BRENT_PRICE(I) / BRENT_PRICE(BASE_YR))
                     TRANADD2 = CST_87_MMBtu *      &
                                       ((BRENT_PRICE(I) / BRENT_PRICE(base_yr)) - 1.0)
                     IF (WDSUP_P(j,k,I,fsource) .NE. 0.0 ) THEN
                        WDSUP_P(j,k,I,fsource) = WDSUP_P(j,k,I,fsource) + TRANSADD
                     ENDIF
!            write(iorndump,*) ' after trans add ',i,k,j,wdsup_p(j,k,i,fsource),transadd,tranadd1,tranadd2
                  END DO !K
               END DO    !J
            END DO       !I
!
            DO I = MNUMYR + 1 , MNUMYR + ECP_D_FPH
               DO J = 1 , NRow
                  DO K = NCST , NCEN
                     WDSUP_P(J,k,I,fsource) = WDSUP_P(J,k,MNUMYR,fsource)
                  END DO
               END DO
            END DO
         ENDIF                               ! end polysys restart file if

!        write out supply schedules
         if (WDDBG .eq. 1) Then
            do i = 1 , MNUMYR + ECP_D_FPH !years
!               write(IORNDUMP,1000) fstock, 1989+i   ! mas, 4/12/2024
               do j = 1 , NWDSUPQ                    !supply tranches
                  write(IORNDUMP,1001) fstock, 1989+i, j, (WDSUP_P(j,k,i,fsource),k=1,16)
                  write(IORNDUMP,1003) fstock, 1989+i, j, (WDSUP_Q(j,k,i,fsource),k=1,16)
               enddo !j
            enddo !i
            do i = 1 , mnumfs
               write(IORNDUMP,1002) i, BM_TYP_CD(i), MP_BM_RS(i), MP_BM_CM(i), MP_BM_IN(i), MP_BM_PW(i), MP_BM_ET(i), MP_BM_BT(i)
1002  format('Feedstock Utilization:',I2,':',A2,':RS=',F8.3,':CM=',F8.3,':IN=',F8.3,':PW=',F8.3,':ET=',F8.3,':BT=',F8.3)
            enddo !i
         endif
      enddo !fsource

!         write out supply schedules
          if (WDDBG .eq. 1) Then
            do i = 1 , MNUMYR + ECP_D_FPH !years
!            write(IORNDUMP,1010) 'UM',1989+i
               do j = 1 , NWDSUPQ                    !supply tranches
                  write(IORNDUMP,1011) 'UM', 1989+i, j, (WDSUP_P_UM(j,k,i),k=1,16)
                  write(IORNDUMP,1013) 'UM', 1989+i, j, (WDSUP_Q_UM(j,k,i),k=1,16)
               enddo !j
            enddo !i
          endif


!     Check if supply schedule is available

      DO fsource = 1 , MNUMFS
         TOT = 0.0
         DO I = I_First , I_Last
            DO K = NCST , NCEN
               DO J = 1 , NRow
                  TOT = TOT + WDSUP_Q(J,K,I,fsource)
               ENDDO
            ENDDO
         ENDDO
         IF (TOT .EQ. 0.0) THEN
            WDSUP_AVL(fsource) = 0
         ELSE
            WDSUP_AVL(fsource) = 1
         END IF
      END DO


1000  format(//,A2,' Year=',I6)
1001  format('WDSUP_P:', A2,' Year=',I6,1x,' Step Prices     ',I3,16(F10.3))
1003  format('WDSUP_Q:', A2,' Year=',I6,1x,' Step Quantities ',I3,16(F10.3))
1010  format(//,'_',A2,' Year=',I6)
1011  format('WDSUP_P_UM', A2,' Year=',I6,1x,' _UM Step Prices     ',I3,16(F10.3))
1013  format('WDSUP_Q_UM', A2,' Year=',I6,1x,' _UM Step Quantities ',I3,16(F10.3))

      INUNIT=FILE_MGR('C',NAME2,.FALSE.)

      return
      end


! *********************************************************************
!  Subroutine Wdinitial
!
!  Subroutine initializes local values used in the Wood submodule.
!  In particular, it does the following:
!   1. zero the supply schedules NWDSUPP and NWDSUPQ
!   2. initializes xummulative builds
!   3. initializes the 'new build' flag array
!
!  Subroutine uses common block 'wwood'.
!
!
!
!     Local Variables
!
!     Integer:
!       i         : generic counter
!       j         : generic counter
!       iyr       : year counter
!       inr       : NERC region counter
!       MNNREFF   : effective NERC regions (=13)
!       MNYREFF   : effective years (1990 - 2015 =>26)
!
!
!     Real:
!
! written by: Michael Kintner-Meyer
! revised   : 8/22/95
! ----------------------------------------------------------------------
      Subroutine Wdinitial
      implicit none

      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'control'
      include 'wrenew'
      include 'wwdcomon'
      include 'uefdout'

! ...... Declaration of local variables
      integer i,j,iyr,inr,MNNREFF

      MNNREFF=unrgns
      WDTRANSADD = 0

! ...... initialize the supply schedule arrays
      do iyr=1,MNUMYR
         do inr=1,NDREG
            do i=1,NWDSUPQ
              do j=1,mnumfs
               WDSUPQ(inr,iyr,i,j)=0.
              enddo !j
            enddo !i
         enddo !inr
         do i=1,NWDSUPP
           do j=1,mnumfs
            WDSUPP(iyr,i,j)=0.
           enddo !j
        enddo !i
      enddo !iyr

! ...... initialize the cumulative builds
      do i=1,MNUMNR
         do j=1,MNUMYR
            CumWdBld(i,j)=0.0
         enddo
      enddo


! ...... initialize the WDNEWBLD
      do i=1,MNNREFF
         do j=1,MNUMYR
            WDNEWBLD(i,j)=.true.
         enddo
      enddo

      return
      end



! *********************************************************************
!  Subroutine Wdvalass
!
!  Subroutine assigns values for all years and regions.
!  In particular, it does the following:
!
!   1. Assigns cost/performance values to all regions and years.
!   2. preassigns the maximal bound by regions and year for max. capacity
!      derived from the maximal values of NWDSUPQ and max. value from the
!      exogenously read-in capacity, whichever is the smallest.
!
!  Subroutine uses common block 'wwood'.
!
!
!
!     Local Variables
!
!     Integer:
!       i         : generic counter
!       j         : generic counter
!       iyr       : year counter
!       inr       : NERC region counter
!       MNNREFF   : effective NERC regions (=13)
!       MNYREFF   : effective years (1990 - 2015 =>26)
!
!
!     Real:
!        SUPWDNR  : supply quantity array for 1 NERC and Year in [TBTU]
!        MaxCap   : Max. capacity evaluated from supply schedule in [GW]
!        Maxtbl   : Function returns the max. value in an 1-dim. array

! written by: Michael Kintner-Meyer
! revised   : 8/22/95
! ----------------------------------------------------------------------
      Subroutine Wdvalass
      implicit none

      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'control'
      include 'wrenew'
      include 'wwdcomon'
      include 'uefdout'

! ...... Declaration of local variables
      integer iyr,inr
!
      do iyr=1,MNUMYR
         do inr=1,UNRGNS
            WCABMEL(inr,iyr)=WDCAP(inr,iyr)

!           WRITE(6,5555) CURIRUN, CURIYR+1989, CURITR, iyr+1989, inr, WDCAP(INR,IYR)
 5555       FORMAT(1X,"WDCAP",5(":",I4),":",F15.3)

         enddo
      enddo

      return
      end


! *********************************************************************
!                    END OF WOOD SUBMODULE
! *********************************************************************





! **************************************************************************
!
!
!     ####    ####   #         ##    #####
!    #       #    #  #        #  #   #    #
!     ####   #    #  #       #    #  #    #
!         #  #    #  #       ######  #####
!    #    #  #    #  #       #    #  #   #
!     ####    ####   ######  #    #  #    #
!
! **************************************************************************


      SUBROUTINE SOLAR
      IMPLICIT NONE
!
!=============================================================================
! SOLES: This program pass the fixed operating costs, variable operating costs,
!        capital costs, contruction leadtime, the fraction of capital costs of
!        construction and the derating factor of the resource by time period
!        separately to both the EFP and ECP.
!=============================================================================
!
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'ecpcntl'
      include 'control'
      include 'wrenew'
      include 'wwind'
      include 'wrenio'
      include 'dsmdimen'
      include 'dsmcaldr'
      include 'uefdout'

      integer nr               ! number of regions
      integer ny               ! number of year
      integer np               ! number of time period

      integer MEMMYR           ! No of EMM years for renewables

      parameter (MEMMYR=MNUMYR+10)

      real tempar(MEMMYR,MNUMNR)! temporary variable for readin lower bounds

      Real dummy,Rdummy(MNUMYR)
      integer iunit1
      integer i,j,k,d,m,h,n ,t             ! index variables

      external file_mgr
      integer file_mgr
      character*20    infile1

      INTEGER OLYR,IJ,IX,IY
      INTEGER tempyr,temphrs(1,24),tmpMonth(12),HrCols,numYrBlks,yblk
      INTEGER CFYRS(MNUMYR)

      INTEGER RD$TBL,RD$R1,RD$R2,RD$I1 , RD$I2   ! Table read functions.
      INTEGER RET_CD             ! Return code from table reads
      CHARACTER*12 TABNAME       ! Storage for name of table to read
      CHARACTER*6 IDUMMY
      REAL TEMPDATA(MNUMYR,8)    ! Storage for technology table data
      REAL TEMPDAT1(MNUMYR,9)    ! Storage for capacity factor table data
      REAL TEMPDAT2(7:8,8)       ! Storage for schedule table data
      REAL TEMPDATCF(12,24)      ! Storage for capacity factor table data
      REAL CF24(24), CInc
      integer yr,wc
      INTEGER RTOVALUE
      EXTERNAL RTOVALUE

      if (CURCALYR.eq.UESTYR .and. CURITR.eq.1) then
         infile1 = 'SOLARIN'
         iunit1 = file_mgr('O',infile1,.false.)

! ........ read in efficiency multiplier applied to the capacity factors
           RET_CD=RD$TBL(IUNIT1,'%SOLEFF    %',MNUMYR,1,6)
           RET_CD=RD$R1(Rdummy,1,MNUMYR)
           RET_CD=RD$R1(EFFMULST,1,MNUMYR)
           RET_CD=RD$R1(EFFMULPV,1,MNUMYR)
           RET_CD=RD$R1(EFFMULPT,1,MNUMYR)


! -------- read in new capacity factors
        DO IJ=1,4
           IF (IJ.EQ.1) THEN
             IX = 1
             IY = IJUMPEMRGN
           ELSEIF (IJ .EQ. 2) THEN
            IF (IJUMPEMRGN.EQ.13) THEN
             IX=14
             IY=14
            ELSEIF (IJUMPEMRGN.EQ.22) THEN
             IX=23
             IY=23
            ELSEIF (IJUMPEMRGN.EQ.25) THEN
             IX=26
             IY=26
            ENDIF
           ELSEIF (IJ .EQ. 3) THEN
            IF (IJUMPEMRGN.EQ.13) THEN
             IX=15
             IY=15
            ELSEIF (IJUMPEMRGN.EQ.22) THEN
             IX=24
             IY=24
            ELSEIF (IJUMPEMRGN.EQ.25) THEN
             IX=27
             IY=27
            ENDIF
           ELSEIF (IJ .EQ. 4) THEN
            IF (IJUMPEMRGN.EQ.13) THEN
             IX=16
             IY=16
            ELSEIF (IJUMPEMRGN.EQ.22) THEN
             IX=25
             IY=25
            ELSEIF (IJUMPEMRGN.EQ.25) THEN
             IX=28
             IY=28
            ENDIF
           ENDIF
         do nr=IX,IY                ! read for each region
            WRITE (TABNAME,'(A3,I1,I1,A7)') '%ST',NR/10,MOD(NR,10),'YEARS %'
            RET_CD = RD$TBL(IUNIT1,TABNAME,1,1,6)
            RET_CD = RD$I1(numYrBlks,1,1)         ! number of year blocks for this region's ST

            do yblk=1,numYrBlks
            WRITE (TABNAME,'(A3,I1,I1,A7)') '%ST',NR/10,MOD(NR,10),'PARAMS%'
            RET_CD = RD$TBL(IUNIT1,TABNAME ,1,1,6)
            RET_CD = RD$I1(tempyr,1,1)           ! year for data block
            RET_CD = RD$I1(HrCols,1,1)           ! number of hour columns
            CFYRS(yblk) = tempyr - 1989

           !read(iunit1,*)(temphrs(1,i),i=1,HrCols)
            WRITE (TABNAME,'(A3,I1,I1,A7)') '%ST',NR/10,MOD(NR,10),'HRS   %'
            RET_CD = RD$TBL (IUNIT1,TABNAME, 1,1,6)  ! Identify input table
            RET_CD = RD$I2(temphrs,1,1,HrCols,1,HrCols)           ! hours for data

            WRITE (TABNAME,'(A3,I1,I1)') '%ST',NR/10,MOD(NR,10)
            RET_CD = RD$TBL (IUNIT1, TABNAME, 12,1,6)  ! Identify input table
            RET_CD = RD$I1(tmpMonth,1,12)           ! month of data
            RET_CD = RD$R2 (TEMPDATCF,1,1,HrCols,12,HrCols)   ! Read the capacity factor table
 !
 !          if last hour column is not for hour 24, add a column for hr 24
 !
            if (HrCols .lt. 24 .and. temphrs(1,HrCols) .ne. 24) then
               HrCols = HrCols + 1
               temphrs(1,HrCols) = 24
               do j=1,12             !for each month
                  TEMPDATCF(j,HrCols) = TEMPDATCF(j,HrCols-1)
               enddo
            endif
!
           do j=1,12         ! for each month
!
!            fill in all 24 hours of data
!
             do i=1,HrCols
                CF24(temphrs(1,i)) = TEMPDATCF(j,i)
                if (i .LT. HrCols) then
                  if (temphrs(1,i) .ge. temphrs(1,i+1)) then
                     write(*,*)'Error in Solarin File - ST cap factors, Rgn ',nr
                     stop
                  endif
                  if (temphrs(1,i) .lt. (temphrs(1,i+1)-1)) then
                     do k= temphrs(1,i)+1, temphrs(1,i+1)-1
                        CF24(k) = TEMPDATCF(j,i)
                     enddo
                  endif
                endif
             enddo    !HrCols
!
!            multiply by annual factor and fill in for all 3 daytypes
!
            ny=CFYRS(yblk)
            do d=1,3
               do k=1,24
                  WSSSTEL_CF(nr,ny,d,j,k) = CF24(k)*EFFMULST(NY)
               enddo
            enddo    ! daytypes

           enddo               !  months
         enddo            !yr block

!        after all the year blocks have been read in  for ST in a region
!        back fill data from 1st year block to 1990, then, 'forward' fill in all other years
!
        if (CFYRS(1) .gt. 1) then
         do ny = CFYRS(1)-1, 1,  -1
            do d=1,3
              do j=1,12
               do k=1,24
                  WSSSTEL_CF(nr,ny,d,j,k) =  WSSSTEL_CF(nr,CFYRS(1),d,j,k)
               enddo
            enddo
         enddo
         enddo
        endif
!
        if (NumYrBlks .gt. 1) then
         do yblk = 1, NumYrBlks - 1
            do ny = CFYRS(yblk), CFYRS(yblk+1) - 2
             do d=1,3
              do j=1,12
               do k=1,24
                  WSSSTEL_CF(nr,ny+1,d,j,k) =  WSSSTEL_CF(nr,ny,d,j,k)
               enddo
              enddo
            enddo
          enddo
         enddo
        endif
!
!      if last year block was not MNUMYR, forward fill out to MNUMYR
!
         if (CFYRS(NumYrBlks) .ne. MNUMYR) then
          do ny = CFYRS(NumYrBlks)+1, MNUMYR
            do d=1,3
              do j=1,12
               do k=1,24
                  WSSSTEL_CF(nr,ny,d,j,k) =  WSSSTEL_CF(nr,CFYRS(numYrBlks),d,j,k)
               enddo
              enddo
            enddo
          enddo
         endif

!
!          Read in PV data for this region
!
            WRITE (TABNAME,'(A3,I1,I1,A7)') '%PV',NR/10,MOD(NR,10),'YEARS %'
            RET_CD = RD$TBL(IUNIT1,TABNAME,1,1,6)
            RET_CD = RD$I1(numYrBlks,1,1)         ! number of year blocks for this region's PV
           do yblk=1,numYrBlks
            WRITE (TABNAME,'(A3,I1,I1,A7)') '%PV',NR/10,MOD(NR,10),'PARAMS%'
            RET_CD = RD$TBL(IUNIT1,TABNAME ,1,1,6)
            RET_CD = RD$I1(tempyr,1,1)           ! year for data block
            RET_CD = RD$I1(HrCols,1,1)           ! number of hour columns
            CFYRS(yblk) = tempyr - 1989

           !read(iunit1,*)(temphrs(1,i),i=1,HrCols)
            WRITE (TABNAME,'(A3,I1,I1,A7)') '%PV',NR/10,MOD(NR,10),'HRS   %'
            RET_CD = RD$TBL (IUNIT1,TABNAME, 1,1,6)  ! Identify input table
            RET_CD = RD$I2(temphrs,1,1,HrCols,1,HrCols)           ! hours for data

            WRITE (TABNAME,'(A3,I1,I1)') '%PV',NR/10,MOD(NR,10)
            RET_CD = RD$TBL (IUNIT1, TABNAME, 12,1,6)  ! Identify input table
            RET_CD = RD$I1(tmpMonth,1,12)           ! month of data
            RET_CD = RD$R2 (TEMPDATCF,1,1,HrCols,12,HrCols)   ! Read the capacity factor table
 !
 !          if last hour column is not for hour 24, add a column for hr 24
 !
            if (HrCols .lt. 24 .and. temphrs(1,HrCols) .ne. 24) then
               HrCols = HrCols + 1
               temphrs(1,HrCols) = 24
               do j=1,12             !for each month
                  TEMPDATCF(j,HrCols) = TEMPDATCF(j,HrCols-1)
               enddo
            endif
!
           do j=1,12            ! for each month
!
!            fill in all 24 hours of data
!
             do i=1,HrCols
                CF24(temphrs(1,i)) = TEMPDATCF(j,i)
                if (i .LT. HrCols) then
                  if (temphrs(1,i) .ge. temphrs(1,i+1)) then
                     write(*,*)'Error in Solarin File - PV cap factors, Rgn ',nr
                     stop
                  endif
                  if (temphrs(1,i) .lt. (temphrs(1,i+1)-1)) then
                     do k= temphrs(1,i)+1, temphrs(1,i+1)-1
                        CF24(k) = TEMPDATCF(j,i)
                     enddo
                  endif
                endif
             enddo
!
!            multiply by annual factor and fill in for all 3 daytypes
!
            ny=CFYRS(yblk)
             do d=1,3
               do k=1,24
                  WSSPVEL_CF(nr,ny,d,j,k) = CF24(k)*EFFMULPV(NY)

               enddo
             enddo      !daytypes

           enddo     ! months
         enddo     ! yr block
!
!        after all the year blocks have been read in  for PV in a region
!        back fill data from 1st year block to 1990, then, 'forward' fill in all other years
!
        if (CFYRS(1) .gt. 1) then
         do ny = CFYRS(1)-1, 1,  -1
            do d=1,3
              do j=1,12
               do k=1,24
                  WSSPVEL_CF(nr,ny,d,j,k) =  WSSPVEL_CF(nr,CFYRS(1),d,j,k)

               enddo
              enddo
            enddo
         enddo
        endif
!
        if (NumYrBlks .gt. 1) then
         do yblk = 1, NumYrBlks - 1
            do ny = CFYRS(yblk), CFYRS(yblk+1) - 2
             do d=1,3
              do j=1,12
               do k=1,24
                  WSSPVEL_CF(nr,ny+1,d,j,k) =  WSSPVEL_CF(nr,ny,d,j,k)

               enddo
              enddo
            enddo
          enddo
         enddo
        endif
!
!      if last year block was not MNUMYR, forward fill out to MNUMYR
!
         if (CFYRS(NumYrBlks) .ne. MNUMYR) then
          do ny = CFYRS(NumYrBlks)+1, MNUMYR
            do d=1,3
              do j=1,12
               do k=1,24
                  WSSPVEL_CF(nr,ny,d,j,k) =  WSSPVEL_CF(nr,CFYRS(numYrBlks),d,j,k)

               enddo
              enddo
            enddo
          enddo
         endif

!        ny = 27
!        DO m = 1, 12
!           DO d = 1, 3
!              WRITE(6,1516) CURIRUN, CURIYR+1989, ny+1989, nr, m, d, (WSSPVEL_CF(nr,ny,d,m,h),h=1,24)
!1516          FORMAT(1X,"CF_PV",6(":",I4),24(":",F6.3))
!           END DO
!        END DO

!          Read in  PV Fixed Tilt (PT) data for this region

            WRITE (TABNAME,'(A3,I1,I1,A7)') '%PT',NR/10,MOD(NR,10),'YEARS %'
            RET_CD = RD$TBL(IUNIT1,TABNAME,1,1,6)
            RET_CD = RD$I1(numYrBlks,1,1)         ! number of year blocks for this region's PV
           do yblk=1,numYrBlks
            WRITE (TABNAME,'(A3,I1,I1,A7)') '%PT',NR/10,MOD(NR,10),'PARAMS%'
            RET_CD = RD$TBL(IUNIT1,TABNAME ,1,1,6)
            RET_CD = RD$I1(tempyr,1,1)           ! year for data block
            RET_CD = RD$I1(HrCols,1,1)           ! number of hour columns
            CFYRS(yblk) = tempyr - 1989

           !read(iunit1,*)(temphrs(1,i),i=1,HrCols)
            WRITE (TABNAME,'(A3,I1,I1,A7)') '%PT',NR/10,MOD(NR,10),'HRS   %'
            RET_CD = RD$TBL (IUNIT1,TABNAME, 1,1,6)  ! Identify input table
            RET_CD = RD$I2(temphrs,1,1,HrCols,1,HrCols)           ! hours for data

            WRITE (TABNAME,'(A3,I1,I1)') '%PT',NR/10,MOD(NR,10)
            RET_CD = RD$TBL (IUNIT1, TABNAME, 12,1,6)  ! Identify input table
            RET_CD = RD$I1(tmpMonth,1,12)           ! month of data
            RET_CD = RD$R2 (TEMPDATCF,1,1,HrCols,12,HrCols)   ! Read the capacity factor table
 !
 !          if last hour column is not for hour 24, add a column for hr 24
 !
            if (HrCols .lt. 24 .and. temphrs(1,HrCols) .ne. 24) then
               HrCols = HrCols + 1
               temphrs(1,HrCols) = 24
               do j=1,12             !for each month
                  TEMPDATCF(j,HrCols) = TEMPDATCF(j,HrCols-1)
               enddo
            endif
!
           do j=1,12            ! for each month
!
!            fill in all 24 hours of data
!
             do i=1,HrCols
                CF24(temphrs(1,i)) = TEMPDATCF(j,i)
                if (i .LT. HrCols) then
                  if (temphrs(1,i) .ge. temphrs(1,i+1)) then
                     write(*,*)'Error in Solarin File - PT cap factors, Rgn ',nr
                     stop
                  endif
                  if (temphrs(1,i) .lt. (temphrs(1,i+1)-1)) then
                     do k= temphrs(1,i)+1, temphrs(1,i+1)-1
                        CF24(k) = TEMPDATCF(j,i)
                     enddo
                  endif
                endif
             enddo
!
!            multiply by annual factor and fill in for all 3 daytypes
!
            ny=CFYRS(yblk)
             do d=1,3
               do k=1,24
                  WSSPTEL_CF(nr,ny,d,j,k) = CF24(k)*EFFMULPT(NY)
               enddo
             enddo      !daytypes

           enddo     ! months
         enddo     ! yr block
!
!        after all the year blocks have been read in  for PV in a region
!        back fill data from 1st year block to 1990, then, 'forward' fill in all other years
!
        if (CFYRS(1) .gt. 1) then
         do ny = CFYRS(1)-1, 1,  -1
            do d=1,3
              do j=1,12
               do k=1,24
                  WSSPTEL_CF(nr,ny,d,j,k) =  WSSPTEL_CF(nr,CFYRS(1),d,j,k)
               enddo
              enddo
            enddo
         enddo
        endif
!
        if (NumYrBlks .gt. 1) then
         do yblk = 1, NumYrBlks - 1
            do ny = CFYRS(yblk), CFYRS(yblk+1) - 2
             do d=1,3
              do j=1,12
               do k=1,24
                  WSSPTEL_CF(nr,ny+1,d,j,k) =  WSSPTEL_CF(nr,ny,d,j,k)
               enddo
               enddo
              enddo
            enddo
          enddo
         endif
!
!      if last year block was not MNUMYR, forward fill out to MNUMYR
!
         if (CFYRS(NumYrBlks) .ne. MNUMYR) then
          do ny = CFYRS(NumYrBlks)+1, MNUMYR
            do d=1,3
              do j=1,12
               do k=1,24
                  WSSPTEL_CF(nr,ny,d,j,k) =  WSSPTEL_CF(nr,CFYRS(numYrBlks),d,j,k)
               enddo
              enddo
            enddo
          enddo
         endif

!        ny = 27
!        DO m = 1, 12
!           DO d = 1, 3
!              WRITE(6,1517) CURIRUN, CURIYR+1989, ny+1989, nr, m, d, (WSSPTEL_CF(nr,ny,d,m,h),h=1,24)
!1517          FORMAT(1X,"CF_PT",6(":",I4),24(":",F6.3))
!           END DO
!        END DO




       enddo    ! regions
     ENDDO !IJ


         yr=1

         read(IUnit1,*) IDummy
         Write(*,*) IDummy
         do nr=1,mnumnr
            read(iunit1,*) (SoPower(nr,yr,wc),wc=1,mnumsl)
         end do

!     Solar Power is constant in all years so copy it over the years (actually as waste of space).

      do nr=1,mnumnr
         do wc=1,mnumsl
               do yr=2,MNUMYR
                  SoPower(nr,yr,wc)=SoPower(nr,1,wc)
               end do
         end do
      end do

!     Ultimate capacity factors by solar class for PT solar technology.
      read(IUNIT1,'(//)')
      read(IUnit1,*) IDummy,(PT_CapF(wc),wc=1,mnumsl)
!     write(*,*) IDummy,(PT_CapF(wc),wc=1,mnumsl)

!     Power density (MW/sq. km) of solar

      read(IUNIT1,'(/)')
      read(IUnit1,*) IDummy,PwrDen_PT
!     write(*,*) IDummy,PwrDen_PT

!     Ultimate capacity factors by solar class for PV solar technology.

      read(IUNIT1,'(//)')
      read(IUnit1,*) IDummy,(PV_CapF(wc),wc=1,mnumsl)
!     write(*,*) IDummy,(PV_CapF(wc),wc=1,mnumsl)

!     Power density (MW/sq. km) of solar

      read(IUNIT1,'(/)')
      read(IUnit1,*) IDummy,PwrDen_PV
!     write(*,*) IDummy,PwrDen_PV
!     Ultimate capacity factors by solar class for ST solar technology.

      read(IUNIT1,'(//)')
      read(IUnit1,*) IDummy,(ST_CapF(wc),wc=1,mnumsl)
!     write(*,*) IDummy,(ST_CapF(wc),wc=1,mnumsl)


!     Power density (MW/sq. km) of solar.
      read(IUNIT1,'(/)')
      read(IUnit1,*) IDummy,PwrDen_ST
!     write(*,*) IDummy,PwrDen_ST

      do yr=1,MNUMYR
         do nr=1,mnumnr
            do wc=1,mnumsl
                  if (yr.le.UESTYR-UHBSYR) then
                     WCapMax_SO(nr,yr,wc)= PwrDen_PV * SoPower(nr,yr,wc)
                  else
                     WCapMax_SO(nr,yr,wc)=WCapMax_SO(nr,(UESTYR-UHBSYR),wc)
                  end if
                  ICapAvl_SO(nr,yr,wc)=SoPower(nr,yr,wc)
            end do
         end do
      end do

      do ny=1, mnumyr
             do wc=1,mnumsl
                  CF_SO(ny,wc) = ST_CAPF(wc)
                  CF_PV(ny,wc) = PV_CAPF(wc)
                  CF_PT(ny,wc) = PT_CAPF(wc)
             enddo
       enddo              !year

!     Fill in the rankings in the early years (we need lagged values) using the strict hierarchy.

      do yr=1,(UESTYR-UHBSYR)-1
         do nr=1,mnumnr
            n=0
            do wc=1,mnumsl
                  n=n+1
                  Rwc_SO(nr,n,yr)=wc
                  Rwc_PV(nr,n,yr)=wc
                  Rwc_PT(nr,n,yr)=wc
            end do
         end do
      end do

      Do yr=2,MNUMYR+5
            do wc=1,mnumsl
               if(yr.le.MNUMYR) then
                 CF_SO(yr-1,wc)=CF_SO(yr,wc)
                 CF_PV(yr-1,wc)=CF_PV(yr,wc)
                 CF_PT(yr-1,wc)=CF_PT(yr,wc)
               endif
            enddo
      enddo
!
      SolarInputCF = 0.0
      PVInputCF = 0.0
      PTInputCF = 0.0
      do ny=1, mnumyr
        do nr=1,unrgns
           do m=1,12
               do d=1,3
                  do h=1,24
!                  if(ny.lt.26)   Write(*,1044)'debug solarinputb4 ',nr,ny,d,m,h,    SolarInputCF(nr,ny) , WSSSTEL_CF(nr,ny,d,m,h), IDAYTQ(d,m)
                      SolarInputCF(nr,ny) = SolarInputCF(nr,ny) + (WSSSTEL_CF(nr,ny,d,m,h) * IDAYTQ(d,m)) / 8760.0
!                  if(ny.lt.26)   Write(*,1044)'debug solarinpuaft ',nr,ny,d,m,h,    SolarInputCF(nr,ny) , WSSSTEL_CF(nr,ny,d,m,h), IDAYTQ(d,m)

!                  if(ny.lt.26)   Write(*,1044)'debug pvinputb4 ',nr,ny,d,m,h,    PVInputCF(nr,ny) , WSSPVEL_CF(nr,ny,d,m,h), IDAYTQ(d,m)
                      PVInputCF(nr,ny) = PVInputCF(nr,ny) + (WSSPVEL_CF(nr,ny,d,m,h) * IDAYTQ(d,m)) / 8760.0
!                  if(ny.lt.26)   Write(*,1044)'debug pvinpuaft ',nr,ny,d,m,h,    PVinputCF(nr,ny) , WSSPVEL_CF(nr,ny,d,m,h), IDAYTQ(d,m)

!                  if(ny.lt.26)   Write(*,1044)'debug PTinputb4 ',nr,ny,d,m,h,    PTInputCF(nr,ny) , WSSPTEL_CF(nr,ny,d,m,h), IDAYTQ(d,m)
                      PTInputCF(nr,ny) = PTInputCF(nr,ny) + (WSSPTEL_CF(nr,ny,d,m,h) * IDAYTQ(d,m)) / 8760.0
!                  if(ny.lt.26)   Write(*,1044)'debug PTinpuaft ',nr,ny,d,m,h,    PTinputCF(nr,ny) , WSSPTEL_CF(nr,ny,d,m,h), IDAYTQ(d,m)

1044  Format(A30,1x,5(I4,1x),2(F8.3,1x),I4)
                  enddo     !hr
               enddo        !daytype
            enddo           !month
        enddo                !year
      enddo                 !region


           IUNIT1 = file_mgr('C',infile1,.false.)

 !GJA 8/30/11  - Commented out all solar bound type assignations, which overwrote rendat
! ........ Assign build bound type
!          DO NR=1,MNUMNR
!             WBTECH(7,NR) = 11
!             WBTECH(8,NR) = 11
!          ENDDO
!          WBTECH(7,2) =11
!          WBTECH(7,11)=11
!          WBTECH(7,12)=11
!          WBTECH(7,13)=11

 !         WBTECH(8,2) =11
 !         WBTECH(8,11)=11
 !         WBTECH(8,12)=11
 !         WBTECH(8,13)=11

      endif

 100  format(F6.0,1x,F9.0,1x,f6.4,2F8.0,1x,f6.4,1x,F6.0,1x,f6.4)
 150  format(F6.0,1x,F6.0)
 160  format(f6.2,1x,f6.2)
 200  format(f6.4,1x,f6.4)
 
       if (CURCALYR.eq.UESTYR .and. CURITR.eq.1) then
         infile1 = 'SOLARCLIPIN'
         iunit1 = file_mgr('O',infile1,.false.)



! -------- read in new capacity factor for otherwise inverter clipped energy
        DO IJ=1,4
           IF (IJ.EQ.1) THEN
             IX = 1
             IY = IJUMPEMRGN
           ELSEIF (IJ .EQ. 2) THEN
            IF (IJUMPEMRGN.EQ.13) THEN
             IX=14
             IY=14
            ELSEIF (IJUMPEMRGN.EQ.22) THEN
             IX=23
             IY=23
            ELSEIF (IJUMPEMRGN.EQ.25) THEN
             IX=26
             IY=26
            ENDIF
           ELSEIF (IJ .EQ. 3) THEN
            IF (IJUMPEMRGN.EQ.13) THEN
             IX=15
             IY=15
            ELSEIF (IJUMPEMRGN.EQ.22) THEN
             IX=24
             IY=24
            ELSEIF (IJUMPEMRGN.EQ.25) THEN
             IX=27
             IY=27
            ENDIF
           ELSEIF (IJ .EQ. 4) THEN
            IF (IJUMPEMRGN.EQ.13) THEN
             IX=16
             IY=16
            ELSEIF (IJUMPEMRGN.EQ.22) THEN
             IX=25
             IY=25
            ELSEIF (IJUMPEMRGN.EQ.25) THEN
             IX=28
             IY=28
            ENDIF
           ENDIF
         do nr=IX,IY                ! read for each region

!          Read in  PV w/ Storage (PT) data for this region

            WRITE (TABNAME,'(A3,I1,I1,A7)') '%PT',NR/10,MOD(NR,10),'YEARS %'
            RET_CD = RD$TBL(IUNIT1,TABNAME,1,1,6)
            RET_CD = RD$I1(numYrBlks,1,1)         ! number of year blocks for this region's PV
           do yblk=1,numYrBlks
            WRITE (TABNAME,'(A3,I1,I1,A7)') '%PT',NR/10,MOD(NR,10),'PARAMS%'
            RET_CD = RD$TBL(IUNIT1,TABNAME ,1,1,6)
            RET_CD = RD$I1(tempyr,1,1)           ! year for data block
            RET_CD = RD$I1(HrCols,1,1)           ! number of hour columns
            CFYRS(yblk) = tempyr - 1989

           !read(iunit1,*)(temphrs(1,i),i=1,HrCols)
            WRITE (TABNAME,'(A3,I1,I1,A7)') '%PT',NR/10,MOD(NR,10),'HRS   %'
            RET_CD = RD$TBL (IUNIT1,TABNAME, 1,1,6)  ! Identify input table
            RET_CD = RD$I2(temphrs,1,1,HrCols,1,HrCols)           ! hours for data

            WRITE (TABNAME,'(A3,I1,I1)') '%PT',NR/10,MOD(NR,10)
            RET_CD = RD$TBL (IUNIT1, TABNAME, 12,1,6)  ! Identify input table
            RET_CD = RD$I1(tmpMonth,1,12)           ! month of data
            RET_CD = RD$R2 (TEMPDATCF,1,1,HrCols,12,HrCols)   ! Read the capacity factor table
 !
 !          if last hour column is not for hour 24, add a column for hr 24
 !
            if (HrCols .lt. 24 .and. temphrs(1,HrCols) .ne. 24) then
               HrCols = HrCols + 1
               temphrs(1,HrCols) = 24
               do j=1,12             !for each month
                  TEMPDATCF(j,HrCols) = TEMPDATCF(j,HrCols-1)
               enddo
            endif
!
           do j=1,12            ! for each month
!
!            fill in all 24 hours of data
!
             do i=1,HrCols
                CF24(temphrs(1,i)) = TEMPDATCF(j,i)
                if (i .LT. HrCols) then
                  if (temphrs(1,i) .ge. temphrs(1,i+1)) then
                     write(*,*)'Error in Solarin File - PT cap factors, Rgn ',nr
                     stop
                  endif
                  if (temphrs(1,i) .lt. (temphrs(1,i+1)-1)) then
                     do k= temphrs(1,i)+1, temphrs(1,i+1)-1
                        CF24(k) = TEMPDATCF(j,i)
                     enddo
                  endif
                endif
             enddo
!
!            multiply by annual factor and fill in for all 3 daytypes
!
            ny=CFYRS(yblk)
             do d=1,3
               do k=1,24
                  WSSPTEL_CF_CLIP(nr,ny,d,j,k) = CF24(k)*EFFMULPT(NY)
               enddo
             enddo      !daytypes

           enddo     ! months
         enddo     ! yr block
!
!        after all the year blocks have been read in  for PV in a region
!        back fill data from 1st year block to 1990, then, 'forward' fill in all other years
!
        if (CFYRS(1) .gt. 1) then
         do ny = CFYRS(1)-1, 1,  -1
            do d=1,3
              do j=1,12
               do k=1,24
                  WSSPTEL_CF_CLIP(nr,ny,d,j,k) =  WSSPTEL_CF_CLIP(nr,CFYRS(1),d,j,k)
               enddo
              enddo
            enddo
         enddo
        endif
!
        if (NumYrBlks .gt. 1) then
         do yblk = 1, NumYrBlks - 1
            do ny = CFYRS(yblk), CFYRS(yblk+1) - 2
             do d=1,3
              do j=1,12
               do k=1,24
                  WSSPTEL_CF_CLIP(nr,ny+1,d,j,k) =  WSSPTEL_CF_CLIP(nr,ny,d,j,k)
               enddo
               enddo
              enddo
            enddo
          enddo
         endif
!
!      if last year block was not MNUMYR, forward fill out to MNUMYR
!
         if (CFYRS(NumYrBlks) .ne. MNUMYR) then
          do ny = CFYRS(NumYrBlks)+1, MNUMYR
            do d=1,3
              do j=1,12
               do k=1,24
                  WSSPTEL_CF_CLIP(nr,ny,d,j,k) =  WSSPTEL_CF_CLIP(nr,CFYRS(numYrBlks),d,j,k)
               enddo
              enddo
            enddo
          enddo
         endif

        ny = 27
        DO m = 1, 12
           DO d = 1, 3
              WRITE(18,1517) CURIRUN, CURIYR+1989, ny+1989, nr, m, d, (WSSPTEL_CF_CLIP(nr,ny,d,m,h),h=1,24)
1517          FORMAT(1X,"CF_PT_CLIP",6(":",I4),24(":",F6.3))
           END DO
        END DO




       enddo    ! regions
     ENDDO !IJ





           IUNIT1 = file_mgr('C',infile1,.false.)
	  end if
      return
      end

!! **************************************************************************
!!   Old hydro submodule
!!
!!    #    #  #    #  ####    ####   #####
!!    #    #   #  #   #   #   #   #  #   #
!!    ######    ##    #   #   ####   #   #
!!    #    #    ##    #   #   # #    #   #
!!    #    #    ##    ####    #  #   #####
!!
!! **************************************************************************
!
!
!
!
!      SUBROUTINE HYDRO
!      IMPLICIT NONE
!!
!!=============================================================================
!! HYDRO: This program reads in regional upper bounds for new hydro builds.
!!        These are combined with the cost multipliers and percentages for
!!        each supply step from the long term elasticities.
!!=============================================================================
!!!!!!!!!!!!
!      include 'parametr'
!      include 'ncntrl'
!      include 'emmparm'
!      include 'ecpcntl'
!      include 'control'
!      include 'wrenew'
!      include 'rencntl'
!      include 'entcntl'
!      include 'uecpout'
!
!! ..... local variables for reading input file
!! .....  Hydro
!
!      integer iunit1
!      real hydcap(mnumnr)
!      INTEGER*4 IRG,PLT,IS,YR,OLYR,IECP,IRNW,FULLYR
!      REAL*4 TOTHYD
!
!      external file_mgr
!      integer file_mgr
!      character*10 dummy(mnumnr)
!      character*20 infile1
!
!      INTEGER RD$TBL,RD$R1,RD$C1 ! Table read functions.
!      INTEGER RET_CD             ! Return code from table reads
!
!!   in first year, read in hydro build limits
!      FULLYR = USYEAR(CURIYR)
!      IF(FULLYR .EQ. UESTYR)THEN
!         infile1 = 'WHYDRO'
!         iunit1 = file_mgr('O',infile1,.false.)
!
!         RET_CD = RD$TBL(IUNIT1,'%HYDRO BLDS%',MNUMNR,0,6) ! Identify table
!         RET_CD = RD$C1(DUMMY,1,MNUMNR) ! Read dummy character
!         RET_CD = RD$R1(HYDCAP,1,MNUMNR) ! Read bounds
!
!! ........... reassign temporary values to permanent array
!              do IRG=1,UNRGNS
!                 UTRSMX(IRG,1) =HYDCAP(IRG)
!              enddo
!
!         IUNIT1 = file_mgr('C',infile1,.false.)
!      END IF
!!  DETERMINE ANY PRIOR HYDRO ADDITIONS AND SUBTRACT FROM SUPPLY CURVES
!      IF((CURIYR + UHBSYR) .GE. UPSTYR)THEN
!       IF((CURIYR + UHBSYR) .EQ. UPSTYR)THEN
!        DO PLT = 1 , ECP_D_RNW
!         IF(UPLNTCD(UCPRNWI(PLT)) .EQ. 'HY')THEN
!          IECP = UCPRNWI(PLT)
!          IRNW = UIRRNWI(PLT)
!         END IF                                                      ! UPLNTCD
!        END DO                                                       ! PLT
!       END IF                                                        ! CURIYR
!!    see if any new hydro has been built already
!          OLYR = CURIYR + UPPLYR(IECP)
!        DO IRG = 1 , UNRGNS
!          TOTHYD = 0.0
!         DO YR = 1 , OLYR
!          TOTHYD = TOTHYD + UADDHYD(IRG,YR)
!         END DO
!!     decrement available supplies by prior decisions
!         DO IS = 1 , MLPTMX
!          UTRSFC(IRG,1,IS) = MAX(UTRSFC(IRG,1,IS),TOTHYD/UTRSMX(IRG,1))
!          UTRSFC(IRG,1,IS) = MIN(UTRSFC(IRG,1,IS),1.0)
!         END DO
!        END DO
!      END IF
!
!      return
!      end
!
!
!
! =======================================================================
!  ####   ######   #####  ######  #        ####    ####   #####    ####
! #    #  #          #    #       #       #    #  #    #  #    #  #
! #       #####      #    #####   #       #    #  #    #  #    #   ####
! #  ###  #          #    #       #       #    #  #    #  #####        #
! #    #  #          #    #       #       #    #  #    #  #   #   #    #
!  ####   ######     #    #       ######   ####    ####   #    #   ####
!
!
! Subroutine GETFLOORS
!
! Purpose: read in the floors for renewable technologies from file 'floor.dat'
!
! OUTPUT:  COMMON WFLOORS
!          integer No_rec      ! NO of records for floors
!
! written be: Michael Kintner-Meyer
! last updated: 1/15/97
! -------------------------------------------------------------------------
      Subroutine GETFLOORS(No_rec)
      USE SQLITE
      implicit none
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'ecpcntl'
      include 'control'
      include 'wflrinc'
        type(sqlite_database)                      :: db
        type(sqlite_statement)                     :: stmt
        type(sqlite_statement)                     :: stmt2
        type(sqlite_statement)                     :: stmt3
        type(sqlite_column), dimension(:), pointer :: col
        type(sqlite_column), dimension(:), pointer :: col2
        type(sqlite_column), dimension(:), pointer :: col3
        character(len=40), pointer, dimension(:)   :: result
        character(len=80)                          :: errmsg
        logical                                    :: finished

        INTEGER*4 ID

      integer file_mgr
      external file_mgr

      character*20  infile1      ! file name
      integer       iunit1       ! FORTRAN unit

      INTEGER No_rec             ! NO of records for floors
      INTEGER IR                 ! INDEX FOR RECORDS
      INTEGER RD$TBL,RD$R1,RD$I1 ! Table read functions.
      INTEGER RD$C1              ! Table read functions.
      INTEGER RET_CD             ! Return code from table reads
      CHARACTER*2 ECP(MNUMFL),EFD(MNUMFL)
      CHARACTER*12 TABNAME       ! Storage for name of table to read

      INTEGER RTOVALUE
      EXTERNAL RTOVALUE


        call sqlite3_open( 'emm_db/NEMS_INPUT.db', db )
        allocate ( col(13) )
        ! QUERY THE DATABASE TABLE
        call sqlite3_column_query( col(1), 'FL_ID', sqlite_int )
        call sqlite3_column_query( col(2), 'EMM_REG', sqlite_int )
        call sqlite3_column_query( col(3), 'ECP_TYP', sqlite_char )
        call sqlite3_column_query( col(4), 'EFD_TYP', sqlite_char )
        call sqlite3_column_query( col(5), 'SYR', sqlite_int )
        call sqlite3_column_query( col(6), 'SMO', sqlite_int )
        call sqlite3_column_query( col(7), 'RYR', sqlite_int )
        call sqlite3_column_query( col(8), 'RMO', sqlite_int )
        call sqlite3_column_query( col(9), 'OWNERSHIP', sqlite_int )
        call sqlite3_column_query( col(10), 'VINTAGE', sqlite_int )
        call sqlite3_column_query( col(11), 'CAPACITY', sqlite_real )
        call sqlite3_column_query( col(12), 'HEATRATE', sqlite_real )
        call sqlite3_column_query( col(13), 'CF', sqlite_real )
        
        call sqlite3_prepare_select( db, 'V_EMM_WFLOORS', col, stmt)
             
        ! LOAD RESULTS INTO FORTRAN VARIABLES FOR NEMS
        do
        
        call sqlite3_next_row( stmt, col, finished )
        if ( finished ) exit
      
        call sqlite3_get_column( col(1), ID)
        call sqlite3_get_column( col(2), WNERC(ID))
        call sqlite3_get_column( col(3), ECP(ID))
        call sqlite3_get_column( col(4), EFD(ID) )
        call sqlite3_get_column( col(5), WOLYR(ID) )
        call sqlite3_get_column( col(6), WOLMO(ID) )
        call sqlite3_get_column( col(7), WRTYR(ID) )
        call sqlite3_get_column( col(8), WRTMO(ID) )
        call sqlite3_get_column( col(9), WOWNTYP(ID) )
        call sqlite3_get_column( col(10), WVINTYP(ID) )
        call sqlite3_get_column( col(11), WCAP(ID) )
        call sqlite3_get_column( col(12), WHR(ID) )
        call sqlite3_get_column( col(13), WCAPF(ID))
        end do
       
        No_rec = id
        
!        DO ID = 1,No_rec
!	        write(6,*) 'reading wfloor',ID, WNERC(ID)," ",ECP(ID)," ",WOLYR(ID)," ",WOLMO(ID)," ",WCAPF(ID)
!        END DO
 

! ........ store ecp/efd indexes in arrays
      DO IR = 1 , No_rec

        Select case (ecp(ir))
        case('SO')
            WECPTYP(IR) = WISO
            WEFDTYP(IR) = UISTH
        case('SS')
            WECPTYP(IR) = WISS
            WEFDTYP(IR) = UISTS
        case('S2')
            WECPTYP(IR) = WIS2
            WEFDTYP(IR) = UIST2
        case('PV')
            WECPTYP(IR) = WIPV
            WEFDTYP(IR) = UISPV
        case('PT')
            WECPTYP(IR) = WIPT
            WEFDTYP(IR) = UIPVT
        case('IN')
            WECPTYP(IR) = WIIN
            WEFDTYP(IR) = UIOIN
        case('FC')
            WECPTYP(IR) = WIFC
            WEFDTYP(IR) = UIFCG
        case('WN')
            WECPTYP(IR) = WIWN
            WEFDTYP(IR) = UIWND
        case('WL')
            WECPTYP(IR) = WIWL
            WEFDTYP(IR) = UIWNL
        case('WF')
            WECPTYP(IR) = WIWF
            WEFDTYP(IR) = UIWFS
        case('GT')
            WECPTYP(IR) = WIGT
            WEFDTYP(IR) = UIGTH
        case('AG')
            WECPTYP(IR) = WIAG
            WEFDTYP(IR) = UIAGT
        case('WD')
            WECPTYP(IR) = WIWD
            WEFDTYP(IR) = UIBMS
         case('BI')
            WECPTYP(IR) = WIBI
            WEFDTYP(IR) = UIBIG
        case('MS')
            WECPTYP(IR) = WIMS
            WEFDTYP(IR) = UIMSW
        case('PC')
            WECPTYP(IR) = WIPC
            WEFDTYP(IR) = UICNC
        case('IG')
            WECPTYP(IR) = WIIG
            WEFDTYP(IR) = UICAV
        case('IS')
            WECPTYP(IR) = WIIS
            WEFDTYP(IR) = UICAS
        case('OC')
            WECPTYP(IR) = WIOC
            WEFDTYP(IR) = UICON
        case('PQ')
            WECPTYP(IR) = WIPQ
            WEFDTYP(IR) = UICOQ
        case('I2')
            WECPTYP(IR) = WII2
            WEFDTYP(IR) = UICNG
        case('NG')
            WECPTYP(IR) = WING
            WEFDTYP(IR) = UICTN
        case('ET')
            WECPTYP(IR) = WIET
            WEFDTYP(IR) = UICTX
        case('CT')
            WECPTYP(IR) = WICT
            WEFDTYP(IR) = UICTX
        case('AT')
            WECPTYP(IR) = WIAT
            WEFDTYP(IR) = UIACT
         case('IC')
            WECPTYP(IR) = WIIC
            WEFDTYP(IR) = UIICE
         case('T2')
            WECPTYP(IR) = WIT2
            WEFDTYP(IR) = UIAC2
        case('EC')
            WECPTYP(IR) = WIEC
            WEFDTYP(IR) = UICCX
        case('CC')
            WECPTYP(IR) = WICC
            WEFDTYP(IR) = UICCX
        case('AC')
            WECPTYP(IR) = WIAC
            WEFDTYP(IR) = UIACC
        case('A2')
            WECPTYP(IR) = WIA2
            WEFDTYP(IR) = UIAC2
        case('CS')
            WECPTYP(IR) = WICS
            WEFDTYP(IR) = UIACS
        case('AN')
            WECPTYP(IR) = WIAN
            WEFDTYP(IR) = UIANC
        case('SM')
            WECPTYP(IR) = WISM
            WEFDTYP(IR) = UISMR
         case('GN')
            WECPTYP(IR) = WIGN
            WEFDTYP(IR) = UIGFN
        case('CN')
            WECPTYP(IR) = WICN
            WEFDTYP(IR) = UICNU
        case('DB')
            WECPTYP(IR) = WIDB
            WEFDTYP(IR) = UIDGB
        case('DP')
            WECPTYP(IR) = WIDP
            WEFDTYP(IR) = UIDGP
        case('P2')
            WECPTYP(IR) = WIP2
            WEFDTYP(IR) = UIHYR
        case('SQ')
            WECPTYP(IR) = WISQ
            WEFDTYP(IR) = UIQST
        case('DS')
            WECPTYP(IR) = WIDS
            WEFDTYP(IR) = UIDST
        case('OS')
            WECPTYP(IR) = WIOS
            WEFDTYP(IR) = UIOST
        case('ST')
            WECPTYP(IR) = WIST
            WEFDTYP(IR) = UISTG
        case('HY')
            WECPTYP(IR) = WIHY
            WEFDTYP(IR) = UIHYC
        case('HO')
            WECPTYP(IR) = WIHO
            WEFDTYP(IR) = UIHYA
        case('HI')
            WECPTYP(IR) = WIHI
            WEFDTYP(IR) = UIHYI
       case('TI')
            WECPTYP(IR) = WITI
            WEFDTYP(IR) = UIHYT
        case default !Default to solar thermal so it can be seen in the results easier
            WECPTYP(IR) = WISO
            WEFDTYP(IR) = UISTH
        end select
!       accumulate floors capacity by type and year
!	        write(6,*) 'wfloor ecp assignment ',no_rec,IR, WNERC(IR)," ",ECP(IR)," ",WOLYR(IR)," ",WECPTYP(IR)

!        Exclude uprates (VIN=1) and planned additions (VIN = 2)
         IF (WVINTYP(IR) .GT. 2)THEN
            UPCAPFLR(WECPTYP(IR),WOLYR(IR) - UHBSYR) = UPCAPFLR(WECPTYP(IR),WOLYR(IR) - UHBSYR) +  &
             WCAP(IR)
         END IF
      END DO

      return
      end
! ======================================================================================
!  ####   ######   #####   #####   ####   #        ####   #####   ####     ####
! #    #  #          #    #       #    #  #       #    #  #    #  #   #   #    #
! #       #####      #     ####   #    #  #       #    #  ####    #    #  #
! #  ###  #          #         #  #    #  #       ######  #   #   #    #  #  ###
! #    #  #          #         #  #    #  #       #    #  #    #  #   #   #    #
!  ####   ######     #    #####   #####   ######  #    #  #    #  ####     ####
!
!
! Subroutine GETSOLARDG
!
! Purpose: read solar distributed generation/capacity for residential and commercial from
!          common block cogen and add them to WFLOORS
!
! OUTPUT:  COMMON WFLOORS
!          integer No_rec      ! NO of records for solar distributed generation resources
!                                added as additional floors
!
! written be: Augustine Kwon
! last updated: 1/6/2016
! ---------------------------------------------------------------------------------------
      Subroutine GETSOLARDG(No_add_rec)
      implicit none
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'ecpcntl'
      include 'control'
      include 'wflrinc'
      include 'cogen'
      include 'uefdout'



      integer file_mgr
      external file_mgr

      character*20  infile1      ! file name
      integer       iunit1       ! FORTRAN unit


      INTEGER No_add_rec             ! NO of records for floors
      INTEGER IRC, I                 ! INDEX FOR RECORDS
      INTEGER IY, IR,ICENSUS
      INTEGER RET_CD             ! Return code from table reads
      CHARACTER*2 ECP(MNUMFL),EFD(MNUMFL)
      REAL DGPVINCCAPNR(MNUMNR,MNUMYR) !yearly incremental capacity for Existing Distributed PV by NERC regions  -  AKN
      REAL DGPVINCGENNR(MNUMNR,MNUMYR) !yearly incremental generation for Existing Distributed PV by NERC regions - AKN
      REAL DGPVCAPF(MNUMNR,MNUMYR)     !yearly capacity factor for Existing Distributed PV by NERC regions  - AKN
      INTEGER RTOVALUE
      EXTERNAL RTOVALUE


!REAL CGTOTCAPNR(MNUMNR,MNUMYR,MNUMCGF)
!REAL CGTOTGENNR(MNUMNR,MNUMYR,MNUMCGF,2)
!IY =  1: 1990
!IY = 61: 2050
!      NEW = .TRUE.
!      PVFLOOROUT = FILE_MGR('O','PV_WFLOOR',NEW)      ! debug file to echo data read from xml file


      DO IY=1,MNUMYR
           IF (IY .GE. (UESTYR-UHBSYR)+2 ) THEN    !add all distributed PV capacity addition, putting initial amount in EMM start year (plus planning, see INTOPLNT)
             DO IR=1,UNRGNS
                   IF (IY .EQ. (UESTYR-UHBSYR)+2) THEN
                     DGPVINCCAPNR(IR,IY) = DPVTOTCAPNR(IR,IY)
                     DGPVINCGENNR(IR,IY) = DPVTOTGENNR(IR,IY) 
                   ELSE
                     DGPVINCCAPNR(IR,IY) = DPVTOTCAPNR(IR,IY) - DPVTOTCAPNR(IR,IY-1)
                     DGPVINCGENNR(IR,IY) = DPVTOTGENNR(IR,IY) - DPVTOTGENNR(IR,IY-1)
                   ENDIF
                   IF (DGPVINCCAPNR(IR,IY) .GT. 0) THEN
                     DGPVCAPF(IR,IY) = DGPVINCGENNR(IR,IY) * 1000 / (DGPVINCCAPNR(IR,IY)*8760)
                     WNERC(No_add_rec+1) = IR
                     ECP(No_add_rec+1) = 'PV'
                     EFD(No_add_rec+1) = 'PV'
                     WOLYR(No_add_rec+1) = IY+1989
                     WOLMO(No_add_rec+1) = 1
                     WRTYR(No_add_rec+1) = 9999
                     WRTMO(No_add_rec+1) = 12
                     WOWNTYP(No_add_rec+1) = 10
                     WVINTYP(No_add_rec+1) = 15          ! unique vintage type to identify later
                     WCAP(No_add_rec+1) = DGPVINCCAPNR(IR,IY)
                     WHR(No_add_rec+1) = 9516
                     WCAPF(No_add_rec+1) = DGPVCAPF(IR,IY)
                     WECPTYP(No_add_rec+1) = WIPV
                     WEFDTYP(No_add_rec+1) = UISPV
                     No_add_rec = No_add_rec+1
                   ENDIF
          END DO
         ENDIF
      END DO

      return
      end

! ======================================================================================
! Subroutine GETLFGCAPADDS
!
! Purpose: add LFG capacity addtions from new LFG module to WFLOORS     
!
! OUTPUT:  COMMON WFLOORS
!          integer No_rec      ! NO of records for LFG capacity additions               s
!                                added as additional floors
!
! ---------------------------------------------------------------------------------------
      Subroutine GETLFGCAPADDS(No_add_rec)
      implicit none
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'ecpcntl'
      include 'control'
      include 'wflrinc'
      include 'uefdout'
      include 'wmscomon'
      include 'wrenew'   

      integer file_mgr
      external file_mgr

      INTEGER No_add_rec             ! NO of records for floors
      INTEGER IRC, I                 ! INDEX FOR RECORDS
      INTEGER IY, IR
      INTEGER RET_CD             ! Return code from table reads
      CHARACTER*2 ECP(MNUMFL),EFD(MNUMFL)
      INTEGER RTOVALUE
      EXTERNAL RTOVALUE

!     LFGCAPNR(:,:) = 0.0
!     LFGCAPNR(22,31) = 100.0
!     LFGCAPNR(12,32) = 220.0
!     LFGCAPNR(1,33) = 315.0
!     LFGCAPNR(19,34) = 437.0
     write(6,*) ' inside lfgcap routine '

      IY = CURIYR
!
      IF (IY .GE. (UESTYR-UHBSYR)+2 ) THEN    !add lfg capacity additions for currnt year by EMM region. into plant??)
        DO IR=1,UNRGNS
          IF (LFGCAPNR(IR,IY) .GT. 0) THEN
            WNERC(No_add_rec+1) = IR
            ECP(No_add_rec+1) = 'SW'
            EFD(No_add_rec+1) = 'SW'
!           WOLYR(No_add_rec+1) = IY+1989
            WOLYR(No_add_rec+1) = IY + 1989 + UPPLYR(WIMS) + 1     ! so intoplnt called.
            WOLMO(No_add_rec+1) = 1
            WRTYR(No_add_rec+1) = 9999
            WRTMO(No_add_rec+1) = 12
            WOWNTYP(No_add_rec+1) = 2         ! non-utility owner
            WVINTYP(No_add_rec+1) = 3          ! unplanned build
            WCAP(No_add_rec+1) = LFGCAPNR(IR,IY)
            WHR(No_add_rec+1) = WHRMSEL(IR,IY)
            WCAPF(No_add_rec+1) = WCFMSEL(IR,IY)
            WECPTYP(No_add_rec+1) = WIMS
            WEFDTYP(No_add_rec+1) = UIMSW
            No_add_rec = No_add_rec+1
          ENDIF
        END DO
      ENDIF

      return
      end

! =====================================================================
!
! #####   #    #   #####  ######  #        ####    ####   #####    ####
! #    #  #    #     #    #       #       #    #  #    #  #    #  #
! #    #  #    #     #    #####   #       #    #  #    #  #    #   ####
! #####   #    #     #    #       #       #    #  #    #  #####        #
! #       #    #     #    #       #       #    #  #    #  #   #   #    #
! #        ####      #    #       ######   ####    ####   #    #   ####
!
! ---------------------------------------------------------------------

!
      SUBROUTINE PUTFLOORS(No_rec)

      implicit none
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'ecpcntl'
      include 'control'
      include 'wflrinc'

      integer No_rec                  ! Total number of records for floors
      integer i                       ! record counter
      real*8 ACAP                     ! capacity in [MW]
      real*8 AHR                      ! Heat rate in [BTU/kWh]
      real*8 ACAPF                    ! capacity factor in [%]
      integer IECP                    ! ecp type


      do i=1,No_rec
        ACAP =DBLE(WCAP(i))
        AHR  =DBLE(WHR(i))
        ACAPF=DBLE(WCAPF(i))
        IECP = WECPTYP(i)
        IF (WVINTYP(i) .EQ. 3) WVINTYP(i) = 20
        IF ((CURIYR + UHBSYR + UPPLYR(IECP) + 1) .EQ. WOLYR(i)) THEN
!                WRITE(6,2394)'putfloors ',no_rec,WNERC(i),WECPTYP(i),WEFDTYP(i),WOLYR(i), &
!                    WOLMO(i),WRTYR(i),WRTMO(i),WOWNTYP(i),WVINTYP(i),ACAP,AHR,ACAPF,ACAPF
                call INTOPLNT(WNERC(i),WECPTYP(i),WEFDTYP(i),WOLYR(i), &
                      WOLMO(i),WRTYR(i),WRTMO(i),WOWNTYP(i),WVINTYP(i),ACAP,AHR,ACAPF,ACAPF)

2394  Format(A25,1x,9(I4,1x),4(F12.3,1x) )
        ENDIF
      enddo
      return
      end



! ================================================================
! Subroutine: INTOPLNT
!
! Purpose: writing plant capacity into the plantfile.
!
!
! Input:
!   Integer:
!       NERC     : Nerc region
!       PLANT    : ECP type
!       IEFD     : EFD type
!       WSYR     : On-line year
!       WSMO     : On-line month
!       WRYR     : Retire year
!       WRMO     : Retire month
!       IOWN     : Ownership (1:util, 2: Non-util)
!       IVIN     : Vintage (2:planned, 3: Unplanned)  !also allows 1=existing for uprates
!
!  Real*8
!       LEVEL    : Capacity in [MW]
!       WWHRATE  : Heat rate
!       WWCF     : Annual capacity factor  in [%]
!       WWCFM    : Monthly Capacity factor in [%]
!
! written by: Michael Kintner-Meyer
! last updated: 1/16/97
!
! -----------------------------------------------------------------
      Subroutine INTOPLNT(NERC,PLANT,IEFD,WSYR,WSMO,WRYR,WRMO,IOWN,IVIN,LEVEL,WWHRATE,WWCF,WWCFM)
!
      IMPLICIT NONE
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'ecpcntl'
      include 'control'
      include 'entcntl'
      include 'enewtech'
      include 'uecpout'
      include 'bildin'
      include 'plntin'
      include 'plntctl'
      include 'wflrinc'
      include 'efpgen'
      include 'dispett'
      include 'ecp_coal'
      include 'cdsparms'
      include 'coalemm'
!
      REAL*8 LEVEL,OVRCST,TMPTRCST
      REAL*8 TRNSCAP(MNUMYR),TRNSCST(MNUMYR)
      REAL*8 EWGROE
      REAL*4 EWGINT
      REAL*4 EWGROR
      REAL*8 TXBOOK
      REAL*8 FNBOOK
      REAL*8 PRATIO
      REAL*8 CAPNNSTL
      REAL*8 CAPNUG
      REAL*4 CPR(ECP_D_LCP)
      REAL*4 CAPD(MNUMYR+ECP_D_XPH)
      INTEGER*4 TLF
      INTEGER*4 NCLF
      INTEGER*4 NLLF
      INTEGER*4 CLT,PLT,ONE
      INTEGER*4 JYR,IMO,INT,RNW,NWGRP,FL_NUM,JECP,SYR,BBN,XYR
      INTEGER*4 NERC,PLANT,YEAR,IGRP,FULLYR,IFL,IECP,IEFD,IOWN,IVIN,FRG
      INTEGER*4 WSYR,WSMO,WRYR,WRMO,I_COAL
      REAL*8    WWHRATE    ! Heat rate in [BTU/kWh]
      REAL*8    WWCF       ! Annual capacity factor in [%]
      REAL*8    WWCFM      ! Monthly capacity factor in [%]
!
      ONE = 1 ! DUH!
!
!     NERC = EMM Region
!
!     INITIALIZE TRANSMISSION CAPACITY AND OVERNIGHT COST
!
      DO JYR = 1 , ECP_D_XPH
         TRNSCAP(JYR) = DBLE(0.0)
         TRNSCST(JYR) = DBLE(0.0)
      END DO
!
!     GET ECP INPUT BLOCK
!
!
      CALL GETBLD(1,NERC)
      IF (UCPDSPIS(PLANT) .GT. 0 ) THEN               ! DISPATCHABLE
         IECP = PLANT
         JECP = UCPDSPI(IECP)
         WSCBEF = UPPSEF(IECP) * 100.0
         OVRCST = UPOVR(JECP) * &
            UPLRPC(JECP) * UPLROPT(JECP) * &
            UPLRLC(JECP) * EPRGM(JECP) * &
            EPACM(JECP) * UPANNADJ(JECP,CURIYR)
      ELSE IF (UCPINTIS(PLANT) .GT. 0) THEN      ! INTERMITTENT
!
!        For Intermittent Plants
!
         WSCBEF = 0.0                         ! SCRUBBER EFFICIENCY
         IECP = UCPINTIS(PLANT)
         JECP = UCPINTI(IECP)
         OVRCST = &
            EPIROVR(UIRINTI(IECP)) * UPLRPC(JECP) * &
            UPLROPT(JECP) * UPLRLC(JECP) * &
            EPRGM(JECP) * EPACM(JECP) * UPANNADJ(JECP,CURIYR)
!    +      EPRGM(JECP) * EPACM(JECP) * EPCCSUP(UIRINTI(IECP),1)
!
      ELSE IF (UCPRNWIS(PLANT) .GT. 0) THEN      ! RENEWABLE
!
!        For Renewable Plants
!
         IECP = UCPRNWIS(PLANT)
         JECP = UCPRNWI(IECP)
         OVRCST = &
            EPIROVR(UIRRNWI(IECP)) * UPLRPC(JECP) * &
            UPLROPT(JECP) * UPLRLC(JECP) * &
            EPRGM(JECP) * EPACM(JECP) * UPANNADJ(JECP,CURIYR)
!    +      EPRGM(JECP) * EPACM(JECP) * EPCCSUP(UIRRNWI(IECP),1)

       ELSE IF (UCPSTOIS(PLANT) .GT. 0) THEN      ! Storage
!
!        For Storage Plants
!
         IECP = UCPSTOIS(PLANT)
         JECP = UCPSTOI(IECP)
         OVRCST = &
            EPIROVR(UIRSTOI(IECP)) * UPLRPC(JECP) * &
            UPLROPT(JECP) * UPLRLC(JECP) * &
            EPRGM(JECP) * EPACM(JECP) * UPANNADJ(JECP,CURIYR)
!    +      EPRGM(JECP) * EPACM(JECP) * EPCCSUP(UIRRNWI(IECP),1)
      END IF
!
!      WRITE(6,*)'after getbld ',CURIYR,NERC,IECP,PLANT

         NLLF = UPNLLF(JECP)
         NCLF = UPNCLF(JECP)
         TLF = UPTXLF(JECP)
         CLT = UPCLYR(JECP)
         PLT = UPPLYR(JECP)
         DO JYR = 1 , CLT
            CPR(JYR) = UPCPRO(JECP,JYR)
         END DO
         DO JYR = 1 , MNUMYR + UNXPH
            CAPD(JYR) = UPCAPD(JYR,JECP)
         END DO
!
         SYR =  WSYR-1989                    ! On Line Year (1 = 1990)
         FULLYR = WSYR                       ! On Lne Year (1990 = 1990)
!
         WHRATE = WWHRATE                         ! HEATRATE BTU / KWH
!
!        STORE CAPACITY-RELATED DATA
!
         WC_NP = LEVEL
         WC_SUM = LEVEL
         WC_WIN = LEVEL
         W_CF = WWCF                           ! ANNUAL CAPACITY FACTOR
         DO IMO = 1, 12
            WCF_M(IMO) = WWCFM                 ! MONTHLY CAPACITY FACTOR
         END DO
!
!        INTEGER
!
         W_SYR = FULLYR
         W_SMO = WSMO
         W_RYR = WRYR
         W_RMO = WRMO
         WRFURB = W_SYR
         WSCBYR = W_SYR
         WVIN = IVIN
         IF (UPTTYP(PLANT) .GT. NW_COAL) THEN
         DO IFL = 1 , UIFPLT
            WFL(IFL) = WFLTP(IEFD,IFL)
            IF (IEFD .LE. EFD_D_DSP) &
               W_FSHR(IFL) = WCMFSH(IEFD,IFL)
         END DO
         ELSE
            WFL = 0
            W_FSHR = 0.0
            WFL(1) = PLANT
            W_FSHR(1) = 1.0
         END IF
         WEFDT = IEFD                             ! EFD Plant Type
         WECPT = PLANT                            ! ECP Plant Type
         WEFPT = UPEFPT(PLANT)                    ! EFP Plant Type
         WNOPER = NERC                            ! NEMS Region
         WNOWN = NERC                             ! NEMS Region
         IF (IOWN .EQ. 10) THEN
           W_MRUN = 9999                         ! DG PV should generate at fixed levels
         ELSE
         W_MRUN = 0                               ! Must Run Code 0 => no
         ENDIF
         W_CR = UPCENSUS(PLANT,NERC)              ! Census Region
         W_GR = UPNGRG(NERC)                      ! NGTDM Region
         W_CLRG = UPCLRG(NERC)                    ! Coal Region
         W_CAR = UPCARG(NERC)                     ! Carbon Region
         FRG = EPNFLRG(W_CR,W_CLRG,W_GR,W_CAR)
         IF (FRG .EQ. 0) write(6,*) 'Fuel Region 0 in WFLOORS ', WNOPER,WECPT,WC_SUM,W_CR, W_CLRG, W_GR, W_CAR
         IF (PLANT .EQ. WIWD .OR. PLANT .EQ. WIPC .OR. PLANT .EQ. WIIG .OR. PLANT .EQ. WIIS  .OR. PLANT .EQ. WIPQ) THEN
            BBN = W_CLRG
         ELSE
            BBN = NERC
         END IF
         IF (IVIN .GT. 1 .AND. IVIN .NE. 15) THEN  ! add costs for planned additions
           IF (IOWN .EQ. 1) THEN
            WFOWN = 1                             ! Ownership Type 1 => Private
!
!           ADD TO EFP'S BUILDS LINKED LIST
!
            WPCST = OVRCST                        ! Over Night Cost for Private Utility
            WC_NP = LEVEL
            CALL UEXPBLD(NERC)
           ELSE
            EWGROE = EPUCRE + UPNRPRM
            EWGINT = EPUIRT + UPNIPRM
            EWGROR = EWGROE * (1.0 - UPNFDT) + &
               EWGINT * UPNFDT
            CALL EPINCST(MNUMYR,UNXPH,ECP_D_FPH,ECP_D_LCP, &
               CLT,PLT,CURIYR,ONE,OVRCST,CPR,CAPD,UPGNPD, &
               EWGINT,UPNFDT,EWGROR,TXBOOK,FNBOOK)
            PRATIO = TXBOOK / FNBOOK
            CAPNNSTL = FNBOOK
            CALL EPCNBLD(DBLE(UPNFDT),PRATIO, &
               DBLE(UPNRPRM),DBLE(UPNIPRM), &
               DBLE(EPUCRE),DBLE(EPUIRT), &
               DBLE(UPTXRT),TLF,NCLF,NLLF, &
               CAPNUG)
            WFOWN = 3                             ! Ownership Type 2 => EWG
            WPCST = CAPNNSTL * CAPNUG             ! Annuity for EWGs
           END IF
         ELSE                                     ! existing addition (uprates), no costs
          IF (IOWN .EQ. 1) WFOWN = 1
          IF (IOWN .EQ. 2) WFOWN = 3
          IF (IOWN .EQ. 10) WFOWN = 1             ! make DGPV owner 1 to avoid grouping with new builds in wfloors
          WPCST = 0.0
         ENDIF

         IF (PLANT .EQ. WIIS)  THEN
             WSEQEF = UPPCEF(WIIS)
         ELSEIF (PLANT .EQ. WICS) THEN
             WSEQEF = UPPCEF(WICS)
         ELSEIF (PLANT .EQ. WIPQ) THEN
             WSEQEF = UPPCEF(WIPQ)
         ELSE
             WSEQEF = 0.0
         ENDIF
!
!        CHARACTER
!
         WSTATE = '00'                            ! State Code
         IF (UPTTYP(PLANT) .GT. NW_COAL) THEN
         W_COMB = 1
         W_POST = 1
         ELSE
            W_COMB = 4
            W_POST = 7
         END IF
         WNOX_R = 0.0
         WNOX_B4 = 0.0
!
!        W_BTP = "00"
!        W_NCT = "00"
!        W_BTM = "0"
!
         W_FOM = UPFOM(JECP)
         W_VOM = UPVOM(JECP)
         IF (IOWN .EQ. 10) THEN
             W_FOM = 0
             W_VOM = 0
         ENDIF


         IF (WNEWGRP(NERC,IEFD,WFOWN,BBN) .EQ. 0) THEN
            WNGRPS(NERC) = WNGRPS(NERC) + 1
            IGRP = WNGRPS(NERC)
            WGRP_NXT = WGRP_NXT + 1
            NWGRP = WGRP_NXT
            WNEWGRP(NERC,IEFD,WFOWN,BBN) = NWGRP
            WTYPE(NWGRP) = IGRP
         ELSE
            NWGRP = WNEWGRP(NERC,IEFD,WFOWN,BBN)
            IGRP = WTYPE(NWGRP)
         END IF
         W_GRP = NWGRP
         W_IGRP = NWGRP
         W_GRP2 = WNXT_SGRP(W_GRP) + 1
         WNXT_SGRP(W_GRP) = W_GRP2
!
!        INSURE THAT NUMBER OF BUILDS DOESN'T EXCEED ALLOCATION
!
         IF (WREC_NXT .GT. WPLT_D_REC) WRITE(6, * ) &
            ' EPO$BILD ERROR: TOO MANY PLANT RECORDS'
!
!        Increment Record Counters
!
         WREC_NXT = WREC_NXT + 1
         W_NXT(WREC_NXT) = W_INT(NERC,IGRP)
         W_INT(NERC,IGRP) = WREC_NXT
         W_CAPAD = 0.0

         I_COAL = MAP_TO_COAL_ID(W_IGRP)

         IF (UPTTYP(PLANT) .LE. NW_COAL) THEN
            IF (I_COAL .EQ. 0) THEN
               NUM_CL_UNIT = NUM_CL_UNIT + 1
               NUM_CL = NUM_CL + 1
               NUM_CMM_UNITS = NUM_CMM_UNITS + 1
               I_COAL = NUM_CL_UNIT
               MAP_TO_COAL_ID(W_IGRP) = NUM_CL_UNIT
               ECL_RG_CAP(NERC,I_COAL) = 0.0
               ECL_RG_CAP(MNUMNR,I_COAL) = 0.0
            END IF
            UCL_CGRP(WREC_NXT) = I_COAL
            UCL_CGRP2(W_GRP) = I_COAL
            ECL_RG_CAP(NERC,I_COAL) = ECL_RG_CAP(NERC,I_COAL) + LEVEL
            ECL_RG_CAP(MNUMNR,I_COAL) = ECL_RG_CAP(MNUMNR,I_COAL) + LEVEL
            DO XYR = W_SYR - UHBSYR , MNUMYR
               EMM_CL_ECPt(I_COAL,XYR) = WECPT
            END DO
         END IF
!
!        WRITE(6,2033) CURIRUN, CURIYR+1989, CURITR, W_IGRP, NERC, W_GRP, W_GRP2, I_COAL, PLANT, W_SYR, W_RYR, WFL(1), WECPT, &
!           WEFDT, IEFD, IOWN, WVIN, BBN, WC_SUM, num_cl, num_cl_unit, num_cmm_units,WSEQEF
 2033    FORMAT(1X,"FROM_WFLOORS",18(":",I5),":",F12.3,3(":",I5),":",F6.2)
         CALL STRPLT(WREC_NXT)

!        SEND PlANNED CCS BUILDS TO CTS MDOEL

                IF (PLANT .EQ. WIIS .or. PLANT .EQ.WICS  .or. PLANT .EQ.WIPQ) THEN
                  IF (LEVEL .GT. 10.0) THEN
                    N_PLTS = N_PLTS + 1
                    N_IGRP(N_PLTS) = W_IGRP
                    N_RY(N_PLTS) = W_SYR
                    N_CFR(N_PLTS) = W_CF
                    N_RG(N_PLTS) = EPNFLRG(W_CR,W_CLRG,W_GR,W_CAR)
                    N_HRAT(N_PLTS) = WHRATE
                    N_CPTY(N_PLTS) = LEVEL
                    N_PTP(N_PLTS) = PLANT
                  write(18,1433) curcalyr,N_PLTS,N_RY(N_PLTS),N_IGRP(N_PLTS),N_RG(N_PLTS),N_CPTY(N_PLTS)*0.001,N_CFR(N_PLTS),N_PTP(N_PLTS)
 1433 format(1h,'!ccsout3P ',I5,1x,I4,1x,3(F10.0,1x),2(F10.3,1x),F10.0)
                  ENDIF
                ENDIF

!
!        IF INT PLANTS SET UADD VARIABLES
!
         IF (IOWN .NE. 10) THEN

             IF (UCPINTIS(PLANT) .GT. 0 ) THEN
               INT = UCPINTIS(PLANT)
               IF (UPLNTCD(UCPINTI(INT)) .EQ. 'SO') THEN
                  UADDSTT(NERC,SYR) = UADDSTT(NERC,SYR) + LEVEL
                  UADDSTT(MNUMNR,SYR) = UADDSTT(MNUMNR,SYR) + LEVEL
                  UADDSTD(NERC,SYR) = UADDSTD(NERC,SYR) + LEVEL
                  UADDSTD(MNUMNR,SYR) = UADDSTD(MNUMNR,SYR) + LEVEL

               ELSEIF (UPLNTCD(UCPINTI(INT)) .EQ. 'PV') THEN
                  UADDPVT(NERC,SYR) = UADDPVT(NERC,SYR) + LEVEL
                  UADDPVT(MNUMNR,SYR) = UADDPVT(MNUMNR,SYR) + LEVEL
                  UADDPVD(NERC,SYR) = UADDPVD(NERC,SYR) + LEVEL
                  UADDPVD(MNUMNR,SYR) = UADDPVD(MNUMNR,SYR) + LEVEL

               ELSEIF (UPLNTCD(UCPINTI(INT)) .EQ. 'PT') THEN
                  UADDPTT(NERC,SYR) = UADDPTT(NERC,SYR) + LEVEL
                  UADDPTT(MNUMNR,SYR) = UADDPTT(MNUMNR,SYR) + LEVEL
                  UADDPTD(NERC,SYR) = UADDPTD(NERC,SYR) + LEVEL
                  UADDPTD(MNUMNR,SYR) = UADDPTD(MNUMNR,SYR) + LEVEL

               ELSEIF (UPLNTCD(UCPINTI(INT)) .EQ. 'WN') THEN
                  UADDWNT(NERC,SYR) = UADDWNT(NERC,SYR) + LEVEL
                  UADDWNT(MNUMNR,SYR) = UADDWNT(MNUMNR,SYR) + LEVEL
                  UADDWND(NERC,SYR) = UADDWND(NERC,SYR) + LEVEL
                  UADDWND(MNUMNR,SYR) = UADDWND(MNUMNR,SYR) + LEVEL

               ELSEIF (UPLNTCD(UCPINTI(INT)) .EQ. 'WL') THEN
                  UADDWLT(NERC,SYR) = UADDWLT(NERC,SYR) + LEVEL
                  UADDWLT(MNUMNR,SYR) = UADDWLT(MNUMNR,SYR) + LEVEL
                  UADDWLD(NERC,SYR) = UADDWLD(NERC,SYR) + LEVEL
                  UADDWLD(MNUMNR,SYR) = UADDWLD(MNUMNR,SYR) + LEVEL

               ELSEIF (UPLNTCD(UCPINTI(INT)) .EQ. 'WF') THEN
                  UADDWFT(NERC,SYR) = UADDWFT(NERC,SYR) + LEVEL
                  UADDWFT(MNUMNR,SYR) = UADDWFT(MNUMNR,SYR) + LEVEL
                  UADDWFD(NERC,SYR) = UADDWFD(NERC,SYR) + LEVEL
                  UADDWFD(MNUMNR,SYR) = UADDWFD(MNUMNR,SYR) + LEVEL
               ENDIF
    !
    !          IF RNW PLANTS SET UADD VARIABLES
    !
             ELSE IF (UCPRNWIS(PLANT) .GT. 0 ) THEN
               RNW = UCPRNWIS(PLANT)
               IF (UPLNTCD(UCPRNWI(RNW)) .EQ. 'HY') THEN
                  UADDHYT(NERC,SYR) = UADDHYT(NERC,SYR) + LEVEL
                  UADDHYT(MNUMNR,SYR) = UADDHYT(MNUMNR,SYR) + LEVEL
                  UADDHYD(NERC,SYR) = UADDHYD(NERC,SYR) + LEVEL
                  UADDHYD(MNUMNR,SYR) = UADDHYD(MNUMNR,SYR) + LEVEL
               ELSEIF (UPLNTCD(UCPRNWI(RNW)) .EQ. 'PS') THEN
                  UADDPST(NERC,SYR) = UADDPST(NERC,SYR) + LEVEL
                  UADDPST(MNUMNR,SYR) = UADDPST(MNUMNR,SYR) + LEVEL
                  UADDPSD(NERC,SYR) = UADDPSD(NERC,SYR) + LEVEL
                  UADDPSD(MNUMNR,SYR) = UADDPSD(MNUMNR,SYR) + LEVEL
               ELSEIF (UPLNTCD(UCPRNWI(RNW)) .EQ. 'GT') THEN
                  UADDGET(NERC,SYR) = UADDGET(NERC,SYR) + LEVEL
                  UADDGET(MNUMNR,SYR) = UADDGET(MNUMNR,SYR) + LEVEL
                  UADDGED(NERC,SYR) = UADDGED(NERC,SYR) + LEVEL
                  UADDGED(MNUMNR,SYR) = UADDGED(MNUMNR,SYR) + LEVEL
               ELSEIF (UPLNTCD(UCPRNWI(RNW)) .EQ. 'WD') THEN
                  UADDWDT(NERC,SYR) = UADDWDT(NERC,SYR) + LEVEL
                  UADDWDT(MNUMNR,SYR) = UADDWDT(MNUMNR,SYR) + LEVEL
                  UADDWDD(NERC,SYR) = UADDWDD(NERC,SYR) + LEVEL
                  UADDWDD(MNUMNR,SYR) = UADDWDD(MNUMNR,SYR) + LEVEL
               ELSEIF (UPLNTCD(UCPRNWI(RNW)) .EQ. 'MS') THEN
                  UADDMST(NERC,SYR) = UADDMST(NERC,SYR) + LEVEL
                  UADDMST(MNUMNR,SYR) = UADDMST(MNUMNR,SYR) + LEVEL
                  UADDMSD(NERC,SYR) = UADDMSD(NERC,SYR) + LEVEL
                  UADDMSD(MNUMNR,SYR) = UADDMSD(MNUMNR,SYR) + LEVEL
               ENDIF
             ENDIF

         ENDIF
!
!        INCREMENT TRANSMISSION CAPACITY AND OVERNIGHT COST
!
!mkm     JYR = SYR - CURIYR
         JYR = SYR - CURIYR
!lc2     JYR = SYR
         TRNSCAP(JYR) = TRNSCAP(JYR) + LEVEL
         IF ((PLANT .LE. ECP_D_DSP .AND. PLANT .NE. WICN .AND. PLANT .NE. WIAN.AND. PLANT .NE. WISM) .OR. PLANT .EQ. WIWD) THEN
           TMPTRCST = FL_CNXT_CST(NERC,FRG)
         ELSE
           TMPTRCST = EPCOVR(PLANT)
         ENDIF
         TRNSCST(JYR) = TRNSCAP(JYR) + TMPTRCST * LEVEL
!
!mkm      END DO   ! LOOP ON PLANT ADDITIONS
!
!     PASS TRANSMISSION CAPACITY AND OVERNIGHT COST TO EFP
!     Reuse Plntin Variables To Pass Aggregate Info to EFP
!
      IF (WVIN .GT. 1 .AND. WVIN .NE. 15) THEN
      WEFPT = EITRAN
      DO JYR = 1 , UNXPH
         IF (TRNSCAP(JYR) .GT. 0.001) THEN
            W_SYR = JYR + USYEAR(CURIYR)
            WC_NP = TRNSCAP(JYR)
            WPCST = TRNSCST(JYR) / TRNSCAP(JYR)
            CALL UEXPBLD(NERC)
         END IF
      END DO
      ENDIF
!
      RETURN
      END


! ********************************************************************
! Subroutine WELAST
!
! invokes the short and long term elasticities.
!
! written by: Michael Kintner-Meyer
! date: 7/25/97
! ---------------------------------------------------------------------
      Subroutine WELAST
      implicit none
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'wrenew'
      include 'rencntl'
      include 'wrenio'

      integer irnt            ! renewable tech counter
      integer istp            ! counter of steps in supply curve
      integer inr             ! region counter

      real largecap           ! national bound simulating free row in LP
      data largecap/5.E5/     ! in [MW]

      do irnt=1,WNTECH
          if (irnt.ne.9 .and. irnt.ne.10 .and.(UTCSSW(irnt).gt.0).and.UTCSSW(irnt).le.3) then
             call WELASTreal(irnt)
!         else
!            do istp=1,MSPTMX
!               UTCAFN(irnt,istp)=largecap
!               do inr=1,MNUMNR
!                  UTCSFN(inr,irnt,istp)=1.0
!               enddo
!            enddo
          endif
      enddo

!      DO inr=1,MNUMNR
!        DO irnt=1,WNTECH
!         DO istp=1,MSPTMX
!           WRITE (IORNDUMP,1000) CURIYR,inr,irnt,istp,
!     &            UTCAFN(irnt,istp),UTCSFN(inr,irnt,istp),SCEN1
!         ENDDO
!        ENDDO
!      ENDDO
!1000  FORMAT('rw_Current_Elasticity:',I2,':',I2,':',I2,':',I2,':',
!     &         F12.3,':',F12.3,':',A18)

      return
      end


! ********************************************************************
! Subroutine WELASTreal
!
! invokes the short and long term elasticities.
!
! written by: Michael Kintner-Meyer
! date: 6/24/97
! ---------------------------------------------------------------------
      Subroutine WELASTreal(irnt)
      implicit none
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'control'
      include 'wrenew'
      include 'rencntl'
      include 'wrenio'
      include 'uefdout'

      integer irnt            ! renewable tech counter
      integer istp            ! counter of steps in supply curve
      integer inr             ! region counter
      logical doprnt

      real value              ! temporary real variable
      real valuenr(MNUMNR)    ! temp. real variable by regions
      real curcap             ! current capacity for ren. tech in [MW]
      real UTCACA(MSPTMX)     ! national capacity additions for constraint in [MW]
      real UTCACS(MSPTMX)     ! capacity value for cost is evaluated in supply curve [MW]
      real getcurcap          ! current capacity function [MW]
      real getcurcn           ! current capacity contraints regional in [MW]
      real STELAST            ! short term elasticity functin

      real LTELAST            ! long term elasticity function
      real curcapmin          ! minimum current capacity for elasticity in [MW]
      data curcapmin /100./


          if (UTCSSW(irnt).gt.0) then


!DSB*****************************************************************
!DSB*****************************************************************
!DSB........Write out supply schedule
!           DO istp = 1, MSPTMX
!             WRITE(IORNDUMP,1000) CURIYR,irnt,istp,curcap, &
!                  UTCACA(istp),UTCACS(istp),SCEN1
!           ENDDO

!1000       FORMAT ('rw_Capacity_Steps:',I2,':',I2,':',I2,':', &
!                    F12.3,':',F12.3,':',F12.3,':',A18)
!DSB*****************************************************************
!DSB*****************************************************************


             do istp=1,MSPTMX
!               value=0.0
!               do inr=1,unrgns
!                  valuenr(inr)=0.0
!               enddo

! ............... get short term elasticity
!               if(UTCSSW(irnt).NE. 2) &
!                 value=STELAST(UTCACS(istp)+curcap,curcap,USTTHR(irnt), &
!                               USTICS(irnt),USTICA(irnt),SCEN1)

! ............... get long term elasticity
!                if(UTCSSW(irnt).GT.1) then
!                   do inr=1,unrgns
!                      valuenr(inr)=LTELAST(irnt,inr,CURIYR)
!                   enddo
!                endif

! ............... assign values to the UTCSFN array
                 do inr=1,unrgns
                     if(UTCSSW(irnt).EQ.2 .OR. UTCSSW(irnt) .EQ. 3) then
                          valuenr(inr)=MAX(0.0,LTELAST(irnt,inr,CURIYR) - 1.0)
                     else
                          valuenr(inr)=0.0
                     endif
                          UTCSFN(inr,irnt,istp)= valuenr(inr)
                 enddo


! ............... assign values to the UTCSFN array
!                do inr=1,unrgns
!                   if(UTCSSW(irnt).EQ.1) then
!                      UTCSFN(inr,irnt,istp)= value
!                      elseif (UTCSSW(irnt).EQ.2) then
!                         UTCSFN(inr,irnt,istp)= valuenr(inr)
!                         elseif (UTCSSW(irnt).EQ.3) then
!                         UTCSFN(inr,irnt,istp)= value+(valuenr(inr)-1)
!                    endif
!                enddo
! .............. determine the constraints on additions. These are added capacity
! .............. for the supply schedule
!               UTCAFN(irnt,istp)=UTCACA(istp)

!DSB.............Write out elasticities
                 DO inr = 1, unrgns
                   WRITE(IORNDUMP,1020) CURIYR,inr,irnt,istp, &
                   UTCSSW(irnt),value,valuenr(inr),UTCAFN(irnt,istp), &
                    UTCSFN(inr,irnt,istp),trim(scen_date)
                 ENDDO
1020             FORMAT('rw_Current_Elasticities:',I2,':',I2,':', &
                          I2,':',I2,':',I2,':',F6.4,':',F6.4,':', &
                          F12.3,':',F6.4,':',A)

             enddo
          endif

!DSB*****************************************************************
!DSB*****************************************************************
!DSB........Write out supply schedule
          DO inr = 1, unrgns
            DO istp = 1, MSPTMX
              WRITE(IORNDUMP,1010) CURIYR,inr,irnt,istp, &
                   UTCSFN(inr,irnt,istp), &
                   UTRSMX(inr,irnt),UTRSCU(inr,irnt), &
                   Getcurcn(inr,irnt,CURIYR),trim(scen_date)
            ENDDO
          ENDDO
1010        FORMAT ('rw_Supply_Schedule:',I2,':',I2,':',I2,':',I2,':', &
                     F12.3,':',F12.3,':',F12.3,':',F12.3,':',A)
!DSB*****************************************************************
!DSB*****************************************************************

!!      ENDDO

      return
      end


! *********************************************************************
! Function Getcurcn(inr,irnt,iyr)
!
! returns the current constraints that are in the WCA??EL variables
! values are in [MW]
!
! dated: 7/14/97
! ---------------------------------------------------------------------
      Function Getcurcn(inr,irnt,iyr)
      implicit none
      include 'parametr'
      include 'emmparm'
      include 'wrenew'

      Integer  inr     ! region pointer
      Integer  irnt    ! technology pointer
      Integer  iyr     ! yeaer pointer

      Real Getcurcn    ! function value in [MW]


      if(irnt.eq.1) then
         Getcurcn=WCAHYEL(inr,iyr)
      else if (irnt.eq.2) then
         Getcurcn=WCAGPEL(inr,iyr)
         elseif(irnt.eq.5) then
           Getcurcn=WCAMSEL(inr,iyr)
           elseif(irnt.eq.6) then   ! biomass
             Getcurcn=WCABMEL(inr,iyr)
             elseif(irnt.eq.7) then
               Getcurcn=WCASTEL(inr,iyr)
               elseif(irnt.eq.8) then
                 Getcurcn=WCAPVEL(inr,iyr)
                 elseif(irnt.eq.9) then
                  Getcurcn=WCAPTEL(inr,iyr)
                  elseif(irnt.eq.10) then
                    Getcurcn=WCAWIEL(inr,iyr)
                    elseif(irnt.eq.11) then
                     Getcurcn=WCAWLEL(inr,iyr)
                     elseif(irnt.eq.12) then
                      Getcurcn=WCAWFEL(inr,iyr)
      endif
      return
      end




! *********************************************************************
! Function LTELAST
!
! Long term elasticities or resource constraint elasticities applied to
! the capital cost of renewable technologies.
! Methodology: Given are n (n=3) steps describing the cost increase as
!              resources are being depleted.
!
! Currently only set up for biomass (6)  in trill BTU
!                      and  wind (9)     in MW  !Wind(WN)=10, WL = 11
!
!
! written by: Michael Kintner-Meyer
! dated:      6/27/97
! --------------------------------------------------------------------
      Function LTELAST(irnt,inr,iyr)
      implicit none
      include 'parametr'
      include 'emmparm'
      include 'wrenew'
      include 'rencntl'

      Real ratio        ! ratio of current + new added over total capability
      Real Ax(MLPTMX)   ! array with x values for table look-up
      Real Ay(MLPTMX)   ! array with y values for table look-up
      Real x            ! x value for table look-up
      Real y            ! y value for table look-up
      Real LTELAST      ! function value, cost multiplier  [-]
      Real remainMW     ! remaining capacity in step [MW]
      Real epsi         ! epsilon for ratio
      data epsi /0.000001/

      Integer irnt      ! renewables technology pointer
      Integer istp      ! pointer for supply points
      Integer inr       ! pointer for EMM regions
      Integer iyr       ! year pointer
      Integer ierror    ! error flag from table lookup
      Integer ltstep    ! step in Long-term elastiticity curve

! ..... currently only set up for geothermal (2) biomass (6) and wind (9)
       if ((irnt.eq.2).or.(irnt.eq.6) .or. (irnt.eq.10).or. (irnt.eq.11)) then

! .....   evaluate the point in the long term supply curve
! .....   1.0 being all of the capacity limited by the resource availability
          if (UTRSMX(inr,irnt).lt. epsi) then
              ratio=0.0
          else
              ratio=UTRSCU(inr,irnt)/UTRSMX(inr,irnt)
          endif

! .....   remap supply array into one-dimensional for table-look up
         do istp=1,MLPTMX
            Ax(istp)=UTRSFC(inr,irnt,istp)
            Ay(istp)=UTCSFC(inr,irnt,istp)
         enddo

! .....  call table look-up subroutine
!mkm         call TBLKUP(Ax,Ay,MLPTMX,ratio,y,ierror)
         call TBLKUP2(Ax,Ay,MLPTMX,ratio,y,ltstep,ierror)

         LTELAST=y


! ...... Revise build constraint to comply with step functions in long
! ...... term elasticities


! ...... for geothermal
         if (irnt.eq.2)then
! ......    Load old constraints in new array
            WOLDCN(inr,irnt)=WCAGPEL(inr,iyr)
            if (ltstep.ge.MLPTMX) then
                remainMW=UTRSMX(inr,irnt)-UTRSCU(inr,irnt)
            else
                remainMW= (UTRSFC(inr,irnt,ltstep+1)*UTRSMX(inr,irnt))- &
                          UTRSCU(inr,irnt)
            endif
            WCAGPEL(inr,iyr)=AMIN1(WCAGPEL(inr,iyr),remainMW)
            WCAGPEL(inr,iyr)=AMAX1(0.0,WCAGPEL(inr,iyr))
         endif

! ...... for biomass
         if (irnt.eq.6)then
! ......    Load old constraints in new array
            WOLDCN(inr,irnt)=WCABMEL(inr,iyr)
            if (ltstep.ge.MLPTMX) then
                remainMW=UTRSMX(inr,irnt)-UTRSCU(inr,irnt)
            else
                remainMW= (UTRSFC(inr,irnt,ltstep+1)*UTRSMX(inr,irnt))- &
                          UTRSCU(inr,irnt)
            endif
            WCABMEL(inr,iyr)=AMIN1(WCABMEL(inr,iyr),remainMW)
            WCABMEL(inr,iyr)=AMAX1(0.0,WCABMEL(inr,iyr))

!           WRITE(6,5555) irnt, iyr+1989, inr, ltstep, MLPTMX, WCABMEL(inr,iyr), remainMW, &
!              UTRSMX(inr,irnt), UTRSCU(inr,irnt), UTRSFC(inr,irnt,ltstep+1)
 5555       FORMAT(1X,"remainMW",5(":",I4), 5(":",F15.3))

         endif

! ...... for wind
         if (irnt.eq.10)then
! ......    Load old constraints in new array
            WOLDCN(inr,irnt)=WCAWIEL(inr,iyr)
            if (ltstep.ge.MLPTMX) then
                remainMW=UTRSMX(inr,irnt)-UTRSCU(inr,irnt)
            else
                remainMW= (UTRSFC(inr,irnt,ltstep+1)*UTRSMX(inr,irnt))- &
                          UTRSCU(inr,irnt)
            endif
!           WCAWIEL(inr,iyr)=AMIN1(WCAWIEL(inr,iyr),remainMW)
!           WCAWIEL(inr,iyr)=AMAX1(0.0,WCAWIEL(inr,iyr))
         endif

! ...... for wind - Low Wind Speed
         if (irnt.eq.11)then
! ......    Load old constraints in new array
            WOLDCN(inr,irnt)=WCAWLEL(inr,iyr)
            if (ltstep.ge.MLPTMX) then
                remainMW=UTRSMX(inr,irnt)-UTRSCU(inr,irnt)
            else
                remainMW= (UTRSFC(inr,irnt,ltstep+1)*UTRSMX(inr,irnt))- &
                          UTRSCU(inr,irnt)
            endif
         endif

      else
         LTELAST=1.
      endif

      return
      end



! *********************************************************************
! Subroutine GETCNTL
! This subroutine reads long and short term capital cost elasticity information
! and build bound data from the 'rendat'
! input file
!
! written by: Michael Kintner-Meyer
! dated:      6/24/97
! --------------------------------------------------------------------
      Subroutine GETCNTL
      implicit none
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'control'
      include 'wrenew'
      include 'rencntl'
      include 'wrenio'
      include 'uefdout'

! ...... Decleration of local variables
      Integer INUNIT,dbg
      integer it,nr,itech,ist
      integer RET_CD,RD$TBL,RD$I2,RD$C1,RD$R1,RD$I1
      Integer FILE_MGR
      External FILE_MGR
      Character *18 NAME1
      Character *8 DUMMY(WNTECH)

      real C1(WNTECH)
      real R1(WNTECH)
      data NAME1/'RENDAT'/
      data dbg /0/

   IF (IJUMPEMRGN.eq.22) THEN
        reglabel(1:IJUMPEMRGN)= (/ &
            '%LT EL NR1% ', &
            '%LT EL NR2% ', &
            '%LT EL NR3% ', &
            '%LT EL NR4% ', &
            '%LT EL NR5% ', &
            '%LT EL NR6% ', &
            '%LT EL NR7% ', &
            '%LT EL NR8% ', &
            '%LT EL NR9% ', &
            '%LT EL NR10%', &
            '%LT EL NR11%', &
            '%LT EL NR12%', &
            '%LT EL NR13%', &
            '%LT EL NR14%', &
            '%LT EL NR15%', &
            '%LT EL NR16%', &
            '%LT EL NR17%', &
            '%LT EL NR18%', &
            '%LT EL NR19%', &
            '%LT EL NR20%', &
            '%LT EL NR21%', &
            '%LT EL NR22%'/)

     ELSEIF(IJUMPEMRGN.eq.25) THEN

       reglabel(1:IJUMPEMRGN)= (/ &
            '%LT EL NR1% ', &
            '%LT EL NR2% ', &
            '%LT EL NR3% ', &
            '%LT EL NR4% ', &
            '%LT EL NR5% ', &
            '%LT EL NR6% ', &
            '%LT EL NR7% ', &
            '%LT EL NR8% ', &
            '%LT EL NR9% ', &
            '%LT EL NR10%', &
            '%LT EL NR11%', &
            '%LT EL NR12%', &
            '%LT EL NR13%', &
            '%LT EL NR14%', &
            '%LT EL NR15%', &
            '%LT EL NR16%', &
            '%LT EL NR17%', &
            '%LT EL NR18%', &
            '%LT EL NR19%', &
            '%LT EL NR20%', &
            '%LT EL NR21%', &
            '%LT EL NR22%', &
            '%LT EL NR23%', &
            '%LT EL NR24%', &
            '%LT EL NR25%'/)
     ENDIF

     INUNIT=FILE_MGR('O',NAME1,.FALSE.)
 !     Write(6,*)'Rendat open'

! ...... Read in Elasticity switch
      RET_CD=RD$TBL(INUNIT,'%COSTSWITCH%',WNTECH,dbg,6)
      RET_CD=RD$C1(DUMMY,1,WNTECH)
      RET_CD=RD$I1(UTCSSW,1,WNTECH)

! ...... Read in short Elasticity
      RET_CD=RD$TBL(INUNIT,'%SHORTTERM EL%',WNTECH,dbg,6)
      RET_CD=RD$C1(DUMMY,1,WNTECH)
      RET_CD=RD$R1(USTTHR,1,WNTECH)     ! Short term elast Threshold
      RET_CD=RD$R1(USTICA,1,WNTECH)     ! fraction of capacity increase
      RET_CD=RD$R1(USTICS,1,WNTECH)     ! fraction of cap. cost increase
      RET_CD=RD$R1(USTCAMX,1,WNTECH)    ! max. point in cap.cost supply curve normalized


! ...... Read in Long Term Elasticity BY REGIONS

      call EMM_RENDAT  

! ...... Read in Biomass Supply Steps
      RET_CD=RD$TBL(INUNIT,'%WSTBMEL   %',1,dbg,6)
      RET_CD=RD$C1(DUMMY,1,1)
      RET_CD=RD$I1(WSTBMEL,1,1)
      IF(WSTBMEL.GT.FSTPMX)THEN
         WRITE(6,1111) WSTBMEL,FSTPMX
 1111  FORMAT(1H ,' The number of supply steps is ',i2,' and the ', &
          'dimension is only ',i2)
!         STOP
         WSTBMEL = FSTPMX
      END IF
      INUNIT=FILE_MGR('C',NAME1,.FALSE.)


!******************************************************************

      do it=1,WNTECH
         write(IORNDUMP,1000) it,UTCSSW(it),USTTHR(it), &
                             USTICA(it),USTICS(it),USTCAMX(it),trim(scen_date)
      enddo
1000   FORMAT('rw_Short_Term_Elasticities_In:',I2,':',I2,':',F7.3,':', &
                F7.3,':',F7.3,':',F7.3,':',A)


      DO nr=1,unrgns
        DO it=1,WNTECH
         DO ist=1,MLPTMX
           write(IORNDUMP,1005) nr,it,ist,UTCSSW(it),UTCSFC(nr,it,ist), &
                              UTRSFC(nr,it,ist),trim(scen_date)
         ENDDO
        ENDDO
      ENDDO
1005   FORMAT('rw_Long_Term_Elasticities_In:',I2,':',I2,':',I2,':', &
                     I2,':',F7.3,':',F7.3,':',A)

      DO it=1,WNTECH
       DO nr=1,unrgns
         write(IORNDUMP,1010) nr,it,WBTECH(it,nr),trim(scen_date)
       ENDDO
      ENDDO
1010   format('rw_Build_Bound_Spec:',I2,':',I2,':',I2,':',A)
!******************************************************************
!******************************************************************

      return
      end




! ****************************************************************
!
!
!
!
!    ######  ####### #     # #         ###   ######
!    #     # #       ##    # #          #    #     #
!    #     # #       # #   # #          #    #     #
!    ######  #####   #  #  # #          #    ######
!    #   #   #       #   # # #          #    #     #
!    #    #  #       #    ## #          #    #     #
!    #     # ####### #     # #######   ###   ######
!
!
! ***************************************************************
!
! RENLIB is a set of routines of general purpose used for the
! renewable fuels module.
!
! written by: Michael Kintner-Meyer
!
!
! *****************************************************************
!  Subroutine MapCtoN(MapMatx,Irow,Icol,A,B)
!
!  Subroutine maps A(Icol) into B(Irow).
!
!  INPUT:
!    Integer: Irow     : Dimension of B
!             Icol     : Dimension of A
!    Real     A        : Array A(Icol)
!             MapMatx: Mapping Matrix (Irow x Icol)
!
!  OUTPUT
!    Real     B        : Array B(Irow)
!
! Written by: Michael Kintner-Meyer
! revised   : 6/6/95
! -------------------------------------------------------------------
      Subroutine MapCtoN(MapMatx,Irow,Icol,A,B,C)
      Implicit none

      integer Irow,Icol,i,j,k,C
      real MapMatx(Irow,Icol),A(Icol,C),B(Irow,C)

! ..... Error trapping
      if(Irow.lt.1 .or. Icol.lt.1) then
         write(*,*) &
           'Error in MapCtoN (Dimensions Irow and Icol are too small'
         write(*,*) 'Irow =', Irow, '  Icol=',Icol
         stop
      endif

! ..... initialize B(i)
      do i=1,Irow
        do j=1,C
         B(i,j)=0.
        enddo !j
      enddo

! ..... Matrix multipication , first rows then columns
      do i=1,Icol
         do j=1,Irow
           do k=1,C
            B(j,k)=B(j,k)+MapMatx(j,i)*A(i,k)
           enddo !k
          enddo !j
      enddo
      return
      end




! *********************************************************************
! Subroutine Tblkup2 (AX,AY,N,x,y,istep,Ierror)
! Special table lookup for WELAST
! returns lookup tab value given X array (AX) and Y array (AY)
! and a given x point. Subroutine will evaluate the y corresponding to x
!
! The passed x value must fall within the Ax(i) value range with a tolerance
! of epsilon, otherwise error message will be triggered.
!
!
!
! Input:
!    real:    AX    : Array with X values
!             AY    : Array with y values
!             x     : x value for wanted y
!
!   interger: N     : Dimension of AX and AY
!             istep : current step in table
!
! Output:
!    real:    y     : y value
!    integer: Ierror: error flag  Ierror=0   ok
!                                 Ierror=1   x is less than lower limit
!                                 Ierror=2   x greater than upper limit
!
! written by: Michael Kintner-Meyer
! date:       5/19/95
! --------------------------------------------------------------------
      Subroutine tblkup2(AX,AY,N,x,y,istep,Ierror)
      implicit none
      include 'parametr'
      include 'emmparm'
      include 'wrenew'
      include 'wrenio'

      integer N,step,Ierror,istep

      real AX(N),AY(N),x,y,epsi,epsi2
      data epsi/0.0001/
      data epsi2/0.001/    ! tolerance to skip into the next step

! ....find position in AX
      step=1
      write(iorndump,100)x,ax,step,n
100   format('x,ax,step,n',F8.3,<n>F8.3,2I6)
      loop_a: do while ((step .le. N) .and. (x.ge.(AX(step)-epsi2)))
         step=step+1
      if (step.gt.N) exit loop_a
      enddo loop_a

      if (step.eq.1) then
          if(x.lt.AX(step)*(1.-epsi)) then
! ....... outside lower limit using epsilon tolerance
             y=AY(step)
             Ierror=1
           else
             y=AY(step)
             Ierror=0
           endif
      else
          if (step.eq.N+1) then
             if (x.gt.AX(step-1)*(1.+epsi))then
! ............ outside upper limit
                y=AY(step-1)
                Ierror=2
              else
                y=AY(step-1)
                Ierror=0
              endif
           else
              y=AY(step-1)
              Ierror=0
           endif
       endif
      istep=MAX0(step-1,1)
      return
      end



! *********************************************************************
! Subroutine Tblkup (AX,AY,N,x,y,Ierror)
!
! returns lookup tab value given X array (AX) and Y array (AY)
! and a given x point. Subroutine will evaluate the y corresponding to x
!
! The passed x value must fall within the Ax(i) value range with a tolerance
! of epsilon, otherwise error message will be triggered.
!
!
!
! Input:
!    real:    AX    : Array with X values
!             AY    : Array with y values
!             x     : x value for wanted y
!
!   interger: N     : Dimension of AX and AY
!
! Output:
!    real:    y     : y value
!    integer: Ierror: error flag  Ierror=0   ok
!                                 Ierror=1   x is less than lower limit
!                                 Ierror=2   x greater than upper limit
!
! written by: Michael Kintner-Meyer
! date:       5/19/95
! --------------------------------------------------------------------
      Subroutine tblkup(AX,AY,N,x,y,Ierror)
      implicit none
      include 'parametr'
      include 'emmparm'
      include 'wrenew'
      include 'wrenio'

      integer N,step,Ierror

      real AX(N),AY(N),x,y,epsi,test_AX
      data epsi/0.0001/

! ....find position in AX
      step=1
!      write(iorndump,100)x,ax,step,n
!100   format('x,ax,step,n',4F8.3,2I6)
        write(iorndump,100)step,n,x,ax
 100  format('step,n,x,ax',2I6,4F8.3)
      test_AX = AX(step)
      do while ((step .le. N) .and. (x.ge.test_AX))
         step=step+1
         if (step .le. N) then
            test_AX = AX(step)
         else
            test_AX = 0.0
         endif
      enddo

      if (step.eq.1) then
          if(x.lt.AX(step)*(1.-epsi)) then
! ....... outside lower limit using epsilon tolerance
             y=AY(step)
             Ierror=1
           else
             y=AY(step)
             Ierror=0
           endif
      else
          if (step.eq.N+1) then
             if (x.gt.AX(step-1)*(1.+epsi))then
! ............ outside upper limit
                y=AY(step-1)
                Ierror=2
              else
                y=AY(step-1)
                Ierror=0
              endif
           else
              y=AY(step-1)
              Ierror=0
           endif
       endif

      return
      end



! *************************************************************
!  Function Maxtbl(A,N)
!
!  Function returns the maximum of Array A with dimension N
!
!  Input:
!     real:  A(n)    : array of dim. N
!
!     integer N      :  dimension of A
!
!  written by: Michael Kintner-Meyer
!  date:       5/25/95
! ---------------------------------------------------------------
      Function Maxtbl(A,N)
      implicit none
      integer N,i
      real Maxtbl,A(N),neginf

      data neginf/-1.E37/

      Maxtbl=neginf
      do i=1,N
         Maxtbl=AMAX1(Maxtbl,A(i))
      enddo
      return
      end


! *************************************************************
!  Function Mintbl(A,N)
!
!  Function returns the minimum of Array A with dimension N
!
!  Input:
!     real:  A(n)    : array of dim. N
!
!     integer N      :  dimension of A
!
!  written by: Michael Kintner-Meyer
!  date:       5/25/95
! ---------------------------------------------------------------
      Function Mintbl(A,N)
      implicit none
      integer N,i
      real Mintbl,A(N),infini

      data infini/1.E37/

      Mintbl=infini
      do i=1,N

         Mintbl=AMin1(Mintbl,A(i))
         write(*,*)i,A(i),Mintbl
      enddo
      return
      end

!
! *********************************************************************
!
!     Subroutine GetPrice
!
!     Linearly interpolates the price (y) given a consumption array AX(rg,yr,i) and and its corresponding price array AY(yr,i)
!              price array now regional also, cga  5/2013  AY(rg,yr,i)
!
!     The passed x value must fall within the AX(rg,yr,i) value range, otherwise error message will be triggered.
!
!     written by: Dave Schoeberlein
!     date:       April, 1999
!     updated to coal demand regions september 2002
!
!
      SUBROUTINE GetPrice(AX,AY,x,y,Ierror,rg,yr)
!
      IMPLICIT NONE
!
!     DECLARATIONS
!
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'wrenew'
      include 'wrenio'

      INTEGER stop     !Flag set when sitting in correct step
      INTEGER step     !Index counter
      INTEGER rg       !CDS region
      INTEGER yr       !Supply curve year
      INTEGER Ierror   !Error trap flag
!                      !Ierror=0   ok
!                      !Ierror=1   Consumption is less than lower limit
!                      !Ierror=2   Consumption greater than upper limit

      REAL AX(NDREG,MNUMYR+ECP_D_FPH,NWDSUPQ) ! Quantity array (Region X Year X Index)
      REAL AY(NDREG,MNUMYR+ECP_D_FPH,NWDSUPP) ! Price array (Region X Year X Index)
      REAL x                                ! Current consumption
      REAL y                                ! Current price
!
!     START SUBROUTINE GETPRICE
!
!     ....find position in AX in which to interpolate
!
      stop=0
      step=1
      DO WHILE (stop.EQ.0 .AND. x.GT.AX(rg,yr,step) .AND. step .LT. NWDSUPP)
         step=step+1
!
!        check for last nonzero step, set large last step and stop
!
         IF (AX(rg,yr,step-1).GT.0.0 .AND. AX(rg,yr,step) .LE. 0.0) THEN
            AX(rg,yr,step) = 99999.99
            AY(rg,yr,step) = 99.99
            stop=1
         ENDIF
      ENDDO

1010  FORMAT('wd_Interpolation_DetailA:',I2,':',I2,':',I2,':', &
              I2,':',F12.3,':',F12.3,':',F12.3,':',F5.2,':',F5.2, &
              ':',A)
!
      IF ( x .LE. 0.0) THEN
         y = AY(rg,yr,2)
         Ierror = 0
      ELSE IF (step.EQ.1) then
!
!        outside lower limit
!
         y = 0.0
         Ierror = 1
      ELSE
         IF (x.GT. AX(rg,yr,step)) THEN
!
!           outside upper limit
!
            y = AY(rg,yr,Step)
            Ierror = 2
       !  ENDIF
         ELSE IF ( X .EQ. AX(rg,yr,step)) THEN
             y = AY(rg,yr,step)
            Ierror = 0
         ELSE
            y = (AY(rg,yr,step) - AY(rg,yr,step-1)) /                           &
                    (AX(rg,yr,step) - AX(rg,yr,step-1)) * (x - AX(rg,yr,step-1)) + AY(rg,yr,step-1)
            Ierror = 0
         ENDIF
      ENDIF
!
!     If price calculated is less than the second step price then send back the second step price.  (Step 1 price in curves is always 0)
!
      IF (y .LT. AY(rg,yr,2)) THEN
         y = AY(rg,yr,2)
      ENDIF
!
!     Write out error if trouble in interpolating price
!
      IF ((CURITR.gt.MAXITR) .OR. (FCRL.EQ.1)) THEN
         IF (ierror .GT. 0) THEN
            write(IORNDUMP,1000) rg,yr,CURIYR,Ierror,step,AX(rg,yr,step),x,y,trim(scen_date)
         ENDIF
      ENDIF
1000  FORMAT('wd_Interpolation_Error:',I2,':',I2,':',I2,':',I2,':',I2,':',F12.3,':',F12.3,':',F12.3,':',A)

!DSB*****************************************************************

      RETURN

      END


!DSB***************************************************************
!DSB           END SUBROUTINE GETPRICE
!DSB***************************************************************


! *************************************************************
!  Function Max_Value(A, X, Y, N)
!
!  Function returns the maximum value of a column in a 3 dimensional
!  array [A] with dimensions X * Y * N
!  [N] is the "depth" of the array
!  [Y] is the "Column" being searched
!  [X] is the "Row" being searched
!
!  Written by: Dave Schoeberlein
!  Date        4/99
! ---------------------------------------------------------------
      Function Max_Value(A, X, Y, N)

      IMPLICIT NONE
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'wrenew'


      INTEGER N   !Depth of array
      INTEGER X   !Row to be searched
      INTEGER Y   !Column to be searched
      INTEGER I   !Counting variable

      REAL Max_Value                    !The function
      REAL A(NDREG,MNUMYR+ECP_D_FPH,NWDSUPQ)    !The Array to be searched
      REAL NEGINF                       !Tolerance
      REAL theValue                     !Current value in array element.

      DATA NEGINF/-1.E37/

!DSB***************************************************************
!DSB           START FUNCTION Max_Value
!DSB***************************************************************

      theValue = NEGINF

      DO I = 1, N
         theValue = AMAX1(theValue,A(X, Y, I))
      ENDDO

      Max_Value = theValue

      RETURN

      END
!DSB***************************************************************
!DSB           END FUNCTION Max_Value
!DSB***************************************************************

!DSB***************************************************************
!
!     ######    #######    #######
!    #      #   #         #       #
!    #      #   #         #       #
!    #          #####     #       #
!    #   ####   #         #       #
!    #      #   #         #       #
!     ######    #######    #######
!
!DSB***************************************************************
!DSB***************************************************************

! *********************************************************************
! SUBROUTINE GEO2000
!
! CALCULATES THE REGIONAL 3 STEP GEOTHERMAL CAPACITY, CAPITAL COSTS, AND
! O&M COSTS SUPPLY CURVES REQUIRED BY THE EMM.
!
!INPUTS:   'WGESITE' FILE -- PETTY INPUT DATA FOR 51 GEOTHERMAL SITES
!          'WGEPARM' GEOTHERMAL PARAMETERS
!
!OUTPUTS:
!
!
!SUBROUTINES :  1. GET_SITE_DATA        READS THE 'PETTY' DATA FROM THE
!                                       'WGESITE" INPUT FILE AND POPULATES
!                                       THE 'GEOSITE' DATA STRUCTURE.
!                                       CALLED ONLY AT FIRST MODEL YEAR
!                                       AND FIRST ITERATION.
!
!               2. GET_PARM_DATA        READS THE GEOTHERMAL PARAMETER FILE
!                                       'WGEPARM'.
!
!               3. BUILD_GEO_CURVES     CREATES THE SUPPLY CURVES.
!                                       POPULATES THE 'GEOCRV', 'GEO_CURVE',
!                                       AND 'CRV_INFO' DATA STRUCTURES.
!                                       CALLED AT LEAST ONCE AT EACH MODEL
!                                       YEAR AND EACH ITERATION.
!                                       CAN RUN MORE THAN ONCE IF AVAILBLE
!                                       CAPACITY RETURNED FOR A REGION = 0
!
!               4. WRITE_DB             OUTPUTS KEY DEBUGGING VARIABLES
!                                       IN A COMMA-DELIMITED FORMAT TO THE
!                                       'WDUMP' OUTPUT FILE.
!                                       CAN BE IMPORTED INTO AN EXCEL WORKBOOK
!                                       STRUCTURE USING UNIX SCRIPT "GET_GEO_DB.SH"
!                                       AND VBA PROGRAM "GEO_OUT.XLS"
!                                       CALLED ONLY IF VARIABLE 'DEBUGGING' = TRUE
! WRITTEN BY: DAVE SCHOEBERLEIN
!             JUNE, 2000
! *********************************************************************
module G_
        INCLUDE 'wgedim'
        INCLUDE 'parametr'   !   standard dimension sizes
        INCLUDE 'ncntrl'     !   control input from integrating module
        INCLUDE 'emmparm'    !   emm local parameters
        INCLUDE 'ecpcntl'
        INCLUDE 'control'
        INCLUDE 'wrenew'     !   global renewables data
        INCLUDE 'wgekparm'   !   rfm-ges key parameters
        INCLUDE 'wgenum'     !   rfm-ges internal numeric data
        INCLUDE 'wgechar'    !   rfm-ges internal character data
        INCLUDE 'wrenio'     !   rfm-ges internal character data
        INCLUDE 'bildin'
        INCLUDE 'bildout'
        INCLUDE 'emshrin'
        INCLUDE 'entcntl'
        INCLUDE 'enewtech'
        INCLUDE 'eusprc'
        INCLUDE 'efpint'
        INCLUDE 'uecpout'
        include 'uefdout'

!DSB*******************************
!DSB    GEO2000 DECLARATIONS
!DSB*******************************
!DSB*****************************************************************
    TYPE GEO_SITE_DATA
        !DATA READ IN FROM WGESITE INPUT FILE (PETTY DATA)
        !THIS STRUCTURE IS POPULATED BY SUBROUTINE 'GET_SITE_DATA'
        !THE NUMBER OF RECORDS = THE NUMBER OF SITES CONTAINED IN
        !THE PETTY INPUT FILE ('WGESITE' INPUT FILE)
        INTEGER SITE_ID
        INTEGER EIA_ID
        CHARACTER(22) NAME      !SITE NAME
        CHARACTER(2) STATE
        INTEGER NERC
        INTEGER CENSUS
        INTEGER TECHTYPE        !1 = BINARY; 2 = FLASH
        REAL CAPACITY_1990      !1990 INSTALLED CAPACITY
        REAL POTENTIAL_CAP(4)   ! (MW)
        REAL CAPACITY_FACTOR    ! 0.00 TO 1.00
        REAL CO2_RATE           !LBS. PER MEGAWATTHOUR
        REAL H2S_RATE           !LBS. PER MEGAWATTHOUR
        REAL EXPLOR_CAP_COST    !(1987$/KW)
        REAL DRILL_CAP_COST     !(1987$/KW)
        REAL FIELD_CAP_COST     !(1987$/KW)
        REAL PLANT_CAP_COST     !(1987$/KW)
        REAL FIELD_OM_COST      !(1987$/KW)
        REAL PLANT_OM_COST      !(1987$/KW)
        REAL HEAT_RATE          !(BTU/KWH)
        REAL COE                !LEVELIZED COST (MILLS/KWHR)
        REAL AVAIL_SUPPLY       !POTENTIAL CAPACITY MINUS
                                !INSTALLED 1990 CAPACITY
        REAL CAP_COST           ! SUM OF DRILLING, FIELD, AND
                                ! PLANT CAPITAL COSTS (ABOVE)
        REAL OM_COST            ! SUM OF FIELD, AND
                                ! PLANT OM COSTS (ABOVE)
        REAL PFILE_EXCAP        ! EXISTING CAPACITY FOR GEOTHERMAL SITE
                                ! FROM EMM PLANT FILE
        REAL SITE_BOUND(MNUMYR) ! YEARLY BUILD LIMITS ON GEOTHERMAL SITES (MW)
        REAL CAPCOST_MULT(MNUMYR) ! YEARLY CAPITAL COST MULTIPLIERS BY GEOTHERMAL SITES
        REAL EXPLOR_CAP_COST_ADJ(MNUMYR)    !(1987$/KW)
        REAL DRILL_CAP_COST_ADJ(MNUMYR)     !(1987$/KW)
        REAL FIELD_CAP_COST_ADJ(MNUMYR)     !(1987$/KW)
        REAL PLANT_CAP_COST_ADJ(MNUMYR)     !(1987$/KW)
        REAL CAP_COST_ADJ(MNUMYR)           ! SUM OF DRILLING, FIELD, AND
                                ! PLANT CAPITAL COSTS (ABOVE)
    END TYPE

     TYPE(GEO_SITE_DATA) :: GEOSITE(MNUMGS)
     TYPE(GEO_SITE_DATA) :: TEMP   !TEMPORARY STRUCTURE USED FOR SORTING
                               !GEOSITE STRUCTURE

!DSB*****************************************************************
    TYPE GEO_CRV_DATA
        !THIS STRUCTURE IS THE PRIMARY STRUCTURE USED TO GENERATE
        !THE THREE STEP SUPPLY CURVES THAT ARE PASSED TO THE EMM.
        !THIS STRUCTURE IS POPULATED BY SUBROUTINE 'BUILD_GEO_CURVES'
        !SUBROUTINE 'BUILD_GEO_CURVES' CREATES 4 RECORDS
        !IN THIS STRUCTURE FOR EACH RECORD IN THE 'GEOSITE' STRUCTURE
        !
                ! RECORD 1 -- BASE COSTS + EXPLORATION COSTS.
        ! RECORD 2 -- BASE COSTS + EXPLORATION COSTS + .33 TIMES
        !             DRILLING & OTHER FIELD COSTS.
        ! RECORD 3 -- BASE COSTS + 2 * EXPLORATION COSTS
        ! RECORD 4 -- BASE COSTS + 2 * EXPLORATION COSTS + .33 TIMES
        !             DRILLING & OTHER FIELD COSTS.

        INTEGER MODEL_YEAR       !CURRENT MODEL YEAR
        INTEGER SITE_ID
        INTEGER EIA_ID
        CHARACTER(22) NAME
        CHARACTER(2) STATE
        INTEGER NERC
        INTEGER CENSUS
        INTEGER TECHTYPE          !1 = BINARY; 2 = FLASH
        REAL COE                  !CALCULATED LEVELIZED COST (MILLS/KWHR)
        REAL AVAIL_SUPPLY         !SUPPLY AVAILABLE FOR RECORD (MW)
        REAL AVAIL_SUPPLY_BOUND   !SUPPLY AVAILABLE FOR RECORD AFTER ENFORCING SITE BOUNDS (MW)
        REAL CUM_SUPPLY           !RUNNING CUMULATIVE SUM OF
                                  ! AVAIALABLE CAPACITY (MW)
        REAL SYS_COST(3)          !RUNNING CUMULATIVE SUM OF
                                  !SYSTEM COST (COE * SITE MW)
                                          !FOR EACH OF THE THREE PRICE SEGMENTS
        REAL SYS_CAP_COST(3)      !RUNNING CUMULATIVE SUM OF
                                  !SYSTEM CAPITAL COST ($/KW * SITE MW)
                                          !FOR EACH OF THE THREE PRICE SEGMENTS
        REAL SYS_OM_COST(3)       !RUNNING CUMULATIVE SUM OF
                                  !SYSTEM O&M COST (MILLS/KWHR * SITE MW)
                                          !FOR EACH OF THE THREE PRICE SEGMENTS
        REAL SYS_HEAT_RATE(3)     !RUNNING CUMULATIVE SUM OF
                                  !HEAT RATE (MMBTU/KWH * SITE MW)
                                          !FOR EACH OF THE THREE PRICE SEGMENTS
        REAL SYS_CAP_FAC(3)       !RUNNING CUMULATIVE SUM OF
                                  !SYSTEM CAPACITY FACTOR (FRACTION * SITE MW)
                                          !FOR EACH OF THE THREE PRICE SEGMENTS
        REAL SYS_CO2_RATE(3)      !RUNNING CUMULATIVE SUM OF
                                  !SYSTEM CO2 EMISSION RATE (LBS/MWH * SITE MW)
                                          !FOR EACH OF THE THREE PRICE SEGMENTS
            REAL CAP_COST             !CAPITAL COST FOR CAPACITY CONTAINED IN
                                  !FOR RECORD (1987$/KW)
        REAL OM_COST              !O&M COST FOR CAPACITY CONTAINED IN
                                  !FOR RECORD (1987$/KW)
        REAL HEAT_RATE            !HEAT RATE FOR CAPACITY CONTAINED IN
                                  !FOR RECORD (BTU/KWH)
        REAL CAP_FAC              !CAPACITY FACTOR FOR CAPACITY CONTAINED IN
                                  !FOR RECORD (FRACTION)
        REAL CO2_RATE             !CO2 EMISSION RATE FOR CAPACITY CONTAINED IN
                                  !FOR RECORD (LBS/MWH)

    END TYPE

     TYPE(GEO_CRV_DATA) :: GEOCRV(6 * MNUMGS)
     TYPE(GEO_CRV_DATA) :: TMPCRV(6 * MNUMGS) !TEMPORARY STRUCTURE USED TO HOLD
                                          !THE VALUES CONTAINED IN 'GEOCRV'
                                              !VALUES ARE WRITTEN BACK TO 'GEOCRV'
                                              !IF AVAILABLE CAPACITY AT HE SITE
                                              !IS GREATER THAN ZERO
     TYPE(GEO_CRV_DATA) :: TEMP2              !TEMPORARY STRUCTURE USED FOR SORTING

!DSB*****************************************************************
    TYPE EMM_CURVE_DATA
        !FINAL CURVES PASSED TO EMM
        REAL EMM_CAP_COST(3)    !FOR EACH OF THESE ARRAYS, FIRST
        REAL EMM_OM_COST(3)     !ELEMENT CONTAINS ACTUAL VALUES.
        REAL EMM_CAPACITY(3)    !ELEMENTS 2 AND 3 CONTAIN MULTIPLIERS
        REAL EMM_HEAT_RATE(3)   !TO BE APPLIED TO ELEMENT 1
        REAL EMM_CAP_FAC(3)     !
        REAL EMM_CO2_RATE(3)    !
    END TYPE

     TYPE(EMM_CURVE_DATA) :: GEO_CURVE(MNUMNR)

!DSB*****************************************************************
    TYPE EXGEO_CAP_DATA
        !GEOTHERMAL EXISTING CAPACITY FROM EMM PLANT FILE
        CHARACTER(8) PLANT_ID    !Plant ID from EMM Geothermal Plant Record
        CHARACTER(25)PLANT_NAME  !Plant Name from "
        INTEGER SITE_ID          !Site ID that maps plant record to Petty data
        CHARACTER(15) SITE_NAME  !Site Name  "
        INTEGER PLANT_VINTAGE    !Plant Vintage from EMM Geothermal Plant Record
        CHARACTER(2) PRIME_MOVER !Prime Mover  "
        INTEGER EFD_TYPE         !EFD_Type from "
        INTEGER NERC             !NERC Region
        CHARACTER(2) STATE       !State
        REAL SUMMER_CAP          !Summer Capacity (MW)
        INTEGER START_YEAR       !Last Unit Start Date
    END TYPE

     TYPE(EXGEO_CAP_DATA) :: EXGEO(NUMEXGS)

!DSB*****************************************************************
    TYPE CURVE_DATA
        !STORES CALCULATED VALUES USED IN BUILDING THE
        !SUPPLY CURVES
        REAL MIN_COE !COE OF FIRST AVAILABLE SITE
        REAL MAX_COE !COE OF SITE AT OR BELOW EMM SIGNAL PRICE
        REAL SEGMENTS(3)  !PRICES CALCULATED FROM SEGMENT
                          !RATIOS.  LAST SEGMENT EQUALS
                          !MAXIMUM COE
        REAL STEP_PRICE(3)       !ACTUAL COE THAT IS AT OR BELOW EACH
                                 !THE PRICES CALCULATED AND STORED IN
                                 !THE SEGMENTS ARRAY (ABOVE)
        REAL STEP_QUAN(3)        !QUANTITY THAT IS AVAILABLE AT
                                 !STEP_PRICE(I)  (MW)
        REAL STEP_CAP_COST(3)    !WEIGHTED AVERAGE CAPITAL COST
                                 ! AT STEP_PRICE(I)  $/KW
        REAL STEP_OM_COST(3)     !WEIGHTED AVERAGE OM COST
                                 !AT STEP_PRICE(I)  $/KW
        REAL STEP_HEAT_RATE(3)   !WEIGHTED AVERAGE HEAT RATE
                                 !AT STEP_PRICE(I)  BTU/KWH
        REAL STEP_CAP_FAC(3)     !WEIGHTED AVERAGE CAPACITY FACTOR
                                 !AT STEP_PRICE(I)  FRACTION
        REAL STEP_CO2_RATE(3)    !WEIGHTED AVERAGE CO2 EMISSION RATE
                                 !AT STEP_PRICE(I)  LBS/MWH
    END TYPE

     TYPE(CURVE_DATA) :: CRV_INFO(MNUMNR)

!DSB*****************************************************************

    INTEGER NUM_SITES  !NUMBER OF SITES IN STRUCTURE 'GEOCRV'
    INTEGER WGESITES   !NUMBER OF GEO SITES IN INPUT FILE

    LOGICAL DEBUGGING  !SET TO TRUE TO WRITE OUTPUT TO 'WDUMP' FILE
    INTEGER I, J, NERC, ISTP, RTECH !COUNTING VARIABLES


      REAL LEARN_FACT             !GEOTHERMAL LEARNING FACTOR FROM ECP
      REAL OPT_FACT               !GEOTHERMAL OPTIMISM FACTOR FROM ECP
      REAL REG_HEAT_RATE(MNUMNR)  !WEIGHTED AVERAGE HEAT RATE BY NERC REGION
      REAL REG_CAP_FAC(MNUMNR)    !WEIGHTED AVERAGE CAPACITY FACTOR BY NERC REGION
      REAL REG_CO2_RATE(MNUMNR)   !WEIGHTED AVERAGE CO2 EMISSION RATE BY NERC REGION
      REAL FXD_CHRG_FACT(MNUMNR)  !FIXED CHARGE FACTOR USED TO
                              !CALCULATE LEVELIZED COSTS FOR EACH SITE

      REAL LVCSTMIN               !MINIMUM LEVELIZED COST OF ALTERNATE TECHNOLOGIES
      REAL EMM_SIGNAL(MNUMNR)     !REGIONAL THRESHOLD COST OF
                                  !ELECTRICITY FROM EMM (MILLS/KWHR)
                                  !UPPER BOUND FOR AVAILABLE CAPACITY

      REAL UNPLAN_GT(MNUMNR)      !TEMPORARY HOLDER FOR UNPLANNED
                              !GEOTHERMAL CAPACITY

      REAL GEO_ADD (MNUMNR)       !UNPLANNED GEOTHERMAL CAPACITY
                              !USED ONLY TO PRESERVE AMOUNT OF
                                  !UNPLANNED BUILDS FOR DEBUG REPORT

      INTEGER NUM_NZERO_SITES     !NUMBER OF GEOTHERMAL SITES IN STRUCTURE
                                  !WITH NON-ZERO CAPACITY AFTER UNPLANNED
                                  !BUILDS HAVE BEEN REMOVED FROM THE CHEAPEST SITES

      INTEGER GEO_ECP_TYPE           !ECP_TYPE FOR GEOTHERMAL TECHNOLOGY
      INTEGER GEO_REG_INDEX(MNUMNR)  ! EQUALS 1 if there are geosites in this region
                                     ! EQUALS 0 if there are no geosites in this region

      REAL GEO_AVOID_COST(MNUMNR) !GEOTHERMAL AVOIDED COST FROM ECP - MILLS/KWHR

      INTEGER PASSES              !STORES NUMBER OF CALLS TO
                              !SUBROUTINE 'BUILD_GEO_CURVES'

      INTEGER MAXPASSES        
      LOGICAL RUN_AGAIN           !SET TO TRUE IF NO CAPACITY IN REGIONS 11, 12, OR 13
      end module G_
!DSB***************************************************************
!DSB           START SUBROUTINE GEO2000
!DSB***************************************************************
      SUBROUTINE GEO2000
      use G_

      IMPLICIT NONE


    DEBUGGING = .TRUE.   !SET DEBUGGING MODE TO GENERATE REPORT
    MAXPASSES = 10

    !GET ECP INDEX FOR GEOTHERMAL TECHNOLOGY
    DO J = 1, ECP_D_CAP
       IF (UPLNTCD(J) .EQ. 'GT') THEN
         GEO_ECP_TYPE = J
       ENDIF
    ENDDO

    !GET FIXED CHARGE FACTOR FROM EMM IF AFTER ECP START YEAR
    !ELSE USE 13 PERCENT.  ALSO, GET AVOIDED COST INCREMENTED
    !BY THE TOLERANCE LEVEL FOR
    !ALSO GET OPTIMISM AND LEARNING FACTORS FROM ECP
    !THE GEOTHERMAL TECHNOLOGY.  THIS WILL BE THE UPPER BOUND
    !OF COE FOR CAPACITY IN THE REGION.
    IF (CURIYR + UHBSYR .GE. ( UPAVLYR(GEO_ECP_TYPE) - UPPLYR(GEO_ECP_TYPE) ) .AND. CURIYR + UHBSYR .GE. UPSTYR ) THEN
           LEARN_FACT = UPLRLC(GEO_ECP_TYPE)
           OPT_FACT = UPLROPT(GEO_ECP_TYPE)
!  CALL SUBROUTINE TO DETERMINE MINIMUM LEVELIZED COSTS OF OTHER TECHNOLOGIES

!           WRITE(6,7118) CURIRUN, CURIYR+1989, UNRGNS, MNUMNR, WIGT
!7118       FORMAT(1X,"RENEW_ECPLVCST_9176",5(":",I4))

            CALL ECPLVCST(1,CURIYR,MNUMNR,UPMCF(WIGT),LVCSTMIN)
       DO NERC = 1, unrgns
            CALL GETBOUT(CURIYR,NERC)
            CALL ECPLVCST(2,CURIYR,NERC,UPMCF(WIGT),LVCSTMIN)
            FXD_CHRG_FACT(NERC) = EPLVFCF(GEO_ECP_TYPE,2)
            IF (FXD_CHRG_FACT(NERC) .EQ. 0.0) FXD_CHRG_FACT(NERC)=0.13
!               GEO_AVOID_COST(NERC) = EPTAVD(GEO_ECP_TYPE)
            GEO_AVOID_COST(NERC) = LVCSTMIN + &     ! adjust for RPS credits
                                                  RENEWCR(CURIYR)
            EMM_SIGNAL(NERC) = GEO_AVOID_COST(NERC) * (1.0 + EPMSTOL)
       ENDDO
    ELSE
           LEARN_FACT = 1.0
           OPT_FACT = 1.0
       DO NERC = 1, MNUMNR
           FXD_CHRG_FACT(NERC) = 0.13
           EMM_SIGNAL(NERC) = 4.5 * 10.0
       ENDDO
    END IF
    write(IORNDUMP,*) ' learn,opt,yr ',learn_fact,opt_fact,curiyr



    !READ DATA FROM WGESITE INPUT FILE -- "PETTY DATA"
        !CALL SUBROUTINE TO READ WGEPARM INPUT INSIDE GET_SITE_DATA SUBROUTINE
    IF ((CURCALYR .EQ. UESTYR) .AND. (CURITR .EQ. 1)) THEN
        CALL GET_SITE_DATA
    ENDIF

    !BUILD SUPPLY CURVES
      CALL BUILD_GEO_CURVES

     !IF AVAILABLE CAPACITY IN THE FIRST SUPPLY CURVE STEP
     !CALCULATED BY 'BUILD_GEO_CURVES'
     !EQUALS ZERO FOR REGIONS 11, 12, OR 13 THEN INCREASE
     !THE EMM'S THRESHOLD VALUE AND SET RUN_AGAIN = TRUE.
     RUN_AGAIN = .FALSE.
     DO NERC = 1 , UNRGNS
      IF ( GEO_REG_INDEX(NERC) .EQ. 1 ) THEN
        IF (CRV_INFO(NERC)%STEP_QUAN(1) .EQ. 0.0) THEN
            EMM_SIGNAL(NERC) = EMM_SIGNAL(NERC) * 1.02
            RUN_AGAIN = .TRUE.
        ENDIF
      ENDIF
     ENDDO

     !ITERATE SUBROUTINE 'BUILD_GEO_CURVES' UNTIL THE CAPACITY
     !AVAILBALE CALCULATED FOR THE FIRST SUPPLY STEP IS GREATER
     !THAN ZERO IN REGIONS 11, 12 AND 13 OR THE SUBROUTINE IS
     !CALLED 10 TIMES.  INCRENET THE EMM THRESHOLD BETWEEN EACH
     !SUBROUTINE CALL.
     PASSES = 0
     DO WHILE (RUN_AGAIN .AND. PASSES .LE. MAXPASSES)
        CALL BUILD_GEO_CURVES
       RUN_AGAIN = .FALSE.
          DO NERC = 1 , UNRGNS
            IF ( GEO_REG_INDEX(NERC) .EQ. 1 ) THEN
             IF (CRV_INFO(NERC)%STEP_QUAN(1) .EQ. 0.0) THEN
               EMM_SIGNAL(NERC) = EMM_SIGNAL(NERC) * 1.02
               RUN_AGAIN = .TRUE.
             ENDIF
            ENDIF
          ENDDO
          IF (RUN_AGAIN .EQ. .TRUE.) THEN
            PASSES = PASSES + 1
          ENDIF
     ENDDO

    !WRITE DATA TO FILE 'WDUMP' IF 'DEBUGGING' = TRUE
    IF (DEBUGGING) THEN
!       IF ((CURITR .GT. MAXITR) .OR. (FCRL .EQ. 1)) THEN
          CALL WRITE_DB
!    ENDIF
    ENDIF
!
!   SET SUPPLY CURVE DATA FOR ECP
!      2 = Geothermal Flash
!
      DO NERC = 1, unrgns
        DO ISTP = 1 , MSPTMX
          IF ( ISTP .EQ. 1) THEN
            UTCAFNR(NERC,2,ISTP) = GEO_CURVE(NERC)%EMM_CAPACITY(ISTP)
            UTCSFN(NERC,2,ISTP)  = 1.0
            UTFXFN(NERC,2,ISTP)  = 1.0
            UTVRFN(NERC,2,ISTP)  = 1.0
          ELSE
            UTCAFNR(NERC,2,ISTP) = GEO_CURVE(NERC)%EMM_CAPACITY(ISTP)
            UTCSFN(NERC,2,ISTP)  = GEO_CURVE(NERC)%EMM_CAP_COST(ISTP)
            UTFXFN(NERC,2,ISTP)  = GEO_CURVE(NERC)%EMM_OM_COST(ISTP)
            UTVRFN(NERC,2,ISTP)  = 1.0
          ENDIF
!
          IF (GEO_REG_INDEX(NERC) .EQ. 1 ) THEN
            IF (UTCAFNR(NERC,2,1) .EQ. 0.0 ) THEN
              write(6,2251) ' warning: no geo capacity in first step of supply curve year: ',curiyr,' region: ',nerc
            ENDIF
          ENDIF

  2251  format(a,I5,a,I5)
!       write(IORNDUMP,*) ' UT VARS NERC STP',UTCAFNR(NERC,2,ISTP),UTCSFN(NERC,2,ISTP),  &
!                UTFXFN(NERC,2,ISTP),UTVRFN(NERC,2,ISTP),NERC,ISTP
        ENDDO
!
!       PUT INITIAL FIXED O&M and CAPITAL COSTS INTO BASE VALUE FOR THE ECP
!
        WCAGPEL(NERC,CURIYR) = GEO_CURVE(NERC)%EMM_CAPACITY(1)
        WCCGPEL(NERC,CURIYR) = GEO_CURVE(NERC)%EMM_CAP_COST(1)
        WOCGPEL(NERC,CURIYR) = GEO_CURVE(NERC)%EMM_OM_COST(1)
!       WHRGPEL(NERC,CURIYR) = GEO_CURVE(NERC)%EMM_HEAT_RATE(1)
        WHRGPEL(NERC,CURIYR) = REG_HEAT_RATE(NERC)
        WEMGPEL(3,NERC,CURIYR) = REG_CO2_RATE(NERC)
        WCFGPEL(NERC,CURIYR) = REG_CAP_FAC(NERC)
!       write(6,*) ' gpel vars ',WCCGPEL(NERC,CURIYR),WOCGPEL(NERC,CURIYR),WHRGPEL(NERC,CURIYR), &
!                 wemgpel(3,nerc,curiyr),wcfgpel(nerc,curiyr)
      ENDDO

    CONTAINS

!DSB*************************************************************
!DSB*************************************************************
                                                               !*
      SUBROUTINE GET_SITE_DATA                           !*
      USE SQLITE
     IMPLICIT NONE                                             !*
                                                               !*
!DSB*************************************************************
!DSB*************************************************************

    !DSB*******************************
    !DSB GET_SITE_DATA DECLARATIONS
    !DSB*******************************
    
        REAL EXCAP,MULT(MNUMYR)    
    INTEGER I, J, NERC, IYR     !COUNTING VARIABLES
    INTEGER strtyr,syr,tyr,gsite,iyear,num_mults,isite
    INTEGER IUNIT               !OUPUT FILE UNIT NUMBER
    INTEGER FILE_MGR            !NEMS FILE MANAGER RETURN VALUE
        EXTERNAL FILE_MGR
        CHARACTER*25 FNAME
        CHARACTER*22 GNAME

        type(sqlite_database)                      :: db
        type(sqlite_statement)                     :: stmt
        type(sqlite_statement)                     :: stmt2
        type(sqlite_statement)                     :: stmt3
        type(sqlite_column), dimension(:), pointer :: col
        type(sqlite_column), dimension(:), pointer :: col2
        type(sqlite_column), dimension(:), pointer :: col3
        character(len=40), pointer, dimension(:)   :: result
        character(len=80)                          :: errmsg
        logical                                    :: finished  
    !DSB********************************************************
    !DSB           START SUBROUTINE GET_SITE_DATA
    !DSB********************************************************

    GEO_REG_INDEX = 0
     
    call sqlite3_open( 'emm_db/NEMS_INPUT.db', db )
      
    allocate (col(23))
    call sqlite3_column_query( col(1), 'ID', sqlite_int )
    call sqlite3_column_query( col(2), 'EMM_RGN', sqlite_int )
    call sqlite3_column_query( col(3), 'SITE_ID', sqlite_int )
    call sqlite3_column_query( col(4), 'EIA_ID', sqlite_int )
    call sqlite3_column_query( col(5), 'NAME', sqlite_char )
    call sqlite3_column_query( col(6), 'STATE', sqlite_char )
    call sqlite3_column_query( col(7), 'CENSUS', sqlite_int )
    call sqlite3_column_query( col(8), 'TECHTYPE', sqlite_int )
    call sqlite3_column_query( col(9), 'CAPACITY_1990', sqlite_real )
    call sqlite3_column_query( col(10), 'POTENTIAL_CAP_1', sqlite_real )
    call sqlite3_column_query( col(11), 'POTENTIAL_CAP_2', sqlite_real )
    call sqlite3_column_query( col(12), 'POTENTIAL_CAP_3', sqlite_real )
    call sqlite3_column_query( col(13), 'POTENTIAL_CAP_4', sqlite_real )
    call sqlite3_column_query( col(14), 'CAPACITY_FACTOR', sqlite_real )
    call sqlite3_column_query( col(15), 'CO2_RATE', sqlite_real )
    call sqlite3_column_query( col(16), 'H2S_RATE', sqlite_real )
    call sqlite3_column_query( col(17), 'EXPLOR_CAP_COST', sqlite_real )
    call sqlite3_column_query( col(18), 'DRILL_CAP_COST', sqlite_real )
    call sqlite3_column_query( col(19), 'FIELD_CAP_COST', sqlite_real )
    call sqlite3_column_query( col(20), 'PLANT_CAP_COST', sqlite_real )
    call sqlite3_column_query( col(21), 'FIELD_OM_COST', sqlite_real )
    call sqlite3_column_query( col(22), 'PLANT_OM_COST', sqlite_real )
    call sqlite3_column_query( col(23), 'HEAT_RATE', sqlite_real )
    call sqlite3_prepare_select( db, 'V_EMM_WGESITE', col, stmt)

   do
   call sqlite3_next_row( stmt, col, finished )
   if ( finished ) exit
      
   call sqlite3_get_column( col(1), I)
   call sqlite3_get_column( col(2), GEOSITE(I)%NERC )
   call sqlite3_get_column( col(3), GEOSITE(I)%SITE_ID )
   call sqlite3_get_column( col(4), GEOSITE(I)%EIA_ID )
   call sqlite3_get_column( col(5), GEOSITE(I)%NAME )
   call sqlite3_get_column( col(6), GEOSITE(I)%STATE )
   call sqlite3_get_column( col(7), GEOSITE(I)%CENSUS )
   call sqlite3_get_column( col(8), GEOSITE(I)%TECHTYPE )
   call sqlite3_get_column( col(9), GEOSITE(I)%CAPACITY_1990 )
   call sqlite3_get_column( col(10), GEOSITE(I)%POTENTIAL_CAP(1) )
   call sqlite3_get_column( col(11), GEOSITE(I)%POTENTIAL_CAP(2) )
   call sqlite3_get_column( col(12), GEOSITE(I)%POTENTIAL_CAP(3) )
   call sqlite3_get_column( col(13), GEOSITE(I)%POTENTIAL_CAP(4) )
   call sqlite3_get_column( col(14), GEOSITE(I)%CAPACITY_FACTOR )
   call sqlite3_get_column( col(15), GEOSITE(I)%CO2_RATE )
   call sqlite3_get_column( col(16), GEOSITE(I)%H2S_RATE )
   call sqlite3_get_column( col(17), GEOSITE(I)%EXPLOR_CAP_COST )
   call sqlite3_get_column( col(18), GEOSITE(I)%DRILL_CAP_COST )
   call sqlite3_get_column( col(19), GEOSITE(I)%FIELD_CAP_COST )
   call sqlite3_get_column( col(20), GEOSITE(I)%PLANT_CAP_COST )
   call sqlite3_get_column( col(21), GEOSITE(I)%FIELD_OM_COST )
   call sqlite3_get_column( col(22), GEOSITE(I)%PLANT_OM_COST )
   call sqlite3_get_column( col(23), GEOSITE(I)%HEAT_RATE )

   end do
   num_sites=I
   WGESITES=I
   deallocate ( col )
   call sqlite3_close( db )
   
        write(IORNDUMP,*) ' number of geo sites ',num_sites
900 FORMAT (I3)
     DO I=1,Num_sites
    !POPULATE STRUCTURE "GEOSITE' WITH DATA FROM FILE
   write(iorndump,936) ' geosite data ', &
       GEOSITE(I)%SITE_ID, & 
       GEOSITE(I)%EIA_ID, & 
       GEOSITE(I)%NAME, & 
       GEOSITE(I)%STATE, & 
       GEOSITE(I)%NERC, & 
       GEOSITE(I)%CENSUS, & 
       GEOSITE(I)%TECHTYPE, & 
       GEOSITE(I)%CAPACITY_1990, & 
       GEOSITE(I)%POTENTIAL_CAP(1), & 
       GEOSITE(I)%POTENTIAL_CAP(2), & 
       GEOSITE(I)%POTENTIAL_CAP(3), & 
       GEOSITE(I)%POTENTIAL_CAP(4), & 
       GEOSITE(I)%CAPACITY_FACTOR, & 
       GEOSITE(I)%CO2_RATE, & 
       GEOSITE(I)%H2S_RATE, & 
       GEOSITE(I)%EXPLOR_CAP_COST, & 
       GEOSITE(I)%DRILL_CAP_COST, & 
       GEOSITE(I)%FIELD_CAP_COST, & 
       GEOSITE(I)%PLANT_CAP_COST, & 
       GEOSITE(I)%FIELD_OM_COST, & 
       GEOSITE(I)%PLANT_OM_COST, &
       GEOSITE(I)%HEAT_RATE  
936 FORMAT(a,I3,I5,A22,A2,I2,2I1,F4.0,4F5.0,F4.2,F6.2,F4.2,F7.2,5F8.2,F6.0)
       
!
!   testing removal of 4th capacity group
!               GEOSITE(I)%POTENTIAL_CAP(4) = 0.0
!           IF (GEOSITE(I)%NERC .EQ. 13) THEN
!       GEOSITE(I)%EXPLOR_CAP_COST = GEOSITE(I)%EXPLOR_CAP_COST * .90 
!       GEOSITE(I)%DRILL_CAP_COST = GEOSITE(I)%DRILL_CAP_COST * .90
!       GEOSITE(I)%FIELD_CAP_COST = GEOSITE(I)%FIELD_CAP_COST * .90
!       GEOSITE(I)%PLANT_CAP_COST = GEOSITE(I)%PLANT_CAP_COST * .90
!       GEOSITE(I)%FIELD_OM_COST  = GEOSITE(I)%FIELD_OM_COST * .90
!       GEOSITE(I)%PLANT_OM_COST  = GEOSITE(I)%PLANT_OM_COST * .90
!            ENDIF
!
        NERC = GEOSITE(I)%NERC
        GEO_REG_INDEX(NERC) = 1

       !CALCULATE COE FOR EACH SITE

        GEOSITE(I)%COE = ( ((GEOSITE(I)%DRILL_CAP_COST + &
                           GEOSITE(I)%FIELD_CAP_COST + &
                               GEOSITE(I)%PLANT_CAP_COST)* &
                               FXD_CHRG_FACT (NERC) *  &
                               LEARN_FACT * OPT_FACT ) + &
                              (GEOSITE(I)%FIELD_OM_COST  + &
                               GEOSITE(I)%PLANT_OM_COST)) / &
                              (GEOSITE(I)%CAPACITY_FACTOR * &
                               8760.0) * 1000.0
!        write(iorndump,910) ' geosite COE ', I,&      
!         GEOSITE(I)%COE,GEOSITE(I)%DRILL_CAP_COST,GEOSITE(I)%FIELD_CAP_COST,GEOSITE(I)%PLANT_CAP_COST, &
!          FXD_CHRG_FACT (NERC), LEARN_FACT, OPT_FACT ,  GEOSITE(I)%FIELD_OM_COST,  &
!          GEOSITE(I)%PLANT_OM_COST,GEOSITE(I)%CAPACITY_FACTOR
	          
                               
       !CALCULATE CAPITAL AND O&M FOR EACH SITE
        GEOSITE(I)%CAP_COST = GEOSITE(I)%DRILL_CAP_COST + &
                              GEOSITE(I)%FIELD_CAP_COST + &
                                  GEOSITE(I)%PLANT_CAP_COST
!        write(iorndump,910) ' geosite CAP_COST ', I,&      
!        GEOSITE(I)%CAP_COST ,GEOSITE(I)%DRILL_CAP_COST, &
!                GEOSITE(I)%FIELD_CAP_COST ,  GEOSITE(I)%PLANT_CAP_COST
                                  
        GEOSITE(I)%OM_COST = (GEOSITE(I)%FIELD_OM_COST + &
                              GEOSITE(I)%PLANT_OM_COST)
!        write(iorndump,910) ' geosite OM_COST ', I,&      
!        GEOSITE(I)%OM_COST,GEOSITE(I)%FIELD_OM_COST, GEOSITE(I)%PLANT_OM_COST
    ENDDO
910 FORMAT(a,1x,I3,1x,12(F12.3,1x))
!  
!    SYR=11
!    
!    call sqlite3_open( 'emm_db/NEMS_INPUT.db', db )
!          
!    allocate (col2(5))
!    call sqlite3_column_query( col2(1), 'GSITE', sqlite_int )
!    call sqlite3_column_query( col2(2), 'GNAME', sqlite_char )
!    call sqlite3_column_query( col2(3), 'YEAR', sqlite_int )
!    call sqlite3_column_query( col2(4), 'SITE_BOUND', sqlite_real )
!    call sqlite3_column_query( col2(5), 'CAPCOST_MULT', sqlite_real )
!    call sqlite3_prepare_select( db, 'V_EMM_WGESITE_BOUND', col2, stmt2)

!    do
!    call sqlite3_next_row( stmt2, col2, finished )
!    if ( finished ) exit
!      
!    call sqlite3_get_column( col2(1), I)
!    call sqlite3_get_column( col2(2), GNAME )
!    call sqlite3_get_column( col2(3), STRTYR)
!    call sqlite3_get_column( col2(4), GEOSITE(I)%site_bound(STRTYR-1989) )
!    call sqlite3_get_column( col2(5), GEOSITE(I)%capcost_mult(STRTYR-1989) )
!    
!    Write(iorndump,*)'checkgeo ',I,GNAME,STRTYR,GEOSITE(I)%site_bound(STRTYR-1989) ,GEOSITE(I)%capcost_mult(STRTYR-1989) 
!    
!    SYR = MIN(SYR,STRTYR-1989)
!    
!    end do
!    deallocate ( col2 )
!    call sqlite3_close( db )

!    !950 FORMAT(I3,1X,A22,<TYR>(1X,F3.0))
!    !980 FORMAT(A,I3,1X,<MNUMYR>(1X,F3.0))
!      do i = 1 , num_sites
!       do iyear = 1 , syr - 1
!         geosite(i)%site_bound(iyear) = 50.0  
!       enddo
!      enddo
!      do i = 1 , num_sites
!        write(iorndump,*) ' GEO bounds ',i,SYR,(geosite(i)%site_bound(iyear),iyear=1,MNUMYR)
!      enddo   
!      
!
!      do i = 1 , num_sites
!       do iyear = 1 , syr - 1
!         geosite(i)%capcost_mult(iyear) = 1.00  
!       enddo
!      enddo
!      do i = 1 , num_sites
!        write(iorndump,*) ' GEO capcostmult ',i,(geosite(i)%capcost_mult(iyr),iyr=1,MNUMYR)
!      enddo

!    CALL SUBROUTINE TO READ WGEPARM INPUT
           CALL GET_PARM_DATA
!
!     adjust capital costs by capital cost multiplier
!     multiplier = 1 for default, ? for hirenew, etc.
!
    DO I = 1, WGESITES
         DO IYR = 1 , MNUMYR
!       write(iorndump,*) ' before capcost mult ',geosite(I)%CAPCOST_MULT(IYR),GEOSITE(I)%EXPLOR_CAP_COST, &
!            geosite(I)%drill_cap_cost,geosite(I)%field_cap_cost,geosite(I)%plant_cap_cost
    GEOSITE(I)%CAP_COST_ADJ(IYR) = GEOSITE(I)%CAP_COST * GEOSITE(I)%CAPCOST_MULT(IYR)
    GEOSITE(I)%EXPLOR_CAP_COST_ADJ(IYR) = GEOSITE(I)%EXPLOR_CAP_COST * GEOSITE(I)%CAPCOST_MULT(IYR)
    GEOSITE(I)%DRILL_CAP_COST_ADJ(IYR) = GEOSITE(I)%DRILL_CAP_COST * GEOSITE(I)%CAPCOST_MULT(IYR)
    GEOSITE(I)%FIELD_CAP_COST_ADJ(IYR) = GEOSITE(I)%FIELD_CAP_COST * GEOSITE(I)%CAPCOST_MULT(IYR)
    GEOSITE(I)%PLANT_CAP_COST_ADJ(IYR) = GEOSITE(I)%PLANT_CAP_COST * GEOSITE(I)%CAPCOST_MULT(IYR)
!
!       write(iorndump,*) ' after capcost mult ',geosite(I)%CAPCOST_MULT(IYR),GEOSITE(I)%EXPLOR_CAP_COST_ADJ(IYR), &
!            geosite(I)%drill_CAP_COST_ADJ(IYR),geosite(I)%field_CAP_COST_ADJ(IYR),geosite(I)%plant_CAP_COST_ADJ(IYR)
          ENDDO
        ENDDO
!    SUBTRACT 1990 CAPACITY FROM POTENTIAL CAPACITY
! remove this sections rsm numbers do not include existing capacity
!   DO I = 1, NUM_SITES
!         EXCAP = GEOSITE(I)%PFILE_EXCAP
!         DO J = 1 , 4
!           IF (EXCAP .GT. 0.0) THEN
!             IF (EXCAP .GT. GEOSITE(I)%POTENTIAL_CAP(J)) THEN
!               EXCAP = EXCAP - GEOSITE(I)%POTENTIAL_CAP(J)
!               GEOSITE(I)%POTENTIAL_CAP(J) = 0.0
!             ELSE
!               GEOSITE(I)%POTENTIAL_CAP(J) = GEOSITE(I)%POTENTIAL_CAP(J) - EXCAP
!               EXCAP = 0.0
!             ENDIF
!           ENDIF
!         ENDDO
!         IF (EXCAP .NE. 0.0) THEN
!          WRITE(6,*) ' ** WARNING: EXISTING CAPACITY GREATER THEN POTENTIAL CAPACITY GEOTHERMAL SITE # ',&
!                       I
!     WRITE(IORNDUMP,*) ' ** WARNING: EXISTING CAPACITY GREATER THEN POTENTIAL CAPACITY GEOTHERMAL SITE # ',&
!                       I
!         ENDIF
!       ENDDO

!   SORT INPUT DATASET BY NERC AND COE
    DO J = 1, (NUM_SITES-1)
      DO I = (J+1), NUM_SITES
        IF ( (DBLE(GEOSITE(J)%NERC) + DBLE(GEOSITE(J)%COE/10000.0)) .GT. &
             (DBLE(GEOSITE(I)%NERC) + DBLE(GEOSITE(I)%COE/10000.0)) ) THEN
               TEMP = GEOSITE(J)
               GEOSITE(J) = GEOSITE(I)
               GEOSITE(I) = TEMP
        ENDIF
      ENDDO
    ENDDO

    END SUBROUTINE GET_SITE_DATA

    !DSB********************************************************
    !DSB           END SUBROUTINE GET_SITE_DATA
    !DSB********************************************************

!DSB*************************************************************
!DSB*************************************************************
                                                               !*
       SUBROUTINE BUILD_GEO_CURVES
       IMPLICIT NONE                                           !*
                                                           !*
!DSB*************************************************************
!DSB*************************************************************

    !DSB*******************************
    !DSB BUILD_GEO_CURVES DECLARATIONS
    !DSB*******************************

    INTEGER I, IYR, J, K, NERC, ID    !COUNTING VARIABLES
        REAL CUM_CAP             !CUMULATIVE CAPACITY AT EACH STEP (MW)
    LOGICAL MAX_FOUND        !SET WHEN THE SITE COE IS GREATER THAN
                             !OR EQUAL TO THE EMM THRESHOLD PRICE

        REAL SITE_COE            !TEMPORARY HOLDER FOR EACH SITE'S COE
    REAL STEP_QUAN           !TEMPORARY HOLDER FOR REGION'S CUMULATIVE
                             !CAPACITY (MW)
        REAL SITE_CAP_COST       !TEMPORARY HOLDER FOR EACH SITE'S CAPITAL COST
        REAL SITE_OM_COST        !TEMPORARY HOLDER FOR EACH SITE'S O&M COST
        REAL SITE_HEAT_RATE      !TEMPORARY HOLDER FOR EACH SITE'S HEAT RATE
        REAL SITE_CAP_FAC        !TEMPORARY HOLDER FOR EACH SITE'S CAPACITY FACTOR
        REAL SITE_CO2_RATE       !TEMPORARY HOLDER FOR EACH SITE'S CO2 EMISSION RATE

        LOGICAL MIN_CAP_FOUND   !CONVENIENCE VARIABLES USED TO
    REAL TOTAL_PRICE        !CALCULATE THE WEIGHTED AVERAGE
    REAL TOTAL_CAP          !PRICE AND QUANTITY FOR EACH SUPPLY
    REAL TOTAL_OM           !STEP
    REAL TOTAL_HRATE        !
    REAL TOTAL_CAPFAC       !
    REAL TOTAL_CO2RATE      !
    REAL TOTAL_QUAN         !
    REAL TOT_HRATE        ! VARIABLES USED TO CALCULATE REGIONAL
    REAL TOT_CAPFAC       ! WEIGHTED AVERAGE HEAT RATES,
    REAL TOT_CO2RATE      ! CO2 EMISSION RATES, AND CAPACITY
    REAL TOT_QUAN         ! FACTORS
    REAL CUMSUP(WGESITES)
    REAL BOUND(WGESITES)
    REAL BND(WGESITES)

    !DSB********************************************************
    !DSB           START SUBROUTINE BUILD_GEO_CURVES
    !DSB********************************************************

    NUM_SITES = 0

    !CALCULATE COE FOR POTENTIAL CAPACITY
     DO I = 1, WGESITES

           ! LOOP OVER 4 POTENTIAL CAPACITY CATEGORIES
           DO J = 1 , 4
             IF (GEOSITE(I)%POTENTIAL_CAP(J) .GT. 0.0) THEN
           NUM_SITES = NUM_SITES + 1
           GEOCRV(NUM_SITES)%MODEL_YEAR = CURIYR + 1989
           GEOCRV(NUM_SITES)%SITE_ID = GEOSITE(I)%SITE_ID
           GEOCRV(NUM_SITES)%EIA_ID = GEOSITE(I)%EIA_ID
           GEOCRV(NUM_SITES)%NAME = GEOSITE(I)%NAME
           GEOCRV(NUM_SITES)%STATE = GEOSITE(I)%STATE
           GEOCRV(NUM_SITES)%NERC = GEOSITE(I)%NERC
           GEOCRV(NUM_SITES)%CENSUS = GEOSITE(I)%CENSUS
           GEOCRV(NUM_SITES)%TECHTYPE = GEOSITE(I)%TECHTYPE
               GEOCRV(NUM_SITES)%AVAIL_SUPPLY = GEOSITE(I)%POTENTIAL_CAP(J)
               GEOCRV(NUM_SITES)%CAP_COST = GEOSITE(I)%CAP_COST
               GEOCRV(NUM_SITES)%OM_COST  = GEOSITE(I)%OM_COST
               GEOCRV(NUM_SITES)%HEAT_RATE = GEOSITE(I)%HEAT_RATE
               GEOCRV(NUM_SITES)%CAP_FAC   = GEOSITE(I)%CAPACITY_FACTOR
               GEOCRV(NUM_SITES)%CO2_RATE  = GEOSITE(I)%CO2_RATE
           write(IORNDUMP,'(a,4i4,f10.2)') "temp1",wgesites,i,num_sites,j,GEOCRV(NUM_SITES)%CAP_COST
!
               ! CALCULATE COE FOR EACH SITE
!
           NERC = GEOCRV(NUM_SITES)%NERC
               IF ( J .EQ. 1 ) THEN
                 GEOCRV(NUM_SITES)%CAP_COST = GEOSITE(I)%CAP_COST_ADJ(CURIYR) + &
                                          GEOSITE(I)%EXPLOR_CAP_COST_ADJ(CURIYR)
!        write(IORNDUMP,'(a,i4,2f7.2)') "temp2",I,GEOSITE(I)%EXPLOR_CAP_COST_ADJ(CURIYR),GEOSITE(I)%FIELD_CAP_COST_ADJ(CURIYR)
             GEOCRV(NUM_SITES)%COE = (((GEOSITE(I)%DRILL_CAP_COST_ADJ(CURIYR)+ &
                                     GEOSITE(I)%EXPLOR_CAP_COST_ADJ(CURIYR)+ &
                                     GEOSITE(I)%FIELD_CAP_COST_ADJ(CURIYR)+ &
                                 GEOSITE(I)%PLANT_CAP_COST_ADJ(CURIYR))* &
                             FXD_CHRG_FACT(NERC)   * &
                                         LEARN_FACT * OPT_FACT ) + &
                             (GEOSITE(I)%FIELD_OM_COST  + &
                             GEOSITE(I)%PLANT_OM_COST)) / &
                             (GEOSITE(I)%CAPACITY_FACTOR * &
                             8760.0) * 1000.0
               ELSEIF ( J .EQ. 2 ) THEN
                 GEOCRV(NUM_SITES)%CAP_COST = GEOSITE(I)%CAP_COST_ADJ(CURIYR) + &
                                          GEOSITE(I)%EXPLOR_CAP_COST_ADJ(CURIYR) + &
                     (.33 * (GEOSITE(I)%DRILL_CAP_COST_ADJ(CURIYR) + GEOSITE(I)%FIELD_CAP_COST_ADJ(CURIYR)))
             GEOCRV(NUM_SITES)%COE = (((1.33 * (GEOSITE(I)%DRILL_CAP_COST_ADJ(CURIYR) + &
                                     GEOSITE(I)%FIELD_CAP_COST_ADJ(CURIYR)) + &
                                     GEOSITE(I)%EXPLOR_CAP_COST_ADJ(CURIYR) + &
                             GEOSITE(I)%PLANT_CAP_COST_ADJ(CURIYR))* &
                             FXD_CHRG_FACT(NERC)   * &
                                         LEARN_FACT * OPT_FACT ) + &
                             (GEOSITE(I)%FIELD_OM_COST  + &
                             GEOSITE(I)%PLANT_OM_COST)) / &
                             (GEOSITE(I)%CAPACITY_FACTOR * &
                         8760.0) * 1000.0
               ELSEIF ( J .EQ. 3 ) THEN
                 GEOCRV(NUM_SITES)%CAP_COST = GEOSITE(I)%CAP_COST_ADJ(CURIYR) + &
                                          2 * GEOSITE(I)%EXPLOR_CAP_COST_ADJ(CURIYR)
             GEOCRV(NUM_SITES)%COE = (((GEOSITE(I)%DRILL_CAP_COST_ADJ(CURIYR) + &
                                     2 * GEOSITE(I)%EXPLOR_CAP_COST_ADJ(CURIYR) + &
                                     GEOSITE(I)%FIELD_CAP_COST_ADJ(CURIYR) + &
                                 GEOSITE(I)%PLANT_CAP_COST_ADJ(CURIYR))* &
                             FXD_CHRG_FACT(NERC)   * &
                                         LEARN_FACT * OPT_FACT ) + &
                             (GEOSITE(I)%FIELD_OM_COST  + &
                             GEOSITE(I)%PLANT_OM_COST)) / &
                             (GEOSITE(I)%CAPACITY_FACTOR * &
                         8760.0) * 1000.0
               ELSEIF ( J .EQ. 4 ) THEN
                 GEOCRV(NUM_SITES)%CAP_COST = GEOSITE(I)%CAP_COST_ADJ(CURIYR) + &
                                          2 * GEOSITE(I)%EXPLOR_CAP_COST_ADJ(CURIYR) + &
                       (.33 * (GEOSITE(I)%DRILL_CAP_COST_ADJ(CURIYR) + GEOSITE(I)%FIELD_CAP_COST_ADJ(CURIYR)))
             GEOCRV(NUM_SITES)%COE = (((1.33 * (GEOSITE(I)%DRILL_CAP_COST_ADJ(CURIYR) + &
                                     GEOSITE(I)%FIELD_CAP_COST_ADJ(CURIYR)) + &
                                     2 *GEOSITE(I)%EXPLOR_CAP_COST_ADJ(CURIYR) + &
                             GEOSITE(I)%PLANT_CAP_COST_ADJ(CURIYR))* &
                             FXD_CHRG_FACT(NERC)   * &
                                         LEARN_FACT * OPT_FACT ) + &
                             (GEOSITE(I)%FIELD_OM_COST  + &
                             GEOSITE(I)%PLANT_OM_COST)) / &
                             (GEOSITE(I)%CAPACITY_FACTOR * &
                         8760.0) * 1000.0
               ENDIF
             ENDIF
           ENDDO
         ENDDO

    !SORT DATASET BY NERC AND COE
         DO J = 1, (NUM_SITES-1)
           DO I = (J+1), NUM_SITES
             IF ( (DBLE(GEOCRV(J)%NERC) + DBLE(GEOCRV(J)%COE/10000.0)) .GT. &
             (DBLE(GEOCRV(I)%NERC) + DBLE(GEOCRV(I)%COE/10000.0)) ) THEN
               TEMP2 = GEOCRV(J)
               GEOCRV(J) = GEOCRV(I)
               GEOCRV(I) = TEMP2
             ENDIF
       ENDDO
     ENDDO

!   !GET NEW UNPLANNED CAPACITY FOR GEOTHERMAL
!   DO NERC = 1, UNRGNS
!      UNPLAN_GT(NERC) = 0.0
!      DO I = 1, CURIYR + UPPLYR(GEO_ECP_TYPE)
!        UNPLAN_GT(NERC) = UNPLAN_GT(NERC) + UADDGED(NERC,I)
!      ENDDO
!      GEO_ADD(NERC) = UNPLAN_GT(NERC)  !SAVE FOR DEBUG PRINTOUT
!   ENDDO  !LOOP OVER NERC REGIONS
!
!     REMOVE UNPLANNED CAPACITY FROM POTENTIAL CAPACITY
!
      IF (CURIYR .GE. FIRSYR+UPPLYR(GEO_ECP_TYPE)+1) THEN
        DO IYR = (FIRSYR+UPPLYR(GEO_ECP_TYPE)+1), CURIYR+UPPLYR(GEO_ECP_TYPE)
!
!      ENFORCE GEOTHERMAL ANNUAL SITE BOUND WHEN SUBTRACTING CAPACITY
!      using site bound from decision year - 1 because renew runs after emm
!
          DO I = 1, WGESITES
            BOUND(I) = GEOSITE(I)%SITE_BOUND(IYR-UPPLYR(GEO_ECP_TYPE)-1)
          ENDDO

          CUMSUP = 0.0
          BND=BOUND
!
          DO I = 1, NUM_SITES
            ID = GEOCRV(I)%SITE_ID
            CUMSUP(ID) = CUMSUP(ID) + GEOCRV(I)%AVAIL_SUPPLY
            IF ( CUMSUP(ID) .GE. BOUND(ID) ) THEN
              GEOCRV(I)%AVAIL_SUPPLY_BOUND = MIN(GEOCRV(I)%AVAIL_SUPPLY,BND(ID))
              BND(ID) = 0.0
            ELSEIF ( CUMSUP(ID) .LT. BOUND(ID) ) THEN
              GEOCRV(I)%AVAIL_SUPPLY_BOUND = MIN(GEOCRV(I)%AVAIL_SUPPLY,BND(ID))
              BND(ID) = BND(ID) - GEOCRV(I)%AVAIL_SUPPLY_BOUND
            ENDIF
          ENDDO

!
!       REMOVE UNPLANNED CAPACITY FROM POTENTIAL CAPACITY
!
      DO NERC = 1, UNRGNS
            UNPLAN_GT(NERC) = UADDGED(NERC,IYR)
            GEO_ADD(NERC) = UNPLAN_GT(NERC)  !SAVE FOR DEBUG PRINTOUT
!          write(6,*) ' unplanned geoadd ',nerc,unplan_gt(nerc),geo_add(nerc)
      ENDDO
      DO I = 1, NUM_SITES
            NERC = GEOCRV(I)%NERC
            IF (NERC .GE. 1 .AND. NERC .LE. UNRGNS) THEN
              IF (UNPLAN_GT(NERC) .GT. 0.0) THEN
                IF (UNPLAN_GT(NERC) .GT. GEOCRV(I)%AVAIL_SUPPLY_BOUND) THEN
                   UNPLAN_GT(NERC) = UNPLAN_GT(NERC) - GEOCRV(I)%AVAIL_SUPPLY_BOUND
                   GEOCRV(I)%AVAIL_SUPPLY = GEOCRV(I)%AVAIL_SUPPLY - GEOCRV(I)%AVAIL_SUPPLY_BOUND
                ELSE
                   GEOCRV(I)%AVAIL_SUPPLY = GEOCRV(I)%AVAIL_SUPPLY - UNPLAN_GT(NERC)
                   UNPLAN_GT(NERC) = 0.0
                ENDIF
              ENDIF
            ENDIF
          ENDDO
!
        ENDDO
      ENDIF
!
!     Limit available supply from each site to the site build bound for current year
!
      DO I = 1, WGESITES
        BOUND(I) = GEOSITE(I)%SITE_BOUND(CURIYR)
      ENDDO

      CUMSUP = 0.0
      BND = BOUND
!
      DO I = 1, NUM_SITES
        ID = GEOCRV(I)%SITE_ID
        CUMSUP(ID) = CUMSUP(ID) + GEOCRV(I)%AVAIL_SUPPLY
        IF ( CUMSUP(ID) .GE. BOUND(ID) ) THEN
          GEOCRV(I)%AVAIL_SUPPLY_BOUND = MIN(GEOCRV(I)%AVAIL_SUPPLY,BND(ID))
          BND(ID) = 0.0
        ELSEIF ( CUMSUP(ID) .LT. BOUND(ID) ) THEN
          GEOCRV(I)%AVAIL_SUPPLY_BOUND = MIN(GEOCRV(I)%AVAIL_SUPPLY,BND(ID))
          BND(ID) = BND(ID) - GEOCRV(I)%AVAIL_SUPPLY_BOUND
        ENDIF
      ENDDO

    !CALCULATE CUMULATIVE CAPACITY AT EACH STEP
    GEOCRV(1)%CUM_SUPPLY  = &
                           GEOCRV(1)%AVAIL_SUPPLY_BOUND
    CUM_CAP  = GEOCRV(1)%AVAIL_SUPPLY_BOUND
    DO I = 2, NUM_SITES
       IF (GEOCRV(I)%NERC .NE. GEOCRV(I-1)%NERC) THEN
          CUM_CAP = 0.0
       ENDIF
       CUM_CAP = CUM_CAP + &
                  GEOCRV(I)%AVAIL_SUPPLY_BOUND
       GEOCRV(I)%CUM_SUPPLY  = CUM_CAP
    ENDDO


    !TRANSFER CURVE DATA TO TEMP STRUCTURE AND READ DATA FROM TEMP STRUCTURE
    !BACK TO CURVE DATA STRUCTURE IF AVAILABLE CAPACITY IS GREATER THAN ZERO.
    NUM_NZERO_SITES = 0
        DO I = 1, NUM_SITES
          IF   (GEOCRV(I)%CUM_SUPPLY .GT. 0.0) THEN
!             (GEOCRV(I)%AVAIL_SUPPLY_BOUND .GT. 0.0) ) THEN
            NUM_NZERO_SITES = NUM_NZERO_SITES + 1
            TMPCRV(NUM_NZERO_SITES) = GEOCRV(I)
          ENDIF
    ENDDO
        DO I = 1, NUM_NZERO_SITES
          GEOCRV(I) = TMPCRV(I)
    ENDDO
!     WRITE(6,*)'NUM_NZERO_SITES',NUM_NZERO_SITES
    !****************************************************
     IF (NUM_NZERO_SITES .GT. 0) THEN
    !****************************************************

    !SET ALL CRV_INFO DATA TO ZERO. IF DATA NOT CHANGED BY
    !SUBSEQUENT BLOCKS OF CODE, THEN THE REGION HAS NO AVAILABLE
    !CAPACITY

    DO NERC = 1, MNUMNR -3
          CRV_INFO(NERC)%MIN_COE = 0.0
          CRV_INFO(NERC)%MAX_COE = 0.0
          DO I = 1, 3
            CRV_INFO(NERC)%SEGMENTS(I)      = 0.0
            CRV_INFO(NERC)%STEP_PRICE(I)    = 0.0
            CRV_INFO(NERC)%STEP_QUAN(I)     = 0.0
        CRV_INFO(NERC)%STEP_CAP_COST(I) = 0.0
        CRV_INFO(NERC)%STEP_OM_COST(I)  = 0.0
        CRV_INFO(NERC)%STEP_HEAT_RATE(I)  = 0.0
        CRV_INFO(NERC)%STEP_CAP_FAC(I)  = 0.0
        CRV_INFO(NERC)%STEP_CO2_RATE(I)  = 0.0
          ENDDO
    ENDDO


    !FIND MAXIMUM COE FOR EACH REGION THAT IS CLOSEST TO THE EMM SIGNAL
    ! PRICE PASSED BY THE ECP SUPPLY CURVE WILL CONSIST OF THOSE SITES
    ! AT OR BELOW THIS SIGNAL PRICE
    MAX_FOUND = .FALSE.
    NERC = GEOCRV(1)%NERC
    CRV_INFO(NERC)%MIN_COE = GEOCRV(1)%COE
     DO I = 2, NUM_NZERO_SITES
      IF (GEOCRV(I)%COE .GT. EMM_SIGNAL(NERC)) THEN
        IF (.NOT. MAX_FOUND) THEN
           CRV_INFO(NERC)%MAX_COE = GEOCRV((I-1))%COE
           MAX_FOUND = .TRUE.
            ENDIF
      ENDIF
      IF (GEOCRV(I)%NERC .NE. GEOCRV((I-1))%NERC) THEN
        IF (.NOT. MAX_FOUND) THEN
               CRV_INFO(NERC)%MAX_COE = GEOCRV((I-1))%COE
        ENDIF
            NERC = GEOCRV(I)%NERC
            CRV_INFO(NERC)%MIN_COE = GEOCRV(I)%COE
            MAX_FOUND = .FALSE.
      ENDIF
      IF (I .EQ. NUM_NZERO_SITES) THEN
        IF (.NOT. MAX_FOUND) THEN
           CRV_INFO(NERC)%MAX_COE = GEOCRV(I)%COE
        ENDIF
      ENDIF
     ENDDO

    !CALCULATE THE SEGMENT VALUES THAT LIE BETWEEN THE MAX AND MIN COE
    DO I = 1, (unrgns)
      DO J = 1, 3
             CRV_INFO(I)%SEGMENTS(J) = CRV_INFO(I)%MIN_COE + &
                (CRV_INFO(I)%MAX_COE - CRV_INFO(I)%MIN_COE) * WGEPRICE_SEG(J)
!             WRITE(IORNDUMP,3924)'CRV_INFO SEG ',I,J,CRV_INFO(I)%SEGMENTS(J) , CRV_INFO(I)%MIN_COE, &
!                CRV_INFO(I)%MAX_COE , WGEPRICE_SEG(J)
3924  FORMAT(A25,1x,2(I4,2x),6(F12.3,1x))                
      ENDDO
    ENDDO

    !*******************************************************
    !BEGIN -- CALCULATE CUMULATIVE SYSTEM COSTS
    !*******************************************************

    !CALCULATE CUMULATIVE SYSTEM COSTS BY MULTIPLYING THE SITE COE BY THE SITE CAPACITY.
    !THESE COSTS WILL BE USED TO CALCULATE THE WEIGHTED AVERAGE COE FOR ALL SITES IN
    !EACH OF THE THREE PRICE SEGMENTS
    DO J = 1, NUM_NZERO_SITES                  !LOOP THROUGH SITES
      NERC = GEOCRV(J)%NERC
      SITE_COE = GEOCRV(J)%COE
      STEP_QUAN = GEOCRV(J)%AVAIL_SUPPLY_BOUND
      SITE_CAP_COST = GEOCRV(J)%CAP_COST
      SITE_OM_COST = GEOCRV(J)%OM_COST
      SITE_HEAT_RATE = GEOCRV(J)%HEAT_RATE
      SITE_CAP_FAC = GEOCRV(J)%CAP_FAC
      SITE_CO2_RATE  = GEOCRV(J)%CO2_RATE
!      Write(IORNDUMP,2045)'CHECK SYS_COSTS ',J,NERC,SITE_COE,STEP_QUAN,SITE_CAP_COST,SITE_OM_COST, &
!      EMM_SIGNAL(NERC), CRV_INFO(NERC)%SEGMENTS(1),CRV_INFO(NERC)%SEGMENTS(2),CRV_INFO(NERC)%SEGMENTS(3)
 2045  FORMAT( A30,1x,2(I4,1x),10(F12.3,1x))
      IF (J .EQ. 1) THEN !PROCESS FIRST SITE
       DO K = 1, 3                                !LOOP OVER STEPS
         IF ((EMM_SIGNAL(NERC) .LT. CRV_INFO(NERC)%SEGMENTS(K)) .OR. &
             (CRV_INFO(NERC)%SEGMENTS(K) .LT. SITE_COE)) THEN
             !SITE COE BELOW SIGNAL PRICE
             GEOCRV(J)%SYS_COST(K) = 0.0
             GEOCRV(J)%SYS_CAP_COST(K) = 0.0
             GEOCRV(J)%SYS_OM_COST(K) = 0.0
             GEOCRV(J)%SYS_HEAT_RATE(K) = 0.0
             GEOCRV(J)%SYS_CAP_FAC(K) = 0.0
             GEOCRV(J)%SYS_CO2_RATE(K) = 0.0
         ELSEIF (K .EQ. 1) THEN
             !PROCESS FIRST STEP
             GEOCRV(J)%SYS_COST(1) = SITE_COE * STEP_QUAN
             GEOCRV(J)%SYS_CAP_COST(1) = SITE_CAP_COST * STEP_QUAN
             GEOCRV(J)%SYS_OM_COST(1) = SITE_OM_COST * STEP_QUAN
             GEOCRV(J)%SYS_HEAT_RATE(1) = SITE_HEAT_RATE * STEP_QUAN
             GEOCRV(J)%SYS_CAP_FAC(1) = SITE_CAP_FAC * STEP_QUAN
             GEOCRV(J)%SYS_CO2_RATE(1) = SITE_CO2_RATE * STEP_QUAN
         ELSEIF (K .EQ. 2) THEN
             !PROCESS SECOND STEP
             IF (GEOCRV(J)%SYS_COST(1) .GT. 0.0) THEN
                 GEOCRV(J)%SYS_COST(2)  = 0.0
                 GEOCRV(J)%SYS_CAP_COST(2)  = 0.0
                 GEOCRV(J)%SYS_OM_COST(2)   = 0.0
                 GEOCRV(J)%SYS_HEAT_RATE(2) = 0.0
                 GEOCRV(J)%SYS_CAP_FAC(2) = 0.0
                 GEOCRV(J)%SYS_CO2_RATE(2) = 0.0
             ELSE
                 GEOCRV(J)%SYS_COST(2) = SITE_COE * STEP_QUAN
                 GEOCRV(J)%SYS_CAP_COST(2) = SITE_CAP_COST * STEP_QUAN
                             GEOCRV(J)%SYS_OM_COST(2) = SITE_OM_COST * STEP_QUAN
                 GEOCRV(J)%SYS_HEAT_RATE(2) = SITE_HEAT_RATE * STEP_QUAN
                 GEOCRV(J)%SYS_CAP_FAC(2) = SITE_CAP_FAC * STEP_QUAN
                 GEOCRV(J)%SYS_CO2_RATE(2) = SITE_CO2_RATE * STEP_QUAN
             ENDIF
         ELSEIF (K .EQ. 3) THEN
             !PROCESS THIRD STEP
             IF ( (GEOCRV(J)%SYS_COST(1) .GT. 0.0) .AND. &
                  (GEOCRV(J)%SYS_COST(2) .GT. 0.0) )THEN
                 GEOCRV(J)%SYS_COST(3) = SITE_COE * STEP_QUAN
                 GEOCRV(J)%SYS_CAP_COST(3) = SITE_CAP_COST * STEP_QUAN
                             GEOCRV(J)%SYS_OM_COST(3) = SITE_OM_COST * STEP_QUAN
                             GEOCRV(J)%SYS_HEAT_RATE(3) = SITE_HEAT_RATE * STEP_QUAN
                 GEOCRV(J)%SYS_CAP_FAC(3) = SITE_CAP_FAC * STEP_QUAN
                 GEOCRV(J)%SYS_CO2_RATE(3) = SITE_CO2_RATE * STEP_QUAN
             ELSE
                 GEOCRV(J)%SYS_COST(3) = 0.0
                 GEOCRV(J)%SYS_CAP_COST(3) = 0.0
                 GEOCRV(J)%SYS_OM_COST(3) = 0.0
                 GEOCRV(J)%SYS_HEAT_RATE(3) = 0.0
                 GEOCRV(J)%SYS_CAP_FAC(3) = 0.0
                 GEOCRV(J)%SYS_CO2_RATE(3) = 0.0
             ENDIF
         ENDIF
       ENDDO                                      !LOOP OVER STEPS
      ELSEIF (NERC .NE. GEOCRV(J-1)%NERC) THEN
      !REGION CHANGE
       DO K = 1, 3                                !LOOP OVER STEPS
         IF ((EMM_SIGNAL(NERC) .LT. CRV_INFO(NERC)%SEGMENTS(K)) .OR. &
             (CRV_INFO(NERC)%SEGMENTS(K) .LT. SITE_COE)) THEN
             !SITE COE BELOW SIGNAL PRICE
             GEOCRV(J)%SYS_COST(K) = 0.0
             GEOCRV(J)%SYS_CAP_COST(K) = 0.0
             GEOCRV(J)%SYS_OM_COST(K) = 0.0
             GEOCRV(J)%SYS_HEAT_RATE(K) = 0.0
             GEOCRV(J)%SYS_CAP_FAC(K) = 0.0
             GEOCRV(J)%SYS_CO2_RATE(K) = 0.0
         ELSEIF (K .EQ. 1) THEN
             !PROCESS FIRST STEP
                 GEOCRV(J)%SYS_COST(1) = SITE_COE * STEP_QUAN
                 GEOCRV(J)%SYS_CAP_COST(1) = SITE_CAP_COST * STEP_QUAN
                             GEOCRV(J)%SYS_OM_COST(1) = SITE_OM_COST * STEP_QUAN
                             GEOCRV(J)%SYS_HEAT_RATE(1) = SITE_HEAT_RATE * STEP_QUAN
                 GEOCRV(J)%SYS_CAP_FAC(1) = SITE_CAP_FAC * STEP_QUAN
                 GEOCRV(J)%SYS_CO2_RATE(1) = SITE_CO2_RATE * STEP_QUAN
         ELSEIF (K .EQ. 2) THEN
             !PROCESS SECOND STEP
             IF (GEOCRV(J)%SYS_COST(1) .GT. 0.0) THEN
                 GEOCRV(J)%SYS_COST(2)  = 0.0
                 GEOCRV(J)%SYS_CAP_COST(2) = 0.0
                 GEOCRV(J)%SYS_OM_COST(2) = 0.0
                 GEOCRV(J)%SYS_HEAT_RATE(2) = 0.0
                 GEOCRV(J)%SYS_CAP_FAC(2) = 0.0
                 GEOCRV(J)%SYS_CO2_RATE(2) = 0.0
             ELSE
                 GEOCRV(J)%SYS_COST(2) = SITE_COE * STEP_QUAN
                 GEOCRV(J)%SYS_CAP_COST(2) = SITE_CAP_COST * STEP_QUAN
                             GEOCRV(J)%SYS_OM_COST(2) = SITE_OM_COST * STEP_QUAN
                             GEOCRV(J)%SYS_HEAT_RATE(2) = SITE_HEAT_RATE * STEP_QUAN
                 GEOCRV(J)%SYS_CAP_FAC(2) = SITE_CAP_FAC * STEP_QUAN
                 GEOCRV(J)%SYS_CO2_RATE(2) = SITE_CO2_RATE * STEP_QUAN
             ENDIF
         ELSEIF (K .EQ. 3) THEN
             !PROCESS THIRD STEP
             IF ( (GEOCRV(J)%SYS_COST(1) .GT. 0.0) .AND. &
                  (GEOCRV(J)%SYS_COST(2) .GT. 0.0) )THEN
                 GEOCRV(J)%SYS_COST(3) = SITE_COE * STEP_QUAN
                 GEOCRV(J)%SYS_CAP_COST(3) = SITE_CAP_COST * STEP_QUAN
                             GEOCRV(J)%SYS_OM_COST(3) = SITE_OM_COST * STEP_QUAN
                             GEOCRV(J)%SYS_HEAT_RATE(3) = SITE_HEAT_RATE * STEP_QUAN
                 GEOCRV(J)%SYS_CAP_FAC(3) = SITE_CAP_FAC * STEP_QUAN
                 GEOCRV(J)%SYS_CO2_RATE(3) = SITE_CO2_RATE * STEP_QUAN
             ELSE
                 GEOCRV(J)%SYS_COST(3)  = 0.0
                 GEOCRV(J)%SYS_CAP_COST(3) = 0.0
                 GEOCRV(J)%SYS_OM_COST(3) = 0.0
                 GEOCRV(J)%SYS_HEAT_RATE(3) = 0.0
                 GEOCRV(J)%SYS_CAP_FAC(3) = 0.0
                 GEOCRV(J)%SYS_CO2_RATE(3) = 0.0
             ENDIF
         ENDIF
       ENDDO                                      !LOOP OVER STEPS
      ELSE                      ! If not first site or region change
       DO K = 1, 3                                !LOOP OVER STEPS
         IF ((EMM_SIGNAL(NERC) .LT. CRV_INFO(NERC)%SEGMENTS(K)) .OR. &
             (CRV_INFO(NERC)%SEGMENTS(K) .LT. SITE_COE)) THEN
             !SITE COE BELOW SIGNAL PRICE
             GEOCRV(J)%SYS_COST(K) = 0.0
             GEOCRV(J)%SYS_CAP_COST(K) = 0.0
             GEOCRV(J)%SYS_OM_COST(K) = 0.0
             GEOCRV(J)%SYS_HEAT_RATE(K) = 0.0
             GEOCRV(J)%SYS_CAP_FAC(K) = 0.0
             GEOCRV(J)%SYS_CO2_RATE(K) = 0.0
         ELSEIF (K .EQ. 1) THEN
             !PROCESS FIRST STEP
             GEOCRV(J)%SYS_COST(1) = SITE_COE * STEP_QUAN + &
                                  GEOCRV(J-1)%SYS_COST(1)
             GEOCRV(J)%SYS_CAP_COST(1) = SITE_CAP_COST * STEP_QUAN + &
                                  GEOCRV(J-1)%SYS_CAP_COST(1)
             GEOCRV(J)%SYS_OM_COST(1) = SITE_OM_COST * STEP_QUAN + &
                                  GEOCRV(J-1)%SYS_OM_COST(1)
             GEOCRV(J)%SYS_HEAT_RATE(1) = SITE_HEAT_RATE * STEP_QUAN + &
                                  GEOCRV(J-1)%SYS_HEAT_RATE(1)
             GEOCRV(J)%SYS_CAP_FAC(1) = SITE_CAP_FAC * STEP_QUAN + &
                                  GEOCRV(J-1)%SYS_CAP_FAC(1)
             GEOCRV(J)%SYS_CO2_RATE(1) = SITE_CO2_RATE  * STEP_QUAN + &
                                  GEOCRV(J-1)%SYS_CO2_RATE(1)
         ELSEIF (K .EQ. 2) THEN
             !PROCESS SECOND STEP
             IF (GEOCRV(J)%SYS_COST(1) .GT. 0.0) THEN
                 GEOCRV(J)%SYS_COST(2)  = 0.0
                             GEOCRV(J)%SYS_CAP_COST(2)  = 0.0
                             GEOCRV(J)%SYS_OM_COST(2)   = 0.0
                 GEOCRV(J)%SYS_HEAT_RATE(2) = 0.0
                 GEOCRV(J)%SYS_CAP_FAC(2) = 0.0
                 GEOCRV(J)%SYS_CO2_RATE(2) = 0.0
             ELSE
                 GEOCRV(J)%SYS_COST(2) = SITE_COE * STEP_QUAN &
                                     + GEOCRV(J-1)%SYS_COST(2)
                 GEOCRV(J)%SYS_CAP_COST(2) = SITE_CAP_COST * STEP_QUAN &
                                     + GEOCRV(J-1)%SYS_CAP_COST(2)
                 GEOCRV(J)%SYS_OM_COST(2) = SITE_OM_COST * STEP_QUAN &
                                     + GEOCRV(J-1)%SYS_OM_COST(2)
                 GEOCRV(J)%SYS_HEAT_RATE(2) = SITE_HEAT_RATE * STEP_QUAN + &
                                           GEOCRV(J-1)%SYS_HEAT_RATE(2)
                 GEOCRV(J)%SYS_CAP_FAC(2) = SITE_CAP_FAC * STEP_QUAN + &
                                           GEOCRV(J-1)%SYS_CAP_FAC(2)
                 GEOCRV(J)%SYS_CO2_RATE(2) = SITE_CO2_RATE  * STEP_QUAN + &
                                           GEOCRV(J-1)%SYS_CO2_RATE(2)
             ENDIF
         ELSEIF (K .EQ. 3) THEN
             !PROCESS THIRD STEP
             IF ( (GEOCRV(J)%SYS_COST(1) .EQ. 0.0) .AND. &
                  (GEOCRV(J)%SYS_COST(2) .EQ. 0.0) )THEN
                 GEOCRV(J)%SYS_COST(3)  = SITE_COE * STEP_QUAN &
                                     + GEOCRV(J-1)%SYS_COST(3)
                 GEOCRV(J)%SYS_CAP_COST(3)  = SITE_CAP_COST * STEP_QUAN &
                                     + GEOCRV(J-1)%SYS_CAP_COST(3)
                 GEOCRV(J)%SYS_OM_COST(3)   = SITE_OM_COST * STEP_QUAN &
                                     + GEOCRV(J-1)%SYS_OM_COST(3)
                 GEOCRV(J)%SYS_HEAT_RATE(3) = SITE_HEAT_RATE * STEP_QUAN + &
                                           GEOCRV(J-1)%SYS_HEAT_RATE(3)
                 GEOCRV(J)%SYS_CAP_FAC(3) = SITE_CAP_FAC * STEP_QUAN + &
                                           GEOCRV(J-1)%SYS_CAP_FAC(3)
                 GEOCRV(J)%SYS_CO2_RATE(3) = SITE_CO2_RATE  * STEP_QUAN + &
                                           GEOCRV(J-1)%SYS_CO2_RATE(3)
             ELSE
                 GEOCRV(J)%SYS_COST(3) = 0.0
                 GEOCRV(J)%SYS_CAP_COST(3) = 0.0
                     GEOCRV(J)%SYS_OM_COST(3) = 0.0
                 GEOCRV(J)%SYS_HEAT_RATE(3) = 0.0
                 GEOCRV(J)%SYS_CAP_FAC(3) = 0.0
                 GEOCRV(J)%SYS_CO2_RATE(3) = 0.0
             ENDIF
         ENDIF
       ENDDO                                      !LOOP OVER STEPS
      ENDIF
      IF  ( (PASSES .EQ. MAXPASSES) .AND. (SITE_COE .EQ. CRV_INFO(NERC)%MIN_COE) &
          .AND. (GEOCRV(J)%SYS_COST(1) .EQ. 0) ) THEN
        GEOCRV(J)%SYS_COST(1) = SITE_COE * STEP_QUAN
        GEOCRV(J)%SYS_CAP_COST(1) = SITE_CAP_COST * STEP_QUAN
        GEOCRV(J)%SYS_OM_COST(1) = SITE_OM_COST * STEP_QUAN
        GEOCRV(J)%SYS_HEAT_RATE(1) = SITE_HEAT_RATE * STEP_QUAN
        GEOCRV(J)%SYS_CAP_FAC(1) = SITE_CAP_FAC * STEP_QUAN
        GEOCRV(J)%SYS_CO2_RATE(1) = SITE_CO2_RATE * STEP_QUAN
      ENDIF
     ENDDO                                       !LOOP THROUGH SITES

    !*******************************************************
    !END -- CALCULATE CUMULATIVE SYSTEM COSTS
    !*******************************************************


    !*******************************************************
    !BEGIN -- CALCULATE WEIGHTED PRICE AND QUANTITY
    !*******************************************************

    !USING THE CUMULATIVE SYSTEM COST CALCULATED ABOVE,
    !CALCULATE THE PRICE AND QUANTITY FOR EACH STEP
    DO K = 1, 3                       !LOOP OVER STEPS
     TOTAL_QUAN = 0.0
     TOTAL_PRICE = 0.0
     TOTAL_CAP = 0.0
     TOTAL_OM = 0.0
     TOTAL_HRATE = 0.0
     TOTAL_CAPFAC = 0.0
     TOTAL_CO2RATE = 0.0
     MIN_CAP_FOUND = .FALSE.
     DO J = 1, NUM_NZERO_SITES        !LOOP OVER SITES
        NERC = GEOCRV(J)%NERC
        IF  (J .GT. 1) THEN
         IF (NUM_NZERO_SITES .GT. 1) THEN
          IF ((NERC .NE. GEOCRV(J+1)%NERC) .OR. (J .EQ. NUM_NZERO_SITES)) THEN
!
!   This if added for cases where the last site in a region is included in the supply curve.
!     or if last site in sort is included in the supply curve
!
          IF (GEOCRV(J)%SYS_COST(K) .GT. 0.0) THEN
            TOTAL_PRICE = GEOCRV(J)%SYS_COST(K)
            TOTAL_CAP = GEOCRV(J)%SYS_CAP_COST(K)
            TOTAL_OM = GEOCRV(J)%SYS_OM_COST(K)
            TOTAL_HRATE = GEOCRV(J)%SYS_HEAT_RATE(K)
            TOTAL_CAPFAC = GEOCRV(J)%SYS_CAP_FAC(K)
            TOTAL_CO2RATE = GEOCRV(J)%SYS_CO2_RATE(K)
            IF ((GEOCRV(J)%SYS_COST(K) .GT. 0.0) .AND. (.NOT. MIN_CAP_FOUND)) THEN
                MIN_CAP_FOUND = .TRUE.
            ENDIF
            IF (MIN_CAP_FOUND ) THEN
               TOTAL_QUAN = TOTAL_QUAN + GEOCRV(J)%AVAIL_SUPPLY_BOUND
            ENDIF
          ENDIF

           IF (TOTAL_QUAN .GT. 0.0) THEN
              CRV_INFO(NERC)%STEP_PRICE(K) = &
                     TOTAL_PRICE/TOTAL_QUAN
              CRV_INFO(NERC)%STEP_CAP_COST(K) = &
                     TOTAL_CAP/TOTAL_QUAN
              CRV_INFO(NERC)%STEP_OM_COST(K) = &
                     TOTAL_OM/TOTAL_QUAN
              CRV_INFO(NERC)%STEP_HEAT_RATE(K) = &
                     TOTAL_HRATE/TOTAL_QUAN
              CRV_INFO(NERC)%STEP_CAP_FAC(K) = &
                     TOTAL_CAPFAC/TOTAL_QUAN
              CRV_INFO(NERC)%STEP_CO2_RATE(K) = &
                     TOTAL_CO2RATE/TOTAL_QUAN
           ELSE
              CRV_INFO(NERC)%STEP_PRICE(K) = &
                     TOTAL_PRICE
              CRV_INFO(NERC)%STEP_CAP_COST(K) = &
                     TOTAL_CAP
              CRV_INFO(NERC)%STEP_OM_COST(K) = &
                     TOTAL_OM
              CRV_INFO(NERC)%STEP_HEAT_RATE(K) = &
                     TOTAL_HRATE
                      CRV_INFO(NERC)%STEP_CAP_FAC(K) = &
                     TOTAL_CAPFAC
                      CRV_INFO(NERC)%STEP_CO2_RATE(K) = &
                     TOTAL_CO2RATE
           ENDIF  !(TOTAL_QUAN > 0)
           CRV_INFO(NERC)%STEP_QUAN(K) = TOTAL_QUAN
           MIN_CAP_FOUND = .FALSE.
           TOTAL_QUAN = 0.0
           TOTAL_PRICE = 0.0
           TOTAL_CAP = 0.0
           TOTAL_OM = 0.0
           TOTAL_HRATE = 0.0
               TOTAL_CAPFAC = 0.0
               TOTAL_CO2RATE = 0.0
          ENDIF  ! (NERC .NE. GEOCRV(J+1)%NERC)
         ENDIF   !(NUM_NZERO_SITE > 1)
        ENDIF   !(J > 1)

        IF ((GEOCRV(J)%SYS_COST(K) .GT. 0.0) .AND. (.NOT. MIN_CAP_FOUND)) THEN
! this if added for last site in regions included in supply curve. if step quan gt 0 then last site in region
! already processed.
         IF (CRV_INFO(NERC)%STEP_QUAN(K) .EQ. 0.0 ) THEN
            MIN_CAP_FOUND = .TRUE.
        ENDIF
        ENDIF
        IF ((MIN_CAP_FOUND ) .AND. (GEOCRV(J)%SYS_COST(K) .NE. 0.0)) THEN
            TOTAL_QUAN = TOTAL_QUAN + GEOCRV(J)%AVAIL_SUPPLY_BOUND
        ENDIF
        IF ( (GEOCRV(J)%SYS_COST(K) .GT. 0.0) .AND. (MIN_CAP_FOUND) ) THEN
          IF (GEOCRV(J+1)%SYS_COST(K) .EQ. 0.0) THEN
            TOTAL_PRICE = GEOCRV(J)%SYS_COST(K)
            TOTAL_CAP = GEOCRV(J)%SYS_CAP_COST(K)
            TOTAL_OM = GEOCRV(J)%SYS_OM_COST(K)
            TOTAL_HRATE = GEOCRV(J)%SYS_HEAT_RATE(K)
            TOTAL_CAPFAC = GEOCRV(J)%SYS_CAP_FAC(K)
            TOTAL_CO2RATE = GEOCRV(J)%SYS_CO2_RATE(K)
          ENDIF
        ENDIF
     ENDDO                            !LOOP OVER SITES

    ENDDO                             !LOOP OVER STEPS
    !*******************************************************
    !END -- CALCULATE WEIGHTED PRICE AND QUANTITY
    !*******************************************************

    !*******************************************************
     ENDIF
    !END -- NUM_NZERO_SITES > 0
    !*******************************************************

    !*******************************************************
    !  CALCULATE WEIGHTED AVERAGE HEAT RATE OVER ALL STEPS IN REGION
       DO NERC = 1, unrgns  !LOOP OVER NERC
         TOT_QUAN = 0.0
         TOT_HRATE = 0.0
         TOT_CAPFAC = 0.0
         TOT_CO2RATE = 0.0
         DO J = 1 , 3
          TOT_QUAN = TOT_QUAN + CRV_INFO(NERC)%STEP_QUAN(J)
          TOT_HRATE = TOT_HRATE + (CRV_INFO(NERC)%STEP_QUAN(J) * CRV_INFO(NERC)%STEP_HEAT_RATE(J))
          TOT_CAPFAC = TOT_CAPFAC + (CRV_INFO(NERC)%STEP_QUAN(J) * CRV_INFO(NERC)%STEP_CAP_FAC(J))
          TOT_CO2RATE = TOT_CO2RATE + (CRV_INFO(NERC)%STEP_QUAN(J) * CRV_INFO(NERC)%STEP_CO2_RATE(J))
         ENDDO
         IF (TOT_QUAN .NE. 0.0) THEN
           REG_HEAT_RATE(NERC) = TOT_HRATE / TOT_QUAN
           REG_CAP_FAC(NERC) = TOT_CAPFAC / TOT_QUAN
           REG_CO2_RATE(NERC) = TOT_CO2RATE / TOT_QUAN
         ELSE
           REG_HEAT_RATE(NERC) = 14000.0
           REG_CAP_FAC(NERC) = .85
           REG_CO2_RATE(NERC) = 20.0
         ENDIF
       ENDDO

    !EMM REQUIRES THE ACTUAL VALUES FOR THE AVAILABLE CAPACITY, CAPITAL COST,
    !AND O&M COST FOR THE FIRST STEP OF THE REGIONAL CURVES AND ONLY MULTIPLIERS
    !TO BE APPLIED TO THE FIRST STEP FOR THE SECOND AND THIRD STEPS

     DO NERC = 1, unrgns  !LOOP OVER NERC
      !CALCULATE CAPITAL COST
      DO J = 1, 3  !LOOP OVER STEPS
        IF (J .EQ. 1) THEN
           IF (CRV_INFO(NERC)% STEP_CAP_COST(J) .EQ. 0.0) THEN
            GEO_CURVE(NERC)%EMM_CAP_COST(J) = 9999.0
               ELSE
            GEO_CURVE(NERC)%EMM_CAP_COST(J) = &
                CRV_INFO(NERC)% STEP_CAP_COST(J)
           ENDIF
            ELSE   !STEPS 2 AND 3
           IF ( (CRV_INFO(NERC)% STEP_CAP_COST(J) .EQ. 0.0) .OR.   &
                      (GEO_CURVE(NERC)%EMM_CAP_COST(1) .EQ. 9999.0) ) THEN
            GEO_CURVE(NERC)%EMM_CAP_COST(J) = 9999.0
               ELSE
                    GEO_CURVE(NERC)%EMM_CAP_COST(J) = &
                    CRV_INFO(NERC)% STEP_CAP_COST(J) / &
                    CRV_INFO(NERC)% STEP_CAP_COST(1)
               ENDIF
            ENDIF
          ENDDO        !LOOP OVER STEPS

      !CALCULATE O&M COST
      DO J = 1, 3  !LOOP OVER STEPS
        IF (J .EQ. 1) THEN
           IF (CRV_INFO(NERC)% STEP_OM_COST(J) .EQ. 0.0) THEN
            GEO_CURVE(NERC)%EMM_OM_COST(J) = 999.0
           ELSE
            GEO_CURVE(NERC)%EMM_OM_COST(J) = &
                CRV_INFO(NERC)% STEP_OM_COST(J)
           ENDIF
            ELSE   !STEPS 2 AND 3
           IF (CRV_INFO(NERC)% STEP_OM_COST(J) .EQ. 0.0) THEN
            GEO_CURVE(NERC)%EMM_OM_COST(J) = 999.0
               ELSE
                   GEO_CURVE(NERC)%EMM_OM_COST(J) = &
                   CRV_INFO(NERC)% STEP_OM_COST(J) / &
                   CRV_INFO(NERC)% STEP_OM_COST(1)
               ENDIF
            ENDIF
          ENDDO        !LOOP OVER STEPS

      !CALCULATE HEAT RATE
      DO J = 1, 3  !LOOP OVER STEPS
        IF (J .EQ. 1) THEN
           IF (CRV_INFO(NERC)% STEP_HEAT_RATE(J) .EQ. 0.0) THEN
            GEO_CURVE(NERC)%EMM_HEAT_RATE(J) = 9999.0
           ELSE
            GEO_CURVE(NERC)%EMM_HEAT_RATE(J) = &
                CRV_INFO(NERC)% STEP_HEAT_RATE(J)
           ENDIF
            ELSE   !STEPS 2 AND 3
           IF (CRV_INFO(NERC)% STEP_HEAT_RATE(J) .EQ. 0.0) THEN
            GEO_CURVE(NERC)%EMM_HEAT_RATE(J) = 9999.0
               ELSE
                    GEO_CURVE(NERC)%EMM_HEAT_RATE(J) = &
                     CRV_INFO(NERC)% STEP_HEAT_RATE(J) / &
                     CRV_INFO(NERC)% STEP_HEAT_RATE(1)
               ENDIF
            ENDIF
          ENDDO        !LOOP OVER STEPS

      !CALCULATE CAPACITY FACTORS
      DO J = 1, 3  !LOOP OVER STEPS
        IF (J .EQ. 1) THEN
           IF (CRV_INFO(NERC)% STEP_CAP_FAC(J) .EQ. 0.0) THEN
            GEO_CURVE(NERC)%EMM_CAP_FAC(J) = 0.001
           ELSE
            GEO_CURVE(NERC)%EMM_CAP_FAC(J) = &
                CRV_INFO(NERC)% STEP_CAP_FAC(J)
           ENDIF
            ELSE   !STEPS 2 AND 3
           IF (CRV_INFO(NERC)% STEP_CAP_FAC(J) .EQ. 0.0) THEN
            GEO_CURVE(NERC)%EMM_CAP_FAC(J) = 0.001
               ELSE
                    GEO_CURVE(NERC)%EMM_CAP_FAC(J) = &
                     CRV_INFO(NERC)% STEP_CAP_FAC(J) / &
                     CRV_INFO(NERC)% STEP_CAP_FAC(1)
               ENDIF
            ENDIF
          ENDDO        !LOOP OVER STEPS

      !CALCULATE CO2 EMISSION RATES
      DO J = 1, 3  !LOOP OVER STEPS
        IF (J .EQ. 1) THEN
           IF (CRV_INFO(NERC)% STEP_CO2_RATE(J) .EQ. 0.0) THEN
            GEO_CURVE(NERC)%EMM_CO2_RATE(J) = 99.99
           ELSE
            GEO_CURVE(NERC)%EMM_CO2_RATE(J) = &
                CRV_INFO(NERC)% STEP_CO2_RATE(J)
           ENDIF
            ELSE   !STEPS 2 AND 3
           IF (CRV_INFO(NERC)% STEP_CO2_RATE(J) .EQ. 0.0) THEN
            GEO_CURVE(NERC)%EMM_CO2_RATE(J) = 99.99
               ELSE
                    GEO_CURVE(NERC)%EMM_CO2_RATE(J) = &
                     CRV_INFO(NERC)% STEP_CO2_RATE(J) / &
                     CRV_INFO(NERC)% STEP_CO2_RATE(1)
               ENDIF
            ENDIF
          ENDDO        !LOOP OVER STEPS

      !TRANSFER CAPACITY AT EACH STEP
          DO J = 1, 3  !LOOP OVER STEPS
        GEO_CURVE(NERC)%EMM_CAPACITY(J) = &
                           CRV_INFO(NERC)%STEP_QUAN(J)
      ENDDO !LOOP OVER STEPS

     ENDDO  !LOOP OVER NERC

    !*******************************************************
    !END - CALCULATE FINAL OUTPUTS
    !*******************************************************


     END SUBROUTINE BUILD_GEO_CURVES

    !DSB********************************************************
    !DSB           END SUBROUTINE BUILD_GEO_CURVES
    !DSB********************************************************


!DSB*************************************************************
!DSB*************************************************************
                                                               !*
      SUBROUTINE WRITE_DB
     IMPLICIT NONE
     include 'control'
!*
!DSB*************************************************************
!DSB*************************************************************
                                                               !*

    !DSB*******************************
    !DSB WRITE_DB DECLARATIONS
    !DSB*******************************

      INTEGER NERC, I, J     !COUNTING VARIABLES

    !DSB********************************************************
    !DSB           START -- SUBROUTINE WRITE_DB
    !DSB********************************************************

     IF (CURCALYR .EQ. UESTYR) THEN
       DO I = 1, WGESITES
         WRITE(IORNDUMP,920) GEOSITE(I)%SITE_ID, &
        GEOSITE(I)%EIA_ID, &
        GEOSITE(I)%NAME, &
        GEOSITE(I)%STATE, &
        GEOSITE(I)%NERC, &
        GEOSITE(I)%CENSUS, &
        GEOSITE(I)%TECHTYPE, &
        GEOSITE(I)%CAPACITY_1990, &
        GEOSITE(I)%POTENTIAL_CAP(1), &
        GEOSITE(I)%POTENTIAL_CAP(2), &
        GEOSITE(I)%POTENTIAL_CAP(3), &
        GEOSITE(I)%POTENTIAL_CAP(4), &
        GEOSITE(I)%CAPACITY_FACTOR, &
        GEOSITE(I)%CO2_RATE, &
        GEOSITE(I)%H2S_RATE, &
        GEOSITE(I)%EXPLOR_CAP_COST, &
        GEOSITE(I)%DRILL_CAP_COST, &
        GEOSITE(I)%FIELD_CAP_COST, &
        GEOSITE(I)%PLANT_CAP_COST, &
        GEOSITE(I)%FIELD_OM_COST, &
        GEOSITE(I)%PLANT_OM_COST, &
        GEOSITE(I)%HEAT_RATE,     &
        GEOSITE(I)%AVAIL_SUPPLY, &
        GEOSITE(I)%COE, &
        GEOSITE(I)%CAP_COST, &
        GEOSITE(I)%OM_COST, &
        GEOSITE(I)%PFILE_EXCAP, &
        TRIM(SCEN_DATE)
       ENDDO
     ENDIF
920 FORMAT('GEO_INPUT_DATA,',I3,',',I5,',',A22,',',A2,',',I2,',', &
            I1,',',I1,',',F4.0,',',4(F5.0,','),F4.2,',', &
            F6.2,',',F4.2,',',F7.2,',', &
            F8.2,',',F8.2,',',F8.2,',',F8.2,',',F8.2,',',F10.1,',', &
            F8.2,',',F8.2,',',F8.2,',',F8.2,',',F5.0,',',A)


       DO I = 1, NUM_NZERO_SITES
         WRITE(IORNDUMP,950) GEOCRV(I)%MODEL_YEAR, &
        GEOCRV(I)%SITE_ID, &
        GEOCRV(I)%EIA_ID, &
        GEOCRV(I)%NAME, &
        GEOCRV(I)%STATE, &
        GEOCRV(I)%NERC, &
        GEOCRV(I)%CENSUS, &
        GEOCRV(I)%TECHTYPE, &
                GEOCRV(I)%AVAIL_SUPPLY, &
                GEOCRV(I)%AVAIL_SUPPLY_BOUND, &
                GEOCRV(I)%CUM_SUPPLY, &
        GEOCRV(I)%COE, &
        GEOCRV(I)%SYS_COST(1), &
        GEOCRV(I)%SYS_COST(2), &
        GEOCRV(I)%SYS_COST(3), &
        GEOCRV(I)%SYS_CAP_COST(1), &
        GEOCRV(I)%SYS_CAP_COST(2), &
        GEOCRV(I)%SYS_CAP_COST(3), &
        GEOCRV(I)%SYS_OM_COST(1), &
        GEOCRV(I)%SYS_OM_COST(2), &
        GEOCRV(I)%SYS_OM_COST(3), &
        GEOCRV(I)%SYS_HEAT_RATE(1), &
        GEOCRV(I)%SYS_HEAT_RATE(2), &
        GEOCRV(I)%SYS_HEAT_RATE(3), &
        GEOCRV(I)%SYS_CAP_FAC(1), &
        GEOCRV(I)%SYS_CAP_FAC(2), &
        GEOCRV(I)%SYS_CAP_FAC(3), &
        GEOCRV(I)%SYS_CO2_RATE(1), &
        GEOCRV(I)%SYS_CO2_RATE(2), &
        GEOCRV(I)%SYS_CO2_RATE(3), &
        TRIM(SCEN_DATE)
       ENDDO

950 FORMAT('GEO_CURVE_DATA,',I4,',',I3,',',I5,',',A22,',',A2,',', &
            I2,',',I1,',',I1,',',F9.2,',', F9.2,',',&
            F9.2,',',F9.2,',',F12.1,',', &
            F12.1,',',F12.1,',',F10.0,',',F10.0,',', &
            F10.0,',',F10.0,',',F10.0,',',F10.0,',',  &
            F10.0,',',F10.0,',',F10.0,',', &
            F7.2,',',F7.2,',',F7.2,',', &
            F9.2,',',F9.2,',',F9.2,',',A)


       DO NERC = 1, unrgns
        IF (GEO_REG_INDEX(NERC) .EQ. 1) THEN
         WRITE(IORNDUMP,960) CURIYR + 1989, &
           NERC, &
           CRV_INFO(NERC)%MIN_COE, &
           CRV_INFO(NERC)%MAX_COE, &
                   CRV_INFO(NERC)%SEGMENTS(1), &
                   CRV_INFO(NERC)%SEGMENTS(2), &
                   CRV_INFO(NERC)%SEGMENTS(3), &
           EMM_SIGNAL(NERC), &
           CRV_INFO(NERC)%STEP_PRICE(1), &
                   CRV_INFO(NERC)%STEP_PRICE(2), &
           CRV_INFO(NERC)%STEP_PRICE(3), &
           CRV_INFO(NERC)%STEP_QUAN(1), &
                   CRV_INFO(NERC)%STEP_QUAN(2), &
           CRV_INFO(NERC)%STEP_QUAN(3), &
           CRV_INFO(NERC)%STEP_CAP_COST(1), &
                   CRV_INFO(NERC)%STEP_CAP_COST(2), &
           CRV_INFO(NERC)%STEP_CAP_COST(3), &
           CRV_INFO(NERC)%STEP_OM_COST(1), &
                   CRV_INFO(NERC)%STEP_OM_COST(2), &
           CRV_INFO(NERC)%STEP_OM_COST(3), &
           CRV_INFO(NERC)%STEP_HEAT_RATE(1), &
                   CRV_INFO(NERC)%STEP_HEAT_RATE(2), &
           CRV_INFO(NERC)%STEP_HEAT_RATE(3), &
                   REG_HEAT_RATE(NERC), &
           CRV_INFO(NERC)%STEP_CAP_FAC(1), &
                   CRV_INFO(NERC)%STEP_CAP_FAC(2), &
           CRV_INFO(NERC)%STEP_CAP_FAC(3), &
                   REG_CAP_FAC(NERC), &
           CRV_INFO(NERC)%STEP_CO2_RATE(1), &
                   CRV_INFO(NERC)%STEP_CO2_RATE(2), &
           CRV_INFO(NERC)%STEP_CO2_RATE(3), &
                   REG_CO2_RATE(NERC), &
           TRIM(SCEN_DATE)
        ENDIF
       ENDDO

960 FORMAT('GEO_CURVE_INFO,',I4,',',I2,',',F6.2,',',F6.2,',', &
            F6.2,',',F6.2,',',F6.2,',',F6.2,',', &
            F6.2,',',F6.2,',',F6.2,',',F10.2,',',F10.2,',', &
            F10.2,',',F10.2,',',F10.2,',',F10.2,',',&
            F10.2,',',F10.2,',',F10.2,',',  &
            F10.2,',',F10.2,',',F10.2,',',F10.2,',',&
            F5.2,',',F5.2,',',F5.2,',',F5.2,',',&
            F7.2,',',F7.2,',',F7.2,',',F7.2,',',A)

       DO NERC = 1, unrgns
        IF (GEO_REG_INDEX(NERC) .EQ. 1) THEN
         WRITE(IORNDUMP,970) CURIYR + 1989, &
           NERC, &
           GEO_CURVE(NERC)%EMM_CAPACITY(1), &
           GEO_CURVE(NERC)%EMM_CAPACITY(2), &
                   GEO_CURVE(NERC)%EMM_CAPACITY(3), &
           GEO_CURVE(NERC)%EMM_CAP_COST(1), &
           GEO_CURVE(NERC)%EMM_CAP_COST(2), &
                   GEO_CURVE(NERC)%EMM_CAP_COST(3), &
           GEO_CURVE(NERC)%EMM_OM_COST(1), &
           GEO_CURVE(NERC)%EMM_OM_COST(2), &
                   GEO_CURVE(NERC)%EMM_OM_COST(3), &
           GEO_CURVE(NERC)%EMM_HEAT_RATE(1), &
           GEO_CURVE(NERC)%EMM_HEAT_RATE(2), &
                   GEO_CURVE(NERC)%EMM_HEAT_RATE(3), &
           GEO_CURVE(NERC)%EMM_CAP_FAC(1), &
           GEO_CURVE(NERC)%EMM_CAP_FAC(2), &
                   GEO_CURVE(NERC)%EMM_CAP_FAC(3), &
           GEO_CURVE(NERC)%EMM_CO2_RATE(1), &
           GEO_CURVE(NERC)%EMM_CO2_RATE(2), &
                   GEO_CURVE(NERC)%EMM_CO2_RATE(3), &
           TRIM(SCEN_DATE)
           write(13,969) ' GEOHTRT IYR IRG HTRT : ',CURIYR+1989,NERC,GEO_CURVE(NERC)%EMM_HEAT_RATE(1)
        ENDIF
       ENDDO

969 FORMAT(A,I4,' : ',I3,' : ',F10.2)
970 FORMAT('GEO_FINAL_CURVES,',I4,',',I2,',',F12.2,',',F10.2,',', &
            F10.2,',',F12.2,',',F10.2,',',F10.2,',', &
            F12.2,',',F10.2,',',F10.2,',',&
            F12.2,',',F10.2,',',F10.2,',',&
            F8.2,',',F8.2,',',F8.2,',',&
            F8.2,',',F8.2,',',F8.2,',',A)

       DO NERC = 1, unrgns
        IF (GEO_REG_INDEX(NERC) .EQ. 1) THEN
           WRITE(IORNDUMP,940) CURIYR+1989,NERC,GEO_ADD(NERC), &
                           EMM_SIGNAL(NERC), FXD_CHRG_FACT(NERC), &
                               GEO_AVOID_COST(NERC), EPMSTOL, &
                               WGEPRICE_SEG(1),WGEPRICE_SEG(2),WGEPRICE_SEG(3),TRIM(SCEN_DATE)
        ENDIF
       ENDDO

940 FORMAT('GEO_BUILDS,',I4,',',I2,',',F10.2,',',F7.3,',',F7.3,',', &
                    F7.3,',',F7.3,',',F5.2,',',F5.2,',',F5.2,',',A)

    END SUBROUTINE WRITE_DB

    !DSB********************************************************
    !DSB           END -- SUBROUTINE WRITE_DB
    !DSB********************************************************
!***********************************************************************
                                                               !*
      SUBROUTINE GET_PARM_DATA
      use sqlite
     IMPLICIT NONE                                         !*
                                                               !*
!DSB*************************************************************
!DSB*************************************************************

    !DSB*******************************
    !DSB GET_PARM_DATA DECLARATIONS
    !DSB*******************************
    REAL MULT(MNUMYR)    
    INTEGER J, NERC, IYR     !COUNTING VARIABLES
    INTEGER strtyr,syr,tyr,gsite,iyear,num_mults,isite
    
    INTEGER I,EXGEORECS,SITEID  !COUNTING VARIABLES
    INTEGER IUNIT               !OUPUT FILE UNIT NUMBER
    INTEGER FILE_MGR            !NEMS FILE MANAGER RETURN VALUE
        EXTERNAL FILE_MGR
        CHARACTER*25 FNAME
        CHARACTER*80 DUMMY
        CHARACTER*22 GNAME

        type(sqlite_database)                      :: db
        type(sqlite_statement)                     :: stmt
        type(sqlite_statement)                     :: stmt2
        type(sqlite_statement)                     :: stmt3
        type(sqlite_column), dimension(:), pointer :: col
        type(sqlite_column), dimension(:), pointer :: col2
        type(sqlite_column), dimension(:), pointer :: col3
        character(len=40), pointer, dimension(:)   :: result
        character(len=80)                          :: errmsg
        logical                                    :: finished 
    !DSB********************************************************
    !DSB           START SUBROUTINE GET_PARM_DATA
    !DSB********************************************************
     

    !READ IN PARAMETERS FROM WGEPARM FILE
!***********************************************************************
!.....Open file
      FNAME = 'WGEPARM'
      IUNIT=FILE_MGR('O',FNAME,.FALSE.)
!***********************************************************************

!.....Read data
!
      READ(IUNIT,*) DUMMY
      READ(IUNIT,*) (WGEPRICE_SEG(I),I=1,MSPTMX)
!
!     Read in annual build bounds by geothermal site                          
!
        READ (IUNIT,*)
        READ (IUNIT,*)
        READ (IUNIT,'(I4)') STRTYR
        READ (IUNIT,*)
        READ (IUNIT,*)
        SYR = STRTYR - 1989
        TYR = MNUMYR - SYR + 1
    DO I = 1, WGESITES
            READ (IUNIT, 950) GSITE,GNAME, &
                 (GEOSITE(I)%SITE_BOUND(IYR),IYR=SYR,MNUMYR)
        ENDDO

950 FORMAT(I3,1X,A22,<TYR>(1X,F3.0))
980 FORMAT(A,I3,1X,<MNUMYR>(1X,F3.0))
!
       do i = 1 , num_sites
        do iyear = 1 , syr - 1
          geosite(i)%site_bound(iyear) = 50.0
        enddo
       enddo
!
!
! Read in next table of geo site data - contains annual capital costs multipliers by site
!
        READ (IUNIT,*)
        READ (IUNIT,*)
        READ (IUNIT,*)
        READ (IUNIT,'(I4)') NUM_MULTS
        READ (IUNIT,'(I4)') STRTYR
        READ (IUNIT,*)
        READ (IUNIT,*)
        SYR = STRTYR - 1989
        TYR = MNUMYR - SYR + 1
        DO I = 1, NUM_MULTS
          READ (IUNIT,960) GSITE,GNAME,(MULT(IYR),IYR=SYR,MNUMYR)
            IF ( TRIM(GNAME) .EQ. 'ALL' ) THEN 
              write(6,*) ' setting all geosite cost multipliers equal to ALL  multipliers ',MULT(61)
              DO ISITE = 1 , NUM_SITES
                GEOSITE(ISITE)%CAPCOST_MULT(:) = MULT(:)           
              ENDDO
            ELSE
              GEOSITE(GSITE)%CAPCOST_MULT(:) = MULT(:)
            ENDIF
        ENDDO
960 FORMAT(I3,1X,A22,<TYR>(1X,F5.3))
!
       do i = 1 , num_sites
        do iyear = 1 , syr - 1
          geosite(i)%capcost_mult(iyear) = 1.00
        enddo
       enddo
       do i = 1 , num_sites
        write(iorndump,*) ' capcostmult ',i,(geosite(i)%capcost_mult(iyr),iyr=1,MNUMYR)
       enddo
!
      IUNIT=FILE_MGR('C',FNAME,.FALSE.)
!

    !POPULATE STRUCTURE "EXGEO' WITH DATA FROM FILE
     call sqlite3_open( 'emm_db/NEMS_INPUT.db', db )
           
     allocate (col3(11))
     call sqlite3_column_query( col3(1), 'PLANT_ID', sqlite_char )
     call sqlite3_column_query( col3(2), 'PLANT_NAME', sqlite_char )
     call sqlite3_column_query( col3(3), 'SITE_ID', sqlite_int )
     call sqlite3_column_query( col3(4), 'SITE_NAME', sqlite_char )
     call sqlite3_column_query( col3(5), 'PLANT_VINTAGE', sqlite_int )
     call sqlite3_column_query( col3(6), 'PRIME_MOVER', sqlite_char )
     call sqlite3_column_query( col3(7), 'EFD_TYPE', sqlite_int )
     call sqlite3_column_query( col3(8), 'EMM_RGN', sqlite_int )
     call sqlite3_column_query( col3(9), 'STATE', sqlite_char )
     call sqlite3_column_query( col3(10), 'SUMMER_CAP', sqlite_real )
     call sqlite3_column_query( col3(11), 'START_YEAR', sqlite_int )
     call sqlite3_prepare_select( db, 'V_EMM_WGEPARM', col3, stmt3)
     I=0
     
     do
     call sqlite3_next_row( stmt3, col3, finished )
     if ( finished ) exit
     I=I+1
       
     call sqlite3_get_column( col3(1), EXGEO(I)%PLANT_ID )
     call sqlite3_get_column( col3(2), EXGEO(I)%PLANT_NAME )
     call sqlite3_get_column( col3(3), EXGEO(I)%SITE_ID)
     call sqlite3_get_column( col3(4), EXGEO(I)%SITE_NAME )
     call sqlite3_get_column( col3(5), EXGEO(I)%PLANT_VINTAGE )
     call sqlite3_get_column( col3(6), EXGEO(I)%PRIME_MOVER)
     call sqlite3_get_column( col3(7), EXGEO(I)%EFD_TYPE )
     call sqlite3_get_column( col3(8), EXGEO(I)%NERC )
     call sqlite3_get_column( col3(9), EXGEO(I)%STATE)
     call sqlite3_get_column( col3(10), EXGEO(I)%SUMMER_CAP)
     call sqlite3_get_column( col3(11), EXGEO(I)%START_YEAR )

     end do
     EXGEORECS = I
     deallocate ( col3 )
     call sqlite3_close( db )

     DO I = 1, EXGEORECS 
          write(IORNDUMP,*) ' exgeo data ',I,exgeo(I)%site_id,exgeo(I)%plant_id,exgeo(I)%summer_cap
     ENDDO

!     DO I = 1, EXGEORECS 
!         READ (IUNIT, 910) EXGEO(I)%PLANT_ID, & 
!         EXGEO(I)%PLANT_NAME, & 
!         EXGEO(I)%SITE_ID, & 
!         EXGEO(I)%SITE_NAME, & 
!         EXGEO(I)%PLANT_VINTAGE, & 
!         EXGEO(I)%PRIME_MOVER, & 
!         EXGEO(I)%EFD_TYPE, & 
!         EXGEO(I)%NERC, & 
!         EXGEO(I)%STATE, & 
!         EXGEO(I)%SUMMER_CAP, & 
!         EXGEO(I)%START_YEAR 
!                 write(IORNDUMP,*) ' exgeo data ',I,exgeo(I)%site_id,exgeo(I)%plant_id, &
!                          exgeo(I)%summer_cap

!     ENDDO

! 910 FORMAT(A8,1X,A25,1X,I3,1X,A15,1X,I3,1X,A2,4X,I2,2X,I2,1X,A2,2X,F8.2,4X,I4)
!
!     FILL EXISTING GEOSITE VARIABLE WITH EXISTING CAPACITY
!
      DO I = 1 , WGESITES
        GEOSITE(I)%PFILE_EXCAP = 0.0
      ENDDO
!
      DO J = 1 , EXGEORECS
        SITEID = EXGEO(J)%SITE_ID
        GEOSITE(SITEID)%PFILE_EXCAP = GEOSITE(SITEID)%PFILE_EXCAP + EXGEO(J)%SUMMER_CAP
      ENDDO

      IUNIT=FILE_MGR('C',FNAME,.FALSE.)
!***********************************************************************

    END SUBROUTINE GET_PARM_DATA

    !DSB********************************************************
    !DSB           END -- SUBROUTINE GET_PARM_DATA
    !DSB********************************************************


    END SUBROUTINE GEO2000

!DSB***************************************************************
!DSB           END SUBROUTINE GEO2000
!DSB***************************************************************
!***************************************************************
!
!    #    #  #     #  ####   ####     ####
!    #    #   #   #   #   #  #   #   #    #
!    #    #    # #    #   #  #   #   #    #
!    ######     #     #   #  ####    #    #
!    #    #     #     #   #  # #     #    #
!    #    #     #     #   #  #  #    #    #
!    #    #     #     ####   #   #    ####
!
!***************************************************************
!***************************************************************
!*********************************************************************
! SUBROUTINE HYDRO
!
! New Hydro Routine: 6/2003, CGA
! CALCULATES THE REGIONAL 3 STEP HYDRO CAPACITY, CAPITAL COSTS, AND
! O&M COSTS SUPPLY CURVES REQUIRED BY THE EMM.
!
!INPUTS:   'HYDSITE' FILE -- INEEL INPUT DATA FOR HYDROTHERMAL SITES
!
!OUTPUTS:
!
!
!SUBROUTINES :  1. GET_HYSITE_DATA      READS THE 'INEEL' DATA FROM THE
!                                       'HYDSITE' INPUT FILE AND POPULATES
!                                       THE 'HYDSITE' DATA STRUCTURE.
!                                       CALLED ONLY AT FIRST MODEL YEAR
!                                       AND FIRST ITERATION.
!
!               2. GET_HYDATA           READS IN THE HYDRO INPUT PARAMETER FILE
!                                       'WHYDRO'.
!
!               3. BUILD_HYD_CURVES     CREATES THE SUPPLY CURVES.
!                                       POPULATES THE 'HYDCRV', 'HYD_CURVE',
!                                       AND 'CRV_INFO' DATA STRUCTURES.
!                                       CALLED AT LEAST ONCE AT EACH MODEL
!                                       YEAR AND EACH ITERATION.
!                                       CAN RUN MORE THAN ONCE IF AVAILBLE
!                                       CAPACITY RETURNED FOR A REGION = 0
!
!               4. WRITE_HYDB           OUTPUTS KEY DEBUGGING VARIABLES
!                                       IN A COMMA-DELIMITED FORMAT TO THE
!                                       'WDUMP' OUTPUT FILE.
!                                       CAN BE IMPORTED INTO AN EXCEL WORKBOOK
!                                       STRUCTURE USING UNIX SCRIPT "GET_HY_DB.SH"
!                                       AND VBA PROGRAM "HYD_OUT.XLS"
!                                       CALLED ONLY IF VARIABLE 'DEBUGGING' = TRUE
! *********************************************************************
module H_
        INCLUDE 'parametr'   !   standard dimension sizes
        INCLUDE 'ncntrl'     !   control input from integrating module
        INCLUDE 'wrenio'     !   global renewables data
        INCLUDE 'emmparm'    !   emm local parameters
        INCLUDE 'ecpcntl'
        INCLUDE 'control'
        INCLUDE 'wrenew'     !   global renewables data
        INCLUDE 'whyparm'    !   hydro parameters
        INCLUDE 'bildin'
        INCLUDE 'bildout'
        INCLUDE 'emshrin'
        INCLUDE 'entcntl'
        INCLUDE 'enewtech'
        INCLUDE 'eusprc'
        INCLUDE 'efpint'
        INCLUDE 'macout'
        INCLUDE 'uecpout'
        INCLUDE 'uefdout'

!DSB*******************************
!DSB    HYDRO DECLARATIONS
!DSB*******************************

!DSB*****************************************************************
    TYPE HYD_SITE_DATA
        !DATA READ IN FROM HYDRO SITE INPUT FILE (INEEL DATA)
        !THIS STRUCTURE IS POPULATED BY SUBROUTINE 'GET_HYSITE_DATA'
        !THE NUMBER OF RECORDS = THE NUMBER OF SITES CONTAINED IN
        !THE INEEL INPUT FILE ('WHYDRO' INPUT FILE)
        CHARACTER(33) PROJNAME  ! Project Name
        CHARACTER(12) PROJNUM   ! Project Number
        CHARACTER(2) STATE
        INTEGER SITE_ID
        INTEGER NERC
        INTEGER LATITUDE
        INTEGER LONGITUDE
        CHARACTER*3 CLASS       ! C=Coop,F=Federal,I=Industrial,M=Municipal,P=Private Utility,
                                        ! R=Private Non-Utility,N/A=Not Available
                CHARACTER*3 UNITTYPE    ! C=Conventional,R=Reversible,Z=Missing
                CHARACTER*3 PLNTTYPE    ! Plant Type
                CHARACTER*3 PROJSTATUS  ! Project Status
                CHARACTER*3 DAMSTATUS   ! Dam Status
                CHARACTER*1 WSPROT      ! Wild/Scenic Protection  Y=Yes,N=No
                CHARACTER*1 WSTRIB      ! Wild/Scenic Tributary, Location  Y=Yes,N=No
                CHARACTER*1 ENVVALUES(10) ! Environmental Values, Y=Yes,N=No
                                          ! 1=Cultural Value, 2=Fish, 3=Geological, 4=Historical,
                                          ! 5=Other, ie. rare wetland, wilderness designation, 6=Recreation
                                          ! 7=Scenic, 8=Wildlife, 9=Threatened/Endangered Wildlife
                                          ! 10=Threatened/Endangered Fish
                CHARACTER*1 LANDCODES(7)  ! Federal Land Codes, Y=Yes,N=No
                                          ! 1=FLC103, National Park, Monument, Rec area, etc.,
                                          ! 2=FLC104, National Forest or Grassland,
                                          ! 3=FLC105, National Wildife Refuge,Game Preserve, or Fish Hatchery
                                          ! 4=FLC106, National Scenic Waterway or Wilderness Areaish Hatchery
                                          ! 5=FLC107, Indian Reservation
                                          ! 6=FLC108, Military Reservation
                                          ! 7=FLC198, Not on Federal Land
                REAL SITEPROB           ! Project Environmental Suitability Factor
                                        ! .10 = Development prohibited or highly unlikely
                                        ! .25 = Major reduction in likelihood of development
                                        ! .50 = Likelihood of development reduced by half
                                        ! .75 = Minor reduction in likelihood of development
                                        ! .90 = Little effect on likelihood of development
        REAL LISCCOST           ! Liscensing Cost $K  (Dollar year 2002?)
        REAL CONSCOST           ! Construction Cost $K
        REAL DEVCOST            ! Overnight Development Cost $K
        REAL MIT_ARCH           ! 30 Year Archaeological and Historical mitigation cost  $K
        REAL MIT_FISH           ! 30 Year Fish and Wildlife mitigation cost  $K
        REAL MIT_SCEN           ! 30 Year Scenic and Recreation mitigation cost  $K
        REAL MIT_WATER          ! 30 Year Water Quality Monitoring Cost          $K
        REAL MIT_PASS           ! 30 Year Fish Passage cost                      $K
        REAL MIT_TOTAL          ! Total mitigation cost  $K
        REAL TOTDEV_COST        ! Total Development Costs (Mit_Total + Devcost) $K
        REAL UNITDEV_COST       ! Total Unit Development Costs $/KW
        REAL COE                ! Levelized Cost (mills/kwh)
        REAL CAP_COST           ! Capital Cost $/KW
        REAL TOTFOM_COST        ! Avg Annual Fixed O&M Cost $K
        REAL TOTVOM_COST        ! Avg Annual Variable O&M Cost $K
        REAL FOM_COST           ! Avg Annual Fixed O&M Unit Cost $/KW
        REAL VOM_COST           ! Avg Annual Variable O&M Unit Cost mills/kwh
        REAL FERC_COST          ! FERC Annual Charge (Applicable if >= 1.5 MW))  $K
        REAL UNITFERC_COST      ! FERC Annual Charge Unit Cost (Applicable if >= 1.5 MW)  $/KW
        REAL POTENTIAL_CAP      ! Potential Capacity (MW)
        REAL AVAIL_SUPPLY       ! Potential Capacity - Installed 1990 Capacity
        REAL MON_CAPACITY_FACTOR(12) ! 0.00 TO 1.00  - monthly capacity factors
        REAL AVG_CAPACITY_FACTOR ! 0.00 TO 1.00  - average capacity factors
        REAL PFILE_EXCAP        ! EXISTING CAPACITY FOR HYDRO SITE
                                ! FROM EMM PLANT FILE ??
        REAL SITE_BOUND(MNUMYR) ! YEARLY BUILD LIMITS ON HYDRO SITES (MW)
        REAL CAPCOST_MULT(MNUMYR) ! YEARLY CAPITAL COST MULTIPLIERS BY HYDRO SITES
        REAL CAP_COST_ADJ(MNUMYR) ! Capital Cost Adjusment Factors
        REAL CAPACITY_1990          !1990 INSTALLED CAPACITY  is this necessary????
        REAL HEAT_RATE          !set to 0 for now
        REAL CO2_RATE           !set to 0 for now
    END TYPE

     TYPE(HYD_SITE_DATA) :: HYDSITE(MNUMHS)
     TYPE(HYD_SITE_DATA) :: TEMP   !TEMPORARY STRUCTURE USED FOR SORTING
                               !HYDROSITE STRUCTURE

!DSB*****************************************************************
    TYPE HYD_CRV_DATA
        !THIS STRUCTURE IS THE PRIMARY STRUCTURE USED TO GENERATE
        !THE THREE STEP SUPPLY CURVES THAT ARE PASSED TO THE EMM.
        !THIS STRUCTURE IS POPULATED BY SUBROUTINE 'BUILD_HYD_CURVES'

        INTEGER MODEL_YEAR       !CURRENT MODEL YEAR
        CHARACTER(12) PROJNUM
        CHARACTER(33) PROJNAME
        CHARACTER(2) STATE
        CHARACTER(3) UNITTYPE
        INTEGER NERC
        INTEGER SITE_ID
        REAL COE                  !CALCULATED LEVELIZED COST (MILLS/KWHR)
        REAL AVAIL_SUPPLY         !SUPPLY AVAILABLE FOR RECORD (MW)
        REAL AVAIL_SUPPLY_BOUND   !SUPPLY AVAILABLE FOR RECORD AFTER ENFORCING SITE BOUNDS (MW)
        REAL CUM_SUPPLY           !RUNNING CUMULATIVE SUM OF
                                  ! AVAIALABLE CAPACITY (MW)
        REAL SYS_COST(3)          !RUNNING CUMULATIVE SUM OF
                                  !SYSTEM COST (COE * SITE MW)
                                          !FOR EACH OF THE THREE PRICE SEGMENTS
        REAL SYS_CAP_COST(3)      !RUNNING CUMULATIVE SUM OF
                                  !SYSTEM CAPITAL COST ($/KW * SITE MW)
                                          !FOR EACH OF THE THREE PRICE SEGMENTS
        REAL SYS_VOM_COST(3)      !RUNNING CUMULATIVE SUM OF
                                  !SYSTEM VARIABLE O&M COST (MILLS/KWHR * SITE MW)
                                          !FOR EACH OF THE THREE PRICE SEGMENTS
        REAL SYS_FOM_COST(3)      !RUNNING CUMULATIVE SUM OF
                                  !SYSTEM FIXED O&M COST ($/KW * SITE MW)
                                          !FOR EACH OF THE THREE PRICE SEGMENTS
        REAL SYS_HEAT_RATE(3)     !RUNNING CUMULATIVE SUM OF
                                  !HEAT RATE (MMBTU/KWH * SITE MW)
                                          !FOR EACH OF THE THREE PRICE SEGMENTS
        REAL SYS_MON_CAP_FAC(3,12)    !RUNNING CUMULATIVE SUM OF
                                  !SYSTEM MONTHLY CAPACITY FACTOR (FRACTION * SITE MW)
                                          !FOR EACH OF THE THREE PRICE SEGMENTS
        REAL SYS_CAP_FAC(3)       !RUNNING CUMULATIVE SUM OF
                                  !SYSTEM CAPACITY FACTOR (FRACTION * SITE MW)
                                          !FOR EACH OF THE THREE PRICE SEGMENTS
        REAL SYS_CO2_RATE(3)      !RUNNING CUMULATIVE SUM OF
                                  !SYSTEM CO2 EMISSION RATE (LBS/MWH * SITE MW)
                                          !FOR EACH OF THE THREE PRICE SEGMENTS
            REAL CAP_COST             !CAPITAL COST FOR CAPACITY CONTAINED IN
                                  !FOR RECORD (1987$/KW)
        REAL VOM_COST             !VARIABLE O&M COST FOR CAPACITY CONTAINED IN
                                  !FOR RECORD (1987$/KW)
        REAL FOM_COST             !FIXED O&M COST FOR CAPACITY CONTAINED IN
                                  !FOR RECORD (1987$/KW)
        REAL HEAT_RATE            !HEAT RATE FOR CAPACITY CONTAINED IN
                                  !FOR RECORD (BTU/KWH)
        REAL CAP_FAC              !AVERAGE CAPACITY FACTOR FOR CAPACITY CONTAINED IN
                                  !FOR RECORD (FRACTION)
        REAL MON_CAP_FAC(12)      !MONTHLY CAPACITY FACTOR FOR CAPACITY CONTAINED IN
                                  !FOR RECORD (FRACTION)
        REAL CO2_RATE             !CO2 EMISSION RATE FOR CAPACITY CONTAINED IN
                                  !FOR RECORD (LBS/MWH)

    END TYPE

     TYPE(HYD_CRV_DATA) :: HYDCRV(6 * MNUMHS)
     TYPE(HYD_CRV_DATA) :: TMPCRV(6 * MNUMHS) !TEMPORARY STRUCTURE USED TO HOLD
                                          !THE VALUES CONTAINED IN 'HYDCRV'
                                              !VALUES ARE WRITTEN BACK TO 'HYDCRV'
                                              !IF AVAILABLE CAPACITY AT HE SITE
                                              !IS GREATER THAN ZERO
     TYPE(HYD_CRV_DATA) :: TEMP2              !TEMPORARY STRUCTURE USED FOR SORTING

!DSB*****************************************************************
    TYPE EMM_CURVE_DATA
        !FINAL CURVES PASSED TO EMM
        REAL EMM_CAP_COST(3)    !FOR EACH OF THESE ARRAYS, FIRST
        REAL EMM_VOM_COST(3)    !ELEMENT CONTAINS ACTUAL VALUES.
        REAL EMM_FOM_COST(3)    !ELEMENT CONTAINS ACTUAL VALUES.
        REAL EMM_CAPACITY(3)    !ELEMENTS 2 AND 3 CONTAIN MULTIPLIERS
        REAL EMM_HEAT_RATE(3)   !TO BE APPLIED TO ELEMENT 1
        REAL EMM_CAP_FAC(3)     !
        REAL EMM_MON_CAP_FAC(3,12)     !
        REAL EMM_CO2_RATE(3)    !
    END TYPE

     TYPE(EMM_CURVE_DATA) :: HYD_CURVE(MNUMNR)

!DSB*****************************************************************
    TYPE EXHYD_CAP_DATA
        !HYDRO EXISTING CAPACITY FROM EMM PLANT FILE
        CHARACTER(8) PLANT_ID    !Plant ID from EMM Hydro Plant Record
        CHARACTER(25)PLANT_NAME  !Plant Name from "
        INTEGER SITE_ID          !Site ID that maps plant record to Petty data
        CHARACTER(15) SITE_NAME  !Site Name  "
        INTEGER PLANT_VINTAGE    !Plant Vintage from EMM Hydro Plant Record
        CHARACTER(2) PRIME_MOVER !Prime Mover  "
        INTEGER EFD_TYPE         !EFD_Type from "
        INTEGER NERC             !NERC Region
        CHARACTER(2) STATE       !State
        REAL SUMMER_CAP          !Summer Capacity (MW)
        INTEGER START_YEAR       !Last Unit Start Date
    END TYPE

     TYPE(EXHYD_CAP_DATA) :: EXHYD(NUMEXHY)

!DSB*****************************************************************
    TYPE CURVE_DATA
        !STORES CALCULATED VALUES USED IN BUILDING THE
        !SUPPLY CURVES
        REAL MIN_COE !COE OF FIRST AVAILABLE SITE
        REAL MAX_COE !COE OF SITE AT OR BELOW EMM SIGNAL PRICE
        REAL SEGMENTS(3)  !PRICES CALCULATED FROM SEGMENT
                          !RATIOS.  LAST SEGMENT EQUALS
                          !MAXIMUM COE
        REAL STEP_PRICE(3)       !ACTUAL COE THAT IS AT OR BELOW EACH
                                 !THE PRICES CALCULATED AND STORED IN
                                 !THE SEGMENTS ARRAY (ABOVE)
        REAL STEP_QUAN(3)        !QUANTITY THAT IS AVAILABLE AT
                                 !STEP_PRICE(I)  (MW)
        REAL STEP_CAP_COST(3)    !WEIGHTED AVERAGE CAPITAL COST
                                 ! AT STEP_PRICE(I)  $/KW
        REAL STEP_VOM_COST(3)    !WEIGHTED AVERAGE VAR OM COST
                                 !AT STEP_PRICE(I)  mills/kwh
        REAL STEP_FOM_COST(3)    !WEIGHTED AVERAGE FIXED OM COST
                                 !AT STEP_PRICE(I)  $/KW
        REAL STEP_HEAT_RATE(3)   !WEIGHTED AVERAGE HEAT RATE
                                 !AT STEP_PRICE(I)  BTU/KWH
        REAL STEP_CAP_FAC(3)     !WEIGHTED AVERAGE CAPACITY FACTOR
                                 !AT STEP_PRICE(I)  FRACTION
        REAL STEP_MON_CAP_FAC(3,12)  !WEIGHTED AVERAGE MONTHLY CAPACITY FACTORS
                                 !AT STEP_PRICE(I)  FRACTION
        REAL STEP_CO2_RATE(3)    !WEIGHTED AVERAGE CO2 EMISSION RATE
                                 !AT STEP_PRICE(I)  LBS/MWH
    END TYPE

     TYPE(CURVE_DATA) :: CRV_INFO(MNUMNR)

!DSB*****************************************************************

    INTEGER NUM_SITES  !NUMBER OF SITES IN STRUCTURE 'HYDCRV'
    INTEGER WHYSITES   !NUMBER OF HYD SITES IN INPUT FILE

    LOGICAL DEBUGGING  !SET TO TRUE TO WRITE OUTPUT TO 'WDUMP' FILE
    INTEGER I, J, NERC, IMO, ISTP, RTECH, ISPR, SFOUND !COUNTING VARIABLES


      REAL LEARN_FACT             !HYDRO LEARNING FACTOR FROM ECP
      REAL OPT_FACT               !HYDRO OPTIMISM FACTOR FROM ECP
      REAL REG_HEAT_RATE(MNUMNR)  !WEIGHTED AVERAGE HEAT RATE BY NERC REGION
      REAL REG_CAP_FAC(MNUMNR)    !WEIGHTED AVERAGE CAPACITY FACTOR BY NERC REGION
      REAL REG_MON_CAP_FAC(MNUMNR,12)    !WEIGHTED AVERAGE MONTHLY CAPACITY FACTORS BY NERC REGION
      REAL REG_CO2_RATE(MNUMNR)   !WEIGHTED AVERAGE CO2 EMISSION RATE BY NERC REGION
      REAL FXD_CHRG_FACT(MNUMNR)  !FIXED CHARGE FACTOR USED TO
                              !CALCULATE LEVELIZED COSTS FOR EACH SITE

      REAL LVCSTMIN               !MINIMUM LEVELIZED COST OF ALTERNATE TECHNOLOGIES
      REAL EMM_SIGNAL(MNUMNR)     !REGIONAL THRESHOLD COST OF
                                  !ELECTRICITY FROM EMM (MILLS/KWHR)
                                  !UPPER BOUND FOR AVAILABLE CAPACITY

      REAL UNPLAN_HY(MNUMNR)      !TEMPORARY HOLDER FOR UNPLANNED
                              !HYDRO CAPACITY

      REAL HYD_ADD (MNUMNR)       !UNPLANNED HYDRO CAPACITY
                              !USED ONLY TO PRESERVE AMOUNT OF
                                  !UNPLANNED BUILDS FOR DEBUG REPORT

      INTEGER NUM_NZERO_SITES     !NUMBER OF HYDRO SITES IN STRUCTURE
                                  !WITH NON-ZERO CAPACITY AFTER UNPLANNED
                                  !BUILDS HAVE BEEN REMOVED FROM THE CHEAPEST SITES

      INTEGER HYD_ECP_TYPE        !ECP_TYPE FOR HYDRO TECHNOLOGY

      REAL HYD_AVOID_COST(MNUMNR) !HYDRO AVOIDED COST FROM ECP - MILLS/KWHR

      INTEGER PASSES              !STORES NUMBER OF CALLS TO
                              !SUBROUTINE 'BUILD_HYD_CURVES'
      INTEGER MAXPASSES         

      LOGICAL RUN_AGAIN           !SET TO TRUE IF NO CAPACITY IN REGIONS
end module H_
      SUBROUTINE HYDRO
      use H_
      IMPLICIT NONE

!***************************************************************
!           START SUBROUTINE HYDRO
!***************************************************************

    DEBUGGING = .TRUE.   !SET DEBUGGING MODE TO GENERATE REPORT
    MAXPASSES = 10

    !GET ECP INDEX FOR HYDRO TECHNOLOGY
    DO J = 1, ECP_D_CAP
       IF (UPLNTCD(J) .EQ. 'HY') THEN
         HYD_ECP_TYPE = J
       ENDIF
    ENDDO

    !GET FIXED CHARGE FACTOR FROM EMM IF AFTER ECP START YEAR
    !ELSE USE 13 PERCENT.  ALSO, GET AVOIDED COST INCREMENTED
    !BY THE TOLERANCE LEVEL FOR
    !ALSO GET OPTIMISM AND LEARNING FACTORS FROM ECP
    !THE HYDRO TECHNOLOGY.  THIS WILL BE THE UPPER BOUND
    !OF COE FOR CAPACITY IN THE REGION.
    IF (CURIYR + 1989 .GE. ( UPAVLYR(HYD_ECP_TYPE) - UPPLYR(HYD_ECP_TYPE) )) THEN
           LEARN_FACT = UPLRLC(HYD_ECP_TYPE)
           OPT_FACT = UPLROPT(HYD_ECP_TYPE)
!  CALL SUBROUTINE TO DETERMINE MINIMUM LEVELIZED COSTS OF OTHER TECHNOLOGIES
            CALL ECPLVCST(1,CURIYR,MNUMNR,UPMCF(WIHY),LVCSTMIN)
       DO NERC = 1, unrgns
            CALL GETBOUT(CURIYR,NERC)
            CALL ECPLVCST(2,CURIYR,NERC,UPMCF(WIHY),LVCSTMIN)
            FXD_CHRG_FACT(NERC) = EPLVFCF(HYD_ECP_TYPE,2)
            IF (FXD_CHRG_FACT(NERC) .EQ. 0.0) FXD_CHRG_FACT(NERC)=0.13
!               HYD_AVOID_COST(NERC) = EPTAVD(HYD_ECP_TYPE)
            HYD_AVOID_COST(NERC) = LVCSTMIN + &     ! adjust for RPS credits
                                                  RENEWCR(CURIYR)
            EMM_SIGNAL(NERC) = HYD_AVOID_COST(NERC) * (1.0 + EPMSTOL)

       ENDDO
    ELSE
           LEARN_FACT = 1.0
           OPT_FACT = 1.0
       DO NERC = 1, MNUMNR
             FXD_CHRG_FACT(NERC) = 0.13
         EMM_SIGNAL(NERC) = 4.5 * 10.0
       ENDDO
    END IF
    write(IORNDUMP,*) ' learn,opt,yr,fcf ',learn_fact,opt_fact,curiyr,(fxd_chrg_fact(nerc),nerc=1,13)
    write(IORNDUMP,*) ' hydro emm_signal ',(emm_signal(nerc),nerc=1,13)


    !READ DATA FROM HYDSITE INPUT FILE -- "INEEL DATA"
    IF ((CURCALYR .EQ. UESTYR) .AND. (CURITR .EQ. 1)) THEN
        CALL GET_HYSITE_DATA
    ENDIF

    !BUILD SUPPLY CURVES
      CALL BUILD_HYD_CURVES

     !IF AVAILABLE CAPACITY IN THE FIRST SUPPLY CURVE STEP
     !CALCULATED BY 'BUILD_HYD_CURVES'
     !EQUALS ZERO FOR ANY? REGION THEN INCREASE
     !THE EMM'S THRESHOLD VALUE AND SET RUN_AGAIN = TRUE.
     RUN_AGAIN = .FALSE.
     DO NERC = 1 , unrgns
        IF (CRV_INFO(NERC)%STEP_QUAN(1) .EQ. 0.0) THEN
            EMM_SIGNAL(NERC) = EMM_SIGNAL(NERC) * 1.02
            RUN_AGAIN = .TRUE.
        ENDIF
     ENDDO

     !ITERATE SUBROUTINE 'BUILD_HYD_CURVES' UNTIL THE CAPACITY
     !AVAILBALE CALCULATED FOR THE FIRST SUPPLY STEP IS GREATER
     !THAN ZERO IN ANY REGION ?? OR THE SUBROUTINE IS
     !CALLED 10 TIMES.  INCRENET THE EMM THRESHOLD BETWEEN EACH
     !SUBROUTINE CALL.
!  make run_again regional?????????????
     PASSES = 0
     DO WHILE (RUN_AGAIN .AND. PASSES .LE. MAXPASSES)
        CALL BUILD_HYD_CURVES
       RUN_AGAIN = .FALSE.
          DO NERC = 1 , unrgns
            IF (CRV_INFO(NERC)%STEP_QUAN(1) .EQ. 0.0) THEN
            EMM_SIGNAL(NERC) = EMM_SIGNAL(NERC) * 1.02
            RUN_AGAIN = .TRUE.
            ENDIF
          ENDDO
          IF (RUN_AGAIN .EQ. .TRUE.) THEN
            PASSES = PASSES + 1
          ENDIF
     ENDDO

    !WRITE DATA TO FILE 'WDUMP' IF 'DEBUGGING' = TRUE
    IF (DEBUGGING) THEN
!         IF ((FCRL .EQ. 1)) THEN
            CALL WRITE_HYDB
!         ENDIF
        ENDIF
!
!   SET SUPPLY CURVE DATA FOR ECP
!      1 = Hydro
!
      DO NERC = 1, unrgns
        DO ISTP = 1 , MSPTMX
          IF ( ISTP .EQ. 1) THEN
            UTCAFNR(NERC,1,ISTP) = HYD_CURVE(NERC)%EMM_CAPACITY(ISTP)
            UTCSFN(NERC,1,ISTP)  = 1.0
            UTFXFN(NERC,1,ISTP)  = 1.0
            UTVRFN(NERC,1,ISTP)  = 1.0
          ELSE
            UTCAFNR(NERC,1,ISTP) = HYD_CURVE(NERC)%EMM_CAPACITY(ISTP)
            UTCSFN(NERC,1,ISTP)  = HYD_CURVE(NERC)%EMM_CAP_COST(ISTP)
            UTFXFN(NERC,1,ISTP)  = HYD_CURVE(NERC)%EMM_FOM_COST(ISTP)
            UTVRFN(NERC,1,ISTP)  = HYD_CURVE(NERC)%EMM_VOM_COST(ISTP)
          ENDIF
!
        WMFHYEL(NERC,ISTP,:,CURIYR) = HYD_CURVE(NERC)%EMM_MON_CAP_FAC(ISTP,:)
!
        IF (UTCAFNR(NERC,1,1) .EQ. 0.0 ) THEN
          write(6,2251) ' warning: no hydro capacity in first step of supply curve year: ',curiyr,' region: ',nerc
        ENDIF
 2251 format(a,I5,a,I5)
!       write(6,*) ' hyel vars ',WCCHYEL(NERC,CURIYR),WOCHYEL(NERC,CURIYR),WVCHYEL(NERC,CURIYR), &
!                 whrhyel(nerc,curiyr),wcfhyel(nerc,curiyr)
!      write(6,224) ' wmfhyel ',(wmfhyel(nerc,istp,imo,curiyr),imo=1,12)
!       write(IORNDUMP,*) ' UT VARS NERC STP',UTCAFNR(NERC,1,ISTP),UTCSFN(NERC,1,ISTP),  &
!                UTFXFN(NERC,1,ISTP),UTVRFN(NERC,1,ISTP),NERC,ISTP
        ENDDO
!
!       PUT INITIAL FIXED O&M and CAPITAL COSTS INTO BASE VALUE FOR THE ECP
!
        WCAHYEL(NERC,CURIYR) = HYD_CURVE(NERC)%EMM_CAPACITY(1)
        WCCHYEL(NERC,CURIYR) = HYD_CURVE(NERC)%EMM_CAP_COST(1)
        WOCHYEL(NERC,CURIYR) = HYD_CURVE(NERC)%EMM_FOM_COST(1)
        WVCHYEL(NERC,CURIYR) = HYD_CURVE(NERC)%EMM_VOM_COST(1)
!       WHRHYEL(NERC,CURIYR) = REG_HEAT_RATE(NERC)
        WHRHYEL(NERC,CURIYR) = UPHTRT(WIHY)
        WCFHYEL(NERC,CURIYR) = HYD_CURVE(NERC)%EMM_CAP_FAC(1)
      ENDDO
 224  format(a,12(f10.5))

    CONTAINS

!DSB*************************************************************
!DSB*************************************************************
                                                               !*
      SUBROUTINE GET_HYSITE_DATA
      USE SQLITE
      IMPLICIT NONE                                             !*
                                                               !*
!DSB*************************************************************
!DSB*************************************************************

    !DSB*******************************
    !DSB GET_HYSITE_DATA DECLARATIONS
    !DSB*******************************


        REAL EXCAP
    INTEGER I, J, NERC, IYR, ISITE     !COUNTING VARIABLES
    INTEGER strtyr,syr,tyr,hsite,iyear
    INTEGER IUNIT               !OUPUT FILE UNIT NUMBER
    INTEGER FILE_MGR            !NEMS FILE MANAGER RETURN VALUE
        EXTERNAL FILE_MGR
        CHARACTER*25 FNAME
        CHARACTER*22 HNAME
  
        type(sqlite_database)                      :: db
        type(sqlite_statement)                     :: stmt
        type(sqlite_statement)                     :: stmt2
        type(sqlite_statement)                     :: stmt3
        type(sqlite_column), dimension(:), pointer :: col
        character(len=40), pointer, dimension(:)   :: result
        character(len=80)                          :: errmsg
        logical                                    :: finished  

    !DSB********************************************************
    !DSB           START SUBROUTINE GET_SITE_DATA
    !DSB********************************************************
     
      call sqlite3_open( 'emm_db/NEMS_INPUT.db', db )
!      WRITE(6,*)' HYDSITE data'
      
      allocate (col(60))
      call sqlite3_column_query( col(1), 'ID', sqlite_int )
      call sqlite3_column_query( col(2), 'PROJNUM', sqlite_char )
      call sqlite3_column_query( col(3), 'PROJNAME', sqlite_char )
      call sqlite3_column_query( col(4), 'STATE', sqlite_char )
      call sqlite3_column_query( col(5), 'EMM_REG', sqlite_int )
      call sqlite3_column_query( col(6), 'CLASS', sqlite_char )
      call sqlite3_column_query( col(7), 'POTENTIAL_CAP', sqlite_real )
      call sqlite3_column_query( col(8), 'UNITTYPE', sqlite_char )
      call sqlite3_column_query( col(9), 'PLNTTYPE', sqlite_char )
      call sqlite3_column_query( col(10), 'PROJSTATUS', sqlite_char )
      call sqlite3_column_query( col(11), 'DAMSTATUS', sqlite_char )
      call sqlite3_column_query( col(12), 'WSPROT', sqlite_char )
      call sqlite3_column_query( col(13), 'WSTRIB', sqlite_char )
      call sqlite3_column_query( col(14), 'ENVVALUES_1', sqlite_char )
      call sqlite3_column_query( col(15), 'ENVVALUES_2', sqlite_char )
      call sqlite3_column_query( col(16), 'ENVVALUES_3', sqlite_char )
      call sqlite3_column_query( col(17), 'ENVVALUES_4', sqlite_char )
      call sqlite3_column_query( col(18), 'ENVVALUES_5', sqlite_char )
      call sqlite3_column_query( col(19), 'ENVVALUES_6', sqlite_char )
      call sqlite3_column_query( col(20), 'ENVVALUES_7', sqlite_char )
      call sqlite3_column_query( col(21), 'ENVVALUES_8', sqlite_char )
      call sqlite3_column_query( col(22), 'ENVVALUES_9', sqlite_char )
      call sqlite3_column_query( col(23), 'ENVVALUES_10', sqlite_char )
      call sqlite3_column_query( col(24), 'LANDCODES_1', sqlite_char )
      call sqlite3_column_query( col(25), 'LANDCODES_2', sqlite_char )
      call sqlite3_column_query( col(26), 'LANDCODES_3', sqlite_char )
      call sqlite3_column_query( col(27), 'LANDCODES_4', sqlite_char )
      call sqlite3_column_query( col(28), 'LANDCODES_5', sqlite_char )
      call sqlite3_column_query( col(29), 'LANDCODES_6', sqlite_char )
      call sqlite3_column_query( col(30), 'LANDCODES_7', sqlite_char )
      call sqlite3_column_query( col(31), 'SITEPROB', sqlite_real )
      call sqlite3_column_query( col(32), 'LISCCOST', sqlite_real )
      call sqlite3_column_query( col(33), 'CONSCOST', sqlite_real )
      call sqlite3_column_query( col(34), 'DEVCOST', sqlite_real )
      call sqlite3_column_query( col(35), 'MIT_ARCH', sqlite_real )
      call sqlite3_column_query( col(36), 'MIT_FISH', sqlite_real )
      call sqlite3_column_query( col(37), 'MIT_SCEN', sqlite_real )
      call sqlite3_column_query( col(38), 'MIT_WATER', sqlite_real )
      call sqlite3_column_query( col(39), 'MIT_PASS', sqlite_real )
      call sqlite3_column_query( col(40), 'MIT_TOTAL', sqlite_real )
      call sqlite3_column_query( col(41), 'TOTDEV_COST', sqlite_real )
      call sqlite3_column_query( col(42), 'UNITDEV_COST', sqlite_real )
      call sqlite3_column_query( col(43), 'TOTFOM_COST', sqlite_real )
      call sqlite3_column_query( col(44), 'FOM_COST', sqlite_real )
      call sqlite3_column_query( col(45), 'TOTVOM_COST', sqlite_real )
      call sqlite3_column_query( col(46), 'VOM_COST', sqlite_real )
      call sqlite3_column_query( col(47), 'FERC_COST', sqlite_real )
      call sqlite3_column_query( col(48), 'AVG_CAPACITY_FACTOR', sqlite_real )
      call sqlite3_column_query( col(49), 'MON_CF_1', sqlite_real )
      call sqlite3_column_query( col(50), 'MON_CF_2', sqlite_real )
      call sqlite3_column_query( col(51), 'MON_CF_3', sqlite_real )
      call sqlite3_column_query( col(52), 'MON_CF_4', sqlite_real )
      call sqlite3_column_query( col(53), 'MON_CF_5', sqlite_real )
      call sqlite3_column_query( col(54), 'MON_CF_6', sqlite_real )
      call sqlite3_column_query( col(55), 'MON_CF_7', sqlite_real )
      call sqlite3_column_query( col(56), 'MON_CF_8', sqlite_real )
      call sqlite3_column_query( col(57), 'MON_CF_9', sqlite_real )
      call sqlite3_column_query( col(58), 'MON_CF_10', sqlite_real )
      call sqlite3_column_query( col(59), 'MON_CF_11', sqlite_real )
      call sqlite3_column_query( col(60), 'MON_CF_12', sqlite_real )      
      call sqlite3_prepare_select( db, 'V_EMM_HYDSITE', col, stmt)
      
      ! LOAD RESULTS INTO FORTRAN VARIABLES FOR NEMS
      do
      call sqlite3_next_row( stmt, col, finished )
      if ( finished ) exit
      
      call sqlite3_get_column( col(1), I)
      call sqlite3_get_column( col(2), HYDSITE(I)%PROJNUM )
      call sqlite3_get_column( col(3), HYDSITE(I)%PROJNAME )
      call sqlite3_get_column( col(4), HYDSITE(I)%STATE )
      call sqlite3_get_column( col(5), HYDSITE(I)%NERC )
      call sqlite3_get_column( col(6), HYDSITE(I)%CLASS )
      call sqlite3_get_column( col(7), HYDSITE(I)%POTENTIAL_CAP )
      call sqlite3_get_column( col(8), HYDSITE(I)%UNITTYPE )
      call sqlite3_get_column( col(9), HYDSITE(I)%PLNTTYPE )
      call sqlite3_get_column( col(10), HYDSITE(I)%PROJSTATUS )
      call sqlite3_get_column( col(11), HYDSITE(I)%DAMSTATUS )
      call sqlite3_get_column( col(12), HYDSITE(I)%WSPROT )
      call sqlite3_get_column( col(13), HYDSITE(I)%WSTRIB )
      call sqlite3_get_column( col(14), HYDSITE(I)%ENVVALUES(1) )
      call sqlite3_get_column( col(15), HYDSITE(I)%ENVVALUES(2) )
      call sqlite3_get_column( col(16), HYDSITE(I)%ENVVALUES(3) )
      call sqlite3_get_column( col(17), HYDSITE(I)%ENVVALUES(4) )
      call sqlite3_get_column( col(18), HYDSITE(I)%ENVVALUES(5) )
      call sqlite3_get_column( col(19), HYDSITE(I)%ENVVALUES(6) )
      call sqlite3_get_column( col(20), HYDSITE(I)%ENVVALUES(7) )
      call sqlite3_get_column( col(21), HYDSITE(I)%ENVVALUES(8) )
      call sqlite3_get_column( col(22), HYDSITE(I)%ENVVALUES(9) )
      call sqlite3_get_column( col(23), HYDSITE(I)%ENVVALUES(10) )
      call sqlite3_get_column( col(24), HYDSITE(I)%LANDCODES(1) )
      call sqlite3_get_column( col(25), HYDSITE(I)%LANDCODES(2) )
      call sqlite3_get_column( col(26), HYDSITE(I)%LANDCODES(3) )
      call sqlite3_get_column( col(27), HYDSITE(I)%LANDCODES(4) )
      call sqlite3_get_column( col(28), HYDSITE(I)%LANDCODES(5) )
      call sqlite3_get_column( col(29), HYDSITE(I)%LANDCODES(6) )
      call sqlite3_get_column( col(30), HYDSITE(I)%LANDCODES(7) )
      call sqlite3_get_column( col(31), HYDSITE(I)%SITEPROB )
      call sqlite3_get_column( col(32), HYDSITE(I)%LISCCOST )
      call sqlite3_get_column( col(33), HYDSITE(I)%CONSCOST )
      call sqlite3_get_column( col(34), HYDSITE(I)%DEVCOST )
      call sqlite3_get_column( col(35), HYDSITE(I)%MIT_ARCH )
      call sqlite3_get_column( col(36), HYDSITE(I)%MIT_FISH )
      call sqlite3_get_column( col(37), HYDSITE(I)%MIT_SCEN )
      call sqlite3_get_column( col(38), HYDSITE(I)%MIT_WATER )
      call sqlite3_get_column( col(39), HYDSITE(I)%MIT_PASS )
      call sqlite3_get_column( col(40), HYDSITE(I)%MIT_TOTAL )
      call sqlite3_get_column( col(41), HYDSITE(I)%TOTDEV_COST )
      call sqlite3_get_column( col(42), HYDSITE(I)%UNITDEV_COST )
      call sqlite3_get_column( col(43), HYDSITE(I)%TOTFOM_COST )
      call sqlite3_get_column( col(44), HYDSITE(I)%FOM_COST )
      call sqlite3_get_column( col(45), HYDSITE(I)%TOTVOM_COST )
      call sqlite3_get_column( col(46), HYDSITE(I)%VOM_COST )
      call sqlite3_get_column( col(47), HYDSITE(I)%FERC_COST )
      call sqlite3_get_column( col(48), HYDSITE(I)%AVG_CAPACITY_FACTOR )
      call sqlite3_get_column( col(49), HYDSITE(I)%MON_CAPACITY_FACTOR(1) )
      call sqlite3_get_column( col(50), HYDSITE(I)%MON_CAPACITY_FACTOR(2) )
      call sqlite3_get_column( col(51), HYDSITE(I)%MON_CAPACITY_FACTOR(3) )
      call sqlite3_get_column( col(52), HYDSITE(I)%MON_CAPACITY_FACTOR(4) )
      call sqlite3_get_column( col(53), HYDSITE(I)%MON_CAPACITY_FACTOR(5) )
      call sqlite3_get_column( col(54), HYDSITE(I)%MON_CAPACITY_FACTOR(6) )
      call sqlite3_get_column( col(55), HYDSITE(I)%MON_CAPACITY_FACTOR(7) )
      call sqlite3_get_column( col(56), HYDSITE(I)%MON_CAPACITY_FACTOR(8) )
      call sqlite3_get_column( col(57), HYDSITE(I)%MON_CAPACITY_FACTOR(9) )
      call sqlite3_get_column( col(58), HYDSITE(I)%MON_CAPACITY_FACTOR(10) )
      call sqlite3_get_column( col(59), HYDSITE(I)%MON_CAPACITY_FACTOR(11) )
      call sqlite3_get_column( col(60), HYDSITE(I)%MON_CAPACITY_FACTOR(12) )      

!      WRITE(6,*)'HYDSITE(I)%PROJNUM ',I, HYDSITE(I)%PROJNUM
!      WRITE(6,*)'HYDSITE(I)%PROJNAME ',I, HYDSITE(I)%PROJNAME
!      WRITE(6,*)'HYDSITE(I)%POTENTIAL_CAP ',I, HYDSITE(I)%POTENTIAL_CAP
      
 1124   FORMAT(1X,I4,1X,A12,1x,A33,1x,A2,1x,I4,1x,A3,1x,F9.3,1x,4(A3,1x),19(A1,1x),F5.2,1x,    &
               3(F8.0,1x),6(F7.0,1x),F8.0,1x,F8.0,1x,F5.0,1x,F7.2,1x,f5.0,1x,f5.2,1x,f5.0,   &
               13(1x,F7.4))

   write(IORNDUMP,1124) i,                & 
        HYDSITE(I)%PROJNUM,     &
        HYDSITE(I)%PROJNAME,    &
        HYDSITE(I)%STATE,       &
        HYDSITE(I)%NERC,       &
        HYDSITE(I)%CLASS ,       &     
        HYDSITE(I)%POTENTIAL_CAP,      &
             HYDSITE(I)%UNITTYPE,       &    
             HYDSITE(I)%PLNTTYPE,       &    
             HYDSITE(I)%PROJSTATUS,       &  
             HYDSITE(I)%DAMSTATUS,       &  
             HYDSITE(I)%WSPROT,       &    
             HYDSITE(I)%WSTRIB,       &   
             (HYDSITE(I)%ENVVALUES(J),J=1,10),       &
             (HYDSITE(I)%LANDCODES(J),J=1,7),  & 
             HYDSITE(I)%SITEPROB,       &         
             HYDSITE(I)%LISCCOST,       &
             HYDSITE(I)%CONSCOST,       & 
             HYDSITE(I)%DEVCOST,        &
             HYDSITE(I)%MIT_ARCH,       &
             HYDSITE(I)%MIT_FISH,       & 
             HYDSITE(I)%MIT_SCEN,       &      
             HYDSITE(I)%MIT_WATER,       &   
             HYDSITE(I)%MIT_PASS,       &   
             HYDSITE(I)%MIT_TOTAL,       & 
             HYDSITE(I)%TOTDEV_COST,       &  
             HYDSITE(I)%UNITDEV_COST,       &  
             HYDSITE(I)%TOTFOM_COST,       &    
             HYDSITE(I)%FOM_COST,       &       
             HYDSITE(I)%TOTVOM_COST,       &    
             HYDSITE(I)%VOM_COST,       &       
             HYDSITE(I)%FERC_COST,       &      
             HYDSITE(I)%AVG_CAPACITY_FACTOR,       & 
             (HYDSITE(I)%MON_CAPACITY_FACTOR(J),J=1,12) 

       !CALCULATE COE FOR EACH SITE
        NERC = HYDSITE(I)%NERC
        HYDSITE(I)%UNITDEV_COST = ( HYDSITE(I)%CONSCOST +       &
                                   HYDSITE(I)%LISCCOST + HYDSITE(I)%MIT_TOTAL ) / HYDSITE(I)%POTENTIAL_CAP
        HYDSITE(I)%CAP_COST = ( HYDSITE(I)%CONSCOST +       &
                                   HYDSITE(I)%LISCCOST + HYDSITE(I)%MIT_TOTAL ) / HYDSITE(I)%POTENTIAL_CAP
!           HYDSITE(I)%CAP_COST = ( HYDSITE(I)%CONSCOST + ( (0.9/HYDSITE(I)%SITEPROB) *      &
!                                 ( HYDSITE(I)%LISCCOST + HYDSITE(I)%MIT_TOTAL ) ) ) / HYDSITE(I)%POTENTIAL_CAP
            HYDSITE(I)%UNITFERC_COST = HYDSITE(I)%FERC_COST / HYDSITE(I)%POTENTIAL_CAP
            HYDSITE(I)%FOM_COST = HYDSITE(I)%FOM_COST + HYDSITE(I)%UNITFERC_COST
        HYDSITE(I)%COE = ( (HYDSITE(I)%CAP_COST * &
                               FXD_CHRG_FACT(NERC) *  &
                               LEARN_FACT * OPT_FACT ) + &
                               HYDSITE(I)%FOM_COST) / &
                              (HYDSITE(I)%AVG_CAPACITY_FACTOR * &
                               8.760) + HYDSITE(I)%VOM_COST
            HYDSITE(I)%HEAT_RATE = 0.0
            HYDSITE(I)%CO2_RATE = 0.0
            HYDSITE(I)%SITE_ID = I
!            I = I + 1
!            GOTO 10
!  1200  CONTINUE
      end do
      deallocate ( col )
      call sqlite3_close( db )
      
        WHYSITES = I - 1
!
!     Set default values for hydro site bounds
!
        DO I = 1 , WHYSITES
          DO IYEAR = 1 , MNUMYR
            HYDSITE(I)%SITE_BOUND(IYEAR) = 9999.0
          ENDDO
        ENDDO
!
!     Set default values for hydro site capital cost multipliers
!
       DO I = 1 , WHYSITES
         DO IYEAR = 1 , MNUMYR
           HYDSITE(I)%CAPCOST_MULT(IYEAR) = 1.00
         ENDDO
       ENDDO

!      CALL SUBROUTINE TO READ WGEPARM INPUT
!      Including site bounds and capital cost multipliers
!
       CALL GET_HYDATA
!
!      Convert site input cost data to 1987$.  input dollar year defined in whydro input file currently 2002.
!
       DO I = 1 , WHYSITES
!
       SFOUND = 0
!
!      adjust variable o&m cost by public acceptance cost by site probability (??before or after dollar year conversion)??

         DO ISPR = 1 , NUM_SITEPROB
          IF (HYDSITE(I)%SITEPROB .EQ. SPROB(ISPR)) THEN
            SFOUND = 1
            HYDSITE(I)%VOM_COST = HYDSITE(I)%VOM_COST + PUBACPCST(ISPR)
          ENDIF
         ENDDO
         IF (SFOUND .EQ. 0) THEN
           write(6,*) ' warning no match for hydro site probability ',i,hydsite(i)%projnum,hydsite(i)%siteprob
         ENDIF
!
         HYDSITE(I)%LISCCOST = HYDSITE(I)%LISCCOST / MC_JPGDP(INPUT_DYEAR - BASEYR + 1)
         HYDSITE(I)%CONSCOST = HYDSITE(I)%CONSCOST / MC_JPGDP(INPUT_DYEAR - BASEYR + 1)
         HYDSITE(I)%DEVCOST = HYDSITE(I)%DEVCOST / MC_JPGDP(INPUT_DYEAR - BASEYR + 1)
         HYDSITE(I)%MIT_ARCH = HYDSITE(I)%MIT_ARCH / MC_JPGDP(INPUT_DYEAR - BASEYR + 1)
         HYDSITE(I)%MIT_FISH = HYDSITE(I)%MIT_FISH / MC_JPGDP(INPUT_DYEAR - BASEYR + 1)
         HYDSITE(I)%MIT_SCEN = HYDSITE(I)%MIT_SCEN / MC_JPGDP(INPUT_DYEAR - BASEYR + 1)
         HYDSITE(I)%MIT_WATER = HYDSITE(I)%MIT_WATER/ MC_JPGDP(INPUT_DYEAR - BASEYR + 1)
         HYDSITE(I)%MIT_PASS = HYDSITE(I)%MIT_PASS / MC_JPGDP(INPUT_DYEAR - BASEYR + 1)
         HYDSITE(I)%MIT_TOTAL = HYDSITE(I)%MIT_TOTAL/ MC_JPGDP(INPUT_DYEAR - BASEYR + 1)
         HYDSITE(I)%TOTDEV_COST = HYDSITE(I)%TOTDEV_COST / MC_JPGDP(INPUT_DYEAR - BASEYR + 1)
         HYDSITE(I)%UNITDEV_COST = HYDSITE(I)%UNITDEV_COST / MC_JPGDP(INPUT_DYEAR - BASEYR + 1)
         HYDSITE(I)%CAP_COST = HYDSITE(I)%CAP_COST / MC_JPGDP(INPUT_DYEAR - BASEYR + 1)
         HYDSITE(I)%TOTFOM_COST = HYDSITE(I)%TOTFOM_COST / MC_JPGDP(INPUT_DYEAR - BASEYR + 1)
         HYDSITE(I)%FOM_COST = HYDSITE(I)%FOM_COST / MC_JPGDP(INPUT_DYEAR - BASEYR + 1)
         HYDSITE(I)%TOTVOM_COST = HYDSITE(I)%TOTVOM_COST / MC_JPGDP(INPUT_DYEAR - BASEYR + 1)
         HYDSITE(I)%VOM_COST = HYDSITE(I)%VOM_COST / MC_JPGDP(INPUT_DYEAR - BASEYR + 1)
         HYDSITE(I)%FERC_COST = HYDSITE(I)%FERC_COST/ MC_JPGDP(INPUT_DYEAR - BASEYR + 1)
       ENDDO
!
!     ADJUST CAPITAL COSTS BY CAPITAL COST MULTIPLIER
!     MULTIPLIER = 1 FOR DEFAULT, ? FOR HIRENEW, ETC.
!
    DO I = 1, WHYSITES
          DO IYR = 1 , MNUMYR
        HYDSITE(I)%CAP_COST_ADJ(IYR) = HYDSITE(I)%CAP_COST * HYDSITE(I)%CAPCOST_MULT(IYR)
!           write(6,*) ' mult test ',iyr,i,hydsite(i)%cap_cost,hydsite(i)%capcost_mult(iyr),hydsite(i)%cap_cost_adj(iyr)
          ENDDO
        ENDDO

!    SUBTRACT 1990 CAPACITY FROM POTENTIAL CAPACITY
!      DO I = 1, NUM_SITES
!         EXCAP = HYDSITE(I)%PFILE_EXCAP
!         DO J = 1 , 4
!           IF (EXCAP .GT. 0.0) THEN
!             IF (EXCAP .GT. HYDSITE(I)%POTENTIAL_CAP(J)) THEN
!               EXCAP = EXCAP - HYDSITE(I)%POTENTIAL_CAP(J)
!               HYDSITE(I)%POTENTIAL_CAP(J) = 0.0
!             ELSE
!               HYDSITE(I)%POTENTIAL_CAP(J) = HYDSITE(I)%POTENTIAL_CAP(J) - EXCAP
!               EXCAP = 0.0
!             ENDIF
!           ENDIF
!         ENDDO
!         IF (EXCAP .NE. 0.0) THEN
!          WRITE(6,*) ' ** WARNING: EXISTING CAPACITY GREATER THEN POTENTIAL CAPACITY HYDRO SITE # ',&
!                       I
!     WRITE(IORNDUMP,*) ' ** WARNING: EXISTING CAPACITY GREATER THEN POTENTIAL CAPACITY HYDRO SITE # ',&
!                       I
!         ENDIF
!       ENDDO
! Recalculate COE with adjusted capcost and input cost data in 87$
        DO I = 1 , WHYSITES
        HYDSITE(I)%COE = ( (HYDSITE(I)%CAP_COST_ADJ(CURIYR) * &
                               FXD_CHRG_FACT(NERC) *  &
                               LEARN_FACT * OPT_FACT ) + &
                               HYDSITE(I)%FOM_COST) / &
                              (HYDSITE(I)%AVG_CAPACITY_FACTOR * &
                               8.760) + HYDSITE(I)%VOM_COST
        ENDDO

!   SORT INPUT DATASET BY NERC AND COE
    DO J = 1, (WHYSITES-1)
      DO I = (J+1), WHYSITES
        IF ( (DBLE(HYDSITE(J)%NERC) + DBLE(HYDSITE(J)%COE/10000.0)) .GT. &
             (DBLE(HYDSITE(I)%NERC) + DBLE(HYDSITE(I)%COE/10000.0)) ) THEN
               TEMP = HYDSITE(J)
               HYDSITE(J) = HYDSITE(I)
               HYDSITE(I) = TEMP
        ENDIF
      ENDDO
    ENDDO

    END SUBROUTINE GET_HYSITE_DATA

    !DSB********************************************************
    !DSB           END SUBROUTINE GET_HYSITE_DATA
    !DSB********************************************************


!DSB*************************************************************
!DSB*************************************************************
                                                               !*
       SUBROUTINE BUILD_HYD_CURVES
       IMPLICIT NONE                                           !*
                                                           !*
!DSB*************************************************************
!DSB*************************************************************

    !DSB*******************************
    !DSB BUILD_HYD_CURVES DECLARATIONS
    !DSB*******************************

    INTEGER I, IM, IYR, J, K, NERC, ID    !COUNTING VARIABLES
        REAL CUM_CAP             !CUMULATIVE CAPACITY AT EACH STEP (MW)
    LOGICAL MAX_FOUND        !SET WHEN THE SITE COE IS GREATER THAN
                             !OR EQUAL TO THE EMM THRESHOLD PRICE

        REAL SITE_COE            !TEMPORARY HOLDER FOR EACH SITE'S COE
    REAL STEP_QUAN           !TEMPORARY HOLDER FOR REGION'S CUMULATIVE
                             !CAPACITY (MW)
        REAL SITE_CAP_COST       !TEMPORARY HOLDER FOR EACH SITE'S CAPITAL COST
        REAL SITE_FOM_COST       !TEMPORARY HOLDER FOR EACH SITE'S FIXED O&M COST
        REAL SITE_VOM_COST       !TEMPORARY HOLDER FOR EACH SITE'S VARIABLE O&M COST
        REAL SITE_HEAT_RATE      !TEMPORARY HOLDER FOR EACH SITE'S HEAT RATE
        REAL SITE_CAP_FAC        !TEMPORARY HOLDER FOR EACH SITE'S CAPACITY FACTOR
        REAL SITE_MON_CAP_FAC(12) !TEMPORARY HOLDER FOR EACH SITE'S MONTHLY CAPACITY FACTORS
        REAL SITE_CO2_RATE       !TEMPORARY HOLDER FOR EACH SITE'S CO2 EMISSION RATE

        LOGICAL MIN_CAP_FOUND   !CONVENIENCE VARIABLES USED TO
    REAL TOTAL_PRICE        !CALCULATE THE WEIGHTED AVERAGE
    REAL TOTAL_CAP          !PRICE AND QUANTITY FOR EACH SUPPLY
    REAL TOTAL_FOM          !STEP
    REAL TOTAL_VOM          !STEP
    REAL TOTAL_HRATE        !
    REAL TOTAL_CAPFAC       !
    REAL TOTAL_MONCAPFAC(12)   !
    REAL TOTAL_CO2RATE      !
    REAL TOTAL_QUAN         !
    REAL TOT_HRATE        ! VARIABLES USED TO CALCULATE REGIONAL
    REAL TOT_CAPFAC       ! WEIGHTED AVERAGE HEAT RATES,
    REAL TOT_MONCAPFAC(12) ! WEIGHTED AVERAGE HEAT RATES,
    REAL TOT_CO2RATE      ! CO2 EMISSION RATES, AND CAPACITY
    REAL TOT_QUAN         ! FACTORS

    REAL CUMSUP(WHYSITES)
    REAL BOUND(WHYSITES)
    REAL BND(WHYSITES)

    !DSB********************************************************
    !DSB           START SUBROUTINE BUILD_HYD_CURVES
    !DSB********************************************************

    NUM_SITES = 0

    !CALCULATE COE FOR POTENTIAL CAPACITY
     DO I = 1, WHYSITES
 
!            IF ((HYDSITE(I)%POTENTIAL_CAP .GT. 0.0) .AND. (HYDSITE(I)%SITEPROB .GE. HYPROB_LIMIT)) THEN
             IF ( HYDSITE(I)%POTENTIAL_CAP .GT. 0.0 )  THEN

           NUM_SITES = NUM_SITES + 1
           HYDCRV(NUM_SITES)%MODEL_YEAR = CURIYR + 1989
           HYDCRV(NUM_SITES)%SITE_ID = HYDSITE(I)%SITE_ID
           HYDCRV(NUM_SITES)%PROJNUM  = HYDSITE(I)%PROJNUM
           HYDCRV(NUM_SITES)%PROJNAME = HYDSITE(I)%PROJNAME
           HYDCRV(NUM_SITES)%STATE = HYDSITE(I)%STATE
           HYDCRV(NUM_SITES)%NERC = HYDSITE(I)%NERC
           HYDCRV(NUM_SITES)%UNITTYPE = HYDSITE(I)%UNITTYPE
               HYDCRV(NUM_SITES)%AVAIL_SUPPLY = HYDSITE(I)%POTENTIAL_CAP
               HYDCRV(NUM_SITES)%CAP_COST = HYDSITE(I)%CAP_COST
               HYDCRV(NUM_SITES)%FOM_COST  = HYDSITE(I)%FOM_COST
               HYDCRV(NUM_SITES)%VOM_COST  = HYDSITE(I)%VOM_COST
               HYDCRV(NUM_SITES)%HEAT_RATE = HYDSITE(I)%HEAT_RATE
               HYDCRV(NUM_SITES)%CAP_FAC   = HYDSITE(I)%AVG_CAPACITY_FACTOR
               HYDCRV(NUM_SITES)%MON_CAP_FAC(:)   = HYDSITE(I)%MON_CAPACITY_FACTOR(:)
               HYDCRV(NUM_SITES)%CO2_RATE  = HYDSITE(I)%CO2_RATE
!
               ! CALCULATE COE FOR EACH SITE
!
           NERC = HYDCRV(NUM_SITES)%NERC
                 HYDCRV(NUM_SITES)%CAP_COST = HYDSITE(I)%CAP_COST_ADJ(CURIYR)
! have to add variable o&m to these calculations (done correctly??).
! remove adj below?? check calculations
             HYDCRV(NUM_SITES)%COE = ((HYDSITE(I)%CAP_COST_ADJ(CURIYR) * &
                             FXD_CHRG_FACT(NERC)   * &
                                         LEARN_FACT * OPT_FACT ) + &
                             (HYDSITE(I)%FOM_COST)) / &
                             (HYDSITE(I)%AVG_CAPACITY_FACTOR * &
                             8.760) + HYDSITE(I)%VOM_COST
             ENDIF
         ENDDO

    !SORT DATASET BY NERC AND COE
         DO J = 1, (NUM_SITES-1)
           DO I = (J+1), NUM_SITES
             IF ( (DBLE(HYDCRV(J)%NERC) + DBLE(HYDCRV(J)%COE/10000.0)) .GT. &
                  (DBLE(HYDCRV(I)%NERC) + DBLE(HYDCRV(I)%COE/10000.0)) ) THEN
               TEMP2 = HYDCRV(J)
               HYDCRV(J) = HYDCRV(I)
               HYDCRV(I) = TEMP2
             ENDIF
       ENDDO
     ENDDO

!   !GET NEW UNPLANNED CAPACITY FOR HYDRO
!   DO NERC = 1, UNRGNS
!      UNPLAN_HY(NERC) = 0.0
!      DO I = 1, CURIYR + UPPLYR(HYD_ECP_TYPE)
!        UNPLAN_HY(NERC) = UNPLAN_HY(NERC) + UADDHYD(NERC,I)
!      ENDDO
!      HYD_ADD(NERC) = UNPLAN_HY(NERC)  !SAVE FOR DEBUG PRINTOUT
!   ENDDO  !LOOP OVER NERC REGIONS
!
!     REMOVE UNPLANNED CAPACITY FROM POTENTIAL CAPACITY
!
      IF (CURIYR .GE. FIRSYR+UPPLYR(HYD_ECP_TYPE)+1) THEN
        DO IYR = (FIRSYR+UPPLYR(HYD_ECP_TYPE)+1), CURIYR+UPPLYR(HYD_ECP_TYPE)
!
!      ENFORCE HYDRO ANNUAL SITE BOUND WHEN SUBTRACTING CAPACITY
!      using site bound from decision year - 1 because renew runs after emm
!
          DO I = 1, WHYSITES
            BOUND(I) = HYDSITE(I)%SITE_BOUND(IYR-UPPLYR(HYD_ECP_TYPE)-1)
          ENDDO
          CUMSUP = 0.0
          BND = BOUND
!
          DO I = 1, NUM_SITES
            ID = HYDCRV(I)%SITE_ID
            CUMSUP(ID) = CUMSUP(ID) + HYDCRV(I)%AVAIL_SUPPLY
            IF ( CUMSUP(ID) .GE. BOUND(ID) ) THEN
              HYDCRV(I)%AVAIL_SUPPLY_BOUND = MIN(HYDCRV(I)%AVAIL_SUPPLY,BND(ID))
              BND(ID) = 0.0
            ELSEIF ( CUMSUP(ID) .LT. BOUND(ID) ) THEN
              HYDCRV(I)%AVAIL_SUPPLY_BOUND = MIN(HYDCRV(I)%AVAIL_SUPPLY,BND(ID))
              BND(ID) = BND(ID) - HYDCRV(I)%AVAIL_SUPPLY_BOUND
            ENDIF
          ENDDO
!
!       REMOVE UNPLANNED CAPACITY FROM POTENTIAL CAPACITY
!
      DO NERC = 1, UNRGNS
            UNPLAN_HY(NERC) = UADDHYD(NERC,IYR)
            HYD_ADD(NERC) = UNPLAN_HY(NERC)  !SAVE FOR DEBUG PRINTOUT
!          write(6,*) ' unplanned geoadd ',nerc,unplan_gt(nerc),geo_add(nerc)
      ENDDO
      DO I = 1, NUM_SITES
            NERC = HYDCRV(I)%NERC
            IF (NERC .GE. 1 .AND. NERC .LE. UNRGNS) THEN
              IF (UNPLAN_HY(NERC) .GT. 0.0) THEN
                IF (UNPLAN_HY(NERC) .GT. HYDCRV(I)%AVAIL_SUPPLY_BOUND) THEN
                   UNPLAN_HY(NERC) = UNPLAN_HY(NERC) - HYDCRV(I)%AVAIL_SUPPLY_BOUND
                   HYDCRV(I)%AVAIL_SUPPLY = HYDCRV(I)%AVAIL_SUPPLY - HYDCRV(I)%AVAIL_SUPPLY_BOUND
                ELSE
                   HYDCRV(I)%AVAIL_SUPPLY = HYDCRV(I)%AVAIL_SUPPLY - UNPLAN_HY(NERC)
                   UNPLAN_HY(NERC) = 0.0
                ENDIF
              ENDIF
            ENDIF
          ENDDO
!
        ENDDO
      ENDIF
!
!     Limit available supply from each site to the site build bound for current year
!
      DO I = 1, WHYSITES
        BOUND(I) = HYDSITE(I)%SITE_BOUND(CURIYR)
      ENDDO
      CUMSUP = 0.0
      BND = BOUND
!
      DO I = 1, NUM_SITES
        ID = HYDCRV(I)%SITE_ID
        CUMSUP(ID) = CUMSUP(ID) + HYDCRV(I)%AVAIL_SUPPLY
        IF ( CUMSUP(ID) .GE. BOUND(ID) ) THEN
          HYDCRV(I)%AVAIL_SUPPLY_BOUND = MIN(HYDCRV(I)%AVAIL_SUPPLY,BND(ID))
          BND(ID) = 0.0
        ELSEIF ( CUMSUP(ID) .LT. BOUND(ID) ) THEN
          HYDCRV(I)%AVAIL_SUPPLY_BOUND = MIN(HYDCRV(I)%AVAIL_SUPPLY,BND(ID))
          BND(ID) = BND(ID) - HYDCRV(I)%AVAIL_SUPPLY_BOUND
        ENDIF
      ENDDO
!
    !CALCULATE CUMULATIVE CAPACITY AT EACH STEP
    HYDCRV(1)%CUM_SUPPLY  = &
                           HYDCRV(1)%AVAIL_SUPPLY_BOUND
    CUM_CAP  = HYDCRV(1)%AVAIL_SUPPLY_BOUND
    DO I = 2, NUM_SITES
       IF (HYDCRV(I)%NERC .NE. HYDCRV(I-1)%NERC) THEN
          CUM_CAP = 0.0
       ENDIF
       CUM_CAP = CUM_CAP + &
                  HYDCRV(I)%AVAIL_SUPPLY_BOUND
       HYDCRV(I)%CUM_SUPPLY  = CUM_CAP
    ENDDO


    !TRANSFER CURVE DATA TO TEMP STRUCTURE AND READ DATA FROM TEMP STRUCTURE
    !BACK TO CURVE DATA STRUCTURE IF AVAILABLE CAPACITY IS GREATER THAN ZERO.
    NUM_NZERO_SITES = 0
        DO I = 1, NUM_SITES
          IF   (HYDCRV(I)%CUM_SUPPLY .GT. 0.0) THEN
!             (HYDCRV(I)%AVAIL_SUPPLY_BOUND .GT. 0.0) ) THEN
            NUM_NZERO_SITES = NUM_NZERO_SITES + 1
            TMPCRV(NUM_NZERO_SITES) = HYDCRV(I)
          ENDIF
    ENDDO
        DO I = 1, NUM_NZERO_SITES
          HYDCRV(I) = TMPCRV(I)
    ENDDO

    !****************************************************
     IF (NUM_NZERO_SITES .GT. 0) THEN
    !****************************************************

    !SET ALL CRV_INFO DATA TO ZERO. IF DATA NOT CHANGED BY
    !SUBSEQUENT BLOCKS OF CODE, THEN THE REGION HAS NO AVAILABLE
    !CAPACITY

    DO NERC = 1, unrgns
     CRV_INFO(NERC)%MIN_COE = 0.0
     CRV_INFO(NERC)%MAX_COE = 0.0
     DO I = 1, 3
       CRV_INFO(NERC)%SEGMENTS(I)      = 0.0
       CRV_INFO(NERC)%STEP_PRICE(I)    = 0.0
       CRV_INFO(NERC)%STEP_QUAN(I)     = 0.0
       CRV_INFO(NERC)%STEP_CAP_COST(I) = 0.0
       CRV_INFO(NERC)%STEP_VOM_COST(I)  = 0.0
       CRV_INFO(NERC)%STEP_FOM_COST(I)  = 0.0
       CRV_INFO(NERC)%STEP_HEAT_RATE(I)  = 0.0
       CRV_INFO(NERC)%STEP_CAP_FAC(I)  = 0.0
       CRV_INFO(NERC)%STEP_MON_CAP_FAC(I,:)  = 0.0
       CRV_INFO(NERC)%STEP_CO2_RATE(I)  = 0.0
     ENDDO
    ENDDO


    !FIND MAXIMUM COE FOR EACH REGION THAT IS CLOSEST TO THE EMM SIGNAL
    ! PRICE PASSED BY THE ECP SUPPLY CURVE WILL CONSIST OF THOSE SITES
    ! AT OR BELOW THIS SIGNAL PRICE
    MAX_FOUND = .FALSE.
    NERC = HYDCRV(1)%NERC
    CRV_INFO(NERC)%MIN_COE = HYDCRV(1)%COE
     DO I = 2, NUM_NZERO_SITES
      IF (HYDCRV(I)%COE .GT. EMM_SIGNAL(NERC)) THEN
        IF (.NOT. MAX_FOUND) THEN
           CRV_INFO(NERC)%MAX_COE = HYDCRV((I-1))%COE
           MAX_FOUND = .TRUE.
            ENDIF
      ENDIF
      IF (HYDCRV(I)%NERC .NE. HYDCRV((I-1))%NERC) THEN
        IF (.NOT. MAX_FOUND) THEN
               CRV_INFO(NERC)%MAX_COE = HYDCRV((I-1))%COE
        ENDIF
            NERC = HYDCRV(I)%NERC
            CRV_INFO(NERC)%MIN_COE = HYDCRV(I)%COE
            MAX_FOUND = .FALSE.
      ENDIF
      IF (I .EQ. NUM_NZERO_SITES) THEN
        IF (.NOT. MAX_FOUND) THEN
           CRV_INFO(NERC)%MAX_COE = HYDCRV(I)%COE
        ENDIF
      ENDIF
     ENDDO

    !CALCULATE THE SEGMENT VALUES THAT LIE BETWEEN THE MAX AND MIN COE
    DO I = 1, (unrgns)
      DO J = 1, 3
             CRV_INFO(I)%SEGMENTS(J) = CRV_INFO(I)%MIN_COE + &
                (CRV_INFO(I)%MAX_COE - CRV_INFO(I)%MIN_COE) * WHYPRICE_SEG(J)
      ENDDO
    ENDDO

    !*******************************************************
    !BEGIN -- CALCULATE CUMULATIVE SYSTEM COSTS
    !*******************************************************

    !CALCULATE CUMULATIVE SYSTEM COSTS BY MULTIPLYING THE SITE COE BY THE SITE CAPACITY.
    !THESE COSTS WILL BE USED TO CALCULATE THE WEIGHTED AVERAGE COE FOR ALL SITES IN
    !EACH OF THE THREE PRICE SEGMENTS
    DO J = 1, NUM_NZERO_SITES                  !LOOP THROUGH SITES
      NERC = HYDCRV(J)%NERC
      SITE_COE = HYDCRV(J)%COE
      STEP_QUAN = HYDCRV(J)%AVAIL_SUPPLY_BOUND
      SITE_CAP_COST = HYDCRV(J)%CAP_COST
      SITE_VOM_COST = HYDCRV(J)%VOM_COST
      SITE_FOM_COST = HYDCRV(J)%FOM_COST
      SITE_HEAT_RATE = HYDCRV(J)%HEAT_RATE
      SITE_CAP_FAC = HYDCRV(J)%CAP_FAC
      SITE_MON_CAP_FAC(:) = HYDCRV(J)%MON_CAP_FAC(:)
      SITE_CO2_RATE  = HYDCRV(J)%CO2_RATE
      IF (J .EQ. 1) THEN !PROCESS FIRST SITE
       DO K = 1, 3                                !LOOP OVER STEPS
         IF ((EMM_SIGNAL(NERC) .LT. CRV_INFO(NERC)%SEGMENTS(K)) .OR. &
             (CRV_INFO(NERC)%SEGMENTS(K) .LT. SITE_COE)) THEN
             !SITE COE BELOW SIGNAL PRICE
             HYDCRV(J)%SYS_COST(K) = 0.0
             HYDCRV(J)%SYS_CAP_COST(K) = 0.0
             HYDCRV(J)%SYS_VOM_COST(K) = 0.0
             HYDCRV(J)%SYS_FOM_COST(K) = 0.0
             HYDCRV(J)%SYS_HEAT_RATE(K) = 0.0
             HYDCRV(J)%SYS_CAP_FAC(K) = 0.0
             HYDCRV(J)%SYS_MON_CAP_FAC(K,:) = 0.0
             HYDCRV(J)%SYS_CO2_RATE(K) = 0.0
         ELSEIF (K .EQ. 1) THEN
             !PROCESS FIRST STEP
             HYDCRV(J)%SYS_COST(1) = SITE_COE * STEP_QUAN
             HYDCRV(J)%SYS_CAP_COST(1) = SITE_CAP_COST * STEP_QUAN
             HYDCRV(J)%SYS_VOM_COST(1) = SITE_VOM_COST * STEP_QUAN
             HYDCRV(J)%SYS_FOM_COST(1) = SITE_FOM_COST * STEP_QUAN
             HYDCRV(J)%SYS_HEAT_RATE(1) = SITE_HEAT_RATE * STEP_QUAN
             HYDCRV(J)%SYS_CAP_FAC(1) = SITE_CAP_FAC * STEP_QUAN
             HYDCRV(J)%SYS_MON_CAP_FAC(1,:) = SITE_MON_CAP_FAC(:) * STEP_QUAN
             HYDCRV(J)%SYS_CO2_RATE(1) = SITE_CO2_RATE * STEP_QUAN
         ELSEIF (K .EQ. 2) THEN
             !PROCESS SECOND STEP
             IF (HYDCRV(J)%SYS_COST(1) .GT. 0.0) THEN
                 HYDCRV(J)%SYS_COST(2)  = 0.0
                 HYDCRV(J)%SYS_CAP_COST(2)  = 0.0
                 HYDCRV(J)%SYS_VOM_COST(2)  = 0.0
                 HYDCRV(J)%SYS_FOM_COST(2)  = 0.0
                 HYDCRV(J)%SYS_HEAT_RATE(2) = 0.0
                 HYDCRV(J)%SYS_CAP_FAC(2) = 0.0
                 HYDCRV(J)%SYS_MON_CAP_FAC(2,:) = 0.0
                 HYDCRV(J)%SYS_CO2_RATE(2) = 0.0
             ELSE
                 HYDCRV(J)%SYS_COST(2) = SITE_COE * STEP_QUAN
                 HYDCRV(J)%SYS_CAP_COST(2) = SITE_CAP_COST * STEP_QUAN
                             HYDCRV(J)%SYS_VOM_COST(2) = SITE_VOM_COST * STEP_QUAN
                             HYDCRV(J)%SYS_FOM_COST(2) = SITE_FOM_COST * STEP_QUAN
                 HYDCRV(J)%SYS_HEAT_RATE(2) = SITE_HEAT_RATE * STEP_QUAN
                 HYDCRV(J)%SYS_CAP_FAC(2) = SITE_CAP_FAC * STEP_QUAN
                 HYDCRV(J)%SYS_MON_CAP_FAC(2,:) = SITE_MON_CAP_FAC(:) * STEP_QUAN
                 HYDCRV(J)%SYS_CO2_RATE(2) = SITE_CO2_RATE * STEP_QUAN
             ENDIF
         ELSEIF (K .EQ. 3) THEN
             !PROCESS THIRD STEP
             IF ( (HYDCRV(J)%SYS_COST(1) .GT. 0.0) .AND. &
                  (HYDCRV(J)%SYS_COST(2) .GT. 0.0) )THEN
                 HYDCRV(J)%SYS_COST(3) = SITE_COE * STEP_QUAN
                 HYDCRV(J)%SYS_CAP_COST(3) = SITE_CAP_COST * STEP_QUAN
                             HYDCRV(J)%SYS_VOM_COST(3) = SITE_VOM_COST * STEP_QUAN
                             HYDCRV(J)%SYS_FOM_COST(3) = SITE_FOM_COST * STEP_QUAN
                             HYDCRV(J)%SYS_HEAT_RATE(3) = SITE_HEAT_RATE * STEP_QUAN
                 HYDCRV(J)%SYS_CAP_FAC(3) = SITE_CAP_FAC * STEP_QUAN
                 HYDCRV(J)%SYS_MON_CAP_FAC(3,:) = SITE_MON_CAP_FAC(:) * STEP_QUAN
                 HYDCRV(J)%SYS_CO2_RATE(3) = SITE_CO2_RATE * STEP_QUAN
             ELSE
                 HYDCRV(J)%SYS_COST(3) = 0.0
                 HYDCRV(J)%SYS_CAP_COST(3) = 0.0
                 HYDCRV(J)%SYS_VOM_COST(3) = 0.0
                 HYDCRV(J)%SYS_FOM_COST(3) = 0.0
                 HYDCRV(J)%SYS_HEAT_RATE(3) = 0.0
                 HYDCRV(J)%SYS_CAP_FAC(3) = 0.0
                 HYDCRV(J)%SYS_MON_CAP_FAC(3,:) = 0.0
                 HYDCRV(J)%SYS_CO2_RATE(3) = 0.0
             ENDIF
         ENDIF
       ENDDO                                      !LOOP OVER STEPS
      ELSEIF (NERC .NE. HYDCRV(J-1)%NERC) THEN
      !REGION CHANGE
       DO K = 1, 3                                !LOOP OVER STEPS
         IF ((EMM_SIGNAL(NERC) .LT. CRV_INFO(NERC)%SEGMENTS(K)) .OR. &
             (CRV_INFO(NERC)%SEGMENTS(K) .LT. SITE_COE)) THEN
             !SITE COE BELOW SIGNAL PRICE
             HYDCRV(J)%SYS_COST(K) = 0.0
             HYDCRV(J)%SYS_CAP_COST(K) = 0.0
             HYDCRV(J)%SYS_VOM_COST(K) = 0.0
             HYDCRV(J)%SYS_FOM_COST(K) = 0.0
             HYDCRV(J)%SYS_HEAT_RATE(K) = 0.0
             HYDCRV(J)%SYS_CAP_FAC(K) = 0.0
             HYDCRV(J)%SYS_MON_CAP_FAC(K,:) = 0.0
             HYDCRV(J)%SYS_CO2_RATE(K) = 0.0
         ELSEIF (K .EQ. 1) THEN
             !PROCESS FIRST STEP
                 HYDCRV(J)%SYS_COST(1) = SITE_COE * STEP_QUAN
                 HYDCRV(J)%SYS_CAP_COST(1) = SITE_CAP_COST * STEP_QUAN
                             HYDCRV(J)%SYS_VOM_COST(1) = SITE_VOM_COST * STEP_QUAN
                             HYDCRV(J)%SYS_FOM_COST(1) = SITE_FOM_COST * STEP_QUAN
                             HYDCRV(J)%SYS_HEAT_RATE(1) = SITE_HEAT_RATE * STEP_QUAN
                 HYDCRV(J)%SYS_CAP_FAC(1) = SITE_CAP_FAC * STEP_QUAN
                 HYDCRV(J)%SYS_MON_CAP_FAC(1,:) = SITE_MON_CAP_FAC(:) * STEP_QUAN
                 HYDCRV(J)%SYS_CO2_RATE(1) = SITE_CO2_RATE * STEP_QUAN
         ELSEIF (K .EQ. 2) THEN
             !PROCESS SECOND STEP
             IF (HYDCRV(J)%SYS_COST(1) .GT. 0.0) THEN
                 HYDCRV(J)%SYS_COST(2)  = 0.0
                 HYDCRV(J)%SYS_CAP_COST(2) = 0.0
                 HYDCRV(J)%SYS_VOM_COST(2) = 0.0
                 HYDCRV(J)%SYS_FOM_COST(2) = 0.0
                 HYDCRV(J)%SYS_HEAT_RATE(2) = 0.0
                 HYDCRV(J)%SYS_CAP_FAC(2) = 0.0
                 HYDCRV(J)%SYS_MON_CAP_FAC(2,:) = 0.0
                 HYDCRV(J)%SYS_CO2_RATE(2) = 0.0
             ELSE
                 HYDCRV(J)%SYS_COST(2) = SITE_COE * STEP_QUAN
                 HYDCRV(J)%SYS_CAP_COST(2) = SITE_CAP_COST * STEP_QUAN
                             HYDCRV(J)%SYS_VOM_COST(2) = SITE_VOM_COST * STEP_QUAN
                             HYDCRV(J)%SYS_FOM_COST(2) = SITE_FOM_COST * STEP_QUAN
                             HYDCRV(J)%SYS_HEAT_RATE(2) = SITE_HEAT_RATE * STEP_QUAN
                 HYDCRV(J)%SYS_CAP_FAC(2) = SITE_CAP_FAC * STEP_QUAN
                 HYDCRV(J)%SYS_MON_CAP_FAC(2,:) = SITE_MON_CAP_FAC(:) * STEP_QUAN
                 HYDCRV(J)%SYS_CO2_RATE(2) = SITE_CO2_RATE * STEP_QUAN
             ENDIF
         ELSEIF (K .EQ. 3) THEN
             !PROCESS THIRD STEP
             IF ( (HYDCRV(J)%SYS_COST(1) .GT. 0.0) .AND. &
                  (HYDCRV(J)%SYS_COST(2) .GT. 0.0) )THEN
                 HYDCRV(J)%SYS_COST(3) = SITE_COE * STEP_QUAN
                 HYDCRV(J)%SYS_CAP_COST(3) = SITE_CAP_COST * STEP_QUAN
                             HYDCRV(J)%SYS_VOM_COST(3) = SITE_VOM_COST * STEP_QUAN
                             HYDCRV(J)%SYS_FOM_COST(3) = SITE_FOM_COST * STEP_QUAN
                             HYDCRV(J)%SYS_HEAT_RATE(3) = SITE_HEAT_RATE * STEP_QUAN
                 HYDCRV(J)%SYS_CAP_FAC(3) = SITE_CAP_FAC * STEP_QUAN
                 HYDCRV(J)%SYS_MON_CAP_FAC(3,:) = SITE_MON_CAP_FAC(:) * STEP_QUAN
                 HYDCRV(J)%SYS_CO2_RATE(3) = SITE_CO2_RATE * STEP_QUAN
             ELSE
                 HYDCRV(J)%SYS_COST(3)  = 0.0
                 HYDCRV(J)%SYS_CAP_COST(3) = 0.0
                 HYDCRV(J)%SYS_VOM_COST(3) = 0.0
                 HYDCRV(J)%SYS_FOM_COST(3) = 0.0
                 HYDCRV(J)%SYS_HEAT_RATE(3) = 0.0
                 HYDCRV(J)%SYS_CAP_FAC(3) = 0.0
                 HYDCRV(J)%SYS_MON_CAP_FAC(3,:) = 0.0
                 HYDCRV(J)%SYS_CO2_RATE(3) = 0.0
             ENDIF
         ENDIF
       ENDDO                                      !LOOP OVER STEPS
      ELSE
       DO K = 1, 3                                !LOOP OVER STEPS
         IF ((EMM_SIGNAL(NERC) .LT. CRV_INFO(NERC)%SEGMENTS(K)) .OR. &
             (CRV_INFO(NERC)%SEGMENTS(K) .LT. SITE_COE)) THEN
             !SITE COE BELOW SIGNAL PRICE
             HYDCRV(J)%SYS_COST(K) = 0.0
             HYDCRV(J)%SYS_CAP_COST(K) = 0.0
             HYDCRV(J)%SYS_VOM_COST(K) = 0.0
             HYDCRV(J)%SYS_FOM_COST(K) = 0.0
             HYDCRV(J)%SYS_HEAT_RATE(K) = 0.0
             HYDCRV(J)%SYS_CAP_FAC(K) = 0.0
             HYDCRV(J)%SYS_MON_CAP_FAC(K,:) = 0.0
             HYDCRV(J)%SYS_CO2_RATE(K) = 0.0
         ELSEIF (K .EQ. 1) THEN
             !PROCESS FIRST STEP
             HYDCRV(J)%SYS_COST(1) = SITE_COE * STEP_QUAN + &
                                  HYDCRV(J-1)%SYS_COST(1)
             HYDCRV(J)%SYS_CAP_COST(1) = SITE_CAP_COST * STEP_QUAN + &
                                  HYDCRV(J-1)%SYS_CAP_COST(1)
             HYDCRV(J)%SYS_VOM_COST(1) = SITE_VOM_COST * STEP_QUAN + &
                                  HYDCRV(J-1)%SYS_VOM_COST(1)
             HYDCRV(J)%SYS_FOM_COST(1) = SITE_FOM_COST * STEP_QUAN + &
                                  HYDCRV(J-1)%SYS_FOM_COST(1)
             HYDCRV(J)%SYS_HEAT_RATE(1) = SITE_HEAT_RATE * STEP_QUAN + &
                                  HYDCRV(J-1)%SYS_HEAT_RATE(1)
             HYDCRV(J)%SYS_CAP_FAC(1) = SITE_CAP_FAC * STEP_QUAN + &
                                  HYDCRV(J-1)%SYS_CAP_FAC(1)
             HYDCRV(J)%SYS_MON_CAP_FAC(1,:) = SITE_MON_CAP_FAC(:) * STEP_QUAN + &
                                  HYDCRV(J-1)%SYS_MON_CAP_FAC(1,:)
             HYDCRV(J)%SYS_CO2_RATE(1) = SITE_CO2_RATE  * STEP_QUAN + &
                                  HYDCRV(J-1)%SYS_CO2_RATE(1)
         ELSEIF (K .EQ. 2) THEN
             !PROCESS SECOND STEP
             IF (HYDCRV(J)%SYS_COST(1) .GT. 0.0) THEN
                 HYDCRV(J)%SYS_COST(2)  = 0.0
                             HYDCRV(J)%SYS_CAP_COST(2)  = 0.0
                             HYDCRV(J)%SYS_VOM_COST(2)  = 0.0
                             HYDCRV(J)%SYS_FOM_COST(2)  = 0.0
                 HYDCRV(J)%SYS_HEAT_RATE(2) = 0.0
                 HYDCRV(J)%SYS_CAP_FAC(2) = 0.0
                 HYDCRV(J)%SYS_MON_CAP_FAC(2,:) = 0.0
                 HYDCRV(J)%SYS_CO2_RATE(2) = 0.0
             ELSE
                 HYDCRV(J)%SYS_COST(2) = SITE_COE * STEP_QUAN &
                                     + HYDCRV(J-1)%SYS_COST(2)
                 HYDCRV(J)%SYS_CAP_COST(2) = SITE_CAP_COST * STEP_QUAN &
                                     + HYDCRV(J-1)%SYS_CAP_COST(2)
                 HYDCRV(J)%SYS_VOM_COST(2) = SITE_VOM_COST * STEP_QUAN &
                                     + HYDCRV(J-1)%SYS_VOM_COST(2)
                 HYDCRV(J)%SYS_FOM_COST(2) = SITE_FOM_COST * STEP_QUAN &
                                     + HYDCRV(J-1)%SYS_FOM_COST(2)
                 HYDCRV(J)%SYS_HEAT_RATE(2) = SITE_HEAT_RATE * STEP_QUAN + &
                                           HYDCRV(J-1)%SYS_HEAT_RATE(2)
                 HYDCRV(J)%SYS_CAP_FAC(2) = SITE_CAP_FAC * STEP_QUAN + &
                                           HYDCRV(J-1)%SYS_CAP_FAC(2)
                 HYDCRV(J)%SYS_MON_CAP_FAC(2,:) = SITE_MON_CAP_FAC(:) * STEP_QUAN + &
                                           HYDCRV(J-1)%SYS_MON_CAP_FAC(2,:)
                 HYDCRV(J)%SYS_CO2_RATE(2) = SITE_CO2_RATE  * STEP_QUAN + &
                                           HYDCRV(J-1)%SYS_CO2_RATE(2)
             ENDIF
         ELSEIF (K .EQ. 3) THEN
             !PROCESS THIRD STEP
             IF ( (HYDCRV(J)%SYS_COST(1) .EQ. 0.0) .AND. &
                  (HYDCRV(J)%SYS_COST(2) .EQ. 0.0) )THEN
                 HYDCRV(J)%SYS_COST(3)  = SITE_COE * STEP_QUAN &
                                     + HYDCRV(J-1)%SYS_COST(3)
                 HYDCRV(J)%SYS_CAP_COST(3)  = SITE_CAP_COST * STEP_QUAN &
                                     + HYDCRV(J-1)%SYS_CAP_COST(3)
                 HYDCRV(J)%SYS_VOM_COST(3)  = SITE_VOM_COST * STEP_QUAN &
                                     + HYDCRV(J-1)%SYS_VOM_COST(3)
                 HYDCRV(J)%SYS_FOM_COST(3)  = SITE_FOM_COST * STEP_QUAN &
                                     + HYDCRV(J-1)%SYS_FOM_COST(3)
                 HYDCRV(J)%SYS_HEAT_RATE(3) = SITE_HEAT_RATE * STEP_QUAN + &
                                           HYDCRV(J-1)%SYS_HEAT_RATE(3)
                 HYDCRV(J)%SYS_CAP_FAC(3) = SITE_CAP_FAC * STEP_QUAN + &
                                           HYDCRV(J-1)%SYS_CAP_FAC(3)
                 HYDCRV(J)%SYS_MON_CAP_FAC(3,:) = SITE_MON_CAP_FAC(:) * STEP_QUAN + &
                                           HYDCRV(J-1)%SYS_MON_CAP_FAC(3,:)
                 HYDCRV(J)%SYS_CO2_RATE(3) = SITE_CO2_RATE  * STEP_QUAN + &
                                           HYDCRV(J-1)%SYS_CO2_RATE(3)
             ELSE
                 HYDCRV(J)%SYS_COST(3) = 0.0
                 HYDCRV(J)%SYS_CAP_COST(3) = 0.0
                     HYDCRV(J)%SYS_VOM_COST(3) = 0.0
                     HYDCRV(J)%SYS_FOM_COST(3) = 0.0
                 HYDCRV(J)%SYS_HEAT_RATE(3) = 0.0
                 HYDCRV(J)%SYS_CAP_FAC(3) = 0.0
                 HYDCRV(J)%SYS_MON_CAP_FAC(3,:) = 0.0
                 HYDCRV(J)%SYS_CO2_RATE(3) = 0.0
             ENDIF
         ENDIF
       ENDDO                                      !LOOP OVER STEPS
      ENDIF
      IF  ( (PASSES .EQ. MAXPASSES) .AND. (SITE_COE .EQ. CRV_INFO(NERC)%MIN_COE) &
          .AND. (HYDCRV(J)%SYS_COST(1) .EQ. 0) ) THEN
        HYDCRV(J)%SYS_COST(1) = SITE_COE * STEP_QUAN
        HYDCRV(J)%SYS_CAP_COST(1) = SITE_CAP_COST * STEP_QUAN
        HYDCRV(J)%SYS_VOM_COST(1) = SITE_VOM_COST * STEP_QUAN
        HYDCRV(J)%SYS_FOM_COST(1) = SITE_FOM_COST * STEP_QUAN
        HYDCRV(J)%SYS_HEAT_RATE(1) = SITE_HEAT_RATE * STEP_QUAN
        HYDCRV(J)%SYS_CAP_FAC(1) = SITE_CAP_FAC * STEP_QUAN
        HYDCRV(J)%SYS_MON_CAP_FAC(1,:) = SITE_MON_CAP_FAC(:) * STEP_QUAN
        HYDCRV(J)%SYS_CO2_RATE(1) = SITE_CO2_RATE * STEP_QUAN
      ENDIF
     ENDDO                                       !LOOP THROUGH SITES

    !*******************************************************
    !END -- CALCULATE CUMULATIVE SYSTEM COSTS
    !*******************************************************


    !*******************************************************
    !BEGIN -- CALCULATE WEIGHTED PRICE AND QUANTITY
    !*******************************************************

    !USING THE CUMULATIVE SYSTEM COST CALCULATED ABOVE,
    !CALCULATE THE PRICE AND QUANTITY FOR EACH STEP
    DO K = 1, 3                       !LOOP OVER STEPS
     TOTAL_QUAN = 0.0
     TOTAL_PRICE = 0.0
     TOTAL_CAP = 0.0
     TOTAL_VOM = 0.0
     TOTAL_FOM = 0.0
     TOTAL_HRATE = 0.0
     TOTAL_CAPFAC = 0.0
     TOTAL_MONCAPFAC(:) = 0.0
     TOTAL_CO2RATE = 0.0
     MIN_CAP_FOUND = .FALSE.
     DO J = 1, NUM_NZERO_SITES        !LOOP OVER SITES
        NERC = HYDCRV(J)%NERC
        IF  (J .GT. 1) THEN
         IF (NUM_NZERO_SITES .GT. 1) THEN
          IF ( (NERC .NE. HYDCRV(J+1)%NERC) .OR. (J .EQ. NUM_NZERO_SITES) ) THEN
!
!   This if added for cases where the last site in a region is included in the supply curve.
!       and if last site in sort is included in the supply curve.
!
          IF (HYDCRV(J)%SYS_COST(K) .GT. 0.0) THEN
            TOTAL_PRICE = HYDCRV(J)%SYS_COST(K)
            TOTAL_CAP = HYDCRV(J)%SYS_CAP_COST(K)
            TOTAL_VOM = HYDCRV(J)%SYS_VOM_COST(K)
            TOTAL_FOM = HYDCRV(J)%SYS_FOM_COST(K)
            TOTAL_HRATE = HYDCRV(J)%SYS_HEAT_RATE(K)
            TOTAL_CAPFAC = HYDCRV(J)%SYS_CAP_FAC(K)
            TOTAL_MONCAPFAC(:) = HYDCRV(J)%SYS_MON_CAP_FAC(K,:)
            TOTAL_CO2RATE = HYDCRV(J)%SYS_CO2_RATE(K)
            IF ((HYDCRV(J)%SYS_COST(K) .GT. 0.0) .AND. (.NOT. MIN_CAP_FOUND)) THEN
                MIN_CAP_FOUND = .TRUE.
            ENDIF
            IF (MIN_CAP_FOUND ) THEN
                TOTAL_QUAN = TOTAL_QUAN + HYDCRV(J)%AVAIL_SUPPLY_BOUND
            ENDIF
          ENDIF

           IF (TOTAL_QUAN .GT. 0.0) THEN
1294 format(a,1x,i2,1x,i7,1x,i2,f15.4,1x,f15.4)
              CRV_INFO(NERC)%STEP_PRICE(K) = &
                     TOTAL_PRICE/TOTAL_QUAN
              CRV_INFO(NERC)%STEP_CAP_COST(K) = &
                     TOTAL_CAP/TOTAL_QUAN
              CRV_INFO(NERC)%STEP_VOM_COST(K) = &
                     TOTAL_VOM/TOTAL_QUAN
              CRV_INFO(NERC)%STEP_FOM_COST(K) = &
                     TOTAL_FOM/TOTAL_QUAN
              CRV_INFO(NERC)%STEP_HEAT_RATE(K) = &
                     TOTAL_HRATE/TOTAL_QUAN
              CRV_INFO(NERC)%STEP_CAP_FAC(K) = &
                     TOTAL_CAPFAC/TOTAL_QUAN
              CRV_INFO(NERC)%STEP_MON_CAP_FAC(K,:) = &
                     TOTAL_MONCAPFAC(:)/TOTAL_QUAN
              CRV_INFO(NERC)%STEP_CO2_RATE(K) = &
                     TOTAL_CO2RATE/TOTAL_QUAN
           ELSE
              CRV_INFO(NERC)%STEP_PRICE(K) = &
                     TOTAL_PRICE
              CRV_INFO(NERC)%STEP_CAP_COST(K) = &
                     TOTAL_CAP
              CRV_INFO(NERC)%STEP_VOM_COST(K) = &
                     TOTAL_VOM
              CRV_INFO(NERC)%STEP_FOM_COST(K) = &
                     TOTAL_FOM
              CRV_INFO(NERC)%STEP_HEAT_RATE(K) = &
                     TOTAL_HRATE
                      CRV_INFO(NERC)%STEP_CAP_FAC(K) = &
                     TOTAL_CAPFAC
                      CRV_INFO(NERC)%STEP_MON_CAP_FAC(K,:) = &
                     TOTAL_MONCAPFAC(:)
                      CRV_INFO(NERC)%STEP_CO2_RATE(K) = &
                     TOTAL_CO2RATE
           ENDIF  !(TOTAL_QUAN > 0)
           CRV_INFO(NERC)%STEP_QUAN(K) = TOTAL_QUAN
           MIN_CAP_FOUND = .FALSE.
           TOTAL_QUAN = 0.0
           TOTAL_PRICE = 0.0
           TOTAL_CAP = 0.0
           TOTAL_VOM = 0.0
           TOTAL_FOM = 0.0
           TOTAL_HRATE = 0.0
               TOTAL_CAPFAC = 0.0
               TOTAL_MONCAPFAC(:) = 0.0
               TOTAL_CO2RATE = 0.0
          ENDIF  ! (NERC .NE. HYDCRV(J+1)%NERC)
         ENDIF   !(NUM_NZERO_SITE > 1)
        ENDIF   !(J > 1)

        IF ((HYDCRV(J)%SYS_COST(K) .GT. 0.0) .AND. (.NOT. MIN_CAP_FOUND)) THEN
! this if added for last site in regions included in supply curve. if step quan gt 0 then last site in region
! already processed.
         IF (CRV_INFO(NERC)%STEP_QUAN(K) .EQ. 0.0 ) THEN
            MIN_CAP_FOUND = .TRUE.
        ENDIF
        ENDIF
        IF ((MIN_CAP_FOUND ) .AND. (HYDCRV(J)%SYS_COST(K) .NE. 0.0)) THEN
            TOTAL_QUAN = TOTAL_QUAN + HYDCRV(J)%AVAIL_SUPPLY_BOUND
        ENDIF
!
        IF ( (HYDCRV(J)%SYS_COST(K) .GT. 0.0) .AND. (MIN_CAP_FOUND) ) THEN
          IF (HYDCRV(J+1)%SYS_COST(K) .EQ. 0.0) THEN
             TOTAL_PRICE = HYDCRV(J)%SYS_COST(K)
             TOTAL_CAP = HYDCRV(J)%SYS_CAP_COST(K)
             TOTAL_VOM = HYDCRV(J)%SYS_VOM_COST(K)
             TOTAL_FOM = HYDCRV(J)%SYS_FOM_COST(K)
             TOTAL_HRATE = HYDCRV(J)%SYS_HEAT_RATE(K)
             TOTAL_CAPFAC = HYDCRV(J)%SYS_CAP_FAC(K)
             TOTAL_MONCAPFAC(:) = HYDCRV(J)%SYS_MON_CAP_FAC(K,:)
             TOTAL_CO2RATE = HYDCRV(J)%SYS_CO2_RATE(K)
          ENDIF
        ENDIF
     ENDDO                            !LOOP OVER SITES

    ENDDO                             !LOOP OVER STEPS
    !*******************************************************
    !END -- CALCULATE WEIGHTED PRICE AND QUANTITY
    !*******************************************************

    !*******************************************************
     ENDIF
    !END -- NUM_NZERO_SITES > 0
    !*******************************************************

    !*******************************************************
    !  CALCULATE WEIGHTED AVERAGE HEAT RATE OVER ALL STEPS IN REGION
       DO NERC = 1, unrgns  !LOOP OVER NERC
         TOT_QUAN = 0.0
         TOT_HRATE = 0.0
         TOT_CAPFAC = 0.0
         TOT_MONCAPFAC(:) = 0.0
         TOT_CO2RATE = 0.0
         DO J = 1 , 3
          TOT_QUAN = TOT_QUAN + CRV_INFO(NERC)%STEP_QUAN(J)
          TOT_HRATE = TOT_HRATE + (CRV_INFO(NERC)%STEP_QUAN(J) * CRV_INFO(NERC)%STEP_HEAT_RATE(J))
          TOT_CAPFAC = TOT_CAPFAC + (CRV_INFO(NERC)%STEP_QUAN(J) * CRV_INFO(NERC)%STEP_CAP_FAC(J))
          TOT_MONCAPFAC(:) = TOT_MONCAPFAC(:) + (CRV_INFO(NERC)%STEP_QUAN(J) * CRV_INFO(NERC)%STEP_MON_CAP_FAC(J,:))
          TOT_CO2RATE = TOT_CO2RATE + (CRV_INFO(NERC)%STEP_QUAN(J) * CRV_INFO(NERC)%STEP_CO2_RATE(J))
         ENDDO
         IF (TOT_QUAN .NE. 0.0) THEN
           REG_HEAT_RATE(NERC) = TOT_HRATE / TOT_QUAN
           REG_CAP_FAC(NERC) = TOT_CAPFAC / TOT_QUAN
           REG_MON_CAP_FAC(NERC,:) = TOT_MONCAPFAC(:) / TOT_QUAN
           REG_CO2_RATE(NERC) = TOT_CO2RATE / TOT_QUAN
         ELSE
           REG_HEAT_RATE(NERC) = 14000.0
           REG_CAP_FAC(NERC) = .85
           REG_MON_CAP_FAC(NERC,:) = .85
           REG_CO2_RATE(NERC) = 20.0
         ENDIF
       ENDDO

    !EMM REQUIRES THE ACTUAL VALUES FOR THE AVAILABLE CAPACITY, CAPITAL COST,
    !AND O&M COST FOR THE FIRST STEP OF THE REGIONAL CURVES AND ONLY MULTIPLIERS
    !TO BE APPLIED TO THE FIRST STEP FOR THE SECOND AND THIRD STEPS

     DO NERC = 1, unrgns  !LOOP OVER NERC
      !CALCULATE CAPITAL COST
      DO J = 1, 3  !LOOP OVER STEPS
        IF (J .EQ. 1) THEN
           IF (CRV_INFO(NERC)% STEP_CAP_COST(J) .EQ. 0.0) THEN
            HYD_CURVE(NERC)%EMM_CAP_COST(J) = 9999.0
               ELSE
            HYD_CURVE(NERC)%EMM_CAP_COST(J) = &
                CRV_INFO(NERC)% STEP_CAP_COST(J)
           ENDIF
            ELSE   !STEPS 2 AND 3
           IF ( (CRV_INFO(NERC)% STEP_CAP_COST(J) .EQ. 0.0) .OR. &
                     (HYD_CURVE(NERC)%EMM_CAP_COST(1) .EQ. 9999.0) ) THEN
            HYD_CURVE(NERC)%EMM_CAP_COST(J) = 9999.0
               ELSE
                    HYD_CURVE(NERC)%EMM_CAP_COST(J) = &
                    CRV_INFO(NERC)% STEP_CAP_COST(J) / &
                    CRV_INFO(NERC)% STEP_CAP_COST(1)
               ENDIF
            ENDIF
          ENDDO        !LOOP OVER STEPS

      !CALCULATE VARIABLE O&M COST
      DO J = 1, 3  !LOOP OVER STEPS
        IF (J .EQ. 1) THEN
           IF (CRV_INFO(NERC)% STEP_VOM_COST(J) .EQ. 0.0) THEN
            HYD_CURVE(NERC)%EMM_VOM_COST(J) = 999.0
           ELSE
            HYD_CURVE(NERC)%EMM_VOM_COST(J) = &
                CRV_INFO(NERC)% STEP_VOM_COST(J)
           ENDIF
            ELSE   !STEPS 2 AND 3
           IF (CRV_INFO(NERC)% STEP_VOM_COST(J) .EQ. 0.0) THEN
            HYD_CURVE(NERC)%EMM_VOM_COST(J) = 999.0
               ELSE
                   HYD_CURVE(NERC)%EMM_VOM_COST(J) = &
                   CRV_INFO(NERC)% STEP_VOM_COST(J) / &
                   CRV_INFO(NERC)% STEP_VOM_COST(1)
               ENDIF
            ENDIF
          ENDDO        !LOOP OVER STEPS

      !CALCULATE FIXED O&M COST
      DO J = 1, 3  !LOOP OVER STEPS
        IF (J .EQ. 1) THEN
           IF (CRV_INFO(NERC)% STEP_FOM_COST(J) .EQ. 0.0) THEN
            HYD_CURVE(NERC)%EMM_FOM_COST(J) = 999.0
           ELSE
            HYD_CURVE(NERC)%EMM_FOM_COST(J) = &
                CRV_INFO(NERC)% STEP_FOM_COST(J)
           ENDIF
            ELSE   !STEPS 2 AND 3
           IF (CRV_INFO(NERC)% STEP_FOM_COST(J) .EQ. 0.0) THEN
            HYD_CURVE(NERC)%EMM_FOM_COST(J) = 999.0
               ELSE
                   HYD_CURVE(NERC)%EMM_FOM_COST(J) = &
                   CRV_INFO(NERC)% STEP_FOM_COST(J) / &
                   CRV_INFO(NERC)% STEP_FOM_COST(1)
               ENDIF
            ENDIF
          ENDDO        !LOOP OVER STEPS

      !CALCULATE HEAT RATE
      DO J = 1, 3  !LOOP OVER STEPS
        IF (J .EQ. 1) THEN
           IF (CRV_INFO(NERC)% STEP_HEAT_RATE(J) .EQ. 0.0) THEN
            HYD_CURVE(NERC)%EMM_HEAT_RATE(J) = 9999.0
           ELSE
            HYD_CURVE(NERC)%EMM_HEAT_RATE(J) = &
                CRV_INFO(NERC)% STEP_HEAT_RATE(J)
           ENDIF
            ELSE   !STEPS 2 AND 3
           IF (CRV_INFO(NERC)% STEP_HEAT_RATE(J) .EQ. 0.0) THEN
            HYD_CURVE(NERC)%EMM_HEAT_RATE(J) = 9999.0
               ELSE
                    HYD_CURVE(NERC)%EMM_HEAT_RATE(J) = &
                     CRV_INFO(NERC)% STEP_HEAT_RATE(J) / &
                     CRV_INFO(NERC)% STEP_HEAT_RATE(1)
               ENDIF
            ENDIF
          ENDDO        !LOOP OVER STEPS

      !CALCULATE CAPACITY FACTORS
      DO J = 1, 3  !LOOP OVER STEPS
        IF (J .EQ. 1) THEN
           IF (CRV_INFO(NERC)% STEP_CAP_FAC(J) .EQ. 0.0) THEN
            HYD_CURVE(NERC)%EMM_CAP_FAC(J) = 0.001
           ELSE
            HYD_CURVE(NERC)%EMM_CAP_FAC(J) = &
                CRV_INFO(NERC)% STEP_CAP_FAC(J)
           ENDIF
            ELSE   !STEPS 2 AND 3
           IF (CRV_INFO(NERC)% STEP_CAP_FAC(J) .EQ. 0.0) THEN
            HYD_CURVE(NERC)%EMM_CAP_FAC(J) = 0.001
               ELSE
                    HYD_CURVE(NERC)%EMM_CAP_FAC(J) = &
                     CRV_INFO(NERC)% STEP_CAP_FAC(J) / &
                     CRV_INFO(NERC)% STEP_CAP_FAC(1)
               ENDIF
            ENDIF
          ENDDO        !LOOP OVER STEPS

      !CALCULATE MONTHLY CAPACITY FACTORS
!
!    set step capacity factors equal to actual number not multipliers
!
      DO J = 1, 3  !LOOP OVER STEPS
            DO IM = 1 , 12   !LOOP OVER MONTHS
!      IF (J .EQ. 1) THEN
             IF (CRV_INFO(NERC)% STEP_MON_CAP_FAC(J,IM) .EQ. 0.0) THEN
              HYD_CURVE(NERC)%EMM_MON_CAP_FAC(J,IM) = 0.001
             ELSE
              HYD_CURVE(NERC)%EMM_MON_CAP_FAC(J,IM) = &
                  CRV_INFO(NERC)% STEP_MON_CAP_FAC(J,IM)
             ENDIF
!             ELSE   !STEPS 2 AND 3
!         IF (CRV_INFO(NERC)% STEP_MON_CAP_FAC(J,IM) .EQ. 0.0) THEN
!         HYD_CURVE(NERC)%EMM_MON_CAP_FAC(J,IM) = 0.001
!                ELSE
!                     HYD_CURVE(NERC)%EMM_MON_CAP_FAC(J,IM) = &
!                      CRV_INFO(NERC)% STEP_MON_CAP_FAC(J,IM) / &
!                      CRV_INFO(NERC)% STEP_MON_CAP_FAC(1,IM)
!                ENDIF
!             ENDIF
            ENDDO      !LOOP OVER MONTHS
          ENDDO        !LOOP OVER STEPS

      !CALCULATE CO2 EMISSION RATES
      DO J = 1, 3  !LOOP OVER STEPS
        IF (J .EQ. 1) THEN
           IF (CRV_INFO(NERC)% STEP_CO2_RATE(J) .EQ. 0.0) THEN
            HYD_CURVE(NERC)%EMM_CO2_RATE(J) = 99.99
           ELSE
            HYD_CURVE(NERC)%EMM_CO2_RATE(J) = &
                CRV_INFO(NERC)% STEP_CO2_RATE(J)
           ENDIF
            ELSE   !STEPS 2 AND 3
           IF (CRV_INFO(NERC)% STEP_CO2_RATE(J) .EQ. 0.0) THEN
            HYD_CURVE(NERC)%EMM_CO2_RATE(J) = 99.99
               ELSE
                    HYD_CURVE(NERC)%EMM_CO2_RATE(J) = &
                     CRV_INFO(NERC)% STEP_CO2_RATE(J) / &
                     CRV_INFO(NERC)% STEP_CO2_RATE(1)
               ENDIF
            ENDIF
          ENDDO        !LOOP OVER STEPS

      !TRANSFER CAPACITY AT EACH STEP
          DO J = 1, 3  !LOOP OVER STEPS
        HYD_CURVE(NERC)%EMM_CAPACITY(J) = &
                           CRV_INFO(NERC)%STEP_QUAN(J)
      ENDDO !LOOP OVER STEPS

     ENDDO  !LOOP OVER NERC

    !*******************************************************
    !END - CALCULATE FINAL OUTPUTS
    !*******************************************************


     END SUBROUTINE BUILD_HYD_CURVES

    !DSB********************************************************
    !DSB           END SUBROUTINE BUILD_HYD_CURVES
    !DSB********************************************************


!DSB*************************************************************
!DSB*************************************************************
                                                               !*
      SUBROUTINE WRITE_HYDB
     IMPLICIT NONE                                             !*
!DSB*************************************************************
!DSB*************************************************************
                                                               !*

    !DSB*******************************
    !DSB WRITE_HYDB DECLARATIONS
    !DSB*******************************

      INTEGER NERC, IMO, I, J     !COUNTING VARIABLES

    !DSB********************************************************
    !DSB           START -- SUBROUTINE WRITE_HYDB
    !DSB********************************************************

     IF (CURCALYR .EQ. UESTYR) THEN
       DO I = 1, WHYSITES
         WRITE(IORNDUMP,920) HYDSITE(I)%SITE_ID, &
        HYDSITE(I)%PROJNUM, &
        HYDSITE(I)%PROJNAME, &
        HYDSITE(I)%STATE, &
        HYDSITE(I)%NERC, &
        HYDSITE(I)%CLASS, &
        HYDSITE(I)%UNITTYPE, &
        HYDSITE(I)%PLNTTYPE, &
        HYDSITE(I)%PROJSTATUS, &
        HYDSITE(I)%DAMSTATUS, &
        HYDSITE(I)%POTENTIAL_CAP, &
        HYDSITE(I)%LISCCOST, &
        HYDSITE(I)%CONSCOST, &
        HYDSITE(I)%MIT_ARCH, &
        HYDSITE(I)%MIT_FISH, &
        HYDSITE(I)%MIT_SCEN, &
        HYDSITE(I)%MIT_WATER, &
        HYDSITE(I)%MIT_PASS, &
        HYDSITE(I)%MIT_TOTAL, &
        HYDSITE(I)%TOTDEV_COST, &
        HYDSITE(I)%UNITDEV_COST, &
        HYDSITE(I)%SITEPROB, &
        HYDSITE(I)%CAP_COST, &
        HYDSITE(I)%UNITFERC_COST, &
        HYDSITE(I)%FOM_COST, &
        HYDSITE(I)%VOM_COST, &
        HYDSITE(I)%COE, &
        HYDSITE(I)%AVG_CAPACITY_FACTOR, &
        (HYDSITE(I)%MON_CAPACITY_FACTOR(IMO),IMO=1,12), &
        TRIM(SCEN_DATE)
       ENDDO
     ENDIF
920 FORMAT('HYD_INPUT_DATA;',I5,';',A12,';',A33,';',A2,';',I2,';', &
            A3,';',4(A3,';'),F8.2,';',              &
            9(F10.0,';'),7(F8.2,';'),F5.3,';',12(F5.3,';'),A)


       DO I = 1, NUM_NZERO_SITES
         IF ( HYDCRV(I)%NERC .LE. (unrgns) ) THEN
           IF (( HYDCRV(I)%SYS_COST(1) .NE. 0.0 ) .OR. ( HYDCRV(I)%SYS_COST(2) .NE. 0.0 ) .OR.    &
                ( HYDCRV(I)%SYS_COST(3) .NE. 0.0 )) THEN
         WRITE(IORNDUMP,950) HYDCRV(I)%MODEL_YEAR, &
        HYDCRV(I)%SITE_ID, &
        HYDCRV(I)%PROJNUM, &
        HYDCRV(I)%PROJNAME, &
        HYDCRV(I)%STATE, &
        HYDCRV(I)%NERC, &
        HYDCRV(I)%UNITTYPE, &
                HYDCRV(I)%AVAIL_SUPPLY, &
                HYDCRV(I)%AVAIL_SUPPLY_BOUND, &
                HYDCRV(I)%CUM_SUPPLY, &
        HYDCRV(I)%COE, &
        HYDCRV(I)%SYS_COST(1), &
        HYDCRV(I)%SYS_COST(2), &
        HYDCRV(I)%SYS_COST(3), &
        HYDCRV(I)%SYS_CAP_COST(1), &
        HYDCRV(I)%SYS_CAP_COST(2), &
        HYDCRV(I)%SYS_CAP_COST(3), &
        HYDCRV(I)%SYS_VOM_COST(1), &
        HYDCRV(I)%SYS_VOM_COST(2), &
        HYDCRV(I)%SYS_VOM_COST(3), &
        HYDCRV(I)%SYS_FOM_COST(1), &
        HYDCRV(I)%SYS_FOM_COST(2), &
        HYDCRV(I)%SYS_FOM_COST(3), &
        HYDCRV(I)%SYS_CAP_FAC(1), &
        HYDCRV(I)%SYS_CAP_FAC(2), &
        HYDCRV(I)%SYS_CAP_FAC(3), &
        (HYDCRV(I)%SYS_MON_CAP_FAC(1,IMO),IMO=1,12), &
        (HYDCRV(I)%SYS_MON_CAP_FAC(2,IMO),IMO=1,12), &
        (HYDCRV(I)%SYS_MON_CAP_FAC(3,IMO),IMO=1,12), &
        TRIM(SCEN_DATE)
           ENDIF
         ENDIF
       ENDDO

950 FORMAT('HYD_CURVE_DATA;',I4,';',I5,';',A12,';',A33,';',A2,';', &
            I2,';',A5,';',F9.2,';', F9.2,';',&
            F9.2,';',F9.2,';',F12.1,';', &
            F12.1,';',F12.1,';',F10.0,';',F10.0,';', &
            F10.0,';',F9.2,';',F9.2,';',F9.2,';',  &
            F10.0,';',F10.0,';',F10.0,';', &
            39(F7.2,';'),A)


       DO NERC = 1, unrgns
         WRITE(IORNDUMP,960) CURIYR + 1989, &
           NERC, &
           CRV_INFO(NERC)%MIN_COE, &
           CRV_INFO(NERC)%MAX_COE, &
                   CRV_INFO(NERC)%SEGMENTS(1), &
                   CRV_INFO(NERC)%SEGMENTS(2), &
                   CRV_INFO(NERC)%SEGMENTS(3), &
           EMM_SIGNAL(NERC), &
           CRV_INFO(NERC)%STEP_PRICE(1), &
                   CRV_INFO(NERC)%STEP_PRICE(2), &
           CRV_INFO(NERC)%STEP_PRICE(3), &
           CRV_INFO(NERC)%STEP_QUAN(1), &
                   CRV_INFO(NERC)%STEP_QUAN(2), &
           CRV_INFO(NERC)%STEP_QUAN(3), &
           CRV_INFO(NERC)%STEP_CAP_COST(1), &
                   CRV_INFO(NERC)%STEP_CAP_COST(2), &
           CRV_INFO(NERC)%STEP_CAP_COST(3), &
           CRV_INFO(NERC)%STEP_FOM_COST(1), &
                   CRV_INFO(NERC)%STEP_FOM_COST(2), &
           CRV_INFO(NERC)%STEP_FOM_COST(3), &
           CRV_INFO(NERC)%STEP_VOM_COST(1), &
                   CRV_INFO(NERC)%STEP_VOM_COST(2), &
           CRV_INFO(NERC)%STEP_VOM_COST(3), &
           CRV_INFO(NERC)%STEP_CAP_FAC(1), &
                   CRV_INFO(NERC)%STEP_CAP_FAC(2), &
           CRV_INFO(NERC)%STEP_CAP_FAC(3), &
                   REG_CAP_FAC(NERC), &
           (CRV_INFO(NERC)%STEP_MON_CAP_FAC(1,IMO),IMO=1,12), &
           (CRV_INFO(NERC)%STEP_MON_CAP_FAC(2,IMO),IMO=1,12), &
           (CRV_INFO(NERC)%STEP_MON_CAP_FAC(3,IMO),IMO=1,12), &
                   (REG_MON_CAP_FAC(NERC,IMO),IMO=1,12), &
           TRIM(SCEN_DATE)
       ENDDO

960 FORMAT('HYD_CURVE_INFO;',I4,';',I2,';',F6.2,';',F6.2,';', &
            F6.2,';',F6.2,';',F6.2,';',F6.2,';', &
            F6.2,';',F6.2,';',F6.2,';',F10.2,';',F10.2,';', &
            F10.2,';',F10.2,';',F10.2,';',F10.2,';',&
            F10.2,';',F10.2,';',F10.2,';',  &
            F10.2,';',F10.2,';',F10.2,';',  &
                        F5.2,';',F5.2,';',F5.2,';',F5.2,';',&
            48(F5.2,';'),A)

       DO NERC = 1, unrgns
         WRITE(IORNDUMP,970) CURIYR + 1989, &
           NERC, &
           HYD_CURVE(NERC)%EMM_CAPACITY(1), &
           HYD_CURVE(NERC)%EMM_CAPACITY(2), &
                   HYD_CURVE(NERC)%EMM_CAPACITY(3), &
           HYD_CURVE(NERC)%EMM_CAP_COST(1), &
           HYD_CURVE(NERC)%EMM_CAP_COST(2), &
                   HYD_CURVE(NERC)%EMM_CAP_COST(3), &
           HYD_CURVE(NERC)%EMM_VOM_COST(1), &
           HYD_CURVE(NERC)%EMM_VOM_COST(2), &
                   HYD_CURVE(NERC)%EMM_VOM_COST(3), &
           HYD_CURVE(NERC)%EMM_FOM_COST(1), &
           HYD_CURVE(NERC)%EMM_FOM_COST(2), &
                   HYD_CURVE(NERC)%EMM_FOM_COST(3), &
           HYD_CURVE(NERC)%EMM_CAP_FAC(1), &
           HYD_CURVE(NERC)%EMM_CAP_FAC(2), &
                   HYD_CURVE(NERC)%EMM_CAP_FAC(3), &
           (HYD_CURVE(NERC)%EMM_MON_CAP_FAC(1,IMO),IMO=1,12), &
           (HYD_CURVE(NERC)%EMM_MON_CAP_FAC(2,IMO),IMO=1,12), &
           (HYD_CURVE(NERC)%EMM_MON_CAP_FAC(3,IMO),IMO=1,12), &
           TRIM(SCEN_DATE)
       ENDDO

970 FORMAT('HYD_FINAL_CURVES;',I4,';',I2,';',F12.2,';',F10.2,';', &
            F10.2,';',F12.2,';',F10.2,';',F10.2,';', &
            F12.2,';',F10.2,';',F10.2,';',&
            F12.2,';',F10.2,';',F10.2,';',&
            F8.2,';',F8.2,';',F8.2,';',36(F8.2,';'),A)

       DO NERC = 1, unrgns
           WRITE(IORNDUMP,940) CURIYR+1989,NERC,HYD_ADD(NERC), &
                           EMM_SIGNAL(NERC), FXD_CHRG_FACT(NERC), &
                               HYD_AVOID_COST(NERC), EPMSTOL, &
                               WHYPRICE_SEG(1),WHYPRICE_SEG(2),WHYPRICE_SEG(3),TRIM(SCEN_DATE)
       ENDDO

940 FORMAT('HYD_BUILDS;',I4,';',I2,';',F10.2,';',F7.3,';',F7.3,';', &
                    F7.3,';',F7.3,';',F5.2,';',F5.2,';',F5.2,';',A)

    END SUBROUTINE WRITE_HYDB

    !DSB********************************************************
    !DSB           END -- SUBROUTINE WRITE_HYDB
    !DSB********************************************************
!***********************************************************************
                                                               !*
      SUBROUTINE GET_HYDATA
     IMPLICIT NONE                                         !*
                                                               !*
!DSB*************************************************************
!DSB*************************************************************

    !DSB*******************************
    !DSB GET_PARM_DATA DECLARATIONS
    !DSB*******************************

    INTEGER I,EXHYDRECS,HSITE,STRTYR,SYR,ISITE   !COUNTING VARIABLES
    INTEGER IYR,NUM_ADJS,NUM_BOUNDS,TYR,FOUND     !COUNTING VARIABLES
    INTEGER IUNIT               !OUPUT FILE UNIT NUMBER
        REAL BOUNDS(MNUMYR),MULT(MNUMYR)
    INTEGER FILE_MGR            !NEMS FILE MANAGER RETURN VALUE
        EXTERNAL FILE_MGR
        CHARACTER*25 FNAME
        CHARACTER*12 HPJNUM
        CHARACTER*80 DUMMY

    !DSB********************************************************
    !DSB           START SUBROUTINE GET_PARM_DATA
    !DSB********************************************************


    !READ IN PARAMETERS FROM WHYDRO  FILE
!***********************************************************************
!.....Open file
      FNAME = 'WHYDRO'
      IUNIT=FILE_MGR('O',FNAME,.FALSE.)
!***********************************************************************

!.....Read data
!
      READ(IUNIT,*) DUMMY
      READ(IUNIT,*) DUMMY
      READ(IUNIT,*) DUMMY
      READ(IUNIT,*) (WHYPRICE_SEG(I),I=1,MSPTMX)
!
      READ(IUNIT,*) DUMMY
      READ(IUNIT,*) HYPROB_LIMIT
!
      READ(IUNIT,*) DUMMY
      READ(IUNIT,*) DUMMY
      READ(IUNIT,*) INPUT_DYEAR
!
!     Read in add on 'public acceptance' costs by site probability
!
      READ(IUNIT,*) DUMMY
      READ(IUNIT,*) DUMMY
      READ(IUNIT,*) NUM_SITEPROB
!write(6,*) ' numsiteprob ',num_siteprob
      READ(IUNIT,*) DUMMY
      READ(IUNIT,*) DUMMY
      DO I = 1, NUM_SITEPROB
        READ(IUNIT,*) SPROB(I),PUBACPCST(I)
      ENDDO
!       do i = 1 , num_siteprob
!          write(6,*) ' siteprob ',sprob(i),pubacpcst(i)
!       enddo

!
!       Read in next table of whydro data   - contains annual build bounds by site
!
      READ(IUNIT,*) DUMMY
      READ(IUNIT,*) DUMMY
      READ(IUNIT,*) DUMMY
      READ(IUNIT,*) NUM_BOUNDS
      READ (IUNIT,*) STRTYR
      READ (IUNIT,*)
      READ (IUNIT,*)
      READ (IUNIT,*)
      SYR = STRTYR - 1989
      TYR = MNUMYR - SYR + 1
      DO I = 1, NUM_BOUNDS
        BOUNDS = 9999.0
    READ (IUNIT,*) HPJNUM,(BOUNDS(IYR),IYR=SYR,MNUMYR)

        FOUND = 0
        DO ISITE = 1 , WHYSITES
          IF ( TRIM(HYDSITE(ISITE)%PROJNUM) .EQ. TRIM(HPJNUM) ) THEN
            HYDSITE(ISITE)%SITE_BOUND(:) = BOUNDS(:)
            FOUND = 1
          ENDIF
        ENDDO
        IF (FOUND .EQ. 0) THEN
          write(6,*) ' warning: hydro site bound project number not found ',hpjnum
        ENDIF

      ENDDO

950 FORMAT(I3,1X,A22,<TYR>(1X,F3.0))
980 FORMAT(A,I3,1X,<MNUMYR>(1X,F3.0))
!
! Read in next table of whydro data   - contains annual capital costs multipliers by site
!
      READ (IUNIT,*)
      READ (IUNIT,*)
      READ (IUNIT,*)
      READ (IUNIT,*) NUM_ADJS
      READ (IUNIT,*) STRTYR
!     write(6,*) ' num_adjs  strtyr ',num_adjs,strtyr
      READ (IUNIT,*)
      READ (IUNIT,*)
      READ (IUNIT,*)
      SYR = STRTYR - 1989
      TYR = MNUMYR - SYR + 1
      DO I = 1, NUM_ADJS
        MULT = 1.0
    READ (IUNIT,*) HPJNUM,(MULT(IYR),IYR=SYR,MNUMYR)

        FOUND = 0
        DO ISITE = 1 , WHYSITES
          IF ( TRIM(HPJNUM) .EQ. 'ALL' ) THEN
!           write(6,*) ' setting all cost multipliers equal to ALL  multipliers '
            HYDSITE(ISITE)%CAPCOST_MULT(:) = MULT(:)
            FOUND = 1
          ELSEIF ( TRIM(HYDSITE(ISITE)%PROJNUM) .EQ. TRIM(HPJNUM) ) THEN
            HYDSITE(ISITE)%CAPCOST_MULT(:) = MULT(:)
            FOUND = 1
          ENDIF
        ENDDO
        IF (FOUND .EQ. 0) THEN
          write(6,*) ' warning: hydro site capcost mult project number not found ',hpjnum
        ENDIF

      ENDDO
960 FORMAT(I3,1X,A22,<TYR>(1X,F5.3))
!

!     GET NUMBER OF SITES IN DATA FILE
!     READ (IUNIT, 900) EXHYDRECS
!     write(IORNDUMP,*) 'numrec exgeo ',exgeorecs
!00 FORMAT (2x,I2)
!     READ(IUNIT,*) DUMMY
!     READ(IUNIT,*) DUMMY

!   !POPULATE STRUCTURE "EXHYD' WITH DATA FROM FILE
!DO I = 1, EXHYDRECS
!   READ (IUNIT, 910) EXHYD(I)%PLANT_ID, &
!   EXHYD(I)%PLANT_NAME, &
!   EXHYD(I)%SITE_ID, &
!   EXHYD(I)%SITE_NAME, &
!   EXHYD(I)%PLANT_VINTAGE, &
!   EXHYD(I)%PRIME_MOVER, &
!   EXHYD(I)%EFD_TYPE, &
!   EXHYD(I)%NERC, &
!   EXHYD(I)%STATE, &
!   EXHYD(I)%SUMMER_CAP, &
!   EXHYD(I)%START_YEAR
!               write(IORNDUMP,*) ' exgeo data ',I,exgeo(I)%site_id,exgeo(I)%plant_id, &
!                        exgeo(I)%summer_cap

!ENDDO

910 FORMAT(A8,1X,A25,1X,I3,1X,A15,1X,I3,1X,A2,4X,I2,2X,I2,1X,A2,2X,F8.2,4X,I4)
!
!     FILL EXISTING HYDSITE VARIABLE WITH EXISTING CAPACITY
!
!     DO I = 1 , WHYSITES
!       HYDSITE(I)%PFILE_EXCAP = 0.0
!     ENDDO
!
!     DO J = 1 , EXHYDRECS
!       SITEID = EXHYD(J)%SITE_ID
!       HYDSITE(SITEID)%PFILE_EXCAP = HYDSITE(SITEID)%PFILE_EXCAP + EXHYD(J)%SUMMER_CAP
!     ENDDO

      IUNIT=FILE_MGR('C',FNAME,.FALSE.)
!***********************************************************************

    END SUBROUTINE GET_HYDATA

    !DSB********************************************************
    !DSB           END -- SUBROUTINE GET_HYDATA
    !DSB********************************************************


    END SUBROUTINE HYDRO

!DSB***************************************************************
!DSB           END SUBROUTINE HYDRO
      Subroutine POLYSYS
      USE P_
      IMPLICIT NONE

      integer jj

    ! call poly for each of the supply curve points
        do jj=1,5 !wdpolypt
           NPT=jj
           call polymain(JJ)
!          call polydbug(JJ)
        enddo

      return
      end
!***************************************************************
  !     Updates from UT 2019
      SUBROUTINE POLYMAIN(jj)
      USE P_
      IMPLICIT NONE

      INTEGER FILE_MGR
      EXTERNAL FILE_MGR
      CHARACTER*25 FNAME
      LOGICAL NEW
      INTEGER IUNIT2,jj,kk,ll

      INTEGER IUNIT1
      INTEGER FILEUNIT

      INTEGER Y,IIT,BIGDONE
      INTEGER ISTART,IEND,J,IPRTBS,NCROPS
      REAL LOWITER,GLAST,CLAST,SOYLAST,DEXLAST, begpric
      REAL BIOTRANS    !transportation costs adder, not in default polysys???
      CHARACTER*2 ZZ
      CHARACTER(20) :: CRASH


       ! dynamically assign array dimensions on the first call
       IF((CURCALYR.EQ.WDPOLYYR).AND.(jj.eq.1)) THEN

            allocate( BCARB(5,18,3110)) !baseline variable
            allocate( BSHIFT(18,4,3111)) !baseline variable
            allocate( PSHIFT(18,2,3111)) !baseline variable
            allocate( CYXB(39,18,4,NPOLYREG2) ) !keep fist indices matches index(65)
            allocate( PLACB(8,18,4,3111)) !baseline variable
            allocate( CMX(100,22,6,NPOLYREG2)) !NPOLYREG))   !keep
            allocate( HARVESTCOST(6,3111) ) !keep
            allocate( WEST(3111))!baseline variable
            allocate( EAST(3111)) !keep
            allocate( PTB(PSYEARS,7,28,3111)) !keep
            allocate( PASTRENT(PSYEARS,NPOLYREG2)) !baseline variable
            allocate( PASTRETRN(PSYEARS,3111)) !baseline variable
            allocate( BIGINDEX(10,3111))!baseline variable
            allocate( RRR(18,NPOLYREG2)) !keep
            allocate( NPVB(PSYEARS,18,4,3111))!baseline variable
            allocate( CY(34,18,4,3111)) !baseline variable
            allocate( CYB(34,18,4,NPOLYREG2)) !baseline variable
            allocate( CYBACKUP(18,3,3111)) !baseline variable
            allocate( LANDRENT(PSYEARS,3111)) !baseline variable
            allocate( CORNDOCK(3,3111))
            allocate( SOYDOCK(3,3111))
            allocate( COTTONDOCK(3,3111))
            allocate( SOYDOCKCT(3,3111))
            allocate( RCNTX(18,18,4,3110)) !keep
            allocate( MUTH(PSYEARS,2,9,3,3110)) !keep
            allocate( CYX(39,18,4,NPOLYREG))
            allocate( RCNT(20,18,4,NPOLYREG))
            allocate( BIOAGE(PSYEARS,32,6,4,NPOLYREG))
            allocate( PRDAGE(PSYEARS,32,6,4,NPOLYREG) )
            allocate( CRN(PSYEARS,26,20,3))
            allocate( TBMX(22,4,NPOLYREG) )
            allocate( PLAC(8,18,4,NPOLYREG) )
            allocate( PRIC(18,NPOLYREG))
            allocate( YIELD(18,4,NPOLYREG) )
            allocate( COST(18,4,NPOLYREG))
            allocate( AYL(PSYEARS,6,4,NPOLYREG) )


       ! initialize allocated arrays to zero; otherwise, you get what is in the assigned memory
            INCENT=0.0;          BCARB=0.0 ;                    BIOAGE=0.0;       PRDAGE=0.0
             BSHIFT=0.0;         PSHIFT=0.0 ;                    CRN=0.0 ;            PT=0.0
             CYX=0.0;             CYXB=0.0;                        TBMX=0.0  ;         PTB=0.0
             PLACB=0.0;         PLAC=0.0;                        PASTRENT=0.0 ;   PASTRETRN=0.0
             PRIC=0.0;            YIELD=0.0;                       BIGINDEX=0.0;     RRR=0.0
             COST=0.0 ;          BIOPL=0.0;                       APL=0.0 ;             NPV=0.0
             CMX=0.0;            HARVESTCOST=0.0;         NPVB=0.0 ;          CY=0.0
             PTTOTAL=0.0;     AYL=0.0;                           CYB=0.0 ;            LANDRENT=0.0
             WEST=0.0;          EAST=0.0 ; RCNT=0.0; RCNTX=0.0; MUTH=0.0 ;CORNDOCK=0.0; SOYDOCK=0.0;  COTTONDOCK=0.0; SOYDOCKCT=0.0
      !initialize other arrays
      AB       = 0.0;      A        = 0.0;      XAB      = 0.0;      XA       = 0.0
      X        = 0.0;      XB       = 0.0;      C        = 0.0;      B        = 0.0
      CFIXED   = 0.0;      PCFIXED  = 0.0;      SFIXED   = 0.0;      PXB      = 0.0
      PX       = 0.0;      PB       = 0.0;      PC       = 0.0;      S        = 0.0
      SB       = 0.0;      XS       = 0.0;      XSB      = 0.0;      XCRB     = 0.0
      XCR      = 0.0;      XAGB     = 0.0;      XAG     = 0.0;      SAUB     = 0.0
      SAU      = 0.0;      CRMRB    = 0.0;      PNXB     = 0.0;      PNB      = 0.0
      SGB      = 0.0;      SGXB     = 0.0;      CONVSN   = 0.0;      CSCP     = 0.0
      BASECP   = 0.0;      BASELV   = 0.0;      EAC      = 0.0;      EGC      = 0.0
      AJC      = 0.0;      EDML     = 0.0;      EGL      = 0.0;      AJL      = 0.0
      EGP      = 0.0;      AJP      = 0.0;      BGSTK    = 0.0;      HISTPR   = 0.0
      GB       = 0.0;      YEARS    = '0';      LVP      =   0.0;      SNT      =   0.0
      ADJLDP   =   0.0;      AdESPL   =   0.0;      EQ11     =   0.0;      EQ12     =   0.0
      EQ13     =   0.0;      AdESBL   =   0.0;      EQ21     =   0.0;      EQ22     =   0.0
      CYL      =   0.0;      CL       =   0.0;      CLL      =   0.0;      XGB      =   0.0
      WPB      =   0.0;      BCCP     =   0.0 ;      BIOPRD   =   0.0;      CSXB     =   0.0
      BIOITER  =   0;      ILOOP    =   0;      ARPTEST  =   0.0;      BASECP   =   0.0
      ANPV     =   0.0;      ENB      =  0.0;      EN       =  0.0 ;      AdjFac      =  1.0
      NPVB    =  0.0;      BIOPRICE =  0.0;      bb = 0.0; SMCPYR   =   0.0


endif
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

     ! RCNT=0.0  !zero out rcnt every year


       POLYCURIYR=CURIYR-(WDPOLYYR-1989)+3 !starts at 3
       if (POLYCURIYR.LT.1) THEN
          POLYCURIYR=1
          write(*,*) 'ERROR - PROBLEM WITH POLYCURIYR'
       ENDIF

       CRVPT=3 !which price point to use for lag
       CRVPTNUM= jj
       I=POLYCURIYR  !change variable name; I is too common
       97 FORMAT(' ','Year -> ',I4)

                        !--
                            CRASHNUM=0  !THIS IS FOR STOCHASTIC MODEL = 1 IF CRASHED AND NEED TO PICK NEW YEAR
                        !--
                            BIOITER=1
                        !--
                        !--  THIS IS THE stochastic version of polysys
                        !--  it has the new spatially-interpolated budgets of traditional crops and switchgrass
                        !--  IT IS A 25 YEAR MODEL
                        !--
                        !--                             ****
                        !-- *************************   MAIN  ****************************
                        !--                             ****
      FNAME='PSSIM'
      NEW=.FALSE.
      IUNIT1=FILE_MGR('O',FNAME,NEW)
      CALL INDX
       NCROPS=INDEX(2)
         ALWAYSCNTY=INDEX(118) !change region version

                        !--             UNIT NUMBER FOR READING SIMULATION TITLE AND PARAMETERS


         10 FORMAT(/,/,/,A22,A100,/,I4,/,A4,/,A4,/,A60,/, &
                            A67,22(/,I4),/,/,f4.2,/,/,F4.0,/,F4.0,/,F4.0 &
                            ,/,/,F4.0,/,F4.0,/,F4.0,/,/,I4,/I4,/I4,/I4,/I4,/I4 &
                            ,/,f4.2)                                              !A60, xx...THIS IS THE NUMBER OF LINES TO READ
                            READ(IUNIT1,10) chad,USERDEFPATH,INDEX(1),EXTPRE,EXTSUF,TITLE1 &
                            ,TITLE2,INDEX(32),INDEX(106) &
                            ,INDEX(99),INDEX(102),INDEX(86),INDEX(84) &
                            ,INDEX(94) &
                            ,INDEX(73),INDEX(93),INDEX(103) &
                            ,INDEX(74),INDEX(107),INDEX(108),INDEX(109) &
                            ,INDEX(110),INDEX(111),INDEX(112),INDEX(113) &
                            ,INDEX(53),INDEX(116),INDEX(104),INDEX(22) &
                            ,PASTASS,MAXPRIC,RESETPRIC, BEGPRIC & !Update from UT 2019
                            ,yrresid,yrherb,yrwoody,INDEX(115),index(101) &
                            ,INDEX(114),INDEX(119),INDEX(117),INDEX(121) & !region change version; !Update from UT 2019
                            ,BRENTOIL !2021 update EIA ENERGY
	 !CLOSE(14)
         IUNIT1=FILE_MGR('C',FNAME,NEW)
         !!!!  EIA - add this so we don't have to change sim file AND code parameter
         !!!! must change baseline files if switching regions
               if (NPOLYREG.eq.305) then
                 index(117)=2
               elseif (NPOLYREG.eq.16) then
                 index(117)=1
               endif

     ! region change version
      if(index(117).eq.1.and.index(106).eq.3)then !and.index(106).eq.3)then  !IF GOING TO 16 REGION EIA MODEL
          INDEX(33)=NPOLYREG
          CNTY=NPOLYREG
      elseif(index(117).eq.2.and.index(106).eq.3)then !and.index(106).eq.3)then
          index(33)=NPOLYREG
          cnty=NPOLYREG
      else
          continue
      ENDIF

                        !--


         !INDEX(30)=WDPOLYYR ! overwrite start year with NEMS variable from wodtech.txt

                        !--
                        !-!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        !-!!!     SETS LOOPS FOR BASELINE OR SIM   !!!
                        !-!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            IF(INDEX(106) == 1)THEN
                INDEX(41)=0  !1 IF BASELINE FROM BASELINE.RMF; 0 IF COMPUTE FROM DATAxxxx.TXT [41]                 ! 0first,1second,1sim   !!!!!!!!!!!!!!!!!!!!!!!!!!
                INDEX(87)=0  !0 IF UPDATING BASELINE; 1 OTHERWISE [87]                                             ! 0first,0second,1sim   !!routine for updating  !!
                INDEX(97)=0  !0 IF Writing Baseline extension (use 41 & 87 =1) ; 1 OTHERWISE [97]                  ! 0first,1second,1sim   !!    baseline          !!
                INDEX(88)=0  ! 1 Supply from 305 Region LP Models; 0 Supply from 7 Region elasticity model  [88]   ! 0first,1second,1sim   !!!!!!!!!!!!!!!!!!!!!!!!!!
            ELSEIF(INDEX(106) == 2)THEN
                INDEX(41)=1  !1 IF BASELINE FROM BASELINE.RMF; 0 IF COMPUTE FROM DATAxxxx.TXT [41]                 ! 0first,1second,1sim   !!!!!!!!!!!!!!!!!!!!!!!!!!
                INDEX(87)=0  !0 IF UPDATING BASELINE; 1 OTHERWISE [87]                                             ! 0first,0second,1sim   !!routine for updating  !!
                INDEX(97)=1  !0 IF Writing Baseline extension (use 41 & 87 =1) ; 1 OTHERWISE [97]                  ! 0first,1second,1sim   !!    baseline          !!
                INDEX(88)=1  ! 1 Supply from 305 Region LP Models; 0 Supply from 7 Region elasticity model  [88]   ! 0first,1second,1sim   !!!!!!!!!!!!!!!!!!!!!!!!!!
            ELSEIF(INDEX(106) == 3)THEN
                INDEX(41)=1  !1 IF BASELINE FROM BASELINE.RMF; 0 IF COMPUTE FROM DATAxxxx.TXT [41]                 ! 0first,1second,1sim   !!!!!!!!!!!!!!!!!!!!!!!!!!
                INDEX(87)=1  !0 IF UPDATING BASELINE; 1 OTHERWISE [87]                                             ! 0first,0second,1sim   !!routine for updating  !!
                INDEX(97)=1  !0 IF Writing Baseline extension (use 41 & 87 =1) ; 1 OTHERWISE [97]                  ! 0first,1second,1sim   !!    baseline          !!
                INDEX(88)=1  ! 1 Supply from 305 Region LP Models; 0 Supply from 7 Region elasticity model  [88]   ! 0first,1second,1sim   !!!!!!!!!!!!!!!!!!!!!!!!!!
            ENDIF
                        !-!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        !--
           CALL XTENSION
          !td CALL OPENFL
                        !--
          ! read this every time to reset variables??
       !  write(*,*) wdpolyyr, '2020', BASEYR,CURIYR,WDPOLYYR-BASEYR+1
         if (CURIYR .EQ. (WDPOLYYR - BASEYR + 1)) THEN

       FNAME='./input/PSBASELINE.UNF'
   !    IUNIT1=FILEUNIT()
       OPEN(UNIT=IUNIT1,FORM='UNFORMATTED',FILE=FNAME)

        READ(IUNIT1)INDEX(27),INDEX(28),INDEX(37),B,XB,AB &
        ,XAB,PB,PXB,CRMRB,PNXB,PNB,SGB,SGXB &
        ,FCTRCP,YRPER,FCTRLV,PERFG,PERMET &
        ,PERPOL,PERLV,PERCP,PERALL,CONVSN,CSCP,CSLV,BASECP,BASELV &
        ,EAC,EGC,AJC,EDML,EGL,AJL,EGP,AJP,BGSTK,BASEID &
        ,YEARNAME,YEARS,GB,XSB,SB,XCRB,XAGB &
        ,IYEAR,SAUB,LVP,SNT,ADJLDP,AdESPL,EQ11,EQ12,EQ13,AdESBL,EQ21 &
        ,EQ22,CYL,CY,CL,CLL,XGB,WPB,BCCP,BIOPRD &
        ,CSXB,BCARB,CARBRATE ,BTRDB ,TRDVARB
                                


         ! write(*,*) 'yearname=',yearname
         ! write(*,*) 'years=',years
         !   write(*,*) 'iyear=',iyear
         !   write(*,*) 'EQ11=',EQ11
          CLOSE(IUNIT1)
       FNAME='./input/PSBASEREGN.UNF'
       OPEN(UNIT=IUNIT1,FORM='UNFORMATTED',FILE=FNAME)
          READ(IUNIT1)ENB
       CLOSE(IUNIT1)
                            !--
                            !--

       CALL ELAST
        ENDIF

!
        POLYFIRSTYR=WDPOLYYR - INDEX(27) + 3 !td added because ISTART VALUE changes
     ISTART=(INDEX(30)-INDEX(27))+3 !ISTART=5
     IEND = INDEX(1) +(INDEX(30)-INDEX(27)) + 2 !IEND=29+2+2=33

     if (CURIYR .EQ. (WDPOLYYR - BASEYR + 1))  THEN
           CALL B2C        ! SET LAGGED VALUES C,X,S,XS,A,XA, MATRICES TO LAST YEARS DATA
           NCROPS = INDEX(2)
           CALL WHATIF

      endif

  I=POLYCURIYR  !change variable name; I is too common
         CALL FROM_NEMS(jj)
      Y=I+INDEX(27)-3
            L = I - 1
            IIT = 1
        DO CTY=1,INDEX(33)
           IF(INDEX(87) == 1 .AND. INDEX(39) > 0.0 .AND. INDEX(74) == 0) THEN
             NEWPRC(NPT,I,CTY) = 0.0 !update from UT 2019      !!BIOPROD
             do dloop = 1, 10
                REGPRC(I,dloop)=0.0
             enddo
             BIOITER = 1
             OLDPRC = 0.0
             LOWITER = 0.0
             BIOLOW = 1000
             ADJPRC = 0.0
           ENDIF
           IF (INDEX(72) == 0)NEWPRC(NPT,I,CTY)=NEWPRC(NPT,I-1,CTY) !EN(I-1,3,1)  !C(I-1,9,9)  !if want cellulosic to fill all endogenous demand
           IF(NEWPRC(NPT,I,CTY) >= MAXPRIC)NEWPRC(NPT,I,CTY)=RESETPRIC !IF AT EXTREME PRICE LIMIT OF 150 THE YEAR BEFORE, REDUCE BY $3 AND TRY TO MEET DEMAND THIS CURRENT YEAR AT A LOWER PRICE
        ENDDO
    87 CONTINUE
    ! Update from Ut 2019 BUT NOT USED HERE SINCE index(74) IS ALWAYS 1
       ! DO CTY=1,INDEX(33)
       !    IF(NEWPRC(NPT,I,CTY).LT.BEGPRIC.AND.I.GE.3.AND.INDEX(74).EQ.0 &
       !      .AND.(REGBIO(CTY).GT.0.0.OR.INDEX(119).EQ.0))THEN
       !          NEWPRC(NPT,I,CTY)=BEGPRIC                 !THIS IS THE MINIMUM PRICE FOR BIOMASS                                                           !!BIOPROD
       !    ENDIF
       ! ENDDO


            IIT = IIT+1
        IF (INDEX(88) == 1)THEN
  424           CONTINUE
            IF(INDEX(87) == 1 .AND. INDEX(39) > 0 &
                .AND. INDEX(74) == 0)THEN
                CALL BIOPROD1                                                                                                               !!BIOPROD
            ENDIF
            CALL RMAIN
       !     If (INDEX(53).GT.0.0) Call WOODY !Update from UT 2019 ; comment because EIA doesn't use Woody
            CALL SUMBIO
            IF(ADJPRC>0.0) then

              GOTO 87
            endif
  425          CONTINUE
                                    !--
            ELSE
            CALL SUPPLY2                                !GO HERE IF ESTIMATING EXTENDED NATIONAL BASELINE OVER 13 YRS
            END IF
            CALL LVSK
            CALL LVINIT
            CALL STGAUS
            IF(INDEX(51)==1) THEN
         !--         **SET UP FOR SIMULTANOUS CROP-LIVESTOCK ITERATIONS**
               BIGITER=0
             120 BIGITER=BIGITER+1
               !--
             IF(BIGITER == 1200)WRITE(*,*)N,I,BIGITER,'bigiter'                  !IF TOO MANY ITERATIONS, QUIT
             IF(BIGITER == 1200)GOTO 1000                              !IF TOO MANY ITERATIONS, QUIT
             IF(BIGITER == 1) THEN
                  GLAST=.01
                  CLAST=.01
                  SOYLAST=.01
                  DEXLAST=.01
                 C(NPT,I,9,1) = b(i,9,1)                                    !GIVE CENTER.FOR STARTING CROP PRICES
                 PC(NPT,i,4,2)=pb(i,4,2)
               ELSE
                  GLAST=SAU(I,13,1)                !IF NOT, ASSIGN LAST ITERATIONS VALUE
                 DEXLAST=A(NPT,I,05,2)
                 SOYLAST=PC(NPT,I,4,2)
               ENDIF

               CALL CENTER      !GET GCAU'S
               CALL LVINDEX     !GET LIVESTOCK INDEX
               CALL GRAINS      !GET CROP PRICE EQUILIBRIUM
               CALL STKCHK
               CALL CENTER      !USE NEW CROP PRICES TO GET NEW GCAU'S
               CALL LVINDEX     !GET NEW LIVESTOCK INDEX
                   !--
                   !--             ***CHECK CONVERGENCE OF SIMULTANOUS EQUATIONS***
                   !--
               BIGDONE=0                                                !0=converged/1=not converged
                   !--
               SAU(I,13,1)=.33*GLAST+(1-.33)*SAU(I,13,1)                !ADJUST INBETWEEN
              IF(ABS((SAU(I,13,1)-GLAST)/GLAST) >= 0.0001) BIGDONE = 1  !IF YES NEW ITERA. IF NO, CONVERGED
              IF(BIGDONE == 1)GOTO 220                                  !.0007 was it before
                   !--
              A(NPT,I,05,2) = .33 * DEXLAST + (1-.33) * A(NPT,I,05,2)           !CHECK LVINDEX FOR CONVERGENCE
              IF(ABS((A(NPT,I,05,2)-DEXLAST)/DEXLAST) >= 0.0001)BIGDONE = 1
                   !--
              220 CONTINUE
              IF (BIGDONE == 1) GOTO 120                                !GO BACK FOR ANOTHER ITERA IF NEEDED
                   !!!!!!!!!!!!!!!!!!!!!!!!!!
        767  CONTINUE
            !

                   !--
                   !--    FOR STOCHASTIC MODEL, PUT ORIGONAL BASELINES BACK IN AFTER SIMULTANIOUS SOLVING
             IF(INDEX(99)==1)THEN
            DO K = 1,NCROPS
                            B(I,4,K)  = TEMPBX(K)      ! Return Exports baseline to original level           !COMMENTED
             B(I,9,K)  = TEMPBP(K)      ! Return Price baseline to original level
             B(I,10,K) = TEMPBDF(K)     ! Return Feed demand baseline to original level
             B(I,11,K) = TEMPBDO(K)     ! Return Food demand baseline to original level
             B(I,40,K) = TEMPBDI(K)     ! Return Industrial demand baseline to original level
                            CFIXED(I,04,K) = 0.0                                                                !!chad commenTED
             CFIXED(I,09,K) = 0.0
             CFIXED(I,10,K) = 0.0
             CFIXED(I,11,K) = 0.0
             CFIXED(I,40,K) = 0.0
            END DO
            ENDIF
                                    !--
                                    !--!!!
            ELSE
               CALL GRAINS
            END IF
         IF(IIT==1)GOTO 87
            CALL MDLDEX
             200 CONTINUE
             CALL MDLGOVC

             CALL REGOUT
         !--
           !  CALL PRINTREsid
            ! IF(INDEX(87) == 1 .AND. INDEX(104) == 1)THEN
             !td commenting call to printloop,printresid and printreg until added to file manager or eliminated
                ! CALL PRINTLOOP     !PRINTS ALL INCENT(J,K,T,CTY) VARIABLES !!RESIDUE VARIABLES (USING PRINT IN RESCNTY.FOR NOW FOR MOST IMPORTANT VARIABLES)
               ! CALL PRINTREG      !CTYOUTa & CTYOUTb FILES. CAN TURN ON WOODOUT,IDLEOUT FILES TOO
             !C           CALL PRINTCRP !EIA CHAD 2017
                ! CALL PRINTRESID
            ! ENDIF
         !--
             !END DO ! end of i loop
           !  write(666,*) 'call backto_nems',jj,curcalyr
              CALL BACKTO_NEMS(jj) ! send results back to NEMS


     if ((CURIYR.eq.LASTYR).and.(jj.eq.5)) then
           IF(INDEX(97).EQ.0) THEN
        CALL MDLINC
     endif
          CALL MDLINC
 !         IF(INDEX(32)==2)CALL PERCNT !region change version
!          IF(INDEX(32)==3)CALL DIFFER !region change version
          !--   Print Supply and utilization tables
          ! Update from UT 2019
           IF(INDEX(119).EQ.1)THEN
       !       CALL PRINTTXT2  !regional demand output
           ELSE
              CALL PRINTTXT  !NATIONAL DEMAND RUN
           ENDIF

      endif
     N=1
     1000 CONTINUE

        CONTAINS



!     Last change:  BW   28 Nov 2001   11:16 am
    SUBROUTINE AVGVAL
      IMPLICIT NONE

    !EIA add
    INTEGER :: NYRSIM,  NCROPS, NVARC, NVARX,  NLVSK, NPGA
    INTEGER :: NVARS, NVARXS, NVARA , NPGXA, NVARXA,  ILAV8, IFAV8 , IFAV9
    INTEGER :: J, ISTART, IEND, ILAV9
!--                          *****************
!--   *********************  AVGVAL SUBROUTINE  ***********************
!--          THIS SUBROUTINE IS CALLED FROM DIFFER.FOR
!--      COMPUTES AVERAGES FOR TWO PERIODS AND ALL YEARS SIMULATED
!--     USED IN PERCNT AND DIFFER SUBROUTINES
!--             AUXILLARY WRITE STATEMENTS (UNIT NO., 0 SCREEN, -1 OFF)

!--   SET THE NUMBER OF YEARS SIMULATED
    NYRSIM = INDEX(1)
    ISTART = INDEX(30)-INDEX(27)+3
    IEND = NYRSIM+(INDEX(30)-INDEX(27))+2
!--   NUMBER OF CROPS IN POLYSYS
      NCROPS = INDEX(2)
!--   NUMBER OF VARIABLES IN C
    NVARC = INDEX(3)
!--   NUMBER OF VARIABLES IN X
    NVARX = INDEX(4)
!--   NUMBER OF MODEL LIVESTOCK COMMODITIES IN POLYSYS
    NLVSK = INDEX(5)
!--   NUMBER OF VARIABLES IN S (2ND SUBSCRIPT), ALSO SB
    NVARS = INDEX(6)
!--   NUMBER OF VARIABLES IN XS (2ND SUBSCRIPT)
    NVARXS = INDEX(7)
!--   NUMBER OF PAGES IN A (3RD SUBSCRIPT)
    NPGA = INDEX(12)
!--   NUMBER OF VARIABLES IN A (2ND SUBSCRIPT)
    NVARA = INDEX(13)
!--   NUMBER OF PAGES IN XA (3RD SUBSCRIPT)
    NPGXA = INDEX(8)
!--   NUMBER OF VARIABLES IN XA (2ND SUBSCRIPT)
    NVARXA = INDEX(14)
!--   SET 'UNIT' NUMBER FOR THE WRITE STATEMENTS
    ILAV8 = INDEX(34) - INDEX(30) + ISTART
    IF(ILAV8>IEND .OR. INDEX(34)==1)ILAV8=IEND
    IFAV8 = ISTART
!--   COMPUTE THE VALUE OF THE BEGINNING VALUE OF THE I INDEX FOR AVERAGE2
!--      :35 FIRST YEAR OF AVERAGE2  :30 FIRST YEAR SIMULATED
    IFAV9 = INDEX(35) - INDEX(30) + ISTART
    IF(IFAV9<ISTART .OR. INDEX(34)==1)IFAV9=ISTART
    ILAV9 = INDEX(1) + (INDEX(30)-INDEX(27)) + 2
!--   COMPUTE AVERAGES FOR THREE PERIODS IF DESIRED
    DO K = 1,NCROPS
        DO J = 1,NVARC
            DO I = 8,10
                AVGC(I,J,K) = 0.0
       END DO
         END DO
        DO J = 1,NVARX
            DO I = 8,10
                AVGX(I,J,K) = 0.0
       END DO
        END DO
    END DO
!--   DO SUMS

    DO K = 1,NCROPS
        DO J = 1,NVARC
            DO I = IFAV8,ILAV8
                AVGC(8,J,K) = AVGC(8,J,K) + C(NPT,I,J,K)
            END DO
            DO I = IFAV9,ILAV9
                AVGC(9,J,K) = AVGC(9,J,K) + C(NPT,I,J,K)
            END DO
            DO I = ISTART,IEND
                AVGC(10,J,K) = AVGC(10,J,K) + C(NPT,I,J,K)
            END DO
        END DO
        DO J = 1,NVARX
            DO I = IFAV8,ILAV8
                AVGX(8,J,K) = AVGX(8,J,K) + X(I,J,K)
            END DO
            DO I = IFAV9,ILAV9
                AVGX(9,J,K) = AVGX(9,J,K) + X(I,J,K)
            END DO
            DO I = ISTART,IEND
                AVGX(10,J,K) = AVGX(10,J,K) + X(I,J,K)
        END DO
        END DO
      END DO
      DO K = 1,NCROPS
        DO J = 1,NVARC
            AVGC(8,J,K) = AVGC(8,J,K)/(ILAV8-IFAV8+1)
            AVGC(9,J,K) = AVGC(9,J,K)/(ILAV9-IFAV9+1)
            AVGC(10,J,K) = AVGC(10,J,K)/(IEND-ISTART+1)
        END DO
        DO J = 1,NVARX
            AVGX(8,J,K) = AVGX(8,J,K)/(ILAV8-IFAV8+1)
            AVGX(9,J,K) = AVGX(9,J,K)/(ILAV9-IFAV9+1)
            AVGX(10,J,K) = AVGX(10,J,K)/(IEND-ISTART+1)
        END DO
    END DO
!--   INITIALIZE TO ZERO FOR ACCUMULATION
    DO K = 1,NLVSK
        DO J = 1,NVARS
            DO I = 8,10
                AVGS(I,J,K) = 0.0
            END DO
        END DO
        DO J = 1,NVARXS
            DO I = 8,10
                AVGXS(I,J,K) = 0.0
            END DO
        END DO
    END DO
!--   DO SUMS
    DO K = 1,NLVSK
        DO J = 1,NVARS
            DO I = IFAV8,ILAV8
                AVGS(8,J,K) = AVGS(8,J,K) + S(NPT,I,J,K)
            END DO
            DO I = IFAV9,ILAV9
                AVGS(9,J,K) = AVGS(9,J,K) + S(NPT,I,J,K)
            END DO
            DO I = ISTART,IEND
                AVGS(10,J,K) = AVGS(10,J,K) + S(NPT,I,J,K)
            END DO
        END DO
        DO J = 1,NVARXS
            DO I = IFAV8,ILAV8
                AVGXS(8,J,K) = AVGXS(8,J,K) + XS(NPT,I,J,K)
            END DO
            DO I = IFAV9,ILAV9
                AVGXS(9,J,K) = AVGXS(9,J,K) + XS(NPT,I,J,K)
            END DO
            DO I = ISTART,IEND
                AVGXS(10,J,K) = AVGXS(10,J,K) + XS(NPT,I,J,K)
            END DO
        END DO
    END DO
    DO K = 1,NLVSK
        DO J = 1,NVARS
            AVGS(8,J,K) = AVGS(8,J,K)/(ILAV8-IFAV8+1)
            AVGS(9,J,K) = AVGS(9,J,K)/(ILAV9-IFAV9+1)
            AVGS(10,J,K) = AVGS(10,J,K)/(IEND-ISTART+1)
        END DO
        DO J = 1,NVARXS
            AVGXS(8,J,K) = AVGXS(8,J,K)/(ILAV8-IFAV8+1)
            AVGXS(9,J,K) = AVGXS(9,J,K)/(ILAV9-IFAV9+1)
            AVGXS(10,J,K) = AVGXS(10,J,K)/(IEND-ISTART+1)
        END DO
    END DO
!--   INITIALIZE TO ZERO FOR ACCUMULATION
    DO K = 1,NPGA
        DO J = 1,NVARA
            DO I = 8,10
                AVGA(I,J,K) = 0.0
            END DO
        END DO
    END DO
    DO K = 1,NPGXA
        DO J = 1,NVARXA
            DO I = 8,10
                AVGXA(I,J,K) = 0.0
            END DO
        END DO
    END DO
!--   DO SUMS
    DO K = 1,NPGA
        DO J = 1,NVARA
            DO I = IFAV8,ILAV8
                AVGA(8,J,K) = AVGA(8,J,K) + A(NPT,I,J,K)
            END DO
            DO I = IFAV9,ILAV9
                AVGA(9,J,K) = AVGA(9,J,K) + A(NPT,I,J,K)
            END DO
            DO I = ISTART,IEND
                AVGA(10,J,K) = AVGA(10,J,K) + A(NPT,I,J,K)
            END DO
        END DO
    END DO
    DO K = 1,NPGXA
        DO J = 1,NVARXA
            DO I = IFAV8,ILAV8
                AVGXA(8,J,K) = AVGXA(8,J,K) + XA(I,J,K)
            END DO
            DO I = IFAV9,ILAV9
                AVGXA(9,J,K) = AVGXA(9,J,K) + XA(I,J,K)
            END DO
            DO I = ISTART,IEND
                AVGXA(10,J,K) = AVGXA(10,J,K) + XA(I,J,K)
            END DO
        END DO
    END DO
    DO K = 1,NPGA
        DO J = 1,NVARA
            AVGA(8,J,K) = AVGA(8,J,K)/(ILAV8-IFAV8+1)
            AVGA(9,J,K) = AVGA(9,J,K)/(ILAV9-IFAV9+1)
            AVGA(10,J,K) = AVGA(10,J,K)/(IEND-ISTART+1)
        END DO
    END DO
    DO K = 1,NPGXA
        DO J = 1,NVARXA
            AVGXA(8,J,K) = AVGXA(8,J,K)/(ILAV8-IFAV8+1)
            AVGXA(9,J,K) = AVGXA(9,J,K)/(ILAV9-IFAV9+1)
            AVGXA(10,J,K) = AVGXA(10,J,K)/(IEND-ISTART+1)
      END DO
      END DO
      RETURN
    END SUBROUTINE AVGVAL

!     Last change:  CH   10 Jul 2006    2:24 pm
    SUBROUTINE B2C
      IMPLICIT NONE

    !EIA add
     INTEGER :: NCROPS,NVARC,NLVSK,NVARS,NPRODS,NVARA,NYRSIM
     INTEGER :: IEND,LBEG,J,NVARPC,NPGA

!--                     **************
!--   ****************  B2C SUBROUTINE *******************
!--   ASSIGNS FIRST TWO OR MORE ROWS (YEARS) OF BASELINE MATRICES
!--          TO RESPECTIVE ROWS OF CALCULATED MATRICES
!--           THIS SUBROUTINE IS CALLED FROM MAIN.FOR
!--                **********************************
!--   FIRST 2 OR MORE YEARS OF:     TO:
!--                             AB      A
!--                             FB      F
!--                             B       C
!--                             SB      S
!--                             PB      PC
!--                             PNB     PNC
!--   AUXILLARY WRITE STATEMENTS (UNIT NO., 0 SCREEN, -1 OFF)

!--             NUMBER OF MODEL CROPS IN POLYSYS
    NCROPS = INDEX(2)
!--             NUMBER OF VARIABLES IN C
    NVARC = INDEX(3)
!--             NUMBER OF LIVESTOCK COMM. IN POLYSYS
    NLVSK = INDEX(5)
!--             NUMBER OF VARIABLES IN S (LIVESTOCK)
    NVARS = INDEX(6)
!--             NUMBER OF PRODUCTS IN POLYSYS
    NPRODS = INDEX(43)
!--             NUMBER OF VARIABLES IN PC (PRODUCTS)
    NVARPC = INDEX(45)
!--             NUMBER OF PAGES IN A
    NPGA = INDEX(12)
!--             NUMBER OF VARIABLES IN A
!--             NUMBER OF YEARS TO SIMULATE
    NYRSIM = INDEX(1)
    NVARA = INDEX(13)
    LBEG = INDEX(30)-INDEX(27)+2
    IEND = NYRSIM+(INDEX(30)-INDEX(27))+2

!--
    DO I = 1,LBEG
        DO J = 1,NVARC
            DO K = 1,NCROPS
                C(NPT,I,J,K) = B(I,J,K)
            END DO! End of K Loop
        END DO        ! End of J Loop
        DO J = 1,NVARS
            DO K = 1,NLVSK
                S(NPT,I,J,K) = SB(I,J,K)
            END DO! End of K Loop
        END DO        ! End of J Loop
        DO J = 1,NVARA
            DO K = 1,NPGA
                A(NPT,I,J,K) = AB(I,J,K)
            END DO! End of K Loop
        END DO        ! End of J Loop
        DO J = 1,20
            DO K = 1,NCROPS
                GC(NPT,I,J,K) = GB(I,J,K)
            END DO! End of K Loop
        END DO        ! End of J Loop
        DO J = 1,8
            DO K = 1,NCROPS
                XGC(I,J,K) = XGB(I,J,K)
            END DO! End of K Loop
        END DO        ! End of J Loop
        DO J = 1,NVARPC
            DO K = 1,NPRODS
                PC(NPT,I,J,K) = PB(I,J,K)
            END DO! End of K Loop
        END DO       ! End of J Loop
        DO J=1,5
            PNC(I,J)=PNB(I,J)
        END DO
        DO J=1,4
            SGC(I,J)=SGB(I,J)
        END DO
        DO J=1,13
            DO K=1,3
                SAU(I,J,K)=SAUB(I,J,K)
            END DO
        END DO
    !c         DO K = 1,NCROPS
    !c            WP(I,K) = WPB(I,K)
    !c         END DO
    END DO   ! End of I Loop
!--   THE C OR COMPUTED F-O-R AND CCC VARIABLE LEVELS
!--   BEGIN THE SIMULATION PROCESS EQUAL TO THEIR
!--   RESPECTIVE B OR BASELINE VALUES (EXCEPT FOR THE
!--   TWO YEARS PREVIOUS TO THE BEGINNING SIMULATION
!--   YEAR, C VALUES ARE USUALLY ZERO PRIOR TO THE
!--   SIMULATION.
    DO K=1,NCROPS
        DO I = 1,IEND
            C(NPT,I,15,K) = B(I,15,K)       ! SETS F-O-R C EQUAL TO F-O-R B
            C(NPT,I,16,K) = B(I,16,K)       ! SETS CCC C EQUAL TO CCC B.
        END DO
    END DO
    RETURN
    END SUBROUTINE B2C

    !     Last change:  Update from UT 2019
        SUBROUTINE BIODIESTRADE
        IMPLICIT NONE


    !-- ******************* ETHTRADE SUBROUTINE *********************
    !--                     *****************
    !--             ***** THIS FIGURES ETHANOL AND BIODIESEL TRADE****
    !--                 ** IT ALSO FIGURES CORN GRAIN AND SOYBEAN DEMANDS****
    !--           ******************************
    !--           * THIS ROUTINE IS CALLED FROM:
    !--           * GRAINS
    !--           * STKCHK
    !-- *****************************************
    !--
        IF(INDEX(101) == 2)THEN   !IF USING THE NEW BIOENEGY TRADE MODULE  FIGURING EXPORTS AND IMPORTS
        !--
        !--   ************************************************************************************
            IF(INDEX(106) == 1)THEN !BASELINE
    !--         **SOY TO PALM OIL RATIO**
                TRDVARB(I,9) = B(I,9,6)/TRDVARB(I,8)  !SOY OIL PRICE / PALM OIL PRICE (Update from UT 2019)

                IF(INDEX(114) == 1)THEN
                !--         ** BIODIESEL EXPORTS **
                !--           EXPORTS (MIL GAL) = B0 + B1*ARGENTINA BIOD PROD + B2*SOYOILTOPALMOIL RATIO
                    BTRDB(I,1,6) = 1100 &
                    + (-0.00023 * TRDVARB(I,7))   & !ARGENTINA BIOD PROD LEVEL
                    + (-29316 * TRDVARB(I,9))  !SOY TO PALM OIL RATIO (FIGURED ABOVE)  !ENDOGENOUS
                !--
                !--         ** BIODIESEL IMPORTS **
                !--           IMPORTS (MIL GAL) = B0 + B1*YEAR + B2*RFS_BIODIESEL
                    BTRDB(I,2,6) = -207.77 &
                    + (368.4707 * TRDVARB(I,6))  !RFS_BIODIESEL
                !--
                ENDIF
            !--
            !--         ** TOTAL ETHANOL PRODUCTION **
            !--           TOTAL PRODUCTION = BASELINE - CHANGEINIMPORTS + CHANGEINEXPORTS
                BTRDB(I,3,6) = XB(I,05,6) * BIOPRD(I,30) ! MIL BUSHELS FOR BIODIESEL * GAL/BU = MIL GAL
           !     ** TOTAL SOYBEAN DEMAND FROM ETHANOL **
                XB(I,05,6) = BTRDB(I,3,6)/BIOPRD(I,30)  !MAKE SURE OF UNITS HERE   !GALLONS OF ETHANOL / GALLONS PER BUSHEL = BUSHELS (Update from UT 2019)
            !--
                XB(I,45,6) = BTRDB(I,1,6)/BIOPRD(I,30) !SOYBEAN DEMAND FOR EXPORTS (X45 USED FOR IMPORTS BELOW)
                XB(I,44,6) = XB(I,05,6)-XB(I,45,6)     !SOYBEAN DEMAND FOR DOMESTIC ETH CONSUMPTION
            ENDIF
        !--    ***********************************************************************************
        !--    ***FIRST FIGURE ENDOGENOUS TRADE VARIABLES (TRDVAR) FOR THE EQUATIONS TO MAKE SURE IN RIGHT
        !--
        !--         **SOY  TO PALM OIL RATIO**
            TRDVAR(I,9) = C(NPT,I,9,6)/TRDVAR(I,8)  !SOY OIL PRICE / PALM OIL PRICE
        !--
        !--  *****NOW COMPUTE TRADE EQUATIONS *****************
        !--
        !--         ** BIODIESEL EXPORTS **
        !--           EXPORTS (MIL GAL) = B0 + B1*ARGENTINA BIOD PROD + B2*SOYOILTOPALMOIL RATIO
            BTRD(I,1,6) = BTRDB(I,1,6) &
            + (-0.00023 * (TRDVAR(I,7)-TRDVARB(I,7)))   & !ARGENTINA BIOD PROD LEVEL
            + (-29316 * (TRDVAR(I,9)-TRDVARB(I,9)))  !SOY TO PALM OIL RATIO (FIGURED ABOVE)  !ENDOGENOUS
             IF (BTRDFIX(I,1,6).GT.0.0) BTRD(I,1,6)=BTRDFIX(I,1,6)  ! (update from UT 2019)
            IF (BTRD(I,1,6).LE.0.0) BTRD(I,1,6)=0.0                          ! (update from UT 2019)
        !--
        !--         ** BIODIESEL IMPORTS **
        !--           IMPORTS (MIL GAL) = B0 + B1*YEAR + B2*RFS_BIODIESEL
            BTRD(I,2,6) = BTRDB(I,2,6) &
            + (368.4707 * (TRDVAR(I,6)-TRDVARB(I,6)))  !RFS_BIODIESEL
              IF (BTRDFIX(I,2,6).GT.0.0) BTRD(I,2,6)=BTRDFIX(I,2,6) ! (update from UT 2019)
            IF (BTRD(I,2,6).LE.0.0) BTRD(I,2,6)=0.0 ! (update from UT 2019)
        !--
        !--      ** TOTAL BIODIESEL PRODUCTION **
        !--         TOTAL PRODUCTION = BASELINE - CHANGEINIMPORTS + CHANGEINEXPORTS
            BTRD(I,3,6) = BTRDB(I,3,6) &
            - (BTRD(I,2,6)-BTRDB(I,2,6)) &
            + (BTRD(I,1,6) - BTRDB(I,1,6))

        !--      ** TOTAL SOYBEAN DEMAND FROM ETHANOL **
            X(I,05,6) = BTRD(I,3,6)/BIOPRD(I,30)  !MAKE SURE OF UNITS HERE   !GALLONS OF ETHANOL / GALLONS PER BUSHEL =
        !c          X(I,05,1) = BTRDB(I,3,1)/BIOPRD(I,27)
            X(I,45,6) = BTRD(I,1,6)/BIOPRD(I,30) !SOYBEAN DEMAND FOR EXPORTS (X45 USED FOR IMPORTS BELOW)
            X(I,44,6) = X(I,05,6)-X(I,45,6)  !SOYBEAN DEMAND FOR DOMESTIC ETH CONSUMPTION
            X(I,46,6)=X(I,44,6)*BIOPRD(I,30)/1000 ! DOM ETH=MIL BU*GAL/BU
            X(I,48,6)=BTRD(I,3,6)/1000 ! TOT ETH PRODUCTION
            X(I,47,6)=BTRD(I,2,6)/1000    ! IMPORT ETHANOL
            X(I,49,6)=X(I,46,6)+X(I,47,6)    !DOMESTIC ETHANOL DEMAND (DOMESTIC PRODCUTION + IMPORTS)
            X(I,50,6)=BTRD(I,1,6)/1000   !ETHANOL DEMAND FOR EXPORT
        !--
            X(I,02,6)= XB(I,02,6) + (X(I,05,6)-XB(I,05,6)) !THIS IS THE DIFFERENCE FROM BASELINE THAT WILL IMPACT TOTAL USE IN GRAINS.FOR !(update from UT 2019)

        ENDIF  !INDEX(101) IF STATEMENT
        RETURN
        END SUBROUTINE BIODIESTRADE

    !     Last change:  Update from UT 2019
        SUBROUTINE BIOHARV
        IMPLICIT NONE

        INTEGER :: IH
        !EIA add
        INTEGER :: IR, IV, H, J
    !--
    !--    FIGURE BIOMASS HARVEST COSTS AND SUM TOTAL COSTS OF PRODUCTION
    !--
    !--    FIGURE SWITCHGRASS HARVEST COSTS AND TOTAL COSTS
    !--
        DO K=1,5
            IF(K == 1)IH=71   !cost categories
            IF(K == 3)IH=61
            IF(K == 4)IH=39  !?MISCANTHUS?
        !--

            IR = 100 !30   !NOW THE ROTATION PERIOD EQUALS 100 TO MATCH THE PLANNING PERIOD IN THE NET PRESENT VALUE CALCULATIONS
        !c        IR=IRTLN(8+K)    !rotation periods
        !c        IF(K.GE.4)THEN
        !c          IR=IRTLN(12+K)
        !c        ENDIF
        !--
            DO T=1,3
                IF(K <= 3)THEN
                    CY(28,8+K,T,CTY)=0.0 !sum harv costs all years
                    CY(29,8+K,T,CTY)=0.0 !sum yield all years
                    CYX(23,8+K,T,CTY)=0.0   !SET PER ACRE TOTAL COSTS TO ZERO
                    CYX(24,8+K,T,CTY)=0.0   !SET VARIABLE COSTS TO ZERO
                ELSE
                    CY(28,12+K,T,CTY)=0.0
                    CY(29,12+K,T,CTY)=0.0
                    CYX(23,12+K,T,CTY)=0.0
                    CYX(24,12+K,T,CTY)=0.0
                ENDIF

            ENDDO !T LOOP
        !--
        !--    HARVEST COSTS INFLATED IN INFLATEBIO
        !--
        !--
        !--
        !--
        ! c      WRITE(*,*)harvc(2,3,k),'harvc in bioharv',i,k,j
            DO IV=1,IR !20 !IR    !SHOULD BE 10 FOR SWITCHRASS
            !--
                IF(K == 2)THEN     !POPLAR HARVEST COSTS FIXED FOR NOW
                    IF(INDEX(115) == 1)THEN
                        CMX(IV,20,K,CTY)=HARVESTCOST(k,CTY)*CMX(IV,22,K,CTY)/RRR(10,CTY)       & !$/DT COST * %MATUREYIELD * MATURE YIELD (update from UT 2019)
                        * CYX(25,10,1,CTY)                           !take 1/rrr of the yield multiplier because only harvest 1/rrr of acre at a time (RRR is the harvest schedule period)
                    ELSE
                        CMX(IV,20,K,CTY)=HARVESTCOST(k,CTY)*CMX(IV,22,K,CTY)       & !$/DT COST * %MATUREYIELD * MATURE YIELD
                        * CYX(25,10,1,CTY)
                    ENDIF
                !--
                ELSEIF(K == 3)THEN !WILLOW
                    IF(INDEX(115) == 1)THEN
                        CMX(IV,20,K,CTY) = HARVESTCOST(k,CTY)*CMX(IV,22,K,CTY)       & !$/DT COST * %MATUREYIELD * MATURE YIELD
                         /RRR(11,CTY)* CYX(25,11,1,CTY)                         !take 1/4 of the yield multiplier because only harvest 1/4 of acre at a  (update from UT 2019)

                    ELSE
                        CMX(IV,20,K,CTY) = HARVESTCOST(k,CTY)*CMX(IV,22,K,CTY)      & !$/DT COST * %MATUREYIELD * MATURE YIELD
                        * CYX(25,11,1,CTY)
                    ENDIF


                !--
                ELSEIF(K == 5)THEN !ENERGY CANE     !!!!harvest costs are zero now!!! no 'twine' apparently in ecane harvest
                    CMX(IV,20,K,CTY) = HARVESTCOST(k,CTY)*CMX(IV,22,K,CTY)       & !$/DT COST * %MATUREYIELD * MATURE YIELD
                    * CYX(25,17,1,CTY)
                !--
                ELSEIF(K == 1)THEN !SWITCHGRASS
                !--       ASSIGN YIELD ADJUSTED COST OF PRODUCTION
                    DO H=1,IH                                           !NUMBER OF DIFFERENT COSTS BASED ON YIELD/AC
                        IF((CYX(25,8+K,1,CTY)*CMX(IV,22,K,CTY)) <= HARVC(H,1,K))THEN           !IF HARVESTABLE YIELD IS LESS THAN OR EQUAL TO YIELD IN ONE OF 50 COST STRUCTURES
                            IF(CYX(2,1,1,CTY).LE.37.or.index(117).ge.1) THEN                 !FIND RIGHT REGION AND ASSIGN COST OF PRODUCTION.
                                CMX(IV,20,K,CTY)=HARVC(H,2,K)*CYX(25,8+K,1,CTY) &
                                *CMX(IV,22,K,CTY)    !NE... 2
                                GOTO 43                                         !GOT IT, SO NO NEED TO GO FURTHER...EXIT LOOP

                            ELSEIF(CYX(2,1,1,CTY) <= 67)THEN
                                CMX(IV,20,K,CTY)=HARVC(H,3,K)*CYX(25,8+K,1,CTY) &
                                *CMX(IV,22,K,CTY)  !APP
                                GOTO 43
                            ELSEIF(CYX(2,1,1,CTY) <= 92)THEN
                                CMX(IV,20,K,CTY)=HARVC(H,4,K)*CYX(25,8+K,1,CTY) &
                                *CMX(IV,22,K,CTY)   !SE
                                GOTO 43
                            ELSEIF(CYX(2,1,1,CTY) <= 119)THEN
                                CMX(IV,20,K,CTY)=HARVC(H,5,K)*CYX(25,8+K,1,CTY) &
                                *CMX(IV,22,K,CTY)    !del
                                GOTO 43
                            ELSEIF(CYX(2,1,1,CTY) <= 164)THEN
                                CMX(IV,20,K,CTY)=HARVC(H,6,K)*CYX(25,8+K,1,CTY) &
                                *CMX(IV,22,K,CTY)    !cb
                                GOTO 43
                           ELSEIF(CYX(2,1,1,CTY) <= 191)THEN
                               CMX(IV,20,K,CTY)=HARVC(H,7,K)*CYX(25,8+K,1,CTY) &
                                *CMX(IV,22,K,CTY)    !ls
                                GOTO 43
                            ELSEIF(CYX(2,1,1,CTY) <= 226)THEN
                                CMX(IV,20,K,CTY)=HARVC(H,8,K)*CYX(25,8+K,1,CTY) &
                                *CMX(IV,22,K,CTY)    !np
                                GOTO 43
                            ELSEIF(CYX(2,1,1,CTY) <= 250)THEN
                                CMX(IV,20,K,CTY)=HARVC(H,9,K)*CYX(25,8+K,1,CTY) &
                                *CMX(IV,22,K,CTY)    !sp
                                GOTO 43
                            ELSEIF(CYX(2,1,1,CTY) <= 287)THEN
                                CMX(IV,20,K,CTY)=HARVC(H,10,K)*CYX(25,8+K,1,CTY) &
                                *CMX(IV,22,K,CTY)   !MNT
                                GOTO 43
                            ELSEIF(CYX(2,1,1,CTY) <= 305)THEN
                                CMX(IV,20,K,CTY)=HARVC(H,11,K)*CYX(25,8+K,1,CTY) &
                                *CMX(IV,22,K,CTY)   !PNW
                                GOTO 43
                            ELSE
                                WRITE(*,*)'CANNOT FIND REGION OF POLYREGION', &
                                CYX(2,1,1,CTY)
                                PAUSE
                            ENDIF
                        ENDIF
      END DO
                !--
                !--
                ELSEIF(K == 4)THEN !MISCANTHUS
                !--       ASSIGN YIELD ADJUSTED COST OF PRODUCTION
                    DO H=1,IH                                           !NUMBER OF DIFFERENT COSTS BASED ON YIELD/AC
                        IF((CYX(25,16,1,CTY)*CMX(IV,22,K,CTY)) <= HARVC(H,1,4))THEN           !IF HARVESTABLE YIELD IS LESS THAN OR EQUAL TO YIELD IN ONE OF 50 COST STRUCTURES
     !                       IF(CYX(2,1,1,CTY) <= 37) THEN                 !FIND RIGHT REGION AND ASSIGN COST OF PRODUCTION.
                             IF(CYX(2,1,1,CTY).LE.37.or.index(117).ge.1) THEN                 !FIND RIGHT REGION AND ASSIGN COST OF PRODUCTION.
                                CMX(IV,20,K,CTY)=HARVC(H,2,4)*CYX(25,16,1,CTY) &
                                *CMX(IV,22,K,CTY)    !NE... 2
                                GOTO 43                                         !GOT IT, SO NO NEED TO GO FURTHER...EXIT LOOP

                            ELSEIF(CYX(2,1,1,CTY) <= 67)THEN
                                CMX(IV,20,K,CTY)=HARVC(H,3,4)*CYX(25,16,1,CTY) &
                                *CMX(IV,22,K,CTY)  !APP
                                GOTO 43
                            ELSEIF(CYX(2,1,1,CTY) <= 92)THEN
                                CMX(IV,20,K,CTY)=HARVC(H,4,4)*CYX(25,16,1,CTY) &
                                *CMX(IV,22,K,CTY)   !SE
                                GOTO 43
                            ELSEIF(CYX(2,1,1,CTY) <= 119)THEN
                                CMX(IV,20,K,CTY)=HARVC(H,5,4)*CYX(25,16,1,CTY) &
                                *CMX(IV,22,K,CTY)    !del
                                GOTO 43
                            ELSEIF(CYX(2,1,1,CTY) <= 164)THEN
                                CMX(IV,20,K,CTY)=HARVC(H,6,4)*CYX(25,16,1,CTY) &
                                *CMX(IV,22,K,CTY)    !cb
                                GOTO 43
                            ELSEIF(CYX(2,1,1,CTY) <= 191)THEN
                                CMX(IV,20,K,CTY)=HARVC(H,7,4)*CYX(25,16,1,CTY) &
                                *CMX(IV,22,K,CTY)    !ls
                                GOTO 43
                            ELSEIF(CYX(2,1,1,CTY) <= 226)THEN
                                CMX(IV,20,K,CTY)=HARVC(H,8,4)*CYX(25,16,1,CTY) &
                                *CMX(IV,22,K,CTY)    !np
                                GOTO 43
                            ELSEIF(CYX(2,1,1,CTY) <= 250)THEN
                                CMX(IV,20,K,CTY)=HARVC(H,9,4)*CYX(25,16,1,CTY) &
                                *CMX(IV,22,K,CTY)    !sp
                                GOTO 43
                            ELSEIF(CYX(2,1,1,CTY) <= 287)THEN
                                CMX(IV,20,K,CTY)=HARVC(H,10,4)*CYX(25,16,1,CTY) &
                                *CMX(IV,22,K,CTY)   !MNT
                                GOTO 43
                            ELSEIF(CYX(2,1,1,CTY) <= 305)THEN
                                CMX(IV,20,K,CTY)=HARVC(H,11,4)*CYX(25,16,1,CTY) &
                                *CMX(IV,22,K,CTY)   !PNW
                                GOTO 43
                            ELSE
                                WRITE(*,*)'CANNOT FIND REGION OF POLYREGION', &
                                CYX(2,1,1,CTY)
                                PAUSE
                            ENDIF
                        ENDIF
                    END DO
                !--
                ELSE
                    CONTINUE
                ENDIF  !END OF K IF STATEMENT
            !--
                43 CONTINUE
            !--
            !--    **APPLY ANY HARVEST EFFICIENCY GAINS THAT ARE ASSUMED TO BE MADE**(IN FILE BIOEFFICIENCY.PRN) !CALCULATED NEW EVERY LOOP, SO NO WORRY OF ESCALATION IN MULTIPLE PRICE LOOPS
                IF(K == 1 .OR. K == 2 .OR. K == 3)THEN
                    CMX(IV,20,K,CTY)=CMX(IV,20,K,CTY)*BIOEF(I,K+8) !SWITCGHRASS,POPLARS,WILLOWS
                ELSEIF(K == 4 .OR. K == 5)THEN
                    CMX(IV,20,K,CTY)=CMX(IV,20,K,CTY)*BIOEF(I,12+K) !MISCAN,ECANE
                ENDIF
            !--
            !--   ***NUTRIENT REPLACEMENT COSTS***   !!!!!!PUTTING IN CMX(IV, 14  FOR NOW,  WHICH IS OFFICIALLY 'IRRIGATION' BUT EMPTY SO USING UNTIL CAN EXPAND THE MATRIX TO MAKE ROOM!!!!!!!!!!!!
            !--
            !--     !ENERGY CANE (kk=5 or k=17
                IF(CMX(IV,22,5,CTY)*CYX(25,17,1,CTY)>1)THEN                 !ADD NUTRIENT REPLACMENT COSTS IF YIELD ABOVE 1 DRY TON. NUT(...) IS IN $ PER DT
                    CMX(IV,14,5,CTY) = (                                       & !CMX(IV,'9'= MIX NUTRIENT COSTS
                    (CMX(IV,22,5,CTY)*CYX(25,17,1,CTY)-1)*NUT(17,6))        !nut(crop k, region (using region 6 for all now)
                ENDIF
            ! SWITCHGRASS (kk=1 or k=9)
                IF(CMX(IV,22,1,CTY)*CYX(25,9,1,CTY)>1)THEN
                    CMX(IV,14,1,CTY) = ( &
                    (CMX(IV,22,1,CTY)*CYX(25,9,1,CTY)-1)*NUT(9,6))




                ENDIF
            ! MISCANTHUS (kk=4 or k=16)
                IF(CMX(IV,22,4,CTY)*CYX(25,16,1,CTY)>1)THEN
                    CMX(IV,14,4,CTY) = ( &
                    (CMX(IV,22,4,CTY)*CYX(25,16,1,CTY)-1)*NUT(16,6))
                ENDIF
            !       !PASTURE INTENSIFICATION
            !      IF(CMX(IV,22,17,CTY)*CYX(25,17,1,CTY)>1)THEN
            !         CMX(IV,9,17,CTY) = CMX(IV,9,17,CTY) +
            !     1        (CMX(IV,22,K,CTY)*CYX(25,17,1,CTY)*NUT(17,6))
            !      ENDIF

            !-- *** TOTAL COSTS OF PRODUCTION CALCULATED HERE ***
                CMX(IV,21,K,CTY)=0.0
                DO J=1,20
                !(Update from UT 2019)
                    CMX(IV,21,K,CTY)=CMX(IV,21,K,CTY)+CMX(IV,J,K,CTY)  * (1+BIOCOSTADJ(I,k))    !TOTAL COSTS PER ACRE ;BIOCOSTADJ(K) IS A PERCENT CHANGE IN TOTAL COSTS ENTERED IN WHATIFUS!!
                END DO
            !--
            !--
            !--
                DO T=1,3
                    IF(K <= 3)THEN !swichgrass, poplars, willows
                    !--       PER ACRE TOTAL COSTS
                        CYX(23,8+K,T,CTY) = CYX(23,8+K,T,CTY)+CMX(IV,21,K,CTY)/IR  !FIGURE ANNUAL AVERAGE OVER COMPLETE ROTATION



                    !--                                                                  !COSTS WILL BE THE SAME FOR ALL LAND USE TYPES (T=LAND USE FOR BIOMASS CROPS)
                    !--       PER ACRE VARIABLE COSTS
                        CYX(24,8+K,T,CTY) = CYX(24,8+K,T,CTY) + &
                        (CMX(IV,21,K,CTY) - CMX(IV,16,K,CTY)-CMX(IV,17,K,CTY)- &
                        CMX(IV,18,K,CTY)-CMX(IV,19,K,CTY))/IR
                    !--
                    !--       SUM HARVEST COSTS PER ACRE OVER ALL YEARS (FOR GROWER PAYMENT)
                        CY(28,8+K,T,CTY) = CY(28,8+K,T,CTY) &
                        + CMX(IV,20,K,CTY)                                   !PER ACRE HARVEST COSTS SUMMED OVER ALL YEARS
                    !--
                    !--       SUM HARVESTED YIELD OVER ALL YEARS (FOR GROWER PAYMENT)
                        IF(K == 1)THEN
                            CY(29,8+K,T,CTY) = CY(29,8+K,T,CTY) &
                            + CYX(25,8+K,1,CTY) * CMX(IV,22,K,CTY)  !yield * yield efficiency
                        ELSEIF(K == 2)THEN
                            IF(INDEX(115) == 1)THEN
                                CY(29,8+K,T,CTY) = CY(29,8+K,T,CTY) &
                                + CYX(25,8+K,1,CTY)*CMX(IV,22,K,CTY)/RRR(10,CTY)   !!fix here incremental jan 2016; (update from UT 2019)
                            ELSE
                                CY(29,8+K,T,CTY) = CY(29,8+K,T,CTY) &
                                + CYX(25,8+K,1,CTY)*CMX(IV,22,K,CTY)
                            ENDIF
                        !--
                        ELSEIF(K == 3)THEN
                            IF(INDEX(115) == 1)THEN
                                CY(29,8+K,T,CTY) = CY(29,8+K,T,CTY) &
                                + CYX(25,8+K,1,CTY)*CMX(IV,22,K,CTY)/RRR(10,CTY)   !!fix here incremental jan 2016 (update from UT 2019)
                            ELSE
                                CY(29,8+K,T,CTY) = CY(29,8+K,T,CTY) &
                                + CYX(25,8+K,1,CTY)*CMX(IV,22,K,CTY)
                            ENDIF
                        ENDIF
                    !--
                    !--
                    ELSE !IF(K == 4 .OR. K == 5)THEN  !miscanthus,ecane
                    !--        PER ACRE total COSTS
                        CYX(23,12+K,T,CTY) = CYX(23,12+K,T,CTY)+CMX(IV,21,K,CTY)/IR
                    !--       PER ACRE VARIABLE COSTS
                        CYX(24,12+K,T,CTY) = CYX(24,12+K,T,CTY) + &
                        (CMX(IV,21,K,CTY) - CMX(IV,16,K,CTY)-CMX(IV,17,K,CTY)- &
                        CMX(IV,18,K,CTY)-CMX(IV,19,K,CTY))/IR
                    !--        SUM HARVEST COSTS PER ACRE OVER ALL YEARS (FOR GROWER PAYMENT)
                        CY(28,12+K,T,CTY) = CY(28,12+K,T,CTY) &
                        + CMX(IV,20,K,CTY)
                    !--        SUM HARVESTED YIELD OVER ALL YEARS (FOR GROWER PAYMENT)
                        CY(29,12+K,T,CTY) = CY(29,12+K,T,CTY) &
                        + CYX(25,12+K,1,CTY) * CMX(IV,22,K,CTY)
                    ENDIF

                ENDDO !T LOOP
            !--
            ENDDO  !IV LOOP
        !--
        !--     **FIGURE GROWER PAYMENTS AT END OF PASTLP.FOR**
        !--
        ENDDO  !END OF k LOOP
    !--
    !--
        RETURN
        END SUBROUTINE BIOHARV

        SUBROUTINE BIOPROD1
       IMPLICIT NONE

    !--
    !--    THIS WILL SEE WHAT DEMAND SHOULD BE BASED ON PRICE OF BIOPRODUCT
    !--
    !--    ELECTRICITY
        BIODMND(I,1) = BIOPRD(I,1)*1000000000
    !--    ETHANOL
        BIODMND(I,2) = BIOPRD(I,2)*1000000000
    !--    BIODIESEL
        BIODMND(I,3) = BIOPRD(I,3)*1000000000
    !--    LEVULINIC ACID
    !c         IF(NEWPRC.LT.56)THEN
    !c           BIODMND(I,4) = BIOPRD(I,4)*1000000
    !c         ELSEIF(NEWPRC.GE.56)THEN
    !c           BIODMND(I,4) = BIOPRD(I,5)*1000000
    !c         ENDIF
    !c         IF(NEWPRC.GE.66)THEN
    !c           BIODMND(I,4) = BIOPRD(I,6)*1000000
    !c         ENDIF
    !--    SUCCINIC ACID
    !c         IF (NEWPRC.LT.40) THEN
    !c           BIODMND(I,5) = BIOPRD(I,7)*1000000
    !c         ELSE
    !c          BIODMND(I,5) = BIOPRD(I,8)*1000000
    !c         ENDIF
    !--    LACTIC ACID
        BIODMND(I,6) = BIOPRD(I,9)*1000000
    !--    PDO
    !--    CORN GRAIN FOR ETHANOL DEMAND FOR PERLACK
        BIODMND(I,7) = BIOPRD(I,10)*1000000000
    !--
    !C       BIOSPLY(I,7) = BIODMND(I,7)           !SINCE PREFILLED IN WHATIF.FOR
    !C       BIOSPLY(I,5) = BIODMND(I,5)
    !C       BIOSPLY(I,6) = BIODMND(I,6)
    !--
    !--      FACTORS TO COMPUTE BIODIESEL FROM BEEF
        BF2BD(2) =  0.0
        BF2BD(3) =  0.003758925
        BF2BD(4) =  0.003758925
        BF2BD(5) =  0.003758925
        BF2BD(6) =  0.003758925
        BF2BD(7) =  0.003758925
        BF2BD(8) =  0.00451071
        BF2BD(9) =  0.005262495
        BF2BD(10) = 0.00601428
        BF2BD(11) = 0.006766065
        BF2BD(12) = 0.00751785
        BF2BD(13) = 0.008269635
        BF2BD(14) = 0.00902142
        BF2BD(15) = 0.009773205
        BF2BD(16) = 0.01052499
        BF2BD(17) = 0.011276775
        BF2BD(18) = 0.01202856
        BF2BD(19) = 0.012780345
        BF2BD(20) = 0.01353213
        BF2BD(21) = 0.014283915
        BF2BD(22) = 0.0150357
        BDFBF(I)  = BF2BD(I) * S(NPT,I,58,1) * 1000000.0
    !--
    !--      FACTORS TO COMPUTE BIODIESEL FROM FOOD
    !--
        POPULATION(2) = 295530.5
        POPULATION(3) = 298211.6
        POPULATION(4) = 300892.7
        POPULATION(5) = 303573.8
        POPULATION(6) = 306254.9
        POPULATION(7) = 308936
        POPULATION(8) = 311622.9
        POPULATION(9) = 314309.8
        POPULATION(10) = 316996.7
        POPULATION(11) = 319683.6
        POPULATION(12) = 322301.9596
        POPULATION(13) = 325010.8665
        POPULATION(14) = 327719.7735
        POPULATION(15) = 330428.6805
        POPULATION(16) = 333137.5875
        POPULATION(17) = 335846.4945
        POPULATION(18) = 338555.4014
        POPULATION(19) = 341356.0537
        POPULATION(20) = 344156.7061
        POPULATION(21) = 346957.3584
        POPULATION(22) = 349758.0107
    !--
        FD2BD(2)  = 0.0
        FD2BD(3)  = 0.415296053
        FD2BD(4)  = 0.415296053
        FD2BD(5)  = 0.415296053
        FD2BD(6)  = 0.415296053
        FD2BD(7)  = 0.415296053
        FD2BD(8)  = 0.498355263
        FD2BD(9)  = 0.581414474
        FD2BD(10) = 0.664473684
        FD2BD(11) = 0.747532895
        FD2BD(12) = 0.830592105
        FD2BD(13) = 0.913651316
        FD2BD(14) = 0.996710526
        FD2BD(15) = 1.079769737
        FD2BD(16) = 1.162828947
        FD2BD(17) = 1.245888158
        FD2BD(18) = 1.328947368
        FD2BD(19) = 1.412006579
        FD2BD(20) = 1.495065789
        FD2BD(21) = 1.578125
        FD2BD(22) = 1.661184211
        BDFFD(I)  = FD2BD(I) * POPULATION(I)  * 1000.0
    !--
    !--      FACTORS TO COMPUTE BIODIESEL FROM POULTRY
    !--
        PL2BD(2)  = 0.0
        PL2BD(3)  = 0.002675726
        PL2BD(4)  = 0.002675726
        PL2BD(5)  = 0.002675726
        PL2BD(6)  = 0.002675726
        PL2BD(7)  = 0.002675726
        PL2BD(8)  = 0.003210871
        PL2BD(9)  = 0.003746017
        PL2BD(10) = 0.004281162
        PL2BD(11) = 0.004816307
        PL2BD(12) = 0.005351452
        PL2BD(13) = 0.005886598
        PL2BD(14) = 0.006421743
        PL2BD(15) = 0.006956888
        PL2BD(16) = 0.007492033
        PL2BD(17) = 0.008027179
        PL2BD(18) = 0.008562324
        PL2BD(19) = 0.009097469
        PL2BD(20) = 0.009632614
        PL2BD(21) = 0.01016776
        PL2BD(22) = 0.010702905
        BDFPL(I)  = PL2BD(I) * S(NPT,I,58,4)  * 1000000.0
    !--                                                                                                 ***biodiesel for other sources turned off for perlack (feb08)
    ! c         BIOSPLY(I,3) = BIODMND(I,3) + BDFBF(I) + BDFFD(I) + BDFPL(I) ! ADD BIODIESEL FROM SOYBEANS AND  BIODIESEL FROM OTHER SOURCES
    ! C         BIODMND(I,3) = BIOSPLY(I,3)        !biodiesel
    !--
    !c       BIOSPLY(I,2) = BIODMND(I,2)           !!!TAKE OUT...THIS IS FOR MAKING ALL ETHANOL FROM CORN GRAIN 9/7/05!!
    !--
    !C         EN(I,3,1) = NEWPRC       !CORN RES
    !C         EN(I,3,5) = NEWPRC       !WHEAT RES
        IF(i <= 3)  cfixed(i,9,9) = 0.0

      RETURN
        END SUBROUTINE BIOPROD1


    !     Update from UT 2019
        SUBROUTINE BIOTRACK
        IMPLICIT NONE

        REAL :: TTLPLNTD,SUMACRES,HARVESTP !,RESIDUAL(50,305)
        !EIA add
        INTEGER :: NCROPS,NBCROPS,IYEAR1,IA,KK

    !--   *****************************************************************************
    !--   This subroutine tracks the acres of switch,poplars,willows planted but not harvested as well
    !--   as any acres balance of it from previous years. The data is by POLYSYS region
    !--   The subroutine is called from RMAIN
    !--   *****************************************************************************
        NCROPS  = INDEX(2)                         ! Number of POLYSYS Crops
    !C      NBCROPS = 3                                ! Number of Biomass Crops
        IYEAR1  = INDEX(30)                        ! FIRST YEAR OF SIMULATION


    !--
        DO KK=1,3 !NBCROPS !SWITCH,POP,WILLOWS                                     !apl(..,2,..),bioage(...,...,2,...),etc..are for switchgrass in pasture (pastlp.for)
        !--
            CY(4,KK+8,1,CTY) = 0.0
            CY(2,KK+8,1,CTY) = 0.0
            AYL(I,KK,1,CTY) = CYX(25,KK+8,1,CTY)                             ! Storage yield corresponding to date
        !--                                                               ! of planting of biomass crops
            IA = 0
            DO WHILE ((I-IA-4) >= 0 .AND. IA < IRTLN(KK+8))                   ! chad changed from -4) 6/15/05!!!
                IA = IA + 1
                BIOAGE(I,IA,KK,1,CTY) =APL(NPT,I-IA+1,KK,1,CTY)                    ! Calculate Plantings by "Age".
                PRDAGE(I,IA,KK,1,CTY)=BIOAGE(I,IA,KK,1,CTY)*CMX(IA,22,KK,CTY)    & ! Calculate Production by "Age".    cmx(22..%harvest) ayl(mature yield)
                * AYL(I-IA+1,KK,1,CTY)
            !--
                IF(KK == 2 .AND. (I-RRR(10,CTY)) > 0.0)THEN !POPLARS YIELD IS ALWAYS THE YIELD EIGHT YEARS PREVIOUSLY
                    IF(IA < RRR(10,CTY))THEN
                        PRDAGE(I,IA,KK,1,CTY)=0.0
         ELSE
        ! write(*,*) 'debug rrr',rrr(10,cty),cty
                        PRDAGE(I,IA,KK,1,CTY)=BIOAGE(I,IA,KK,1,CTY)* &
                        CMX(rrr(10,cty),22,KK,CTY)* AYL(I-RRR(10,CTY)+1,KK,1,CTY)    !THIS IS TO MAKE PLANTINGS *ALWAYS* INCREMENTAL !!###make sure rrr(cty) is an integer!!
                        if(cty == 27 .AND. kk == 2)then
                        ! c        write(*,*)bioage(i,ia,kk,1,cty),cmx(rrr(cty),22,kk,cty),
                        ! c     1            ayl(i-rrr(cty)+1,kk,1,cty)
                        endif

            ENDIF
            ENDIF

            ! (update from UT 2019)
             IF(KK==3.AND.(I-RRR(11,CTY)).GT.0.0)THEN
                 IF(IA<RRR(11,CTY))THEN
                    PRDAGE(I,IA,KK,1,CTY)=0.0
                 ELSEIF(IA.GE.RRR(11,CTY).AND.IA.LT.(RRR(11,CTY)*2))THEN
                    PRDAGE(I,IA,KK,1,CTY)=BIOAGE(I,IA,KK,1,CTY)*  &
                       CMX(RRR(11,CTY),22,KK,CTY)* AYL(I-RRR(11,CTY)+1,KK,1,CTY)   !THIS IS TO MAKE PLANTINGS *ALWAYS* INCREMENTAL !YEAR 4 IN YEAR 4 TI 7
                 ELSEIF(IA.GE.RRR(11,CTY)*2)THEN
                   PRDAGE(I,IA,KK,1,CTY)=BIOAGE(I,IA,KK,1,CTY)* &
                      CMX(RRR(11,CTY),22,KK,CTY)* AYL(I-(RRR(11,CTY)*2)+1,KK,1,CTY)   !THIS IS TO MAKE PLANTINGS *ALWAYS* INCREMENTAL  !YEAR 8 IN ALL YEARS ABOVE
                 ENDIF
            ENDIF

            !--
                IF(PRDAGE(I,IA,KK,1,CTY)>0) THEN
                    CY(2,KK+8,1,CTY) = CY(2,KK+8,1,CTY)+BIOAGE(I,IA,KK,1,CTY)       ! Calculate Acres Harvested
         END IF
                CY(4,KK+8,1,CTY) = CY(4,KK+8,1,CTY) + PRDAGE(I,IA,KK,1,CTY)          ! Calculate Production by year

         END DO

        ENDDO
    !-- !!!!!END SWTCH,POP,WILLS / BEGIN MISCAN AND E.CANE
    !--
        DO KK=4,5 !miscanthus and Ecane                                   !apl(..,2,..),bioage(...,...,2,...),etc..are for switchgrass in pasture (pastlp.for)
        !--
            CY(4,KK+12,1,CTY) = 0.0
            CY(2,KK+12,1,CTY) = 0.0
            AYL(I,KK,1,CTY) = CYX(25,KK+12,1,CTY)                             ! Storage yield corresponding to date
        !--                                                                        ! of planting of biomass crops
            IA = 0
            DO WHILE ((I-IA-4) >= 0 .AND. IA<IRTLN(KK+12))                   ! chad changed from -4) 6/15/05!!!
                IA = IA + 1
                BIOAGE(I,IA,KK,1,CTY) =APL(NPT,I-IA+1,KK,1,CTY)                    ! Calculate Plantings by "Age".
                IF(BIOAGE(I,IA,KK,1,CTY) < 0.0)BIOAGE(I,IA,KK,1,CTY)=0.0
                PRDAGE(I,IA,KK,1,CTY)=BIOAGE(I,IA,KK,1,CTY)*CMX(IA,22,KK,CTY)   & ! Calculate Production by "Age".
                * AYL(I-IA+1,KK,1,CTY)
                IF(PRDAGE(I,IA,KK,1,CTY)>0) THEN
                    CY(2,KK+12,1,CTY) = CY(2,KK+12,1,CTY)+BIOAGE(I,IA,KK,1,CTY)       !Calculate Acres Harvested
                END IF
                CY(4,KK+12,1,CTY) = CY(4,KK+12,1,CTY) + PRDAGE(I,IA,KK,1,CTY)       !Calculate Production by year
            END DO
        !--
        !         IF(CY(4,KK+12,1,CTY).LT.0.0)THEN
        !             WRITE(*,*)'LESS ZERO',CY(4,KK+12,1,CTY),KK,CTY
        !                   WRITE(*,*)I,IA
        !      WRITE(*,*)CY(4,KK+12,1,CTY),PRDAGE(I,IA,KK,1,CTY)
        !      WRITE(*,*)BIOAGE(I,IA,KK,1,CTY),CMX(IA,22,KK,CTY),AYL(I,KK,1,CTY)
        !             PAUSE
        !          ENDIF
        ENDDO
    !--
      RETURN
        END SUBROUTINE BIOTRACK

    !     Last change:  CH   20 May 2009    3:35 pm

        SUBROUTINE CARB
        IMPLICIT NONE

        REAL ::  CY1HOLD,CY2HOLD,CY3HOLD,RESRED
        !EIA add
        INTEGER :: IISTART, NCROPS, J
    !--
        IISTART = INDEX(30) - INDEX(27) + 3
        NCROPS = INDEX(2)
        POLY=INDEX(63)
        CNTY=INDEX(33)
    !--
        DO CTY=1,CNTY
        !--
            DO K=1,NCROPS
            !--
                DO T=1,3
                !--
                !--        **SUM ENERGY AND EMISSION FOR ALL ACRES IN EACH CROP AND TILLAGE**
                    IF(INDEX(39) == 86)then
                        WRITE(*,*)'!WARNING! SIM 86 IS ONLY TO COMPUTE CARBON LIMT!'
                        PAUSE
                        IF(K == 8)THEN                                                 !SET ALL ACRES TO NOTILL TO GET LIMIT!!
                            CONTINUE
                        ELSE
                            CY1HOLD=CY(1,K,1,CTY)
                            CY2HOLD=CY(1,K,2,CTY)
                            CY3HOLD=CY(1,K,3,CTY)
                            CY(1,K,3,CTY)=CY(1,K,1,CTY)+CY(1,K,2,CTY)+CY(1,K,3,CTY)
                            CY(1,K,1,CTY)=0.0
                            CY(1,K,2,CTY)=0.0
                        ENDIF
                    ENDIF
                !--
                    DO J=10,21
                        CY(J,K,T,CTY) = CYX(J+16,K,T,CTY) * CY(1,K,T,CTY)               !EMISSIONPERACRE * PL ACRES
                        CY(J,K,4,CTY) = CY(J,K,4,CTY) + CY(J,K,T,CTY)
                    END DO
                !--
                !--
                    CARBRATE(14,1)=0.1
                !--

                !--       ***CARBON ACCUMULATION*** (soil and afforest)
                !C          RESRED=0.0
                    IF(RCNT(11,K,T,CTY) > 1.0)THEN  !RESRED=RCNTX(11,K,T,CTY)             !IF HARVESTING residues, THEN REDUCE RATE OF CARBON GAIN BY THIS..harvesting would likely lead to a LOSS of soil carbon
                        CY(25,K,T,CTY) = 0.0  !NOW no CARBON GAIN WITH RESIDUE REMOVAL (LIKELY A NET LOSS IN CARBON)
                    ELSE
                    !--
                        CY(25,K,T,CTY) = (BCARB(1,K,CTY)* &
                        (CARBRATE(K,T)                                & !* RESRED                                                                                   !!!!!@#$@#@#$%!!!
                        *(-0.5938*LOG(BCARB(1,K,CTY)*.2471)+1.65224) &
                        ) )                                                                   & !BASECARBONLEVEL * RATE OF ACCUMULATION * ADJUSTMENTFACTOR
                        * CY(1,K,T,CTY)                                 ! * SIMACRES
                    !C         IF(I.EQ.15.AND.K.EQ.14.AND.T.EQ.1.and.cy(1,k,t,cty).gt.0)THEN
                    !C         WRITE(*,*)CY(25,K,T,CTY),BCARB(1,K,CTY),CARBRATE(K,T),
                    !C     1             CY(1,K,T,CTY)
                    !C         PAUSE
                    !C         ENDIF
                    ENDIF
                !--
                !--       ***AFFORESTATION AND CROPLAND TO PASTURE CONVERSTION *** (add above ground to total)  !if t=1 then represents cropland to pasture conversion, if t=2or3 then afforestation
                    IF(K == 14)THEN
                        IF(T == 1)THEN                                 !CROPLAND TO PASTURE GAINS CARBON ONLY IN EAST !
                            CY(25,K,T,CTY) = CY(25,K,T,CTY) * EAST(CTY)
                        ELSEIF(K > 2 .AND. CY(1,K,T,CTY) > 0.0)THEN    !AFFORASTATION ABOVE GROUND CARBON
                            CY(25,K,T,CTY) = CY(25,K,T,CTY) &
                            + (CYX(25,K,T,CTY)*(2000/2200) * 0.5)         !YIELD * 0.5
                        ENDIF
                    ENDIF
                !--
                !--       ***COST OF CARBON PROGRAM*** or rather benefits to farmers!!
                    CY(26,K,T,CTY) = CY(1,K,T,CTY) &
                    *(INCENT(1,K,T,CTY)*0.9)            !10% MM&V
                !c     1                   * INCENT(1,K,T,CTY)                    !NOW USING NATIONAL LEVEL OF WEIGHTED AVG TO PAY
                !--       !!!!!!!!!!!!!!!!!!!!!!!!!!!!
                    IF(INDEX(39) == 86)then
                        IF(k /= 8)then
                            CY(1,K,1,CTY)=CY1HOLD
                            CY(1,K,2,CTY)=CY2HOLD
                            CY(1,K,3,CTY)=CY3HOLD
                        ENDIF
                    ENDIF
                !--       !!!!!!!!!!!!!!!!!!!!!!!!!!
                !c        IF(CY(25,K,T,CTY).LT.0.0)CY(25,K,T,CTY)=0.0
                !--
                   ! CYInew(K,T,CTY) = CY(1,K,T,CTY)
                     CYInew(NPT,I,K,T,CTY) = CY(1,K,T,CTY)  !CAPTURE YEARLY PLANTED ACRES FOR NEXT YEAR TO BEGIN WITH IN INPUT2LP !EIA CHAD 2017

                !--
             ENDDO
             ENDDO
        !--
        ENDDO
    !--
        RETURN
        END SUBROUTINE CARB

    !     Last change:  CH   22 May 2006    4:44 pm
        SUBROUTINE CENTER
        IMPLICIT NONE


        CHARACTER(10) :: BASENAME
        !EIA add
        INTEGER ISTART,IEND,II

    !--
        IF(I>13 .AND. INDEX(41)==0) THEN       !!THIS IS TO SET EQUAL TO BASELINE FOR EXTRA YEARS TAKE OUT
        !--
        !      XS=XSB
        !      XAG=XAGB
        !      XCR=XCRB
            S(NPT,I,61,1)=XSB(I,6,1)
            S(NPT,I,62,1)=XSB(I,5,1)
            S(NPT,I,63,1)=XSB(I,7,1)
            S(NPT,I,61,2)=XSB(I,1,2)
            S(NPT,I,63,2)=XSB(I,7,2)
            S(NPT,I,61,4)=XSB(I,1,4)
            S(NPT,I,61,5)=XSB(I,1,5)
        !--
        ENDIF
    !--                      *****************************
    !--                      ****** LIVESTOCK MODEL ******
    !--                      *****************************
    !--
    !--   This is the central simulation program which calls all subprograms of the
    !--   livestock model.  The baseline is read in "Livebase.for".
    !--
    !--
        ISTART=(INDEX(30)-INDEX(27))+3
        IEND = INDEX(1) +(INDEX(30)-INDEX(27)) + 2
    !--
    !      IF(INDEX(87).EQ.1)THEN
    !--
        IF(I == ISTART .AND. BIGITER == 1)THEN
        !--
            DO II=1,IEND
                IYEAR(II)=INDEX(30)-3+II          !SET YEAR RIGHT
            ENDDO
        !--
        !--
         ENDIF
    !-
        CALL CROPTIE                      !do equations that tie model to crops
        CALL PRESIM                       !do most production eq before simulaneous eq
        CALL LVSIMUL                      !do simultanious equations
    !        WRITE(*,*)'SITERA=',SITERA
    !        PAUSE
        IF (SITERA == 10000)GOTO 500         !quit if too many iterations in solving
        CALL POSTSIM                      !DO REST OF EQUATIONS
        CALL GCAU                         !DO ANIMAL UNITS
        CALL FINISH                       !DO USDA 'BASELINE' OUTPUT VARIABLES
    !--
    !--
    !--    **figure computed total feed expenses **
        A(NPT,I,30,2) = ((S(NPT,I,41,1)*(S(NPT,I,21,1)*1000)) +   & !PER COW TO TOTAL
        (S(NPT,I,41,2)*((S(NPT,I,24,2)*1000000)/112)) +   & !PER CWT TO TOTAL
        ((S(NPT,I,41,4)/112)*(S(NPT,I,24,4)*1000)) + &
        ((S(NPT,I,41,5)/112)*S(NPT,I,24,5)*1000) )/1000000
    !--

    !--
        500 CONTINUE
        IF(sitera == 10000)then
            WRITE(*,*)'max itera in center'
          !  pause
        endif
    !--
    !      ENDIF                            !!TAKE OUT
      RETURN
        END SUBROUTINE CENTER


!     Update from UT 2021
        SUBROUTINE COSTCHG
        IMPLICIT NONE
      include 'parametr'
      include 'ncntrl'
      include 'control'
      include 'macout'
      include 'intout'
     


        !EIA add
        INTEGER :: IISTART, NCROPS, J
        REAL ENGYOIL(33,3)

    !C      REAL ::  BENERGY
    !--      CALLED FROM RMAIN
!ENGY values for high and low oil cases    
!these are calculated from the BRENT oil prices differences between the latest high and low oil price cases todo: put in an input file
DATA ENGYOIL / 3*0.0,	1.0, -0.51974,	-0.53317, -0.48398,	-0.47391,-0.46967,	-0.4697,	-0.47374,	-0.47424,	-0.47475,	-0.4745,	-0.46688,	-0.46338,	-0.46581,	-0.46094,	-0.45884,	-0.45963,	-0.4647,	-0.46803,	-0.48685,	-0.49267,	-0.49418,	-0.5016,	-0.50713,	-0.50873,	-0.51074,	-0.51288,	-0.51263,	-0.51258,-0.50404, &
                33*0.0, &
                3*0.0,	1.0, 0.760279,	0.965498,	0.979879, 0.977292,	0.999767,	1.000864,	1.001184,	0.98983,	0.953824,	0.942681,	0.915007,	0.896804,	0.876158,	0.898913,	0.895293,	0.897886,	0.884112,	0.886936,	0.876768,	0.86118,	0.89371,	0.890663,	0.870585,	0.867712,	0.864073,	0.87964,	0.865455,	0.867578,	0.892984/
              
        ENGY=ENGYOIL(POLYCURIYR,WWOP)
        IISTART = INDEX(30) - INDEX(27) + 3
        NCROPS = INDEX(2)
        POLY=INDEX(63)
        CNTY=INDEX(33)
    !--
    !c      DO CTY=1,CNTY
    !--
  ! this replaces reading "IN" values from the whatif file so we don't have to keep different whatif files for the side cases
        DO K=1,NCROPS
           if (k.eq.2) then
               ENGY=ENGYOIL(POLYCURIYR,WWOP)
            else
              ENGY=0.0
            endif
        
            DO T=1,3
            !--
            !--        **FIGURE ADDITIONAL COSTS FROM CARBON PRICE**
                INCENT(2,K,T,CTY) = CYX(27,K,T,CTY)*CARBINCT(I) !DIRECT INPUTS  tC PER ACRE * $ PER tC
                IF(INDEX(75) == 1)THEN !IF FERT EXEMPT
                    INCENT(3,K,T,CTY) = 0.0
                ELSE
                    INCENT(3,K,T,CTY) = CYX(29,K,T,CTY)*CARBINCT(I) !FERTILIZERS                              !!!!!####fertilizers will be subsidized to stop price increases#####!!!!!!!!!
                ENDIF
                INCENT(4,K,T,CTY) = CYX(31,K,T,CTY)*CARBINCT(I) !CHEMICALS                                       !!!     remember fert in resdcnty.for too         ###~!!1!!
                INCENT(5,K,T,CTY) = CYX(33,K,T,CTY)*CARBINCT(I) !SEEDS
                INCENT(6,K,T,CTY) = INCENT(2,K,T,CTY) + INCENT(3,K,T,CTY) &
                + INCENT(4,K,T,CTY) + INCENT(5,K,T,CTY)
            !--
            !--       **FIGURE ADDITIONAL COSTS FROM ENERGY PRICE INCREASES**
            ! Overwrite poly brent number with NEMS number
            BRENTOIL=BRENT_PRICE(WDPOLYYR - BASEYR + 2)*mc_JPGDP(WDPOLYYR - BASEYR + 2) 
            BENERGY = BRENTOIL/5698000  ! $ PER  BTU !BASELINE ENERGY COST IN BUDGETS  READ IN SIM.INS    !EIA ENERGY 
            !--
                INCENT(7,K,T,CTY) = CYX(26,K,T,CTY)* BENERGY * ENGY  ! = BTU'S * $perBTU * %CHANGE IN ENERGY COST = $/AC CHANGE IN COST OF PRODUCTION  !DIRECT INPUTS
               ! if (k.eq.2) write(666,*) 'check increase',cyx(26,k,t,cty),incent(7,k,t,cty)
                INCENT(8,K,T,CTY) = CYX(28,K,T,CTY)* BENERGY * ENGY  ! FERTILIZERS
                INCENT(9,K,T,CTY) = CYX(30,K,T,CTY)* BENERGY * ENGY  ! CHEMICALS                !ENGY FROM WHATIF
                INCENT(10,K,T,CTY)= CYX(32,K,T,CTY)* BENERGY * ENGY  ! SEEDS
                INCENT(11,K,T,CTY)= INCENT(7,K,T,CTY) + INCENT(8,K,T,CTY) &
                + INCENT(9,K,T,CTY) + INCENT(10,K,T,CTY)
            !--
            !--       **CY K=12 AND T=2 IS PASTURELAND THAT IS INTENSIVELY MANAGED, THEREFORE NO CARBON COSTS OR INCENTIVES**
                IF(K == 12 .AND. T == 2)THEN
                    DO J=1,22
                        INCENT(J,K,T,CTY) = 0.0
                    ENDDO
                ENDIF
            !--
            !--        **residues costs are computed in rescnty.for**
            !--
            !--         Update cost of production data with calculated adjustment factor.


            !--  ************THIS WILL PICK UP ANY CHANGES IN COSTS DONE IN THE RWHATIF (WHATIFUS STATEMENTS)**************
                IF(K <= 8)THEN
                !--         Compute Per Acre Average Variable Cost
                    CYX(24,K,T,CTY) = 0.0
                    CYX(24,K,T,CTY)=CYX(5,K,T,CTY)+CYX(4,K,T,CTY) &
                    +CYX(6,K,T,CTY)+CYX(7,K,T,CTY) &
                    +CYX(8,K,T,CTY)+CYX(9,K,T,CTY) &
                    +CYX(10,K,T,CTY)+CYX(11,K,T,CTY) &
                    +CYX(12,K,T,CTY)+CYX(13,K,T,CTY) &
                    +CYX(14,K,T,CTY)+CYX(15,K,T,CTY) &
                    +CYX(16,K,T,CTY)+CYX(17,K,T,CTY) &
                   +CYX(18,K,T,CTY)! +CYX(19,K,T,CTY)  !error corrected july 31 2017...these were uncommented before leading to fixed costs being double counted
                   
  !                  +CYX(20,K,T,CTY)+CYX(21,K,T,CTY)
!--         Total Cost (fixed included) per acre
            CYX(23,K,T,CTY) = 0.0
            CYX(23,K,T,CTY)=CYX(24,K,T,CTY) & !+CYXB(4,K,T,CTY) &  !labor into variable costs
                         +CYX(19,K,T,CTY)+CYX(20,K,T,CTY) &
                         +CYX(21,K,T,CTY)+CYX(22,K,T,CTY)
                !--
                ENDIF
            !--          ******************************************************
            !--
            !--
            ENDDO
        ENDDO
    !--
    !c      ENDDO
    !--
      RETURN
        END SUBROUTINE COSTCHG

    !     Last change:  CH   22 May 2006    4:44 pm
        SUBROUTINE CROPTIE
      IMPLICIT NONE

    !--
    !-- DEFLATED corn price
    !--rcornp=cornp/CPI*100;
    !--

        XCR(NPT,I,5)=XCRB(I,5)+(C(NPT,I,9,1)/XAG(I,1)*100)- &
        (B(I,9,1)/XAGB(I,1)*100)
    !--
    !-- DEFLATED Soybean meal price
    !--rsbmp=sbmp/CPI*100;
    !--

        XCR(NPT,I,7)=XCRB(I,7)+(PC(NPT,I,4,2)/XAG(I,1)*100)- &
        (PB(I,4,2)/XAGB(I,1)*100)
    !--
    !-- DEFLATED Hay price
    !--rhayp=hayp/CPI*100;
    !--

        XCR(NPT,I,6)=XCRB(I,6)+(XAG(I,14)/XAG(I,1)*100)- &
        (XAGB(I,14)/XAGB(I,1)*100)
    !--
    !-- Feed cost
    !--fedcost=(cornp*(248/56)+sbmp*(20/2000)+hayp*(38/2000));
    !--

        XCR(NPT,I,12)=XCRB(I,12)+(C(NPT,I,9,1)-B(I,9,1))*4.42857+(PC(NPT,I,4,2)- &
        PB(I,4,2))*.01+(XAG(I,14)-XAGB(I,14))*.019
    !--
    !-- Feed cost divided by hay price
    !--rfedcost=fedcost/hayp;
    !--

        XCR(NPT,I,8)=XCRB(I,8)+(XCR(NPT,I,12)/XAG(I,14))-(XCRB(I,12)/XAGB(I,14))
    !--
    !--  Broiler feed costs
    !--brfeedc=(((((((cornp+.4*(cpi/124.0))/56*2000)*.70)+((sbmp+19.5*(cpi/124.0))*.30)))*1.09+
    !--    (10.5*cpi/124.0))/2000*2.03*100);
    !--

        S(NPT,I,41,4)=SB(I,41,4)+(((((((C(NPT,I,9,1)+.4*(XAG(I,1)/124.0))/56* &
        &               2000)*.7)+((PC(NPT,I,4,2)+19.5*(XAG(I,1)/124.0))*.3))*1.09+ &
        (10.5*XAG(I,1)/124.0))/2000*2.03*100)-((((((B(I,9,1)+ &
        .4*(XAGB(I,1)/124.0))/56*2000)*.7)+((PB(I,4,2)+19.5* &
        (XAGB(I,1)/124.0))*.3))*1.09+(10.5*XAGB(I,1)/124.0))/ &
        &               2000*2.03*100))
    !--
    !-- TOTAL  COSTS OF BROILER PRODUCTION
    !--brtc=(brfeedc/0.75+((8*(cpi/124.0)*0.9))/.75+(10.4*(cpi/124.0)*0.9));
    !--

        S(NPT,I,42,4)=SB(I,42,4)+(S(NPT,I,41,4)-SB(I,41,4))/0.75 &
        +(XS(NPT,I,32,4)-XSB(I,32,4))
    !--
    !-- Turkey feed costs
    !--tufeedc=(((cornp)/56*2000)*.70+((sbmp)*.30))/2000*2.9*100;
    !--

        S(NPT,I,41,5)=SB(I,41,5)+((((C(NPT,I,9,1)/56*2000)*.70+ &
        (PC(NPT,I,4,2)*.30))/2000*2.9*100)-(((B(I,9,1)/56*2000)*.70 &
        +(PB(I,4,2)*.30))/2000*2.9*100))
    !--
    !--     TOTAL COSTS OF TURKEY PRODUCTION
    !--tutc=(tufeedc+8.50*CPI/118.3)/(.80)+43;
    !--

        S(NPT,I,42,5)=SB(I,42,5)+((S(NPT,I,41,5)+8.50*XAG(I,1)/118.3)/(.80)+43) &
        -((SB(I,41,5)+8.50*XAG(I,1)/118.3)/(.80)+43) &
        +(XS(NPT,I,32,5)-XSB(I,32,5))
    !--
    !--   CATTLE FEED COSTS
    !--   =BASELINE+CHANGE GRAIN PER COW+SILAGE+PROTEIN SUP+HAY+ALL PASTURE AND PRIV RANGE
    !--

        S(NPT,I,41,1)=SB(I,41,1)+3.9068*(C(NPT,I,9,1)-B(I,9,1))+ &
        .02814*(PC(NPT,I,4,2)-PB(I,4,2))+ &
        .11065*(PC(NPT,I,4,2)-PB(I,4,2))+ &
        .41830*(XAG(I,14)-XAGB(I,14))+ &
        .43075*(XAG(I,14)-XAGB(I,14))
    !--
    !--     TOTAL VARIABLE COSTS OF COW PRODUCTION
    !--

        S(NPT,I,60,1)=SB(I,60,1)+(S(NPT,I,41,1)-SB(I,41,1))+ &
        (XS(NPT,I,32,1)-XSB(I,32,1))
    !--
    !--     TOTAL COSTS OF COW PRODUCTION
    !--     =BASELINE+CHANGE FEED COSTS+CHANGE OTHER VARIABLE COSTS+CHANGE FIXED COST
    !--

        S(NPT,I,42,1)=SB(I,42,1)+(S(NPT,I,60,1)-SB(I,60,1))+ &
        (XS(NPT,I,33,1)-XSB(I,33,1))
    !--
    !--     HOG FEED COSTS
    !--     =BASELINE+CHANGE CORN PER PIG+SOYBEAN MEAL+HAY
    !--

        S(NPT,I,41,2)=SB(I,41,2)+5.8202*(C(NPT,I,9,1)-B(I,9,1))+ &
        .05258*(PC(NPT,I,4,2)-PB(I,4,2))+ &
        .00329*(XAG(I,14)-XAGB(I,14))
    !--
    !--     TOTAL VARIABLE COSTS OF HOG PRODUCTION
    !--

        S(NPT,I,60,2)=SB(I,60,2)+(S(NPT,I,41,2)-SB(I,41,2))+ &
        (XS(NPT,I,32,2)-XSB(I,32,2))
    !--
    !--     TOTAL COSTS OF HOG PRODUCTION
    !--     =BASELINE+CHANGE FEED COSTS+CHANGE OTHER VAR COSTS+CHANGE FIXED COSTS
    !--

        S(NPT,I,42,2)=SB(I,42,2)+(S(NPT,I,60,2)-SB(I,60,2))+ &
        (XS(NPT,I,33,2)-XSB(I,33,2))
    !--
        RETURN
        END SUBROUTINE CROPTIE

    !     Last change:  CH   26 May 2006   11:33 am
        SUBROUTINE DIFFER
        IMPLICIT NONE

        !EIA add

        INTEGER :: NPRODS,NLVSK,NYRSIM,ISTART,IEND,IJ
        INTEGER :: J,NCROPS,NPGA,NVARXA,NVARPC,NVARC,NVARX
        INTEGER :: NVARPX,NVARS,NVARXS,NXCR,NSAU,NVARA,NPGXA,NREG

    !--
    !--   VER. 1.0
    !--
    !--                          *****************
    !-- ***********************  DIFFER SUBROUTINE  ***********************
    !--                          *****************
    !--
    !--  ****** COMPUTES SIMULATION RESULTS AS PERCENT OF BASE ******
    !--
    !--             AUXILLARY WRITE STATEMENTS (UNIT NO., 0 SCREEN, -1 OFF)
    !--
    !--            **************
    !--            * THIS SUBROUTINE IS CALLED FROM
    !--            * MAIN.FOR
    !--            **************
    !--

    !--
    !--
    !--             SET THE NUMBER OF YEARS SIMULATED
    !--
        NYRSIM = INDEX(1)
    !--
        ISTART = INDEX(30)-INDEX(27)+3
        IEND = NYRSIM+(INDEX(30)-INDEX(27))+2
    !--
    !--             NUMBER OF CROPS IN POLYSYS
    !--
        NCROPS = INDEX(2)
    !--
    !--             NUMBER OF VARIABLES IN C
    !--
        NVARC = INDEX(3)
    !--
    !--             NUMBER OF VARIABLES IN X
    !--
    !--
        NVARX = INDEX(4)
    !--
    !--             NUMBER OF MODEL PRODUCTS IN POLYSYS
    !--
        NPRODS = INDEX(43)
    !--
    !--             NUMBER OF VARIABLES IN PC (2ND SUBSCRIPT), ALSO PB
    !--
        NVARPC = INDEX(45)
    !--
    !--             NUMBER OF VARIABLES IN PX AND PXB (2ND SUBSCRIPT)
    !--
        NVARPX = INDEX(46)
    !--
    !--             NUMBER OF MODEL LIVESTOCK COMMODITIES IN POLYSYS
    !--
        NLVSK = INDEX(5)
    !--
    !--             NUMBER OF VARIABLES IN S (2ND SUBSCRIPT), ALSO SB
    !--
        NVARS = INDEX(6)
    !--
    !--             NUMBER OF VARIABLES IN XS (2ND SUBSCRIPT)
    !--
        NVARXS = INDEX(7)
    !--
    !--             NUMBER OF VARIABLES IN XCR LIVESTOCK MATRIX
    !--
        NXCR = INDEX(9)
    !--
    !--             NUMBER OF VARIABLES IN SAU LIVESTOCK MATRIX
    !--
        NSAU = INDEX(10)
    !--
    !--             NUMBER OF PAGES IN A (3RD SUBSCRIPT)
    !--
        NPGA = INDEX(12)
    !--
    !--             NUMBER OF VARIABLES IN A (2ND SUBSCRIPT)
    !--
        NVARA = INDEX(13)
    !--
    !--             NUMBER OF PAGES IN XA (3RD SUBSCRIPT)
    !--
        NPGXA = INDEX(8)
    !--
    !--
    !--             NUMBER OF VARIABLES IN XA (2ND SUBSCRIPT)
    !--
        NVARXA = INDEX(14)
    !--
    !--   NUMBER OF REGIONS IN POLYSYS ERS VERSION
    !--
        NREG = 7
    !--
    !--             COMPUTE DIFFERENCES
    !--
    !--          LOOP ACROSS YEARS
    !--
      DO I = ISTART,IEND
        !--
        !--             CROPS
        !--
            DO K = 1,NCROPS
                DO J = 1,NVARC
                    C(NPT,I,J,K) = C(NPT,I,J,K)-B(I,J,K)
         END DO
                DO J = 1,NVARX
                    X(I,J,K) = X(I,J,K)-XB(I,J,K)
            END DO
         END DO
        !--
        !--             ENERGY CROPS
        !--
            DO K = 1,NCROPS
                DO J = 1,6
                    EN(NPT,I,J,K) = EN(NPT,I,J,K)-ENB(I,J,K)
           END DO
         END DO
        !--
        !--        PRODUCTS
        !--
            DO K = 1,NPRODS
                DO J = 1,NVARPC
                    PC(NPT,I,J,K) = PC(NPT,I,J,K)-PB(I,J,K)
         END DO
                DO J = 1,NVARPX
                    PX(I,J,K) = PX(I,J,K)-PXB(I,J,K)
         END DO
      END DO
            CRMR(I) = CRMR(I) - CRMRB(I)
        !--
        !--        LIVESTOCK
        !--
            DO K = 1,NLVSK
            DO J = 1,NVARS
                    S(NPT,I,J,K) = S(NPT,I,J,K)-SB(I,J,K)
         END DO
                DO J = 1,NVARXS
                    XS(NPT,I,J,K) = XS(NPT,I,J,K) - XSB(I,J,K)
         END DO
         END DO
            DO J=1,NXCR
                XCR(NPT,I,J) = XCR(NPT,I,J)-XCRB(I,J)
      END DO
            DO IJ=1,3
                DO J=1,NSAU
                    SAU(I,J,IJ) = SAU(I,J,IJ) - SAUB(I,J,IJ)
            END DO
         END DO
        !--
        !--      AGGREGATE
        !--
            DO K = 1,NPGA
                DO J = 1,NVARA
                    A(NPT,I,J,K) = A(NPT,I,J,K)-AB(I,J,K)
      END DO
            END DO
        !--
            DO K = 1,NPGXA
                DO  J = 1,NVARXA
                    XA(I,J,K) = XA(I,J,K) - XAB(I,J,K)
         END DO
      END DO
        !--
        END DO         ! Finish Loop around Years
    !--
    !--             COMPUTE AVERAGES FOR THREE PERIODS IF DESIRED
    !--
        IF(INDEX(34)/=0)CALL AVGVAL
      RETURN
        END SUBROUTINE DIFFER

        SUBROUTINE ELAST
      IMPLICIT NONE

        CHARACTER(16) :: STR,TXT1
        CHARACTER(19) :: TXT2
        !EIA additions
        INTEGER NCROPS, NPRODS, M, J, KK
        INTEGER FILE_MGR
        EXTERNAL FILE_MGR
        CHARACTER*25 FNAME
        LOGICAL NEW
        INTEGER IUNIT1
    !--
    !--   VER. 2.0
    !--                     *****************
    !-- ******************  ELAST SUBROUTINE  *******************
    !--                     *****************
    !--               * THIS SUBROUTINE IS CALLED FROM
    !--               * MAIN.FOR
    !--               ********************************
    !--      ****** DEFINE CROP ELASTICITIES ******
    !--
    !--             AUXILLARY WRITE STATEMENTS (UNIT NO., 0 SCREEN, -1 OFF)

    !--   INDEX(2) IS THE NUMBER OF CROPS IN POLYSYS [NCROPS]
    !c      NCROPS = INDEX(2)
        NCROPS= 12  !!dont' change this because it corresponds to the elasticities  read in in ELAST.TXT!!!
    !--   INDEX(43) IS THE NUMBER OF PRODUCTS IN POLYSYS [NPRODS]
        NPRODS = INDEX(43) !should be 3
    !--
    !--   READ SUPPLY ELASTICITIE
    !--
    !--      READ 1996 SUPPLY ELASTICITIES

           FNAME='PSELASTS96' !1996 farm bill  !EIA add
           NEW=.FALSE.                                    !EIA add
           IUNIT1=FILE_MGR('O',FNAME,NEW)   !EIA add



     !   OPEN(UNIT=31,FILE='ELASTS96.BAS')
    !--      SKIP 4 LINES:
        DO K = 1,4
            READ(IUNIT1,*)
            END DO
        DO M = 1,7
            READ(IUNIT1,*)TXT1
            DO K=1,8
                READ(IUNIT1,*)TXT1,(EEAC(K,J,M),J=1,8)
         END DO
            READ(IUNIT1,*)TXT1,(EAJR(1,J,M),J=1,8)
        END DO
         IUNIT1=FILE_MGR('C',FNAME,NEW)  !EIA add
    !--
    !--
    !--   READ OTHER SUPPLY ELASTICITIES
    !--
     FNAME='PSELASTOSP'                             !EIA add
      NEW=.FALSE.                                          !EIA add
      IUNIT1=FILE_MGR('O',FNAME,NEW)         !EIA add

      !  OPEN(UNIT=31,FILE='ELASTOSP.BAS')
    !--   SKIP 4 LINES:
        DO K = 1,4
            READ(IUNIT1,*)
            END DO
        DO J=1,5
            READ(IUNIT1,*)TXT2,(EGC(J,K),K=1,8)
        END DO
        READ(IUNIT1,*)TXT2,(AJC(2,K),K=1,8)
        READ(IUNIT1,*)TXT2,(AJC(5,K),K=1,8)
        IUNIT1=FILE_MGR('C',FNAME,NEW)    !EIA add
    !--
    !--   READ DEMAND ELASTICITIES FROM ELAST.TXT FILE: FIRST SKIP 6 LINES
    !--
    !c      OPEN(UNIT=31,FILE='ELAST2017.TXT')
        FNAME='PSELAST'                           !EIA add
        NEW=.FALSE.                                  !EIA add
        IUNIT1=FILE_MGR('O',FNAME,NEW) !EIA add
       ! OPEN(UNIT=31,FILE='ELAST.TXT')
        DO K = 1,6
            READ(IUNIT1,*)
        END DO
        READ(IUNIT1,*)STR,(EGC(7,K),K=1,NCROPS),(EGP(1,KK),KK=1,NPRODS)
    !     WRITE(*,*)STR,(EGC(7,K),K=1,NCROPS),(EGP(1,KK),KK=1,NPRODS)
        READ(IUNIT1,*)STR,(EGC(8,K),K=1,NCROPS),(EGP(3,KK),KK=1,NPRODS)
    !     WRITE(*,*)STR,(EGC(8,K),K=1,NCROPS),(EGP(3,KK),KK=1,NPRODS)
        READ(IUNIT1,*)STR,(EGC(9,K),K=1,NCROPS),(EGP(2,KK),KK=1,NPRODS)
    !     WRITE(*,*)STR,(EGC(9,K),K=1,NCROPS),(EGP(2,KK),KK=1,NPRODS)
        READ(IUNIT1,*)STR,(EGC(10,K),K=1,NCROPS),(EGP(4,KK),KK=1,NPRODS)
    !     WRITE(*,*)STR,(EGC(10,K),K=1,NCROPS),(EGP(4,KK),KK=1,NPRODS)
        READ(IUNIT1,*)STR,(EGC(11,K),K=1,NCROPS),(EGP(2,KK),KK=1,NPRODS)
    !     WRITE(*,*)STR,(EGC(11,K),K=1,NCROPS),(EGP(2,KK),KK=1,NPRODS)
        READ(IUNIT1,*)STR,(EGC(12,K),K=1,NCROPS),(EGP(2,KK),KK=1,NPRODS)
    !     WRITE(*,*)STR,(EGC(12,K),K=1,NCROPS),(EGP(2,KK),KK=1,NPRODS)
        READ(IUNIT1,*)STR,(EGC(14,K),K=1,NCROPS),(EGP(2,KK),KK=1,NPRODS)
    !     WRITE(*,*)STR,(EGC(14,K),K=1,NCROPS),(EGP(2,KK),KK=1,NPRODS)
        READ(IUNIT1,*)STR,(EGC(13,K),K=1,NCROPS)
    !     WRITE(*,*)STR,(EGC(13,K),K=1,NCROPS)
        READ(IUNIT1,*)STR,(AJC(4,K),K=1,NCROPS),(AJP(2,KK),KK=1,NPRODS)
    !     WRITE(*,*)STR,(AJC(4,K),K=1,NCROPS),(AJP(2,KK),KK=1,NPRODS)
        READ(IUNIT1,*)STR,(AJC(10,K),K=1,NCROPS),(AJP(1,KK),KK=1,NPRODS)
    !     WRITE(*,*)STR,(AJC(10,K),K=1,NCROPS),(AJP(1,KK),KK=1,NPRODS)
        READ(IUNIT1,*)STR,(AJC(11,K),K=1,NCROPS)
    !     WRITE(*,*)STR,(AJC(11,K),K=1,NCROPS)
        READ(IUNIT1,*)STR,(AJC(9,K),K=1,NCROPS)
    !     WRITE(*,*)STR,(AJC(9,K),K=1,NCROPS)
     IUNIT1=FILE_MGR('C',FNAME,NEW)    !EIA add
        EGC(15,1) = 0.0
        EGC(15,2) = 0.0
        EGC(15,3) = 0.0
        EGC(15,4) = 0.0
        EGC(15,5) = 0.06
        EGC(15,6) = 0.0
        EGC(15,7) = 0.0
        EGC(15,8) = 0.0
        DO K = 1,NCROPS
        !--      DEMAND 1 EQNS (FEED, CRUSH, OR MILL DEMAND)
            AJC(10,K) = 1.0 - AJC(10,K)
        !--      EXPORT DEMAND
            AJC(4,K) = 1.0 - AJC(4,K)
        !--      FOOD DEMAND
            AJC(11,K) = 1.0 - AJC(11,K)
        !--      INDUSTRIAL DEMAND
            AJC(9,K) = 1.0 - AJC(9,K)
        END DO
        DO K = 1,NPRODS
        !--      DEMAND 1
            AJP(1,K) = 1.0 - AJP(1,K)
        !--      EXPORT DEMAND
            AJP(2,K) = 1.0 - AJP(2,K)
      END DO
      RETURN
        END SUBROUTINE ELAST


    !     update from UT 2019
        SUBROUTINE ethtrade
        IMPLICIT NONE

        INTEGER :: IYYEAR(41),iyyr
        !EIA add
        INTEGER :: NYRSIM, ISTART, IEND, BB
        REAL :: ETHABEFOR
    !--
        NYRSIM = INDEX(1)
        ISTART = INDEX(30)-INDEX(27)+3
        IEND = NYRSIM+(INDEX(30)-INDEX(27))+2
        IYYR = INDEX(30) - 2
    !--
    !c      write(*,*)istart,iend,nyrsim
        DO bb=ISTART-2,IEND
            IYYEAR(bb) = IYYR
            IYYR = IYYR + 1
        END DO
    !--                     *****************
    !-- ******************* ETHTRADE SUBROUTINE *********************
    !--                     *****************
    !--             ***** THIS FIGURES ETHANOL AND BIODIESEL TRADE****
    !--                 ** IT ALSO FIGURES CORN GRAIN AND SOYBEAN DEMANDS****
    !--           ******************************
    !--           * THIS ROUTINE IS CALLED FROM:
    !--           * GRAINS
    !--           * STKCHK
    !-- *****************************************
    !--
        IF(INDEX(101) == 2)THEN   !IF USING THE NEW BIOENEGY TRADE MODULE  FIGURING EXPORTS AND IMPORTS
        !--
        !--   ************************************************************************************
            IF(INDEX(106) == 1)THEN !BASELINE
            !--         **CORN TO SUG PRICE RATIO**
                TRDVARB(I,3) = C(NPT,I,9,1) / TRDVARB(I,1)   !MAKE SURE TRDVARB(I,3) IF FIGURED IN BASELINE
            !--
            !--
            !--
                IF(INDEX(114) == 1)THEN
                !--         *ETHANOL EXPORTS*
                !--         EXPORTS (MIL GAL) = B0 +B1*SUGAR PRICE ($/KG) + B2*(EXPORTDUMMY)
                    BTRDB(I,1,1) = -21825                          & !BASELINE VALUE WHERE FIGURED IN BASELINE RUN
                    + 1180 * TRDVARB(I,1)   & ! B1 * THE CHANGE IN SUGAR PRICE, WHERE SUGAR PRICE IS SAME AS BASELINE UNLESS EXOGENOUSLY ENTIRED IN WHATIF
                    + 671.6749 * TRDVARB(I,2)   & ! B2 * THE DUMMY VARIABLE, WHERE THE DUMMY VARIABLE IS READ IN BSELINE RUN AND SIM IS THE SAME UNLESS ENTERED IN WHATIF (VALUE OF 1)
                    + 10.8794 * IYYEAR(I) &
                    +(-72.9173 * C(NPT,I-1,9,1))  !CORN PRICE
                     IF (BTRDB(I,1,1).LE.0.0)BTRDB(I,1,1)=0.0 !Update from Ut 2019
                !--
                !--        *ETHANOL IMPORTS*
                !--         IMPORTS (MIL GAL) = B0 + B1*corntosugar ratio + b2*oil price ($/BARREL) + b3*ethanolprice ($/GAL)
                    BTRDB(I,2,1) = -789.3809 &
                    + 17.8812 * TRDVARB(I,3)    & !CORN TO SUGAR RATIO (FIGURED ABOVE)  ENDOGENOUS
                    + (-5.0472 * TRDVARB(I,4))  & !OIL PRICE
                    + 580.1438 * TRDVARB(I,5)     !ETHANOL PRICE                     MAKE ENDOGENOUS
                      IF (BTRDB(I,2,1).LE.0.0)BTRDB(I,2,1)=0.0 !Update from Ut 2019
                ENDIF
            !--
            !--
            !--         ** TOTAL ETHANOL PRODUCTION **
            !--           TOTAL PRODUCTION = BASELINE - CHANGEINIMPORTS + CHANGEINEXPORTS
                BTRDB(I,3,1) = XB(I,05,1)*BIOPRD(I,27) !MIL GAL TOT ETH (update from UT 2019)
            !--
                XB(I,45,1) = BTRDB(I,1,1)/BIOPRD(I,27) !CORN GRAIN DEMAND FOR EXPORTS (X45 USED FOR IMPORTS BELOW)
                XB(I,44,1) = XB(I,05,1)-XB(I,45,1)  !CORN GRAIN DEMAND FOR DOMESTIC ETH CONSUMPTION
            !--
            ENDIF
        !--    ***********************************************************************************


        !--    ***FIRST FIGURE ENDOGENOUS TRADE VARIABLES (TRDVAR) FOR THE EQUATIONS TO MAKE SURE IN RIGHT
        !--
        !--    **CORN TO SUG PRICE RATIO**
            TRDVAR(I,3) = C(NPT,I,9,1) / TRDVAR(I,1)   !MAKE SURE TRDVARB(I,3) IF FIGURED IN BASELINE
        !--
        !--
        !--  *****NOW COMPUTE TRADE EQUATIONS *****************
        !--
        !--
        !--      *ETHANOL EXPORTS*
        !--      EXPORTS (THOUS BARRELS) = B0 +B1*SUGAR PRICE ($/KG) + B2*(EXPORTDUMMY)  !WHERE B0= -4146  B1=21987 B2=16529
            BTRD(I,1,1) = BTRDB(I,1,1)                              & !BASELINE VALUE WHERE FIGURED IN BASELINE RUN
            + (1180 * (TRDVAR(I,1) - TRDVARB(I,1)))    & ! B1 * THE CHANGE IN SUGAR PRICE, WHERE SUGAR PRICE IS SAME AS BASELINE UNLESS EXOGENOUSLY ENTIRED IN WHATIF
            + (671.6749 * (TRDVAR(I,2) - TRDVARB(I,2)))    & ! B2 * THE DUMMY VARIABLE, WHERE THE DUMMY VARIABLE IS READ IN BSELINE RUN AND SIM IS THE SAME UNLESS ENTERED IN WHATIF (VALUE OF 1)
            + (-72.9173 * (C(NPT,I-1,9,1) - B(I-1,9,1)))
             IF(BTRDFIX(I,1,1).GT.0.0) BTRD(I,1,1)=BTRDFIX(I,1,1)        ! update from UT 2019
             IF (BTRD(I,1,1).LE.0.0) BTRD(I,1,1)=0.0  ! update from UT 2019
        !--
        !--     *ETHANOL IMPORTS*
        !--      IMPORTS (THOUS BARRELS) = B0 + B1*corntosugar ratio + b2*oil price + b3*ethanolprice !where b0=-18790, b1=425.491, b2=-120.1387, b3=13811
            BTRD(I,2,1) = BTRDB(I,2,1) &
            + (17.8812 * (TRDVAR(I,3) - TRDVARB(I,3)))    & !CORN TO SUGAR RATIO
            + (-5.0472 * (TRDVAR(I,4) - TRDVARB(I,4)))  & !OIL PRICE
            + (580.1438 * (TRDVAR(I,5) - TRDVARB(I,5)))     !ETHANOL
            IF(BTRDFIX(I,2,1).GT.0.0) BTRD(I,2,1)=BTRDFIX(I,2,1)  ! update from UT 2019
         IF (BTRD(I,2,1).LE.0.0) BTRD(I,2,1)=0.0  ! update from UT 2019
        !--
        !--
        !--      ** TOTAL ETHANOL PRODUCTION **
        !--         TOTAL PRODUCTION = BASELINE - CHANGEINIMPORTS + CHANGEINEXPORTS
            BTRD(I,3,1) = BTRDB(I,3,1) &
            - (BTRD(I,2,1)-BTRDB(I,2,1)) &
            + (BTRD(I,1,1) - BTRDB(I,1,1))
        !c         write(*,*)BTRD(I,1,1),BTRD(I,2,1),BTRD(I,3,1),'EX,IM,TOT',I,K
        !--
        !--      ** TOTAL CORN GRAIN DEMAND FROM ETHANOL **
            X(I,05,1) = BTRD(I,3,1)/BIOPRD(I,27)  !MAKE SURE OF UNITS HERE   !GALLONS OF ETHANOL / GALLONS PER BUSHEL = BUSHELS
        !c          X(I,05,1) = BTRDB(I,3,1)/BIOPRD(I,27)
            X(I,45,1) = BTRD(I,1,1)/BIOPRD(I,27) !CORN GRAIN DEMAND FOR EXPORTS (X45 USED FOR IMPORTS BELOW)

            X(I,44,1)= (XB(I,44,1)) * (1.0          & !I PUT IN ((X(NPT,I,05,1)-X(NPT,I,45,1)) INSTEAD OF XB(I,44,1)...WHICH WOULD BE FIGURED IN A BASEINE RUN.
            + EGC(13,K)*(C(NPT,I,09,1)-B(I,09,1))/B(I,09,1) &
            )

            X(I,02,K)=C(NPT,I,40,K) + X(I,05,K) !TOTAL DOMESTIC DEMAND FOR CORN = OTHER + ETHANOL DOMESTIC (update from UT 2019)
        !--
            X(I,46,1)=X(I,44,1)*BIOPRD(I,27)/1000 ! DOM ETH=MIL BU*GAL/BU
            X(I,48,1)=BTRD(I,3,1)/1000 ! TOT ETH PRODUCTION
            X(I,47,1)=BTRD(I,2,1)/1000    ! IMPORT ETHANOL
            X(I,49,1)=X(I,46,1)+X(I,47,1)    !DOMESTIC ETHANOL DEMAND (DOMESTIC PRODCUTION + IMPORTS)
            X(I,50,1)=BTRD(I,1,1)/1000   !ETHANOL DEMAND FOR EXPORT
        !--
        !--
        !--
        ELSEIF(INDEX(101) == 1)THEN    !WHICH MEANS ASSUME DOMESTIC ETHANOL DEMNAD CONSTANT, BUT IF PRICE CORN RISES THEN IMPORT MORE OF THE DEMAND. NO FIGURING OF EXPORTS HERE
        !           CORN GRAIN FOR ETHANOL
            ETHABEFOR = X(I,05,K) !RECORD BEFORE SEE IF CHANGES
            IF(INDEX(101) == 1)THEN
                X(I,44,K) = XB(I,05,K) * (1.0               & !X(B = TOTAL CORN GRAIN FOR ETHANOL (update from UT 2019)
                + EGC(13,K)*(C(NPT,I,09,K)-B(I,09,K))/B(I,09,K) &
                ) + AJC(09,K) * (C(NPT,L,40,K) - B(L,40,K))
            ELSEIF(INDEX(101)==0)THEN ! (update from UT 2019)
                X(I,44,K) =XB(I,05,K)
            ENDIF
            IF(X(I,44,K) < ETHABEFOR)THEN !(update from UT 2019)
                X(I,45,K) = ETHABEFOR-X(I,44,K) !IMPORT THE DIFFERENCE if domestic ethanol production drops. We import to satisfy the same domestic demand. (update from UT 2019)
            ELSEIF(X(I,44,K) >= XB(I,05,K))THEN ! (update from UT 2019)
                X(I,45,K)=0.0
                X(I,44,K)=ETHABEFOR             !IN NO IMPORTS, DON'T EXPAND ABOVE WHAT IT IS (update from UT 2019)
            ENDIF
            X(I,05,K)=ETHABEFOR - X(I,45,K) !DOMESTIC ETHANOL CORN DEMAND = BEFORE -  (update from UT 2019)
            X(I,44,K)=X(I,05,K) + X(I,45,K) !TOTAL ETHANOL CORN DEMAND (update from UT 2019)
            X(I,02,K)=C(NPT,I,40,K) + X(I,05,K) !TOTAL DOMESTIC DEMAND = OTHER + ETHANOL  (update from UT 2019)
            X(I,46,K)=X(I,44,K)*BIOPRD(I,27)/1000 !BIL GAL DOM ETH=MIL BU*GAL/BU / 1000
            X(I,48,K)=X(I,44,K)*BIOPRD(I,27)/1000 !BIL GAL TOT  ETH (update from UT 2019)
            X(I,47,K)=X(I,48,K)-X(I,46,K)   !BIL GAL IMPORT ETHANOL
        !--
        !--
        !c            write(*,*) x(i,47,1),x(i,48,1),x(i,46,1),'imp tot domest',i
        !c            write(*,*)x(i,44,1),x(i,5,1),'dom corn, tot corn'
        !--
        ELSE  !IF INDEX(101)=0 WHICH MEANS DON'T MESS WITH THE BASELINE ETHANOL
        !update from UT 2019)
           IF(X(I,05,K).GT.XB(I,05,K))THEN
               X(I,44,K)=X(I,05,K) + X(I,45,K) !TOTAL ETHANOL CORN DEMAND
               X(I,02,K)=C(NPT,I,40,K) + X(I,05,K) !TOTAL DOMESTIC DEMAND = OTHER + ETHANOL DOMESTIC
               X(I,46,K)=X(I,44,K)*BIOPRD(I,27)/1000 !BIL GAL DOM ETH=MIL BU*GAL/BU / 1000
               X(I,48,K)=X(I,44,K)*BIOPRD(I,27)/1000 !BIL GAL TOT ETH
               X(I,47,K)=X(I,48,K)-X(I,46,K)   !BIL GAL IMPORT ETHANOL
           ELSE
        !--
        !--        CORN GRAIN FOR ETHANOL
              ETHABEFOR = X(I,05,K) !RECORD BEFORE SEE IF CHANGES
              IF(INDEX(101) == 1)THEN
                  X(I,44,K) = XB(I,05,K) * (1.0               & !X(B = TOTAL CORN GRAIN FOR ETHANOL
                  + EGC(13,K)*(C(NPT,I,09,K)-B(I,09,K))/B(I,09,K) &
                  ) + AJC(09,K) * (C(NPT,L,40,K) - B(L,40,K))
              ELSEIF(INDEX(101).EQ.0)THEN !update from UT 2019
                  X(I,44,K) =XB(I,05,K)
              ENDIF
              IF(X(I,44,K) < ETHABEFOR)THEN !update from UT 2019
                X(I,45,K) = ETHABEFOR-X(I,44,K) !IMPORT THE DIFFERENCE if domestic ethanol production drops. We import to satisfy the same domestic demand. !update from UT 2019
             ELSEIF(X(I,44,K) >= XB(I,05,K))THEN !update from UT 2019
                X(I,45,K)=0.0
                X(I,44,K)=ETHABEFOR             !IN NO IMPORTS, DON'T EXPAND ABOVE WHAT IT IS !update from UT 2019
             ENDIF
             X(I,05,K)=ETHABEFOR - X(I,45,K) !DOMESTIC ETHANOL CORN DEMAND = BEFORE - IMPORTS !update from UT 2019
             X(I,44,K)=X(I,05,K) + X(I,45,K) !TOTAL ETHANOL CORN DEMAND !update from UT 2019
             X(I,02,K)=C(NPT,I,40,K) + X(I,05,K) !TOTAL DOMESTIC DEMAND = OTHER + ETHANOL DOMESTIC !update from UT 2019
             X(I,46,K)=X(I,44,K)*BIOPRD(I,27)/1000 !BIL GAL DOM ETH=MIL BU*GAL/BU / 1000
             X(I,48,K)=X(I,44,K)*BIOPRD(I,27)/1000 !BIL GAL TOT ETH !update from UT 2019
             X(I,47,K)=X(I,48,K)-X(I,46,K)   !BIL GAL IMPORT ETHANOL
          ENDIF
        !--
        ENDIF  !INDEX(101) IF STATEMENT

    !--
        RETURN
        end SUBROUTINE ethtrade

    !     Last change:  CH   22 May 2006    4:45 pm
        SUBROUTINE FINISH
        IMPLICIT NONE

        !EIA add
        INTEGER :: II,IEND
    !--
        IEND = INDEX(1) +(INDEX(30)-INDEX(27)) + 2
        DO II=1,IEND
        !--     BEGINNING STOCKS(CHIHTYO)
            XS(NPT,II,10,4)=XS(NPT,II,10,4)/100
            XSB(II,10,4)=XSB(II,10,4)/100
        !--     FI SLAUGHTER(CHIAIYO)
            S(NPT,II,24,4)=S(NPT,II,24,4)/1000
            SB(II,24,4)=SB(II,24,4)/1000
        !--     EXPORTSB(CHIHTYOE)
            S(NPT,II,39,4)=S(NPT,II,39,4)/1000
            SB(II,39,4)=SB(II,39,4)/1000
        !--     ENDING STOCKSB(CHIHTYOE)
            XS(NPT,II,11,4)=XS(NPT,II,11,4)/100
            XSB(II,11,4)=XSB(II,11,4)/100
        !--     BEGINNING STOCKS(TURHT)
            XS(NPT,II,10,5)=XS(NPT,II,10,5)/1000
            XSB(II,10,5)=XSB(II,10,5)/1000
        !--     FI SLAUGHTER(CHIAIYO)
            S(NPT,II,24,5)=S(NPT,II,24,5)/1000
            SB(II,24,5)=SB(II,24,5)/1000
        !--     EXPORTS(TURMX)
            XS(NPT,II,13,5)=XS(NPT,II,13,5)/1000
            XSB(II,13,5)=XSB(II,13,5)/1000
        !--     ENDING STOCKS(TURHTE)
            XS(NPT,II,11,5)=XS(NPT,II,11,5)/1000
            XSB(II,11,5)=XSB(II,11,5)/1000
      END DO
    !--
    !--             ***CATTLE SECTOR USDA FORMAT RESULTS***
    !--
    !--     FARM PRODUCTION
    !      FIN(I,3,1)=FINB(I,3,1)

        S(NPT,I,43,1)=SB(I,43,1)
    !--         TOTAL PRODUCTION
    !      FIN(I,4,1)=FINB(I,4,1)+(FIN(I,2,1)-FINB(I,2,1))
    !     1     +(FIN(I,3,1)-FINB(I,3,1))

        S(NPT,I,44,1)=SB(I,44,1)+(S(NPT,I,24,1)-SB(I,24,1)) &
        +(S(NPT,I,43,1)-SB(I,43,1))
    !--     TOTAL SUPPLY
    !      FIN(I,6,1)=FINB(I,6,1)+(FIN(I,1,1)+FIN(I,4,1)+FIN(I,5,1))
    !     1  -(FINB(I,1,1)+FINB(I,4,1)+FINB(I,5,1))

        S(NPT,I,45,1)=SB(I,45,1)+(XS(NPT,I,10,1)+S(NPT,I,44,1)+XS(NPT,I,12,1)) &
        -(XSB(I,10,1)+SB(I,44,1)+XSB(I,12,1))
    !--     TOTAL CONSUMPTION
    !      FIN(I,9,1)=FIN(I,4,1)+FIN(I,5,1)+FIN(I,1,1)-FIN(I,7,1)-FIN(I,8,1)

        S(NPT,I,47,1)=SB(I,47,1)+(S(NPT,I,44,1)+XS(NPT,I,12,1)+XS(NPT,I,10,1)-XS(NPT,I,13,1) &
        -XS(NPT,I,11,1))-(SB(I,44,1)+XSB(I,12,1)+XSB(I,10,1) &
        -XSB(I,13,1)-XSB(I,11,1))
    !--     PER CAPITA, CARCASS WEIGHT
    !      FIN(I,10,1)=FINB(I,10,1)+(FIN(I,9,1)/XAG(I,3)
    !     1     -FINB(I,9,1)/XAGB(I,3))

        S(NPT,I,48,1)=SB(I,48,1)+(S(NPT,I,47,1)/XAG(I,3) &
        -SB(I,47,1)/XAGB(I,3))
    !--     PER CAPITA, RETAIL WEIGHT
    !      FIN(I,11,1)=FINB(I,11,1)+.695*(FIN(I,10,1)-FINB(I,10,1))

        S(NPT,I,49,1)=SB(I,49,1)+.695*(S(NPT,I,48,1)-SB(I,48,1))
    !--     NEB CHOICE STEERS
    !--      FIN(I,14,1)=FINB(I,14,1)+(FIN(I,15,1)*XAG(I,1)/100)
    !--     1           -(FINB(I,15,1)*XAGB(I,1)/100)

        S(NPT,I,61,1)=SB(I,61,1)+(S(NPT,I,6,1)*XAG(I,1)/100) &
        -(SB(I,6,1)*XAGB(I,1)/100)
    !--     BEEF CATTLE, FARM PRICE

        S(NPT,I,50,1)=SB(I,50,1)+(S(NPT,I-1,50,1)*S(NPT,I,61,1)/S(NPT,I-1,61,1)) &
        -(SB(I-1,50,1)*SB(I,61,1)/SB(I-1,61,1))
    !--     YEARLING STEERS, OK CITY
    !      FIN(I,16,1)=FINB(I,16,1)+(FIN(I,17,1)*XAG(I,1)/100)
    !     1   -(FINB(I,17,1)*XAGB(I,1)/100)

        S(NPT,I,62,1)=SB(I,62,1)+(S(NPT,I,5,1)*XAG(I,1)/100) &
        -(SB(I,5,1)*XAGB(I,1)/100)
    !--     CALVES, FARM PRICE
    !      FIN(I,13,1)=FINB(I,13,1)+(FIN(I-1,13,1)*FIN(I,16,1)/FIN(I-1,16,1))
    !     1 -(FINB(I-1,13,1)*FINB(I,16,1)/FINB(I-1,16,1))

        S(NPT,I,51,1)=SB(I,51,1)+(S(NPT,I-1,51,1)*S(NPT,I,62,1)/S(NPT,I-1,62,1)) &
        -(SB(I-1,51,1)*SB(I,62,1)/SB(I-1,62,1))
    !--     RETAIL:BEEF AND VEAL(RCPIBV)
    !      FIN(I,18,1)=FINB(I,18,1)+(S(NPT,I,7,1)*XAG(I,1)/100)
    !     1  -(SB(I,7,1)*XAGB(I,1)/100)

        S(NPT,I,63,1)=SB(I,63,1)+(S(NPT,I,7,1)*XAG(I,1)/100) &
        -(SB(I,7,1)*XAGB(I,1)/100)
    !--     RETAIL:OTHER MEATS
    !      FIN(I,19,1)=FINB(I,19,1)+(FIN(I-1,19,1)*FIN(I,18,1)/FIN(I-1,18,1))
    !     1  -(FINB(I-1,19,1)*FINB(I,18,1)/FINB(I-1,18,1))

        S(NPT,I,54,1)=SB(I,54,1)+(S(NPT,I-1,54,1)*S(NPT,I,63,1)/S(NPT,I-1,63,1)) &
        -(SB(I-1,54,1)*SB(I,63,1)/SB(I-1,63,1))
    !--     ERS RETAIL BEEF PRICE
    !      FIN(I,20,1)=FINB(I,20,1)+(FIN(I-1,20,1)*FIN(I,18,1)/FIN(I-1,18,1))
    !     1  -(FINB(I-1,20,1)*FINB(I,18,1)/FINB(I-1,18,1))

        S(NPT,I,55,1)=SB(I,55,1)+(S(NPT,I-1,55,1)*S(NPT,I,63,1)/S(NPT,I-1,63,1)) &
        -(SB(I-1,55,1)*SB(I,63,1)/SB(I-1,63,1))
    !--
    !--             ***HOG SECTOR USDA FORMAT RESULTS***
    !--
    !--     FARM PRODUCTION
    !      FIN(I,3,2)=FINB(I,3,2)

        S(NPT,I,43,2)=SB(I,43,2)
    !--         TOTAL PRODUCTION
    !      FIN(I,4,2)=FINB(I,4,2)+(FIN(I,2,2)-FINB(I,2,2))+(FIN(I,3,2)-
    !     1           FINB(I,3,2))

        S(NPT,I,44,2)=SB(I,44,2)+(S(NPT,I,24,2)-SB(I,24,2))+(S(NPT,I,43,2)- &
        SB(I,43,2))
    !--     TOTAL SUPPLY
    !      FIN(I,6,2)=FIN(I,1,2)+FIN(I,4,2)+FIN(I,5,2)

        S(NPT,I,46,2)=SB(I,46,2)+(XS(NPT,I,10,2)+S(NPT,I,44,2)+XS(NPT,I,12,2))- &
        (XSB(I,10,2)+SB(I,44,2)+XSB(I,12,2))
    !--     TOTAL CONSUMPTION
    !      FIN(I,9,2)=FIN(I,1,2)+FIN(I,4,2)+FIN(I,5,2)-FIN(I,7,2)-FIN(I,8,2)

        S(NPT,I,47,2)=SB(I,47,2)+(XS(NPT,I,10,2)+S(NPT,I,44,2)+XS(NPT,I,12,2)-XS(NPT,I,13,2)- &
        XS(NPT,I,11,2))-(XSB(I,10,2)+SB(I,44,2)+XSB(I,12,2)-XSB(I,13,2)- &
        XSB(I,11,2))
    !--     PER CAPITA, CARCASS WEIGHT
    !      FIN(I,10,2)=FINB(I,10,2)+(FIN(I,9,2)/XAG(I,3))
    !     1 -(FINB(I,9,2)/XAGB(I,3))

        S(NPT,I,48,2)=SB(I,48,2)+(S(NPT,I,47,2)/XAG(I,3)) &
        -(SB(I,47,2)/XAGB(I,3))
    !--     PER CAPITA, RETAIL WEIGHT
    !      FIN(I,11,2)=FINB(I,11,2)+.776*(FIN(I,10,2)-FINB(I,10,2))

        S(NPT,I,49,2)=SB(I,49,2)+.776*(S(NPT,I,48,2)-SB(I,48,2))
    !--     IA-SoMN Price
    !      FIN(I,14,2)=FINB(I,14,2)+(FIN(I,15,2)*XAG(I,1)/100)
    !     1  -(FINB(I,15,2)*XAGB(I,1)/100)

        S(NPT,I,61,2)=SB(I,61,2)+(S(NPT,I,1,2)*XAG(I,1)/100) &
        -(SB(I,1,2)*XAGB(I,1)/100)
    !--     HOG, FARM PRICE
    !      FIN(I,12,2)=FINB(I,12,2)+(FIN(I,14,2)-FINB(I,14,2))

        S(NPT,I,50,2)=SB(I,50,2)+(S(NPT,I,61,2)-SB(I,61,2))
    !--     RETAIL:pork cpi(rcpipo)

        S(NPT,I,63,2)=SB(I,63,2)+(S(NPT,I,7,2)*XAG(I,1)/100) &
        -(SB(I,7,2)*XAGB(I,1)/100)
    !--     ERS RETAIL pork PRICE

        S(NPT,I,55,2)=SB(I,55,2)+(S(NPT,I-1,55,2)*S(NPT,I,63,2)/S(NPT,I-1,63,2))- &
        (SB(I-1,55,2)*SB(I,63,2)/SB(I-1,63,2))
    !--    TO FIGURE HOG INVENTORY(DO NOT PRINT)

        S(NPT,I,59,2)=SB(I,59,2)+3.278789*(S(NPT,I,44,2)-SB(I,44,2))
    !--    HOG INVENTORY

        S(NPT,I,56,2)=SB(I,56,2)+(S(NPT,I,59,2)/S(NPT,I-1,59,2)*S(NPT,I-1,56,2)) &
        -(SB(I,59,2)/SB(I-1,59,2)*SB(I-1,56,2))
    !--
    !--         ***CHICKEN SECTOR***
    !--
    !--     TOTAL PRODUCTION

        S(NPT,I,44,4)=SB(I,44,4)+(S(NPT,1,44,4)/S(NPT,1,24,4)*S(NPT,I,24,4)) &
        -(SB(1,44,4)/SB(1,24,4)*SB(I,24,4))
    !--     TOTAL SUPPLY

        S(NPT,I,46,4)=SB(I,46,4)+(XS(NPT,I,10,4)+S(NPT,I,44,4))- &
        (XSB(I,10,4)+SB(I,44,4))
    !--     TOTAL CONSUMPTION

        S(NPT,I,47,4)=SB(I,47,4)+(S(NPT,I,46,4)-S(NPT,I,39,4)-XS(NPT,I,11,4))- &
        (SB(I,46,4)-SB(I,39,4)-XSB(I,11,4))
    !--     PER CAPITA, CARCASS WEIGHT

        S(NPT,I,48,4)=SB(I,48,4)+(S(NPT,I,47,4)/XAG(I,3)) &
        -(SB(I,47,4)/XAGB(I,3))
    !--     PER CAPITA, RETAIL WEIGHT

        S(NPT,I,49,4)=SB(I,49,4)+.879*(S(NPT,I,48,4)-SB(I,48,4))
    !--     12 CITY MARKET PRICE

        S(NPT,I,61,4)=SB(I,61,4)+(S(NPT,I,1,4)*XAG(I,1)/100) &
        -(SB(I,1,4)*XAGB(I,1)/100)
    !--     BROILER, FARM PRICE

        S(NPT,I,50,4)=SB(I,50,4)+(S(NPT,I,61,4)-SB(I,61,4))*.6
    !--     RETAIL:COMPOSITE BROILER

        S(NPT,I,53,4)=SB(I,53,4)+(S(NPT,I-1,53,4)* &
        (S(NPT,I,7,4)*XAG(I,1))/(XAG(I-1,1)*S(NPT,I-1,7,4))) &
        -(SB(I-1,53,4)*(SB(I,7,4)*XAGB(I,1)) &
        /(XAGB(I-1,1)*SB(I-1,7,4)))
    !--
    !--     ***TURKEY SECTOR***
    !--
    !--         TOTAL PRODUCTION

        S(NPT,I,44,5)=SB(I,44,5)+(S(NPT,1,44,5)/S(NPT,1,24,5)*S(NPT,I,24,5)) &
        -(SB(1,44,5)/SB(1,24,5)*SB(I,24,5))
    !--     TOTAL SUPPLY

        S(NPT,I,46,5)=SB(I,46,5)+(XS(NPT,I,10,5)+S(NPT,I,44,5))- &
        (XSB(I,10,5)+SB(I,44,5))
    !--     TOTAL CONSUMPTION

        S(NPT,I,47,5)=SB(I,47,5)+(S(NPT,I,46,5)-XS(NPT,I,13,5)-XS(NPT,I,11,5))- &
        (SB(I,46,5)-XSB(I,13,5)-XSB(I,11,5))
    !--     PER CAPITA, CARCASS WEIGHT

        S(NPT,I,48,5)=SB(I,48,5)+S(NPT,I,47,5)/XAG(I,3)-SB(I,47,5)/XAGB(I,3)
    !--     DEFLATED HEN WHOLESALE PRICE()

        S(NPT,I,52,5)=SB(I,52,5)+(S(NPT,I-1,52,5)*S(NPT,I,1,5)/S(NPT,I-1,1,5)) &
        -(SB(I-1,52,5)*SB(I,1,5)/SB(I-1,1,5))
    !--     HEN TURKEY WHOLESALE PRICE

        S(NPT,I,61,5)=SB(I,61,5)+(S(NPT,I,52,5)*XAG(I,1)/100) &
        -(SB(I,52,5)*XAGB(I,1)/100)
    !--     TURKEY, FARM PRICE

        S(NPT,I,50,5)=SB(I,50,5)+(S(NPT,I,61,5)-SB(I,61,5))*.6
    !--     RETAIL:POULTRY()

        S(NPT,I,53,5)=SB(I,53,5)+(S(NPT,I,61,5)*(S(NPT,I-1,53,5)/ &
        S(NPT,I-1,61,5)))-(SB(I,61,5)*(SB(I-1,53,5)/SB(I-1,61,5)))
    !--     CALCULATED POULTY CPI
    !      S(I,54,5)=SB(I,54,5)+((((((S(I,53,4)/S(I-1,53,4))-1)*0.8)+       !no longer included in ers baseline
    !     1     (((S(I,53,5)/S(I-1,53,5))-1)*0.2))+1)*S(I-1,54,5))-
    !     1  ((((((SB(I,53,4)/SB(I-1,53,4))-1)*0.8)+
    !     1     (((SB(I,53,5)/SB(I-1,53,5))-1)*0.2))+1)*SB(I-1,54,5))
    !--
    !--
        DO II=1,IEND
        !--     BEGINNING STOCKS(CHIHTYO)
            XS(NPT,II,10,4)=XS(NPT,II,10,4)*100
            XSB(II,10,4)=XSB(II,10,4)*100
        !--     FI SLAUGHTER(CHIAIYO)
            S(NPT,II,24,4)=S(NPT,II,24,4)*1000
            SB(II,24,4)=SB(II,24,4)*1000
        !--     EXPORTSB(CHIHTYOE)
            S(NPT,II,39,4)=S(NPT,II,39,4)*1000
            SB(II,39,4)=SB(II,39,4)*1000
        !--     ENDING STOCKSB(CHIHTYOE)
            XS(NPT,II,11,4)=XS(NPT,II,11,4)*100
            XSB(II,11,4)=XSB(II,11,4)*100
        !--     BEGINNING STOCKS(TURHT)
            XS(NPT,II,10,5)=XS(NPT,II,10,5)*1000
            XSB(II,10,5)=XSB(II,10,5)*1000
        !--     FI SLAUGHTER(CHIAIYO)
            S(NPT,II,24,5)=S(NPT,II,24,5)*1000
            SB(II,24,5)=SB(II,24,5)*1000
        !--     EXPORTS(TURMX)
            XS(NPT,II,13,5)=XS(NPT,II,13,5)*1000
            XSB(II,13,5)=XSB(II,13,5)*1000
        !--     ENDING STOCKS(TURHTE)
            XS(NPT,II,11,5)=XS(NPT,II,11,5)*1000
            XSB(II,11,5)=XSB(II,11,5)*1000
      END DO
        RETURN
        END SUBROUTINE FINISH

    !     Last change:  CH   22 May 2006    4:46 pm
        SUBROUTINE FLEXGR
        IMPLICIT NONE

        !EIA add
        INTEGER :: IYEAR1
        REAL :: R
    !--
    !--                       *****************
    !--     ****************  FLEXGR SUBROUTINE **********************
    !--                       *****************
    !--     *******************************************
    !--     ***** THIS SUBROUTINE IS CALLED FROM ******
    !--     ***** GRAINS.FOR AND RELEAS.FOR        ******
    !--     *******************************************
    !--     ***** PRICE FLEXIBILITY SCHEDULES FOR GRAINS AND COTTON *****
    !--   FIRST YEAR OF SIMULATION
        IYEAR1 = INDEX(30)
    !--   AUXILLARY WRITE STATEMENTS (UNIT NO., 0 SCREEN, -1 OFF)

    !--      PRICE FLEXIBILITY SCHEDULES ARE
    !--      BASED ON THE RATIO OF COMMERICAL STOCKS TO TOTAL USE.
    !--      THIS SUBROUTINE WILL BE CALLED EACH ITERATION OF THE
    !--      GRAINS SUBROUTINE.  FOR THE FIRST ITERATION BASELINE
    !--      VALUES FOR ENDOGENOUS DEMAND AND PRICE ARE USED
    !--      (C SET TO B IN STGAUS); PREDETERMINED EXPORTS ARE USED
    !--      IF SPECIFED.  SIMULATED VALUES USED FOR SUPPLY.
    !--    ***     COMPUTE 'COMMERCIAL STOCK' / TOTAL USE RATIOES AND     ***
    !--    *** SELECT PRICE FLEXIBILITY FOR EACH FEED GRAIN AND FOR WHEAT ***
        IF(INDEX(50)==0) THEN                ! OLD PRICE FLEXIBILITIES
        !--      CORN
            R = (C(NPT,I,08,1) - C(NPT,I,13,1)) / C(NPT,I,13,1)
            IF(R<0.05)                     EGC(06,1) = -6.0   !swapped these out april 2017, hoping that stochastic will solve / not crash as much
            IF(R>=0.05 .AND. R<0.10)       EGC(06,1) = -4.0
        !         IF(R<0.05)                   EGC(06,1) = -3.5
        !         IF(R>=0.05.AND.R<0.10)       EGC(06,1) = -3.5
            IF(R>=0.10 .AND. R<0.15)       EGC(06,1) = -3.5
            IF(R>=0.15 .AND. R<0.20)       EGC(06,1) = -2.75
            IF(R>=0.20 .AND. R<0.30)       EGC(06,1) = -2.00
            IF(R>=0.30)                  EGC(06,1) = -1.00
        !--      GRAIN SORGHUM
            R = (C(NPT,I,08,2) - C(NPT,I,13,2)) / C(NPT,I,13,2)
            IF(R<05)                       EGC(06,2) = -3.96
        !         IF(R<0.05)                     EGC(06,2) = -3.5
            IF(R>=0.05 .AND. R<0.10)       EGC(06,2) = -2.64
            IF(R>=0.10 .AND. R<0.15)       EGC(06,2) = -2.31
            IF(R>=0.15 .AND. R<0.20)       EGC(06,2) = -1.82
            IF(R>=0.20 .AND. R<0.30)       EGC(06,2) = -1.32
            IF(R>=0.30)                     EGC(06,2) = -1.00
        !--      OATS
            R = (C(NPT,I,08,3) - C(NPT,I,13,3)) / C(NPT,I,13,3)
            IF(R<0.05)                     EGC(06,3) = -3.00
            IF(R>=0.05 .AND. R<0.10)       EGC(06,3) = -2.00
            IF(R>=0.10 .AND. R<0.15)       EGC(06,3) = -1.75
            IF(R>=0.15 .AND. R<0.20)       EGC(06,3) = -1.38
            IF(R>=0.20)                     EGC(06,3) = -1.00
        !--      BARLEY
            R = (C(NPT,I,08,4) - C(NPT,I,13,4)) / C(NPT,I,13,4)
            IF(R<0.05)                     EGC(06,4) = -2.16
            IF(R>=0.05 .AND. R<0.10)       EGC(06,4) = -1.44
            IF(R>=0.10 .AND. R<0.15)       EGC(06,4) = -1.26
            IF(R>=0.15)                     EGC(06,4) = -1.00
        !--      WHEAT
            R = (C(NPT,I,08,5) - C(NPT,I,13,5)) / C(NPT,I,13,5)
            IF(R<0.10)                     EGC(06,5) = -6.0
            IF(R>=0.10 .AND. R<0.15)       EGC(06,5) = -4.0
        !         IF(R<0.10)                   EGC(06,5) = -3.5
        !         IF(R>=0.10.AND.R<0.15)       EGC(06,5) = -3.5
            IF(R>=0.15 .AND. R<0.20)       EGC(06,5) = -3.0
            IF(R>=0.20 .AND. R<0.30)       EGC(06,5) = -2.4
            IF(R>=0.30 .AND. R<0.50)       EGC(06,5) = -2.00
            IF(R>=0.50 .AND. R<0.60)       EGC(06,5) = -1.5
            IF(R>=0.60)                  EGC(06,5) = -1.00
        !C         EGC(06,5) = -0.005
        !--      SOYBEANS
            R = (C(NPT,I,08,6) - C(NPT,I,13,6)) / C(NPT,I,13,6)
            IF(R<0.033)                    EGC(06,6) = -6.0
        !        IF(R>=0.033.AND.R<0.066)     EGC(06,6) = -4.0
        !        IF(R<0.033)                    EGC(06,6) = -3.5
        !        IF(R>=0.033.AND.R<0.066)     EGC(06,6) = -3.5
        !        IF(R>=0.066.AND.R<0.10)      EGC(06,6) = -3.0
        !        IF(R>=0.10.AND.R<0.15)       EGC(06,6) = -2.4
        !        IF(R>=0.15.AND.R<0.20)       EGC(06,6) = -2.00
        !        IF(R>=0.20)                     EGC(06,6) = -1.75
        !c         IF(R<0.033)                  EGC(06,6) = -3.25
            IF(R>=0.033 .AND. R<0.066)     EGC(06,6) = -3.0
            IF(R>=0.066 .AND. R<0.10)      EGC(06,6) = -2.5
            IF(R>=0.10 .AND. R<0.15)       EGC(06,6) = -2.00
            IF(R>=0.15 .AND. R<0.20)       EGC(06,6) = -1.75
            IF(R>=0.20)                  EGC(06,6) = -1.50
        !--      COTTON
            R = (C(NPT,I,08,7) - C(NPT,I,13,7)) / C(NPT,I,13,7)
            IF(R<0.15)                   EGC(06,7) = -5.0 * 0.70
            IF(R>=0.15 .AND. R<0.20)       EGC(06,7) = -4.0 * 0.70
        !         IF(R<0.15)                   EGC(06,7) = -3.5 * 0.70
        !         IF(R>=0.15.AND.R<0.20)       EGC(06,7) = -3.5 * 0.70
            IF(R>=0.20 .AND. R<0.25)       EGC(06,7) = -3.0 * 0.70
            IF(R>=0.25 .AND. R<0.35)       EGC(06,7) = -2.25 * 0.70
            IF(R>=0.35 .AND. R<0.55)       EGC(06,7) = -1.75 * 0.70
            IF(R>=0.55)                  EGC(06,7) = -1.00
        !C      EGC(6,7) = -9.0
        !--      RICE
            R = (C(NPT,I,08,8) - C(NPT,I,13,8)) / C(NPT,I,13,8)
            IF(R<0.15)                     EGC(06,8) = -5.0
            IF(R>=0.15 .AND. R<0.20)       EGC(06,8) = -4.0
        !c         IF(R<0.15)                     EGC(06,8) = -3.5
        !c         IF(R>=0.15.AND.R<0.20)       EGC(06,8) = -3.5
            IF(R>=0.20 .AND. R<0.25)       EGC(06,8) = -3.0
            IF(R>=0.25 .AND. R<0.35)       EGC(06,8) = -2.25
            IF(R>=0.35 .AND. R<0.55)       EGC(06,8) = -1.75
            IF(R>=0.55)                     EGC(06,8) = -1.00
        ELSEIF(INDEX(50)==1) THEN         ! NEW PRICE FLEXIBILITIES
        !--      CORN
            R = (C(NPT,I,08,1) - C(NPT,I,13,1)) / C(NPT,I,13,1)
            IF(R<0.05)                   EGC(06,1) = -7.00!*1.1 !-7.0
            IF(R>=0.05 .AND. R<0.066)      EGC(06,1) = -7.00!*1.1 !-6.0
            IF(R>=0.066 .AND. R<0.10)      EGC(06,1) = -7.00!*1.25 !-4.0
            IF(R>=0.10 .AND. R<0.15)       EGC(06,1) = -2.8*1.75 !-2.8
            IF(R>=0.15 .AND. R<0.20)       EGC(06,1) = -2.2*1.75 !-2.0
            IF(R>=0.20 .AND. R<0.25)       EGC(06,1) = -1.6*1.75
            IF(R>=0.25 .AND. R<0.35)       EGC(06,1) = -1.4*1.5
            IF(R>=0.35 .AND. R<0.45)       EGC(06,1) = -1.2*1.5!-0.8
            IF(R>=0.45)                  EGC(06,1) = -1.0*1.5 !-0.8
        !--      GRAIN SORGHUM
            R = (C(NPT,I,08,2) - C(NPT,I,13,2)) / C(NPT,I,13,2)
        !        IF(R<05)                     EGC(06,2) = -3.96
            IF(R<0.05)                   EGC(06,2) = -3.5
            IF(R>=0.05 .AND. R<0.10)       EGC(06,2) = -2.64
            IF(R>=0.10 .AND. R<0.15)       EGC(06,2) = -2.31
            IF(R>=0.15 .AND. R<0.20)       EGC(06,2) = -1.82
            IF(R>=0.20 .AND. R<0.30)       EGC(06,2) = -1.32
            IF(R>=0.30)                     EGC(06,2) = -1.00
        !--      OATS
            R = (C(NPT,I,08,3) - C(NPT,I,13,3)) / C(NPT,I,13,3)
            IF(R<0.05)                     EGC(06,3) = -3.00
            IF(R>=0.05 .AND. R<0.10)       EGC(06,3) = -2.00
            IF(R>=0.10 .AND. R<0.15)       EGC(06,3) = -1.75
            IF(R>=0.15 .AND. R<0.20)       EGC(06,3) = -1.38
            IF(R>=0.20)                     EGC(06,3) = -1.00
        !--      BARLEY
            R = (C(NPT,I,08,4) - C(NPT,I,13,4)) / C(NPT,I,13,4)
            IF(R<0.05)                     EGC(06,4) = -2.16
            IF(R>=0.05 .AND. R<0.10)       EGC(06,4) = -1.44
            IF(R>=0.10 .AND. R<0.15)       EGC(06,4) = -1.26
            IF(R>=0.15)                     EGC(06,4) = -1.00
        !--      WHEAT
            R = (C(NPT,I,08,5) - C(NPT,I,13,5)) / C(NPT,I,13,5)
            IF(R<0.05)                   EGC(06,5) = -6.0
            IF(R>=0.05 .AND. R<0.066)      EGC(06,5) = -6.0
            IF(R>=0.066 .AND. R<0.10)      EGC(06,5) = -3.9  !* 1.5
            IF(R>=0.10 .AND. R<0.15)       EGC(06,5) = -2.7  !* 1.5
            IF(R>=0.15 .AND. R<0.20)       EGC(06,5) = -2.0  !* 1.5
            IF(R>=0.20 .AND. R<0.25)       EGC(06,5) = -1.6  !* 1.5
            IF(R>=0.25 .AND. R<0.30)       EGC(06,5) = -1.4  !* 1.5
            IF(R>=0.30 .AND. R<0.35)       EGC(06,5) = -1.3  !* 1.5
            IF(R>=0.35 .AND. R<0.50)       EGC(06,5) = -1.2  !* 1.5
            IF(R>=0.50 .AND. R<0.55)       EGC(06,5) = -1.2  !* 1.5
            IF(R>=0.55 .AND. R<0.60)       EGC(06,5) = -1.2  !* 1.5
            IF(R>=0.60)                  EGC(06,5) = -1.2  !* 1.5
        !--      SOYBEANS
        !         R = (C(NPT,I,08,6) - C(NPT,I,13,6)) / C(NPT,I,13,6)
        !         IF(R<0.05)                     EGC(06,6) = -2.6*1.50
        !         IF(R>=0.05.AND.R<0.066)      EGC(06,6) = -1.4*1.50
        !         IF(R>=0.066.AND.R<0.10)      EGC(06,6) = -1.2*1.25
        !         IF(R>=0.10.AND.R<0.15)       EGC(06,6) = -1.1*1.25 !-0.8
        !         IF(R>=0.15.AND.R<0.20)       EGC(06,6) = -1.1!*1.25 !-0.8
        !         IF(R>=0.20.AND.R<0.25)       EGC(06,6) = -1.0!*1.25 !-0.8
        !         IF(R>=0.25.AND.R<0.30)       EGC(06,6) = -1.0!*1.25 !-0.8
        !         IF(R>=0.30.AND.R<0.35)       EGC(06,6) = -1.0!*1.25 !-0.8
        !         IF(R>=0.35.AND.R<0.50)       EGC(06,6) = -1.0!*1.25 !-0.8
        !         IF(R>=0.50.AND.R<0.55)       EGC(06,6) = -1.0!*1.25 !-0.8
        !         IF(R>=0.55.AND.R<0.60)       EGC(06,6) = -1.0!*1.25 !-0.8
        !         IF(R>=0.60)                     EGC(06,6) = -1.0!*1.25 !-0.8
        !--      SOYBEANS
            R = (C(NPT,I,08,6) - C(NPT,I,13,6)) / C(NPT,I,13,6)
            IF(R<0.033)                  EGC(06,6) = -3.25 !chad changed april 2017 -6.0
            IF(R>=0.033 .AND. R<0.066)     EGC(06,6) = -3.0
            IF(R>=0.066 .AND. R<0.10)      EGC(06,6) = -2.5
            IF(R>=0.10 .AND. R<0.15)       EGC(06,6) = -2.00
            IF(R>=0.15 .AND. R<0.20)       EGC(06,6) = -1.75
            IF(R>=0.20)                  EGC(06,6) = -1.50
        !--      COTTON
            R = (C(NPT,I,08,7) - C(NPT,I,13,7)) / C(NPT,I,13,7)
            IF(R<0.05)                   EGC(06,7) = -3.50 *0.65
            IF(R>=0.05 .AND. R<0.066)      EGC(06,7) = -3.00 *0.65
            IF(R>=0.066 .AND. R<0.10)      EGC(06,7) = -2.50 *0.65
            IF(R>=0.10 .AND. R<0.15)       EGC(06,7) = -2.20 *0.70
            IF(R>=0.15 .AND. R<0.20)       EGC(06,7) = -2.00 *0.70
            IF(R>=0.20 .AND. R<0.25)       EGC(06,7) = -1.75 *0.70
            IF(R>=0.25 .AND. R<0.30)       EGC(06,7) = -1.50 *0.70
            IF(R>=0.30 .AND. R<0.35)       EGC(06,7) = -1.40 *0.75
            IF(R>=0.35 .AND. R<0.50)       EGC(06,7) = -1.30 *0.75
            IF(R>=0.50 .AND. R<0.55)       EGC(06,7) = -1.25 *0.75 !-0.9
            IF(R>=0.55 .AND. R<0.60)       EGC(06,7) = -1.25 *0.75 !-0.9
            IF(R>=0.60)                  EGC(06,7) = -1.25 *0.75 !-0.9
        !--      RICE
            R = (C(NPT,I,08,8) - C(NPT,I,13,8)) / C(NPT,I,13,8)
            IF(R<0.05)                   EGC(06,8) = -3.0!*1.80
            IF(R>=0.05 .AND. R<0.066)      EGC(06,8) = -3.0!*1.80
            IF(R>=0.066 .AND. R<0.10)      EGC(06,8) = -2.8!*1.50
            IF(R>=0.10 .AND. R<0.15)       EGC(06,8) = -2.2!*1.25
            IF(R>=0.15 .AND. R<0.20)       EGC(06,8) = -1.6!*1.00
            IF(R>=0.20 .AND. R<0.25)       EGC(06,8) = -1.2*1.00
            IF(R>=0.25 .AND. R<0.30)       EGC(06,8) = -1.2*1.00
            IF(R>=0.30 .AND. R<0.35)       EGC(06,8) = -1.2*1.00
            IF(R>=0.35 .AND. R<0.50)       EGC(06,8) = -1.2*1.00
            IF(R>=0.50 .AND. R<0.55)       EGC(06,8) = -1.2*1.00
            IF(R>=0.55 .AND. R<0.60)       EGC(06,8) = -1.2*1.00
            IF(R>=0.60)                  EGC(06,8) = -1.2*1.00
        END IF
    !--
    !--   PEANUTS
        EGPN(1) = 5.0          ! FOOD AND SEED USE (QUOTA) PRICE FLEXIBILITY
        EGPN(2) = 1.0          ! UNRESTRICTED CRUSHING DEMAND PRICE FLEXIBILITY
        EGPN(3) = 2.5          ! ADDITIONALS CONTRACT (EXPORTS) DEMAND PRICE FLEXIBILITY
    !--   SUGARCANE AND SUGARBEETS
        EGC(06,10) = 1.248     ! THIS COEFFICIENTS ARE LINEAR COEFFICIENTS NOT FLEXIBILITES. BOTH
        EGC(06,11) = 1.428     ! FOR SUGARCANE(10) AND SUGARBEETS(11) RESPECTIVELY
    !--    SOYBEAN OIL
        R = (PC(NPT,I,5,1)- PC(NPT,I,6,1))/PC(NPT,I,6,1)
    !     IF(R<0.05)                     EGP(05,1) = -1.50
    !     IF(R>=0.05.AND.R<0.08)       EGP(05,1) = -1.25
    !     IF(R>=0.08.AND.R<0.10)       EGP(05,1) = -0.75
    !     IF(R>=0.10.AND.R<0.12)       EGP(05,1) = -0.50
    !     IF(R>=0.12.AND.R<0.15)       EGP(05,1) = -0.25
    !     IF(R>=0.15)                   EGP(05,1) = -0.00
        IF(R<0.02)                    EGP(05,1) = -8.50
        IF(R>=0.02 .AND. R<0.03)        EGP(05,1) = -7.50
        IF(R>=0.03 .AND. R<0.05)        EGP(05,1) = -6.50
        IF(R>=0.05 .AND. R<0.07)        EGP(05,1) = -5.50
        IF(R>=0.07 .AND. R<0.09)        EGP(05,1) = -4.50
        IF(R>=0.09 .AND. R<0.11)        EGP(05,1) = -3.00
        IF(R>=0.11 .AND. R<0.13)        EGP(05,1) = -1.50
        IF(R>=0.13 .AND. R<0.15)        EGP(05,1) = -1.00
        IF(R>=0.15)                   EGP(05,1) = -0.1          !WAS 0.00
    !--    SOYBEAN MEAL
        R = ((2/PX(I,3,2))*(PC(NPT,I,5,2)-PC(NPT,I,6,2)) + C(NPT,I,8,6)-C(NPT,I,13,6))    & !THIS IS MESSED UP!!! ASK DANIEL IF HE GOT ()IN WRONG PLACE
        /(2/PX(I,3,2))*PC(NPT,I,6,2)
    !      IF (I.GE.7) THEN
    !      WRITE(*,*)R,PC(NPT,I,5,2),PB(I,5,2),'FLEXGR'
    !      WRITE(*,*)C(I,6,2),B(I,6,2),C(NPT,I,8,6),B(I,8,6)
    !      WRITE(*,*)C(I,13,6),B(I,13,6),PX(I,3,2),PC(NPT,I,6,2),PB(I,6,2)
    !      ENDIF
        IF(R<0.01)                   EGP(05,2) = -6.5
        IF(R>=0.01 .AND. R<0.02)       EGP(05,2) = -5.50
        IF(R>=0.02 .AND. R<0.05)       EGP(05,2) = -4.50
        IF(R>=0.05 .AND. R<0.10)       EGP(05,2) = -3.75
        IF(R>=0.10 .AND. R<0.15)       EGP(05,2) = -3.00
        IF(R>=0.15 .AND. R<0.20)       EGP(05,2) = -2.25
        IF(R>=0.20)                  EGP(05,2) = -1.75
        EGP(05,2) = -0.3                                            !ADDED THIS BECAUSE R CALC MESS UP ASK DANIEL!!!
    !      IF(R<0.0050)                EGP(05,2) = -2.25
    !      IF(R>=0.0050.AND.R<0.0075)  EGP(05,2) = -1.90
    !      IF(R>=0.0075.AND.R<0.010)   EGP(05,2) = -1.55
    !      IF(R>=0.010.AND.R<0.015)    EGP(05,2) = -1.20
    !      IF(R>=0.015.AND.R<0.020)    EGP(05,2) = -0.85
    !      IF(R>=0.025)                EGP(05,2) = -0.50
    !--   SUGAR
        R = (PC(NPT,I,5,3)- PC(NPT,I,6,3))/PC(NPT,I,6,3)
        IF(R<0.10)                   EGP(05,3) = -3.0
        IF(R>=0.10 .AND. R<0.12)       EGP(05,3) = -2.00
        IF(R>=0.12 .AND. R<0.16)       EGP(05,3) = -1.00
        IF(R>=0.16)                  EGP(05,3) = -1.00
        RETURN
        END SUBROUTINE FLEXGR

    !     Last change:  CH   23 May 2006   10:41 am
        SUBROUTINE GCAU


        !EIA add
        INTEGER :: II,IEND
    !--
    !--     GRAIN CONSUMING ANIMAL UNITS
    !--

    !--
        SAU(I,1,1)=SAUB(I,1,1)+((XS(NPT,I,9,1)-XSB(I,9,1))/10311)*10.801
        SAU(I,2,1)=SAUB(I,2,1)+((XS(NPT,I,9,1)-XSB(I,9,1))/10311)*0.726
        SAU(I,3,1)=SAUB(I,3,1)+((S(NPT,I,28,1)-SB(I,28,1))+ &
        (S(NPT,I,27,1)-SB(I,27,1)))/27272*18.191
        SAU(I,4,1)=SAUB(I,4,1)+((S(NPT,I,15,1)-SB(I,15,1))/33183)*4.010
        SAU(I,5,1)=SAUB(I,5,1)+((XAG(I,8)-XAGB(I,8))/9.4)*0.212
        SAU(I,6,1)=SAUB(I,6,1)+((XAG(I,6)-XAGB(I,6))/1460)*0
        SAU(I,7,1)=SAUB(I,7,1)+((XAG(I,7)-XAGB(I,7))/2541)*0.514
        SAU(I,8,1)=SAUB(I,8,1)+((XS(NPT,I,27,4)-XSB(I,27,4))/5783.5)*6.085
        SAU(I,9,1)=SAUB(I,9,1)+((S(NPT,I,24,4)-SB(I,24,4))/16124389)*10.359
        SAU(I,10,1)=SAUB(I,10,1)+((S(NPT,I,15,4)-SB(I,15,4))/31917)*1.273
        SAU(I,11,1)=SAUB(I,11,1)+((S(NPT,I,24,5)-SB(I,24,5))/3923416)*3.750
        SAU(I,12,1)=SAUB(I,12,1)+((S(NPT,I,24,2)-SB(I,24,2))/15623)*20.824
    !--   GCAUTOT COMPUTED
        SAU(I,13,1)=SAUB(I,13,1)+(SAU(I,1,1)+SAU(I,2,1)+SAU(I,3,1)+ &
        SAU(I,4,1)+SAU(I,5,1)+SAU(I,6,1)+SAU(I,7,1)+SAU(I,8,1)+ &
        SAU(I,9,1)+SAU(I,10,1)+SAU(I,11,1)+SAU(I,12,1)) - &
        (SAUB(I,1,1)+SAUB(I,2,1)+SAUB(I,3,1)+ &
        SAUB(I,4,1)+SAUB(I,5,1)+SAUB(I,6,1)+SAUB(I,7,1)+SAUB(I,8,1)+ &
        SAUB(I,9,1)+SAUB(I,10,1)+SAUB(I,11,1)+SAUB(I,12,1))
    !--
    !--     HIGH PROTEIN CONSUMING ANIMAL UNITS
    !--
        SAU(I,1,2)=SAUB(I,1,2)+((XS(NPT,I,9,1)-XSB(I,9,1))/10311)*10.801
        SAU(I,2,2)=SAUB(I,2,2)+((XS(NPT,I,9,1)-XSB(I,9,1))/10311)*0.946
        SAU(I,3,2)=SAUB(I,3,2)+((S(NPT,I,28,1)-SB(I,28,1))+ &
        (S(NPT,I,27,1)-SB(I,27,1)))/27272*10.553
        SAU(I,4,2)=SAUB(I,4,2)+((S(NPT,I,15,1)-SB(I,15,1))/33183)*6.904
        SAU(I,5,2)=SAUB(I,5,2)+((XAG(I,8)-XAGB(I,8))/9.4)*1.045
        SAU(I,6,2)=SAUB(I,6,2)+((XAG(I,6)-XAGB(I,6))/1460)*0
        SAU(I,7,2)=SAUB(I,7,2)+((XAG(I,7)-XAGB(I,7))/2541)*0.000
        SAU(I,8,2)=SAUB(I,8,2)+((XS(NPT,I,27,4)-XSB(I,27,4))/5783.5)*9.672
        SAU(I,9,2)=SAUB(I,9,2)+((S(NPT,I,24,4)-SB(I,24,4))/16124389)*28.934
        SAU(I,10,2)=SAUB(I,10,2)+((S(NPT,I,15,4)-SB(I,15,4))/31917)*4.277
        SAU(I,11,2)=SAUB(I,11,2)+((S(NPT,I,24,5)-SB(I,24,5))/3923416)*13.319
        SAU(I,12,2)=SAUB(I,12,2)+((S(NPT,I,24,2)-SB(I,24,2))/15623)*26.452
    !--   HCAUTOT COMPUTED
        SAU(I,13,2)=SAUB(I,13,2)+(SAU(I,1,2)+SAU(I,2,2)+SAU(I,3,2)+ &
        SAU(I,4,2)+SAU(I,5,2)+SAU(I,6,2)+SAU(I,7,2)+SAU(I,8,2)+ &
        SAU(I,9,2)+SAU(I,10,2)+SAU(I,11,2)+SAU(I,12,2)) - &
        (SAUB(I,1,2)+SAUB(I,2,2)+SAUB(I,3,2)+ &
        SAUB(I,4,2)+SAUB(I,5,2)+SAUB(I,6,2)+SAUB(I,7,2)+SAUB(I,8,2)+ &
        SAUB(I,9,2)+SAUB(I,10,2)+SAUB(I,11,2)+SAUB(I,12,2))
    !       WRITE(*,*)'GCAU'
    !       WRITE(*,*)SAU(I,13,2),SAUB(I,13,2)
    !       PAUSE
    !--
    !--     ROUGHAGE CONSUMING ANIMAL UNITS
    !--
        SAU(I,1,3)=SAUB(I,1,3)+((XS(NPT,I,9,1)-XSB(I,9,1))/10311)*10.676
        SAU(I,2,3)=SAUB(I,2,3)+((XS(NPT,I,9,1)-XSB(I,9,1))/10311)*3.359
        SAU(I,3,3)=SAUB(I,3,3)+((S(NPT,I,27,1)-SB(I,27,1))+ &
        (S(NPT,I,28,1)-SB(I,28,1)))/27272*01.882
        SAU(I,4,3)=SAUB(I,4,3)+((S(NPT,I,15,1)-SB(I,15,1))/33183)*53.947
        SAU(I,5,3)=SAUB(I,5,3)+((XAG(I,8)-XAGB(I,8))/9.4)*1.877
        SAU(I,6,3)=SAUB(I,6,3)+((XAG(I,6)-XAGB(I,6))/1460)*0.414
        SAU(I,7,3)=SAUB(I,7,3)+((XAG(I,7)-XAGB(I,7))/2541)*0.994
        SAU(I,8,3)=SAUB(I,8,3)+((XS(NPT,I,27,4)-XSB(I,27,4))/5783.5)*0.224
        SAU(I,9,3)=SAUB(I,9,3)+((S(NPT,I,24,4)-SB(I,24,4))/16124389)*0.0
        SAU(I,10,3)=SAUB(I,10,3)+((S(NPT,I,15,4)-SB(I,15,4))/31917)*0.0
        SAU(I,11,3)=SAUB(I,11,3)+((S(NPT,I,24,5)-SB(I,24,5))/3923416)*0.266
        SAU(I,12,3)=SAUB(I,12,3)+((S(NPT,I,24,2)-SB(I,24,2))/15623)*2.679
    !--   RCAUTOT COMPUTED
        SAU(I,13,3)=SAUB(I,13,3)+(SAU(I,1,3)+SAU(I,2,3)+SAU(I,3,3)+ &
        SAU(I,4,3)+SAU(I,5,3)+SAU(I,6,3)+SAU(I,7,3)+SAU(I,8,3)+ &
        SAU(I,9,3)+SAU(I,10,3)+SAU(I,11,3)+SAU(I,12,3)) - &
        (SAUB(I,1,3)+SAUB(I,2,3)+SAUB(I,3,3)+ &
        SAUB(I,4,3)+SAUB(I,5,3)+SAUB(I,6,3)+SAUB(I,7,3)+SAUB(I,8,3)+ &
        SAUB(I,9,3)+SAUB(I,10,3)+SAUB(I,11,3)+SAUB(I,12,3))
    !--
    !      IF(ABS(SAUB(I,13,2)-SAU(I,13,2))<.05)THEN
    !        SAU(I,13,2)=SAUB(I,13,2)
    !      ENDIF
    !--          !!FOR NOW FEED DEMANDS ARE A % CHANGE IN GCAU'S!!
    !--                 until ers gives us real equations
    !--
    !--     CORN DEMAND FROM LIVESTOCK SECTOR (MIL BU) 65 BU per gcau
    !      XCRB(I,13)=65*XCRB(I,9)
    !               ERS EQUATION FOR COARSE GRAIN FEED DEMAND(found in ERS corn baseline worksheet)

        XCR(NPT,I,13)=XCRB(I,13)+(-4.9961*(C(NPT,I,9,1)-B(I,9,1)) &
        + 1.6534*(SAU(I,13,1)-SAUB(I,13,1)))*2205/56
    !      IF(i==13)then
    !      WRITE(*,*)XCR(NPT,I,13),XCRB(I,13),SAU(I,13,1),SAUB(I,13,1),I
    !      WRITE(*,*)XAG(I,8),XAGB(I,8),XS(NPT,I,9,1),XSB(I,9,1)
    !      WRITE(*,*)S(I,24,4),SB(I,24,4)
    !      PAUSE
    !      endif
    !     IF(XCR(NPT,I,13)<0.0) THEN
    !        WRITE(*,*)'LIV',XCR(NPT,I,13),XCRB(I,13),C(NPT,I,9,1),B(I,9,1)
    !     1 ,SAU(I,13,1),SAUB(I,13,1)
    !     END IF
    !      XCR(NPT,I,13)=XCRB(I,13)*SAU(I,13,1)/SAUB(I,13,1)
    !      XCR(NPT,I,13)=XCRB(I,13)+(XCRB(I,13)*(SAU(I,13,1)-
    !     1          SAUB(I,13,1))/SAUB(I,13,1))
    !--     SOYBEAN DEMAND FROM LIVESTOCK SECTOR(MIL BU) 10.45 BU PER HPAU
    !      XCR(NPT,I,14)=10.45*SAUB(I,13,2)
        XCR(NPT,I,14)=XCRB(I,14)+XCRB(I,14)*(SAU(I,13,2)- &
        SAUB(I,13,2))/SAUB(I,13,2)
    !--     SORGHUM DEMAND             4.255 BU PER GCAU
    !      XCR(NPT,I,15)=4.255*XCR(NPT,I,9)
        XCR(NPT,I,15)=XCRB(I,15)+(XCRB(I,15)*(SAU(I,13,1)- &
        SAUB(I,13,1))/SAUB(I,13,1))
    !--     BARLEY DEMAND
    !      XCR(NPT,I,16)=2.194*XCR(NPT,I,9)
        XCR(NPT,I,16)=XCRB(I,16)+(XCRB(I,16)*(SAU(I,13,1)- &
        SAUB(I,13,1))/SAUB(I,13,1))
    !--     OAT DEMAND
    !      XCR(NPT,I,17)=2.153*XCR(NPT,I,9)
        XCR(NPT,I,17)=XCRB(I,17)+(XCRB(I,17)*(SAU(I,13,1)- &
        SAUB(I,13,1))/SAUB(I,13,1))
    !--     WHEAT DEMAND
    !      XCR(NPT,I,18)=3.42*XCR(NPT,I,9)
        XCR(NPT,I,18)=XCRB(I,18)+(XCRB(I,18)*(SAU(I,13,1)- &
        SAUB(I,13,1))/SAUB(I,13,1))
    !--
        RETURN
        END SUBROUTINE GCAU

    !     Last change:  CH   2021
       SUBROUTINE GRAINS
        IMPLICIT NONE

        REAL ::  RATEOFCHXC(15)
        REAL :: CLAST(5,18),PLAST(3,3),PNLAST(3)                    !,TEMPBX(15)
        REAL :: CONV(18),XD(18),FD(18)
        REAL :: EKCN(3),EKSU(3),SUR(12,18),SURB(12,18)
        REAL :: STOCKMIN(18),STOCKMAX(18),PINC(18),MINPR(18)
        CHARACTER(10) :: CRASH
        REAL :: DIFSTK,EXD,FED,FOD,FID,DIFX,BUY
        REAL :: CONVER
        REAL :: HOLDBEXPORTS(15),HOLDBFEEDD(15),HOLDBFOODD(15)
        INTEGER :: INEGPR
       !EIA add
        REAL RATEOFCHPOP,WLAST,WCURR
        INTEGER J,IONE,LASTCHECKEDK,LASTCHECKEDM,NCROPS,NPRODS
        INTEGER IYEAR1,IDB,IO,NGAUS1,NGAUS2,NGAUSP
 

    !--
    !--                     *****************
    !-- ******************* GRAINS SUBROUTINE *********************
    !--                     *****************
    !--             ***** CROP DEMAND EQUATIONS *****
    !--                  ** USES GAUSS-SIEDEL **
    !--           ******************************
    !--           * THIS ROUTINE IS CALLED FROM:
    !--           * MAIN
    !--           * RELEAS
    !-            ******************************
    !--           * SUBROUTINES CALLS:
    !--           * FLEXGR
    !--           * PRODUCTS
    !--           ******************************
        EKCN(1) = 1.020712     ! Sorghum price wrt Corn Price
        EKCN(2) = 0.609788     ! Oats price wrt Corn Price
        EKCN(3) = 0.772677     ! Barley price wrt Corn Price
        EKSU(1) = -0.01760     ! Sorghum price wrt Stock to Use Ratio
    !     EKSU(2) = -0.44132     ! Oats price wrt Stock to Use Ratio
        EKSU(2) = 0.000000
        EKSU(3) = 0.000000     ! Barley price wrt Stock to Use Ratio
        NCROPS = INDEX(2)      ! NUMBER OF CROPS IN POLYSYS
        NPRODS = INDEX(43)     ! NUMBER OF PRODUCTS IN POLYSYS
        IYEAR1 = INDEX(30)     ! FIRST YEAR OF SIMULATION
        BUY = 0.0
    !--             AUXILLARY WRITE STATEMENTS (UNIT NO., 0 SCREEN, -1 OFF)

        IDB = INDEX(25)
        IO = INDEX(21)

    !--             SET WEIGHTS FOR USE IN GAUSS (OUTSIDE THE LOOP)
        WLAST = .33
        WCURR = 1.0 - WLAST
        NGAUS1 = INDEX(19)     ! NUMBER OF CROP VARIABLES USED IN GAUSS ROUTINE
        NGAUS2 = INDEX(44)     ! NUMBER OF PRODUCT VARIABLES USED IN GAUSS ROUTINE
        NGAUSP = 3             ! NUMBER PEANUT PRICES TO SOLVE FOR IN GAUSS ROUTINE
    !--
    !--             INDEX(31) IDENTIFIES WHICH DEMAND GROUP IS BEING
    !--             WORKED WITH.  GRAINS GROUP IS 1.  THIS VARIABLE
    !--             IS USED IN BANDCK, SUPPRT, AND RELEAS.
        INDEX(31) = 1
    !--             IONE IS USED BY THE DEBUG WRITE ROUTINE.  IT WILL WRITE
    !--             OUT THE VALUES FOR THE FIRST ITERATION OF THE CURRENT
    !--             CALL OF THE SUBROUTINE (CAN BE CALLED FROM RELEAS AND
    !--             AND SUPPRT AS WELL AS MAIN)
        IONE = 1
        IF(BIGITER==1.0)THEN
            DO K = 1,NCROPS
                TEMPBX(K) = B(I,04,K)      ! Hold Exports baseline in temporary storage         !chad uncommented 5/5/04
                TEMPBP(K) = B(I,09,K)      ! Hold PRICE baseline in tem,porary storage
                TEMPBDF(K)= B(I,10,K)      ! Hold Feed demand baseline in temporary storage
                TEMPBDO(K)= B(I,11,K)      ! Hold Food demand baseline in temporary storage
                TEMPBDI(K)= B(I,40,K)      ! Hold industrial demand baseline in temporary storage
           END DO
         ENDIF
    !--
        DO K = 1,NCROPS
            C(NPT,I,08,K)= C(NPT,I,07,K)-C(NPT,L,15,K)-C(NPT,L,16,K)-C(NPT,L,36,K)-C(NPT,L,37,K)


            FD(K) = EGC(7,K)
            XD(K) = EGC(14,K)
            IF(CFIXED(I,4,K)>0.0) THEN                                            !
            !c            B(I,4,K) = CFIXED(I,4,K)    !IN DETERMINISTIC COMMENT  !chad commented TO BE ABLE TO FIX EXPORTS IN WHATIF
            !c            CFIXED(I,4,K) = 0.0         !IN DETERMINISTIC COMMENT  !chad commented
            END IF                                                                 !one more below to uncomment (where we fix exports below)!!                                                             !one more below!!
           END DO
        DO J=1,3                ! Reset iteration counter
            ITERA(I-2,J) = 0
           END DO
        IDONE = 1
    !--             COUNT ITERATION:  ITERA(I-2,KK) I-2 FOR YEAR, KK = 1
        100 ITERA(I-2,1) = ITERA(I-2,1) + 1
        3 FORMAT(' ','>> BACK TO GRAINS ')

    !--
    !--             IF EXCEED ALLOWABLE NUMBER OF ITERATIONS
        IF(ITERA(I-2,1)>INDEX(20))WRITE(*,*)'REACHED LIMIT->' &
        ,ITERA(I-2,1),'  iterations',LASTCHECKEDK,LASTCHECKEDM,K
        IF(ITERA(I-2,1)>INDEX(20))THEN
            GO TO 1000
         ENDIF
    !--
    !--   PUT VALUES FROM PREVIOUS ITERATION INTO CLAST
    !--   FOR USE IN GAUSS-SIEDEL ROUTINE
    !--   IF FIRST TIME THROUGH BASELINE VALUES WILL BE
    !--   USED WHICH WERE SET IN FLEXGR SUBROUTINE
    !--   IF RECALCULATING AFTER STOCK ACTION, THE VALUES
    !--   WILL BE AS SAME AS LAST TIME THE SUBROUTINE WAS
    !--   USED.
    !--   INITIAL VALUES FOR CROPS
    !--
        DO K = 1,NCROPS
            DO J = 1,NGAUS1
            !      J=2
                CLAST(J,K) = C(NPT,I,IGAUS1(J),K)
            END DO
        END DO
    !--   GET PRICE FLEXIBLITY
        IF(ITERA(I-2,1) <= 30)CALL FLEXGR        !!FLEXGR
    !      IF(BIGITER==1.AND.K==7.AND.cfixed(
    !--   ************************
    !--   CALL PRODUCTS SUBROUTINE
    !--   TO BRING IGAUS VALUES TO
    !--   THE SOLUTION ALGORITHM
    !--
        IF(INDEX(48)==1)THEN                   !if using soybean complex
            CALL PRODUCTS
       ELSE
            PC(NPT,I,4,2)=PB(I,4,2)+(PB(I,4,2)*(C(NPT,I,9,6)-B(I,9,6))/B(I,9,6))
        ENDIF
    !--   ********************
    !--   * LOOP MODEL CROPS *
    !--   ********************

    !--
    !--
        DO K = KSAVE,NCROPS
            101 CONTINUE
        !--     ****** EXPORT DEMAND**************    |14 OWN PRICE ELASTICITY
            IF(K <= 8)THEN
                C(NPT,I,04,K) = B(I,04,K) * (1.0 &
                + EGC(14,K) * &
                (C(NPT,I,09,K) - B(I,09,K) ) &
                / (B(I,09,K)*XB(I,36,K)) &
                + EGC(15,K) * (C(NPT,I,09,1) - B(I,09,1)) / B(I,09,1) &
                ) + AJC(04,K) * (C(NPT,L,04,K) - B(L,04,K))
                IF(C(NPT,I,04,K)<0.0) C(NPT,I,04,K) = B(I,04,K)/10.0
            ELSE
                C(NPT,I,4,K)=0
            ENDIF
            IF(CFIXED(I,4,K) > 0.0)C(NPT,I,4,K) = CFIXED(I,4,K) !UNCOMMENTED IN THE 2008POLY !3/2013 This FIXES exports to whatif readin. Make sure above 'shock' is commented!!
        !--
        !c        IF(INDEX(106).EQ.1.AND.I.GT.13)THEN
        !c         C(NPT,I,4,K)=B(I,4,K)
        !c        ENDIF
        !c         write(*,*)b(i,4,1),C(NPT,I,4,1),k,i,'after 2nd'
        !--                                      |07 OWN PRICE
        !--      FEED DEMAND                     |08 INDEX LIVES PRICES
        !--                                      |09 SOYBEAN BY PRODUCTS MARGIN
        !--                                      |10 LIVES PROD UNITS
        !--                                      |11 CORN PRICE
            IF(K==6) THEN
            !            CRMRB(I) = 1
            !            CRMR(I) = CRMRB(I)
                C(NPT,I,10,K) = B(I,10,K) * ( 1.0 &
                + EGC(07,K) * (C(NPT,I,09,K)-B(I,09,K)) / B(I,09,K) &
                + EGC(08,K) * (A(NPT,I,20,3)-AB(I,20,3)) / AB(I,20,3) &
                + EGC(09,K) * (CRMR(I) - CRMRB(I)) / CRMRB(I) &
            !C     4                + EGC(10,K) * (A(NPT,I,5,2) - AB(I,5,2)) / AB(I,5,2)
                + EGC(10,K) * (SAU(I,13,2)-SAUB(I,13,2)) / SAUB(I,13,2) &
                + EGC(11,K) * (C(NPT,I,09,1) - B(I,09,1)) / B(I,09,1) &
                ) + AJC(10,K) * (C(NPT,L,10,K) - B(L,10,K))
            ELSEIF(K >= 9) THEN
                C(NPT,I,10,K) = C(NPT,I,03,K)
            ELSE
                C(NPT,I,10,K) = B(I,10,K) * ( 1.0 &
                + EGC(07,K) * (C(NPT,I,09,K)-B(I,09,K))/B(I,09,K) &
                + EGC(08,K) * (A(NPT,I,20,3)-AB(I,20,3)) / AB(I,20,3) &
                + EGC(09,K) * (PC(NPT,I,4,2) - PB(I,4,2)) / PB(I,4,2) &
            !C     4                + EGC(10,K) * (A(NPT,I,05,2)-AB(I,05,2)) / AB(I,05,2)
                + EGC(10,K) * (SAU(I,13,1)-SAUB(I,13,1)) / SAUB(I,13,1) &
                + EGC(11,K) * (C(NPT,I,09,1) - B(I,09,1)) / B(I,09,1) &
                ) + AJC(10,K) * (C(NPT,L,10,K) - B(L,10,K))
            END IF
        !--
        !--
        !c        IF(K.EQ.4)C(NPT,I,10,K)=B(I,10,K)   !BARLEY  CAUSING PROBLEMS 5/8/07 SO DID THIS
        !c        IF(K.EQ.4)C(NPT,I,4,K)=B(I,4,K)
        !--
        !--
            IF(INDEX(51)==1) THEN                    ! IF USING ERS LIVESTOCK MODEL THEN
                IF(K == 1)C(NPT,I,10,1)=XCR(NPT,I,13)         ! CORN DEMAND FROM ERS LIVESTOCK MODEL EQUATION (GOOD!)
            !           C(NPT,I,10,2)=XCR(NPT,I,15)                   ! THE REST HERE ARE SIMPLY SAME % CHANGE AS
            !           C(NPT,I,10,3)=XCR(NPT,I,17)                   ! GCAU'S FROM ERS MODEL
            !           C(NPT,I,10,4)=XCR(NPT,I,16)                   ! NEED TO FIND OR ESTIMATE NEW EQUATIONS LINKING
            !--         C(NPT,I,10,5)=XCR(NPT,I,18)                   ! GCAUS'S OR HCAU'S AND OTHER VARIABLES TO FEED DEMAND
                       if (k.eq.6) C(NPT,I,10,6)=XCR(NPT,I,14)    !AUG 2020 update
            END IF
            IF(K == 1)THEN
                DRYGSUB=BIOPRD(I,50)/2000*35.65/1000000     !DISTILLERS DRY GRAINS FROM ETHANOL REDUCES CORN FEED DEMAND
                IF(C(NPT,I,10,1) >= DRYGSUB)THEN               !ONE TON OF DISTILLERS GRAINS SUBSTITUTES FOR 35.65 BUSHELS OF CORN (Delucchi, 1998)
                    C(NPT,I,10,1)=C(NPT,I,10,1)-DRYGSUB              !THIS WILL LOWER PRICE OF CORN, THEREBY EFFECTING LIVESTOCK DEMAND
                ELSE                                       !ASSUMING DRY GRAINS WILL SELL JUST ALITTLE CHEAPER THAN CORN FOR FEED.
                    C(NPT,I,10,1) = 0.0
                ENDIF
            ELSEIF(K == 6)THEN
                CONTINUE
            ELSE                                           !!!!!!!!!!!!!!
                C(NPT,I,10,k) = C(NPT,I,10,k)                       !!!!!this was = b(i,10,k) in nri project!!but messed up later years in 25yrversion
            ENDIF                                          !!!!!!!!!!!!!
			IF(CFIXED(I,10,K)>0.0)C(NPT,I,10,K) = CFIXED(I,10,K)  !!2021 update from UT
        !--
        !--             FOOD DEMAND       |11 FOOD DEMAND
        !--      WHEAT, RICE, PEANUTS
            IF(K==1 .OR. K==5 .OR. K==8 .AND. (INDEX(99)==0)) THEN
                IF(CFIXED(I,11,K)>0.0)THEN
                !c               HOLDBFOODD(K) = B(I,11,K)    !  THESE STEMENTS ARE USE TO SHOCK FOOD DEMAND RATHER THAN FIXED THEM
                !c               B(I,11,K) = CFIXED(I,11,K)
       END IF
      END IF
            IF(K==5 .OR. K==8)C(NPT,I,11,K) = B(I,11,K) * (1.0 &
            + EGC(12,K)*(C(NPT,I,09,K)-B(I,09,K))/B(I,09,K) &
            ) + AJC(11,K) * (C(NPT,L,11,K) - B(L,11,K))
        !--      WHEN FOOD DEMAND PREDETERMINED, SET VALUE
            IF(INDEX(99)==0) THEN
                IF(CFIXED(I,11,K)>0.0)C(NPT,I,11,K)=CFIXED(I,11,K)
            END IF
        !--      INDUSTRIAL DEMAND
        !--      CORN                     |13 OWN PRICE
            IF(K == 1)THEN
                C(NPT,I,40,K) = B(I,40,K) * (1.0 &
                + EGC(13,K)*(C(NPT,I,09,K)-B(I,09,K))/B(I,09,K) &
                ) + AJC(09,K) * (C(NPT,L,40,K) - B(L,40,K))
            !--
            ENDIF

        !--
        !--
            IF(K == 1)CALL ETHTRADE
            IF(K == 6)CALL BIODIESTRADE
        !--
        !--
        !--
        !c         IF(K.EQ.1)WRITE(*,*)B(I,40,K),C(NPT,I,40,K),XB(I,2,K),X(I,2,K)
        !c     1 ,'INGRAINS'
        !--      IF INDUSTRIAL DEMAND PREDETERMINED, SET VALUE
            IF(CFIXED(I,40,K)>0.0)C(NPT,I,40,K) = CFIXED(I,40,K)
        !--                                     |10 FEED DEMAND
        !--      TOTAL USE                      |11 FOOD DEMAND (WHEAT, RICE, PEANUTS ONLY)
        !--                                     |04 EXPORTS
        !--                                     |40 INDUSTRIAL DEMAND
        !--                                     |02 OTHER DEMAND
        !------***IMPORTANT***REPEATS FURTHER DOWN*****
            IF(K == 1)THEN
                C(NPT,I,13,K) = C(NPT,I,10,K)+C(NPT,I,11,K)+C(NPT,I,04,K)+X(I,02,K)
            ELSE
                C(NPT,I,13,K) = C(NPT,I,10,K)+C(NPT,I,11,K)+C(NPT,I,04,K)+C(NPT,I,40,K)+X(I,02,K)
            ENDIF

        !--
        !--      ***************************    |07   SUPPLY
        !--      TOTAL ENDING YEAR INVENTORY    |13   TOTAL USE
        !--      ***************************
            C(NPT,I,14,K) = C(NPT,I,07,K) - C(NPT,I,13,K)
        !     1                + C(NPT,I,15,K) + C(NPT,I,16,K) + C(NPT,I,36,K) + C(NPT,I,37,K)
        !--      ********************************  |14  TOTAL ENDING STOCK
        !--      COMMERICAL ENDING YEAR INVENTORY  |15  F-O-R ENDING STOCK
        !--      ********************************  |16  CCC ENDING STOCK
            C(NPT,I,17,K) = C(NPT,I,14,K)-C(NPT,I,15,K)-C(NPT,I,16,K)-C(NPT,I,36,K)-C(NPT,I,37,K) &
            - C(NPT,I,38,K)
        !--      ******************
        !--      STOCK TO USE RATIO
        !--      ******************
            IF(B(I,13,K)==0.0)THEN
                B(I,12,K) = 0.0
            ELSE
                B(I,12,K) = B(I,17,K)/B(I,13,K)
            ENDIF
            IF(C(NPT,I,13,K)==0.0)THEN
                C(NPT,I,12,K) = 0.0
            ELSE
                C(NPT,I,12,K) = C(NPT,I,17,K)/C(NPT,I,13,K)
            ENDIF
        !--      *****                          |08   EFFECTIVE SUPPLY
        !--      PRICE                          |13   TOTAL DEMAND
        !--      *****
        !--
            IF(K>=9)THEN
                C(NPT,I,9,K) = B(I,9,K)
            !c         ELSE IF (K==12) THEN
            !c            C(NPT,I,9,K) = B(I,9,K) +
            !c     1                ( 1.0 + (1/(-0.51))*(C(NPT,I,3,K)-B(I,3,K))/B(I,3,K))
            !c         ELSEIF(K>1.AND.K<5) THEN
            !c            IF(C(NPT,I,12,K)<0.0)C(NPT,I,12,K) = B(I,12,K)                   !!important sets ratio to baseline if zero
            !c            C(NPT,I,9,K) =B(I,9,K)*(1+EKCN(K-1)*(C(NPT,I,9,1)-B(I,9,1))/B(I,9,1)
            !c     1               +EKSU(K-1)*(C(NPT,I,12,K)-B(I,12,K))/B(I,12,K))
            ELSE
                C(NPT,I,09,K) = B(I,09,K) * (1.0 &
                + EGC(06,K) * (((C(NPT,I,08,K) - B(I,08,K)) &
                - (C(NPT,I,13,K) - B(I,13,K))) / B(I,13,K)))
                IF(C(NPT,I,09,K)<0.01)C(NPT,I,9,K) = B(I,9,K)/5.0
            END IF
        !--


            IF(CFIXED(I,09,K) /= 0.0)C(NPT,I,09,K) = CFIXED(I,09,K)
        !--
        !--    ***IMPORTANT**THIS IS 2ND FIGURING OF C(13)**OTHER ABOVE**
            IF(K == 1)THEN
                C(NPT,I,13,K) = C(NPT,I,10,K)+C(NPT,I,11,K)+C(NPT,I,04,K)+X(I,02,K)
            ELSE
                C(NPT,I,13,K) = C(NPT,I,10,K)+C(NPT,I,11,K)+C(NPT,I,04,K)+C(NPT,I,40,K)+X(I,02,K)  !DONT TAKE DIFFERENCE!!!!
            ENDIF
        !--
      END DO
    !--   ************* END OF CROP DO LOOP ****************************
        4 FORMAT(' ','*** ITERATION NO.',I3,' ***',/,T3,'CROP',T14,'FEED' &
        ,T24,'FOOD',T31,'EXPORTS',T39,'TOTAL USE',T53,'PRICE' &
        ,T61,'TOT END',T71,'COM END')
    !--
        6 FORMAT(' ',T4,I2,T7,4F10.1,F10.2,2F10.1)
    !--
        IF(IDB>=0 .AND. (IONE==1 .OR. MOD(ITERA(I-2,1),5)==0)) THEN
            IONE = IONE + 1
            WRITE(IDB,4)ITERA(I-2,1)
            DO K = 1,NCROPS
                8 WRITE(IDB,6)K,C(NPT,I,10,K),C(NPT,I,11,K),C(NPT,I,04,K),C(NPT,I,13,K) &
                ,C(NPT,I,09,K),C(NPT,I,14,K),C(NPT,I,17,K)
      END DO
        ENDIF
    !--   ************************|IGAUS1 1 EXPORTS    IGAUS2 1 EXPORTS    IGAUSP 1 FOOD PEANUT PRICE QUOTA
    !--   * GAUSS-SIEDEL ROUTINE *|       2 PRICE             2 PRICE             2 UNRESTRICTED CRUSHED PRICE
    !--   ************************|       3 DOM.DEMAND1       3 DOM.DEMAND1       3 CONTR. ADN'L (EXPORT)PRICE
    !--                           |       4 DOM.DEMAND2
    !--   TAKES WEIGHTED AVERAGE OF LAST ITERATION AND CURRENT ITERATION VALUES OF VARIABLES FOR USE THE NEXT TIME
    !--   THROUGH THE DEMAND EQUATIONS.  THIS CONTINUES UNTIL NONE OF THE VARIABLE VALUES CHANGE APPRECIABLY FROM
    !--   THE PREVIOUS ITERATION.
    !--   SET IDONE = 0, IF CONVERGENCE CHECK FAILS, IDONE IS SET TO 1
        IDONE = 0
    !--   ***************************
    !--   * LOOP ACROSS MODEL CROPS *
    !--   ***************************
        DO K = 1,NCROPS        ! NCROPS NUMBER OF CROPS IN POLYSYS
            DO J = 1,NGAUS1             ! NGAUS1 NUMBER OF SIMULTANEOUS VARIABLES PER CROP
            !         J=2
            !            IF(K>1.AND.K<5)GOTO 200                                                            !!this avoids sorghum
            !c            IF(K==9.AND.J==2) GOTO 200   ! DO NOT SOLVE FOR SEASONAL AVERAGE PEANUTS PRICE      !!only solving corn and sybns
            !--      TAKE WEIGHTED AVERAGE USING WEIGHTS ASSIGNED AT TOP OF ROUTINE
                IF(C(NPT,I,IGAUS1(J),K)<0.0)C(NPT,I,IGAUS1(J),K) = B(I,IGAUS1(J),K)                     !!!if<zero back to baseline
                C(NPT,I,IGAUS1(J),K) = WLAST*CLAST(J,K) + WCURR*C(NPT,I,IGAUS1(J),K)                      !!this not working of sorghum
            !--      IF IDONE = 1 ALREADY FOUND A VARIABLE THAT HASN'T
            !--      CONVERGED -- NO SENSE CHECKING THIS VARIABLE
            !--      IF CLAST(J,K) = 0.0 WILL CAUSE DIVIDE BY ZERO ERROR
            !--      IF AT LEAST ONE IS TRUE, GO AROUND CONVERGENCE CHECK
                IF(IDONE==1 .OR. CLAST(J,K)==0.0)GO TO 200
            !--      CHECK TO SEE THIS VARIABLE VALUE HAS CONVERGED OR
            !--      CHANGED FROM ITS VALUE IN THE PREVIOUS ITERATION
            !--      IF VARIABLE HAS CONVERGED GO AROUND FLAG SETTING INSTRUCTION
            !--      IF STATEMENT IS NOT TRUE THEN NEXT STATEMENT WILL SET
            !--      IDONE = 1 AND NO MORE CONVERGENCE TESTS WILL BE
            !--      CONDUCTED DURING THE REST OF THE LOOP
                LASTCHECKEDK = K     ! THIS IS FOR DEBUGGING PURPOSES ONLY K INDICATES WHICH CROP
                LASTCHECKEDM = 1     ! AND THE 1 INDICATES WICH GAUS SET
           !     IF(I <= 12)THEN
                              IF(K==2.AND.(C(NPT,I,9,2)-C(NPT,I,9,1)).GE.-0.05) C(NPT,I,9,2)=C(NPT,I,9,1)-0.05    !2021 update     !!sorghum must be less than corn price!!  Aug 2020 update
          !      ENDIF
                CONVER=(ABS((C(NPT,I,IGAUS1(J),K)-CLAST(J,K))/CLAST(J,K))-0.001)
            !            WRITE(*,*)C(NPT,I,IGAUS1(J),K),CLAST(J,K)
            !            WRITE(*,*)ITERA(I-2,1),J,K,CONVER
            !            PAUSE
            !             IF(K>1.AND.K<5)GOTO 200
            !c             IF(K>1.AND.K<3)GOTO 200  !this skips sorghum
                IF((ABS((C(NPT,I,IGAUS1(J),K)-CLAST(J,K))/CLAST(J,K))-0.001) &
                <= 0.0)GO TO 200
            !--      FLUNKED TEST
                IDONE = 1
                200 CONTINUE
            !         C(NPT,I,23,K)= EGC(6,K)
            !               END IF
            !         WRITE(*,*)'PRICE->',K,J,C(NPT,I,IGAUS1(J),K),CLAST(J,K),N,CONVER
            END DO                         ! End of J Loop
        !         WRITE(*,*)'PRODC->',K,C(NPT,I,3,K),B(I,3,K)
        END DO                    ! End of K Loop
    !--   IF CONVERGENCE FAILED, KEEP ON TRUCKIN'
        IF(IDONE>0)GO TO 100
    !--   CONVERGENCE ACHIEVED  GO HOME!
    !--   (WRITE OUT RESULTS IF IDB IS ON)C--
        500 IF(IDB>=0 .AND. MOD(ITERA(I-2,1),5)/=0 .AND. IONE/=2) THEN
            WRITE(IDB,4)ITERA(I-2,1)
            DO K = 1,NCROPS
                WRITE(IDB,6)K,C(NPT,I,10,K),C(NPT,I,11,K),C(NPT,I,04,K),C(NPT,I,13,K) &
                ,C(NPT,I,09,K),C(NPT,I,14,K),C(NPT,I,17,K)
            END DO
        ENDIF
    !--
        RETURN
        1000 WRITE(IO,1005) INDEX(20),LASTCHECKEDK,LASTCHECKEDM,I
        1005 FORMAT(' ','REACHED MAXIMUM NUMBER OF ITERATIONS:',I4,/ &
        ,' CROP-> ',I2,'  MATRIX-> ',I2,'  PERIOD-> ',I2)
    !--
    !      IF(CRASHYR.EQ.CRASHYROLD.AND.N.EQ.NOLD)GOTO 555
    !c      if(crashnumber.eq.1)then
    !C              CRASH='CRASH.TXT'
    !              OPEN(UNIT=134,FILE=CRASH)
    !      endif
    !       WRITE(134,*)CRASHNUMBER,CRASHYR,N,I,k           !RECORDS YEARS OF YIELD DRAWS THAT MADE CRASH
    !       crashyrold=crashyr
    !       Nold=N
        555 CONTINUE
    !c            CLOSE(77)

    !c            pause
    !--
        RETURN
        END SUBROUTINE GRAINS
    !     Last change:  CH   11 Jul 2006   12:07 pm


    !     Last change:  CH   2021  12:07 pm
        SUBROUTINE HARVEST
        IMPLICIT NONE


        !EIA add
        INTEGER :: IISTART, NCROPS,  J, IR

    !--
        IISTART = INDEX(30) - INDEX(27) + 3
        NCROPS = INDEX(2)
        POLY=INDEX(63)
        CNTY=INDEX(33)
    !--
        DO CTY=1,CNTY
        !--
            DO K=1,NCROPS
            !--
            !--     SET TOTALS TO ZERO
                CY(2,K,4,CTY) = 0.0
                CY(6,K,4,CTY) = 0.0
                CY(4,K,4,CTY) = 0.0
                DO J=10,24
                    CY(J,K,4,CTY) = 0.0
                END DO
            !--
                DO T=1,3
                !--
                    IF(K /= 9 .AND. K /= 10 .AND. K /= 11 .AND. K /= 13 &
                    .AND. K /= 16 .AND. K /= 17)THEN
                    !--       Harvested Acres = Planted Acreage above * PlAc
                        CY(2,K,T,CTY) = CY(1,K,T,CTY) * PlAC(1,K,T,CTY)
                       ! if (k.eq.1) write(668,*) 'cy2=', curcalyr,CY(2,K,T,CTY) ,CY(1,K,T,CTY) , PlAC(1,K,T,CTY), cty,t
                    ENDIF
                    CY(2,K,4,CTY) = CY(2,K,4,CTY) + CY(2,K,T,CTY)   !TOTAL FOR CROP
                !--
                    IF(K /= 9 .AND. K /= 10 .AND. K /= 11 .AND. K /= 13 &
                    .AND. K /= 16 .AND. K /= 17)THEN

                    !--       Output = Harvested Acreage * Yield
                        CY(4,K,T,CTY) = CY(2,K,T,CTY) * CYX(25,K,T,CTY)
						
                   !OILSEED/COTTON/SOY  !2021 update
            IF(K.EQ.15)THEN !.AND.T.EQ.1)THEN  !ADD DOUBLE CROPPED CORN TO CORN PRODUCTION AND SOY TO SOY PRODUCTION
              CY(4,15,T,CTY) = CY(2,K,T,CTY) * CYX(25,K,T,CTY) * 0.5  !ONLY 1/2 ACRE OF EVERY ACRE IN THE ROTATION IS IN PENNYCRESS, SO HALVE THE PRODUCTION
                
              CY(4,7,T,CTY) = CY(4,7,T,CTY) + (CY(2,15,T,CTY) &
                 * 0.5 * CYX(25,7,T,CTY)*(1-COTTONDOCK(T,CTY))) !CYX(39,18,2,CTY)))        !ACREAGE OF PENNYCRESS/CORN DOUBLE CROP * X% LESS THAN NORMAL CORN YIELD     ONLY 50% OF YIELD BECAUSE ONLY 1/2 ACRE
              CY(4,6,T,CTY) = CY(4,6,T,CTY) + (CY(2,15,T,CTY) &
                 *0.5 * CYX(25,6,T,CTY)*(1-SOYDOCKCT(T,CTY))) !CYX(39,18,3,CTY)))        !ACREAGE OF PENNYCRESS/SOY DOUBLE CROP * X% LESS THAN NORMAL SOY YIELD      ONLY 50% OF YIELD BECAUSE ONLY 1/2 ACRE 
            ENDIF   
             !OILSEED/CORN/SOY    
 
                        IF(K == 18 .AND. T == 1)THEN  !ADD DOUBLE CROPPED CORN TO CORN PRODUCTION AND SOY TO SOY PRODUCTION
                            CY(4,18,T,CTY) = CY(2,K,T,CTY) * CYX(25,K,T,CTY) * 0.5  !ONLY 1/2 ACRE OF EVERY ACRE IN THE ROTATION IS IN PENNYCRESS, SO HALVE THE PRODUCTION

                            CY(4,1,T,CTY) = CY(4,1,T,CTY) + (CY(2,18,T,CTY) &
                            * 0.5 * CYX(25,1,T,CTY)*(1-CORNDOCK(T,CTY)))       !ACREAGE OF PENNYCRESS/CORN DOUBLE CROP * X% LESS THAN NORMAL CORN YIELD     ONLY 50% OF YIELD BECAUSE ONLY 1/2 ACRE
                            CY(4,6,T,CTY) = CY(4,6,T,CTY) + (CY(2,18,T,CTY) &
                            *0.5 * CYX(25,6,T,CTY)*(1-SOYDOCK(T,CTY)))      !ACREAGE OF PENNYCRESS/SOY DOUBLE CROP * X% LESS THAN NORMAL SOY YIELD      ONLY 50% OF YIELD BECAUSE ONLY 1/2 ACRE
                        ENDIF
                    !--
		    !!end 2021 update 
                    ENDIF
                    CY(4,K,4,CTY) = CY(4,K,4,CTY) + CY(4,K,T,CTY)   !TOTAL FOR CROP
                !--
                !          IF(CY(4,K,T,CTY).LT.0.0)THEN
                !              WRITE(*,*)'RMAIN',CY(4,K,T,CTY),K,T,CTY
                !              PAUSE
                !          ENDIF
                !--
                !--       Tot.Cost = AVC*Pl.Ac.
                CY(6,K,T,CTY) = CYB(6,K,T,CTY) +  ((CYX(23,K,T,CTY) * CY(1,K,T,CTY)) - &
                        (CYXB(23,K,T,CTY)*CYB(1,K,T,CTY)))           !region change version

              !      CY(6,K,T,CTY) = CYX(23,K,T,CTY) * CY(1,K,T,CTY) !CYB(6,K,T,CTY)
                !     1                  - CYXB(23,K,T,CTY) * CYB(1,K,T,CTY))
                    CY(6,K,4,CTY) = CY(6,K,4,CTY) + CY(6,K,T,CTY)   !TOTAL FIRST
                !--
                    IF(CY(2,K,T,CTY) > 0.0)THEN
                        CY(3,K,T,CTY) = CY(4,K,T,CTY)/CY(2,K,T,CTY)  !YIELD
                    ELSE
                        CY(3,K,T,CTY) = 0.0
                    ENDIF
                !--
                ENDDO !end t

            !!!!!!!!!!!!
            !--   FIGURE 'PER UNIT' OF TOTAL COST FOR EACH CROP  (this is for output in ctyout file)
            !---   SWEET SORGHUM IS AN ANNUAL CROP, SO FIGURE  TOTAL COST PER DT AND PROFIT SEPARATELY
            !--
                IR=100 !30
            !--
                IF(K == 9 .OR. K == 10 .OR. K == 11 .OR. K == 16 .OR. K == 17)THEN   !!!!!!!!PERENNIAL BIOMASS CROPS!!!!!!!!!!
                !--
                !--
                    DO T=1,3
                        IF(CY(1,k,T,CTY) > 0.0)THEN                                            !(PRICE*DT
                            CY(30,k,T,CTY) = CFIXED(I,9,k)      & !GROWER PAYMENT =
                            - CY(28,k,T,CTY)/CY(29,k,T,CTY)                   !HARVCOSTSPERACRE/DT OVER ALL YEARS)
                        !--
                            CY(33,K,T,CTY) = (CYX(23,K,T,CTY)*IR) /                            & !TOTAL COST PER DRY TON = AVERAGE TOTAL COST PER ACRE*YEARS OF ROTATION / DT PER ACRE OVER ROTATION PERIOD
                            CY(29,K,T,CTY)
                        !--
                            CY(34,K,T,CTY) = CY(5,K,T,CTY)-CY(33,K,T,CTY) !PROFIT PER UNIT OF PRODUCTION = PRICE PER UNIT - COST PER UNIT
                        !--
                        ELSE
                            CY(30,k,T,CTY)=CY(5,K,T,CTY) !0.0         !IF NO PLANTED ACRES, THEN NO GROWER PAYMENT
                            CY(33,K,T,CTY)=0.0                              !TOTAL COST PER UNIT PRODUCTION
                            CY(34,K,T,CTY)=0.0                              !PROFIT PER UNIT PRODUCTIOJN
                        ENDIF
                    !--
                    ENDDO !END T
                !--
                !--
                ELSE   !!!!!!!!!!!!ANNUAL CROPS = CONVENTIONAL CROPS + SWEET SORGHUM!!!!!!!!!!!!!!
                !--
                !--
                    DO T=1,3
                        CY(29,K,T,CTY)=CY(3,K,T,CTY)*IR  !THE SUM OF YIELD FOR OTHER CROPS IS SIMPLY THE ANNUAL YIELD*NUMBER OF YEARS OF PLANNING PERIOD(20)...USED IN PRINTREG OUTPUT
                        IF(CY(2,K,T,CTY) > 1.0 .AND. CY(3,K,T,CTY) > 0.0)THEN
                        !--
                            CY(30,K,T,CTY) = CY(5,K,T,CTY) !SET 'GROWER PAYMENT' TO PRICE (BECAUSE HARVEST COSTS ARE NOT SEPARATED OUT)
                        !--
                            CY(33,K,T,CTY) = CYX(23,K,T,CTY)*IR /  & !TOTAL COST PER DRY TON
                            CY(29,K,T,CTY)
                        !--
                            CY(34,K,T,CTY) = CY(5,K,T,CTY)-CY(33,K,T,CTY) !PROFIT PER UNIT OF PRODUCTION = PRICE PER UNIT - COST PER UNIT
                        ELSE
                            CY(33,K,T,CTY) = 0.0
                            CY(30,K,T,CTY) = CY(5,K,T,CTY) !0.0
                            CY(34,K,T,CTY) = 0.0
                        ENDIF
                    !--
                    ENDDO
                ENDIF
            !--
            !!!!!!!!!!!!
            ENDDO   !end k
        ENDDO     !end cty
    !--
    !--
        RETURN
        END SUBROUTINE HARVEST
    !     Last change:  CH   2021
         SUBROUTINE INDX
        IMPLICIT NONE


         INTEGER II,J, NUMYR
    !--
    !--   VER. 1.0
    !--
    !--                     ****************
    !-- ******************  INDX SUBROUTINE  *********************
    !--                     ****************
    !--
    !--          ************************************
    !--          * THIS SUBROUTINE IS CALLED FROM
    !--          * MAIN.FOR
    !--          ************************************
    !--
    !--              ***THIS INDICES WERE IN SIM.INS BUT ARE HARDWIRED HERE FOR NOW
    !--      below taken out nov 2014 for harry baumes
    !C      INDEX(99)=0  !0<- 0 IF DETERMINISTIC ANALYSIS; 1 IF STOCHASTIC  [99]                  # ALWAYS RUN THIS AS DETERMINISTIC DURING BASELINE RUNS #
    !C      INDEX(102)=1 !1<- 1 IF LAND RENTAL RATES INCLUDED IN TOTAL COSTS; 0 OF NOT[102]       # MUST RERUN BASELINE #
    !C      INDEX(86)=0  !0<- 0 TILLAGE PRACTICE FLEXIBILITY 0 TO 3; 0=LOW 3=HIGH [86]            # MUST RERUN BASELINE #
    !C      INDEX(84)=0  !0<- 0 IF USING BASE CASE YIELD GROWTH ASSUMPTIONS (for residues); 1 IF USING HIGH YIELD GROWTH ASSUMPTIONS [84]
    !C      INDEX(22)=0  !0<-   0 IF NO LandUseChange FIGURING; 1 IF WANT TO FIGURE LUC [22]

    !--      below taken out before oct 2014
        INDEX(42)= 1 !1<- Baseline Used: 0 FAPRI; 1 USDA ; 2 CBO ; 3 OTHER [42]
        INDEX(69)= 0 !0<- 0 IF RESIDUES NOT CONSTRAINED BY CARBON; 1 IF RESIDUES CONSTRAINED TO CARBON-NEUTRAL [69]                         !only pertains if [83]=0
        INDEX(83)= 1 !1<- 0 IF USING OLD RAIN,WIND,CARBON CONSTRAINTS; 1 IF USING NEW DAVE MUTH RUSLE2 CONSTRAINTS [83]
        INDEX(78)= 0 !0<- 0 IF NO CARBON INCENTIVES TO ANY CROPS; 1 IF ALLOW CARBON INCENTIVES [78]
        INDEX(75)= 1 !1<- 1 IF FERTILIZERS EXEMPT IN CARBON BILL; 0 IF NOT EXEMPT [75]
        INDEX(76)= 0 !0<- 0 IF BIOMASS CROPS NOT RECEIVING CARBON SEQUESTRATION INCENTIVES;1 IF BIOMASS CROPS RECEIVE CARBON INCENTIVE [76]
        INDEX(72)= 0 !0<-   0 IF CELLULOSIC TO FILL ENDOG DEMAND; 1 IF MODEL DECIDES CORNGRAIN/CELL MIX [72]
        INDEX(79)= 0 !0<- 0 IF DON'T HAVE TO MEET Renewable Elect Standard; 1 of meet RES [79]
        INDEX(82)= 0 !0<- 0 IF USING ORNL SWITCHGRASS YIELDS; 1 IF USING OLD WESTWARD SWITCH YIELDS [82]            ###must rerun baseline###
        INDEX(81)= 0 !0<-   0 IF NO IMPLANB PRINTOUT; 1 IF WANT IMPLANB PRINTOUT [81]
    !--
      INDEX(30)=2020 !2013<- FIRST YEAR TO SIMULATE [INDEX(30)]    !!****UPDATE THIS WITH THE BASELINE***!!!
        INDEX(80) =0 !0<- 0 IF NO CROPLAND TO PASTURE CONVERSION; 1 IF ALLOW CROPLAND TO PASTURE CONVERSION [80]    ###MUST RERUN BASELINE###      !using as proxy for possible 'MiG' movements
    !c      INDEX(101)=0 !0<-   1 IF ALLOW DOMESTIC CORN DEMAND FOR ETHANOL TO FALL UNDER HIGH PRICES[101]
        INDEX(77)= 1 !1<-   0 IF NO POPLARS AND WILLOWS AS BIOMASS CROPS; 1 IF POPLARS AND WILLOW INCLUDED [77]
    !0<-   WOODY - 'Logging' % OF AVAILABLE TO TAKE (1-100) [52]
    !0<-   WOODY - 'Thinnings' RATIO OF AVAILABLE TO TAKE [54]
    !0<-   WOODY - 'Primary Wood Waste' RATIO OF AVAILABLE TO TAKE [55]
    !0<-   WOODY - 'Urban Wood Waste' RATIO OF AVAILABLE TO TAKE [56]
    !0<-   WOODY - 'Standing Wood Harvesting' RATIO OF AVAILABLE TO TAKE [57]
        INDEX(105)= 1 !0<- 1 IF USING CRP NCCPI VALUE TO ESTIMATE CROP YIELD, 0 IF EXOGENOUS % REDUCTION LEVEL [105]
    !--
    !--
    !--          ****** ASSIGN VALUES TO INDEX ARRAY ******
    !--
        INDEX(2) = 18 !15  ! NUMBER OF MODEL CROPS [NCROPS] 11
        INDEX(3) = 50  ! NUMBER OF VARIABLES IN C & B (2ND SUBSCRIPT) [NVARC]
        INDEX(4) = 48  ! NUMBER OF VARIABLES IN X & XB (2ND SUBSCRIPT) [NVARX]
        INDEX(5) = 6   ! NUMBER OF MODEL LIVESTOCK COMMODITIES [NLVSK]
        INDEX(6) = 63  ! NUMBER OF VARIABLES IN S & SB (2ND SUBSCRIPT) [NVARS]
        INDEX(7) = 33  ! NUMBER OF VARIABLES IN XS & XSB (2ND SUBSCRIPT) [NVARXS]
        INDEX(8) = 2   ! NUMBER OF PAGES IN XA (3RD SUBSCRIPT) [NPGXA] (OUT OF USUAL ORDER)
        INDEX(9) = 18  ! NUMBER OF J VARIABLES IN XCR LIVESTOCK MATRIX
        INDEX(10) = 13 ! NUMBER OF J VARIABLES IN SAU LIVESTOCK MATRIX
        INDEX(11) = 1  ! READ IN SIM.INS WHICH LIVESTOCK BASELINE ROUTINE TO RUN
        INDEX(12) = 3  ! NUMBER OF PAGES IN A (3RD SUBSCRIPT) [NPGA]
        INDEX(13) = 41 ! NUMBER OF VARIABLES IN A & AB (2ND SUBSCRIPT) [NVARA]
        INDEX(14) = 10 ! NUMBER OF VARIABLES IN XA (2ND SUBSCRIPT) [NVARXA]
        INDEX(15) = 20 ! NUMBER OF ELASTICITIES IN EGC (1ST SUBSCRIPT) [NEGC]
        INDEX(16) = 11 ! NUMBER OF (1 - ADJ COEF) IN AJC (1ST SUBSCRIPT) IN C ORDER [NAJC]
        INDEX(17) = 3  ! NUMBER OF ELASTICITIES IN EGL (1ST SUBSCRIPT) [NEGL]
        INDEX(18) = 1  ! NUMBER OF (1- ADJ COEF) IN AJL (1ST SUBSCRIPT) IN S ORDER [NAJL]
        INDEX(19) = 5  ! NUMBER OF CROP VARIABLES USED IN GAUSS [NGAUS1] SEE @END FOR CODES
      INDEX(20) = 2000 ! MAXIMUM NUMBER OF ITERATIONS [NMAXIT]
        INDEX(21) = 6  ! 'UNIT' NUMBER FOR WRITE STATEMENTS  [IO]
        INDEX(24) = -7 ! WRITE OUT SUBROUTINE NAME AS EXECUTED TO FILE 7; -7 NOT; 6 SCREEN[24]
        INDEX(25) = -7 ! WRITE OUT DEBUG INFO AS EXECUTED TO FILE 7; -7 NOT; 6 SCREEN[25]
        INDEX(26) = 5  ! UNIT NUMBER FOR READING BASELINE INFORMATION [IN]
        INDEX(31) = 1 ! IDENTIFIES WHICH DEMAND GROUP IS BEING WORKED WITH.  GRAINS GROUP IS 1.
    !--                   THIS VARIABLE IS USED IN BANDCK, SUPPRT, AND RELEAS. NO OTHER SET OF
    !--                   RELATIONSHIPS USE GAUS, CURRENTLY SO VALUE SHOULD REMAIN AT 1.
        INDEX(33) = 3109 !NUMBER OF COUNTIES    !was 3110 in old fips codes, but changed in aug 2008 to 3109
        INDEX(118)= 3109
        INDEX(36) = 0 ! PAGE NUMBER COUNTER, BEGINS ALWAYS AT ZERO [IPAGE]
        INDEX(38) = 14 ! UNIT NUMBER FOR READING SIMULATION TITLES & PARAMETERS
        INDEX(40) = 0
        INDEX(43) = 3  ! Number of Products in PB and PC matrices
        INDEX(44) = 3  ! Number of PRODUCTS Variables in IGAUS2 vector
        INDEX(45) = 10 ! Number of VARIABLES in PB and PC matrices
        INDEX(46) = 4  ! Number of VARIABLES in PXB and PX matrices
        INDEX(47) = 15 ! Number of crops dimesioned in the model  !not used anywhere else, using index(2) instead
        INDEX(48) = 1      !   1<- 1 IF USING SOYBEAN COMPLEX; 0 OTHERWISE[48]
        INDEX(50) = 1  !0= old price flexibilities; 1= new price flexibilities      !   1<- 1 NEW PRICE FLEXIBILITES; 0 OTHERWISE [50]
        INDEX(51) = 1     !   1<- 1 IF USING ERS ANNUAL LIVESTOCK MODEL; 0 OTHERWISE [51]
        INDEX(60) = 0  ! 2 Initial Acreage change intentions IYEAR-1; 1 from Intentios IYEAR-2; 0 otherwise INDEX(60)
        INDEX(61) = 14 ! Number of Endogenous Variables in SUPPLY MODULE
        INDEX(62) = 27 ! Number of Exogenous Variables in SUPPLY MODULE
        INDEX(63) = 305 ! Number of POLYSYS Regions
        INDEX(64) = 9  ! Number of USDA Production Regions
        INDEX(65) = 39 ! J VARIABLES IN CYX AND CYXB
        INDEX(66) = 1  ! First L index value in ALL matrices for POLYSYS Regions
        INDEX(67) = INDEX(63) + 1    ! First L index value in ALL matrices for USDA Regions
        INDEX(68) = INDEX(67) + 9    ! First L index value in ALL matrices for State Regions
        INDEX(74) = 0      ! TO SPECIFY IF EXOGENOUS OR ENDOGENOUS BIOENERY PRICES [74]
        INDEX(75) = 0 !1 IF FERTILIZER CARBON IS EXEMPT FROM CARBON BILL; 0 IF NO EXEMPT [75] !!DEFINED IN SIM.INS
        INDEX(76) = 0 !0 IF BIOMASS CROPS NOT RECEIVING CARBON SEQUESTRATION INCENTIVES;1 IF BIOMASS CROPS RECEIVE CARBON INCENTIVE [76] !!DEFINED IN SIM.INS
    !!      INDEX(77) = 0 !0 IF NO POPLARS AND WILLOWS AS BIOMASS CROPS; 1 IF POPLARS AND WILLOW INCLUDED [77] !DEFINED IN SIM.INS
        INDEX(78) = 0 !0 IF NO CARBON INCENTIVES TO ANY CROP; 1 IF ALLOW CARBON INCENTIVE [78]
        INDEX(79) = 0 !0 IF DON'T HAVE TO MEET Renewable Elect Standard; 1 of meet RES [79]
        INDEX(80) = 0 !0 IF NO AFFORESTATION; 1 IF AFFORESTATION [80]
        INDEX(81) = 0 !0 NO IMPLANB PRINTOUT; 1 IF WANT IMPLANB PRINTOUT [81]
        INDEX(89) = 0  ! 1 IF EXPECTED PRICE 3 YR LAG; 0 IF EXPECTED PRICE 1 YR LAG [89]
    !c      INDEX(92) = 0 !1      ! 0 IF USING CASH COST PER ACRE; 1 IF USING VARIABLE COST PER ACRE [92]
        INDEX(100) = 100 !12 !100 !100 ! Number of Iterations of Stochastic Subroutines
    !--   ***********
    !--   NGAUS1 VARIABLE CODES FROM C MATRIX (SECOND SUBSCRIPT)
    !--   WHICH ARE USED IN GAUSS SECTION OF THE FGWTDM SUBROUTINE.
    !--
        IGAUS1(1) = 4  ! EXPORTS
        IGAUS1(2) = 9  ! PRICE
        IGAUS1(3) = 10 ! DEMAND 1 (FEED, CRUSH, OR MILL)
        IGAUS1(4) = 11 ! DEMAND 2 (FOOD - ONLY WHEAT USING THIS)
        IGAUS1(5) = 40 ! DEMAND 2 (INDUSTRIAL DEMAND)
    !--   ***********
    !--   NGAUS2 VARIABLE CODES FROM C MATRIX (SECOND SUBSCRIPT)
    !--   WHICH ARE USED IN GAUSS SECTION OF THE FGWTDM SUBROUTINE.
        IGAUS2(1) = 3  ! EXPORTS
        IGAUS2(2) = 4  ! PRICE
        IGAUS2(3) = 2  ! DOMESTIC DEMAND
    !--   ***********
    !--   IGAUSP VARIABLE CODES FROM PNB AND PN MATRIX (SECOND SUBSCRIPT)
    !--   WHICH ARE USED IN GAUSS SECTION OF THE GRAINS SUBROUTINE.
        IGAUSP(1) = 1  ! EXPORTS
        IGAUSP(2) = 2  ! PRICE
        IGAUSP(3) = 3  ! DOMESTIC DEMAND
    !--   *************************************************
    !--   THIS SECTION ZEROES OUT THE NUMBER OF ITERATIONS MATRIX
        NUMYR = INDEX(1)
        DO I = 1,NUMYR
            DO J = 1,3
                ITERA(I,J) = 0
         END DO
           END DO
        RETURN
        END SUBROUTINE INDX

    !update fom UT 2021
       SUBROUTINE INFLATEBIO
        IMPLICIT NONE

        !EIA add
        INTEGER :: ISTART, IEND, NCROPS,  H, J, IV, IY
    !--
        ISTART=(INDEX(30)-INDEX(27))+3
        IEND = INDEX(1) +(INDEX(30)-INDEX(27)) + 2
        NCROPS = INDEX(2)
        POLY=INDEX(63)
        CNTY=INDEX(33)
    !--
        if(index(106) == 3)then !only inflate these in the simulation because may do it double if do it in the baseline
        !--    **INFLATE BIOMASS HARVEST COSTS**
        !--      (switchgrass, miscanthus) !willows was here, but harvest costs no longer in wilcost
            DO H=1,71
                DO J=2,11
                    DO K=1,5
                        HARVC(H,J,K)=HARVC(H,J,K)*(INFL(I,1,1))   !HARVEST COSTS ARE READ FROM BASELINE EVERY YEAR, SO DON'T HAVE TO WORRY ABOUT A HARVCB VARIABLE
                    ENDDO
                ENDDO
            ENDDO
        !--   **INFLATE BIOMASS HARVEST COSTS**
        !--     (POPLAR AND ECANE, willow)
            DO CTY=1,CNTY
                DO K=1,6
                    HARVESTCOST(K,CTY)=HARVESTCOST(K,CTY)*(INFL(I,1,1))
                ENDDO
            ENDDO
        !--
        !--  **INFLATE BIOMASS PRODUCTION COSTS
        !--      (SWITCHGRASS, MISCANTHUS, ECANE, WILLOW, POPLAR)
            DO CTY=1,CNTY
                DO IV=1,35  ! update 2021  was 100 !Update from UT 2019
                    DO J=1,21
                        DO K=1,5
                        !--                                          !!ADJUST SWITCHGRASS IN BASELINE, CUS DOESN'T EXIST IN USDA BASELINE
                            CMX(IV,J,K,CTY)=CMX(IV,J,K,CTY)*INFL(I,1,1)      ! COSTS ARE READ FROM BASELINE EVERY YEAR, SO DON'T HAVE TO WORRY ABOUT A CMXB VARIABLE
                        !--
                        ENDDO
                    ENDDO
                ENDDO
            ENDDO
        !--
        !--  **INFLATE BIOMASS PRODUCTION COSTS
        !--      (SWEET SORGHUM, ALGAE)
        !--
            DO CTY=1,CNTY
                CYX(23,13,1,CTY)=CYXB(23,13,1,CTY)*INFL(I,1,1) ! ALGAE
                CYX(23,15,1,CTY)=CYXB(23,15,1,CTY)*INFL(I,1,1) !SWEET SORGHUM
            ENDDO
        !--
        !--
        endif !end index 106=3 only

    !--  !!!!!!!!!!!INFLATE LAND RENTAL RATES!!!  !land rents are read in simulation, so not double inflating
        DO CTY=1,CNTY
            DO IY=2,PSYEARS  !region change version !UT 2019 update has change from 32 to 35 but we already have 41??
            !--
                LANDRENT(IY,CTY)=LANDRENT(1,CTY)
            !c     1                       +(LANDRENT(1,CTY)*0.01)*(IY-1) ! 1% INFLATION PER YEAR
                PASTRENT(IY,CTY)=PASTRENT(1,CTY) &
                +(PASTRENT(1,CTY)*0.01)*(IY-1) ! 1% INFLATION PER YEAR
            !--
            !c             LANDRENT(IY,CTY)=LANDRENT(1,CTY)*INFL(I,1,1)  ! USE CORN (AND BIOMASS) INFLATOR
            !c             PASTRENT(IY,CTY)=PASTRENT(1,CTY)*INFL(I,1,1)  !
            !--
            ENDDO
        enddo

    !--  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !--
    !--
    !--
    !--
        RETURN
        END SUBROUTINE INFLATEBIO

        !Update from UT 2021
        SUBROUTINE INPUT2LP
        IMPLICIT NONE

        REAL :: XTLAND=0.0,XNETLAND=0.0,TotalNFX=0.0,TotalOFX=0.0
        REAL :: RETOCC=0.0,DFPYRT=0.0,DFPYRTB=0.0
        REAL :: ARPCHNG=0.0,O92CHNG=0.0,ACRCHNG=0.0,LANDN6=0.0
        REAL :: SIMCOST=0.0,MKTRET=0.0,PGMRET=0.0, TOTALAREA = 0.0
        REAL :: PASTPOS=0.0,PASTNEW=0.0,CNRATIO=0.0
        REAL :: TILLMIN=0.0,TILLFLEX=0.0                            !@
        REAL :: WITHIN(18,3)=0.0
        REAL :: MAXWITHIN=0.0
        REAL :: PRCTCROP(18) = 0.0
      !  REAL :: QPRIEXP(3111)=0.0 !,QPRIEXPB(3111)=0.0
        INTEGER ::  xxx,yyy,Z
        CHARACTER(20) :: LPNUMBER !Update from UT 2019
        REAL :: HOLDLR(12,18)=0.0,HOLDAR(12,18)=0.0
        REAL :: ARET(8),ACHECK(8),CROPPLD(8)

        !EIA add INTEGER  KSORT(8)
      INTEGER  :: NCROPS,J,IYEAR1,KT,ICON,ICOUNT,IACT, KK, KKTT
      INTEGER :: FILE_MGR
      EXTERNAL::  FILE_MGR
      CHARACTER*25 :: FNAME
      LOGICAL :: NEW
     INTEGER :: IUNIT1,IUNIT2,FILEUNIT
     REAL :: PERMAX, SUMMINRHS

    !--
    !--
    !--   *****************************************************************************
    !--   This subroutine carries out the simulation process, from the calculation of
    !--   all vaues for the initial tableau of the LP, to the computation of all the
    !--   simulated values for all crops and CRDs.  The subroutine is called from RMAIN
    !--   and the LP models are solved in LPSIM and the output collected in OUTFRMLP
    !--   *****************************************************************************
        NCROPS=INDEX(2)          ! Number of Crops for which the LP has been set
        IYEAR1 = INDEX(30) ! FIRST YEAR OF SIMULATION

    !--
        DO K=1,NCROPS
            MINBIO(K,1) = 0.0
           END DO
    !--
    !--   First update the LP elements of the objective function and Cij matrix.
    !--   For the Cij of LP, right now, we have 45 rows of constraints and 97
    !--   columns of variables. According to the Simplex method, the 2 dimensional
    !--   matrix that optimizes the LP has one more row to store the objective
    !--   function. The number of total columns needed to store the slack
    !--   variables are 45. Therefore, the total number of column is
    !--   45 + 97. We need to update the LP from bb ( which never change )
    !--   every time we run a CRD.
        DO xxx = 1,147 !123 !99 !98!74
            DO yyy = 1,273 !228 !183 !181!109
                LPA(xxx,yyy) = bb(xxx,yyy)
            END DO
        END DO
    !--
    !--   ****************begin to fill the LPA'S******************************************************************
    !--
    !--   LOOP ACROSS CROPS
        DO K = 1,NCROPS                                                            !K LOOP
            DO T=1,3
            !!!!!!!!!!!!!!!!!!!!!!!new c loop here!!!!!!!!!!!!
                KT=NCROPS*(T-1)+K                                                            !FOR LPA AND RHS MATRICES
            !--
            !--      Calculate ratio of harvested to planted
                IF(CYB(1,K,T,CTY) <= 0.0) THEN
                    PlAc(1,K,T,CTY) = 0.0
                ELSE
                    PlAc(1,K,T,CTY) = CYB(2,K,T,CTY)/CYB(1,K,T,CTY)
                END IF
                IF(CYB(1,K,T,CTY) <= 1.0)PLAC(1,K,T,CTY) = 0.95 !PLAC(1,K,1,CTY)  !TO ALLOW FOR LANDS WITH ORIGONALLY ZERO ACRES TO BE HARVESTED
                IF(K.EQ.15.OR.K.EQ.18)PLAC(1,K,T,CTY)=PLAC(1,1,1,CTY) !EIAX !MAKE OILSEEDS HARVESTED AT SAME RATE AS COUNTY CORNLANDS update 2021
            !c         IF(PLAC(1,K,T,CTY).GT.1.0)PLAC(1,K,T,CTY) = 1.0
            !--
            !--    Increase the flexibility of the maximum change in acres, PlAc(2,K,crdl)
            !--    Based on Net Present Value calculated in NPValue.for (orig set in compbase)

                IF(K <= 8 .OR. K == 12) THEN
                    IF(NPV(NPT,I,K,T,CTY) > 0.0) GOTO 27
                    IF(NPV(NPT,I-1,K,T,CTY) < 0.0 .AND. NPV(NPT,I-2,K,T,CTY) < 0.0) THEN
                        PlAc(2,K,T,CTY) = 3*PlAcB(2,K,T,CTY)                     !3
                    ELSEIF(NPV(NPT,I-1,K,T,CTY) < 0.0 .AND. NPV(NPT,I-2,K,T,CTY) >= 0.0) &
                        THEN
                        PlAc(2,K,T,CTY) = 2*PlAcB(2,K,T,CTY)                     !2
       ELSE
                        PlAc(2,K,T,CTY) = PlAcB(2,K,T,CTY)
       END IF
      END IF
                27 CONTINUE
            !--
            !--   The upper limit to PlAc array values is 1
                DO J = 2,5
                    IF(PlAc(J,K,T,CTY) > 1.0) PlAc(J,K,T,CTY) = 1.0
      END DO
                IF(PlAc(2,K,T,CTY) > 0.5) PlAc(2,K,T,CTY) = 0.5             !0.5
            !--
            ! cc         IF(K.EQ.8.AND.T.EQ.3)PLAC(2,8,3,CTY) = 0.0  !RICE NO NOTILL                       !!!rice to stop no-till!!!
                IF(K == 12 .AND. T == 2)PLAC(2,12,2,CTY)=0.0  !HAY NO REDUCED TILL
            !C         PLAC(2,K,2,CTY)=0.0    !NO REDUCED TILL FOR ALL CROPS (JUNE 2012)
            !--
            !--      SET MATRIX PROFIT EQUAL TO NET PRESENT VALUE
            !--

                LPA(1,KT) = -NPV(NPT,I,K,T,CTY)
            !--
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! c loop end
            !-- then kt = 73 on are zero because simply right hand sides
            !!!!!!!!!!!!!!!!!!!!!
            ENDDO    !T LOOP
        !--
            PLAC(2,K,4,CTY) = MAX(PLAC(2,K,1,CTY),PLAC(2,K,2,CTY),     & !TOTAL ACREAGE PERCENTAGE CAN CHANGE BY LARGEST PORTION OF TILLAGE
            PLAC(2,K,3,CTY))
        !--                                                                !K LOOP
        END DO
    !--
    !--   **The above END DO closes the crop loop to calculate the LPA(1,Z) values.**
        DO Z=1,273 !228 !183!181!109                                                                                           !!!change this!!
            IF(ABS(LPA(1,Z)) == 0.0) LPA(1,Z) = 0.0 ! If LPA = 0 it does not enter LP with minus(-) sign.
        END DO
    !--
    !--   ****************begin to fill the RIGHT HAND SIDES******************************************************************
    !--
        DO ICON = 1,500
            RHS(ICON) = 0.0  ! Refresh the RHS values
         END DO
    !--
        XTLAND = 0.0       ! XTLAND = Summation of All Acres Change in Crops
    !--
    !c      M2 = 0                                     ! Count number of GT constraints
        DO K = 1,NCROPS
        !--
            CY(1,K,4,CTY) = 0.0
        !--
            DO T=1,3                                 !T LOOP
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!new c loop here
                KT=NCROPS*(T-1)+K
            !--
            !--      The base planted acres from which to calculate the acres available
            !--      to the LP is given by the following statement.
                IF(I == 3)THEN
                    CY(1,K,T,CTY) = CYB(1,K,T,CTY)
                ELSE
                     CY(1,K,T,CTY) =  CYInew(NPT,I-1,K,T,CTY)
                     !CY(1,K,T,CTY) =  CYInew(K,T,CTY)          !EIA CHAD 2017

                !--
                !C           IF(K.EQ.9.AND.T.GT.1)CY(1,K,T,CTY)=0.0     !DON'T INCLUDE SWITCHGRASS ON CONVERTED PASTURE (USING 'K=2' IN SWITCHGRASS FOR 'PASTURE CONVERTED)
                !C           IF(K.EQ.10.AND.T.GT.1)CY(1,K,T,CTY)=0.0    !SAME
                !C           IF(K.EQ.11.AND.T.GT.1)CY(1,K,T,CTY)=0.0    !SAME
                !C           IF(K.EQ.15.AND.T.GT.1)CY(1,K,T,CTY)=0.0    !SAME
                !C           IF(K.EQ.16.AND.T.GT.1)CY(1,K,T,CTY)=0.0    !SAME
                !C           IF(K.EQ.17.AND.T.GT.1)CY(1,K,T,CTY)=0.0    !SAME
                !C           IF(K.EQ.12.AND.T.EQ.2)CY(1,K,T,CTY)=0.0    !DONT' INCLUDE HAY ON CONVERTED PASTURE        (USING 'K=2' IN HAY FOR 'PASTURE CONVERTED HAY')
                !C           IF(K.EQ.14.AND.T.GT.1)CY(1,K,T,CTY)=0.0    !DON'T INCLUDE AFFORESTATION ON PASTURE
                !--
                ENDIF
            !--
            !--
            !--
            !--      Total Acres by Crop, all tillages
                CY(1,K,4,CTY) = CY(1,K,4,CTY) + CYB(1,K,T,CTY)                !keep total acres of crop same as baseline
            !--
                IF((K >= 9 .AND. K <= 11) .OR. K >= 13) GOTO 3476
            !--
                XTLAND = XTLAND + CYB(1,K,T,CTY)                            !total acres must be equal to baseline!!
                IF(INDEX(87) == 1)THEN
                    XTLAND = XTLAND-BSHIFT(K,T,CTY)    !MAKE SURE THE TOTAL ACREAGE IS LOWERED TO MAKE UP FOR ALL THE SHIFT ADJUSTMENTS THAT HAPPEN AFTER SOLVING (IN OUTFMLP)
                ! C          IF(BSHIFT(K,T,CTY).LT.0.0.AND.
                ! C     1      (CY(1,K,T,CTY).LT.ABS(BSHIFT(K,T,CTY))))THEN
                ! C            XTLAND=XTLAND+BSHIFT(K,T,CTY)
                ! C          ENDIF
      ENDIF
            !--
                3476 CONTINUE
            !--      CROPS AND HAY

            !--
            !--     **PERCENT CHANGE IN NPV BETWEEN SIM AND BASELINE**
                IF(INDEX(86) == 3)THEN
                    TILLFLEX = 0.75 !2.0                         !most flexible
                ELSEIF(INDEX(86) == 2)THEN
                    TILLFLEX = 0.5 !1.0                         !medium flexiblity
                ELSEif(INDEX(86) == 1)THEN
                    TILLFLEX = 0.3 !0.5                         !low flexibility
                ELSE
                    TILLFLEX = 0.001 !0.0
                ENDIF

             !   if (k.eq.1) write(658,*) 'NPVB=',curcalyr,NPVB(I,K,T,CTY),NPV(NPT,I,K,T,CTY),T,cty
                IF(INDEX(87) == 0 .OR. NPVB(I,K,T,CTY) == 0.0)THEN
                !--
                    CY(31,K,T,CTY)=1.0                                            !@
                ELSE
                    CY(31,K,T,CTY)=1.0+ABS((NPV(NPT,I,K,T,CTY)-NPVB(I,K,T,CTY))        & !@  !this is to increase the rate of landuse change proportional to changes in net returns
                    /NPVB(I,K,T,CTY)) * TILLFLEX
                !--
                    IF(ABS(NPV(NPT,I,K,T,CTY)-NPVB(I,K,T,CTY)) < 40.0) CY(31,K,T,CTY)=1.0                                        !@
                    IF(CY(31,K,T,CTY) > 10.0) CY(31,K,T,CTY)=10.0               !@!CAN'T BE OVER 10
                !--
                ENDIF
               ! IF (K.EQ.1) CY(31,K,T,CTY)=1.0 !!! TESTING FOR TILLAGE CHANGE -- REMOVE tdtd
               ! if (k.eq.1) write(667,*) 'check CY',curcalyr,j,CY(31,K,T,CTY),k,t,cty
            !--
                WITHIN(K,T)=CY(31,K,T,CTY)
            !--   *********************************************
            ENDDO  !END T LOOP
        !--
        ENDDO   !END K LOOP
    !--
    !--
        DO K=1,NCROPS
        !--
        !--
            MAXWITHIN= MAX(CY(31,K,1,CTY),CY(31,K,2,CTY),CY(31,K,3,CTY))  !used in between crop allocation below
        !--
        !--
            TILLMIN=0.0  !for setting the minimum of all tillage catagories within a crop so that its not less that the bshift that must be applied
            DO T=1,3
                KT=NCROPS*(T-1)+K
            !--
            ! c         IF(CY(1,K,4,CTY).EQ.0.0.and.k.ne.9)LPA(1,KT)=0.0                           !IF NO ACRES, THEN SET NPV TO ZERO FOR LP    ! .and.k.ne.9
            !--
            !!!!!!!!!!!!!!!!!!
                IF(K <= 8 .OR. K == 12)THEN
                !!!!!!!!!!!!!!!!!!
                !--
                !--      MAX OF TILLAGE CROP

                        IF(PLAC(2,K,T,CTY) == 0)THEN
                            RHS(KT+2) = 0.0       !IF THIS TILLAGE IS NOT AN OPTION (LIKE RICE NT, OR HAY RT)
                        ELSE
                            RHS(KT+2) = CY(1,K,T,CTY)                                  & !FIRST
                            + CY(1,K,1,CTY) *PLAC(2,K,1,CTY)*WITHIN(K,1)   & !@                 !MAX GAIN IS X% OF 'ALL' TILLAGE ACRES IN A CROP           !nasa15_was 1 now 2
                            + CY(1,K,2,CTY) *PLAC(2,K,2,CTY)*WITHIN(K,2)   & !@                                                                       !nasa15_was 1
                            + CY(1,K,3,CTY) *PLAC(2,K,3,CTY)*WITHIN(K,3)  !@                                                                            !nasa15_was 1
                            IF(T <= 2 .AND. CY(1,K,T,CTY) == 0.0)RHS(KT+2)=0.0          !CAN'T COME INTO CONVENTIONAL TILLAGE FROM OTHER
                        ENDIF

                !--
                !--      MIN OF TILLAGE CROP
                !--
                !--
                    RHS(2+3*NCROPS+NCROPS+KT) = CY(1,K,T,CTY)                                    & !THIRD
                    - CY(1,K,T,CTY) * PLAC(2,K,T,CTY) &
                    * 2 * WITHIN(K,T)                       !@          !MAX LOSS IS X% OF ACRES IN THAT TILLAGE AND CROP        !nasa15_was 2 now 4
                !--
                !--
                    IF(RHS(2+3*NCROPS+NCROPS+KT) < 0.0) &
                    RHS(2+3*NCROPS+NCROPS+KT)=0.0
                !--
                !!!!!!!!!!!!!!!!!!
                ELSEIF((K >= 9 .AND. K <= 11) .AND. T == 1)THEN
                !!!!!!!!!!!!!!!!!!
                !--
                !--      !!***SET biomass MIN AND MAX***!!!!!!!!!!!!!!!!!!!!
                !C         IF((K.GE.9.AND.K.LE.11).AND.T.EQ.1)THEN
                !--        MINIMUM
                    IF(BIOPL(NPT,I-1,K-8,1,CTY) > 0)THEN
                        IF(I-IRTLN(K) < 4) THEN
                            RHS(2+3*NCROPS+NCROPS+KT) = BIOPL(NPT,I-1,K-8,1,CTY)
                        ELSE
                            IF(K == 10)THEN
                                RHS(2+3*NCROPS+NCROPS+KT) = BIOPL(NPT,I-1,K-8,1,CTY) &
                                - APL(NPT,I-IRTLN(K),K-8,1,CTY)*RRR(K,CTY)    !APL WAS REDUCED IN OUTFMLP TO 'INCREMENTAL PLANTINGS', NOW PUT BACK TO ALL CONVERTED ACREAGE
                            ELSEIF(K == 11)THEN
                                RHS(2+3*NCROPS+NCROPS+KT) = BIOPL(NPT,I-1,K-8,1,CTY) &
                                - APL(NPT,I-IRTLN(K),K-8,1,CTY)*RRR(K,CTY) !Update from UT 2019
                            ELSE
                                RHS(2+3*NCROPS+NCROPS+KT) = BIOPL(NPT,I-1,K-8,1,CTY) &
                                - APL(NPT,I-IRTLN(K),K-8,1,CTY)
                            ENDIF

                        END IF
                        MINBIO(K,1) = RHS(2+3*NCROPS+NCROPS+KT)
                    ENDIF
                    RHS(2+3*NCROPS+NCROPS+3*NCROPS+K) = RHS(2+3*NCROPS+NCROPS+KT)          !SET BIOMASS CROP TOTAL TO CONVENTION (SINCE NO ALTERNATIVES)
                !--        MAXIMUM
                !--
                    IF(I >= 4)THEN                                                         !THIS CONTROLS WHAT YEAR BIOMASS CROP CAN COME IN!!!
                        IF(NPV(NPT,I,K,T,CTY) > 0.0 .OR. BIOPL(NPT,I-1,K-8,1,CTY) > 0)THEN
                            PERMAX = 0.08*(1.20)**(I-12)           !1.2
                            !if (I.GT.29)  PERMAX = 0.08*(1.20)**(29-12)   !hold switchgrass constant after 2042 !LOOK LOOK
                            IF (PERMAX>1.0)PERMAX=1.00
                            RHS(KT+2) = BIOPL(NPT,I-1,K-8,1,CTY) + PERMAX*XTLAND
                            IF(C(NPT,I,9,K) <= 30 ) & !TDTDTD.AND. INDEX(74) == 0) &
                            RHS(KT+2)=BIOPL(NPT,I-1,K-8,1,CTY)           !IF PRICE BELOW 30, THEN NO EXPANSION OF SWITCHGRASS
                            END IF
                        ENDIF
                        IF(CYX(25,K,T,CTY) == 0.0)RHS(KT+2) = 0.0       !IF NO YIELD, THEN SWITCHGRASS CAN'T GROW HERE!!
                            RHS(2+3*NCROPS+K) = RHS(KT+2)                   !SET SWITCH CROP TOTAL TO CONVENTION (SINCE NO ALTERNATIVES)
                        !!!!!!!!!!!!!!!!!!
                        ELSEIF((K >= 16 .AND. K <= 17) .AND. T == 1)THEN   !Miscanthus and Ecane
                        !!!!!!!!!!!!!!!!!!
                        !--
                        !--      !!***SET biomass MIN AND MAX***!!!!!!!!!!!!!!!!!!!!
                        !C         IF((K.GE.9.AND.K.LE.11).AND.T.EQ.1)THEN
                        !--        MINIMUM
                            IF(BIOPL(NPT,I-1,K-12,1,CTY) > 0)THEN
                                IF(I-IRTLN(K) < 4) THEN
                                    RHS(2+3*NCROPS+NCROPS+KT) = BIOPL(NPT,I-1,K-12,1,CTY)
                                ELSE
                                    RHS(2+3*NCROPS+NCROPS+KT) = BIOPL(NPT,I-1,K-12,1,CTY) &
                                    - APL(NPT,I-IRTLN(K),K-12,1,CTY)
                                END IF
                                MINBIO(K,1) = RHS(2+3*NCROPS+NCROPS+KT)
                            ENDIF
                            RHS(2+3*NCROPS+NCROPS+3*NCROPS+K) = RHS(2+3*NCROPS+NCROPS+KT)          !SET BIOMASS CROP TOTAL TO CONVENTION (SINCE NO ALTERNATIVES)
                        !--        MAXIMUM
                        !--
                            IF(I >= 4)THEN                                                         !THIS CONTROLS WHAT YEAR BIOMASS CROP CAN COME IN!!!
                                IF(NPV(NPT,I,K,T,CTY) > 0.0 .OR. BIOPL(NPT,I-1,K-12,1,CTY) > 0)THEN
                                    PERMAX = 0.08*(1.20)**(I-12)           !1.2
                                    IF (PERMAX>1.0)PERMAX=1.00
                                    RHS(KT+2) = BIOPL(NPT,I-1,K-12,1,CTY) + PERMAX*XTLAND
                                    IF(C(NPT,I,9,K) <= 30) & !!TDTDTD .AND. INDEX(74) == 0) &
                                    RHS(KT+2)=BIOPL(NPT,I-1,K-12,1,CTY)           !IF PRICE BELOW 30, THEN NO EXPANSION OF SWITCHGRASS
                                    END IF
                                ENDIF
                                IF(CYX(25,K,T,CTY) == 0.0)RHS(KT+2) = 0.0       !IF NO YIELD, THEN SWITCHGRASS CAN'T GROW HERE!!
                                    RHS(2+3*NCROPS+K) = RHS(KT+2)                   !SET SWITCH CROP TOTAL TO CONVENTION (SINCE NO ALTERNATIVES)
                                !--
                                !--    !!!!!!!!!!!END MISCANTHUS!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                !--
                                !--
                                ELSEIF(K == 14 .AND. T == 1)THEN ! .AND. INDEX(80) == 1)THEN  !AFFORESTATION or pasture conversion
                                !--
                                !--        MINIMUM
                                    IF(BIOPL(NPT,I-1,6,1,CTY) > 0)THEN                         !BIOPL(NPT,I,6....IS FOR PASTURE CONVERSION ...NOT TOTAL IMPLEMENTED IN BIOTRACK!!
                                        RHS(2+3*NCROPS+NCROPS+KT) = BIOPL(NPT,I-1,6,1,CTY)
                                        MINBIO(K,1) = RHS(2+3*NCROPS+NCROPS+KT)
                                    ENDIF
                                    RHS(2+3*NCROPS+NCROPS+3*NCROPS+K) = RHS(2+3*NCROPS+NCROPS+KT)
                                !--        MAXIMUM
                                !--
                                    IF(INDEX(80) == 0)THEN
                                        RHS(KT+2) = 0.0                !NO CONVERSION IF SIM.INS DOESN'T ALLOW (MAKE SURE THIS IS CONSISTENT IN BASELINE RUNS
                                    ELSE
                                        RHS(KT+2) = BIOPL(NPT,I-1,6,1,CTY) + 0.5*XTLAND                ! 50% OF ALL LAND
                                    ENDIF
                                !--
                                    RHS(2+3*NCROPS+K) = RHS(KT+2)
                                !--
                                !--
                                ELSEIF(K == 15 .AND. T == 1)THEN                                !SWEET SORGHUM
                                !--
                                !--        MINIMUM
                                    RHS(2+3*NCROPS+NCROPS+KT) = 0
                                    RHS(2+3*NCROPS+NCROPS+3*NCROPS+K) = RHS(2+3*NCROPS+NCROPS+KT)  !SAME FOR ALL CUS ONLY T=1 FOR SWEET SORGUM
                                !--
                                !--        MAXIMUM
                                    PERMAX = 0.08*(1.20)**(I-12)*0.20
                                    IF (PERMAX>1.0)PERMAX=1.00
                                    IF(NPV(NPT,I,K,T,CTY) <= 0.0)THEN
                                        RHS(KT+2) = 0.0
            ELSE
                                        RHS(KT+2) = PERMAX*XTLAND           !!set to zero now
                                    ENDIF
                                    RHS(2+3*NCROPS+K) = RHS(KT+2)
                                !--
                                !--
                                !--
                                !--
                                ELSEIF(K == 18 .AND. T == 1)THEN                                !pennycress
                                !--
                                !--        MINIMUM
                                    RHS(2+3*NCROPS+NCROPS+KT) = 0
                                    RHS(2+3*NCROPS+NCROPS+3*NCROPS+K) = RHS(2+3*NCROPS+NCROPS+KT)  !SAME FOR ALL CUS ONLY T=1 FOR Canola
                                !--
                                !--        MAXIMUM
                                    PERMAX = 0.1 * (I-3)   ! !0.08*(1.20)**(I-12)*0.50  !0.08*(1.20)**(I-12)*0.20
                                    IF (PERMAX>1.0)PERMAX=1.00
                                    IF(NPV(NPT,I,K,T,CTY) <= 0.0)THEN
                                        RHS(KT+2) = 0.0
                                    ELSE
                                        RHS(KT+2) = PERMAX*XTLAND           !!set to zero now
                                    ENDIF
                                    RHS(2+3*NCROPS+K) = RHS(KT+2)
                                !--
                                !--
                                ENDIF
                            !--
                            !!!!!!!!!!!!!!!!!!!!this is to correct if 'sum of minimums exceeds total land'!!!!!!!!!!!!!!!!!!!
                                IF(k == 18 .AND. t == 3)THEN !IF LAST
                                    summinrhs=0.0
                                    DO Kk=1,NCROPS
                                        DO Tt=1,3
                                            KkTt=NCROPS*(Tt-1)+Kk
                                            summinrhs=summinrhs+RHS(2+3*NCROPS+NCROPS+KkTt)   !sum all min rhs's
                                        enddo
                                    enddo
                                    IF(summinrhs > xtland)then                         !check if rhs greater than total land
                                        DO KK=1,NCROPS
                                            DO TT=1,3
                                                KkTt=NCROPS*(Tt-1)+Kk
                                                IF((KK < 9 .OR. KK == 12) .AND. BSHIFT(KK,TT,CTY) > 0.0)THEN  !only adjust
                                                    RHS(2+3*NCROPS+NCROPS+KKTT) = CY(1,KK,TT,CTY) &
                                                    - CY(1,KK,TT,CTY) * PLAC(2,KK,TT,CTY) &
                                                    * 2 * WITHIN(KK,TT) &
                                                    - BSHIFT(KK,TT,CTY)*0.6               !reduce min by 60% of bshift acreage. this % can be adjusted
                                                !--
                                                    IF(RHS(2+3*NCROPS+NCROPS+KKTT) < 0.0) &
                                                    RHS(2+3*NCROPS+NCROPS+KKTT)=0.0
                                                !--
                                                ENDIF
                                            enddo
                                        enddo
                                    ENDIF
                                endif
                            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                            !--
                            !--      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                            !--      *** EACH TILLAGE BSHIFT CONSTRAINT***
                                IF(INDEX(87) == 1)THEN
                                    IF(RHS(2+3*NCROPS+NCROPS+KT) < -BSHIFT(K,T,CTY))THEN        !TO AVOID NEGATIVE SOLUTIONS AFTER WE APPLY BSHIFT in outfmlp
                                        RHS(2+3*NCROPS+NCROPS+KT)= -BSHIFT(K,T,CTY)
                                    ENDIF
                                    IF(RHS(KT+2) < RHS(2+3*NCROPS+NCROPS+KT))THEN        !MAKE SURE MAX IS AT LEAST EQUAL TO MIN
                                        RHS(KT+2)=RHS(2+3*NCROPS+NCROPS+KT)
                                    ENDIF
                                ENDIF
                            !--
                                TILLMIN=TILLMIN+RHS(2+3*NCROPS+NCROPS+KT)  !FOR USE BELOW
                            !--
                            !--     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

                            ENDDO           !T LOOP
                        !--
                        !--    SET TOTAL CROP MAX AND MIN FOR ALL BUT BIOMASS CROPS (DONE ABOVE)
                            IF(K <= 8 .OR. K == 12)THEN
                            !--     MAX OF TOTAL CROP
                                RHS(2+3*NCROPS+K) = CY(1,K,4,CTY)                                & !SECOND
                                + CY(1,K,4,CTY)*PlAC(2,K,4,CTY)*1 &
                                * (1+((MAXWITHIN-1)/7))                 !10%                                                      !nasa15_was 1...NOW 2
                                IF(K == 12)RHS(2+3*NCROPS+K) = CY(1,K,4,CTY)                     !HAY CANNOT SWITCH TO OTHER CROPS
                            !--
                            !--     MIN OF TOTAL CROP
                                RHS(2+3*NCROPS+NCROPS+3*NCROPS+K) = CY(1,K,4,CTY)                 & !FOURTH
                                - CY(1,K,4,CTY)*PLAC(2,K,4,CTY)*2                & !10%                                                        !nasa15_was 2...NOW 4
                                * (1+((MAXWITHIN-1)/7))
                                IF(K == 12) &
                                RHS(2+3*NCROPS+NCROPS+3*NCROPS+K) = CY(1,K,4,CTY)
                            !--
                            ENDIF
                        !--
                        ! cccccccccc         IF(CTY.EQ.2185.AND.I.EQ.8)RHS(2+3*NCROPS+NCROPS+3*NCROPS+K) =0
                        !--     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        !--     !!!!!!! *** OVERALL CROP BSHIFT CONSTRAINT***  !!!!!
                            IF(INDEX(87) == 1)THEN
                                IF(RHS(2+3*NCROPS+NCROPS+3*NCROPS+K) < TILLMIN)THEN          !THIS IS TO AVOID A BIGGER TOTAL CROP MINUMUM THAN THE SUM OF THE TILLAGE MINUMUMS
                                    RHS(2+3*NCROPS+NCROPS+3*NCROPS+K)=TILLMIN
                                ENDIF
                                IF(RHS(2+3*NCROPS+K) < RHS(2+3*NCROPS+NCROPS+3*NCROPS+K))THEN
                                    RHS(2+3*NCROPS+K)=RHS(2+3*NCROPS+NCROPS+3*NCROPS+K)        !!MAKE SURE MAX IS AT LEAST EQUAL TO MIN
                                ENDIF
                            ENDIF
                        !--    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        !--
                        !--    APPLY EXOGENOUS LIMITS ON % OF TOTAL LAND THAT CAN GO TO EACH CROP
                        !--
                            IF(RHS(2+3*NCROPS+K) > (XTLAND*CYX(39,K,1,CTY)))THEN      !2021 update              !!potential problem!! if diff in outfrmlp, put this in it's own k loop
                                RHS(2+3*NCROPS+K)= XTLAND*CYX(39,K,1,CTY)   !2021 update
                            ENDIF
                        !--
                        !--
                        END DO           !K LOOP
                    !--
                        RHS(2+3*NCROPS+NCROPS+3*NCROPS+NCROPS+1) = XTLAND
                    !--
                        RHS(2) = XTLAND
                    !--
                    !--   The following statements write the LP of a particular crdl to a TXT file
                    
                      !  IF(CTY == 1705) THEN
                     !       2424 FORMAT('  ',99F15.2)
                        ! CC         IF(I.EQ.4) THEN
                          !  LPNUMBER='LPin.TXT'
                         !   OPEN(UNIT=77,FILE=LPNUMBER)
                         !   WRITE(77,*)CTY
                         !   DO ICOUNT = 1,146                                           !!xxx
                         !       WRITE(77,2424)RHS(ICOUNT),(LPA(ICOUNT,IACT),IACT=1,54)   !!vn     slack variables=shadow prices in first row of lpa!!
                         !   END DO
                         !   CLOSE(77)
                        !       WRITE(*,*)'DONE WRITING LPin->',CTY
                        ! CCC         END IF
                        !END IF
                    !--
                    !--
                        RETURN
                        END SUBROUTINE INPUT2LP

                    !     Last change:  CH   26 Jun 2009    1:42 pm
        SUBROUTINE LPSIM
        IMPLICIT NONE

        DOUBLE PRECISION :: pivot,snum,store(1000)                   !500
        DOUBLE PRECISION ::  BIGM,OBJMAX
        INTEGER :: VarNum,RowNum,NumIter
        INTEGER :: x,y,TotalVar,scol,srow,OPTIMIZED,num
        CHARACTER(11) :: LPNUMBER
        INTEGER :: IYEAR1,IX,NV,ICOLUMNS,IROWS
       INTEGER :: INFEASIBLE,IM
    !--
    !--
        IF(RHS(2) == 0.0)GOTO 999
    !--
    !--             FIRST YEAR OF SIMULATION
    !--
        IYEAR1 = INDEX(30)
    !--
    !--             AUXILLARY WRITE STATEMENTS (UNIT NO., 0 SCREEN, -1 OFF)
    !--

    !--
    !--
        do ix=1,500               !!500
            store(ix) = 0
        end do
    !--
    !--    ***************************************************************************
    !--    This subroutine contains a Linear Programming algorithm specifically
    !--    customized for RASS, and taylor to solve a maximization problem with
    !--    LT constraints only. The subrouitne is called from INPUT2LP.
    !--    ***************************************************************************
    !--
    !--   Set value for BIGM
    !--
    !c       BIGM = 100000000000000000000000000000000000.00
        BIGM = 100000000.0
    !--
        M1 = 73 !61 !49 !37                           ! Less than constraints
        M2 = 72 !60 !48 !36                           ! Greater than constrains is counted in INPUT2LP subroutine    !!this was commented
        M3 =  1                           ! Equal to constraints
        M  = M1 + M2 + M3                  ! Total number of constraints
        NV = 54 !45 !36                            ! Number of activities
    !--
    !--   The number of elements of the RHR solution needs to be pre-specified. It is
    !--   given by the sum of the number of activities and the number of constraints.
    !--
        VarNum = NV
        RowNum = M
        TotalVar = VarNum + RowNum
    !--
    !--    Big M SIMPLEX ALGORITHM : SETUP
    !--
    !--     Step 1 : is skipped because all RHS values are > or = to 0
    !--
    !--     Step 1': Identify greater(M2) than and equal to constraints(M3)
    !--     M1 = less than constraints, M2 = greater than constraints, M3 = equal to constraints
    !--     Objective function values = RHS(1)
    !--     First M1 constraint = RHS(2)
    !--     First M2 constraint = RHS(1+M1+1)
    !--     First M3 constraint = RHS(1+M1+M2+1)
    !--
    !--     Step 2 : Convert each inequality constraint to the standard form.
    !--     For constraints of the form LESS THAN then :
    !--     add a slack variable (1- diagonally).
    !--
        do x = 1,M1
            LPA(x+1,NV+x) = 1
        end do
    !--
    !--     For constraints of the form GREATER THAN OR EQUAL TO then :
    !--     substract an excess variable (-1,diagonally).
    !--
        do x = 1,M2
            LPA(1+M1+x,NV+M1+x) = -1                                          !these are not being printed
        end do
    !--
    !--     Step 3: For constraints "? or "=", add an artificial variable to
    !--             each constraint
    !--
        do x = 1,M2+M3
            LPA(1+M1+x,NV+M1+M2+x) = 1
        end do
    !--
    !--     Step 4 : Since our problem is a maximization problem, add (for each
    !--              artificial variable 'a') -Mai to the objective function.
    !--
        do x = 1,NV+M1+M2+M2+M3
            if(x > NV+M1+M2) then
                LPA(1,x) = BIGM
            end if
        end do
    !--
    !--     Step 5 : Since each artificial variable will be in the starting basis,
    !--              all artificial variables must be eliminated from row 1 before
    !--              begining the simplex. This ensures we begin with a canonical
    !--              form. In choosing the entering variable remember that M is a
    !--              very large positive number.  After this transformation solve
    !--              the LP applying the Simplex.  If all artificial variables are
    !--              equal to Zero (0) in the optimal solution, the optimal solution
    !--              to the original problem has been found. If any artificial
    !--              variables is positive in the optimal solution, the original
    !--              problem is infeasible.
    !--
        do y = 1,NV+M1+M2+M2+M3
            do x = 1,M2+M3
                LPA(1,y) = LPA(1,y) - LPA(1+M1+x,y)*BIGM
            end do
        end do
    !--
        RHS(1) = 0
    !--
        icolumns = NV+M1+M2+M2+M3
        irows = 1 + M1 + M2 + M3
    !--
        TotalVar = icolumns
        RowNum = irows - 1
    !--
    !--    To put all index of RHR. As activities come into the solution the elements
    !--    of NAME(x) change from 0 to the column number of the activity.
    !--
        do x = 1,500                      !!500
            NAME(x) = 0
        end do
    !--
    !--  *****************************************************************
    !--
    !--                 ITERATIVE SIMPLEX PROCEDURE
    !--
    !--  *****************************************************************
    !--
    !-- THE ITERATIVE SIMPLEX PROCEDURE STARTS BY CHECKING IF THE INITIAL
    !-- SOLUTION IS OPTIMIZED.
    !--
        OPTIMIZED = 0
        NumIter = 1
        do while ( OPTIMIZED /= 1)
            num = 0
        !--
            do x=1,TotalVar
                if (LPA(1,x) >= 0.0) then
                    num = num + 1
                end if
            end do
        !--
            if (num == TotalVar) OPTIMIZED = 1
        !--
            if (OPTIMIZED == 0)then
            !--
            !--  BELOW WILL SELECT THE LARGEST -VE VALUE IN THE FIRST ROW Z
            !--  scol is the selected column with the largest -ve Z
            !--
                snum = 999999999.9999                                                !!!!12 NINES
            !--
                do y=1,TotalVar
                    if (LPA(1,y) < snum) then
                        snum = LPA(1,y)
                        scol = y
                    end if
                end do
            !--
            !-- AFTER SELECTING THE RIGHT COLUMN, SELECT THE +VE VALUES IN THE SELECTED
            !-- COLUMN TO DIVIDE ALL RHR. THEN SELECT THE SMALLEST RESULT AND THAT WILL
            !-- BE THE SELECTED ROW.
            !-- ROW SHOULD START FROM 2 INSTEAD OF 1 BECAUSE ROW 1 HAS THE OBJ FUNCTION.
            !--
                do x = 2,RowNum+1
                    if (LPA(x,scol) <= 0.000000001) then                             !!!14 ZEROS AFTER .
                        store(x) = 1.e9                                              !!!1.e12
                    else
                        store(x) =(RHS(x)/LPA(x,scol))
                    end if
                end do
            !--
            !-- THE FOLLOWING STATEMENT IDENTIFIES SELECTED ROW(SROW)
            !--
                snum = 999999999.9999                                               !!!10 NINES
                do x=2,RowNum+1
                    if(store(x) < snum) then
                        snum = store(x)
                        srow = x
                    end if
                end do
            !--
            !-- USING SELECTED ROW (SROW) AND SELECTED COLUMN (SCOL), WE IDENTIFY THE
            !-- THE PIVOT ELEMENT.
            !--
                pivot = LPA(srow,scol)
                NAME(scol) = srow
                do x = 1,TotalVar + 1
                    if((x /= scol) .AND. (NAME(x) == srow))then
                        NAME(x) = 0
                    end if
                end do
            !--
            !-- BELOW IS TO COMPUTE THE VALUES OF THE NEW BASIC VARIABLES IN THE NEXT
            !-- TABLEAU.
            !--
                do y = 1,TotalVar
                    LPA(srow,y) = (LPA(srow,y) / pivot)
                end do
                RHS(srow) = (RHS(srow) / pivot)
            !--
            !-- TO COMPUTE THE NEW VALUES FOR THE NEXT TABLEAU, WE USE THE FOLLOWING
            !-- FORMULA, new row = old row -(pivot column coefficient)*new pivot row
            !-- THE VALUES OF PIVOT COLUMN COEFFICIENT, ARE rstore IN store(i)
            !-- THE NEW PIVOT ROW IS THE ONE COMPUTED ABOVE.
            !--
                do x = 1, RowNum + 1
                    store(x) = LPA(x,scol)
                end do
            !--
                do x = 1, RowNum + 1
                    if ((x /= srow) .AND. (store(x)/= 0.0)) then
                    !--
                        do y=1,TotalVar
                            if(y==scol) then
                                LPA(x,y) = 0.0
                            else
                                LPA(x,y) = LPA(x,y) - (store(x)*LPA(srow,y))
                            end if
                        end do
                    !--
                        RHS(x) = RHS(x)-(store(x)*RHS(srow))
                        if (RHS(x) < +1.E-8)then
                            RHS(x) = 0.0
                        end if
                    end if
                    IF(CTY == 2109)THEN
                    !c                WRITE(*,*)X,RHS(X),NAME(X),RHS(NAME(X)),numiter
                    ENDIF
                end do
                IF(CTY == 2109)THEN
                !c      PAUSE
                ENDIF
            !--
                NumIter = NumIter + 1
                IF (NumIter > 222) THEN
                    WRITE(*,*)'NON OPTIMAL SOL 1.:Exceeded Max Num of Iter ->',CTY
                    EXIT
            END IF
            end if
        end do
    !--
    !        INDEX(24) = -7
        INFEASIBLE = 0
        DO IM=NV+M1+M2+1,TotalVar
            IF(NAME(IM)==0) GOTO 2423
            IF(RHS(NAME(IM))>0.1) THEN
                INFEASIBLE =1
                IF(INFEASIBLE==1) GOTO 2424
         END IF
            2423 CONTINUE
        END DO
        2424 CONTINUE
        IF(INFEASIBLE==1) THEN
            WRITE(*,*)'Infeasible LP->',cty,' ',' ',cty
        !c        PAUSE
            DO IM = NV+M1+M2+1,TotalVar
                IF(NAME(IM)>0) THEN
                    WRITE(*,*)'SOL',IM,RHS(IM),NAME(IM),RHS(NAME(IM))
      ELSE
                    WRITE(*,*)'SOL',IM,RHS(IM),NAME(IM),0
            END IF
            END DO
        !         INDEX(24) = -9
        !          PAUSE 23
         END IF
    !--
    !        if(INDEX(24)==-9) then
    !        IF(i==4.or.i==12)then
    !         IF(crdl==249)then
    !     DO M = 1,TotalVar
    !     IF(NAME(M)>0) THEN
    !     WRITE(*,*)'AL SOL',M,RHS(M),NAME(M),RHS(NAME(M))
    !     ELSE
    !     WRITE(*,*)'SOL',M,RHS(M),NAME(M),0,'numiter',NumIter
    !     END IF
    !    END DO
    !    write(*,*)'printed in lpsim'
    !         pause
    !         endif
    !        endif

    !--   The following statements write the LP of a particular crdl to a TXT file

    !--   The following statements write the LP of a particular crdl to a TXT file
    !      IF(CTY==634) THEN
        4367 FORMAT('  ',99F15.2)
    ! c         IF(I==9) THEN
    !c            LPNUMBER='lpout.txt'
    !c            OPEN(UNIT=79,FILE=LPNUMBER)
    !c            WRITE(79,*)CTY
    !c            DO M = 1,TotalVar
    !c     IF(NAME(M)>0) THEN
    !c      WRITE(79,*)'AL SOL',M,RHS(M),NAME(M),RHS(NAME(M))
    !c     ELSE
    !c      WRITE(79,*)'SOL',M,RHS(M),NAME(M),0,'NumIter->',NumIter
    !c     END IF
    !c          END DO
    !         ELSEIF(i==12)then
    !          LPNUMBER='lpout12.txt'
    !          OPEN(UNIT=79,FILE=LPNUMBER)
    !          WRITE(79,*)crdl
    !             DO M = 1,TotalVar
    !      IF(NAME(M)>0) THEN
    !       WRITE(79,*)'AL SOL',M,RHS(M),NAME(M),RHS(NAME(M))
    !      ELSE
    !       WRITE(79,*)'SOL',M,RHS(M),NAME(M),0
    !      END IF
    !          END DO
    !        endif
    !         CLOSE(79)
    !         WRITE(*,*)'DONE WRITING->',crdl
    !     END IF
    !c      IF(cty.eq.128) THEN
    ! 4367      FORMAT('  ',99F15.2)
    !c         IF(I.eq.5) THEN
    !c            LPNUMBER='outLP.txt'
    !c            OPEN(UNIT=79,FILE=LPNUMBER)
    !c            WRITE(79,*)cty
    !     DO M = 1,TotalVar
    !      IF(NAME(M)>0) THEN
    !       WRITE(79,*)'AL SOL',M,RHS(M),NAME(M),RHS(NAME(M))
    !      ELSE
    !       WRITE(79,*)'SOL',M,RHS(M),NAME(M),0,'NumIter->',NumIter
    !      END IF
    !          END DO
    !         ELSEIF(i==12)then
    !          LPNUMBER='lpout12.txt'
    !          OPEN(UNIT=79,FILE=LPNUMBER)
    !          WRITE(79,*)crdl
    !             DO M = 1,TotalVar
    !c            DO ICOUNT = 1,500
    !               WRITE(79,*)ICOUNT,RHS(NAME(ICOUNT)),
    !c       WRITE(79,*)ICOUNT,RHS(ICOUNT),store(icount),NAME(ICOUNT)
    !c     1           ,(LPA(ICOUNT,IACT),IACT=1,500)
    !c            END DO
    !      IF(NAME(M)>0) THEN
    !       WRITE(79,*)'AL SOL',M,RHS(M),NAME(M),RHS(NAME(M))
    !      ELSE
    !       WRITE(79,*)'SOL',M,RHS(M),NAME(M),0
    !      END IF
    !          END DO
    !c         WRITE(*,*)'DONE WRITING outLP->',cty
    !         pause
    !c         endif
    !c         CLOSE(79)
    !c      END IF
    ! c      IF(CTY==1080) THEN
    ! c 2376    FORMAT('  ',99F15.2)
    ! c         IF(I==5) THEN
    ! c            LPNUMBER='LPout.txt'
    ! c            OPEN(UNIT=79,FILE=LPNUMBER)
    ! c            WRITE(79,*)crdl
    ! c           DO ICOUNT = 1,500
    ! c               WRITE(79,*)RHS(ICOUNT),(LPA(ICOUNT,IACT),IACT=1,500)
    ! c            END DO
    ! c            CLOSE(79)
    ! c            WRITE(*,*)'DONE WRITING->',cty
    !         ELSEIF (I==12) THEN
    !            LPNUMBER='LPou12.txt'
    !            OPEN(UNIT=79,FILE=LPNUMBER)
    !            WRITE(79,*)crdl
    !            DO ICOUNT = 1,20
    !               WRITE(79,2376)RHS(ICOUNT),(LPA(ICOUNT,IACT),IACT=1,34)
    !            END DO
    !            CLOSE(79)
    !            WRITE(*,*)'DONE WRITING->',crdl
    ! 2376    FORMAT('  ',99F15.2)
    !C         IF(I==3) THEN
    !            LPNUMBER='LPout.txt'
    !            OPEN(UNIT=79,FILE=LPNUMBER)
    !            WRITE(79,*)CTY
    !            WRITE(79,*)(lpa(1,1+45+kT),kT=1,45)   !SLACK VARIABLES?
    !            DO ICOUNT = 1,90
    !               WRITE(79,2376)rhs(NAME(icount)),(LPA(NAME(ICOUNT),
    !     1                       NAME(IACT)),IACT=1,90)       !store(iact) or store(icount)
    !            END DO
    !            CLOSE(79)
    !            WRITE(*,*)'DONE WRITING->',CTY
    ! c        END IF
    ! c      END IF
    !--
        999 CONTINUE
        return
        END SUBROUTINE LPSIM

!     Last change:  CH   23 May 2006   10:24 am
!--
    SUBROUTINE LVINDEX
    IMPLICIT NONE

    !EIA add
    INTEGER :: NLVSK,J
!--
!--             NUMBER OF LIVESTOCK CATEGORIES IN POLYSYS
!--
    NLVSK = INDEX(5)
!--
!--     *************************                            !!!SUB IN NEW NOTATION BELOW
!--     INDEX OF LIVESTOCK PRICES
!--     *************************
!--
!--             SEE SETDEX FOR DETAILS ON PROCEDURE
!--
    DO K = 1, NLVSK
        A(NPT,I,K+10,3) = FCTRLV(K) * S(NPT,I,50,K)          ! OLD S(I,02,K)
               END DO
!--             MEAT ANIMALS ONLY INCLUDE CATTLE AND HOGS
    A(NPT,I,18,3)= A(NPT,I,11,3)*PERMET(1)+A(NPT,I,12,3)*PERMET(2)
!--             POULTRY INCLUDES ALL THREE
    A(NPT,I,19,3)= A(NPT,I,14,3)*PERPOL(1)+A(NPT,I,15,3)*PERPOL(2) &
    + A(NPT,I,16,3)*PERPOL(3)

!--
!--             EVEN THOUGH SHEEP DATA ARE NOT USED TO CALCULATE
!--             THE MEAT ANIMAL INDEX, THE WEIGHT TO CONSTRUCT THE
!--             LIVESTOCK PRICE INDEX INCLUDES SHEEP.
!--
    A(NPT,I,20,3)= A(NPT,I,18,3)*PERLV(1)+A(NPT,I,19,3) &
    * PERLV(2)+A(NPT,I,17,3)*PERLV(3)
!--

!--
!--             1977 IS USED AS THE DISPLAY YEAR.  CONVERT ALL INDEXES
!--             TO 1977=100 HERE.  AGGREGATION FAILS IF DONE AS PART OF
!--             THE CALULATIONS ABOVE.
!--
    DO J =11,20
        A(NPT,I,J,3) = A(NPT,I,J,3)/CONVSN(J)
               END DO
!--
!--
!--     **************************
!--     LIVESTOCK PRODUCTION UNITS
!--     **************************
    A(NPT,I,05,2) = 0.001170*S(NPT,I,44,1)+0.0016660*S(NPT,I,44,2) &
    +0.000939*S(NPT,I,44,4)+0.001078*S(NPT,I,44,5) &
    +0.000673*S(NPT,I,44,3)+0.001482*S(NPT,I,44,6)
!C     3           +0.000105*S(NPT,I,44,7)

    RETURN
    END SUBROUTINE LVINDEX

!     Last change:  DTU  17 May 102   11:53 am
    SUBROUTINE LVINIT
    IMPLICIT NONE

    !EIA add
    INTEGER NYRSIM,IEND
!--                     *****************
!--   ****************  WIREIT SUBROUTINE  *******************
!--    SETS INITIAL LIVESTOCK VARIABLES TO STARTING VALUE
!--
!--   NUMBER OF YEARS TO BE SIMULATED
    NYRSIM = INDEX(1)
    IEND = NYRSIM+(INDEX(30)-INDEX(27)) + 2
!--   FOR AND CCC STOCKS FOR ALL CROPS
!--   LIVESTOCK INITIAL VALUES FOR LVSIMUL.FOR
    S(NPT,I,36,2)=SB(I,36,2)
    S(NPT,I,36,4)=SB(I,36,4)
!--
    RETURN
    END SUBROUTINE LVINIT


!     Last change:  CH   22 May 2006    4:55 pm
    SUBROUTINE LVSIMUL

!--
!--             **SET UP FOR SIMULTANOUS ITERATIONS**
!--
    SITERA=0
    100 SITERA=SITERA+1
!       WRITE(*,*)'siteration',SITERA
    IF(SITERA == 800)GOTO 400                    !IF TOO MANY ITERATIONS, QUIT
    DO K=1,5
        DO J=1,39
            IF (SITERA == 1)THEN    !IF FIRST ITERATION ASSIGN BASELINE AS LAST ITERA
                SLAST(J,K)=SB(I,J,K)
            ELSE
                SLAST(J,K)=S(NPT,I,J,K)                      !IF NOT, ASSIGN LAST ITERATIONS VALUE
            ENDIF
        ENDDO
    ENDDO
!--
!--             ***Hogs and Broilers are solved simultaneously***
!--
!--             Boar and Stag Slaughter
!--bskgnus= 808.8386 +-16.1634*rhogrec;
!--bskgnus=hog40+hog41*(rhogrec+WHOGREC);
!--

    S(NPT,I,26,2)=SB(I,26,2)+LVP(9,2)*(S(NPT,I,36,2)-SB(I,36,2))
!--
!--             Barrow and Gilt Slaughter
!--bgkgnus= 12015.42+.775401 *pigcalt+  -1.38541*pigcalt*(1-(.975))+ -122.936 *rhogrec;
!--bgkgnus=hog20+hog21*pigcalt+hog24*pigcalt*(1-(firatio))+hog25*rhogrec
!--

    S(NPT,I,28,2)=SB(I,28,2)+LVP(11,2)*(S(NPT,I,23,2)-SB(I,23,2))+ &
    LVP(12,2)*(1-LVP(24,6))*(S(NPT,I,23,2)-SB(I,23,2))+ &
    LVP(13,2)*(S(NPT,I,36,2)-SB(I,36,2))
!--
!--             Total Pork Production
!--poscpus=(hoKCAUS*(bgkgnus+swkgnus+bskgnus)*1/.975)/1000;
!--poscpus=(hoKCAUS*(bgkgnus+swkgnus+bskgnus)*1/firatio)/1000;
!--

    S(NPT,I,24,2)=SB(I,24,2)+((S(NPT,I,32,2)*(S(NPT,I,28,2)+S(NPT,I,27,2)+S(NPT,I,26,2))* &
    &           1/LVP(24,6))/1000)-((SB(I,32,2)*(SB(I,28,2)+SB(I,27,2)+ &
    SB(I,26,2))*1/LVP(24,6))/1000)
!--
!--             Broiler chick placements
!--     CHISCBR  = 190813.9+ .402329 *CHPBRHSF*EGGAA/100+ 16532.47*rbroilnr+ 76853.19 *TBR;
!--     CHISCBR  =BRC0+BRC1*CHPBRHSF*EGGAA/100+brc3*rbroilnr+brc2*TBR;
!--

    S(NPT,I,23,4)=SB(I,23,4) + LVP(8,4)*((S(NPT,I,15,4)*XS(NPT,I,26,4)/100)- &
    (SB(I,15,4)*XSB(I,26,4)/100))+ &
    LVP(9,4)*(S(NPT,I,36,4)-SB(I,36,4))
!--
!--             Chicken Slaughter
!--     CHIKIYO = .765102*CHISCBR+(20526.26+33181.54*TBR);
!--     CHIKIYO  =BRS2*CHISCBR+(BRS0+BRS1*TBR);
!--

    S(NPT,I,25,4)=SB(I,25,4)+LVP(11,4)*(S(NPT,I,23,4)-SB(I,23,4))
!--
!--             Total Broiler Production
!--     CHIAIYO  =    CHIKIYO*CYKDGAUS
!--

    S(NPT,I,24,4)=SB(I,24,4)+(S(NPT,I,33,4)*S(NPT,I,25,4))-(SB(I,33,4)*SB(I,25,4))
!--
!--             Broiler Exports
!--     chimxyo=chiaiyo*chiazyo*milt;
!--

    S(NPT,I,39,4)=SB(I,39,4)+(S(NPT,I,24,4)*XS(NPT,I,22,4)*XS(NPT,I,21,4))- &
    (SB(I,24,4)*XSB(I,22,4)*XSB(I,21,4))
!--
!--
!--             ***CONSUMPTION SIDE EQUATIONS***
!--
!--
!--             ***Per Capita Consumption Section***
!--
!--             Per Capita Pork Consumption
!--PCN=(POSCPUS+POCITUS+POSMTUS-POUXTUS-POCOTUS)/(POPa)*.776;
!--

    S(NPT,I,34,2)=SB(I,34,2)+((S(NPT,I,24,2)-SB(I,24,2))+(XS(NPT,I,10,2)- &
    XSB(I,10,2))+(XS(NPT,I,12,2)-XSB(I,12,2))-(XS(NPT,I,13,2)- &
    XSB(I,13,2))-(XS(NPT,I,11,2)-XSB(I,11,2)))/XAGB(I,3)*.776
!--
!--             Per Capita Broiler Consumption
!--     BRCN=(CHIAIYO*CHIAZYO-CHIBKYO+CHIHTYO-CHIMXYO-CHIHTYOE)/(POPa*1000);
!--

    S(NPT,I,34,4)=SB(I,34,4)+(((S(NPT,I,24,4)*XS(NPT,I,22,4))-(SB(I,24,4)* &
    XSB(I,22,4)))-(XS(NPT,I,23,4)-XSB(I,23,4))+(XS(NPT,I,10,4)- &
    XSB(I,10,4))-(S(NPT,I,39,4)-SB(I,39,4))-(XS(NPT,I,11,4)- &
    XSB(I,11,4)))/(XAGB(I,3)*1000)
!--
!--                     ***Change in Consumption Section***
!--
!--             Change in pork consumption
!--             dpcn=(dif(PCN)/lag(PCN));
!--

    S(NPT,I,35,2)=SB(I,35,2)+(((S(NPT,I,34,2)-S(NPT,I-1,34,2))/S(NPT,I-1,34,2))- &
    ((SB(I,34,2)-SB(I-1,34,2))/SB(I-1,34,2)))
!--
!--             Change in broiler consumption
!--             dbrcn=(dif(BRCN)/lag(BRCN));
!--

    S(NPT,I,35,4)=SB(I,35,4)+(((S(NPT,I,34,4)-S(NPT,I-1,34,4))/S(NPT,I-1,34,4))- &
    ((SB(I,34,4)-SB(I-1,34,4))/SB(I-1,34,4)))
!--
!--
!--             Difference in pork CPI
!--DRCPIPO= -.0198 +  -.40941*DBCN+ -1.08813 *DPCN+  -.12914*DBRCN+ -.02632 *DTUCN+ 1 *(drcepc/100)+ -.20567 *0.01 + .225012 * (dcrcepc/100) +.613835  *                     -.04;
!--DRCPIPO=F20+F21*DBCN+F22*DPCN+F23*DBRCN+F24*DTUCN+F26*DRCELDPC+F25*DQLFD+F27*DQcesp+F28*DQcengp
!--

    S(NPT,I,14,2)=SB(I,14,2)+LVP(15,2)*(S(NPT,I,35,1)-SB(I,35,1))+LVP(16,2)* &
    (S(NPT,I,35,2)-SB(I,35,2))+LVP(17,2)*(S(NPT,I,35,4)-SB(I,35,4))+ &
    LVP(18,2)*(S(NPT,I,35,5)-SB(I,35,5))
!--
!--             Difference in broiler CPI
!--DRCPIBR= -.00354+ -.94707*DBCN+  -.13149*DPCN+ -1.35845 *DBRCN+-.0792 *DTUCN+ 1 *(drcepc/100)+ 1.025955*.01+  -.02619* (dcrcepc/100)+.321397 *(-.04);
!--DRCPIBR=F30+F31*DBCN+F32*DPCN+F33*DBRCN+F34*DTUCN+F36*DRCELDPC+F35*DQLFD+F37*DQcesp+F38*DQcengp;
!--

    S(NPT,I,14,4)=SB(I,14,4)+LVP(15,4)*(S(NPT,I,35,1)-SB(I,35,1))+LVP(16,4)* &
    (S(NPT,I,35,2)-SB(I,35,2))+LVP(17,4)*(S(NPT,I,35,4)-SB(I,35,4))+ &
    LVP(18,4)*(S(NPT,I,35,5)-SB(I,35,5))
!--
!--             Difference in 7 market barrow and gilt price
!--dRBG7MP=  .010541+ 1.174368*(drCPIPO)+ -1.09958*dif(poscpus)/lag(poscpus);
!--dRBG7MP=SPH10+SPH11*(drCPIPO)+SPH12*dif(poscpus)/lag(poscpus)
!--

    S(NPT,I,8,2)=SB(I,8,2)+LVP(24,2)*(S(NPT,I,14,2)-SB(I,14,2))+ &
    LVP(25,2)*(((S(NPT,I,24,2)-S(NPT,I-1,24,2))/S(NPT,I-1,24,2))- &
    ((SB(I,24,2)-SB(I-1,24,2))/SB(I-1,24,2)))
!--
!--             Difference in 12 city wholesale broiler price variable
!--dRCHIP= .017798+ 1.223751*(drCPIBR)+( -.57062)*dif(BRCN)/lag(BRCN);
!--dRCHIP=RBRS0+RBRS1*(drCPIBR)+(RBRS2)*dif(BRCN)/lag(BRCN)
!--

    S(NPT,I,8,4)=SB(I,8,4)+LVP(25,4)*(S(NPT,I,14,4)-SB(I,14,4))+ &
    LVP(26,4)*(((S(NPT,I,34,4)-S(NPT,I-1,34,4))/S(NPT,I-1,34,4))- &
    ((SB(I,34,4)-SB(I-1,34,4))/SB(I-1,34,4)))
!--
!--             7-market barrow and gilt price
!--RBG7MP=LAG(RBG7MP)*(1+DRBG7MP)-.2;
!--

    S(NPT,I,1,2)=SB(I,1,2)+(S(NPT,I-1,1,2)*(1+S(NPT,I,8,2)))-(SB(I-1,1,2)* &
    (1+SB(I,8,2)))
!--
!--             12 city wholesale broiler price
!--RCHIP=LAG(RCHIP)*(1+DRCHIP);  RCHIP=LAG(RCHIP)*(1+DRCHIP)-(year-2002)*.05+brfp;
!--

    S(NPT,I,1,4)=SB(I,1,4)+(S(NPT,I-1,1,4)*(1+S(NPT,I,8,4)))- &
    (SB(I-1,1,4)*(1+SB(I,8,4)))
!--
!--             Hog net returns
!--rhogrec=((44.20*(RBG7MP*cPI/100)/44.76)-(htotalc-(((year-1998)*.6)*cpi/136)))/cpi*100;
!--rhogrec=((44.20*(RBG7MP*cPI/100)/44.76)-(httcc-hcostf-((0+(year-2000)*.5)*cpi/136)))/cpi*100
!--

    S(NPT,I,36,2)=SB(I,36,2)+(((44.2*(S(NPT,I,1,2)*XAG(I,1)/100)/44.76)- &
    (S(NPT,I,42,2)-(((IYEAR(I)-2000)*.5)*XAG(I,1)/136)))/XAG(I,1)*100)- &
    (((44.2*(SB(I,1,2)*XAG(I,1)/100)/44.76)- &
    (SB(I,42,2)-(((IYEAR(I)-2000)*.5)*XAG(I,1)/136)))/XAG(I,1)*100)
!--
!--             Broiler net returns
!--rbroilnr=rchip-(brtc/cpi*100);
!--

    S(NPT,I,36,4)=SB(I,36,4)+(S(NPT,I,1,4)-SB(I,1,4))- &
    ((S(NPT,I,42,4)-SB(I,42,4))/XAG(I,1)*100)
!--
!--                ********************************************
!--                *CHECK CONVERGENCE OF SIMULTANOUS EQUATIONS*
!--                ********************************************
!--
    IDONE=0     !0=converged/1=not converged
    do K=1,5
        do j=1,39
            S(NPT,I,J,K)=.33*SLAST(J,K)+(1.0 - 0.33)*S(NPT,I,J,K)               !WEIGHTED AVERAGE
            IF (IDONE == 1 .OR. SLAST(J,K) == 0.0)GOTO 200            !BYPASS CHECK IF NOT NEEDED
            IF ((ABS((S(NPT,I,J,K)-SLAST(J,K))/SLAST(J,K))-.0001) <= 0.0) &
            GOTO 200                                                !IF YES THEN CONVERGED
                IDONE=1                                                 !IF NO, THEN ANOTHER ITERA
                200 CONTINUE
            ENDDO
        ENDDO
        IF (IDONE == 1) GOTO 100                                  !BACK FOR ANOTHER ITERA
        400 continue                                                  !INCASE TOO MANY ITERATIONS
    !--         Total Pork Production
    !--poscpus=(hoKCAUS*(bgkgnus+swkgnus+bskgnus)*1/.975)/1000;
    !--poscpus=(hoKCAUS*(bgkgnus+swkgnus+bskgnus)*1/firatio)/1000;
        RETURN
        END SUBROUTINE LVSIMUL

                        !     Last change:  CH   21 Aug 2004    2:10 pm
        SUBROUTINE LVSK
        IMPLICIT NONE

        REAL :: RATEOFCHQL(7),RATEOFCHDL(7)

        !EIA add
        INTEGER :: IYEAR1,IDB,NLVSK,J
    !--
    !--   VER. 1.0
    !--
    !--                         ****************
    !-- *********************   LVSK  SUBROUTINE  ***********************
    !--                         ****************
    !--
    !--      *********
    !--      * THIS SUBROUTINE IS CALLED FROM
    !--      * MAIN.FOR
    !--      *********
    !--
    !--             FIRST YEAR OF SIMULATION
    !--
        IYEAR1 = INDEX(30)
    !--
    !--             AUXILLARY WRITE STATEMENTS (UNIT NO., 0 SCREEN, -1 OFF)
    !--

        IDB = INDEX(25)
    !--
    !--

    !--
    !--
    !--             NUMBER OF LIVESTOCK CATEGORIES IN POLYSYS
    !--
        NLVSK = INDEX(5)
    !--
    !--             LOOP MODEL LIVESTOCK CATEGORIES
    !--

    !--
    !--
        IF(INDEX(51)==0) THEN                               !!chad added
        !--
        !--             LOOP MODEL LIVESTOCK CATEGORIES
        !--
            DO K = 1,NLVSK

                IF(K==3) GOTO 180
            !--
            !--     **********                     |01 OWN PRICE
            !--     PRODUCTION                     |02 CROSS CATTLE PRICE
            !--     **********                     |03 CROSS HOG PRICE
            !--                                    |04 CROSS SHEEP PRICE
            !--                                    |05 FEED PRICE INDEX
            !--                                    |06 PRICES PAID
            !--
            !--             [02, 03 & 04 ZERO FOR OWN COMMODITY (EGL(02,1) = 0.0)]
            !--
                S(NPT,I,01,K) = SB(I,01,K) * ( 1.0 &
                + EGL(1,K) * (S(NPT,L,02,K)  - SB(L,02,K))  / SB(L,02,K) &
                + EGL(2,K) * (S(NPT,L,02,01) - SB(L,02,01)) / SB(L,02,01) &
                + EGL(3,K) * (S(NPT,L,02,02) - SB(L,02,02)) / SB(L,02,02) &
            !     4         + EGL(4,K) * (S(NPT,L,02,03) - SB(L,02,03)) / SB(L,02,03)
                + EGL(5,K) * (A(NPT,L,24,3) - AB(L,24,3)) / AB(L,24,3) &
                + EGL(6,K) * (A(NPT,L,23,3) - AB(L,23,3)) / AB(L,23,3) &
                ) + AJL(01,K) * (S(NPT,L,01,K) - SB(L,01,K))
            !--
            !--     ****************************   |   PRODUCTION
            !--     AVAILABLE FOR DOMESTIC CONS.   |   IMPORTS
            !--     ****************************   |   EXPORTS
            !--                                    |   CCC REMOVALS

                    S(NPT,I,03,K) = S(NPT,I,01,K) + XS(NPT,I,01,K) - XS(NPT,I,02,K) - XS(NPT,I,03,K)

                180 CONTINUE
            ENDDO
        !--
        !--     *****                          |01 CATTLE AVAIL FOR CONS.
        !--     PRICE                          |02 HOGS     "    "    "   ETC.
        !--     *****                          |03 SHEEP
        !--                                    |04 CHICKENS
        !--                                    |05 TURKEYS
        !--                                    |06 EGGS
        !--                                    |07 MILK
        !--
            DO K = 1,NLVSK

                IF(K==3) GOTO 280
                S(NPT,I,02,K) = SB(I,02,K) * ( 1.0 &
                + EDML(K,1) * (S(NPT,I,03,1) - SB(I,03,1)) / SB(I,03,1) &
                + EDML(K,2) * (S(NPT,I,03,2) - SB(I,03,2)) / SB(I,03,2) &
            !    3   + EDML(K,3) * (S(NPT,I,03,3) - SB(I,03,3)) / SB(I,03,3)
                + EDML(K,4) * (S(NPT,I,03,4) - SB(I,03,4)) / SB(I,03,4) &
                + EDML(K,5) * (S(NPT,I,03,5) - SB(I,03,5)) / SB(I,03,5) &
                + EDML(K,6) * (S(NPT,I,03,6) - SB(I,03,6)) / SB(I,03,6) &
                + EDML(K,7) * (S(NPT,I,03,7) - SB(I,03,7)) / SB(I,03,7) &
                )
                280 CONTINUE
            ENDDO
        !--
        !--     *************************
        !--     INDEX OF LIVESTOCK PRICES
        !--     *************************
        !--
        !--             SEE SETDEX FOR DETAILS ON PROCEDURE
        !--
            DO K = 1, NLVSK
                A(NPT,I,K+10,3) = FCTRLV(K) * S(NPT,I,02,K)
               END DO
        !--             MEAT ANIMALS ONLY INCLUDE CATTLE AND HOGS
            A(NPT,I,18,3)= A(NPT,I,11,3)*PERMET(1)+A(NPT,I,12,3)*PERMET(2)
        !--             POULTRY INCLUDES ALL THREE
            A(NPT,I,19,3)= A(NPT,I,14,3)*PERPOL(1)+A(NPT,I,15,3)*PERPOL(2) &
            + A(NPT,I,16,3)*PERPOL(3)
        !--
        !--             EVEN THOUGH SHEEP DATA ARE NOT USED TO CALCULATE
        !--             THE MEAT ANIMAL INDEX, THE WEIGHT TO CONSTRUCT THE
        !--             LIVESTOCK PRICE INDEX INCLUDES SHEEP.
        !--
            A(NPT,I,20,3)= A(NPT,I,18,3)*PERLV(1)+A(NPT,I,19,3) &
            * PERLV(2)+A(NPT,I,17,3)*PERLV(3)
        !--

        !--
        !--             1977 IS USED AS THE DISPLAY YEAR.  CONVERT ALL INDEXES
        !--             TO 1977=100 HERE.  AGGREGATION FAILS IF DONE AS PART OF
        !--             THE CALULATIONS ABOVE.
        !--
            DO J =11,20
                A(NPT,I,J,3) = A(NPT,I,J,3)/CONVSN(J)
               END DO
        !--
        !--
        !--     **************************
        !--     LIVESTOCK PRODUCTION UNITS
        !--     **************************
            A(NPT,I,05,2) = 0.001170*S(NPT,I,01,1)+0.0016660*S(NPT,I,01,2)+0.000673 &
            *S(NPT,I,01,3)+0.000939*S(NPT,I,01,4)+0.001078*S(NPT,I,01,5) &
            +0.001482*S(NPT,I,01,6)+0.000105*S(NPT,I,01,7)              !S(NPT,I,1,7) WAS COMMENTED 10/24/03

        !--
        ELSE
        !--
        !--             LOOP MODEL LIVESTOCK CATEGORIES
        !--
            DO K = 1,NLVSK

                IF(K==3) GOTO 170
            !--
            !--     **********                     |01 OWN PRICE
            !--     PRODUCTION                     |02 CROSS CATTLE PRICE
            !--     **********                     |03 CROSS HOG PRICE
            !--                                    |04 CROSS SHEEP PRICE
            !--                                    |05 FEED PRICE INDEX
            !--                                    |06 PRICES PAID
            !--
            !--             [02, 03 & 04 ZERO FOR OWN COMMODITY (EGL(02,1) = 0.0)]
            !--
                S(NPT,I,44,K) = SB(I,44,K) * ( 1.0 &
                + EGL(1,K) * (S(NPT,L,50,K)  - SB(L,50,K))  / SB(L,50,K) &
                + EGL(2,K) * (S(NPT,L,50,01) - SB(L,50,01)) / SB(L,50,01) &
                + EGL(3,K) * (S(NPT,L,50,02) - SB(L,50,02)) / SB(L,50,02) &
            !     4 + EGL(4,K) * (S(NPT,L,50,03) - SB(L,50,03)) / SB(L,50,03)
                + EGL(5,K) * (A(NPT,L,24,3) - AB(L,24,3)) / AB(L,24,3) &
                + EGL(6,K) * (A(NPT,L,23,3) - AB(L,23,3)) / AB(L,23,3) &
                ) + AJL(01,K) * (S(NPT,L,44,K) - SB(L,44,K))
            !      WRITE(*,*)I,K,S(NPT,I,44,K),SB(I,44,K)
            !      WRITE(*,*)EGL(1,K),S(NPT,L,50,K),SB(L,50,K)
            !      WRITE(*,*)EGL(2,K),S(NPT,L,50,01),SB(L,50,01)
            !      WRITE(*,*)EGL(3,K),S(NPT,L,50,02),SB(L,50,02)
            !      WRITE(*,*)EGL(5,K),A(NPT,L,24,3),AB(L,24,3)
            !      WRITE(*,*)EGL(6,K),A(NPT,L,23,3),AB(L,23,3)
            !      WRITE(*,*)AJL(01,K),S(NPT,L,44,K),SB(L,44,K)
            !--
            !--     ****************************   |   PRODUCTION
            !--     AVAILABLE FOR DOMESTIC CONS.   |   IMPORTS
            !--     ****************************   |   EXPORTS
            !--                                    |   CCC REMOVALS

                    S(NPT,I,57,K) = SB(I,57,K) + (S(NPT,I,44,K) + XS(NPT,I,28,K) - XS(NPT,I,29,K) &
                    - XS(NPT,I,30,K)) - &
                    (SB(I,44,K) + XSB(I,28,K) - XSB(I,29,K) &
                    - XSB(I,30,K))


                170 CONTINUE
            END DO
        !--
        !--     *****                          |01 CATTLE AVAIL FOR CONS.
        !--     PRICE                          |02 HOGS     "    "    "   ETC.
        !--     *****                          |03 SHEEP
        !--                                    |04 CHICKENS
        !--                                    |05 TURKEYS
        !--                                    |06 EGGS
        !--                                    |07 MILK
        !--
            DO K = 1,NLVSK

                IF(K==3) GOTO 270
                S(NPT,I,50,K) = SB(I,50,K) * ( 1.0 &
                + EDML(K,1) * (S(NPT,I,57,1) - SB(I,57,1)) / SB(I,57,1) &
                + EDML(K,2) * (S(NPT,I,57,2) - SB(I,57,2)) / SB(I,57,2) &
            !     3 + EDML(K,3) * (S(NPT,I,57,3) - SB(I,57,3)) / SB(I,57,3)
                + EDML(K,4) * (S(NPT,I,57,4) - SB(I,57,4)) / SB(I,57,4) &
                + EDML(K,5) * (S(NPT,I,57,5) - SB(I,57,5)) / SB(I,57,5) &
                + EDML(K,6) * (S(NPT,I,57,6) - SB(I,57,6)) / SB(I,57,6) &
            !    7 + EDML(K,7) * (S(NPT,I,57,7) - SB(I,57,7)) / SB(I,57,7)
                )
            270 CONTINUE
               END DO
        !--
        endif
        RETURN
        END  SUBROUTINE LVSK



    !     Last change:  CH   26 May 2006    5:04 pm
        SUBROUTINE MDLDEX
        IMPLICIT NONE


        !EIA add
         INTEGER IDB,NCROPS,NLVSK,J,NYRSIM,ISTART,IEND
    !--
    !--
    !--
    !--                         *****************
    !-- *********************** MDLDEX SUBROUTINE ***********************
    !--                          *****************
    !--
    !--        ****** COMPUTES BASELINE PRICES RECEIVED AND OTHER ******
    !--                           INDEXES
    !--
    !--             AUXILLARY WRITE STATEMENTS (UNIT NO., 0 SCREEN, -1 OFF)
    !--

        IDB = INDEX(25)
    !--
    !--

    !--
    !--       ****************
    !--       * THIS SUBROUTINE IS CALLED FROM
    !--       * MAIN.FOR
    !--       ****************
    !--
    !--             NUMBER OF YEARS SIMULATED
    !--
        NYRSIM = INDEX(1)
        ISTART = INDEX(30)-INDEX(27)+3
        IEND = NYRSIM+(INDEX(30)-INDEX(27))+2
    !--
    !--
    !--             NUMBER OF CROPS IN POLYSYS
    !--
    !--      NCROPS = INDEX(2)
    ! CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
    !                                                                                    C
    !           OVERRIDE BECAUSE RICE IS NOT READY       C
    !                                                                                    C
    ! CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
        NCROPS =7
    !--
    !--             NUMBER OF LIVESTOCK CATEGORIES
    !--
        NLVSK = INDEX(5)
    !--
    !--     ************************
    !--     INDEX OF PRICES RECEIVED
    !--     ************************
    !--
    !--             MUST BE RESTRUCTURED IF MORE COMMODITIES ARE ADDED
    !--
    !c      DO I = ISTART,IEND                                            !!in 25 year version this mdldex needs to be in i loop
        L=I-1
        DO K = 1,NCROPS
            A(NPT,I,K,3)= FCTRCP(K)*(YRPER(K)*C(NPT,I,09,K)+(1-YRPER(K))*C(NPT,L,09,K))
      END DO
        A(NPT,I,8,3)= A(NPT,I,1,3)*PERFG(1) + A(NPT,I,2,3)*PERFG(2) &
        + A(NPT,I,3,3)*PERFG(3) + A(NPT,I,4,3)*PERFG(4)
    !--             FOOD GRAINS ONLY CONTAINS WHEAT
        A(NPT,I,9,3) = A(NPT,I,5,3)
    !--             OIL CROPS ONLY INCLUDE SOYBEANS
        A(NPT,I,10,3)= A(NPT,I,6,3)
    !--
    !-- *********** LIVESTOCK PRICE INDEXES COMPUTED IN LVSK
    !--             SINCE ALL LIVESTOCK NEEDED IN FEED GRAIN DEMAND EQ.
    !--
    !--             WEIGHTS FOR: FEED GRAINS INCLUDES HAY; FOOD GRAINS
    !--             INCLUDES RICE AND RYE; OIL SEEDS INCLUDES PEANUTS,
    !--             COTTONSEED AND OTHER OILSEEDS IN THE CONSTRUCTION OF
    !--             THE CROP PRICE INDEX.
    !--
        A(NPT,I,21,3)= A(NPT,I,9,3)*PERCP(1)+A(NPT,I,5,3)*PERCP(2) &
        + A(NPT,I,6,3)*PERCP(3)+A(NPT,I,7,3)*PERCP(4)
    !--
    !--             CROPS AND LIVESTOCK CATEGORIES THAT WERE LEFT OUT OF THE
    !--             CROP PRICE INDEX AND LIVESTOCK PRICE INDEX ARE INCLUDED
    !--             IN WEIGHTS FOR THE ALL PRODUCTS PRICE INDEX
    !--                 (MULT BY CONVSN(20) TO CONVERT BACK TO 71-73
    !--                  FOR AGGREGATION PURPOSES)
    !--
        A(NPT,I,22,3)= A(NPT,I,20,3)*PERALL(1)*CONVSN(20)+A(NPT,I,21,3)*PERALL(2)
    !--
    !--             1977 IS USED AS THE DISPLAY YEAR.  CONVERT ALL INDEXES
    !--             TO 1977=100 HERE.  AGGREGATION FAILS IF DONE AS PART OF
    !--             THE CALULATIONS ABOVE.
    !--
        DO J = 1,10
            A(NPT,I,J,3) = A(NPT,I,J,3)/CONVSN(J)
         END DO
        DO J = 21,22
            A(NPT,I,J,3) = A(NPT,I,J,3)/CONVSN(J)
           END DO
    !--

    !--
    !--             PRELIMINARY WORK ON EQNS
    !--
        A(NPT,I,23,3) = AB(I,23,3) * (1.0 &
        +0.118*(A(NPT,I,24,3)-AB(I,24,3))/AB(I,24,3) &
        +0.117*(A(NPT,I,20,3)-AB(I,20,3))/AB(I,20,3) &
        +0.018*(A(NPT,I,21,3)-AB(I,21,3))/AB(I,21,3) &
        )


        A(NPT,I,26,3) = AB(I,26,3)*(1+0.06*(A(NPT,I,22,3)-AB(I,22,3))/AB(I,22,3))
    !      WRITE(*,*)a(i,26,3),ab(i,26,3),a(i,22,3),ab(i,22,3),i,'inmdldex'
    !c      END DO      !!in 25 year version this mdldex needs to be in i loop
        RETURN
        END SUBROUTINE MDLDEX

    !     Last change:  CH   15 Jun 2006    3:07 pm
        SUBROUTINE MDLGOVC
        IMPLICIT NONE

        REAL :: BSACRES=0.0,HIGHER=0.0,MKTPRC=0.0,CCPADJ=0.0

        !EIA add
        REAL :: GPMDCP
        INTEGER IEND,IDB,II,NYRSBS,YEAR,NCROPS
        INTEGER NYRSIM,ISTART

        IEND = INDEX(1) +(INDEX(30)-INDEX(27)) + 2
    !-- *********************** MDLGOVC SUBROUTINE ***********************
    !--             ****** COMPUTES GOVERNMENT PAYMENST ******
    !--             AUXILLARY WRITE STATEMENTS (UNIT NO., 0 SCREEN, -1 OFF)

        IDB = INDEX(25)

    !--             NUMBER OF YEARS SIMULATED
        NYRSIM = INDEX(1)
        ISTART= 3
        NYRSBS = INDEX(28) + 2
    !--             NUMBER OF CROPS IN POLYSYS
    !c      NCROPS = INDEX(2)
        NCROPS = 8
        YEAR = I+INDEX(27)-3

        L = I - 1
    !--      ACCUMULATION VARIABLES
        GPMDCP = 0.0
        XA(I,5,2)=0.0
    !--
        DO K = 1,NCROPS      ! DO LOOP FOR CROPS
        !--
        !--   ********************************************************
        !--   *************LOAN DEFICIENCY PAYMENTS*******************
        !--   ********************************************************
        !--
        !c            IF(K==7.AND.I>=3) THEN
        !c                WP(I,K) = 0.92655 * (1-0.963434)
        !c     1                   + 0.14545 * (C(NPT,I,9,K) - 0.963434 *C(NPT,I-1,9,K))
        !c     1                   - 0.03773 * (C(NPT,I-1,9,K) - 0.963434 *C(NPT,I-2,9,K))
        !c     1                   + 0.963434 * WP(I-1,K)
        !c            END IF
        !c            IF(K==8.AND.I>=3) THEN
        !c               WP(I,K) = -0.57926*(1+ 0.141857)
        !c     1                  + 0.827123*(C(NPT,I,9,K)+ 0.141857*C(NPT,I-1,9,K))
        !c     1                  + 0.021773*(C(NPT,I-1,9,K)+0.141857*C(NPT,I-2,9,K))
        !c     1                  - 0.141857*WP(I-1,K)
        !c            END IF




        !--      Difference between Loan Rate and Farm Price
        !c         IF(K==7.OR.K==8) THEN
        !c            GC(I,9,K) = GB(I,9,K)
        !c     1                + (X(I,11,K)-XB(I,11,K)) - (WP(I,K)-WPB(I,K))  !now usda has rice and cotton prices in baseline, before did not
        !c         ELSE
            GC(NPT,I,9,K) = GB(I,9,K) &
            + (X(I,11,K)-XB(I,11,K)) - (C(NPT,I,9,K)-B(I,9,K))
        !c         END IF
        !--      Average LDP rate per unit of production
            GC(NPT,I,4,K) = GB(I,4,K) + (MAX(0.0,GC(NPT,I,9,K))-MAX(0.0,GB(I,9,K)))
        !--      Logit of Share of Bushels taking LDP
            GC(NPT,I,10,K) = GB(I,10,K) + EQ22(K) * (GC(NPT,I,4,K)-GB(I,4,K))
        !--      Percent of Bushels taking LDP
            GC(NPT,I,8,K) = MAX(0.5,(EXP(GC(NPT,I,10,K))/(1+EXP(GC(NPT,I,10,K)))))
        !--      Logit of share of Production under loan
            GC(NPT,I,11,K)=GB(I,11,K) &
            +EQ12(K)*((X(I,11,K)-XB(I,11,K))-(C(NPT,I,9,K)-B(I,9,K))) &
            +EQ13(K) * (GC(NPT,I,4,K)-GB(I,4,K))
        !--      Percent of production under loan
            GC(NPT,I,5,K) = EXP(GC(NPT,I,11,K)) /(1.0 + EXP(GC(NPT,I,11,K)))
        !--      Bushels placed under loan
            IF(K==7) THEN
                GC(NPT,I,6,K) = GC(NPT,I,5,K) * C(NPT,I,3,K)*1000*480/504
       ELSE
                GC(NPT,I,6,K) = GC(NPT,I,5,K) * C(NPT,I,3,K)
      END IF
        !--      Production eligible for LDP
            IF(K==7) THEN
                GC(NPT,I,7,K) = C(NPT,I,3,K)*1000*480/504 - GC(NPT,I,6,K)
       ELSE
                GC(NPT,I,7,K) = C(NPT,I,3,K) - GC(NPT,I,6,K)
       END IF
        !        ----------------------------------------------------
        !--      Total LDP's for crop year                          !
            GC(NPT,I,1,K) = GB(I,1,K)+(GC(NPT,I,7,K)*GC(NPT,I,8,K)*GC(NPT,I,4,K)) & !
            - (GB(I,7,K)*GB(I,8,K)*GB(I,4,K))        !
            C(NPT,I,20,K) = MAX(GC(NPT,I,1,K),0.0)                       !
        !--      Total LDP's for fiscal year                        !
            GC(NPT,I,2,K) = GB(I,2,K)                               & !
            + CYL(K) * (GC(NPT,L,1,K)-GB(L,1,K))          & !
            + CYY(K) * (GC(NPT,I,1,K)-GB(I,1,K))         !
            C(NPT,I,41,K) = MAX(GC(NPT,I,2,K),0.0)                       !
        !--      Total LDP's for calendar year                      !
            GC(NPT,I,3,K) = GB(I,3,K)                               & !
            + CLL(K) * (GC(NPT,L,1,K)-GB(L,1,K))          & !
            + CL(K)  * (GC(NPT,I,1,K)-GB(I,1,K))         !
            C(NPT,I,33,K) = MAX(GC(NPT,I,3,K),0.0)                       !
        !        ----------------------------------------------------
        !--
        !--         AGGREGATE INTO TOTAL FOR ALL MODEL CROPS
            A(NPT,I,17,2) = A(NPT,I,17,2)+C(NPT,I,20,K)
        !--
        !--      *******CHANGE UNITS IN COTTON AND RICE*******
        !--
            IF(K==7)THEN   ! IF COTTON
                DO II=1,IEND
                    C(NPT,II,09,07) = C(NPT,II,09,07) * 480.0   ! CONVERT $ PER LB. TO $ PER BALE FOR CASH RECEIPTS EQ.
                    B(II,09,07) = B(II,09,07) * 480.0   ! ALSO BASE MARKET PRICE FOR VARIABLE EXPENSE PER AC ==
                    X(II,10,07) = X(II,10,07) * 480.0   ! 09  OWN PRICE
                    X(II,11,07) = X(II,11,07) * 480.0   ! 10  TARGET PRICE
                    XB(II,10,07) = XB(II,10,07) * 480.0 ! 11  CCC LOAN RATE
                    XB(II,11,07) = XB(II,11,07) * 480.0 !
                    X(II,32,07) = X(II,32,07) * 480.0   ! DIRECT PAYMENT RATE
                    XB(II,32,07) = XB(II,32,07) *480.0
                    X(II,08,07) = X(II,08,07) / 480.0   ! PROGRAM YIELD (NEW)FOR COUNTER CYCLICAL PYMNTS
                    X(II,07,07) = X(II,07,07) / 480.0   ! PROGRAM YIELD (OLD)FOR DIRECT CONTRACT PYMNTS
                    XB(II,08,07) = XB(II,08,07) / 480.0
                    XB(II,07,07) = XB(II,07,07) / 480.0
                    B(II,02,07) = B(II,02,07)/480.0     !YIELD TO BALES PER ACRE
                ENDDO
                BCCP(7)=BCCP(7)/480
      END IF
            IF(K==8)THEN   ! IF RICE
                DO II=1,IEND
                    X(II,08,08) = X(II,08,08) / 100.0
                    X(II,07,08) = X(II,07,08) / 100.0
                    XB(II,07,08) = XB(II,07,08) / 100.0
                    XB(II,08,08) = XB(II,08,08) / 100.0
                ENDDO
            END IF
        !--
        !--         HIGHER OF PRICE AND BASIC LOAN RATE TO COMPUTE DEFICIENCY PAYMENT RATE
        !--         ****SET MKT PRICE USED IN CCP COMPUTATION****
        !--         **BARLEY USES FEED PRICE, NOT FARM PRICE**
            IF(K==4)THEN
                MKTPRC=-.202096 + 0.894*C(NPT,I,9,K)
            ELSE
                MKTPRC = C(NPT,I,9,K)
         ENDIF
        !--
            IF(X(I,11,K)>MKTPRC)THEN
                HIGHER = X(I,11,K)
            ELSE
                HIGHER = MKTPRC
         ENDIF
        !--         ****************************    |10 TARGET PRICE
        !--         COMPUTED COUNTER CYCLICAL PYMNTS|01 HARVESTED ACREAGE
        !--         ****************************    |07 FARM PROGRAM YIELD
        !--                                         |DFPYRT DEF PAYMENT RATE
        !--                                         |BSACRES PLANTED IN 2002
        !--                                         |09 PARTICIPATION RATE
        !--
            IF(X(I,10,K) > (HIGHER+X(I,32,K)))THEN                 !SET COMPUTED PAYMENT RATE
                C(NPT,I,43,K) = X(I,10,K) - (HIGHER+X(I,32,K))
            ELSE
                C(NPT,I,43,K) = 0.0
         ENDIF

        !!!!!   CCP payments turned OFF HERE  !!!!!  IF TURN ON, ALSO TURN ON IN SETGOVC.FOR
            C(NPT,I,43,K) = 0.0
        !--
            IF(INDEX(42)==0)THEN
            !             IF(B(I,43,K)==0)THEN
            !               CCPADJ=0
            !             ELSE
            !               CCPADJ=(B(I,32,K)/B(I,43,K))/(XB(I,8,K)*XB(I,6,K))  !CCPADJ ADJUSTS CONTER PRODUCTION UNIT
            !             ENDIF
            !             CCP(K)=X(I,7,K)*X(I,6,K)*CCPADJ                       !FAPRI NOT USING THE .85...USES READIN PRODUCTION UNITS
                BCCP(K) = XB(I,8,K)*XB(I,6,K)*.85
                CCP(K) = X(I,8,K)*X(I,6,K)*.85                        !STARTING IN 2003 FAPRI USES "CCP PROGRAM YIELD" IN BASELINE
            ELSE
                BCCP(K) = XB(I,7,K)*XB(I,6,K)*.85
                CCP(K)=X(I,7,K)*X(I,6,K)*.85
         ENDIF
        !--                                                                !SOLVE CROP YR COUNTCYLPYMTS IF NOT IN BASELINE

            C(NPT,I,32,K)=B(I,32,K)+(CCP(K)*C(NPT,I,43,K)-BCCP(K)*B(I,43,K))
        !--
            IF(I>13)THEN
                C(NPT,I,42,K)=C(NPT,I-1,32,K)
            ELSE
                IF(K==1 .OR. K==2 .OR. K==6)THEN
                    C(NPT,I,42,K) = B(I,42,K)+ 0.7*(C(NPT,I-1,32,K)-B(I-1,32,K))  & !FISCAL YEAR CCP'S
                    +0.3*(C(NPT,I-2,32,K)-B(I-2,32,K))
                ELSE
                    C(NPT,I,42,K) = C(NPT,I-1,32,K)
         ENDIF
            ENDIF
            IF(C(NPT,I,32,K)==0 .AND. C(NPT,I-1,32,K)==0 .AND. C(NPT,I-2,32,K)==0) &
            C(NPT,I,42,K)=0
            CONTINUE
        !--        ***********************
        !--        AGGREGATE COUNTER CYCLICAL PAYMENTS
        !--        ***********************
            A(NPT,I,18,2)=A(NPT,I,18,2)+C(NPT,I,32,K)                           !!A(NPT,I,18,2) WAS STORAGE PAYMENTS
        !--
        !--        ******************              |
        !--        CONTRACT PAYMENTS               |
        !--        ******************              |32 PAYMENT RATE
        !--
        !C          IF(X(I,10,K) > 0.0001.AND.X(I,34,K)<.001) THEN
            IF(X(I,32,K) == 0)THEN
                X(I,34,K) = 0
       ELSE
                X(I,34,K) = 0.0  !!!2014 FARM BILL  NO MORE CONTRACT PAYMENTS!!!
            !C              X(I,34,K) = XB(I,34,K)+(X(I,06,K) * X(I,07,K) *       !BSacres*BSyield*pymtrate*.85
            !C     1                   X(I,32,K)*0.85) -
            !C     1                   (XB(I,06,K) * XB(I,07,K) *
            !C     1                   XB(I,32,K)*0.85)
            ENDIF
        !C          ENDIF
        !--       ***********************
        !--       AGGREGATE CONTRACT PAYMENTS
        !--       ***********************
            XA(I,5,2) = XA(I,5,2) + X(I,34,K)
        !--
        !--       *************************       |   DEFICIENCY PAYMENTS
        !--       TOTAL GOVERNMENT PAYMENTS       |   STORAGE PAYMENTS
        !--       *************************       |   DIVERSION PAYMENTS
        !--                                       |   FIXED DECOUPLED PAYMENTS
        !--                                       |   COUNTER CYCLICAL PAYMENTS
            C(NPT,I,24,K) = C(NPT,I,20,K) + C(NPT,I,21,K) + C(NPT,I,22,K) + X(I,34,K) &
            + C(NPT,I,32,K)
        !--
        !--      *************************       |   ACCUMULATED MODEL CROP GVPM
        !--      AGGREGATE GOVERNMENT PAYMENTS   |05 CONTRACT GOVERNMENT PAYMENTS
        !--      *************************       |07 OTHER GOVERNMENT PAYMENTS
        !--
            GPMDCP = GPMDCP + C(NPT,I,24,K)
            IF(XA(I,07,2) <= 0.0)XA(I,7,2) = 0
            A(NPT,I,20,2) = GPMDCP +  XA(I,7,2)            !+ A(NPT,I,19,2)*ITIMES
        !--
        !--      *********************************************
        !--      TOTAL CASH AND GOVERNMENT GOVERNMENT PAYMENTS
        !--      *********************************************
            C(NPT,I,27,K) = C(NPT,I,19,K) + C(NPT,I,24,K)
        !--
        !--      SET COTTON PRICE VARIABLES BACK $ PER LB.
        !--      AND CONVERT PROGRAM YIELD BACK TO LBS
            IF(K==7)THEN   ! IF COTTON OR RICE
                DO II=1,IEND
                    C(NPT,II,09,07) = C(NPT,II,09,07) / 480.0   ! CONVERT $ PER LB. TO $ PER BALE FOR CASH RECEIPTS EQ.
                    B(II,09,07) = B(II,09,07) / 480.0   ! ALSO BASE MARKET PRICE FOR VARIABLE EXPENSE PER AC ==
                    X(II,10,07) = X(II,10,07) / 480.0   ! 09  OWN PRICE
                    X(II,11,07) = X(II,11,07) / 480.0   ! 10  TARGET PRICE
                    XB(II,10,07) = XB(II,10,07) / 480.0 ! 11  CCC LOAN RATE
                    XB(II,11,07) = XB(II,11,07) / 480.0 !
                    X(II,32,07) = X(II,32,07) / 480.0   ! DIRECT PAYMENT RATE
                    XB(II,32,07) = XB(II,32,07) /480.0   !
                    X(II,08,07) = X(II,08,07) * 480.0   ! PROGRAM YIELD (NEW)FOR CCP
                    X(II,07,07) = X(II,07,07) * 480.0   ! PROGRAM YIELD (OLD)FOR CONTRACT PYMTS
                    XB(II,08,07) = XB(II,08,07) * 480.0
                    XB(II,07,07) = XB(II,07,07) * 480.0
                    B(II,02,07) = B(II,02,07) * 480.0   ! YIELD TO BALES PER ACRE
         ENDDO
                BCCP(7)=BCCP(7)*480
            END IF
            IF(K==8)THEN
                DO II=1,IEND
                    X(II,08,08) = X(II,08,08) * 100.0
                    X(II,07,08) = X(II,07,08) * 100.0
                    XB(II,07,08) = XB(II,07,08) * 100.0
                    XB(II,08,08) = XB(II,08,08) * 100.0
        ENDDO
            END IF
        END DO         ! End of CROPS DO Loop
        RETURN
        END SUBROUTINE MDLGOVC

                        !     Last change:  2021
       SUBROUTINE MDLINC
        IMPLICIT NONE

        REAL :: BSACRES=0.0,HIGHER=0.0

       !EIA add
      REAL STKHD

      INTEGER NYRSIM,ISTART,IEND,NCROPS,II,LAG,IDB,NLVSK,L2,L3

    !     DIMENSION SMCPYR(12,8)
    !--
    !--                     *****************
    !-- ******************* MDLINC SUBROUTINE ************************
    !--             THIS SUBROUTINE IS CALLED FROM MAIN
    !--    COMPUTES INCOME RELATED VARIABLES FOR MODEL CROPS & LIVESTOCK
    !--                     *****************
    !--   NUMBER OF YEARS SIMULATED
        NYRSIM = INDEX(1)
        ISTART = INDEX(30)-INDEX(27)+3
        IEND = NYRSIM+(INDEX(30)-INDEX(27))+2
    !--   NUMBER OF CROPS IN POLYSYS
    !      NCROPS = INDEX(2)
        NCROPS = 8
    !--   NUMBER OF LIVESTOCK CATEGORIES
        NLVSK = INDEX(5)
    !--   AUXILLARY WRITE STATEMENTS (UNIT NO., 0 SCREEN, -1 OFF)

        IDB = INDEX(25)

    !--   SET LAGGED DEFICIENCY PAYMENT TO BASELINE COMPUTED VALUE
        LAG = ISTART-1
        DO K = 1,NCROPS
            SMCPYR(LAG,K) = BASECP(LAG,02,K)
           END DO
    !--   DO LOOP TO COMPUTE ALL YEARS FROM FIRST YEAR TO LAST
        DO I = ISTART,IEND
        !--      SET UP LAG VARIABLES FOR USE IN CASH RECEIPTS EQ.
            L  =  I - 1
            L2 =  L - 1
            L3 = L2 - 1
        !--      SET TO ZERO JUST TO BE SAFE SINCE THEY ARE USED TO ACCUMULATE VALUES
            A(NPT,I,01,2) = 0.0
            A(NPT,I,03,2) = 0.0
            A(NPT,I,06,2) = 0.0
            A(NPT,I,10,2) = 0.0
            A(NPT,I,13,2) = 0.0
            A(NPT,I,26,2) = 0.0
            A(NPT,I,28,2) = 0.0
        !--      *************
        !--      CROP SECTION
        !--      *************
            DO K = 1, NCROPS
                IF(K==7)THEN   ! IF COTTON OR RICE
                    DO II=1,IEND
                        C(NPT,II,09,07) = C(NPT,II,09,07) * 480.0   ! CONVERT $ PER LB. TO $ PER BALE FOR CASH RECEIPTS EQ.
                        B(II,09,07) = B(II,09,07) * 480.0   ! ALSO BASE MARKET PRICE FOR VARIABLE EXPENSE PER AC ==
                    ENDDO
                END IF
            !--         THE CASH RECEIPTS EQUATIONS USE A THREE YEAR LAG OF
            !--         ENDING STOCK.  THIS IS NOT AVAILABLE FOR THE FIRST
            !--         YEAR SIMULATED (I = 3), SO BEGINNING STOCK FOR 2
            !--         YEARS BACK IS USED, BGSTK(K).
                IF(I==3)THEN
                    STKHD = BGSTK(K)
                ELSE          ! ELSE (I > 3) USE ENDING STOCK FROM THREE YEARS BACK
                    STKHD = C(NPT,L3,14,K)
         ENDIF
            !--         *******************             :03 PRODUCTION
            !--         VALUE OF PRODUCTION             :09 PRICE
            !--         *******************
            !--         (COTTON PRICE IS IN $/BALE HERE)
                C(NPT,I,26,K) = C(NPT,I,03,K) * C(NPT,I,09,K)
                  !   WRITE(666,*)'value of prod',C(1:5,I,26,K),B(I,26,K),C(NPT,I,09,K),B(I,09,K),C(NPT,I,03,K),curcalyr,npt,i,k
            !c     1  ,B(I,03,K)
            !--         AGGREGATE INTO TOTAL FOR ALL MODEL CROPS
                A(NPT,I,06,2) = A(NPT,I,06,2)+C(NPT,I,26,K)
            !--         *************                   |01 INTERCEPT
            !--         CASH RECIEPTS                   |02 LAGGED PRODUCTION * PRICE
            !--         *************                   |03 PRODUCTION * PRICE
            !--                                         |04 CHANGE IN LAGGED ENDING STK
            !--                                          (CHANGE IN CURRENT BEG STK)
            !--                                         |05 RHO
            !--         CSCP IS A MATRIX OF REGRESSION COEFFICENTS FOR THE CROP CASH RECEIPTS EQUATIONS WHICH
            !--         ARE DEFINED IN DATA STATEMENTS IN THE SETINC.FOR SUBROUTINE (FROM THE CASH COMMON STATEMENT).
            !--         BASECP CONTAINS BASELINE EQUATION-ESTIMATED VALUES FOR CASH RECEIPTS (CS), DEFICIENCY PAYMENTS,
            !--         STORAGE PAYMANTS AND DIVERSION PAYMENTS FROM THE SETINC.FOR SUBROUTINE (FROM CASH COMMON STATEMENT).
            !--         THE CS EQUATION HERE ADJUSTS THE BASELINE CASH RECEIPTS  [B(I,19,K)] BY THE RATIO OF THE EQUATION-GENERATED
            !--         SIMULATED AND EQUATION-GENERATED BASECP(I,01,K) BASELINE VALUES.
            !--         IF THE B(X,19,K) VALUES WERE COMPUTED USING THE EQUATION, EQUATION-GENERATED SIMULATION VALUES
            !--         COULD BE USED DIRECTLY. BUT IF THE BASELINE CASH RECEIPTS WAS NOT GENERATED
            !--         FROM AN EQUATION IN SETINC BUT WAS "READ-IN" FROM PUBLISHED BASELINE, THE RATIO APPROACH PROVIDES AN
            !--         SIMUATION ESTIMATE CONSISTENT WITH THE READ-IN ESTIMATE.  IDENTICAL VALUES ARE ENSURED IN A
            !--         NO CHANGE SIMULATION.

                C(NPT,I,19,K) = B(I,19,K) * (CSCP(1,01,K) * (1.0 - CSCP(5,01,K)) &
                + CSCP(2,01,K)*(C(NPT,L,26,K)-CSCP(5,01,K)*C(NPT,L2,26,K)) &
                + CSCP(3,01,K)*(C(NPT,I,26,K)-CSCP(5,01,K)*C(NPT,L,26,K)) &
                + CSCP(4,01,K)*((C(NPT,L,14,K)-C(NPT,L2,14,K)) &
                - CSCP(5,01,K)*(C(NPT,L2,14,K)-STKHD)) &
                + CSCP(5,01,K)*C(NPT,L,19,K))/BASECP(I,01,K)
            !--         AGGREGATE INTO TOTAL FOR ALL MODEL CROPS
                A(NPT,I,03,2) = A(NPT,I,03,2) + C(NPT,I,19,K)
            !--
            !--         ************************************************************
            !--         IF POLYSYS IS RUNNING, INDEX(88) =1, THE COST WAS CALCULATED
            !--         IN OUTFRMLP. IF NOT POLYSYS STATEMENTS ARE USED
            !--         ************************************************************
                IF(INDEX(88)==1) THEN
                !--            Average Variable Cost
                    C(NPT,I,5,K) = B(I,5,K) + SMAVCS(I,K) - BLAVCS(I,K)
                !--            Total Variable Cost (includes cost of diverted acreage)
                    C(NPT,I,6,K) = B(I,6,K) + SMTVCS(I,K) - BLTVCS(I,K)
                ELSE
                !--            ********************************|04 OWN PRICE
                !--            VARIABLE COST PER ACRE EQUATIONS|05 PRICES PAID
                !--            ********************************
                !--            COMPUTE VARIABLE EXPENSE PER ACRE IF VARIABLE
                !--            EXPENSE PER ACRE IS NOT PREDETERMINED FOR THE
                !--            KTH CROP.
                    C(NPT,I,05,K) = B(I,05,K) * (1.0 &
                    + EGC(04,K) * (C(NPT,I,9,K) - B(I,9,K)) / B(I,9,K) &
                    + EGC(05,K) * (A(NPT,I,23,3)-AB(I,23,3))/AB(I,23,3) &
                    ) + AJC(05,K) * (C(NPT,L,05,K) - B(L,05,K))
                !--            IF PREDETERMINED, SET VALUE
                    IF(CFIXED(I,05,K)>001) C(NPT,I,05,K) = CFIXED(I,05,K)
                !--            **********************            |01 HARVESTED ACREAGE
                !--            TOTAL VARIABLE EXPENSE            |05 VARIABLE EXPENSE PER ACRE
                !--            **********************            |03 SETASIDE ACREAGE
                !--                                              |04 DIVERTED ACREAGE
                !--                                              |05 OATS VARIABLE EXP./ACRE
                !--            AS IMPLEMENTED HERE, TOTAL VARIABLE EXPENSE IS
                !--            HARVESTED ACREAGE TIMES VARIABLE COST PER ACRE
                !--            PLUS 70% OF OATS (OR 45% OF WHEAT FOR WHEAT CASE) VAR.
                !--            COST PER ACRE TIMES TOTAL OF PAID AND UNPAID DIVERTED
                !--            ACRES. (MAY WANT TO ADJUST HARVESTED ACREAGE
                !--            TO PLANTED.)
                !--            ***NOTE: BASE VARIABLE EXPENSE FOR OATS IS USED TO VALUE
                !--                     EXPENSES ON DIVERTED ACREAGE BECAUSE C VALUE
                !--                     FOR OATS IS NOT AVAILABLE FOR CORN AND GS
                !--                     TRIPS THROUGH THE LOOP.****
                    IF((K/=5) .AND. (K/=2)) THEN
                        C(NPT,I,6,K) = C(NPT,I,34,K)*C(NPT,I,5,K)+(0.7*(X(I,3,K)+X(I,4,K)) & !CHAD CHANGED 8/2019 WAS C(I,01
                        * B(I,05,3))
                    ELSE IF(K==2) THEN
                        C(NPT,I,06,2) = 1.20*C(NPT,I,34,2)*C(NPT,I,05,2) !CHAD CHANGED 8/2019 WAS C(I,01
                    ELSE
                        C(NPT,I,06,5) = C(NPT,I,05,05)*(C(NPT,I,34,05)+0.45*(X(I,03,05) & !CHAD CHANGED 8/2019 WAS C(I,01
                        + X(I,04,05)))
         ENDIF
         ENDIF
            !--         THE LAST ENDIF CLOSES THE DECISION OF WHERE THE COSTS WERE CALCULATED **
            !--         AGGREGATE INTO TOTAL FOR ALL MODEL CROPS
                A(NPT,I,01,2) = A(NPT,I,01,2)+C(NPT,I,06,K)
            !--         *******************
            !--         NET RETURNS BY CROP
            !--         *******************
            !--         This variable is in crop year basis & includes Deficiency Payments,
            !--         do not include storage,diversion, or other government payments
                C(NPT,I,28,K) = C(NPT,I,26,K) - C(NPT,I,06,K) + C(NPT,I,24,K)
            !--         AGGREGATE INTO TOTAL FOR ALL MODEL CROPS
                A(NPT,I,26,2) = A(NPT,I,26,2) + C(NPT,I,28,K) + XA(I,5,2)
            !--         ****************
            !--         VALUE OF EXPORTS
            !--         ****************
                C(NPT,I,29,K) = C(NPT,I,04,K)*C(NPT,I,09,K)
            !--         AGGREGATE INTO TOTAL FOR ALL MODEL CROPS
                A(NPT,I,13,2) = A(NPT,I,13,2)+C(NPT,I,29,K)
            !--         SET COTTON PRICE VARIABLES BACK $ PER LB.
            !--         AND CONVERT PROGRAM YIELD BACK TO LBS
                IF(K==7)THEN   ! IF COTTON OR RICE
                    DO II=1,IEND
                        C(NPT,II,09,07) = C(NPT,II,09,07) / 480.0   ! CONVERT $ PER LB. TO $ PER BALE FOR CASH RECEIPTS EQ.
                        B(II,09,07) = B(II,09,07) / 480.0   ! ALSO BASE MARKET PRICE FOR VARIABLE EXPENSE PER AC ==
                    ENDDO
                END IF
            END DO         ! End of CROPS DO Loop
        !--      *****************
        !--      LIVESTOCK SECTION
        !--      *****************
            DO K = 1,NLVSK
            !--         *************                   |01 INTERCEPT
            !--         CASH RECEIPTS                   |02 PRODUCTION * PRICE
            !--         *************                   |03 CHANGE IN PRICE
            !--                                         |04 RHO
            !--         CSLV IS A MATRIX OF REGRESSION COEFFICENTS
            !--         FOR THE LIVESTOCK CASH RECEIPTS EQUATIONS WHICH
            !--         ARE DEFINED IN DATA STATEMENTS IN THE SETINC.FOR
            !--         SUBROUTINE (FROM THE CASH COMMON STATEMENT).
            !--         THE BASELV MATRIX CONTAINS EQUATION ESTIMATED VALUES FOR CASH RECEIPTS.
            !--         SEE CROP CASH RECEIPTS FOR CALCULATION APPROACH
                IF(INDEX(51)==0) THEN
                    S(NPT,I,04,K) = SB(I,04,K) * (CSLV(1,K) * (1.0 - CSLV(4,K)) &
                    + CSLV(2,K)*(S(NPT,I,01,K)*S(NPT,I,02,K) &
                    - CSLV(4,K)*S(NPT,L,01,K)*S(NPT,L,02,K)) &
                    + CSLV(3,K)*((S(NPT,I,02,K)-S(NPT,L,02,K)) &
                    - CSLV(4,K)*(S(NPT,L,02,K)-S(NPT,L2,02,K))) &
                    + CSLV(4,K)*S(NPT,L,04,K))/BASELV(I,K)
                    A(NPT,I,10,2) = A(NPT,I,10,2)+S(NPT,I,04,K)                         ! AGGREGATE INTO TOTAL FOR ALL MODEL LIVESTOCK
                ELSE

                    S(NPT,I,58,K) = SB(I,58,K) * (CSLV(1,K) * (1.0 - CSLV(4,K)) &
                    + CSLV(2,K)*(S(NPT,I,44,K)*S(NPT,I,50,K) &
                    - CSLV(4,K)*S(NPT,L,44,K)*S(NPT,L,50,K)) &
                    + CSLV(3,K)*((S(NPT,I,50,K)-S(NPT,L,50,K)) &
                    - CSLV(4,K)*(S(NPT,L,50,K)-S(NPT,L2,50,K))) &
                    + CSLV(4,K)*S(NPT,L,58,K))/BASELV(I,K)
                    A(NPT,I,10,2) = A(NPT,I,10,2)+S(NPT,I,58,K)                     ! AGGREGATE INTO TOTAL FOR ALL MODEL LIVESTOCK
                END IF
            END DO   ! End of Livestock Do Loop
        !--
        !--      ******************************  |03 AVAILABLE FOR DOMESTIC CONS.
        !--      CONSUMER EXPENDITURES FOR FOOD  |02 PRICE CONVERTED TO $/CWT,
        !--      ******************************      CNTS/LB TO $/LB
        !--                                     |11 WHEAT FOOD DEMAND
            IF(INDEX(51)==0) THEN
                A(NPT,I,24,2) = AB(I,24,2) + ( &
                (S(NPT,I,03,1)*S(NPT,I,02,1)-SB(I,03,1)*SB(I,02,1))*0.01 &
                + (S(NPT,I,03,2)*S(NPT,I,02,2)-SB(I,03,2)*SB(I,02,2))*0.01 &
                + (S(NPT,I,03,3)*S(NPT,I,02,3)-SB(I,03,3)*SB(I,02,3))*0.01 &
                + (S(NPT,I,03,4)*S(NPT,I,02,4)-SB(I,03,4)*SB(I,02,4))*0.01 &
                + (S(NPT,I,03,5)*S(NPT,I,02,5)-SB(I,03,5)*SB(I,02,5))*0.01 &
                + (S(NPT,I,03,6)*S(NPT,I,02,6)-SB(I,03,6)*SB(I,02,6))*0.01 &
                + (S(NPT,I,03,7)*S(NPT,I,02,7)-SB(I,03,7)*SB(I,02,7))*0.01 &
                )*0.001
            ELSE
                A(NPT,I,24,2) = AB(I,24,2) + ( &
                (S(NPT,I,57,1)*S(NPT,I,50,1)-SB(I,57,1)*SB(I,50,1))*0.01 &
                +(S(NPT,I,57,2)*S(NPT,I,50,2)-SB(I,57,2)*SB(I,50,2))*0.01 &
                +(S(NPT,I,57,3)*S(NPT,I,50,3)-SB(I,57,3)*SB(I,50,3))*0.01 &
                +(S(NPT,I,57,4)*S(NPT,I,50,4)-SB(I,57,4)*SB(I,50,4))*0.01 &
                +(S(NPT,I,57,5)*S(NPT,I,50,5)-SB(I,57,5)*SB(I,50,5))*0.01 &
                +(S(NPT,I,57,6)*S(NPT,I,50,6)-SB(I,57,6)*SB(I,50,6))*0.01 &
                +(S(NPT,I,57,7)*S(NPT,I,50,7)-SB(I,57,7)*SB(I,50,7))*0.01 &
                )*0.001
            END IF
        !--      ************************        |   ACCUMULATED MODEL CROP CSRC
        !--      TOTAL CROP CASH RECEIPTS        |01 OTHER CROP CASH RECEIPTS
        !--      ************************
            A(NPT,I,02,2) = A(NPT,I,03,2)+XA(I,01,2)
        !--      *****************************   |   ACCUMULATED MODEL LVSK CSRC
        !--      TOTAL LIVESTOCK CASH RECEIPTS   |04 OTHER LIVESTOCK CASH REC.
        !--      *****************************
            A(NPT,I,09,2) = A(NPT,I,10,2)+XA(I,04,2)
        !--      *******************             |02 CROP CASH RECEIPTS
        !--      TOTAL CASH RECEIPTS             |09 LIVESTOCK CASH RECEIPTS
        !--      *******************             |08 OTHER CASH INCOME
            A(NPT,I,15,2) = A(NPT,I,02,2)+A(NPT,I,09,2) !+XA(I,08,2) !now other cash income is added in 'total gross income'
        !--      *******************************************
        !--      TOTAL CASH RECEIPTS AND GOVERNMENT PAYMENTS
        !--      *******************************************
        !--                                     |15 TOTAL CASH RECEIPTS
        !--                                     |20 TOTAL GOVERNMENT PAYMENTS

            A(NPT,I,21,2) = A(NPT,I,15,2)+A(NPT,I,20,2)
        !--      ****************                |20 INDEX OF LIVESTOCK PRICES
        !--      NON-MONEY INCOME
        !--      ****************

            A(NPT,I,16,2) = (A(NPT,I,20,3)/AB(I,20,3))*AB(I,16,2)

        !--      *********************           |21 TOTAL CASH REC. & GOV'T PAY
        !--      REALIZED GROSS INCOME           |16 NON-MONEY INCOME
        !--      *********************

            A(NPT,I,22,2) = A(NPT,I,21,2)+A(NPT,I,16,2)+XA(I,08,2)
        !--      **********************          |24 PRICES PAID FOR FEED INDEX
        !--      LIVESTOCK FEED EXPENSE          |05 LIVESTOCK PRODUCTION UNITS
        !--      **********************

            A(NPT,I,07,2) = (A(NPT,I,24,3)/AB(I,24,3))*(A(NPT,I,05,2)/AB(I,05,2)) &
            * AB(I,07,2)
        !--      ***************************     |20 INDEX OF LIVESTOCK PRICES
        !--      PURCHASED LIVESTOCK EXPENSE     |05 LIVESTOCK PRODUCTION UNITS
        !--      ***************************

            A(NPT,I,08,2) = (A(NPT,I,20,3)/AB(I,20,3))*(A(NPT,I,05,2)/AB(I,05,2)) &
            * AB(I,08,2)
        !--      *********************************** | 23 REALIZED NET INCOME
        !--      OTHER AND FIXED PRODUCTION EXPENSES
        !--      ***********************************

            A(NPT,I,14,2) = AB(I,14,2) * (1 + 0.05 * (A(NPT,L,23,2)-AB(L,23,2)) &
            /AB(L,23,2))
        !--      *************************       |14 OTHER PRODUCTION EXPENSES
        !--      TOTAL PRODUCTION EXPENSES       |01 MODEL CROP VARIABLE EXPENSES
        !--      *************************       |07 PURCHASED FEED EXPENSE
        !--                                     |08 PURCHASED LIVESTOCK EXPENSE

            A(NPT,I,12,2) = A(NPT,I,14,2)+A(NPT,I,01,2)+A(NPT,I,07,2)+A(NPT,I,08,2)
        !--      ***********************************      |06 TOTAL VALUE OF PRODUCTION
        !--      ValProd + DefPay + ContPay - VarExp      |17 TOTAL DEFICIENCY PAYMENTS
        !--      ***********************************      |05 TOTAL CONTRACT PAYMENTS
        !--                                              |01 TOTAL VARIABLE EXPENSES
        !--
            A(NPT,I,28,2) = A(NPT,I,6,2) + A(NPT,I,20,2) - A(NPT,I,1,2)!+ANPV(I)         !REPLACE A(NPT,I,17,20) WITH A(NPT,I,20,2)
        !--      *******************             |22 REALIZED GROSS INCOME
        !--      NET REALIZED INCOME             |12 TOTAL PRODUCTION EXPENSES
        !--      *******************

        !c         A(NPT,I,23,2) = A(NPT,I,22,2) - A(NPT,I,12,2)
        !--    Now add switchgrass and residue returns
            A(NPT,I,39,2) = ANPV(I,9)+ANPV(I,10)+ANPV(I,11)+ANPV(I,16)      & !THIS IS BIOMASS CONTRIBUTION !
            +ANPV(I,17) + EN(NPT,I,10,1)+EN(NPT,I,10,5)    & !CORN AND WHEAT NET PROFIT
            + EN(NPT,I,10,2)+EN(NPT,I,10,3)+EN(NPT,I,10,4) !SORGH OATS BARLEY TOO
            A(NPT,I,23,2) = A(NPT,I,22,2) - A(NPT,I,12,2) + A(NPT,I,39,2)  !NET FARM INCOME WITH BIOMASS!
            A(NPT,I,38,2) = A(NPT,I,28,2)            !THIS IS NET FARM INCOME WITHOUT BIOMASS CROP INCOME!! FOR REPORTING
            A(NPT,I,36,2) = A(NPT,I,28,2) + A(NPT,I,39,2)

        !c         write(*,*)a(i,23,2),anpv(i),'netrealized','biomass'
        !c         write(*,*)a(i,28,2),'val-exp'
        !c         write(*,*)a(i,37,2),'biomass'
        !c         write(*,*)a(i,36,2),'val-exp+biomass',i
        !c         pause
            IF(INDEX(87)==1)THEN
                A(NPT,I,38,2) = A(NPT,I,28,2) - AB(I,28,2)
                A(NPT,I,39,2) = A(NPT,I,39,2) - AB(I,37,2)
                A(NPT,I,36,2) = A(NPT,I,36,2) - AB(I,36,2)
            ENDIF
        !--      We want to print deficiency payments in a per crop year basis so
        !--      we use the following statement to accomplish this without affecting
        !--      net farm income calendar year calculations
        !        DO K=1,NCROPS
        !           C(NPT,I,20,K) = SMDFPY(I,K)
        !           B(I,20,K) = BASECP(I,02,K)
        !         END DO
        END DO    ! End of I Do Loop
        RETURN
        END SUBROUTINE MDLINC

     SUBROUTINE NPVALUE    !updated 2021
        IMPLICIT NONE

        CHARACTER(34) :: NPVEXAMPLE
        CHARACTER(50) :: NPVPRINT
        REAL :: RESRED,RESINCENT
        REAL :: LOWFLOW
        INTEGER :: IIYEAR(41)

!EIA add
        INTEGER IYEAR1,IPLAN,NCROPS,II,IB,IP,III,  NYRSIM,  ISTART,  IEND, IYR
       REAL REVENUES,FLOW,SHRCST,HRVCST,PENNYYIELD, CORNYIELD, SOYYIELD, CORNCOST, SOYCOST, PENNYCOST, TOTALPENNYCOSTS

      INTEGER FILE_MGR
      EXTERNAL FILE_MGR
      CHARACTER*25 FNAME
      LOGICAL NEW
      INTEGER IUNIT1,IUNIT2,FILEUNIT
    !--
    !C      WRITE(*,*)LANDRENT(I,CTY),LANDRENT(1,CTY),I,CTY,'LR'
    !--
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !-- *****WRITE NPV NUMBERS FOR OAK RIDGE FOR CORNELL RESEARCH*******
    !--
    !C      IF(INDEX(106).EQ.3)THEN
    !C   42 FORMAT(35A)
    !C   43 FORMAT(I4,';'A8';',I4,';',F6.0,';',F4.0,';',I3,';',I3,';',I3,';
    !C     1',F20.4,';',F20.4,';',F20.4,';',F20.4,';',F20.4,';',F20.4,';'
    !C     1,F20.4,';',F20.4,';',F20.4,';',F20.4,';',F20.4,';',F20.4,';'
    !C     1,F20.4,';',F20.4,';',F20.4,';',F20.4,';',F20.4,';',F20.4,';'
    !C     1,F20.4,';',F20.4,';',F20.4,';',F20.4,';',F20.4,';',F20.4,';'
    !C     1,F20.4,';',F20.4,';',F20.4)
    !--
    !C      NPVPRINT = 'output/'//EXTT//'OUTnpv.TXT'
    !C      OPEN(UNIT=56,FILE = NPVPRINT)
    !--
    !C      IF(I.EQ.3.AND.CTY.EQ.1)THEN
    !C      WRITE(56,42)'YEAR;','SIM#;','COUNTY;','FIPS;','POLY;','CROP;',
    !C     1'TILLAGE;','ROT_YEAR;','RETURNS;','MATURE_YIELD;','PERC_MATURE;',
    !C     1'PRICE;','TOTCOST;','LANDRENT;'
    !C      ENDIF
    !C      ENDIF
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !--
    !      WRITE(*,*)'IN NPVALUE ILOOP = ',ILOOP
        IYEAR1 = INDEX(30)      ! FIRST YEAR OF SIMULATION
    !--
    !--
        NYRSIM = INDEX(1)
        ISTART = INDEX(30)-INDEX(27)+3
        IEND = NYRSIM+(INDEX(30)-INDEX(27))+2
        IYR = INDEX(30) - 2
    !--
        DO III=ISTART-2,IEND
            IIYEAR(III) = IYR
            IYR = IYR + 1
        END DO
    !--
    !--
    !--

        FLOW = 0
        LOWFLOW=100000
        REVENUES = 0
    !c      DRATE = 0.065           ! DISCOUNT RATE
        NCROPS = INDEX(2)       ! NUMBER OF CROPS
        IPLAN = 100 !30 !20              ! LENGTH OF PLANNING PERIOD
        IF(INDEX(1)>INDEX(28)) THEN
            IB = INDEX(1)
        ELSE
            IB = INDEX(28)
        END IF
        DO K = 1,NCROPS
            DRATE = DRATEK(I,K)   !discount rate here now!!
            IF(CFIXED(I,9,K)>0) THEN
                C(NPT,I,9,K) = CFIXED(I,9,K)         !CHANGED FROM BELOW 12/12/09
            !c            DO IP = I , IB + 2
            !c               C(NPT,IP,9,K) = CFIXED(IP,9,K)
            !c            END DO
            END IF
        !--
        !--
            DO T=1,3                                                   !TILLAGE LOOP
            !--
            !--      ***FIGURE CARBON INCENTIVE LEVEL per acre***
            !--
            !--                                                                !$ PER ACRE =
                INCENT(1,K,T,CTY) = (CARBINCT(I)*0.9) *                 & !$ PER TON *                     !0.9 = GROSS TO NET INCENTIVE PRICE...ASSUME 10% FOR MM&V OF CARBON PROGRAM.
                ( BCARB(1,K,CTY) *                                & !TONS PER ACRE BASE *
                ( CARBRATE(K,T)              & ! * RESRED          !(RATE OF GAIN * ADJUSTMENTFACTOR) = TONS GAIN PER ACRE BY CROP,TILLAGE AND COUNTY     (
                * ( -.5938*LOG(BCARB(1,K,CTY)*.2471)+1.65224)     & !ADJUST CARBON RATE BY ADJUSTMENT FACTOR EQUATION (FUNCTION(BASE SOIL CARBON)
                ) )                                             !SEE METHODOLOGY IN CHAD'S DISSERTATION
            !--
                IF(INDEX(76) == 0 .AND. (K >= 9 .AND. K <= 11))THEN  !IF BIOMASS DOESNT RECEIVE CARBON INCENTIVES
                    INCENT(1,K,T,CTY) = 0.0
                ELSE
                    CONTINUE    !KEEP DEFINED VALUE FROM ABOVE
                ENDIF
            !--
                IF(K == 14 .AND. INDEX(80) == 1)THEN   ! add afforestation
                !c              IF(EAST(CTY).EQ.1)THEN
                    INCENT(1,K,T,CTY) = 0.0 !1.1 !PASTRENT(CTY)  !50 !  (CARBINCT(I)*0.9)         ! below ground + 90% carbon price * MT carbon in the afforest wood growth    !NASA15_SET TO ONE TO MAKE IT A PROFITABLE OPTION...SO THAT ANY NON-PROFITABLE LAND WILL SWITCH IN.
                !    1                          *(CYX(25,K,T,CTY)*2000/2200*0.5)
                !c              ENDIF
                ENDIF
            !--
                IF(INDEX(78) == 0)THEN         !IF NO CARBON INCENTIVES TO ANY CROP (LIKE NOTILL)
                    INCENT(1,K,T,CTY) = 0.0
                ENDIF
            !--
            !--      ***DETERMINE IF EITHER HARVEST RESIDUES OR TAKE CARBON INCENTIVE***
            !--
                IF(INCENT(1,K,T,CTY) >= RCNT(9,K,T,CTY))THEN
                    RESINCENT = 0.0                 !IF CARBON CREDIT HIGHER, THEN DON'T HARVEST RESIDUES        !CHECK IN RESDCNTY.FOR TO MAKE SURE NOT HARVESTING IF TAKING THIS!
                ELSE
                    RESINCENT = RCNT(9,K,T,CTY)     !IF RESIDUE PROFIT HIGHER, THEN HARVEST RESIDUES
                    INCENT(1,K,T,CTY) = 0.0         !AND DON'T PARTAKE IN CARBON CREDITS
                ENDIF
            !--               **********
            !--
            !--
                NPV(NPT,I,K,T,CTY) = 0.0
                II = 0
                DO INPV = 1,IPLAN
                    II = INPV + I - 1
                    IF(INDEX(87) == 1) THEN
                        IF(K == 9 .OR. K == 15)THEN                             !SWITCHGRASS OR SWEET SORGHUM
                            PRIC(K,CTY) = C(NPT,I,9,K)*CYX(3,K,T,CTY)           !IF SWITCHGRASS USE CURRENT PRICE
                            IF(NEWPRC(NPT,I,CTY).GT.0.0) PRIC(K,CTY)=NEWPRC(NPT,i,cty) !Update from UT 2019

                        ELSEIF(K == 10 .OR. K == 11 .OR. K == 16 .OR. K == 17)THEN
                            PRIC(K,CTY) = C(NPT,I,9,K)
                            IF(NEWPRC(NPT,I,CTY).GT.0.0) PRIC(K,CTY)=NEWPRC(NPT,i,cty) !Update from UT 2019
                        ELSE
                            PRIC(K,CTY) = C(NPT,I-1,9,K)*CYX(3,K,T,CTY)
                        ENDIF
                    ELSE
                        PRIC(K,CTY) = B(I-1,9,K)*CYX(3,K,T,CTY)
                    END IF
              !  ***SET CROP PRICE TO ZERO IF SIM.INS SWITCH SET TO ZERO*** Update from UT 2019
            IF(INDEX(108).EQ.0) PRIC(9,CTY)=0.0 !SWITCHGRASS [108]
            IF(INDEX(109).EQ.0) PRIC(10,CTY)=0.0!POPLARS [109]
            IF(INDEX(110).EQ.0) PRIC(11,CTY)=0.0!WILLOWS [110]
            IF(INDEX(111).EQ.0) PRIC(15,CTY)=0.0!SWEET SORGHUM[111]
            IF(INDEX(112).EQ.0) PRIC(16,CTY)=0.0!MISCANTHUS [112]
            IF(INDEX(113).EQ.0) PRIC(17,CTY)=0.0!ENERGY CANE [113]
!             ********************************************************
                    CY(5,K,T,CTY)=PRIC(K,CTY) !FOR COUNTY LEVEL PRICE OUTPUT
                !--         Select higher of Price expectation or Marketing Loan Rate
                    IF(X(I,11,K) > PRIC(K,CTY)) THEN
                        PRIC(K,CTY) = X(I,11,K)
                    END IF
                !--
                    IF(K >= 9 .AND. K <= 11) THEN                                         !switchgrass, poplars, willows
                        IF(I >= 4) THEN


                            REVENUES = (CYX(25,K,T,CTY)*CMX(INPV,22,K-8,CTY) )   & !yeild now here
                            * PRIC(K,CTY)
                            IF(K == 10 .AND. INDEX(115) == 1)REVENUES=REVENUES/RRR(K,CTY) !Update from UT 2019
                            IF(K == 11 .AND. INDEX(115) == 1)REVENUES=REVENUES/RRR(K,CTY)   !willows on incremental plantings so 1/4 of yield (carries thru to revenue (Update from UT 2019)

                        !--
                        !--
                            IF(K == 9)THEN
                                FLOW = REVENUES - (CMX(INPV,21,K-8,CTY)+LANDRENT(I,CTY))         !J=20=TOTAL COSTS PER ACRE !LANDRENT ADDED TO COSTS FOR COST OF LAND
                            ELSEIF(K == 10)THEN
                                IF(INDEX(115) == 1)THEN
                                    IF(INPV < RRR(K,CTY))THEN
                                        FLOW = REVENUES - (CMX(INPV,21,K-8,CTY)+ &
                                        LANDRENT(I,CTY)*(INPV/RRR(K,CTY)))         !ONLY PLANTING 1/RRR EVERY YEAR, SO ONLY PAY RENT ON WHAT PLANTED, LEASE OUT THE REST
                                    ELSE
                                        FLOW = REVENUES - (CMX(INPV,21,K-8,CTY)+ &
                                        LANDRENT(I,CTY)*(RRR(K,CTY)/RRR(K,CTY)))         !BUT BY THE RRR YEAR, ALL PLANTED SO PAY ALL RENT
                                    ENDIF
                                ELSE
                                    FLOW = REVENUES - (CMX(INPV,21,K-8,CTY)+ &
                                    LANDRENT(I,CTY))
                                ENDIF
                            ELSEIF(K == 11)THEN
                                IF(INDEX(115) == 1)THEN
                                    IF(INPV < RRR(K,CTY))THEN !update from UT 2019
                                        FLOW = REVENUES - (CMX(INPV,21,K-8,CTY)+ &
                                        LANDRENT(I,CTY)*(INPV/RRR(K,CTY)))         !ONLY PLANTING 1/4 EVERY YEAR, SO ONLY PAY RENT ON WHAT PLANTED, LEASE OUT THE REST
                                    ELSE
                                        FLOW = REVENUES - (CMX(INPV,21,K-8,CTY)+ &
                                        LANDRENT(I,CTY)*(RRR(K,CTY)/RRR(K,CTY)))         !BUT BY THE FOURTH YEAR, ALL PLANTED SO PAY ALL RENT
         ENDIF
                                ELSE
                                    FLOW = REVENUES - (CMX(INPV,21,K-8,CTY)+ &
                                    LANDRENT(I,CTY)  )
                                ENDIF
                            ENDIF
                        !--
                        !           if(cty.eq.1001.and.k.eq.10.and.i.eq.8)then
                        !                              write(*,*)inpv,pric(inpv,k,cty)
                        !               write(*,*)flow,revenues, cmx(inpv,21,k-8,cty)
                        !               write(*,*)yield(inpv,k,t,cty),cyx(25,k,t,cty),
                        !     1                  cmx(inpv,22,k-8,cty)

                        !           endif
                        !-- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        !C      IF(INDEX(106).EQ.3)THEN
                        !C               IF(I.EQ.19.AND.K.EQ.9.AND.T.EQ.1)THEN
                        !C                WRITE(56,43)IIYEAR(I),EXT,
                        !C     1               CTY,CY(8,K,1,CTY),CY(9,K,1,CTY),K,T,INPV,
                        !C     1             FLOW,CYX(25,K,T,CTY),CMX(INPV,22,K-8,CTY),
                        !C     1            PRIC(INPV,K,CTY),CMX(INPV,21,K-8,CTY),
                        !C     1               LANDRENT(I,CTY)
                        !C               ENDIF
                        !C      ENDIF
                        !-- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        !c          if(cty.eq.1111.and.k.eq.9)then
                        !c              write(*,*)'switch',cmx(inpv,21,k-8,cty),landrent(i,cty)
                        !c     1                   ,inpv,i,flow
                        !c          endif

                        ELSE
                            FLOW = 0.0
                        END IF
                    !c            if(cty.eq.2.and.k.eq.9.and.t.eq.1)then
                    !c            write(*,*)cmx(inpv,22,k-8,cty),'yield',inpv,i,'SWTCHGRS'
                    !c            write(*,*)cmx(inpv,21,k-8,cty),'costs',landrent(i,cty),
                    !c     1                'landrent'
                    !c            endif
                    !--
                    ELSEIF(K == 16 .OR. K == 17)THEN !MISCANTHUS OR E.CANE
                        IF(I >= 4) THEN
                        !c               YIELD(INPV,K,T,CTY)=CYX(25,K,T,CTY)*CMX(INPV,22,K-12,CTY)
                            REVENUES = (CYX(25,K,T,CTY)*CMX(INPV,22,K-12,CTY) )    & !yield now in here
                            * PRIC(K,CTY)
                            FLOW = REVENUES - (CMX(INPV,21,K-12,CTY)+LANDRENT(I,CTY))
                        !              if(cty.eq.1111.and.k.eq.16)then
                        !              write(*,*)'miscan',cmx(inpv,21,k-12,cty),landrent(i,cty)
                        !     1                  ,inpv,i,flow
                        !              endif

                        !               if(k.eq.16.and.cy(1,k,t,cty).ge.0.0)then
                        !          write(*,*)cty,cyx(25,k,t,cty),cmx(inpv,22,k-12,cty)
                        !          write(*,*)flow,revenues,cmx(inpv,21,k-12,cty),landrent(i,cty)
                        !               endif

                        ELSE
                            FLOW = 0.0
                        END IF
                    !--
        
      ELSEIF(K.EQ.15)then        !OILSEEDS/COTTON/SOY ROTATIONS !USED K=15 THAT WAS SWEET SORGHUM

!C--             ***Yield ***
                  PENNYYIELD = CYX(25,15,T,CTY)* 0.5    !1/2 acre of yield                 
                  IF(CRN(I,5,K,T).GT.0.0)THEN      !ONLY GIVE CORN A YIELD IF PENNYCRESS HAS A PRICE AND IS AN OPTION  17+1=18(PENNYCRESS) 17+2=19(CAMELINA) 17+3=20(CARINATA)
                   CORNYIELD = CYX(25,7,1,CTY)*(1-COTTONDOCK(T,CTY))*0.5 !CYX(39,18,2,CTY))*0.5    ! 1/2 acre of yield REDUCED BY 'DOCK' (CYX(22,18,2...IS THE DOCK READ IN READBIO
                   SOYYIELD  = CYX(25,6,1,CTY)*(1-SOYDOCKCT(T,CTY))*0.5  !CYX(39,18,3,CTY))*0.5    !1/2 ACRE OF SOY YIELD REDUCED BY 'DOCK'                 
                    ENDIF
!C--             ***COSTS**           CORNCOST,PENNYCOST,TOTALPENNYCOSTS
                  CORNCOST = CYX(23,7,1,CTY) * 0.5 !1/2 ACRE OF COSTS
                  SOYCOST  = CYX(23,6,1,CTY) * 0.5
                  PENNYCOST = CYX(23,15,T,CTY) * 0.5 !1/2 ACRE OF COSTS
                  
                  TOTALPENNYCOSTS = CORNCOST+PENNYCOST+SOYCOST+ LANDRENT(I,CTY)
!C--             ***GROSS REVENUE***
               REVENUES =  (CORNYIELD * PRIC(7,CTY)) + &
                          (SOYYIELD  * PRIC(6,CTY)) + &
                          (PENNYYIELD * CRN(I,5,K,T)) !C(I,9,17+T)) !PRIC(18,CTY))   USE PRICES AT NATIONAL LEVEL K=18(P) K=19(CAMELINA) K=20(CARINATA)
!C--            ***NET REVENUE***
                  FLOW = REVENUES - TOTALPENNYCOSTS   
                  IF(CYB(1,7,1,CTY).EQ.0.0) FLOW=0.0        !rotation can only come in if there is cotton and soy planted in baseline !maybe change to cotton in baseline and soy yield and cost     
                  IF(CRN(I,5,K,T).EQ.0.0)FLOW=0.0  !rotation can only come in if there is an oilseed price offered

                    ELSEIF (K == 18) THEN !PENNYCRESS
                        if (t.eq.1) then !update from UT 2019
                    !--             ***Yield ***
                        PENNYYIELD = CYX(25,18,1,CTY)* 0.5    !1/2 acre of yield
                        IF(CRN(I,5,K,T) > 0.0)THEN      !ONLY GIVE CORN A YIELD IF PENNYCRESS HAS A PRICE AND IS AN OPTION
                    CORNYIELD = CYX(25,1,1,CTY)*(1-CORNDOCK(T,CTY))*0.5 !CYX(39,18,2,CTY))*0.5    ! 1/2 acre of yield REDUCED BY 'DOCK' (CYX(22,18,2...IS THE DOCK READ IN READBIO !update 2021
                    SOYYIELD  = CYX(25,6,1,CTY)*(1-SOYDOCK(T,CTY))*0.5  !CYX(39,18,3,CTY))*0.5    !1/2 ACRE OF SOY YIELD REDUCED BY 'DOCK'                 
                    ENDIF
                    !--             ***COSTS**           CORNCOST,PENNYCOST,TOTALPENNYCOSTS
                        CORNCOST = CYX(23,1,1,CTY) * 0.5 !1/2 ACRE OF COSTS
                        SOYCOST  = CYX(23,6,1,CTY) * 0.5
                        PENNYCOST = CYX(23,18,T,CTY) * 0.5 !1/2 ACRE OF COSTS

                        TOTALPENNYCOSTS = CORNCOST+PENNYCOST+SOYCOST &
                        + LANDRENT(I,CTY)
                    !--             ***GROSS REVENUE***
                        REVENUES =  (CORNYIELD * PRIC(1,CTY)) + &
                        (SOYYIELD  * PRIC(6,CTY)) + &
                        (PENNYYIELD *  CRN(I,5,K,T))!C(I,9,17+T)) !PRIC(18,CTY))   USE PRICES AT NATIONAL LEVEL K=18(P) K=19(CAMELINA) K=20(CARINATA)
                    !--            ***NET REVENUE***
                        FLOW = REVENUES - TOTALPENNYCOSTS
			!update 2021
                  IF(CYB(1,1,1,CTY).EQ.0.0) FLOW=0.0   !rotation can only come in if there is corn and soy planted in baseline   
                  IF(CRN(I,5,K,T).EQ.0.0)FLOW=0.0  !rotation can only come in if there is an oilseed price offered
                        ENDIF ! end t if
                    !--
                    !--
                    !--
                    ELSE   ! ** ALL CONVENTIONAL CROPS *** & sweet sorghum
                    !--             ***Yield Calculations for no till yield change over time***
                        IF(T == 3)THEN
                            YIELD(K,T,CTY) = CYX(25,K,3,CTY) + & !update from UT 2019
                            CYX(25,K,3,CTY) * ( &
                            (-7.0988)+10.0610*(1-EXP(-0.4610*         & !BASED ON ANALYSIS OF FIELD EXPERIMENTS
                            (INPV-1)) ) &
                            ) /100                                        !TRIS WEST SUMMER 2006
                        ELSE
                            YIELD(K,T,CTY) = CYX(25,K,T,CTY)
                        ENDIF
                    !--              ********************************************************
                    !C               YIELD(INPV,K,T,CTY) = CYX(25,K,T,CTY)
                        IF(K==8)YIELD(K,T,CTY)=YIELD(K,T,CTY)/100
                    !c               IF(INDEX(92)==0)THEN
                        COST(K,T,CTY) = CYX(23,K,T,CTY)+LANDRENT(I,CTY)
                    !c               ELSE
                    !c                  COST(INPV,K,T,CTY) = CYX(24,K,T,CTY)+LANDRENT(I,CTY)  !cash cost
                    !c              ENDIF
                    !--
                        REVENUES = YIELD(K,T,CTY) * PRIC(K,CTY)

                        IF(K == 1 .OR. K == 5)THEN
                            FLOW = REVENUES - COST(K,T,CTY) &
                            + RESINCENT                      !RCNT(10,K,T,CTY)                                  !CORN AND WHEAT RESIDUES net returns ADDED
                        ELSE
                            FLOW = REVENUES - COST(K,T,CTY)
                        ENDIF
                    !--
                    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                    !c                  IF(I.EQ.19.AND.K.EQ.1.AND.T.EQ.1)THEN
                    !c                WRITE(56,43)IIYEAR(I),EXT,
                    !c     1               CTY,CY(8,K,1,CTY),CY(9,K,1,CTY),K,T,INPV,
                    !c     1             FLOW,CYX(25,K,T,CTY),1.0,
                    !c     1            PRIC(INPV,K,CTY),CYX(23,K,T,CTY),
                    !c     1               LANDRENT(I,CTY)
                    !c              ENDIF
                    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                       ! if(k == 1 .AND. cty == 675)then
                        !         write(*,*)cost(inpv,k,t,cty),'innpvalue',i,t,inpv
                        !           write(*,*)yield(inpv,k,t,cty),pric(inpv,k,cty),revenues
                        !           write(*,*)flow,i,inpv,t
                       ! endif
                    !--
         ENDIF
                !--
                !--        ******SET K=14 ALTERNATIVE LAND MANAGEMENT AFFOREST OR PASTURE FLOW LESS THAN LOWEST OTHER FLOW(BY SOME PERCENTAGE********
                !--                         THIS MAKES PASTURE NOT COME IN IN BASELINE, BUT IF CHANGES TO RETURNS OCCUR, COULD SEE CROPLAND CONVERT
                !--

                !--
                    IF(K == 14 .AND. T == 1)THEN
                        FLOW= PASTRETRN(I,CTY)!+ 10
                    !c              if(cty.eq.645)WRITE(*,*)PASTRETRN(I,CTY),I,'PASTRETRN',CTY
                    ENDIF
                !--
                !--     **********************************************************************************************************
                !--
                !--
                    FLOW = FLOW &
                    + INCENT(1,K,T,CTY)                                 & ! INCENTIVE PER ACRE FOR TILLAGE SYSTEM AND AFFORESTATION (1/7/07)
                    - INCENT(6,K,T,CTY)                                 & ! TOTAL ADDITIONAL COSTS FROM CARBON PRICE  !COMPUTED IN COSTCHG.FOR
                    - INCENT(11,K,T,CTY)                               ! TOTAL ADDITIONAL COSTS FROM ENERGY PRICE INCREASE
                !--
                    NPV(NPT,I,K,T,CTY) = NPV(NPT,I,K,T,CTY) + FLOW/(1+DRATE)**INPV ! this adds 20 years up.
                   ! if (k.eq.1) write(658,*) 'npv=',NPV(NPT,I,K,T,CTY), FLOW,DRATE,INPV,curiyr,t,cty
                !--
                !--     **Restrict Biomass Crops to years defined in sim.ins**
                    IF(IIYEAR(I) < YRHERB)THEN
                        IF(K == 9 .OR. K == 15 .OR. K == 16 .OR. K == 17)THEN  !HERBACIOUS
                            NPV(NPT,I,K,T,CTY)=0.0
                        ENDIF
                    ENDIF
                    IF(IIYEAR(I) < YRWOODY)THEN
                        IF(K == 10 .OR. K == 11)THEN
                            NPV(NPT,I,K,T,CTY)=0.0
                        ENDIF
                    ENDIF
                !--
                !--
                !--        !THIS IS TO AVOID VERY SMALL CHANGES IN NPV THROWING OFF THE SOLUTION (THIS HAPPENS IF COSTS OF PRODUCTION IN THE BASELINE OF TWO CROPS ARE VERY CLOSE)
                    IF(INDEX(106) == 3)THEN
                        IF(ABS(NPV(NPT,I,K,T,CTY)-NPVB(I,K,T,CTY)) <= 5.0)THEN
                            NPV(NPT,I,K,T,CTY)=NPVB(I,K,T,CTY)
         ENDIF
         ENDIF
                !--
                    CY(7,K,T,CTY) = NPV(NPT,I,K,T,CTY) * (DRATE*(1+DRATE)**INPV)/      & ! not needed anywhere else but for printout in ctyouta
                    (((1+DRATE)**INPV)-1)
                !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                !!!!!!!!!!!!!!!!!PRINT COUNTY EXAMPLE OF NPV CALCULATION!!!!!!!!!!!!
                  !!!!!!!!!!!!!!!! TD commenting out this section !!!!!!!!!!!!!!!
                !--
                
                  !  IF(CTY == 1 .AND. T == 1) THEN
                  !      IF(K == 10 .OR. K == 11)THEN
                        !--
                        !--     PRINT RESIDUE DATA BY COUNTY
                  !          78 FORMAT(32A)
                  !          79 FORMAT(I4,';'I4,';',I3,';',I3,';',F20.3,';' &
                  !          ,F20.3,';',F20.3,';',F20.3,';',F20.3,';',F20.3,';',F20.3,';' &
                  !          ,F20.3,';',F20.3,';',F20.3,';',F20.3,';',F20.3,';',F20.3,';', &
                  !          F20.3,';',F20.3,';',F20.3,';',F20.3,';',F20.3,';', &
                  !          F20.3,';',F20.3,';',F20.3,';')
                  !      !--
                  !
                  !          NPVEXAMPLE = 'output/'//EXTT//'NPVEXAMPL.TXT'
                  !      !C          IF(I.EQ.ISTART)THEN
                  !         ! IF(INPV == 1 .AND. i == 4)THEN
                  !              OPEN(UNIT=59,FILE = NPVEXAMPLE)
                  !          !--
                  !              WRITE(59,78)'YEAR;','COUNTY;','K;','ROT_YR;','NPV;', &
                  !              'CURRENT_YR_NETRETRN;','GROSS_REV;','TOTALCOSTS;','LANDRENT;', &
                  !              'YIELD;','PRICE;','MATUREYIELD;','PERCENTYIELD;'
                  !          ELSE
                  !              OPEN(UNIT=59,FILE = NPVEXAMPLE,POSITION='APPEND')
                  !          !--
                  !              WRITE(59,79)IIYEAR(I),CTY,K,INPV,NPV(NPT,I,K,T,CTY), &
                  !              FLOW,REVENUES,CMX(INPV,21,K-8,CTY), &
                  !              REVENUES-CMX(INPV,21,K-8,CTY)-FLOW,  & !LANDRENT
                  !              YIELD(K,T,CTY),PRIC(K,CTY), &
                  !              CYX(25,K,T,CTY),CMX(INPV,22,K-8,CTY)  !MATURE YIELD, % MATURE YIELD

                   !        ENDIF
                   !         CLOSE(UNIT=59)
                        !--
                        !--
                    !    ENDIF
                   ! ENDIF
                !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                !!!!!!!!!!!!!!!!!!!!!!!!!
                END DO  !end of inpv loop
            !--
            !--      **RECORD BASELINE NPVB**

            !--
            END DO         !END TILLAGE LOOP
        !--
        END DO          !END OF CROP LOOP
    !--
        234 CONTINUE
        RETURN
        END  SUBROUTINE NPVALUE

        SUBROUTINE OTHRESDCNTY
        IMPLICIT NONE

        CHARACTER(14) :: RESIDUES
        CHARACTER(11) :: CNTNAME
        CHARACTER(2) :: STNAME
        CHARACTER SK
        INTEGER :: IYYEAR(41)
        INTEGER :: JJ,KK
        !EIA add
        INTEGER :: IISTART, NCROPS, NYRSIM, ISTART, IEND, IYYR, J, HH
    !--
    !      DOUBLE PRECISION RCNTX(35,306,3200),RCNT(35,306,3200)
        IISTART = INDEX(30) - INDEX(27) + 3
        NCROPS = INDEX(2)
        POLY=INDEX(63)
        CNTY=INDEX(33)
    !--
        NYRSIM = INDEX(1)
        ISTART = INDEX(30)-INDEX(27)+3
        IEND = NYRSIM+(INDEX(30)-INDEX(27))+2
        IYYR = INDEX(30) - 2
    !--
    !--           *** RESIDUE HARVESTING CARBON DATA ***
        IF(CTY == 1)THEN
            DO CLN=1,CNTY
                DO K=2,4
                    DO T=1,3
                        DO J=1,18
                            RCNTX(J,K,T,CLN)=RCNTX(J,5,T,CLN)  !USE WHEAT AS PROXY FOR SORGHUM, OATS AND BARLEY (BUT NOW USING MUTH DATA BELOW FOR CONSTRAINTS JUNE 2011)
           END DO
           END DO
           END DO
            ENDDO
         ENDIF
    !--
    !--
    !--   START CROP LOOP
        DO K=2,4
        !--
        !--   Set Residue profit per acre to zero for each year and region (DON'T DO IT BEFORE HERE, LAG USED IN NPVALUE)
        !      REN(14,1,CRDL) = 0.0
        !      REN(14,5,CRDL) = 0.0
        !--
        !C      RCNT(11,1,4,CTY) = 0.0   !REGIONAL SUM OF RESIDUE HARVESTED TO ZERO TO SUM
        !C      RCNT(11,5,4,CTY) = 0.0
        !--
            DO T=1,4
                RCNT(10,K,T,CTY) = 0.0
                RCNT(11,K,T,CTY) = 0.0
                DO J=12,18
                    RCNT(J,K,T,CTY) = 0.0     !CARBON AND ENERGY
                END DO
            END DO
        !--
        !--
            IF((CY(2,K,1,CTY)+CY(2,K,2,CTY)+CY(2,K,3,CTY) &
            ) <= 0.0)THEN      !IF NO CORN OR WHEAT ACRES
                CONTINUE
            ELSE
            !--
                DO T=1,3
                !--
                !--      HARVESTABLE RESIDUE PER ACRE = YIELD CONVERTED TO TONS * SRG RATIO - MINIMUM THAT MUST REMAIN(FROM ROBIN)
                !--      moisture fraction must be deducted: 15.5% and 13.5%: Anthony Turhollow (2008)
                !--
                !--      TOTAL RESIDUE YIELD (WITHOUT CONSTRAINTS)
                    IF(K == 2)THEN      !SORGHUM
                        RCNT(3,K,T,CTY)=(CYX(25,K,T,CTY)*56/2000)*1*(1-.155)            !1 is stover to yield ratio, .155 in moisture fraction (Turhollow,2008)
                    ELSEIF(K == 3)THEN  !OATS
                        RCNT(3,K,T,CTY)=(CYX(25,K,T,CTY)*32/2000)*2.0*(1-.135)          !1.57 is winter wheat straw to yield ratio, .135 is moisture fraction(Turhollow,2008)
                    ELSEIF(K == 4)THEN !BARELY
                        RCNT(3,K,T,CTY)=(CYX(25,K,T,CTY)*48/2000)*1.5*(1-.135)
                    ENDIF
                !--
                !--      TOTAL POTENTIAL HARVESTABLE YIELD (WITH CONSTRAINTS)
                    IF(INDEX(83) == 1)THEN   !!!!!!!!IF USING MUTH DATA!!!!!!!!
                        IF(INDEX(84) == 1)THEN
                            J=2                  !HIGH YIELD
                        ELSE
                            J=1                  !BASE CASE YIELD
                        ENDIF
                        RCNT(6,K,T,CTY) = RCNT(3,K,T,CTY)- &
                        MAX(MUTH(I,J,K,T,CTY),(RESEFF(I,5,5)*RCNT(3,K,T,CTY)))   !AMOUNT THAT MUST REMAIN MAX(MUTHDATA,WHEAT HARVE TECH CONSTRAINT)
                    ELSE
                        RCNT(6,K,T,CTY) = RCNT(3,K,T,CTY) * .31     !ASSUME 69% OF RESIDUES MUST REMAIN (PERLACK, JUNE 09)

                    ENDIF
                !--
                    IF(RCNT(6,K,T,CTY) <= 0.0)RCNT(6,K,T,CTY)=0.0   !IF NEGATIVE AVAILABLE, SET TO ZERO
                !--
                !--      ASSIGN YIELD ADJUSTED COST OF PRODUCTION FOR SORGHUM,BARLEY AND OATS
                    DO HH=1,50                                           !NUMBER OF DIFFERENT COSTS BASED ON YIELD/AC
                        IF(RCNT(6,K,T,CTY) <= CSX(10,HH,1,K))THEN           !IF HARVESTABLE YIELD IS LESS THAN OR EQUAL TO YIELD IN ONE OF 50 COST STRUCTURES

                                 RCNT(7,K,T,CTY)=CSX(10,HH,10,K)+CSX(14,1,10,K) !RUS...RESTOF US. 10       !EIA16 COMMENTED ALL REGIONS AND ONLY USING 'REST OF COUNTRY ;region change version
                                JJ=10
                                GOTO 44

         ENDIF
           END DO
                !--
                    44 CONTINUE
                !--
                    RCNT(8,K,T,CTY)=EN(NPT,I,3,5)                            !national PRICE PER TON READ INTO WHATIF transfer to regions!!!!!!  USE WHEAT AS PROXY
                    !update from UT 2019
                    IF (NEWPRC(NPT,I,CTY).GT.0.0) RCNT(8,K,T,CTY)=NEWPRC(NPT,I,CTY) !for biomass regional module
                    If (INDEX(107)==0) RCNT(8,k,t,cty)=0.0 !if not including residues
                !--
                !--
 !!TD This is outside the HH loop. check with CHAD               
                !--      FIGURE GROWER PAYMENT (PRICE PER DT - COST PER DT)
 !!TD                   IF(RCNT(8,K,T,CTY) > CSX(10,HH,JJ,K))THEN                !nutrition replacement costs are $25
!!TD                       RCNT(20,K,T,CTY)=RCNT(8,K,T,CTY)- CSX(10,HH,JJ,K) !(RCNT(7,K,T,CTY)-20)
!!TD                    ENDIF
                !--
                !--      POTENTIAL RETURNS PER ACRE IF HARVEST
                    RCNT(9,K,T,CTY) = (RCNT(8,K,T,CTY)*RCNT(6,K,T,CTY)) &
                    - (RCNT(7,K,T,CTY)*RCNT(6,K,T,CTY))

                    ! write(666,*) 'debug costs',curcalyr,k,t,cty,RCNT(9,K,T,CTY),RCNT(8,K,T,CTY),RCNT(7,K,T,CTY),RCNT(6,K,T,CTY)
                !--
                !--      RETURNS PER ACRE OF HARVESTED
                    IF (RCNT(9,K,T,CTY) > 0.0) THEN
                        RCNT(10,K,T,CTY)=RCNT(9,K,T,CTY)
                    END IF
                    IF(INCENT(1,K,T,CTY) > 0.0)RCNT(10,K,T,CTY)=0.0        !IF TAKING CARBON CREDIT, THEN CANNOT HARVEST      !!
                    !--
                    !--      PROFITABLY HARVESTED PRODUCTION IN COUNTY(BY TILLAGE)
                        IF(RCNT(9,K,T,CTY) > 0.0)THEN
                            RCNT(11,K,T,CTY) = RCNT(6,K,T,CTY)*CY(2,K,T,CTY)
                            RCNT(19,K,T,CTY) = CY(2,K,T,CTY)  !CAPTURE HARVESTED ACRES FOR RESIDUES
                        ENDIF
                        IF(INCENT(1,K,T,CTY) > 0.0)RCNT(11,K,T,CTY)=0.0        !IF TAKING CARBON CREDIT, THEN CANNOT HARVEST      !!
                        !--
                        !--      HARVESTED PRODUCTION IN COUNTY (ALL TILLAGES)
                            RCNT(11,K,4,CTY) = RCNT(11,K,4,CTY)+RCNT(11,K,T,CTY)
                        !--
                        !--      CARBON AND ENERGY IN COUNTY
                            DO J=12,18
                                RCNT(J,K,T,CTY) = RCNTX(J,K,T,CTY)*RCNT(11,K,T,CTY)   !PER DT * DT
                            !--
                            !--       CARBON AND ENERGY IN COUNTY (ALL TILLAGES)
                                RCNT(J,K,4,CTY) = RCNT(J,K,4,CTY) + RCNT(J,K,T,CTY)   !SUM OVER ALL TILLAGES
                            !--
                            END DO
                        !--
                        ENDDO !T LOOP
                    !--
                    !--
                    ENDIF
                !--
                ENDDO   !END K LOOP
            !--
            !--
                RETURN
                END SUBROUTINE OTHRESDCNTY

            !     Last change:  CH   29 Jun 2009    4:38 pm
                SUBROUTINE OUTFRMLP
                IMPLICIT NONE

                REAL,DIMENSION(165) :: HOLDARP = 0.0,SORTRET=0.0,ACADJ=0.0
                REAL :: TOTALC(3111),TOTALB(3111),DIFPAREA
                INTEGER,DIMENSION(18) :: KKSORT
                !EIA add
                INTEGER IK,NCROPS,IYEAR1,KT,IP
                REAL :: XTBLAH, XTBLAHB, XTCYBLAH, NOTILLADD, AAMIN
            !--
            !--   *****************************************************************************
            !--   This subroutine captures the solution values from LP's and assigns them
            !--   Also computes BSHIFTS in baseline to bring values back to baseline
            !--   The subroutine is called from RMAIN
            !--   *****************************************************************************
                NCROPS=INDEX(2)
            !--   FIRST YEAR OF SIMULATION
                IYEAR1 = INDEX(30)
            !--   AUXILLARY WRITE STATEMENTS (UNIT NO., 0 SCREEN, -1 OFF)

            !--   Compute the solution values of the acres shift from the solution of the
            !--   LP.  This values will be always substracted to obatin the baseline back
            !--   when running POLYSYS with no changes, and also to compute simulation
            !--   results away from the baseline.
            !--   Compute the solution values of the acres shift from the baseline solution of the LP.
            !--   These values will be always substracted to obatin the baseline back when running POLYSYS.
            !      WRITE(*,*)'BASELINEDONE->',BASELINEDONE

            !--   From here onwards, we are calculating the output using the LP solution.  The LP solution
            !--   for each crop are in RHS(80 to 94); RHS(1) contains the value of the objective function.
                23 FORMAT(I4,I4,I4,F12.2,F12.2,F12.2,F12.2,F12.2,F12.2)
                24 FORMAT(I4,I4,I4,I12,F12.2,F12.2,F12.2,F12.2,F12.2)
                IP = 0
            !--
            !--   ***CAPTURE SHADOW PRICES***
            !--
                DO K=1,NCROPS
                    DO T=1,3
                        KT=NCROPS*(T-1)+K
                        CY(27,K,T,CTY) = LPA(1,NCROPS*3+1+KT)
                    ENDDO
           END DO
            !--
            !--
            !--   Simulated Planted Acres = Pl.Ac - Ac.Shift + Sol.From LP - Baseline LP Sol.
            !-      IF (RHS(1).NE.0.0) THEN      !CHECK AND SEE IF CHANGES OCCURRED IN THE MATRIX, IF NOT, THEN NO CHANGES TO ACRES
                xtblah= 0.0
                xtblahb=0.0
                XTCYBLAH=0.0
                DO K = 1,NCROPS
                    NOTILLADD=0.0
                    DO T=1,3
                        KT=NCROPS*(T-1)+K
                        IF(NAME(KT)>0)THEN
                            CY(1,K,T,CTY) = RHS(NAME(KT))  + BSHIFT(K,T,CTY)                !!BASELINE - ACRES PUT INTO LP +ACRES OUT OF LP - BASELINE FIX
                            IF(CY(1,K,T,CTY)<-2.0)THEN
                                WRITE(*,*)RHS(NAME(KT)),BSHIFT(K,T,CTY),K,T,CTY
                                WRITE(*,*)'RHS(NAME(KT)) BSHIFT K T CTY' ! PROBLEM CONTACT CHAD'
                                CY(1,K,T,CTY) = 0.0
                            ENDIF
                        ELSE
                        !C               WRITE(*,*)CY(1,K,T,CTY),BSHIFT(K,T,CTY),K,T,CTY,'ASFS'
                            CY(1,K,T,CTY) = BSHIFT(K,T,CTY)
                            IF(CY(1,K,T,CTY)<0) CY(1,K,T,CTY) = 0.0
                        ENDIF

                        if(abs(cy(1,k,t,cty)-cyb(1,k,t,cty)) >= 10.0)then
                        !c          write(*,*)'not equal in outfmlp planted',cty,k,t
                        !c          write(*,*)cy(1,k,t,cty),cyb(1,k,t,cty)
                        endif
                    !--

                        IF(NAME(KT) > 0.0)THEN
                            XTblah= XTblah+rhs(NAME(kt))
                            xtblahb= xtblahb +cyb(1,k,t,cty)
                            XTCYBLAH=XTCYBLAH +CY(1,K,T,CTY)
                        ENDIF
                    !--
                        IF(NAME(KT) == 0 .AND. BSHIFT(K,T,CTY) < 0)THEN
                        !C           WRITE(*,*)I,K,T,CTY,'NONSOLUTION NEG BSHIFT'
                        ENDIF
                    !c        IF(rhs(NAME(kt)).lt.1.0.AND.BSHIFT(K,T,CTY).GT.0.0)THEN
                    !c          CY(1,K,T,CTY)=RHS(NAME(KT))
                    !c          WRITE(*,*)'AREWEHERE?',CY(1,K,T,CTY),BSHIFT(K,T,CTY),K,T,CTY
                    !c          NOTILLADD=BSHIFT(K,T,CTY)
                    ! c         ENDIF

                    !--
                    !C      IF(cty.eq.634.and.i.eq.17)then
                    !C      WRITE(*,*)cy(1,k,t,cty),k,t,cty,'outfmlp1'
                    !C      endif
                    ENDDO
                !--
                END DO
            !--
            !--************************************************************************************
            !--   *THIS IS TO ADD THE 'BSHIFT LOCKED IN ACREAGE FROM SOYBEANS TO PENNYCRESS**
            ! c          IF(CY(1,18,1,CTY).GT.0.0)THEN !.AND.CTY.EQ.105
            ! c           DO T=1,3
            ! c            IF(BSHIFT(6,T,CTY).GT.0.0) THEN !IF CORN CONVENTIONAL ALWAYS HAS A POSITIVE BSHIFT (MEANING THERE IS UNEXPLAINED ACREAGE IN THE 'REAL' BASELINE,
            !c                ALLBSHIFT = ALLBSHIFT + BSHIFT(6,T,CTY) !FOR GETTING A SIZE !not important can be commented
            ! c                CY(1,18,1,CTY) = CY(1,18,1,CTY) + 1.0*BSHIFT(6,T,CTY) !THEN TAKE 10% OF THIS ACREAGE AND ASSIGN TO PENNYCRESS
            ! c                CY(1,6,T,CTY) = CY(1,6,T,CTY) - 1.0*BSHIFT(6,T,CTY)
            ! c                BSHIFT(6,T,CTY) = BSHIFT(6,T,CTY)- 1.0*BSHIFT(6,T,CTY)  !THEN SUBTRACT THIS FROM THE CORN BSHIFT
            !c            WRITE(*,*)CY(1,18,1,CTY),BSHIFT(6,T,CTY),CTY,T,'PNY BSHIFT'
            ! c            ENDIF
            ! c            ENDDO
            ! c           ENDIF
            !--
            !--   *THIS IS TO ADD THE 'BSHIFT LOCKED IN ACREAGE FROM CORN TO PENNYCRESS**
            ! c          IF(CY(1,18,1,CTY).GT.0.0)THEN !.AND.CTY.EQ.105
            ! c           DO T=1,3
            ! c            IF(BSHIFT(1,T,CTY).GT.0.0) THEN !IF CORN CONVENTIONAL ALWAYS HAS A POSITIVE BSHIFT (MEANING THERE IS UNEXPLAINED ACREAGE IN THE 'REAL' BASELINE,
            !c                ALLBSHIFT = ALLBSHIFT + BSHIFT(1,T,CTY) !FOR GETTING A SIZE
            ! c                CY(1,18,1,CTY) = CY(1,18,1,CTY) + 1.0*BSHIFT(1,T,CTY) !THEN TAKE 10% OF THIS ACREAGE AND ASSIGN TO PENNYCRESS
            ! c                CY(1,1,T,CTY) = CY(1,1,T,CTY) - 1.0*BSHIFT(1,T,CTY)
            ! c                BSHIFT(1,T,CTY) = BSHIFT(1,T,CTY)- 1.0*BSHIFT(1,T,CTY)  !THEN SUBTRACT THIS FROM THE CORN BSHIFT
            !c            WRITE(*,*)CY(1,18,1,CTY),BSHIFT(6,T,CTY),CTY,T,'PNY BSHIFT'
            ! c            ENDIF
            ! c            ENDDO
            ! c          ENDIF
            !--*****************************************************************************
            !--
            !--
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            !--     Adjust regional acres if gaining in simulations (because of bshift)
            !--     This is done by taking away from least profitable Conventional tillage activities
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            !--
            !--  ******FIRST CORRECT BY TAKING FROM CONVENTIONAL TILLAGE********
            !--    SORT THE CROPS BY RETURNS WITH THE LEAST PROFITABLE BEING FIRST
                KKSORT = 0
                DO K = 1,NCROPS
                    SORTRET(K) = NPV(NPT,I,K,1,cty)
           END DO
                DO IK = 1,NCROPS
                    AAMIN = 9999999.99
                    DO K=1,NCROPS
                        IF(SORTRET(K)<AAMIN) THEN
                            KKSORT(IK) = K
                            AAMIN = SORTRET(K)
                        END IF
           END DO
                    SORTRET(KKSORT(IK)) = 9999.9999
           END DO
            !--
            !--  IS THERE A DIFFERENCE IN TOTAL ACRES IN THE REGION?
                TOTALC(CTY) = 0.0
                TOTALB(CTY) = 0.0
                DIFPAREA = 0.0
                DO K=1,NCROPS
                    DO T=1,3
                        TOTALB(CTY) = TOTALB(CTY) + CYB(1,K,T,CTY)
                        TOTALC(CTY) = TOTALC(CTY) + CY(1,K,T,CTY)
           END DO
                END DO
            !--
                DIFPAREA = TOTALC(CTY) - TOTALB(CTY)
            !--
            !      if(CTY.EQ.60)then
              !  IF(DIFPAREA > 50)THEN !region change version
              !      write(*,*)difparea,totalc(cty),totalb(cty),cty,i,'DIF'
              !  endif

            !c      GOTO 432
            !--
            !--    IF SO, THEN WE NEED TO TAKE THAT % OF PLANTED ACRES THAT THE LEAST PROFITABLE CROP PUT AVAILABLE
            !--    IF THE LEAST PROFITABLE RUNS OUT OF ACRES TO DROP, THEN WE TAKE THEM FROM THE NEXT LEAST PROFITABLE.
            !--
                DO K =1,NCROPS
                    IF(DIFPAREA > 1.0) THEN
                        ACADJ(KKSORT(K))=CY(1,KKSORT(K),1,CTY)*PlAc(1,KKSORT(K),1,CTY)                 !!
                        IF(ACADJ(KKSORT(K)) <= DIFPAREA) THEN
                            CY(1,KKSORT(K),1,CTY) = CY(1,KKSORT(K),1,CTY) &
                            - ACADJ(KKSORT(K))
                            DIFPAREA = DIFPAREA - ACADJ(KKSORT(K))
       ELSE
                            CY(1,KKSORT(K),1,CTY) = CY(1,KKSORT(K),1,CTY) - DIFPAREA
                            DIFPAREA = 0.0
                        END IF
                    !C      IF(cty.eq.634.and.i.eq.17)then
                    !c      WRITE(*,*)cy(1,k,t,cty),k,t,cty,'outfmlp1'
                    !C      WRITE(*,*)DIFPAREA,CY(1,KKSORT(K),1,CTY),KKSORT(K),CTY,K,'DDD'
                    !C      WRITE(*,*)ACADJ(KKSORT(K)),PlAc(1,KKSORT(K),1,CTY)
                    !C       PAUSE
                    !C      endif
       ENDIF
      END DO
            !--
            !--  ******THEN CORRECT BY TAKING FROM REDUCED TILLAGE********
                KKSORT = 0
                DO K = 1,NCROPS
                    SORTRET(K) = NPV(NPT,I,K,2,cty)
         END DO
                DO IK = 1,18
                    AAMIN = 9999999.99
                    DO K=1,NCROPS
                        IF(SORTRET(K)<AAMIN) THEN
                            KKSORT(IK) = K
                            AAMIN = SORTRET(K)
                        END IF
      END DO
                    SORTRET(KKSORT(IK)) = 9999.9999
           END DO
            !--
                TOTALC(CTY) = 0.0
                TOTALB(CTY) = 0.0
                DIFPAREA = 0.0
                DO K=1,NCROPS
                    DO T=1,3
                        TOTALB(CTY) = TOTALB(CTY) + CYB(1,K,T,CTY)
                        TOTALC(CTY) = TOTALC(CTY) + CY(1,K,T,CTY)
           END DO
                END DO
            !--
                DIFPAREA = TOTALC(CTY) - TOTALB(CTY)
            !--
                DO K =1,NCROPS
                    IF(DIFPAREA > 1.0) THEN
                        ACADJ(KKSORT(K))=CY(1,KKSORT(K),2,CTY)*PlAc(1,KKSORT(K),2,CTY)               !!
                        IF(ACADJ(KKSORT(K)) <= DIFPAREA) THEN
                            CY(1,KKSORT(K),2,CTY) = CY(1,KKSORT(K),2,CTY) &
                            - ACADJ(KKSORT(K))
                            DIFPAREA = DIFPAREA - ACADJ(KKSORT(K))
       ELSE
                            CY(1,KKSORT(K),2,CTY) = CY(1,KKSORT(K),2,CTY) - DIFPAREA
                            DIFPAREA = 0.0
       END IF
                    ENDIF
                END DO
            !--  ******THEN CORRECT BY TAKING FROM no- TILLAGE********
            !c      GOTO 432
            !--
                KKSORT = 0
                DO K = 1,NCROPS
                    SORTRET(K) = NPV(NPT,I,K,3,cty)
                END DO
                DO IK = 1,18                    !WAS 15 12/12/09
                    AAMIN = 9999999.99
                    DO K=1,NCROPS
                        IF(SORTRET(K)<AAMIN) THEN
                            KKSORT(IK) = K
                            AAMIN = SORTRET(K)
      END IF
      END DO
                    SORTRET(KKSORT(IK)) = 9999.9999
      END DO
            !--
                TOTALC(CTY) = 0.0
                TOTALB(CTY) = 0.0
                DIFPAREA = 0.0
                DO K=1,NCROPS
                    DO T=1,3
                        TOTALB(CTY) = TOTALB(CTY) + CYB(1,K,T,CTY)
                        TOTALC(CTY) = TOTALC(CTY) + CY(1,K,T,CTY)
                    END DO
                END DO
            !--
                DIFPAREA = TOTALC(CTY) - TOTALB(CTY)
            !--
                DO K =1,NCROPS
                    IF(DIFPAREA > 1.0) THEN
                        ACADJ(KKSORT(K))=CY(1,KKSORT(K),3,CTY)*PlAc(1,KKSORT(K),3,CTY)                 !!
                        IF(ACADJ(KKSORT(K)) <= DIFPAREA) THEN
                            CY(1,KKSORT(K),3,CTY) = CY(1,KKSORT(K),3,CTY) &
                            - ACADJ(KKSORT(K))
                            DIFPAREA = DIFPAREA - ACADJ(KKSORT(K))
                        ELSE
                            CY(1,KKSORT(K),3,CTY) = CY(1,KKSORT(K),3,CTY) - DIFPAREA
                            DIFPAREA = 0.0
      END IF
                    ENDIF
                !--    ***
                !c      IF(CY(1,K,3,CTY).LT.CYB(1,K,3,CTY))THEN
                !c         CY(1,K,3,CTY) = CYB(1,K,3,CTY)
                !c      ENDIF
                !      IF((cy(1,k,3,cty)-cyb(1,k,3,cty)).LE.-1000.0)then
                !       WRITE(*,*)cy(1,k,3,cty),cyb(1,k,3,cty),k,cty,i,'outfrm'
                !      endif
           END DO
            !--
            !--
                432 CONTINUE
            !--
            !--  ***make sure that planted acres is not negative***
                DO K=1,NCROPS
                    DO T=1,3
                        IF (CY(1,K,T,CTY) < 0.0)then
                            CY(1,K,T,CTY)=0.0
                        endif
                        !region change version; removed in update from UT 2019
                    !    if(CY(1,K,T,CTY).lt.minbio(k,1).and.t.eq.1)then  !makes sure that planted is at least up to the minimum!!
                       !     write(666,*) 'minbio set',MINBIO(K,1),cy(1,k,t,cty)
                        !    cy(1,k,t,cty)=MINBIO(K,1)

                        !endif

                    ENDDO
                ENDDO
            !--
                DO K=9,11
                !--       RECORD BIOMASS PLANTED ACRES
                    BIOPL(NPT,I,K-8,1,CTY) = CY(1,K,1,CTY)
                    IF(BIOPL(NPT,I,K-8,1,CTY) <= MINBIO(K,1)) THEN
                        APL(NPT,I,K-8,1,CTY) = 0.0
                    ELSE
                        APL(NPT,I,K-8,1,CTY)=BIOPL(NPT,I,K-8,1,CTY)-MINBIO(K,1)
                        IF(K == 10)then ! .AND. INDEX(115) == 1)THEN
                            APL(NPT,I,K-8,1,CTY)=APL(NPT,I,K-8,1,CTY)/RRR(K,CTY)  !ONLY PLANTED 1/RRR OF ACREAGE OF POPLARS   !AWAYS DO  TO MAKE PLANTINGS *ALWAYS* INCREMENTAL
                        ENDIF
                        IF(K == 11)then ! .AND. INDEX(115) == 1)THEN
                            APL(NPT,I,K-8,1,CTY)=APL(NPT,I,K-8,1,CTY)/RRR(K,CTY)  !ONLY PLANTED 1/4 OF ACREAGE OF WILLOWS    !AWAYS DO  TO MAKE PLANTINGS *ALWAYS* INCREMENTAL
                        ENDIF
                    !--
                        IF(APL(NPT,I,K-8,1,CTY) < 0.0)THEN
                            WRITE(*,*)'apl NEGATIVE'
                            WRITE(*,*)APL(NPT,I,K-8,1,CTY),BIOPL(NPT,I,K-8,1,CTY),MINBIO(K,1)
                            write(*,*)I,k,CTY,'inoutflmpp'
                           ! pause
                        ENDIF
                    END IF
                ENDDO
                DO K=16,17
                !--       RECORD BIOMASS PLANTED ACRES
                    BIOPL(NPT,I,K-12,1,CTY) = CY(1,K,1,CTY)
                    IF(BIOPL(NPT,I,K-12,1,CTY) == MINBIO(K,1)) THEN
                        APL(NPT,I,K-12,1,CTY) = 0.0
                    ELSE
                        APL(NPT,I,K-12,1,CTY)=BIOPL(NPT,I,K-12,1,CTY)-MINBIO(K,1)
                    END IF
                ENDDO
            !--
                BIOPL(NPT,I,6,1,CTY) = CY(1,14,1,CTY)  !cropland conversion to pasture !AFFORESTATION on pasture if t=2 or 3, but t=1 is converted pasture
            !--
                IF(I>=4)IP=1
            !--
                RETURN
                END SUBROUTINE OUTFRMLP

            !     Last change:  DTU   1 Feb 101   11:26 am
                SUBROUTINE PAGENO2(IPAGE,IUNIT2)
                IMPLICIT NONE

                !EIA add
                INTEGER IPAGE, IUNIT2

                CHARACTER(8) :: CLOCK
                CHARACTER(8) :: CALENDAR


                2 FORMAT(A10,A68)
                5 FORMAT(' ')
                8 FORMAT(' ',A60,1X'            Page ',I2)
                18 FORMAT(' ',A60,1X'            Page ',I2)
                28 FORMAT('1')
                9 FORMAT(' ',A60,2X,' POLYSYS Sim. # ',I2)
                10 FORMAT(' ',63X,A8,' ',A8)
            !      CALL TIME(CLOCK)
            !      CALL DATE(CALENDAR)
                IPAGE = IPAGE + 1
            !--             SIMULATION NUMBER
            !--        ISIMNO = INDEX(39)
            !--
                IF(IPAGE==1)THEN
                    WRITE(IUNIT2,18)TITLE1,IPAGE
                ELSE
                    WRITE(IUNIT2,28)
                    WRITE(IUNIT2,8)TITLE1,IPAGE
                ENDIF
                WRITE(IUNIT2,9)TITLE2,INDEX(39)
                WRITE(IUNIT2,10) CLOCK,CALENDAR
                RETURN
                END SUBROUTINE PAGENO2


            !     Last change:  DTU  27 Jul 100    3:38 pm
            !     Last change:  DTU   3 May 101   10:35 pm
                 SUBROUTINE PAGETXT(IPAGE,IUNIT2)
                IMPLICIT NONE

                CHARACTER(8) :: CLOCK
                CHARACTER(8) :: CALENDAR
                INTEGER ::  IPAGE, IUNIT2

                2 FORMAT(A10,A68)
                5 FORMAT(' ')
                8 FORMAT(' ',A60,12X,'            Page ',I2)
                18 FORMAT(' ',A60,13X,'            Page ',I2)
                28 FORMAT('1')
                9 FORMAT(' ',A60,14X,' POLYSYS Sim. # ',I2)
                10 FORMAT(' ',74X,A8,'  ',A8)
            !      CALL TIME(CLOCK)
            !      CALL DATE(CALENDAR)
                IPAGE = IPAGE + 1
            !--             SIMULATION NUMBER
            !--        ISIMNO = INDEX(39)
            !--
                IF(IPAGE==1)THEN
                    WRITE(IUNIT2,18)TITLE1,IPAGE
                ELSE
                    WRITE(IUNIT2,28)
                    WRITE(IUNIT2,8)TITLE1,IPAGE
                ENDIF
                WRITE(IUNIT2,9)TITLE2,INDEX(39)
                WRITE(IUNIT2,10) CLOCK,CALENDAR
                RETURN
                END SUBROUTINE PAGETXT



        SUBROUTINE PASTINLP
        IMPLICIT NONE

        REAL :: XTLAND=0.0,XNETLAND=0.0,TotalNFX=0.0,TotalOFX=0.0
        REAL :: RETOCC=0.0,DFPYRT=0.0,DFPYRTB=0.0
        REAL :: ARPCHNG=0.0,O92CHNG=0.0,ACRCHNG=0.0,LANDN6=0.0
        REAL :: SIMCOST=0.0,MKTRET=0.0,PGMRET=0.0, TOTALAREA = 0.0
        REAL :: PASTPOS=0.0,PASTNEW=0.0,CNRATIO=0.0
        REAL,DIMENSION(15)                  :: PRCTCROP = 0.0
        INTEGER ::  xxx,yyy,Z
        CHARACTER(20) :: LPNUMBER
        REAL, DIMENSION(12,15)  :: HOLDLR=0.0,HOLDAR=0.0
        REAL, DIMENSION(8) :: ARET,ACHECK,CROPPLD

        !EIA add
        INTEGER :: NCROPS, IYEAR1, ICON, ICOUNT, IACT
        REAL :: PERMAX
    !--
    !--
    !--   *****************************************************************************
    !--   This subroutine is copied off of input2lp but for pasture acres
    !--   *****************************************************************************
        NCROPS=7 !5 !2        ! Number ALTERNATIVE CROPS
        IYEAR1 = INDEX(30) ! FIRST YEAR OF SIMULATION

    !--
    !c      DO K=1,NCROPS
        MINBIO(9,2) = 0.0
    !c      END DO
    !--   ****************begin to fill the LPA'S******************************************************************
    !--
    !--   LOOP ACROSS CROPS
        DO K = 1,NCROPS
        !--      SET MATRIX PROFIT EQUAL TO NET PRESENT VALUE
            LPA(1,K) = -PT(NPT,I,2,K,CTY)
        END DO
    !--
        DO Z=1,47 !33 !17 !9!183   !SAME AS YYY
            IF(ABS(LPA(1,Z)) == 0.0) LPA(1,Z) = 0.0 ! If LPA = 0 it does not enter LP with minus(-) sign.
        END DO
    !--
    !--   ****************begin to fill the RIGHT HAND SIDES******************************************************************
    !--
        DO ICON = 1,500
            RHS(ICON) = 0.0  ! Refresh the RHS values
        END DO
    !--
        XTLAND = 0.0       ! XTLAND = Summation of All Acres Change in Crops
    !--
        DO K = 1,NCROPS
        !--
        !--
        !--      The base planted acres from which to calculate the acres available
        !--      to the LP is given by the following statement.
            IF(PT(NPT,I-1,1,K,CTY) == 0.0 .AND. I < 7)THEN                                                 !make sure comes here first year
                PT(NPT,I,1,K,CTY) = PTB(I,1,K,CTY)
            ELSE
            !C           PT(NPT,I,1,K,CTY) = PTB(I,1,K,CTY)
                PT(NPT,I,1,K,CTY) = PT(NPT,I-1,1,K,CTY)
            ENDIF

        !--
        !--
            XTLAND = XTLAND + PTB(I,1,K,CTY)                            !total acres must be equal to baseline!!
        !--
            3476 CONTINUE
        !--
        ENDDO
    !--
        DO K=1,NCROPS             !NCROPS IS ONLY THE CROPS IN PASTURE MATRIX HERE!!
        !--
        !C         IF(PT(NPT,I,1,K,CTY).EQ.0.0)LPA(1,K)=0.0                           !IF NO ACRES, THEN SET NPV TO ZERO FOR LP
        !--
            PERMAX = 0.125*(1.20)**(I-5)
            IF (PERMAX>1.0)PERMAX=1.00
        !--
        !--     MAX
            RHS(2+K) = PT(NPT,I,1,K,CTY)                                & !SECOND
            +  PTB(I,1,1,CTY) *.1*PERMAX
        !--
            IF(K >= 2 .AND. K <= 4)THEN
                IF(CYX(25,7+K,1,CTY) == 0.0)RHS(2+K)=0.0     !IF NO YIELD, THEN  CAN'T GROW HERE!!
                ENDIF
                IF(K == 5)THEN
                    IF(CYX(25,13,1,CTY) == 0.0)RHS(2+K)=0.0
                ENDIF
                IF(K == 6)THEN
                    IF(CYX(25,16,1,CTY) == 0.0)RHS(2+K)=0.0
                ENDIF
                IF(K == 7)THEN
                    IF(CYX(25,17,1,CTY) == 0.0)RHS(2+K)=0.0
                ENDIF
            !--
            !--     MIN
                IF(K == 2)THEN     !IF SWITCHGRASS
                    IF(BIOPL(NPT,I-1,1,2,CTY) > 0)THEN
                        IF(I-IRTLN(9) < 4) THEN
                            RHS(2+NCROPS+K) = BIOPL(NPT,I-1,1,2,CTY)
                        ELSE
                            RHS(2+NCROPS+K) = BIOPL(NPT,I-1,1,2,CTY) &
                            - APL(NPT,I-IRTLN(9),1,2,CTY)
                        END IF
                    ELSE
                        RHS(2+NCROPS+K) = 0.0
                    ENDIF
                !--
                ELSEIF(K == 6 .OR. K == 7)THEN     !IF miscanthus OR ECANE
                    IF(BIOPL(NPT,I-1,K-1,2,CTY) > 0)THEN
                        IF(I-IRTLN(10+K) < 4) THEN
                            RHS(2+NCROPS+K) = BIOPL(NPT,I-1,K-1,2,CTY)
                        ELSE
                            RHS(2+NCROPS+K) = BIOPL(NPT,I-1,K-1,2,CTY) &
                            - APL(NPT,I-IRTLN(10+K),K-1,2,CTY)
                        END IF
                    ELSE
                        RHS(2+NCROPS+K) = 0.0
                    ENDIF
                !--
                !--
                ELSEIF(K == 3 .OR. K == 4 .OR. K == 5)THEN         !IF WILLOWS OR POPLARS OR ALGAE or ecane
                    IF(BIOPL(NPT,I-1,K-1,2,CTY) > 0)THEN
                        IF(I-IRTLN(10+K) < 4) THEN
                            RHS(2+NCROPS+K) = BIOPL(NPT,I-1,K-1,2,CTY)
                        ELSE
                            IF(K == 3)THEN !POPLARS
                                RHS(2+NCROPS+K) = BIOPL(NPT,I-1,K-1,2,CTY) &
                                - APL(NPT,I-IRTLN(10+K),K-1,2,CTY)    & !APL WAS MADE TO ONLY HAVE 'INCREMENTAL PLANTINGS
                                * RRR(10,CTY)                       !NOW MAKE IT ALL THOSE ACRES THAT WERE CONVERTED AT BEGINNING OF ROTATION
                            ELSEIF(K == 4)THEN !WILLOWS
                                RHS(2+NCROPS+K) = BIOPL(NPT,I-1,K-1,2,CTY) &
                                - APL(NPT,I-IRTLN(10+K),K-1,2,CTY) &
                                * RRR(11,CTY)
                            ELSE
                                RHS(2+NCROPS+K) = BIOPL(NPT,I-1,K-1,2,CTY) &
                                - APL(NPT,I-IRTLN(10+K),K-1,2,CTY)
                            END IF
                        ENDIF
                    ELSE
                        RHS(2+NCROPS+K) = 0.0
                    ENDIF



                    RHS(2+NCROPS+K)=PT(NPT,I-1,1,K,CTY)          !!caution, should this be here?
                !--
                ELSE               !IF PASTURE      K=1
                !--
                    IF(CYX(2,1,1,CTY) >= 250)THEN
                        RHS(2+NCROPS+K) = PT(NPT,I,1,K,CTY) &
                        - PT(NPT,I,1,K,CTY)*0.05             !MIN IN LAST YEARS - 5% FOR PASTURE WEST OF 100TH MERIDIAN
                    ELSE
                        RHS(2+NCROPS+K) = PT(NPT,I,1,K,CTY) &
                        - PT(NPT,I,1,K,CTY)*0.2                  !MIN IS LAST YEARS - 20% FOR CROP PASTURE EAST OF 100TH MERIDIAN
                    ENDIF
                    IF(RHS(2+NCROPS+K) <= 0.0)RHS(2+NCROPS+K)=0.0
                ENDIF
                IF(K >= 2 .AND. K <= 4) MINBIO(7+K,2) = RHS(2+NCROPS+K) !SWITCHGRASS,POP,WILL
                IF(K >= 6 .AND. K <= 7) MINBIO(10+K,2)= RHS(2+NCROPS+K) !MISCANTHUS, ECANE
            !--
            END DO
        !--
        !--     HAYLANDS OR 'INTENSIFICATION OF PASTURELANDS'
            LPA(17,2) =-PT(NPT,I,5,1,CTY)  !lpa(down,across)=lpa(total#max constraints+#ofcrop+2,#ofcrop)     !HAY THAT MUST COME IN FOR SWITCHGRASS
            LPA(18,3) =-PT(NPT,I,5,1,CTY)  !THESE ACRES COME OUT OF PASTURELAND IF CONVERTED...SO HAYLANDS ARE ACCOUNTED FOR!!
            LPA(19,4) =-PT(NPT,I,5,1,CTY)   !willows
            LPA(20,5) =-PT(NPT,I,5,1,CTY)   !algae
            LPA(21,6) =-PT(NPT,I,5,1,CTY)   !miscanthus
            LPA(22,7) =-PT(NPT,I,5,1,CTY)   !E.cane
        !--
            LPA(17,8) = 1
            LPA(18,9) = 1
            LPA(19,10) = 1
            LPA(20,11) = 1
            LPA(21,12) = 1
            LPA(22,13) = 1
        !--
            RHS(17) = 0      !THESE ARE FOR HAY OFFSET RHS'S
            RHS(18) = 0
            RHS(19) = 0
            RHS(20) = 0
            RHS(21) = 0
            RHS(22) = 0
        !--
            RHS(2) = XTLAND
        !--
        !--   The following statements write the LP of a particular crdl to a TXT file
        !!!! update aug 2020
            !IF(CTY == 2447) THEN    !loudon, tn
            !    2424 FORMAT('  ',99F15.2)
            !!C         IF(I.EQ.14) THEN
             !   LPNUMBER='PSin2.TXT'
             !   OPEN(UNIT=77,FILE=LPNUMBER)
             !   WRITE(77,*)CTY
             !   DO ICOUNT = 1,99                                                    !!xxx
             !       WRITE(77,2424)RHS(ICOUNT),(LPA(ICOUNT,IACT),IACT=1,36)            !!vn     slack variables=shadow prices in first row of lpa!!
             !   END DO
             !   CLOSE(77)
            !c            WRITE(*,*)'DONE WRITING PSin2->',CTY,i
            !C        END IF
            !END IF
        !--
        !--
            RETURN
            END SUBROUTINE PASTINLP

            SUBROUTINE PASTLP
            IMPLICIT NONE

        !--
            CHARACTER(20) :: CNTNAME
            CHARACTER STNAME
            INTEGER :: xxx,yyy,Z,COUNTY,sk,POLYREGION,kk(5)    !,east(3110)
            REAL :: IRRIGAT, PERMPAST, CROPPAST, ALLPAST
            !EIA add
            INTEGER ::  IISTART, CTYY
            INTEGER FILE_MGR
            EXTERNAL FILE_MGR
            CHARACTER*25 FNAME
            LOGICAL NEW
            INTEGER IUNIT1,FILEUNIT
        !--
            IISTART = INDEX(30) - INDEX(27) + 3
        !--
        !--   Number of COUNTIES
            CNTY = INDEX(33)
        !--  ****THIS IS AN ALTERNATIVE LP MODEL TO KEEP TRACK OF OTHER LANDS*******
        !--      BESIDES CROPLAND, CROPLAND IN PASTURE, PASTURELAND AND CRP
        !--      CAN POTENTIALLY SWITCH INTO SWITCHGRASS OR FORESTRY
        !--      A NEW MATRIX, PT(NPT,J,K,CTY) AND PTB(J,K,CTY) IS CREATED TO KEEP TRACK
        !--      ALL NEW SWITCHGRASS ACRES ARE THEN TRANSFERED THE CY MATRIX UNDER T=2 (WHICH IS SUPPOSED TO BE 'TILLAGE TYPE' BUT SWITCHRASS IS ALWAYS NOTILL ANYWAY
        !--
        !--      M1=8 !6  !LESS THAN CONSTRAINTS     number of choices + total (total acreage,pasture,switch,pop,willows)
        !--      M2=13 !9  !GREATER THAN CONSTRAINTS  number of choices + number of hay offsets (pasture,switch,pop,willows,switch hay,pop hay,willow hay)
        !--      M3=0  !EQUAL TO CONSTRAINTS
        !--      RN=21 !15 ! M1+M2+M3
        !--      VN=7 !9  ! # OF ACTIVITIES (CHOICES + HAY OFFSETS)
        !--      XXX=22 !16 !M1+M2+1
        !--      YYY=41 !33 !VN+M1+M2+M2+M3+M3
        !--      Z=41 !33   !YYY   (SET IN PASTINLP.FOR)
        !--
        !--    The first set of data to read is the cij elements of the LP initial
        !--    tableau. Only read the Matrix the first time we are running
            RN = 21 !15 !12 !10!9!5!98         !M1+M2+M3
            VN = 13 !9 !7 !5!4!2!36         !NUMBER OF ACTIVITIES

           FNAME='PSPASTMRX'                        !EIA add
           NEW=.FALSE.                                    !EIA add
          ! IUNIT1=FILE_MGR('O',FNAME,NEW)   !EIA add
            IUNIT1=FILEUNIT();
            OPEN(UNIT=IUNIT1,FILE='./input/PASTMTRX.txt') !File name change when updated from UT 2019
            READ(iunit1,*)PP
            CLOSE(UNIT=IUNIT1)
            !  IUNIT1=FILE_MGR('C',FNAME,NEW)   !EIA add
        !--   Transpose the Matrix because the Fortran reads differently than
        !--   the the LP solver.
            DO yyy= 1,VN
                DO xxx= 1,RN+1
                    qq(xxx,yyy) = pp(yyy,xxx)
                END DO
            END DO
        !--   First update the LP elements of the objective function and Cij matrix.
        !--   For the Cij of LP, right now, we have 45 rows of constraints and 97
        !--   columns of variables. According to the Simplex method, the 2 dimensional
        !--   matrix that optimizes the LP has one more row to store the objective
        !--   function. The number of total columns needed to store the slack
        !--   variables are 45. Therefore, the total number of column is
        !--   45 + 97. We need to update the LP from bb ( which never change )
        !--   every time we run a CRD.
            DO xxx = 1,22 !16 !13 !11!10!6 !99      !M1+M2+M3+1
                DO yyy = 1,47 !33 !20!17!9!183  !VN+M1+M2+M2+M3+M3
                    LPA(xxx,yyy) = qq(xxx,yyy)                       !if CHANGING matrix, don't forget to change dimensions of pp and qq in Maxlp.inc   pp(vn,xxx) qq(xxx,yyy)
                END DO
            END DO
        !--
        !--  ***PASTURE RENTAL VALUES READ FROM 'LANDRENTALRATES.PRN' AT BOTTOM OF 'READALL.FOR'***
        !--
        !--    ***READ IN CROPLAND IN PASTURE ACRES (AND YIELD and rental) AT COUNTY LEVEL***
        !--
           IF(CTY == 1)THEN            !(I == IISTART .AND. CTY == 1)THEN

             FNAME='PSPASTACRES'                   !EIA add
             NEW=.FALSE.                                    !EIA add
            !  IUNIT1=FILE_MGR('O',FNAME,NEW)   !EIA add
             IF (INDEX(121)==0) then
                OPEN(UNIT=IUNIT1,FILE='./input/PASTURELAND_CENSUS.txt')
              ELSE
                 OPEN(UNIT=IUNIT1,FILE='./input/PASTURELAND_CDL.txt')
              ENDIF
                READ(IUNIT1,*)

                DO CTYY=1,alwaysCNTY !region change version
                  READ(IUNIT1,*)COUNTY,CNTNAME,STNAME,SK,SK,ALLPAST, & !LUCM(I,1,21,CTYY),  !EIA CHAD 2019        !LUC21 IS THE 'ALL PASTURELAND FOR USE IN TRACKING LAND USE CHANGE IN LUC.FOR
                   PERMPAST,CROPPAST,PTB(I,1,27,CTYY),PTB(I,4,1,CTYY), &
                   east(ctyy)                                            !J=4PASTURE YIELD     J=1&K=8=PERMPAST


                    IF (county /= CTYY) WRITE(*,*)'OUT ORDER PASTACRES',COUNTY,CTYY

                      PTB(I,1,14,CTYY)=ALLPAST*PERMPAST !PERMANENT PASTURE (Update from UT 2019)
                      PTB(I,1,1,CTYY)=ALLPAST*CROPPAST !CROPLAND PASTURE (Update from UT 2019)

                    IF(EAST(CTYY) == 0)THEN                                         !EAST(CTYY) IS FOR THE 25X25. IF 1 THEN EAST OF LINE, IF 0 THEN WEST OF LINE AND DON'T INCLUDE PASTURE
                        PTB(I,1,14,CTYY)=0.0
                        PTB(I,1,1,CTYY)=0.0
                        PTB(I,1,27,CTYY)=0.0
                        PTB(I,4,1,CTYY)=0.0
                    ENDIF
                END DO
                CLOSE(UNIT=IUNIT1)
                if(index(117).EQ.1.or.index(117).eq.2)CALL EIApast !CONVERTS ALL READ IN DATA TO ONLY 16 REGIONS     !!region change version

                ! IUNIT1=FILE_MGR('C',FNAME,NEW)   !EIA add
            ENDIF
        !--
        !--   @@@MAKE YIELDS THE SAME FOR ALL LANDUSE CATAGORIES@@@
            DO T=1,3
                DO K=10,11
                !         CYX(25,K,T,CTY)= CYX(25,K,1,CTY)  !READ IN READBIO   !NOW ASSIGNING AFTER NPV CALCULATION JUST IN CASE STOCHASTIC YIELDS ASSIGNED,...MAKE SURE USING NON-STOCHASTIC FOR NPV CALC!
                    CYX(3,K,T,CTY) = 1.0
                ENDDO
                DO K=16,17
                !         CYX(25,K,T,CTY)= CYX(25,K,1,CTY)  !READ IN READBIO   !NOW ASSIGNING AFTER NPV CALCULATION JUST IN CASE STOCHASTIC YIELDS ASSIGNED,...MAKE SURE USING NON-STOCHASTIC FOR NPV CALC!
                    CYX(3,K,T,CTY) = 1.0
                ENDDO
            ENDDO
        !--
        !--   RATO OF IRRIGATED PASTURELAND OF TOTAL PASTURELAND
            IRRIGAT =  PTB(I,1,27,CTY)/(PTB(I,1,14,CTY)+PTB(I,1,1,CTY))
            IF(IRRIGAT <= 0)IRRIGAT=0.0
            IF(IRRIGAT > 1.0)IRRIGAT=1.0
        !--   TAKE OUT IRRIGATED LAND FROM TOTAL PASTURELANDS
            PTB(I,1,1,CTY) = (1-IRRIGAT)*PTB(I,1,1,CTY)
            PTB(I,1,14,CTY) =(1-IRRIGAT)*PTB(I,1,14,CTY)
        !--   RATIO OF PASTURE YIELD TO HAY YIELD
            PT(NPT,I,5,1,CTY)=PTB(I,4,1,CTY)/(CYX(25,12,1,CTY)-PTB(I,4,1,CTY)) !!!!!!!!NEW EQUATION!!!!!!!!
            PT(NPT,I,5,1,CTY)= PASTASS  !PASTASS READ IN SIM.INS  !1                     !THIS ASSUMES INTENSIFICATION CAN double PASTURELAND PRODUCTIVITY!!
        !c      IF(PT(NPT,I,5,1,CTY).GT.4.0)PT(NPT,I,5,1,CTY)=4.0
        !c      IF(PT(NPT,I,5,1,CTY).LT.1.0)PT(NPT,I,5,1,CTY)=1.0
        !--
            IF(I >= 4)then ! .AND.                                          !year switchgrass can come in (i=5=2010)  !as of jan2009
            !c     1  PT(NPT,5,5,1,CTY).LT.0.8)THEN                            !HAY YIELDS MUST BE GREATER THAN FORAGE YIELDS (AND EXCEED THEM BY 20%)
            !c     1  IRRIGAT.LT.0.2)THEN                                  !IRRIGATED PASTURELANDS MUST BE LESS THAT 20% OF TOTAL
            !--
            !--
            !--    CROPLAND IN PASTURE LP
            !--
                IF(INDEX(73) == 1)THEN                    !if want cropland in pasture available
                    IF(PTB(I,1,1,CTY) > 0.0)THEN            !IF THERE IS CROPLAND IN PASTURE
                        CALL PASTNPV
                        CALL PASTINLP
                        CALL PASTLPSIM
                        CALL PASTSTOC
                        CALL PASTOUTLP
                    ENDIF
                ENDIF
            !--
            !--
            !--
            !--    PERMANENT PASTURE LP
            !--
                IF(INDEX(93) == 1)THEN                    !if want cropland in pasture available
                    IF(PTB(I,1,14,CTY) > 0.0)THEN         !IF THERE IS PERMANENT PASTURE
                    !--      PERMANENT PASTURE LP
                    !!!!!!!!!!!!!!!!!copied from above!!!!!!!!!!!!!!!!!!!!!!!!!!!
                      FNAME='PSPASTMRX'                        !EIA add
                      NEW=.FALSE.                                    !EIA add
                     ! IUNIT1=FILE_MGR('O',FNAME,NEW)   !EIA add
                 !     IUNIT1=FILEUNIT();
            OPEN(UNIT=IUNIT1,FILE='./input/PASTMTRX.txt')  !update from UT 2019

                      READ(iunit1,*)PP
                        CLOSE(UNIT=IUNIT1)
                  !   IUNIT1=FILE_MGR('C',FNAME,NEW)   !EIA add


                        DO yyy= 1,VN                                         !
                            DO xxx= 1,RN+1                                     !
                                qq(xxx,yyy) = pp(yyy,xxx)                       !
                            END DO                                             !
                        END DO                                               !
                        DO xxx = 1,22 !16 !13     !M1+M2+M3+1                        !
                            DO yyy = 1,47 !33 !26  !VN+M1+M2+M2+M3+M3                  !
                                LPA(xxx,yyy) = qq(xxx,yyy)                      !                                  !if CHANGING matrix, don't forget to change dimensions of pp and qq in Maxlp.inc   pp(vn,xxx) qq(xxx,yyy)
                            END DO                                             !
                        END DO                                               !
                    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


                        CALL PERMNPV
                        CALL PERMINLP
                        CALL PERMLPSIM
                        CALL PERMSTOC
                        CALL PERMOUTLP
                    ENDIF
                ENDIF !END OF INDEX(93)
            !--
            ENDIF
        !--
        !--       ADD NEW ACRES from cropland in pasture TO CY MATRIX                               PLANTED ACRES TO THE T=2, WHICH IS THE PASTURELAND CONVERTED TO BIOMASS CROPS           !!!T=2=BIOMASS from CROPLAND IN pasture!!!
            CY(1,9,2,CTY) = PT(NPT,I,1,2,CTY)  !SWITCHGRASS
            CY(1,10,2,CTY)= PT(NPT,I,1,3,CTY)  !POPLAR
            CY(1,11,2,CTY)= PT(NPT,I,1,4,CTY)  !WILLOW
            CY(1,13,2,CTY)= PT(NPT,I,1,5,CTY)  !ALGAE
            CY(1,16,2,CTY)= PT(NPT,I,1,6,CTY)  !MISCANTHUS
            CY(1,17,2,CTY)= PT(NPT,I,1,7,CTY)  !E.CANE
        !--
        !--       ADD NEW ACRES from permpasture TO CY MATRIX                               PLANTED ACRES TO THE T=3, WHICH IS THE PASTURELAND CONVERTED TO SWITCHGRASS           !!!T=3=BIOMASS from PERMANENT pasture!!!
            CY(1,9,3,CTY) = PT(NPT,I,1,15,CTY)  !SWITCHGRASS
            CY(1,10,3,CTY)= PT(NPT,I,1,16,CTY)  !POPLAR



            CY(1,11,3,CTY)= PT(NPT,I,1,17,CTY)  !WILLOW
            CY(1,13,3,CTY)= PT(NPT,I,1,18,CTY)  !ALGAE
            CY(1,16,3,CTY)= PT(NPT,I,1,19,CTY)  !MISCANTHUS
            CY(1,17,3,CTY)= PT(NPT,I,1,20,CTY)  !E.CANE
        !--
        !--       ADD NEW ACRES FROM PASTURLANDS THAT MUST BE INTENSIFIED TO OFFSET FORAGE LOST ON BIOMASS LANDS
            PT(NPT,I,1,28,CTY)= PT(NPT,I,1,8,CTY)+PT(NPT,I,1,9,CTY)+PT(NPT,I,1,10,CTY) &
            + PT(NPT,I,1,11,CTY)+PT(NPT,I,1,12,CTY)+PT(NPT,I,1,13,CTY) &
            + PT(NPT,I,1,21,CTY)+PT(NPT,I,1,22,CTY)+PT(NPT,I,1,23,CTY) &
            + PT(NPT,I,1,24,CTY)+PT(NPT,I,1,25,CTY)+PT(NPT,I,1,26,CTY)
        !--
        !--       ASSIGN HARVESTED ACREAGE
            CY(2,9,2,CTY) = PT(NPT,I,7,2,CTY)  !SWITCHGRASS
       !     if (npt.eq.1) write(666,*) 'debug sw harvest 2 ',CY(2,9,2,CTY) ,cty,curcalyr
            CY(2,10,2,CTY)= PT(NPT,I,7,3,CTY)  !POPLAR
            CY(2,11,2,CTY)= PT(NPT,I,7,4,CTY)  !WILLOW
            CY(2,13,2,CTY)= PT(NPT,I,7,5,CTY)  !ALGAE
            CY(2,16,2,CTY)= PT(NPT,I,7,6,CTY)  !MISCANTHUS
            CY(2,17,2,CTY)= PT(NPT,I,7,7,CTY)  !E.CANE
        !--
            CY(2,9,3,CTY) = PT(NPT,I,7,15,CTY)  !SWITCHGRASS   PERMPAST
            CY(2,10,3,CTY)= PT(NPT,I,7,16,CTY)  !POPLAR
            CY(2,11,3,CTY)= PT(NPT,I,7,17,CTY)  !WILLOW
            CY(2,13,3,CTY)= PT(NPT,I,7,18,CTY)  !ALGAE
            CY(2,16,3,CTY)= PT(NPT,I,7,19,CTY)  !MISCANTHUS
            CY(2,17,3,CTY)= PT(NPT,I,7,20,CTY)  !E.CANE

        !--       ASSIGN ANNUAL PRODUCTION
            CY(4,9,2,CTY) = PT(NPT,I,6,2,CTY)  !SWITCHGRASS
            CY(4,10,2,CTY)= PT(NPT,I,6,3,CTY)  !POPLAR
            CY(4,11,2,CTY)= PT(NPT,I,6,4,CTY)  !WILLOW
            CY(4,13,2,CTY)= PT(NPT,I,6,5,CTY)  !ALGAE
            CY(4,16,2,CTY)= PT(NPT,I,6,6,CTY)  !MISCANTHUS
            CY(4,17,2,CTY)= PT(NPT,I,6,7,CTY)  !E.CANE
        !--
            CY(4,9,3,CTY) = PT(NPT,I,6,15,CTY)  !SWITCHGRASS   PERMPAST
            CY(4,10,3,CTY)= PT(NPT,I,6,16,CTY)  !POPLAR
            CY(4,11,3,CTY)= PT(NPT,I,6,17,CTY)  !WILLOW
            CY(4,13,3,CTY)= PT(NPT,I,6,18,CTY)  !ALGAE
            CY(4,16,3,CTY)= PT(NPT,I,6,19,CTY)  !MISCANTHUS
            CY(4,17,3,CTY)= PT(NPT,I,6,20,CTY)  !E.CANE
        !--remove this?? --td
            kk(1)=9
            kk(2)=10
            kk(3)=11
            kk(4)=16
            kk(5)=17

          RETURN
            END SUBROUTINE PASTLP
        !**************************************************************************************************
            SUBROUTINE PASTLPSIM
            IMPLICIT NONE

            DOUBLE PRECISION :: pivot,snum,store(1000)                   !500
            DOUBLE PRECISION ::  BIGM,OBJMAX
            INTEGER :: VarNum,RowNum,NumIter
            INTEGER :: x,y,TotalVar,scol,srow,OPTIMIZED,num
            CHARACTER(11) :: LPNUMBER
            !EIA add
            INTEGER ::  IYEAR1, IX, NV, ICOLUMNS, IROWS, INFEASIBLE, IM
        !--
        !--
            IF(RHS(2) == 0.0)GOTO 999
        !--
        !--             FIRST YEAR OF SIMULATION
        !--
            IYEAR1 = INDEX(30)
        !--
        !--             AUXILLARY WRITE STATEMENTS (UNIT NO., 0 SCREEN, -1 OFF)
        !--

        !--
        !--
            do ix=1,500               !!500
                store(ix) = 0
            end do
        !--
        !--    ***************************************************************************
        !--    This subroutine contains a Linear Programming algorithm specifically
        !--    customized for RASS, and taylor to solve a maximization problem with
        !--    LT constraints only. The subrouitne is called from INPUT2LP.
        !--    ***************************************************************************
        !--
        !--   Set value for BIGM
        !--
        !c       BIGM = 100000000000000000000000000000000000.00
            BIGM = 100000000.0
        !--
            M1 = 8 !6 !5 !5!3!49!37                           ! Less than constraints
            M2 = 13 !9 !7 !5!4!2!48!36                           ! Greater than constrains is counted in INPUT2LP subroutine    !!this was commented
            M3 =  0 !1                           ! Equal to constraints
            M  = M1 + M2 + M3                  ! Total number of constraints
            NV = 13 !9 !7 !5!4!2!36                            ! Number of activities
        !--
        !--   The number of elements of the RHR solution needs to be pre-specified. It is
        !--   given by the sum of the number of activities and the number of constraints.
        !--
            VarNum = NV
            RowNum = M
            TotalVar = VarNum + RowNum
        !--
        !--    Big M SIMPLEX ALGORITHM : SETUP
        !--
        !--     Step 1 : is skipped because all RHS values are > or = to 0
        !--
        !--     Step 1': Identify greater(M2) than and equal to constraints(M3)
        !--     M1 = less than constraints, M2 = greater than constraints, M3 = equal to constraints
        !--     Objective function values = RHS(1)
        !--     First M1 constraint = RHS(2)
        !--     First M2 constraint = RHS(1+M1+1)
        !--     First M3 constraint = RHS(1+M1+M2+1)
        !--
        !--     Step 2 : Convert each inequality constraint to the standard form.
        !--     For constraints of the form LESS THAN then :
        !--     add a slack variable (1- diagonally).
        !--
            do x = 1,M1
                LPA(x+1,NV+x) = 1
            end do
        !--
        !--     For constraints of the form GREATER THAN OR EQUAL TO then :
        !--     substract an excess variable (-1,diagonally).
        !--
            do x = 1,M2
                LPA(1+M1+x,NV+M1+x) = -1                                          !these are not being printed
            end do
        !--
        !--     Step 3: For constraints "? or "=", add an artificial variable to
        !--             each constraint
        !--
            do x = 1,M2+M3
                LPA(1+M1+x,NV+M1+M2+x) = 1
            end do
        !--
        !--     Step 4 : Since our problem is a maximization problem, add (for each
        !--              artificial variable 'a') -Mai to the objective function.
        !--
            do x = 1,NV+M1+M2+M2+M3
                if(x > NV+M1+M2) then
                    LPA(1,x) = BIGM
                end if
            end do
        !--
        !--     Step 5 : Since each artificial variable will be in the starting basis,
        !--              all artificial variables must be eliminated from row 1 before
        !--              begining the simplex. This ensures we begin with a canonical
        !--              form. In choosing the entering variable remember that M is a
        !--              very large positive number.  After this transformation solve
        !--              the LP applying the Simplex.  If all artificial variables are
        !--              equal to Zero (0) in the optimal solution, the optimal solution
        !--              to the original problem has been found. If any artificial
        !--              variables is positive in the optimal solution, the original
        !--              problem is infeasible.
        !--
            do y = 1,NV+M1+M2+M2+M3
                do x = 1,M2+M3
                    LPA(1,y) = LPA(1,y) - LPA(1+M1+x,y)*BIGM
                end do
            end do
        !--
            RHS(1) = 0
        !--
            icolumns = NV+M1+M2+M2+M3
            irows = 1 + M1 + M2 + M3
        !--
            TotalVar = icolumns
            RowNum = irows - 1
        !--
        !--    To put all index of RHR. As activities come into the solution the elements
        !--    of NAME(x) change from 0 to the column number of the activity.
        !--
            do x = 1,500                      !!500
                NAME(x) = 0
            end do
        !--
        !--  *****************************************************************
        !--
        !--                 ITERATIVE SIMPLEX PROCEDURE
        !--
        !--  *****************************************************************
        !--
        !-- THE ITERATIVE SIMPLEX PROCEDURE STARTS BY CHECKING IF THE INITIAL
        !-- SOLUTION IS OPTIMIZED.
        !--
            OPTIMIZED = 0
            NumIter = 1
            do while ( OPTIMIZED /= 1)
                num = 0
            !--
                do x=1,TotalVar
                    if (LPA(1,x) >= 0.0) then
                        num = num + 1
                    end if
                end do
            !--
                if (num == TotalVar) OPTIMIZED = 1
            !--
                if (OPTIMIZED == 0)then
                !--
                !--  BELOW WILL SELECT THE LARGEST -VE VALUE IN THE FIRST ROW Z
                !--  scol is the selected column with the largest -ve Z
                !--
                    snum = 999999999.9999                                                !!!!12 NINES
                !--
                    do y=1,TotalVar
                        if (LPA(1,y) < snum) then
                            snum = LPA(1,y)
                            scol = y
                        end if
                    end do
                !--
                !-- AFTER SELECTING THE RIGHT COLUMN, SELECT THE +VE VALUES IN THE SELECTED
                !-- COLUMN TO DIVIDE ALL RHR. THEN SELECT THE SMALLEST RESULT AND THAT WILL
                !-- BE THE SELECTED ROW.
                !-- ROW SHOULD START FROM 2 INSTEAD OF 1 BECAUSE ROW 1 HAS THE OBJ FUNCTION.
                !--
                    do x = 2,RowNum+1
                        if (LPA(x,scol) <= 0.000000001) then                             !!!14 ZEROS AFTER .
                            store(x) = 1.e9                                              !!!1.e12
                        else
                            store(x) =(RHS(x)/LPA(x,scol))
                        end if
                    end do
                !--
                !-- THE FOLLOWING STATEMENT IDENTIFIES SELECTED ROW(SROW)
                !--
                    snum = 999999999.9999                                               !!!10 NINES
                    do x=2,RowNum+1
                        if(store(x) < snum) then
                            snum = store(x)
                            srow = x
                        end if
                    end do
                !--
                !-- USING SELECTED ROW (SROW) AND SELECTED COLUMN (SCOL), WE IDENTIFY THE
                !-- THE PIVOT ELEMENT.
                !--
                    pivot = LPA(srow,scol)
                    NAME(scol) = srow
                    do x = 1,TotalVar + 1
                        if((x /= scol) .AND. (NAME(x) == srow))then
                            NAME(x) = 0
                        end if
                    end do
                !--
                !-- BELOW IS TO COMPUTE THE VALUES OF THE NEW BASIC VARIABLES IN THE NEXT
                !-- TABLEAU.
                !--
                    do y = 1,TotalVar
                        LPA(srow,y) = (LPA(srow,y) / pivot)
                    end do
                    RHS(srow) = (RHS(srow) / pivot)
                !--
                !-- TO COMPUTE THE NEW VALUES FOR THE NEXT TABLEAU, WE USE THE FOLLOWING
                !-- FORMULA, new row = old row -(pivot column coefficient)*new pivot row
                !-- THE VALUES OF PIVOT COLUMN COEFFICIENT, ARE rstore IN store(i)
                !-- THE NEW PIVOT ROW IS THE ONE COMPUTED ABOVE.
                !--
                    do x = 1, RowNum + 1
                        store(x) = LPA(x,scol)
                    end do
                !--
                    do x = 1, RowNum + 1
                        if ((x /= srow) .AND. (store(x)/= 0.0)) then
                        !--
                            do y=1,TotalVar
                                if(y==scol) then
                                    LPA(x,y) = 0.0
                                else
                                    LPA(x,y) = LPA(x,y) - (store(x)*LPA(srow,y))
                                end if
                            end do
                        !--
                            RHS(x) = RHS(x)-(store(x)*RHS(srow))
                            if (RHS(x) < +1.E-8)then
                                RHS(x) = 0.0
                            end if
                        end if
                        IF(CTY == 2109)THEN
                        !c                WRITE(*,*)X,RHS(X),NAME(X),RHS(NAME(X)),numiter
         ENDIF
                    end do
                    IF(CTY == 2109)THEN
                    !c      PAUSE
         ENDIF
                !--
                    NumIter = NumIter + 1
                    IF (NumIter > 222) THEN
                        WRITE(*,*)'NON OPTIMAL SOL 3.:Exceeded Max Num of Iter ->',CTY
                        EXIT
       END IF
                end if
            end do
        !--
        !        INDEX(24) = -7
            INFEASIBLE = 0
            DO IM=NV+M1+M2+1,TotalVar
                IF(NAME(IM)==0) GOTO 2423
                IF(RHS(NAME(IM))>0.1) THEN
                    INFEASIBLE =1
                    IF(INFEASIBLE==1) GOTO 2424
      END IF
                2423 CONTINUE
           END DO
            2424 CONTINUE
            IF(INFEASIBLE==1) THEN
                WRITE(*,*)'Infeasible LP in crop past->',cty,' ',' ',cty
            !C        PAUSE
                DO IM = NV+M1+M2+1,TotalVar
                    IF(NAME(IM)>0) THEN
                        WRITE(*,*)'SOL',IM,RHS(IM),NAME(IM),RHS(NAME(IM))
       ELSE
                        WRITE(*,*)'SOL',IM,RHS(IM),NAME(IM),0
       END IF
      END DO

            END IF
        !--

            999 CONTINUE
            return
            END SUBROUTINE PASTLPSIM
   !*********************************************************************************
   ! updated 2021
           SUBROUTINE PASTNPV
            IMPLICIT NONE

            INTEGER :: IIYEAR(41)
            REAL :: pastcost,PORTINTEG
            !EIA add
            INTEGER :: IYEAR1, NYRSIM, ISTART, IEND, IYR, III, NCROPS, IPLAN, IB
            REAL :: FLOW, REVENUES

        !--
        !      WRITE(*,*)'IN NPVALUE ILOOP = ',ILOOP
            IYEAR1 = INDEX(30)      ! FIRST YEAR OF SIMULATION
        !--
            NYRSIM = INDEX(1)
            ISTART = INDEX(30)-INDEX(27)+3
            IEND = NYRSIM+(INDEX(30)-INDEX(27))+2
            IYR = INDEX(30) - 2
        !--
            DO III=ISTART-2,IEND
                IIYEAR(III) = IYR
                IYR = IYR + 1
            END DO
        !--

            FLOW = 0
            REVENUES = 0
            DRATE = 0.065          ! DISCOUNT RATE
            NCROPS = 2              !THIS IS ALTERNATIVE CROPS
            IPLAN = 100 !30 !20              ! LENGTH OF PLANNING PERIOD
            IF(INDEX(1)>INDEX(28)) THEN
                IB = INDEX(1)
            ELSE
                IB = INDEX(28)
            END IF
        !C      DRATE = DRATEK(I,K)
        !--
        !--
        !--   CROPLAND IN PAST NPV
            FLOW = PASTRENT(i,CTY)
            PT(NPT,I,2,1,CTY) = 0.0
            DO INPV = 1,IPLAN
                PT(NPT,I,2,1,CTY) = PT(NPT,I,2,1,CTY) + FLOW/(1+DRATE)**INPV
            ENDDO

        !--
        !--
        !--   SWITCHGRASS,POPLARS, WILLOWS   NPV     K=2=POPLARS K=3=WILLOWS
            DO K=1,3
            !c       IF(K.EQ.1)THEN
            !c        PT(NPT,I,2,1+K,CTY) = NPV(NPT,I,9,2,CTY)        !SWITCHGRASS NPV(NPT,i,k,t,cty)
            !c       ELSE
                PT(NPT,I,2,1+K,CTY) = 0.0
                DO INPV = 1, IPLAN
                    REVENUES = CYX(25,8+K,2,CTY)*CMX(INPV,22,K,CTY)*PRIC(8+K,CTY) !Update from UT 2019
                   !   REVENUES = CYX(25,8+K,2,CTY)*CMX(INPV,22,K,CTY)  * C(NPT,I,9,8+K)*CYX(3,8+K,2,CTY) !price index for EIA   region change version
                    IF(K == 2 .AND. INDEX(115) == 1)REVENUES=REVENUES/RRR(10,CTY) !*1.10 !IF POPLARS, ONLY HARVESTING 1/RRR OF EVERY ACRE    !+ 10% predictive yield boost (new varieties)
                    IF(K == 3 .AND. INDEX(115) == 1)REVENUES=REVENUES/RRR(11,CTY)  !IF WILLOWS, ONLY HARVESTING 1/4 OF EVERY ACRE
                !--
                !--      ***FIGURE COSTS AND ADD CONVERSION COST OF 'INTENSIFICATION' TO THE COST OF BIOMASS CROPS
                    IF(INPV == 1)THEN
                        IF(K == 2 .AND. INDEX(115) == 1)THEN
                            PASTCOST = CMX(INPV,21,K,CTY)+ 50*PT(NPT,I,5,1,CTY)/RRR(10,CTY)
                        ELSEIF(K == 3 .AND. INDEX(115) == 1)THEN
                            PASTCOST = CMX(INPV,21,K,CTY)+ 50*PT(NPT,I,5,1,CTY)/RRR(11,CTY)
                        ELSE
                            PASTCOST = CMX(INPV,21,K,CTY)+ 50*PT(NPT,I,5,1,CTY)   !EXTRA COST OF BREAKING PASTURE INTO HAY ($20*HAY ACREAGE THAT MUST COME IN) OR 'COST OF INTENSIFICATION'
                        ENDIF
                    ELSE
		    !2021 update
                        IF(K == 2 .AND. INDEX(115) == 1)THEN
 
                            PORTINTEG = INPV/RRR(10,CTY)
                            IF(PORTINTEG > 1.0)PORTINTEG=1.0
                            PASTCOST = CMX(INPV,21,K,CTY) + 10*PT(NPT,I,5,1,CTY)*PORTINTEG
                        ELSEIF(K == 3 .AND. INDEX(115) == 1)THEN
                             PORTINTEG = INPV/RRR(11,CTY)
                            IF(PORTINTEG > 1.0)PORTINTEG=1.0
                            PASTCOST = CMX(INPV,21,K,CTY) + 10*PT(NPT,I,5,1,CTY)*PORTINTEG
                        ELSE
                            PASTCOST = CMX(INPV,21,K,CTY) + 10*PT(NPT,I,5,1,CTY)
                        ENDIF
                    ENDIF
                !--
                    FLOW = REVENUES - PASTCOST                                   & !J=20=TOTAL COSTS PER ACRE
                    + INCENT(1,8+K,2,CTY)                                 & ! INCENTIVE PER ACRE FOR TILLAGE SYSTEM (1/7/07)
                    - INCENT(6,8+K,2,CTY)                                 & ! TOTAL ADDITIONAL COSTS FROM CARBON PRICE  !COMPUTED IN COSTCHG.FOR
                    - INCENT(11,8+K,2,CTY)                               ! TOTAL ADDITIONAL COSTS FROM ENERGY PRICE INCREASE
                !--
                !--     ***** AFFORESTATION CREDIT ****
                !c         IF(INDEX(80).EQ.1.AND.C(I,9,8+K).EQ.0)THEN
                !c          FLOW = FLOW
                !c     1         + CYX(25,8+K,1,CTY) *.5 * (CARBINCT(I)*0.9)                !ANNUAL WOOD YIELD * 0.5 * (CARBON PRICE *.9) = CARBON ACCUMULATION * INCENTIVE PRICE (IN METRIC TONS C)
                !c         ENDIF
                !--      *********************************
                !--
                    PT(NPT,I,2,1+K,CTY) = PT(NPT,I,2,1+K,CTY) + FLOW/(1+DRATE)**INPV     !PT(NPT,I,J,K,CTY) K=3=POPLARS
                ENDDO
            !c       ENDIF !ifk=1 loop
            !--
            ENDDO
        !--
        !--
        !--    ***ALGAE NPV***
            PT(NPT,I,2,5,CTY) = 0.0
            DO INPV = 1, IPLAN
                REVENUES = CYX(25,13,1,CTY)*C(NPT,I,9,13)  !YIELD * PRICE
            !--
                IF(INPV == 1)THEN
                    PASTCOST = CYX(23,13,1,CTY)+ 50*PT(NPT,I,5,1,CTY)   !EXTRA COST OF BREAKING PASTURE INTO HAY ($20*HAY ACREAGE THAT MUST COME IN)
                ELSE
                    PASTCOST = CYX(23,13,1,CTY) + 10*PT(NPT,I,5,1,CTY)
                ENDIF
            !--
                FLOW = REVENUES - PASTCOST                                  & !J=20=TOTAL COSTS PER ACRE
                + INCENT(1,13,2,CTY)                                 & ! INCENTIVE PER ACRE FOR TILLAGE SYSTEM (1/7/07)
                - INCENT(6,13,2,CTY)                                 & ! TOTAL ADDITIONAL COSTS FROM CARBON PRICE  !COMPUTED IN COSTCHG.FOR
                - INCENT(11,13,2,CTY)                               ! TOTAL ADDITIONAL COSTS FROM ENERGY PRICE INCREASE
            !--
                PT(NPT,I,2,5,CTY) = PT(NPT,I,2,5,CTY) + FLOW/(1+DRATE)**INPV
            ENDDO
        !--
        !--
        !--    ***MISCANTHUS NPV***
            PT(NPT,I,2,6,CTY) = 0.0
            DO INPV = 1, IPLAN
                !REVENUES = CYX(25,16,2,CTY)*CMX(INPV,22,4,CTY)*C(NPT,I,9,16)
                REVENUES = CYX(25,16,2,CTY)*CMX(INPV,22,4,CTY)*PRIC(16,CTY) !update from UT 2019
                 !REVENUES = CYX(25,16,2,CTY)*CMX(INPV,22,4,CTY) * C(NPT,I,9,16) * CYX(3,16,2,CTY) !region change version
            !--
                IF(INPV == 1)THEN
                    PASTCOST = CMX(INPV,21,4,CTY)+ 50*PT(NPT,I,5,1,CTY)   !EXTRA COST OF BREAKING PASTURE INTO HAY ($20*HAY ACREAGE THAT MUST COME IN)
                ELSE
                    PASTCOST = CMX(INPV,21,4,CTY) + 10*PT(NPT,I,5,1,CTY)
                ENDIF
            !--
                FLOW = REVENUES - PASTCOST                                  & !J=20=TOTAL COSTS PER ACRE
                + INCENT(1,16,2,CTY)                                 & ! INCENTIVE PER ACRE FOR TILLAGE SYSTEM (1/7/07)
                - INCENT(6,16,2,CTY)                                 & ! TOTAL ADDITIONAL COSTS FROM CARBON PRICE  !COMPUTED IN COSTCHG.FOR
                - INCENT(11,16,2,CTY)                               ! TOTAL ADDITIONAL COSTS FROM ENERGY PRICE INCREASE
            !--
                PT(NPT,I,2,6,CTY) = PT(NPT,I,2,6,CTY) + FLOW/(1+DRATE)**INPV     !PT(NPT,I,J,K,CTY) K=3=POPLARS
            ENDDO
        !--
        !-- ***E.CANE NPV***
        !--
            PT(NPT,I,2,7,CTY) = 0.0
            DO INPV = 1, IPLAN
              !  REVENUES = CYX(25,17,2,CTY)*CMX(INPV,22,5,CTY)*C(NPT,I,9,17
                REVENUES = CYX(25,17,2,CTY)*CMX(INPV,22,5,CTY)*PRIC(17,CTY) !!update from Ut 2019
             !    REVENUES = CYX(25,17,2,CTY)*CMX(INPV,22,5,CTY) * C(NPT,I,9,17) * CYX(3,17,2,CTY) !region change version
            !--
                IF(INPV == 1)THEN
                    PASTCOST = CMX(INPV,21,5,CTY)+ 50*PT(NPT,I,5,1,CTY)   !EXTRA COST OF BREAKING PASTURE INTO HAY ($20*HAY ACREAGE THAT MUST COME IN)
                ELSE
                    PASTCOST = CMX(INPV,21,5,CTY) + 10*PT(NPT,I,5,1,CTY)
                ENDIF
            !--
                FLOW = REVENUES - PASTCOST                                  & !J=20=TOTAL COSTS PER ACRE
                + INCENT(1,17,2,CTY)                                 & ! INCENTIVE PER ACRE FOR TILLAGE SYSTEM (1/7/07)
                - INCENT(6,17,2,CTY)                                 & ! TOTAL ADDITIONAL COSTS FROM CARBON PRICE  !COMPUTED IN COSTCHG.FOR
                - INCENT(11,17,2,CTY)                               ! TOTAL ADDITIONAL COSTS FROM ENERGY PRICE INCREASE
            !--
                PT(NPT,I,2,7,CTY) = PT(NPT,I,2,7,CTY) + FLOW/(1+DRATE)**INPV     !PT(NPT,I,J,K,CTY) K=3=POPLARS
            ENDDO
        !--
        !--     **Restrict Biomass Crops to years defined in sim.ins**
            IF(IIYEAR(I) < YRHERB)THEN
                PT(NPT,I,2,2,CTY)=0.0 !SWITCHGRASS
                PT(NPT,I,2,6,CTY)=0.0 !MISCANTHUS
                PT(NPT,I,2,7,CTY)=0.0 !ECANE
            ENDIF
            IF(IIYEAR(I) < YRWOODY)THEN
                PT(NPT,I,2,3,CTY)=0.0 !POPLAR
                PT(NPT,I,2,4,CTY)=0.0 !WILLOW
            ENDIF
        !--
      RETURN
            END SUBROUTINE PASTNPV
        !     *************************************************************************
            SUBROUTINE PASTOUTLP
            IMPLICIT NONE

            REAL,DIMENSION(65) :: HOLDARP = 0.0,SORTRET=0.0,ACADJ=0.0
            REAL :: TOTALC(3111),TOTALB(3111),DIFPAREA
            INTEGER,DIMENSION(12) :: KKSORT
            !EIA add
            INTEGER :: NCROPS,  IYEAR1, IP, IA
            REAL :: xtblah,  xtblahb,  XTCYBLAH
        !--
        !--   *****************************************************************************
        !--   This subroutine captures the solution values from LP's and assigns them
        !--   Also computes BSHIFTS in baseline to bring values back to baseline
        !--   The subroutine is called from RMAIN
        !--   *****************************************************************************
            NCROPS=13 !9 !7 !5               !include hay in this number
        !--   FIRST YEAR OF SIMULATION
            IYEAR1 = INDEX(30)
        !--   AUXILLARY WRITE STATEMENTS (UNIT NO., 0 SCREEN, -1 OFF)

        !--   Compute the solution values of the acres shift from the solution of the
        !--   LP.  This values will be always substracted to obatin the baseline back
        !--   when running POLYSYS with no changes, and also to compute simulation
        !--   results away from the baseline.
        !--   Compute the solution values of the acres shift from the baseline solution of the LP.
        !--   These values will be always substracted to obatin the baseline back when running POLYSYS.
        !      WRITE(*,*)'BASELINEDONE->',BASELINEDONE
        !--
        !--
            T=1
        !--

        !--   From here onwards, we are calculating the output using the LP solution.  The LP solution
        !--   for each crop are in RHS(80 to 94); RHS(1) contains the value of the objective function.
            23 FORMAT(I4,I4,I4,F12.2,F12.2,F12.2,F12.2,F12.2,F12.2)
            24 FORMAT(I4,I4,I4,I12,F12.2,F12.2,F12.2,F12.2,F12.2)
            IP = 0
        !--
        !--   ***CAPTURE SHADOW PRICES***
        !--
            DO K=1,NCROPS
                PT(NPT,I,3,K,CTY) = LPA(1,NCROPS+1+K)
            END DO
        !--
        !--
        !--   Simulated Planted Acres = Pl.Ac - Ac.Shift + Sol.From LP - Baseline LP Sol.
        !-      IF (RHS(1).NE.0.0) THEN      !CHECK AND SEE IF CHANGES OCCURRED IN THE MATRIX, IF NOT, THEN NO CHANGES TO ACRES
            xtblah= 0.0
            xtblahb=0.0
            XTCYBLAH=0.0
            DO K = 1,NCROPS
                IF(NAME(K)>0)THEN
                    PT(NPT,I,1,K,CTY) = RHS(NAME(K)) + PSHIFT(K,1,CTY)                !!BASELINE - ACRES PUT INTO LP +ACRES OUT OF LP - BASELINE FIX
                    IF(PT(NPT,I,1,K,CTY)<0) PT(NPT,I,1,K,CTY) = 0.0
                ELSE
                    PT(NPT,I,1,K,CTY) = PSHIFT(K,1,CTY)
                    IF(PT(NPT,I,1,K,CTY)<0) PT(NPT,I,1,K,CTY) = 0.0
                ENDIF
            !--
                IF(NAME(K) > 0.0)THEN
                    XTblah= XTblah+rhs(NAME(k))
                    xtblahb= xtblahb +PTB(I,1,k,cty)
                    XTCYBLAH=XTCYBLAH +PT(NPT,I,1,K,CTY)
                ENDIF
                ! section removed in update from ut 2019
            !--region change version
         !     IF(K.GE.2.AND.K.LE.4)THEN
         !       if(PT(NPT,I,1,K,CTY).lt.MINBIO(K+7,2))then  !makes sure that planted is at least up to the minimum!!
         !           PT(NPT,I,1,K,CTY)=MINBIO(K+7,2)
        !       endiF
        !      ENDIF

      END DO
        !--
        !--       RECORD THIS YEAR'S NEW ACRES
            DO K=1,3 !switch, pop, willow
                BIOPL(NPT,I,K,2,CTY) = PT(NPT,I,1,1+K,CTY) !CY(1,8+K,2,CTY)
                IF(BIOPL(NPT,I,K,2,CTY) <= MINBIO(8+K,2)) THEN    !MINBIO IS THE ACRES THAT WERE PLANTED IN PREVIOUS YEARS
                    APL(NPT,I,K,2,CTY) = 0.0
                ELSE
                    APL(NPT,I,K,2,CTY)=BIOPL(NPT,I,K,2,CTY)-MINBIO(8+K,2)
                    IF(K == 2)then! .AND. INDEX(115) == 1)THEN
                        APL(NPT,I,K,2,CTY)=APL(NPT,I,K,2,CTY)/RRR(10,CTY)  !ONLY PLANTED 1/RRR OF ACREAGE OF POPLARS   !AWAYS DO  TO MAKE PLANTINGS *ALWAYS* INCREMENTAL
                    ENDIF
                    IF(K == 3)then! .AND. INDEX(115) == 1)THEN
                        APL(NPT,I,K,2,CTY)=APL(NPT,I,K,2,CTY)/RRR(11,CTY)  !ONLY PLANTED 1/4 OF ACREAGE OF WILLOWS   !AWAYS DO  TO MAKE PLANTINGS *ALWAYS* INCREMENTAL
                    ENDIF
                END IF
            ENDDO
        !--   K=4=ALGAE !NOT COMPUTING RIGHT NOW
        !--
        !--       RECORD THIS YEAR'S NEW miscanthus and Ecane ACRES
            DO K=5,6
                BIOPL(NPT,I,K,2,CTY) = PT(NPT,I,1,1+K,CTY)
                IF(BIOPL(NPT,I,K,2,CTY) <= MINBIO(11+K,2)) THEN
                    APL(NPT,I,K,2,CTY) = 0.0
                ELSE
                    APL(NPT,I,K,2,CTY)=BIOPL(NPT,I,K,2,CTY)-MINBIO(11+K,2)
                END IF
            ENDDO
        !--
        !--      BIOTRACK FOR PASTURELAND IN BIOMASS CROPS
            DO K=1,6
                IF(K == 4)THEN !ALGAE
                    PT(NPT,I,7,1+K,CTY)=PT(NPT,I,1,1+K,CTY) !HARV
                    PT(NPT,I,6,1+K,CTY)=PT(NPT,I,1,1+K,CTY)*CYX(25,13,2,CTY) !PROD
                !C       ELSEIF(K.EQ.6)THEN !E.CANE
                !C         PT(NPT,I,7,1+K,CTY)=PT(NPT,I,1,1+K,CTY)
                !C         PT(NPT,I,6,1+K,CTY)=PT(NPT,I,1,1+K,CTY)*CYX(25,17,1,CTY)
                ELSEIF(K >= 1 .AND. K <= 3)THEN
                    PT(NPT,I,7,1+K,CTY) = 0.0
                    PT(NPT,I,6,1+K,CTY) = 0.0
                    AYL(I,K,2,CTY) = CYX(25,8+K,2,CTY)                             ! Storage yield corresponding to date
                !--                                                                     ! of planting of biomass crops
                    IA = 0
                !-- This section updated from UT 2019
                    DO WHILE ((I-IA-4)>=0 .AND. IA<IRTLN(8+K))                       ! chad changed from -4) 6/15/05!!!
                        IA = IA + 1  !IA is the years back, so IA=4 is the record of what occured 4 years ago (plantings and yield)
                        BIOAGE(I,IA,K,2,CTY) = APL(NPT,I-IA+1,K,2,CTY)                    ! Calculate Plantings by "Age". for willow and poplars these are incremental plantings
                        PRDAGE(I,IA,K,2,CTY)=BIOAGE(I,IA,K,2,CTY) &
                        *CMX(IA,22,K,CTY)*AYL(I-IA+1,K,2,CTY)              ! Calculate Production by "Age".
                        IF(K == 2 .AND. (I-RRR(10,CTY)) > 0.0)THEN !POPLARS ALWAYS TAKE YIELD RRR(CTY) YEARS BEFORE
                            if(ia < rrr(10,cty))then
                                PRDAGE(I,IA,K,2,CTY)=0.0
                            ELSE
                                PRDAGE(I,IA,K,2,CTY)=BIOAGE(I,IA,K,2,CTY) &
                                *CMX(rrr(10,cty),22,K,CTY)*AYL(I-RRR(10,CTY)+1,K,2,CTY)    !THIS IS TO MAKE PLANTINGS *ALWAYS* INCREMENTAL
                            ENDIF
                        ENDIF
                    !--
                        IF(K == 3)THEN
                            IF(IA < RRR(11,CTY))THEN
                                PRDAGE(I,IA,K,2,CTY)=0.0
                            ELSEIF(IA >= RRR(11,CTY) .AND. IA < (RRR(11,CTY)*2))THEN
                               PRDAGE(I,IA,K,2,CTY) = BIOAGE(I,IA,K,2,CTY) &
                                                  *CMX(RRR(11,CTY),22,K,CTY)*AYL(I-ia+1,K,2,CTY) !THIS IS TO MAKE PLANTINGS *ALWAYS* INCREMENTAL  new:(I-RRR(11,CTY)+1,K

                             ELSEif(ia.ge.(RRR(11,CTY)*2))then
                                PRDAGE(I,IA,K,2,CTY) = BIOAGE(I,IA,K,2,CTY) *CMX((RRR(11,CTY)*2),22,K,CTY)  *AYL(I-ia+1,K,2,CTY)      !THIS IS TO MAKE PLANTINGS *ALWAYS* INCREMENTAL
                             ENDIF
                        ENDIF
                    !--
                        IF(PRDAGE(I,IA,K,2,CTY)>0) THEN
                            PT(NPT,I,7,1+K,CTY) = PT(NPT,I,7,1+K,CTY)+BIOAGE(I,IA,K,2,CTY)       ! Calculate Acres Harvested
                         !  if ((NPT.eq.1).and.(k.eq.1)) write(666,*) 'debug harvest sw', PT(NPT,I,7,1+K,CTY) ,BIOAGE(I,IA,K,2,CTY) ,curcalyr,cty,IA
                        END IF
                        PT(NPT,I,6,1+K,CTY) =PT(NPT,I,6,1+K,CTY) + PRDAGE(I,IA,K,2,CTY)          ! Calculate Production by year


                    END DO

                ELSEIF(K >= 5 .AND. K <= 6)THEN !MISCANTHUS   and ecane?
                    PT(NPT,I,7,1+K,CTY) = 0.0
                    PT(NPT,I,6,1+K,CTY) = 0.0
                    AYL(I,K,2,CTY) = CYX(25,11+K,2,CTY)                             ! Storage yield corresponding to date
                !--                                                                     ! of planting of biomass crops
                    IA = 0
                    DO WHILE ((I-IA-4)>=0 .AND. IA<IRTLN(11+K))                       ! chad changed from -4) 6/15/05!!!
                        IA = IA + 1
                        BIOAGE(I,IA,K,2,CTY) = APL(NPT,I-IA+1,K,2,CTY)                    ! Calculate Plantings by "Age".
                        IF(BIOAGE(I,IA,K,2,CTY) < 0.0)BIOAGE(I,IA,K,2,CTY)=0.0
                        PRDAGE(I,IA,K,2,CTY)=BIOAGE(I,IA,K,2,CTY) &
                        *CMX(IA,22,K-1,CTY)*AYL(I-IA+1,K,2,CTY)              ! Calculate Production by "Age".
                        IF(PRDAGE(I,IA,K,2,CTY)>0) THEN
                            PT(NPT,I,7,1+K,CTY) = PT(NPT,I,7,1+K,CTY)+BIOAGE(I,IA,K,2,CTY)       ! Calculate Acres Harvested
                        END IF
                        PT(NPT,I,6,1+K,CTY) =PT(NPT,I,6,1+K,CTY) + PRDAGE(I,IA,K,2,CTY)          ! Calculate Production by year
                    END DO
                ENDIF
            ENDDO
            IF(I>=4)IP=1
        !--
            RETURN
            END SUBROUTINE PASTOUTLP
        !   ************************************************************************************************
            SUBROUTINE PASTSTOC
            IMPLICIT NONE

        !--
        !--   wait until now to assign yields to pastureland crops in case there was a change in the devy.for file....
        !--   stochastic runs...want to make sure they 'plan' using the non-stoch yields...and then assign for the output
        !--
            T=2
            DO K=9,11
                CYX(25,K,T,CTY)= CYX(25,K,1,CTY)
            ENDDO
            DO K=16,17
                CYX(25,K,T,CTY)= CYX(25,K,1,CTY)
            ENDDO

            RETURN
            END SUBROUTINE PASTSTOC

        !     ****************************************************************************************************
            SUBROUTINE PERCNT
            IMPLICIT NONE

            !EIA add
            INTEGER ::  IDB, NYRSIM, ISTART, IEND, NCROPS, NVARC, NVARX, NPRODS, NVARPC, NVARPX, NLVSK, NVARS, NVARXS, NXCR
            INTEGER :: NSAU, NPGA, NVARXA, IO, J, NVARA, NPGXA, IJ
        !--
        !--   VER. 1.0
        !--
        !--                          *****************
        !-- ***********************  PERCNT SUBROUTINE  ***********************
        !--                          *****************
        !--
        !--          **********************************
        !--          * THIS SUBROUTINE IS CALLED FROM *
        !--          * MAIN.FOR                       *
        !--          **********************************
        !--
        !--  ****** COMPUTES SIMULATION RESULTS AS PERCENT OF BASE ******
        !--
        !--             AUXILLARY WRITE STATEMENTS (UNIT NO., 0 SCREEN, -1 OFF)
        !--

            IDB = INDEX(25)
        !--
        !--

        !--
        !--
        !--             SET THE NUMBER OF YEARS SIMULATED
        !--
            NYRSIM = INDEX(1)
        !--
            ISTART = INDEX(30)-INDEX(27)+3
            IEND = NYRSIM+(INDEX(30)-INDEX(27))+2
        !--
        !--             NUMBER OF CROPS IN POLYSYS
        !--
            NCROPS = INDEX(2)
        !--
        !--             NUMBER OF VARIABLES IN C
        !--
            NVARC = INDEX(3)
        !--
        !--             NUMBER OF VARIABLES IN X
        !--
            NVARX = INDEX(4)
        !--
        !--             NUMBER OF MODEL PRODUCTS IN POLYSYS
        !--
            NPRODS = INDEX(43)
        !--
        !--             NUMBER OF VARIABLES IN PC (2ND SUBSCRIPT), ALSO PB
        !--
            NVARPC = INDEX(45)
        !--
        !--             NUMBER OF VARIABLES IN PX AND PXB (2ND SUBSCRIPT)
        !--
            NVARPX = INDEX(46)
        !--
        !--             NUMBER OF MODEL LIVESTOCK COMMODITIES IN POLYSYS
        !--
            NLVSK = INDEX(5)
        !--
        !--             NUMBER OF VARIABLES IN S (2ND SUBSCRIPT), ALSO SB
        !--
            NVARS = INDEX(6)
        !--
        !--             NUMBER OF VARIABLES IN XS (2ND SUBSCRIPT)
        !--
            NVARXS = INDEX(7)
        !--
        !--             NUMBER OF VARIABLES IN XCR LIVESTOCK MATRIX
        !--
            NXCR = INDEX(9)
        !--
        !--             NUMBER OF VARIABLES IN SAU LIVESTOCK MATRIX
        !--
            NSAU = INDEX(10)
        !--
        !--             NUMBER OF PAGES IN A (3RD SUBSCRIPT)
        !--
            NPGA = INDEX(12)
        !--
        !--             NUMBER OF VARIABLES IN A (2ND SUBSCRIPT)
        !--
            NVARA = INDEX(13)
        !--
        !--             NUMBER OF PAGES IN XA (3RD SUBSCRIPT)
        !--
            NPGXA = INDEX(8)
        !--
        !--
        !--             NUMBER OF VARIABLES IN XA (2ND SUBSCRIPT)
        !--
            NVARXA = INDEX(14)
        !--
        !--             SET 'UNIT' NUMBER FOR THE WRITE STATEMENTS
        !--
            IO = INDEX(21)
        !--
        !--
        !--        COMPUTE PERCENTAGES
        !--
        !--       LOOP AROUND YEARS
        !--
            DO I = ISTART,IEND
            !--
            !--             CROPS
            !--
                DO K = 1,NCROPS
                    DO J = 1,NVARC
                        IF(B(I,J,K)/=0.0)THEN
                            C(NPT,I,J,K) = (C(NPT,I,J,K)-B(I,J,K))/B(I,J,K)*100
      ELSE
                            IF ((J == 16) .AND. (K == 5)) THEN
                            !              write(*,*)'value of B ->',B(I,J,K)
                            !              write(*,*)'value of C ->',C(NPT,I,J,K)
                            !              write(*,*)'I ->',I
                            !              PAUSE 11
      ENDIF
                            IF(C(NPT,I,J,K)/=0.0)C(NPT,I,J,K) = 999.99
                        ENDIF
                    END DO
                !--
                    DO J = 1,NVARX
                        IF(XB(I,J,K)/=0.0)THEN
                            X(I,J,K) = (X(I,J,K)-XB(I,J,K))/XB(I,J,K)*100
                        ELSE
                            IF(X(I,J,K)/=0.0)X(I,J,K) = 999.99
                        ENDIF
                    END DO
                END DO
            !--
            !--
            !--             ENERGY CROPS
            !--
                DO K = 1,NCROPS
                    DO J = 1,6
                        IF(ENB(I,J,K)/=0.0)THEN
                            EN(NPT,I,J,K) = (EN(NPT,I,J,K)-ENB(I,J,K))/ENB(I,J,K)*100
                        ELSE
                            IF(EN(NPT,I,J,K)/=0.0)EN(NPT,I,J,K) = 999.99
                        ENDIF
                    END DO
                ENDDO
            !--
            !--            PRODUCTS
            !--
                DO K = 1,NPRODS
                    DO J = 1,NVARPC
                        IF(PB(I,J,K)/=0.0)THEN
                            PC(NPT,I,J,K) = (PC(NPT,I,J,K)-PB(I,J,K))/PB(I,J,K)*100
                        ELSE
                            IF(PC(NPT,I,J,K)/=0.0)PC(NPT,I,J,K) = 999.99
                        ENDIF
                    END DO
                !--
                    DO J = 1,NVARPX
                        IF(PXB(I,J,K)/=0.0)THEN
                            PX(I,J,K) = (PX(I,J,K)-PXB(I,J,K))/PXB(I,J,K)*100
                        ELSE
                            IF(PX(I,J,K)/=0.0)PX(I,J,K) = 999.99
                        ENDIF
                    END DO
                END DO
                IF(CRMRB(I)/=0.0) THEN
                    CRMR(I) = (CRMR(I) - CRMRB(I)) / CRMRB(I)
                ELSE
                    IF(CRMR(I)/=0.0)CRMR(I) = 999.999
                END IF
            !--
            !--             LIVESTOCK
            !--
                DO K = 1,NLVSK
                    DO J = 1,NVARS
                        IF(SB(I,J,K) /= 0.0)THEN
                            S(NPT,I,J,K) = (S(NPT,I,J,K)-SB(I,J,K))/SB(I,J,K)*100
                            IF(SB(I,J,K) <= 0)S(NPT,I,J,K)=-S(NPT,I,J,K)            !THIS IS FOR NEG NET RETURN BASELINE VALUES
                        ELSE
                            IF(S(NPT,I,J,K) /= 0.0)S(NPT,I,J,K) = 999.99
                        ENDIF
                    END DO
                !--
                    DO J = 1,NVARXS
                        IF(XSB(I,J,K) /= 0.0)THEN
                            XS(NPT,I,J,K) = (XS(NPT,I,J,K)-XSB(I,J,K))/XSB(I,J,K)*100
                        ELSE
                            IF(XS(NPT,I,J,K) /= 0.0)XS(NPT,I,J,K) = 999.99
                        ENDIF
                    END DO
                END DO
            !--
                DO IJ = 1,3
                    DO J = 1,NSAU
                        IF(SAUB(I,J,IJ) /= 0.0)THEN
                            SAU(I,J,IJ) = (SAU(I,J,IJ)-SAUB(I,J,IJ))/SAUB(I,J,IJ)*100
                        ELSE
                            IF(SAU(I,J,IJ) /= 0.0)SAU(I,J,IJ) = 999.99
                        ENDIF
                    END DO
                END DO
            !--
                DO J = 1,NXCR                                         !CHAD ADDED
                    IF(XCRB(I,J) /= 0.0)THEN
                        XCR(NPT,I,J) = (XCR(NPT,I,J)-XCRB(I,J))/XCRB(I,J)*100
                    ELSE
                        IF(XCR(NPT,I,J) /= 0.0)XCR(NPT,I,J) = 999.99
                    ENDIF
                END DO
            !--
            !--
            !--       AGGREGATE
            !--
                DO K = 1,NPGA
                    DO J = 1,NVARA
                        IF(AB(I,J,K)/=0.0)THEN
                            A(NPT,I,J,K) = (A(NPT,I,J,K)-AB(I,J,K))/AB(I,J,K)*100
                        ELSE
                            IF(A(NPT,I,J,K)/=0.0)A(NPT,I,J,K) = 999.99
                        ENDIF
                    END DO
                END DO
            !--
                DO K = 1,NPGXA
                    DO J = 1,NVARXA
                        IF(XAB(I,J,K)/=0.0)THEN
                            XA(I,J,K) = (XA(I,J,K)-XAB(I,J,K))/XAB(I,J,K)*100
                        ELSE
                            IF(XA(I,J,K)/=0.0)XA(I,J,K) = 999.99
                        ENDIF
                    END DO
                END DO

            !--
            END DO       ! End of Loop around Years
        !--
        !--             COMPUTE AVERAGES FOR THREE PERIODS IF DESIRED
        !--
            IF(INDEX(34)/=0)CALL AVGVAL
      RETURN
            END SUBROUTINE PERCNT

        !     ************************************************************************************************
            SUBROUTINE PERMINLP
       IMPLICIT NONE

            REAL :: XTLAND=0.0,XNETLAND=0.0,TotalNFX=0.0,TotalOFX=0.0
            REAL :: RETOCC=0.0,DFPYRT=0.0,DFPYRTB=0.0
            REAL :: ARPCHNG=0.0,O92CHNG=0.0,ACRCHNG=0.0,LANDN6=0.0
            REAL :: SIMCOST=0.0,MKTRET=0.0,PGMRET=0.0, TOTALAREA = 0.0
            REAL :: PASTPOS=0.0,PASTNEW=0.0,CNRATIO=0.0
            REAL,DIMENSION(15)                  :: PRCTCROP = 0.0
           ! REAL,DIMENSION(3111) :: QPRIEXP=0.0 !,QPRIEXPB=0.0
            INTEGER ::  xxx,yyy,Z
          !  CHARACTER(20) :: LPNUMBER
            REAL, DIMENSION(12,15)  :: HOLDLR=0.0,HOLDAR=0.0
            REAL, DIMENSION(8) :: ARET,ACHECK,CROPPLD
            !EIA add
            INTEGER :: NCROPS, iYEAR1, ICON
            REAL :: PERMAX
        !--
        !--
        !--   *****************************************************************************
        !--   This subroutine is copied off of input2lp but for pasture acres
        !--   *****************************************************************************
            NCROPS=7 !5 !4!2        ! Number ALTERNATIVE CROPS
            IYEAR1 = INDEX(30) ! FIRST YEAR OF SIMULATION

        !--
        !c      DO K=1,NCROPS
            MINBIO(9,3) = 0.0
        !c      END DO
        !--   ****************begin to fill the LPA'S******************************************************************
        !--
        !--   LOOP ACROSS CROPS
            DO K = 1,NCROPS
            !--      SET MATRIX PROFIT EQUAL TO NET PRESENT VALUE
                LPA(1,K) = -PT(NPT,I,2,13+K,CTY)
            END DO
        !--
            DO Z=1,47 !33 !17 !9!183   !SAME AS YYY
                IF(ABS(LPA(1,Z)) == 0.0) LPA(1,Z) = 0.0 ! If LPA = 0 it does not enter LP with minus(-) sign.
            END DO
        !--
        !--   ****************begin to fill the RIGHT HAND SIDES******************************************************************
        !--
            DO ICON = 1,500
                RHS(ICON) = 0.0  ! Refresh the RHS values
            END DO
        !--
            XTLAND = 0.0       ! XTLAND = Summation of All Acres Change in Crops
        !--
            DO K = 1,NCROPS
            !--
            !--
            !--      The base planted acres from which to calculate the acres available
            !--      to the LP is given by the following statement.
                IF(PT(NPT,I-1,1,13+K,CTY) == 0.0 .AND. I < 7)THEN  !make sure comes here first year
                    PT(NPT,I,1,13+K,CTY) = PTB(I,1,13+K,CTY)
                ELSE
                !C           PT(NPT,I,1,K,CTY) = PTB(I,1,K,CTY)
                    PT(NPT,I,1,13+K,CTY) = PT(NPT,I-1,1,13+K,CTY)
                ENDIF

            !--
            !--
                XTLAND = XTLAND + PTB(I,1,13+K,CTY)                            !total acres must be equal to baseline!!
            !--
                3476 CONTINUE
            !--
            ENDDO
        !--
            DO K=1,NCROPS                !NCROPS IS ONLY THE CROPS IN PASTURE MATRIX HERE!!
            !--
            !C         IF(PT(NPT,I,1,K,CTY).EQ.0.0)LPA(1,K)=0.0                           !IF NO ACRES, THEN SET NPV TO ZERO FOR LP
            !--
                PERMAX = 0.125*(1.20)**(I-5)
                IF (PERMAX>1.0)PERMAX=1.00
            !--
            !--     MAX
                RHS(2+K) = PT(NPT,I,1,13+K,CTY)                                & !SECOND
                +  PTB(I,1,14,CTY)*0.1*PERMAX
            !--
                IF(K >= 2 .AND. K <= 4)THEN
                    IF(CYX(25,7+K,1,CTY) == 0.0)RHS(2+K)=0.0     !IF NO YIELD, THEN  CAN'T GROW HERE!!
                    ENDIF
                    IF(K == 5)THEN
                        IF(CYX(25,13,1,CTY) == 0.0)RHS(2+K)=0.0
                    ENDIF
                    IF(K == 6)THEN
                        IF(CYX(25,16,1,CTY) == 0.0)RHS(2+K)=0.0
                    ENDIF
                    IF(K == 7)THEN
                        IF(CYX(25,17,1,CTY) == 0.0)RHS(2+K)=0.0
                    ENDIF
                !--
                !--     MIN
                    IF(K == 2)THEN     !IF SWITCHGRASS
                        IF(BIOPL(NPT,I-1,1,3,CTY) > 0)THEN
                            IF(I-IRTLN(9) < 4) THEN
                                RHS(2+NCROPS+K) = BIOPL(NPT,I-1,1,3,CTY)
                            ELSE
                                RHS(2+NCROPS+K) = BIOPL(NPT,I-1,1,3,CTY) &
                                - APL(NPT,I-IRTLN(9),1,3,CTY)
                            END IF
                        ELSE
                            RHS(2+NCROPS+K) = 0.0
                        ENDIF
                    !--
                    ELSEIF(K == 6 .OR. K == 7)THEN     !IF miscanthus
                        IF(BIOPL(NPT,I-1,K-1,3,CTY) > 0)THEN
                            IF(I-IRTLN(10+K) < 4) THEN
                                RHS(2+NCROPS+K) = BIOPL(NPT,I-1,K-1,3,CTY)
                            ELSE
                                RHS(2+NCROPS+K) = BIOPL(NPT,I-1,K-1,3,CTY) &
                                - APL(NPT,I-IRTLN(10+K),K-1,3,CTY)
                            END IF
                        ELSE
                            RHS(2+NCROPS+K) = 0.0
                        ENDIF
                    !--
                    !--
                    ELSEIF(K == 3 .OR. K == 4 .OR. K == 5)THEN         !IF WILLOWS,POPLARS,algae
                        IF(BIOPL(NPT,I-1,K-1,3,CTY) > 0)THEN
                            IF(I-IRTLN(10+K) < 4) THEN
                                RHS(2+NCROPS+K) = BIOPL(NPT,I-1,K-1,3,CTY)
                            ELSE
                                IF(K == 3)THEN !POPLARS
                                    RHS(2+NCROPS+K) = BIOPL(NPT,I-1,K-1,3,CTY) &
                                    - APL(NPT,I-IRTLN(10+K),K-1,3,CTY)    & !APL WAS MADE TO ONLY HAVE 'INCREMENTAL PLANTINGS
                                    * RRR(10,CTY)                       !NOW MAKE IT ALL THOSE ACRES THAT WERE CONVERTED AT BEGINNING OF ROTATION
                                ELSEIF(K == 4)THEN !WILLOWS
                                    RHS(2+NCROPS+K) = BIOPL(NPT,I-1,K-1,3,CTY) &
                                    - APL(NPT,I-IRTLN(10+K),K-1,3,CTY) &
                                    * RRR(11,CTY)
                                ELSE
                                    RHS(2+NCROPS+K) = BIOPL(NPT,I-1,K-1,3,CTY) &
                                    - APL(NPT,I-IRTLN(10+K),K-1,3,CTY)
                                END IF
                            ENDIF
                        ELSE
                            RHS(2+NCROPS+K) = 0.0
                        ENDIF

                        RHS(2+NCROPS+K)=PT(NPT,I-1,1,13+K,CTY)         !!caution, should this be here?
                    !--
                    ELSE               !IF PASTURE      K=1
                    !--
                        IF(CYX(2,1,1,CTY) >= 250)THEN
                            RHS(2+NCROPS+K) = PT(NPT,I,1,13+K,CTY) &
                            - PT(NPT,I,1,13+K,CTY)*0.05 !0.05 !0.2                  !MIN IS LAST YEARS - 5% FOR PERMANENT PASTURE WEST OF THE 100 MERIDIAN!!!
                        ELSE
                            RHS(2+NCROPS+K) = PT(NPT,I,1,13+K,CTY) &
                            - PT(NPT,I,1,13+K,CTY)*0.1 !0.10 !0.2                  !MIN IS LAST YEARS - 10% FOR PERMANENT PASTURE EAST OF THE 100TH MERIDIAN!!!
                        ENDIF
                        IF(RHS(2+NCROPS+K) <= 0.0)RHS(2+NCROPS+K)=0.0
                    ENDIF
                    IF(K >= 2 .AND. K <= 4) MINBIO(7+K,3) = RHS(2+NCROPS+K) !SWITCHGRASS,POP,WILL
                    IF(K >= 6 .AND. K <= 7) MINBIO(10+K,3)= RHS(2+NCROPS+K) !MISCANTHUS, ECANE
                !--
                END DO
            !--
            !--     HAYLANDS
                LPA(17,2) =-PT(NPT,I,5,1,CTY)  !lpa(down,across)=lpa(total#max constraints+#ofcrop+2,#ofcrop)     !HAY THAT MUST COME IN FOR SWITCHGRASS
                LPA(18,3) =-PT(NPT,I,5,1,CTY)  !THESE ACRES COME OUT OF PASTURELAND IF CONVERTED...SO HAYLANDS ARE ACCOUNTED FOR!!
                LPA(19,4) =-PT(NPT,I,5,1,CTY)   !willows
                LPA(20,5) =-PT(NPT,I,5,1,CTY)   !algae
                LPA(21,6) =-PT(NPT,I,5,1,CTY)   !miscanthus
                LPA(22,7) =-PT(NPT,I,5,1,CTY)   !E.cane
            !--
                LPA(17,8) = 1
                LPA(18,9) = 1
                LPA(19,10) = 1
                LPA(20,11) = 1
                LPA(21,12) = 1
                LPA(22,13) = 1
            !--
                RHS(17) = 0      !THESE ARE FOR HAY OFFSET RHS'S
                RHS(18) = 0
                RHS(19) = 0
                RHS(20) = 0
                RHS(21) = 0
                RHS(22) = 0
            !--
                RHS(2) = XTLAND
            !--
            !--   The following statements write the LP of a particular crdl to a TXT file (update aug 2020)
            !      IF(CTY.EQ.2447) THEN    !loudon, tn
            ! 2424    FORMAT('  ',99F15.2)
            !x         IF(I.EQ.12) THEN
            !            LPNUMBER='PSin3.TXT'
            !            OPEN(UNIT=77,FILE=LPNUMBER)
            !            WRITE(77,*)CTY
            !            DO ICOUNT = 1,99                                           !!xxx
            !              WRITE(77,2424)RHS(ICOUNT),(LPA(ICOUNT,IACT),IACT=1,47)   !!vn     slack variables=shadow prices in first row of lpa!!
            !            END DO
            !            CLOSE(77)
            !            WRITE(*,*)'DONE WRITING PSin3->',CTY
            !x        END IF
            !      END IF
            !--
            !--
                RETURN
                END SUBROUTINE PERMINLP

            !     *********************************************************************************************************
                SUBROUTINE PERMLPSIM
                IMPLICIT NONE

                DOUBLE PRECISION :: pivot,snum,store(1000)                   !500
                DOUBLE PRECISION ::  BIGM,OBJMAX
                INTEGER :: VarNum,RowNum,NumIter
                INTEGER :: x,y,TotalVar,scol,srow,OPTIMIZED,num
                CHARACTER(11) :: LPNUMBER
                !EIA add
                INTEGER :: IYEAR1, IX, NV, ICOLUMNS, IROWS, IM, INFEASIBLE
            !--
            !--
                IF(RHS(2) == 0.0)GOTO 999
            !--
            !--             FIRST YEAR OF SIMULATION
            !--
                IYEAR1 = INDEX(30)
            !--
            !--             AUXILLARY WRITE STATEMENTS (UNIT NO., 0 SCREEN, -1 OFF)
            !--

            !--
            !--
                do ix=1,500               !!500
                    store(ix) = 0
                end do
            !--
            !--    ***************************************************************************
            !--    This subroutine contains a Linear Programming algorithm specifically
            !--    customized for RASS, and taylor to solve a maximization problem with
            !--    LT constraints only. The subrouitne is called from INPUT2LP.
            !--    ***************************************************************************
            !--
            !--   Set value for BIGM
            !--
            !c       BIGM = 100000000000000000000000000000000000.00
                BIGM = 100000000.0
            !--
                M1 = 8 !6 !5!5!3!49!37                           ! Less than constraints
                M2 = 13 !9 !7!5!4!2!48!36                           ! Greater than constrains is counted in INPUT2LP subroutine    !!this was commented
                M3 =  0!1                           ! Equal to constraints
                M  = M1 + M2 + M3                  ! Total number of constraints
                NV = 13 !9 !7!5!4!2!36                            ! Number of activities
            !--
            !--   The number of elements of the RHR solution needs to be pre-specified. It is
            !--   given by the sum of the number of activities and the number of constraints.
            !--
                VarNum = NV
                RowNum = M
                TotalVar = VarNum + RowNum
            !--
            !--    Big M SIMPLEX ALGORITHM : SETUP
            !--
            !--     Step 1 : is skipped because all RHS values are > or = to 0
            !--
            !--     Step 1': Identify greater(M2) than and equal to constraints(M3)
            !--     M1 = less than constraints, M2 = greater than constraints, M3 = equal to constraints
            !--     Objective function values = RHS(1)
            !--     First M1 constraint = RHS(2)
            !--     First M2 constraint = RHS(1+M1+1)
            !--     First M3 constraint = RHS(1+M1+M2+1)
            !--
            !--     Step 2 : Convert each inequality constraint to the standard form.
            !--     For constraints of the form LESS THAN then :
            !--     add a slack variable (1- diagonally).
            !--
                do x = 1,M1
                    LPA(x+1,NV+x) = 1
                end do
            !--
            !--     For constraints of the form GREATER THAN OR EQUAL TO then :
            !--     substract an excess variable (-1,diagonally).
            !--
                do x = 1,M2
                    LPA(1+M1+x,NV+M1+x) = -1                                          !these are not being printed
                end do
            !--
            !--     Step 3: For constraints "? or "=", add an artificial variable to
            !--             each constraint
            !--
                do x = 1,M2+M3
                    LPA(1+M1+x,NV+M1+M2+x) = 1
                end do
            !--
            !--     Step 4 : Since our problem is a maximization problem, add (for each
            !--              artificial variable 'a') -Mai to the objective function.
            !--
                do x = 1,NV+M1+M2+M2+M3
                    if(x > NV+M1+M2) then
                        LPA(1,x) = BIGM
                    end if
                end do
            !--
            !--     Step 5 : Since each artificial variable will be in the starting basis,
            !--              all artificial variables must be eliminated from row 1 before
            !--              begining the simplex. This ensures we begin with a canonical
            !--              form. In choosing the entering variable remember that M is a
            !--              very large positive number.  After this transformation solve
            !--              the LP applying the Simplex.  If all artificial variables are
            !--              equal to Zero (0) in the optimal solution, the optimal solution
            !--              to the original problem has been found. If any artificial
            !--              variables is positive in the optimal solution, the original
            !--              problem is infeasible.
            !--
                do y = 1,NV+M1+M2+M2+M3
                    do x = 1,M2+M3
                        LPA(1,y) = LPA(1,y) - LPA(1+M1+x,y)*BIGM
                    end do
                end do
            !--
                RHS(1) = 0
            !--
                icolumns = NV+M1+M2+M2+M3
                irows = 1 + M1 + M2 + M3
            !--
                TotalVar = icolumns
                RowNum = irows - 1
            !--
            !--    To put all index of RHR. As activities come into the solution the elements
            !--    of NAME(x) change from 0 to the column number of the activity.
            !--
                do x = 1,500                      !!500
                    NAME(x) = 0
                end do
            !--
            !--  *****************************************************************
            !--
            !--                 ITERATIVE SIMPLEX PROCEDURE
            !--
            !--  *****************************************************************
            !--
            !-- THE ITERATIVE SIMPLEX PROCEDURE STARTS BY CHECKING IF THE INITIAL
            !-- SOLUTION IS OPTIMIZED.
            !--
                OPTIMIZED = 0
                NumIter = 1
                do while ( OPTIMIZED /= 1)
                    num = 0
                !--
                    do x=1,TotalVar
                        if (LPA(1,x) >= 0.0) then
                            num = num + 1
                        end if
                    end do
                !--
                    if (num == TotalVar) OPTIMIZED = 1
                !--
                    if (OPTIMIZED == 0)then
                    !--
                    !--  BELOW WILL SELECT THE LARGEST -VE VALUE IN THE FIRST ROW Z
                    !--  scol is the selected column with the largest -ve Z
                    !--
                        snum = 999999999.9999                                                !!!!12 NINES
                    !--
                        do y=1,TotalVar
                            if (LPA(1,y) < snum) then
                                snum = LPA(1,y)
                                scol = y
                            end if
                        end do
                    !--
                    !-- AFTER SELECTING THE RIGHT COLUMN, SELECT THE +VE VALUES IN THE SELECTED
                    !-- COLUMN TO DIVIDE ALL RHR. THEN SELECT THE SMALLEST RESULT AND THAT WILL
                    !-- BE THE SELECTED ROW.
                    !-- ROW SHOULD START FROM 2 INSTEAD OF 1 BECAUSE ROW 1 HAS THE OBJ FUNCTION.
                    !--
                        do x = 2,RowNum+1
                            if (LPA(x,scol) <= 0.000000001) then                             !!!14 ZEROS AFTER .
                                store(x) = 1.e9                                              !!!1.e12
                            else
                                store(x) =(RHS(x)/LPA(x,scol))
                            end if
                        end do
                    !--
                    !-- THE FOLLOWING STATEMENT IDENTIFIES SELECTED ROW(SROW)
                    !--
                        snum = 999999999.9999                                               !!!10 NINES
                        do x=2,RowNum+1
                            if(store(x) < snum) then
                                snum = store(x)
                                srow = x
                            end if
                        end do
                    !--
                    !-- USING SELECTED ROW (SROW) AND SELECTED COLUMN (SCOL), WE IDENTIFY THE
                    !-- THE PIVOT ELEMENT.
                    !--
                        pivot = LPA(srow,scol)
                        NAME(scol) = srow
                        do x = 1,TotalVar + 1
                            if((x /= scol) .AND. (NAME(x) == srow))then
                                NAME(x) = 0
                            end if
                        end do
                    !--
                    !-- BELOW IS TO COMPUTE THE VALUES OF THE NEW BASIC VARIABLES IN THE NEXT
                    !-- TABLEAU.
                    !--
                        do y = 1,TotalVar
                            LPA(srow,y) = (LPA(srow,y) / pivot)
                        end do
                        RHS(srow) = (RHS(srow) / pivot)
                    !--
                    !-- TO COMPUTE THE NEW VALUES FOR THE NEXT TABLEAU, WE USE THE FOLLOWING
                    !-- FORMULA, new row = old row -(pivot column coefficient)*new pivot row
                    !-- THE VALUES OF PIVOT COLUMN COEFFICIENT, ARE rstore IN store(i)
                    !-- THE NEW PIVOT ROW IS THE ONE COMPUTED ABOVE.
                    !--
                        do x = 1, RowNum + 1
                            store(x) = LPA(x,scol)
                        end do
                    !--
                        do x = 1, RowNum + 1
                            if ((x /= srow) .AND. (store(x)/= 0.0)) then
                            !--
                                do y=1,TotalVar
                                    if(y==scol) then
                                        LPA(x,y) = 0.0
                                    else
                                        LPA(x,y) = LPA(x,y) - (store(x)*LPA(srow,y))
                                    end if
                                end do
                            !--
                                RHS(x) = RHS(x)-(store(x)*RHS(srow))
                                if (RHS(x) < +1.E-8)then
                                    RHS(x) = 0.0
                                end if
                            end if
                            IF(CTY == 2109)THEN
                            !c                WRITE(*,*)X,RHS(X),NAME(X),RHS(NAME(X)),numiter
                            ENDIF
                        end do
                        IF(CTY == 2109)THEN
                        !c      PAUSE
                        ENDIF
                    !--
                        NumIter = NumIter + 1
                        IF (NumIter > 222) THEN
                               WRITE(*,*)'NON OPTIMAL SOL 2.:Exceeded Max Num of Iter ->',CTY
                            EXIT
                        END IF
                    end if
                end do
            !--
            !        INDEX(24) = -7
                INFEASIBLE = 0
                DO IM=NV+M1+M2+1,TotalVar
                    IF(NAME(IM)==0) GOTO 2423
                    IF(RHS(NAME(IM))>0.1) THEN
                        INFEASIBLE =1
                        IF(INFEASIBLE==1) GOTO 2424
                    END IF
                    2423 CONTINUE
                END DO
                2424 CONTINUE
                IF(INFEASIBLE==1) THEN
                    WRITE(*,*)'Infeasible LP in permpast->',cty,' ',' ',cty
                !C        PAUSE
                    DO IM = NV+M1+M2+1,TotalVar
                        IF(NAME(IM)>0) THEN
                            WRITE(*,*)'SOL',IM,RHS(IM),NAME(IM),RHS(NAME(IM))
                        ELSE
                            WRITE(*,*)'SOL',IM,RHS(IM),NAME(IM),0
                        END IF
                    END DO
                !         INDEX(24) = -9
                !          PAUSE 23
                END IF
            !--
            !--   The following statements write the LP of a particular crdl to a TXT file
            !--
                999 CONTINUE
                return
                END SUBROUTINE PERMLPSIM
!*******************************************************************************************************************************
                SUBROUTINE PERMNPV
                IMPLICIT NONE

                INTEGER :: IIYEAR(41)
                REAL :: PASTCOST,PORTINTEG
                !EIA add
                INTEGER :: IYEAR1, NYRSIM,ISTART, IEND, IYR, III, NCROPS, IPLAN, IB
                REAL :: FLOW, REVENUES
            !--
            !      WRITE(*,*)'IN NPVALUE ILOOP = ',ILOOP
                IYEAR1 = INDEX(30)      ! FIRST YEAR OF SIMULATION
            !--
                NYRSIM = INDEX(1)
                ISTART = INDEX(30)-INDEX(27)+3
                IEND = NYRSIM+(INDEX(30)-INDEX(27))+2
                IYR = INDEX(30) - 2
            !--
                DO III=ISTART-2,IEND
                    IIYEAR(III) = IYR
                    IYR = IYR + 1
                END DO
            !--

                FLOW = 0
                REVENUES = 0
                DRATE = 0.065         ! DISCOUNT RATE
                NCROPS = 2              !THIS IS ALTERNATIVE CROPS
                IPLAN = 100 !30 !20              ! LENGTH OF PLANNING PERIOD             !was 16
                IF(INDEX(1)>INDEX(28)) THEN
                    IB = INDEX(1)
      ELSE
                    IB = INDEX(28)
                END IF
            !C      DRATE = DRATEK(I,K)
            !--
            !--
            !--   CROPLAND IN PAST NPV
                FLOW = PASTRENT(i,CTY)
                PT(NPT,I,2,14,CTY) = 0.0
                DO INPV = 1,IPLAN
                    PT(NPT,I,2,14,CTY) = PT(NPT,I,2,14,CTY) + FLOW/(1+DRATE)**INPV
                ENDDO
            !--
            !--
            !--   SWITCHGRASS,POPLARS, AND WILLOWS  NPV     K=2=POPLARS K=3=WILLOWS
                DO K=1,3
                !c       IF(K.EQ.1)THEN
                !c        PT(NPT,I,2,14+K,CTY) = NPV(NPT,I,9,3,CTY)        !SWITCHGRASS NPV(NPT,i,k,t,cty)
                !c       ELSE
                    PT(NPT,I,2,14+K,CTY) = 0.0
                    DO INPV = 1, IPLAN
                      !   REVENUES = CYX(25,8+K,3,CTY)*CMX(INPV,22,K,CTY) * C(NPT,I,9,8+K)*CYX(3,8+K,3,CTY) !price index for EIA   (region change version)
                         REVENUES = CYX(25,8+K,3,CTY)*CMX(INPV,22,K,CTY)*PRIC(8+K,CTY) !update from UT 2019
                          IF(K.EQ.2.AND.INDEX(115).EQ.1)REVENUES=REVENUES/RRR(10,CTY) !*1.10 !IF POPLARS, ONLY HARVESTING 1/RRR OF EVERY ACRE       !10% predictive yield boost
                          IF(K.EQ.3.AND.INDEX(115).EQ.1)REVENUES=REVENUES/RRR(11,CTY) !IF WILLOWS, ONLY HARVESTING 1/4 OF EVERY ACRE

                    !--
                    !--
                    !--      ***FIGURE COSTS AND ADD CONVERSION COST OF 'INTENSIFICATION' TO THE COST OF BIOMASS CROPS
                        IF(INPV == 1)THEN
                            IF(K == 2 .AND. INDEX(115) == 1)THEN
                                PASTCOST = CMX(INPV,21,K,CTY)+ 100*PT(NPT,I,5,1,CTY)/RRR(10,CTY)
                            ELSEIF(K == 3 .AND. INDEX(115) == 1)THEN
                                PASTCOST = CMX(INPV,21,K,CTY)+ 100*PT(NPT,I,5,1,CTY)/RRR(11,CTY)
                            ELSE
                                PASTCOST = CMX(INPV,21,K,CTY)+ 100*PT(NPT,I,5,1,CTY)   !EXTRA COST OF BREAKING PASTURE INTO HAY ($20*HAY ACREAGE THAT MUST COME IN) OR 'COST OF INTENSIFICATION'
                            ENDIF
                        ELSE
                            IF(K == 2 .AND. INDEX(115) == 1)THEN
                                PORTINTEG = INPV/RRR(10,CTY)
                                IF(PORTINTEG > 1.0)PORTINTEG=1.0
                                PASTCOST = CMX(INPV,21,K,CTY) + 15*PT(NPT,I,5,1,CTY)*PORTINTEG
                            ELSEIF(K == 3 .AND. INDEX(115) == 1)THEN
                                PORTINTEG = INPV/RRR(11,CTY)
                                IF(PORTINTEG > 1.0)PORTINTEG=1.0
                                PASTCOST = CMX(INPV,21,K,CTY) + 15*PT(NPT,I,5,1,CTY)*PORTINTEG
                            ELSE
                                PASTCOST = CMX(INPV,21,K,CTY) + 15*PT(NPT,I,5,1,CTY)
                            ENDIF
                        ENDIF
                    !--
                    !--
                        FLOW = REVENUES - PASTCOST                                               & !J=20=TOTAL COSTS PER ACRE
                        + INCENT(1,8+K,3,CTY)                                 & ! INCENTIVE PER ACRE FOR TILLAGE SYSTEM (1/7/07)
                        - INCENT(6,8+K,3,CTY)                                 & ! TOTAL ADDITIONAL COSTS FROM CARBON PRICE  !COMPUTED IN COSTCHG.FOR
                        - INCENT(11,8+K,3,CTY)                               ! TOTAL ADDITIONAL COSTS FROM ENERGY PRICE INCREASE
                    !--
                    !--
                    !--     ***** AFFORESTATION CREDIT ****
                    !c         IF(INDEX(80).EQ.1.AND.C(I,9,8+K).EQ.0)THEN
                    !c          FLOW = FLOW
                    !c     1         + CYX(25,8+K,1,CTY) *.5 * (CARBINCT(I)*0.9)                !ANNUAL WOOD YIELD * 0.5 * (CARBON PRICE *.9) = CARBON ACCUMULATION * INCENTIVE PRICE (IN METRIC TONS C)
                    !c         ENDIF
                    !--      *********************************
                    !--
                        PT(NPT,I,2,14+K,CTY) = PT(NPT,I,2,14+K,CTY) + FLOW/(1+DRATE)**INPV                !PT(NPT,I,J,K,CTY) K=3=POPLARS
                    ENDDO
                !c       ENDIF
                ENDDO
            !--
            !--    ***ALGAE NPV***
                PT(NPT,I,2,18,CTY) = 0.0
                DO INPV = 1, IPLAN
                    REVENUES = CYX(25,13,1,CTY)*C(NPT,I,9,13)  !YIELD * PRICE
                !--
                    IF(INPV == 1)THEN
                        PASTCOST = CYX(23,13,1,CTY)+ 100*PT(NPT,I,5,1,CTY)   !EXTRA COST OF BREAKING PASTURE INTO HAY ($20*HAY ACREAGE THAT MUST COME IN)
                    ELSE
                        PASTCOST = CYX(23,13,1,CTY) + 15*PT(NPT,I,5,1,CTY)
                    ENDIF
                !--
                    FLOW = REVENUES - PASTCOST                                       & !J=20=TOTAL COSTS PER ACRE
                    + INCENT(1,13,2,CTY)                                 & ! INCENTIVE PER ACRE FOR TILLAGE SYSTEM (1/7/07)
                    - INCENT(6,13,2,CTY)                                 & ! TOTAL ADDITIONAL COSTS FROM CARBON PRICE  !COMPUTED IN COSTCHG.FOR
                    - INCENT(11,13,2,CTY)                               ! TOTAL ADDITIONAL COSTS FROM ENERGY PRICE INCREASE
                !--
                    PT(NPT,I,2,18,CTY) = PT(NPT,I,2,18,CTY) + FLOW/(1+DRATE)**INPV
                ENDDO
            !--
            !--
            !--    ***MISCANTHUS NPV***
                PT(NPT,I,2,19,CTY) = 0.0
                DO INPV = 1, IPLAN
                    !REVENUES = CYX(25,16,3,CTY)*CMX(INPV,22,4,CTY)*C(NPT,I,9,16)
                    REVENUES = CYX(25,16,3,CTY)*CMX(INPV,22,4,CTY)*PRIC(16,CTY) !update from UT 2019
                   !  REVENUES = CYX(25,16,3,CTY)*CMX(INPV,22,4,CTY) * C(NPT,I,9,16)*CYX(3,16,3,CTY) !price index for EIA   (region change version)
                !--
                    IF(INPV == 1)THEN
                        PASTCOST = CMX(INPV,21,4,CTY)+ 100*PT(NPT,I,5,1,CTY)   !EXTRA COST OF BREAKING PASTURE INTO HAY ($20*HAY ACREAGE THAT MUST COME IN)
                    ELSE
                        PASTCOST = CMX(INPV,21,4,CTY) + 15*PT(NPT,I,5,1,CTY)
                    ENDIF
                !--
                    FLOW = REVENUES - PASTCOST                                       & !J=20=TOTAL COSTS PER ACRE
                    + INCENT(1,16,2,CTY)                                 & ! INCENTIVE PER ACRE FOR TILLAGE SYSTEM (1/7/07)
                    - INCENT(6,16,2,CTY)                                 & ! TOTAL ADDITIONAL COSTS FROM CARBON PRICE  !COMPUTED IN COSTCHG.FOR
                    - INCENT(11,16,2,CTY)                               ! TOTAL ADDITIONAL COSTS FROM ENERGY PRICE INCREASE
                !--
                    PT(NPT,I,2,19,CTY) = PT(NPT,I,2,19,CTY) + FLOW/(1+DRATE)**INPV     !PT(NPT,I,J,K,CTY) K=3=POPLARS
                ENDDO
            !--
            !-- ***E.CANE NPV***
            !--
                PT(NPT,I,2,20,CTY) = 0.0
                DO INPV = 1, IPLAN
                    !REVENUES = CYX(25,17,3,CTY)*CMX(INPV,22,5,CTY)*C(NPT,I,9,17)
                    REVENUES = CYX(25,17,3,CTY)*CMX(INPV,22,5,CTY)*PRIC(17,CTY) !update from UT 2019
                   ! REVENUES = CYX(25,17,3,CTY)*CMX(INPV,22,5,CTY) *C(NPT,I,9,17)*CYX(3,17,3,CTY) !price index for EIA   (region change version)
                !--
                    IF(INPV == 1)THEN
                        PASTCOST = CMX(INPV,21,5,CTY)+ 100*PT(NPT,I,5,1,CTY)   !EXTRA COST OF BREAKING PASTURE INTO HAY ($20*HAY ACREAGE THAT MUST COME IN)
                    ELSE
                        PASTCOST = CMX(INPV,21,5,CTY) + 15*PT(NPT,I,5,1,CTY)
                    ENDIF
                !--
                    FLOW = REVENUES - PASTCOST                                       & !J=20=TOTAL COSTS PER ACRE
                    + INCENT(1,17,2,CTY)                                 & ! INCENTIVE PER ACRE FOR TILLAGE SYSTEM (1/7/07)
                    - INCENT(6,17,2,CTY)                                 & ! TOTAL ADDITIONAL COSTS FROM CARBON PRICE  !COMPUTED IN COSTCHG.FOR
                    - INCENT(11,17,2,CTY)                               ! TOTAL ADDITIONAL COSTS FROM ENERGY PRICE INCREASE
                !--
                    PT(NPT,I,2,20,CTY) = PT(NPT,I,2,20,CTY) + FLOW/(1+DRATE)**INPV     !PT(NPT,I,J,K,CTY) K=3=POPLARS
                ENDDO
            !--
            !--
            !--
            !--     **Restrict Biomass Crops to years defined in sim.ins**
                IF(IIYEAR(I) < YRHERB)THEN
                    PT(NPT,I,2,15,CTY)=0.0 !SWITCHGRASS
                    PT(NPT,I,2,19,CTY)=0.0 !MISCANTHUS
                    PT(NPT,I,2,20,CTY)=0.0 !ECANE
                ENDIF
                IF(IIYEAR(I) < YRWOODY)THEN
                    PT(NPT,I,2,16,CTY)=0.0 !POPLAR
                    PT(NPT,I,2,17,CTY)=0.0 !WILLOW
      ENDIF
            !--
            !--
       RETURN
                END SUBROUTINE PERMNPV
            !     ****************************************************************************************
                SUBROUTINE PERMOUTLP
      IMPLICIT NONE

                REAL,DIMENSION(65) :: HOLDARP = 0.0,SORTRET=0.0,ACADJ=0.0
                REAL :: TOTALC(3111),TOTALB(3111),DIFPAREA
                INTEGER,DIMENSION(12) :: KKSORT
                !EIA add
                INTEGER :: NCROPS, IYEAR1, IP, G, IB, IA, J, IAGE, IYR, IEND, ISTART, NYRSIM
                REAL :: xtblah, xtblahb, XTCYBLAH
            !--
            !--   *****************************************************************************
            !--   This subroutine captures the solution values from LP's and assigns them
            !--   Also computes BSHIFTS in baseline to bring values back to baseline
            !--   The subroutine is called from RMAIN
            !--   *****************************************************************************
                NCROPS=13 !9 !7!5               !include hay in this number
            !--   FIRST YEAR OF SIMULATION
                IYEAR1 = INDEX(30)
            !--   AUXILLARY WRITE STATEMENTS (UNIT NO., 0 SCREEN, -1 OFF)

            !--   Compute the solution values of the acres shift from the solution of the
            !--   LP.  This values will be always substracted to obatin the baseline back
            !--   when running POLYSYS with no changes, and also to compute simulation
            !--   results away from the baseline.
            !--   Compute the solution values of the acres shift from the baseline solution of the LP.
            !--   These values will be always substracted to obatin the baseline back when running POLYSYS.
            !      WRITE(*,*)'BASELINEDONE->',BASELINEDONE
            !--
            !--
                T=1
            !--

            !--   From here onwards, we are calculating the output using the LP solution.  The LP solution
            !--   for each crop are in RHS(80 to 94); RHS(1) contains the value of the objective function.
                23 FORMAT(I4,I4,I4,F12.2,F12.2,F12.2,F12.2,F12.2,F12.2)
                24 FORMAT(I4,I4,I4,I12,F12.2,F12.2,F12.2,F12.2,F12.2)
                IP = 0
            !--
            !--   ***CAPTURE SHADOW PRICES***
            !--
                DO K=1,NCROPS
                    PT(NPT,I,3,13+K,CTY) = LPA(1,NCROPS+1+K)
      END DO
            !--
            !--
            !--   Simulated Planted Acres = Pl.Ac - Ac.Shift + Sol.From LP - Baseline LP Sol.
            !-      IF (RHS(1).NE.0.0) THEN      !CHECK AND SEE IF CHANGES OCCURRED IN THE MATRIX, IF NOT, THEN NO CHANGES TO ACRES
                xtblah= 0.0
                xtblahb=0.0
                XTCYBLAH=0.0
                DO K = 1,NCROPS
                    IF(NAME(K)>0)THEN
                        PT(NPT,I,1,13+K,CTY) = RHS(NAME(K)) + PSHIFT(K,2,CTY)                !!BASELINE - ACRES PUT INTO LP +ACRES OUT OF LP - BASELINE FIX
                        IF(PT(NPT,I,1,13+K,CTY)<0) PT(NPT,I,1,13+K,CTY) = 0.0
          ELSE
                        PT(NPT,I,1,13+K,CTY) = PSHIFT(K,2,CTY)
                        IF(PT(NPT,I,1,13+K,CTY)<0) PT(NPT,I,1,13+K,CTY) = 0.0
          ENDIF
                !--
                !--
                    IF(NAME(K) > 0.0)THEN
                        XTblah= XTblah+rhs(NAME(k))
                        xtblahb= xtblahb +PTB(I,1,13+K,CTY)
                        XTCYBLAH=XTCYBLAH +PT(NPT,I,1,13+K,CTY)
                    ENDIF
                !--
                !section removed in update from UT 2019
               !region change version
                !   IF(K.GE.2.AND.K.LE.4)THEN
                !      if(PT(NPT,I,1,13+K,CTY).lt.MINBIO(K+7,3))then  !makes sure that planted is at least up to the minimum!!
                !          PT(NPT,I,1,13+K,CTY)=MINBIO(K+7,3)
                !      endif
                !   ENDIF

          END DO
            !--
            !--       RECORD THIS YEAR'S NEW ACRES
                DO K=1,3
                    BIOPL(NPT,I,K,3,CTY) = PT(NPT,I,1,14+K,CTY) !CY(1,8+K,2,CTY)
                    IF(BIOPL(NPT,I,K,3,CTY) <= MINBIO(8+K,3)) THEN
                        APL(NPT,I,K,3,CTY) = 0.0
                    ELSE
                        APL(NPT,I,K,3,CTY)=BIOPL(NPT,I,K,3,CTY)-MINBIO(8+K,3)
                        IF(K == 2)then ! .AND. INDEX(115) == 1)THEN
                            APL(NPT,I,K,3,CTY)=APL(NPT,I,K,3,CTY)/RRR(10,CTY)  !ONLY PLANTED 1/RRR OF ACREAGE OF POPLARS        !AWAYS DO  TO MAKE PLANTINGS *ALWAYS* INCREMENTAL
                        ENDIF
                        IF(K == 3)then ! .AND. INDEX(115) == 1)THEN
                            APL(NPT,I,K,3,CTY)=APL(NPT,I,K,3,CTY)/RRR(11,CTY)  !ONLY PLANTED 1/4 OF ACREAGE OF WILLOWS !AWAYS DO  TO MAKE PLANTINGS *ALWAYS* INCREMENTAL
      ENDIF
      END IF
        ENDDO
            !--
            !--       RECORD THIS YEAR'S NEW miscanthus ACRES
                DO K=5,6
                    BIOPL(NPT,I,K,3,CTY) = PT(NPT,I,1,14+K,CTY)
                    IF(BIOPL(NPT,I,K,3,CTY) <= MINBIO(11+K,3)) THEN
                        APL(NPT,I,K,3,CTY) = 0.0
                    ELSE
                        APL(NPT,I,K,3,CTY)=BIOPL(NPT,I,K,3,CTY)-MINBIO(11+K,3)
                    END IF
                ENDDO
            !--
            !--
            !--      BIOTRACK FOR PASTURELAND IN BIOMASS CROPS
                DO K=1,6
                    IF(K == 4)THEN !ALGAE
                        PT(NPT,I,7,14+K,CTY)=PT(NPT,I,1,14+K,CTY)
                        PT(NPT,I,6,14+K,CTY)=PT(NPT,I,1,14+K,CTY)*CYX(25,13,3,CTY)
                    !C      ELSEIF(K.EQ.6)THEN !E.CANE
                    !C         PT(NPT,I,7,14+K,CTY)=PT(NPT,I,1,14+K,CTY)
                    !C         PT(NPT,I,6,14+K,CTY)=PT(NPT,I,1,14+K,CTY)*CYX(25,17,1,CTY)
                    ELSEIF(K >= 1 .AND. K <= 3)THEN  !SWITCH,POP,WILLOW
                        PT(NPT,I,7,14+K,CTY) = 0.0
                        PT(NPT,I,6,14+K,CTY) = 0.0
                        AYL(I,K,3,CTY) = CYX(25,8+K,3,CTY)                     ! Storage yield corresponding to date
                    !--                                                               ! of planting of biomass crops
                        IA = 0
                        DO WHILE ((I-IA-4)>=0 .AND. IA<IRTLN(8+K))                 ! chad changed from -4) 6/15/05!!!
                            IA = IA + 1
                            BIOAGE(I,IA,K,3,CTY) = APL(NPT,I-IA+1,K,3,CTY)    ! Calculate Plantings by "Age".        MAY HAVE TO CHANGE BIOAGE PRDAGE FOR PERMPASTU
                            PRDAGE(I,IA,K,3,CTY) = BIOAGE(I,IA,K,3,CTY) &
                            *CMX(IA,22,K,CTY)  * AYL(I-IA+1,K,3,CTY)            ! Calculate Production by "Age".
                        !--
                            IF(K == 2 .AND. (I-RRR(10,CTY)) > 0.0)THEN !POPLARS ALWAYS TAKE YIELD RRR(CTY) YEARS BEFORE
                                if(ia < rrr(10,cty))then
                                    PRDAGE(I,IA,K,3,CTY)=0.0
                                else
                                    PRDAGE(I,IA,K,3,CTY) = BIOAGE(I,IA,K,3,CTY) &
                                    *CMX(rrr(10,cty),22,K,CTY)  * AYL(I-RRR(10,CTY)+1,K,3,CTY)     !THIS IS TO MAKE PLANTINGS *ALWAYS* INCREMENTAL
                                endif
                            ENDIF
                        !--
                        !--
                            IF(K == 3)THEN  !WILLOWS
                                IF(IA < RRR(11,CTY))THEN
                                    PRDAGE(I,IA,K,3,CTY)=0.0
                                ELSEIF(IA >= RRR(11,CTY) .AND. IA < (RRR(11,CTY)*2))THEN
                                    PRDAGE(I,IA,K,3,CTY) = BIOAGE(I,IA,K,3,CTY) &
                                    *CMX(RRR(11,CTY),22,K,CTY) * AYL(I-IA+1,K,3,CTY) !THIS IS TO MAKE PLANTINGS *ALWAYS* INCREMENTAL
                                ELSEif(ia >= (RRR(11,CTY)*2))then
                                    PRDAGE(I,IA,K,3,CTY) = BIOAGE(I,IA,K,3,CTY) &
                                    *CMX((RRR(11,CTY)*2),22,K,CTY) * AYL(I-IA+1,K,3,CTY)       !THIS IS TO MAKE PLANTINGS *ALWAYS* INCREMENTAL

      ENDIF
            ENDIF
                        !--
                            IF(PRDAGE(I,IA,K,3,CTY)>0) THEN
                                PT(NPT,I,7,14+K,CTY) =PT(NPT,I,7,14+K,CTY) &
                                +BIOAGE(I,IA,K,3,CTY)       ! Calculate Acres Harvested
                            END IF
                            PT(NPT,I,6,14+K,CTY) =PT(NPT,I,6,14+K,CTY) +PRDAGE(I,IA,K,3,CTY)          ! Calculate Production by year
                        END DO

                    ELSEIF(K >= 5 .AND. K <= 6)THEN !MISCANTHUS
                        PT(NPT,I,7,14+K,CTY) = 0.0
                        PT(NPT,I,6,14+K,CTY) = 0.0
                        AYL(I,K,3,CTY) = CYX(25,11+K,1,CTY)                             ! Storage yield corresponding to date
                    !--                                                                     ! of planting of biomass crops
                        IA = 0
                        DO WHILE ((I-IA-4)>=0 .AND. IA<IRTLN(11+K))                       ! chad changed from -4) 6/15/05!!!
                            IA = IA + 1
                            BIOAGE(I,IA,K,3,CTY) = APL(NPT,I-IA+1,K,3,CTY)                    ! Calculate Plantings by "Age".
                            IF(BIOAGE(I,IA,K,3,CTY) < 0.0)BIOAGE(I,IA,K,3,CTY)=0.0
                            PRDAGE(I,IA,K,3,CTY)=BIOAGE(I,IA,K,3,CTY) &
                            *CMX(IA,22,K-1,CTY)*AYL(I-IA+1,K,3,CTY)              ! Calculate Production by "Age".
                            IF(PRDAGE(I,IA,K,3,CTY)>0) THEN
                                PT(NPT,I,7,14+K,CTY) = PT(NPT,I,7,14+K,CTY)+BIOAGE(I,IA,K,3,CTY)       ! Calculate Acres Harvested
                            END IF
                            PT(NPT,I,6,14+K,CTY) =PT(NPT,I,6,14+K,CTY) + PRDAGE(I,IA,K,3,CTY)          ! Calculate Production by year
           END DO
                    ENDIF

                !               IF(PT(NPT,I,6,14+K,CTY).LT.0.0)THEN
                !             WRITE(*,*)'PERMOUTLP',PT(NPT,I,6,14+K,CTY),K,CTY
                !                   WRITE(*,*)I,IA
                !      WRITE(*,*)PRDAGE(I,IA,K,3,CTY)
                !      WRITE(*,*)BIOAGE(I,IA,K,3,CTY),CMX(IA,22,K-1,CTY),AYL(I,K,3,CTY)
                !             PAUSE
                !          ENDIF


                ENDDO
                IF(I>=4)IP=1
            !--
      RETURN
                END SUBROUTINE PERMOUTLP
            !     Last change:  CH    6 May 2009    3:21 pm
                SUBROUTINE PERMSTOC
      IMPLICIT NONE

            !--
            !--   wait until now to assign yields to pastureland crops in case there was a change in the devy.for file....stochastic runs...
            !--   want to make sure they 'plan' using the non-stoch yields...and then assign for the output
            !--
                T=3
                DO K=9,11
                    CYX(25,K,T,CTY)= CYX(25,K,1,CTY)
                ENDDO
                DO K=16,17
                    CYX(25,K,T,CTY)= CYX(25,K,1,CTY)
                ENDDO
            !--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                RETURN
                END SUBROUTINE PERMSTOC

            !     Last change:  CH   23 May 2006    9:48 am
                SUBROUTINE POSTSIM
                IMPLICIT NONE

            !--
            !--
            !--         Difference in beef-veal CPI
            !--DRCPIBV= -.01203+ -1.1955*DBCN+-.22927*DPCN+ -.52089*DBRCN+ -.00111 *DTUCN+ 1*(drcepc/100)+ -.22549 *.01 + .159393*(dcrcepc/100)+  .452938*-.04;
            !--DRCPIBV=F10+F11*DBCN+F12*DPCN+F13*DBRCN+F14*DTUCN+F16*DRCELDPC+F15*DQLFD+F17*DQcesp+F18*DQcengp
            !--

                S(NPT,I,14,1)=SB(I,14,1)+LVP(45,1)*(S(NPT,I,35,1)-SB(I,35,1))+ &
                LVP(46,1)*(S(NPT,I,35,2)-SB(I,35,2))+LVP(47,1)* &
                (S(NPT,I,35,4)-SB(I,35,4))+LVP(48,1)*(S(NPT,I,35,5)-SB(I,35,5))
            !--
            !--         Difference in turkey CPI
            !--DRcpiTU=-.01106+ -.95675 *DBCN+ -.14179*DPCN+ -.44353*DBRCN+ -.66736 *DTUCN+1 * (drcepc/100)+  1.604581*0.01 +-1.59189 * (dcrcepc/100)+.63289*(-.04);
            !--DRcpiTU=F40+F41*DBCN+F42*DPCN+F43*DBRCN+F44*DTUCN+F46*DRCELDPC+F45*DQLFD+-F47*DQcesp+F48*DQcengp
            !--

                S(NPT,I,14,5)=SB(I,14,5)+LVP(16,5)*(S(NPT,I,35,1)-SB(I,35,1))+ &
                LVP(17,5)*(S(NPT,I,35,2)-SB(I,35,2))+LVP(18,5)* &
                (S(NPT,I,35,4)-SB(I,35,4))+LVP(19,5)*(S(NPT,I,35,5)-SB(I,35,5))
            !--
            !--         Difference in Box beef wholesale price
            !--drbxBWP=1.003882  +1 *(drCPIBV)+ -1.1777 *(dif((STKGNUS*STKGAUS+HFKGNUS *HFKGAUS+ beuxtus)/ bescpus) /lag((STKGNUS*STKGAUS
            !--    +HFKGNUS*HFKGAUS+beuxtus)/bescpus));
            !--drbxBWP=be10+be11*(drCPIBV)+be14*(dif((STKGNUS*STKGAUS+HFKGNUS*HFKGAUS+beuxtus)/bescpus)
            !--    /lag((STKGNUS*STKGAUS+HFKGNUS*HFKGAUS+beuxtus)/bescpus));
            !--

                S(NPT,I,8,1)=SB(I,8,1)+LVP(56,1)*(S(NPT,I,14,1)-SB(I,14,1))+ &
                LVP(57,1)*((((((S(NPT,I,28,1)*S(NPT,I,30,1)) &
                +(S(NPT,I,27,1)*S(NPT,I,29,1))+ &
                XS(NPT,I,13,1))/S(NPT,I,24,1))- &
                (((S(NPT,I-1,28,1)*S(NPT,I-1,30,1)) &
                +(S(NPT,I-1,27,1)*S(NPT,I-1,29,1))+ &
                XS(NPT,I-1,13,1))/S(NPT,I-1,24,1)))/ &
                (((S(NPT,I-1,28,1)*S(NPT,I-1,30,1))+(S(NPT,I-1,27,1)*S(NPT,I-1,29,1))+ &
                XS(NPT,I-1,13,1))/S(NPT,I-1,24,1)))- &
                (((((SB(I,28,1)*SB(I,30,1)) &
                +(SB(I,27,1)*SB(I,29,1))+ &
                XSB(I,13,1))/SB(I,24,1))- &
                (((SB(I-1,28,1)*SB(I-1,30,1)) &
                +(SB(I-1,27,1)*SB(I-1,29,1))+ &
                XSB(I-1,13,1))/SB(I-1,24,1)))/ &
                (((SB(I-1,28,1)*SB(I-1,30,1))+ &
                (SB(I-1,27,1)*SB(I-1,29,1))+ &
                XSB(I-1,13,1))/SB(I-1,24,1))))
            !--
            !--         Difference in cow carcus price
            !--drcwp=.006152+ 1.447117*(drCPIBV)+ -.39699 *dif(((CWKGNBE+CWKGNDA) *CWKGAUS+BESMTUS)/bescpus) /lag(((CWKGNBE+CWKGNDA)*
            !--          CWKGAUS+BESMTUS)/bescpus);
            !--drcwp=be20+be21*(drCPIBV)+be24*dif(((CWKGNBE+CWKGNDA)*CWKGAUS+BESMTUS)/bescpus)
            !--      /lag(((CWKGNBE+CWKGNDA)*CWKGAUS+BESMTUS)/bescpus);
            !--

                S(NPT,I,9,1)=SB(I,9,1)+LVP(59,1)*(S(NPT,I,14,1)-SB(I,14,1))+ &
                LVP(60,1)*((((((S(NPT,I,25,1)+XS(NPT,I,16,1))* &
                S(NPT,I,31,1)+XS(NPT,I,12,1))/ &
                S(NPT,I,24,1))- &
                (((S(NPT,I-1,25,1)+XS(NPT,I-1,16,1))* &
                S(NPT,I-1,31,1)+XS(NPT,I-1,12,1))/ &
                S(NPT,I-1,24,1)))/ &
                (((S(NPT,I-1,25,1)+XS(NPT,I-1,16,1))*S(NPT,I-1,31,1)+XS(NPT,I-1,12,1))/ &
                S(NPT,I-1,24,1)))- &
                (((((SB(I,25,1)+XSB(I,16,1))* &
                SB(I,31,1)+XSB(I,12,1))/ &
                SB(I,24,1))- &
                (((SB(I-1,25,1)+XSB(I-1,16,1))* &
                SB(I-1,31,1)+XSB(I-1,12,1))/ &
                SB(I-1,24,1)))/ &
                (((SB(I-1,25,1)+XSB(I-1,16,1))*SB(I-1,31,1)+XSB(I-1,12,1))/ &
                SB(I-1,24,1))))
            !--
            !--         Difference in omaha fed steer price
            !-- drstpom=  -.00168+ .868567 *drbxbwp;
            !-- drstpom=be30+be31*drbxbwp;
            !--

                S(NPT,I,13,1)=SB(I,13,1)+LVP(62,1)*(S(NPT,I,8,1)-SB(I,8,1))
            !--
            !--         Difference in omaha fed heifer price
            !-- drhfpom=-.00086 + .826819*drbxbwp;
            !-- drhfpom=be40+be41*drbxbwp
            !--

                S(NPT,I,11,1)=SB(I,11,1)+LVP(64,1)*(S(NPT,I,8,1)-SB(I,8,1))
            !--
            !--         Difference in omaha cow price
            !-- drcwpom=-.00169 + .891149*drcwp;
            !-- drcwpom=be50+be51*drcwp
            !--

                S(NPT,I,10,1)=SB(I,10,1)+LVP(66,1)*(S(NPT,I,9,1)-SB(I,9,1))
            !--
            !--         Difference in turkey wholesale eastern price variable
            !-- dRERTURP=  .00277665+ 1.155973  *(dRCPITU)+.01;
            !--     dRERTURP=RERTYS0+RERTYS1*(dRCPITU)+.01;
            !--

                S(NPT,I,8,5)=SB(I,8,5)+LVP(25,5)*(S(NPT,I,14,5)-SB(I,14,5))
            !--
            !--         Retail beef-veal CPI
            !--         rCPIBV=LAG(RCPIBV)*(1+DRCPIBV);
            !--

                S(NPT,I,7,1)=SB(I,7,1)+(S(NPT,I-1,7,1)*(1+S(NPT,I,14,1)))-(SB(I-1,7,1)* &
                (1+SB(I,14,1)))
            !--
            !--         Retail Pork CPI
            !--         rCPIPO=LAG(RCPIPO)*(1+DRCPIPO);
            !--

                S(NPT,I,7,2)=SB(I,7,2)+(S(NPT,I-1,7,2)*(1+S(NPT,I,14,2)))-(SB(I-1,7,2)* &
                (1+SB(I,14,2)))
            !--
            !--         Retail Broiler CPI
            !--         rCPIBR=LAG(RCPIBR)*(1+DRCPIBR);
            !--

                S(NPT,I,7,4)=SB(I,7,4)+(S(NPT,I-1,7,4)*(1+S(NPT,I,14,4)))-(SB(I-1,7,4)* &
                (1+SB(I,14,4)))
            !--
            !--         Retail turkey CPI
            !--         rCPITU=LAG(RCPITU)*(1+DRCPITU);
            !--

                S(NPT,I,7,5)=SB(I,7,5)+(S(NPT,I-1,7,5)*(1+S(NPT,I,14,5)))-(SB(I-1,7,5)* &
                (1+SB(I,14,5)))
            !-- Retail Turkey CPI(INDEX)
            !-- tydrwtin=rcpitu*cpi/100
                XS(NPT,I,7,5)=XSB(I,7,5)+(S(NPT,I,7,5)*XAG(I,1)/100)- &
                (SB(I,7,5)*XAGB(I,1)/100)
            !--
            !--         Box beef wholesale price
            !--         rbxbwp=LAG(RBXBWP)*(1+DRBXBWP);
            !--

                S(NPT,I,1,1)=SB(I,1,1)+(S(NPT,I-1,1,1)*(1+S(NPT,I,8,1)))-(SB(I-1,1,1)* &
                (1+SB(I,8,1)))
            !--
            !--         Cow carcus price
            !--         rcwp=LAG(RCWP)*(1+DRCWP);
            !--

                S(NPT,I,2,1)=SB(I,2,1)+(S(NPT,I-1,2,1)*(1+S(NPT,I,9,1)))-(SB(I-1,2,1)* &
                (1+SB(I,9,1)))
            !--
            !--         Omaha fed steer price(NEB)
            !--         rstpom=LAG(RSTPOM)*(1+DRSTPOM);
            !--

                S(NPT,I,6,1)=SB(I,6,1)+(S(NPT,I-1,6,1)*(1+S(NPT,I,13,1)))-(SB(I-1,6,1)* &
                (1+SB(I,13,1)))
            !--
            !--         Omaha fed heifer price
            !--         rhfpom=LAG(RHFPOM)*(1+DRHFPOM);
            !--

                S(NPT,I,4,1)=SB(I,4,1)+(S(NPT,I-1,4,1)*(1+S(NPT,I,11,1)))-(SB(I-1,4,1)* &
                (1+SB(I,11,1)))
            !--
            !--         Omaha Cow Price
            !--         rcwpom=LAG(RCWPOM)*(1+DRCWPOM);
            !--

                S(NPT,I,3,1)=SB(I,3,1)+(S(NPT,I-1,3,1)*(1+S(NPT,I,10,1)))-(SB(I-1,3,1)* &
                (1+SB(I,10,1)))
            !--
            !--                 Turkey Price (eastern region)
            !--         RERTURPR=LAG(RERTURPR)*(1+DRERTURP);
            !--

                S(NPT,I,1,5)=SB(I,1,5)+(S(NPT,I-1,1,5)*(1+S(NPT,I,8,5)))- &
                (SB(I-1,1,5)*(1+SB(I,8,5)))
            !--
            !--         Yearling Steer Price (deflated)
            !--RFSTP= -11.1097+ 1.036045*(rstpom/.649)+ -1.59926 *(rcornp*(248/56)+rsbmp*(20/2000)+rhayp*(38/2000))+ -.00213 *(dif(lag(ccrop)))+3;
            !--RFSTP=fst10+fst11*(rstpom/.649)+fst12*(rcornp*(248/56)+rsbmp*(20/2000)+rhayp*(38/2000))
            !--      +fst13*(dif(lag(ccrop)))+3
            !--

                S(NPT,I,5,1)=SB(I,5,1)+LVP(68,1)*((S(NPT,I,6,1)-SB(I,6,1))/.649)+ &
                LVP(69,1)*((248/56)*(XCR(NPT,I,5)-XCRB(I,5))+(20/2000)* &
                (XCR(NPT,I,7)-XCRB(I,7))+(38/2000)*(XCR(NPT,I,6)-XCRB(I,6)))+ &
                LVP(70,1)*((S(NPT,I-1,23,1)-S(NPT,I-2,23,1))-(SB(I-1,23,1)-SB(I-2,23,1)))
            !--
            !--                     ***Net Returns Section***
            !--
            !--         Cow cash returns
            !--rrct=(((77.71+46.27+61.52+40.30)*(RFSTP*CPI/100)/64.56*(1+(.01*(year-1996)))+
            !--((28.64*RCWP*CPI/100)/38.29)*(1+((year-1995)*.01)))-(ctotalc-(55)))/cpi*100;
            !--

                S(NPT,I,36,1)=SB(I,36,1)+((((225.8)*(S(NPT,I,5,1)*XAG(I,1)/100)/64.56*(1+ &
                (.01*(IYEAR(I)-1996)))+((28.64*S(NPT,I,2,1)*XAG(I,1)/100)/38.29)* &
                (1+((IYEAR(I)-1995)*.01)))-(S(NPT,I,42,1)-55))/XAG(I,1)*100)- &
                ((((225.8)*(SB(I,5,1)*XAGB(I,1)/100)/64.56*(1+ &
                (.01*(IYEAR(I)-1996)))+((28.64*SB(I,2,1)*XAGB(I,1)/100)/38.29)* &
                (1+((IYEAR(I)-1995)*.01)))-(SB(I,42,1)-55))/XAGB(I,1)*100)
            !--
            !--         Turkey net returns(deflated)
            !--         rtuRKNR=rerturpr-(tutc/cpi*100)+5;
            !--

                S(NPT,I,36,5)=SB(I,36,5)+(S(NPT,I,1,5)-(S(NPT,I,42,5)/XAG(I,1)*100))- &
                (SB(I,1,5)-(SB(I,42,5)/XAGB(I,1)*100))
            !--
      RETURN
                END SUBROUTINE POSTSIM
            !     Last change:  CH   23 May 2006    9:48 am
                SUBROUTINE PRESIM
                IMPLICIT NONE

            !--
            !--         ***set beginning stocks equal to ending stocks of year before***
            !--
                DO K=1,7
                    XS(NPT,I,10,K)=XSB(I,10,K)+(XS(NPT,I-1,11,K)-XSB(I-1,11,K))
                ENDDO
            !--
            !--         Beef Cow Inventory
            !--cbcijus= 457.5917 +.790458 *lag(cbcijus)+ 17.75825* LAG2(RRCT)+ 1.301077*lag(hfcbjus)+ -.35196 *lag(cwkgnbe)+cwfudge+cwfudge1;
            !--cbcijus=ca10+ca11*lag(cbcijus)+ca12* LAG2(RRCT)+ca14*lag(hfcbjus)+ca15*lag(cwkgnbe)
            !--

                S(NPT,I,15,1)=SB(I,15,1)+LVP(71,1)*(S(NPT,I-1,15,1)-SB(I-1,15,1))+ &
                LVP(72,1)*(S(NPT,I-2,36,1)-SB(I-2,36,1))+ &
                LVP(73,1)*(S(NPT,I-1,17,1)-SB(I-1,17,1))+ &
                LVP(74,1)*(S(NPT,I-1,25,1)-SB(I-1,25,1))
            !--
            !--         Calf Crop
            !--ccrop= -459.151+ .90953 *(CBCIJUS+CMCIJUS) + 15.5597 *LAG1(RRCT);
            !--ccrop=ca20+ca21*(CBCIJUS+CMCIJUS)+ca23*LAG1(RRCT)
            !--

                S(NPT,I,23,1)=SB(I,23,1)+ LVP(7,1)*((S(NPT,I,15,1)-SB(I,15,1))+ &
                (XS(NPT,I,9,1)-XSB(I,9,1)))+ &
                LVP(8,1)*(S(NPT,I-1,36,1)-SB(I-1,36,1))
            !--
            !--         Steer Inventory (500>lb)
            !--STCIJUS= 4944.79+.231615*LAG(CCROP-CVKCNUS+Cimport-Cexports)+ 47.1567* t;
            !--STCIJUS=ca30+ca31*LAG(CCROP-CVKCNUS+Cimport-Cexports)+ca33* t;
            !--

                S(NPT,I,20,1)=SB(I,20,1)+LVP(10,1)*((S(NPT,I-1,23,1)-SB(I-1,23,1))- &
                (XS(NPT,I-1,17,1)-XSB(I-1,17,1))+(XS(NPT,I-1,15,1)- &
                XSB(I-1,15,1))-(XS(NPT,I-1,14,1)-XSB(I-1,14,1)))
            !--
            !--         All heifer inventory (500>lb)
            !--hfcijus= 11444.7+.127433 *LAG(CCROP-CVKCNUS+cimport-Cexports)+ -52.5183* LAG(RHAYp/rcornp)+ 80.38539 * t ;
            !--hfcijus=ca40+ca41*LAG(CCROP-CVKCNUS+cimport-Cexports)+ca42* LAG(RHAYp/rcornp)+ca43* t
            !--

                S(NPT,I,18,1)=SB(I,18,1)+LVP(13,1)*((S(NPT,I-1,23,1)-SB(I-1,23,1))- &
                (XS(NPT,I-1,17,1)-XSB(I-1,17,1))+(XS(NPT,I-1,15,1)- &
                XSB(I-1,15,1))-(XS(NPT,I-1,14,1)-XSB(I-1,14,1)))+ &
                LVP(14,1)*((XCR(NPT,I-1,6)/XCR(NPT,I-1,5))- &
                (XCRB(I-1,6)/XCRB(I-1,5)))
            !--
            !--         Other heifer inventory (500> lb)
            !--hfcojus=3700.42+ .027243*LAG(CCROP-CVKCNUS+cimport-Cexports)+ 94.65696* LAG(RHAYp/rcornp)+ -7.53217  *LAG(RRCT);
            !--hfcojus=ca50+ca51*LAG(CCROP-CVKCNUS+cimport-Cexports)+ca52* LAG(RHAYp/rcornp)+ca53*LAG(RRCT)
            !--

                S(NPT,I,19,1)=SB(I,19,1)+LVP(17,1)*((S(NPT,I-1,23,1)-SB(I-1,23,1))- &
                (XS(NPT,I-1,17,1)-XSB(I-1,17,1))+(XS(NPT,I-1,15,1)- &
                XSB(I-1,15,1))-(XS(NPT,I-1,14,1)-XSB(I-1,14,1)))+ &
                LVP(18,1)*((XCR(NPT,I-1,6)/XCR(NPT,I-1,5))- &
                (XCRB(I-1,6)/XCRB(I-1,5))) &
                +LVP(19,1)*(S(NPT,I-1,36,1)-SB(I-1,36,1))
            !--
            !--         Beef heifers for replacement
            !--hfcbjus= -787.963+ .205469*cbcijus+ -25.6686 * LAG(RHAYp/rcornp)+ 2.652821  *LAG(RRCT)+cwfudge;
            !--hfcbjus=ca60+ca61*cbcijus+ca62*LAG(RHAYp/rcornp)+ca63*LAG(RRCT)+cwfudge
            !--

                S(NPT,I,17,1)=SB(I,17,1)+LVP(21,1)*(S(NPT,I,15,1)-SB(I,15,1))+ &
                LVP(22,1)*((XCR(NPT,I-1,6)/XCR(NPT,I-1,5))- &
                (XCRB(I-1,6)/XCRB(I-1,5))) &
                +LVP(23,1)*(S(NPT,I-1,36,1)-SB(I-1,36,1))
            !--
            !--         Bull inventory(>500 lbs)
            !--blcijus= -1122.5+ .064177 *(CBCIJUS+CMCIJUS)+ 14.27645* t;
            !--blcijus=ca70+ca71*(CBCIJUS+CMCIJUS)+ca72* t;
            !--

                S(NPT,I,16,1)=SB(I,16,1)+LVP(25,1)*((S(NPT,I,15,1)-SB(I,15,1))+ &
                (XS(NPT,I,9,1)-XSB(I,9,1)))
            !--
            !--         Heifers, steers, and bulls (<500 lbs)
            !--cvcijus= -6199.43+ .562424*LAG(CCROP-CVKCNUS+cimport-cexports)+ 148.0977 *LAG(RHAYp) ;
            !--cvcijus=ca80+ca81*LAG(CCROP-CVKCNUS+cimport-cexports)+ca82*LAG(RHAYp) ;
            !--

                S(NPT,I,22,1)=SB(I,22,1)+LVP(80,1)*((S(NPT,I-1,23,1)-SB(I-1,23,1))- &
                (XS(NPT,I-1,17,1)-XSB(I-1,17,1))+(XS(NPT,I-1,15,1)- &
                XSB(I-1,15,1))-(XS(NPT,I-1,14,1)-XSB(I-1,14,1)))+ &
                LVP(81,1)*(XCR(NPT,I-1,6)-XCRB(I-1,6))
            !--
            !--         Steer slaughter
            !--stkgnus= 4846.86+ .368034*LAG(CCROP-CVKCNUS+cimport-cexports)+ -14053.3*rfedcost+  -.17256 *lag(ccrop-cvkcnus+cimport-cexports)*(1-0.975) +stfudge;
            !--stkgnus=ca90+ca91*LAG(CCROP-CVKCNUS+cimport-cexports)+ca93*rfedcost+ca94*lag(ccrop-cvkcnus+cimport-cexports)*(1-FIRATIO)+stfudge
            !--

                S(NPT,I,28,1)=SB(I,28,1)+LVP(28,1)*((S(NPT,I-1,23,1)-SB(I-1,23,1))- &
                (XS(NPT,I-1,17,1)-XSB(I-1,17,1))+(XS(NPT,I-1,15,1)- &
                XSB(I-1,15,1))-(XS(NPT,I-1,14,1)-XSB(I-1,14,1)))+ &
                LVP(29,1)*(XCR(NPT,I,8)-XCRB(I,8))+LVP(30,1)*(1-LVP(24,6))* &
                ((S(NPT,I-1,23,1)-SB(I-1,23,1))-(XS(NPT,I-1,17,1)- &
                XSB(I-1,17,1))+(XS(NPT,I-1,15,1)-XSB(I-1,15,1))- &
                (XS(NPT,I-1,14,1)-XSB(I-1,14,1)))
            !--
            !--         Heifer slaughter
            !--hfkgnus=  6057.44+ .142822*LAG(CCROP-CVKCNUS+cimport-cexports)+ -131487 * dif(cmcijus)+ -11.5576 *lag(rrct)+ -.79538  *lag(ccrop-cvkcnus+cimport-cexports)*(1-0.975)+stfudge;
            !--hfkgnus=ca100+ca101*LAG(CCROP-CVKCNUS+cimport-cexports)+ca102*dif(cmcijus)+ca104*lag(rrct)+ca105*lag(ccrop-cvkcnus+cimport-cexports)*(1-FIRATIO)+stfudge;
            !--

                S(NPT,I,27,1)=SB(I,27,1)+(LVP(32,1)*(S(NPT,I-1,23,1)-XS(NPT,I-1,17,1)+ &
                XS(NPT,I-1,15,1)-XS(NPT,I-1,14,1))+ &
                LVP(33,1)*(XS(NPT,I,9,1)-XS(NPT,I-1,9,1)) &
                +LVP(34,1)*S(NPT,I-1,36,1)+LVP(35,1)*(1-LVP(24,6))* &
                (S(NPT,I-1,23,1)-XS(NPT,I-1,17,1)+XS(NPT,I-1,15,1)-XS(NPT,I-1,14,1)))- &
                (LVP(32,1)*(SB(I-1,23,1)-XSB(I-1,17,1)+ &
                XSB(I-1,15,1)-XSB(I-1,14,1))+ &
                LVP(33,1)*(XSB(I,9,1)-XSB(I-1,9,1)) &
                +LVP(34,1)*SB(I-1,36,1)+LVP(35,1)*(1-LVP(24,6))* &
                (SB(I-1,23,1)-XSB(I-1,17,1)+XSB(I-1,15,1)-XSB(I-1,14,1)))
            !--
            !--         Beef cow slaughter
            !--cwkgnbe= 2767.41+.08502*cbcijus+ -9.45063*lag(Rrct)+ -44.2597*rhayp/rcornp+ -.35963 *lag(cbcijus)*(1-0.975)-(500-(25*(year-1996)));
            !--cwkgnbe=ca130+ca131*cbcijus+ca132*lag(Rrct)+ca134*rhayp/rcornp+ca135*lag(cbcijus)*(1-FIRATIO)-(500-(25*(year-1996)));
            !--

                S(NPT,I,25,1)=SB(I,25,1)+LVP(37,1)*(S(NPT,I,15,1)-SB(I,15,1))+ &
                LVP(38,1)*(S(NPT,I-1,36,1)-SB(I-1,36,1))+ &
                LVP(39,1)*((XCR(NPT,I,6)/XCR(NPT,I,5))-(XCRB(I,6)/XCRB(I,5)))+ &
                LVP(40,1)*(1-LVP(24,6))*(S(NPT,I-1,15,1)-SB(I-1,15,1))
            !--
            !--         Bull slaughter
            !--blkgnus=-879.306 +.044822*(cwkgnbe+cwkgnda)+ .502197 *blcijus;
            !--blkgnus=ca140+ca141*(cwkgnbe+cwkgnda)+ca142*blcijus
            !--

                S(NPT,I,26,1)=SB(I,26,1)+LVP(42,1)*((S(NPT,I,25,1)-SB(I,25,1))+(XS(NPT,I,16,1) &
                -XSB(I,16,1)))+LVP(43,1)*(S(NPT,I,16,1)-SB(I,16,1))
            !--
            !--             Commercial Beef Carcus Weight
            !--cekcaus=746+((YEAR-2002)*2.5*(stkgnus+hfkgnus)/(stkgnus+hfkgnus+cwkgnbe+cwkgnda+blkgnus))
            !--

                S(NPT,I,32,1)=SB(I,32,1)+(IYEAR(I)-2002)*2.5*((S(NPT,I,28,1)+S(NPT,I,27,1))/ &
                (S(NPT,I,28,1)+S(NPT,I,27,1)+S(NPT,I,25,1)+XS(NPT,I,16,1)+S(NPT,I,26,1)) - &
                (SB(I,28,1)+SB(I,27,1))/ &
                (SB(I,28,1)+SB(I,27,1)+SB(I,25,1)+XSB(I,16,1)+SB(I,26,1)))
            !--
            !--         Total beef production
            !--bescpus=(cekcaus*(stkgnus+hfkgnus+cwkgnbe+cwkgnda+blkgnus)*1/.975)/1000;
            !--bescpus=(cekcaus*(stkgnus+hfkgnus+cwkgnbe+cwkgnda+blkgnus)*1/firatio)/1000-befudge;
            !--

                S(NPT,I,24,1)=SB(I,24,1)+((S(NPT,I,32,1)*(S(NPT,I,28,1)+S(NPT,I,27,1)+S(NPT,I,25,1)+ &
                XS(NPT,I,16,1)+S(NPT,I,26,1))*1/LVP(24,6))/1000)-((SB(I,32,1)* &
                (SB(I,28,1)+SB(I,27,1)+SB(I,25,1)+XSB(I,16,1)+ &
                SB(I,26,1))*1/LVP(24,6))/1000)
            !--
            !--     Steer Weights (dressed)
            !--STKGAUS=LAG(STKGAUS)*CEKCAUS/LAG(CEKCAUS);
            !--

                S(NPT,I,30,1)=SB(I,30,1)+(S(NPT,I-1,30,1)*S(NPT,I,32,1)/S(NPT,I-1,32,1))- &
                (SB(I-1,30,1)*SB(I,32,1)/SB(I-1,32,1))
            !--
            !--     Heifer Weights (dressed)
            !--HFKGAUS=LAG(hfKGAUS)*CEKCAUS/LAG(CEKCAUS);
            !--

                S(NPT,I,29,1)=SB(I,29,1)+(S(NPT,I-1,29,1)*S(NPT,I,32,1)/S(NPT,I-1,32,1))- &
                (SB(I-1,29,1)*SB(I,32,1)/SB(I-1,32,1))
            !--
            !--     Commercial Cow Weights
            !--CWKGAUS=LAG(cwkGAUS)*CEKCAUS/LAG(CEKCAUS);
            !--

                S(NPT,I,31,1)=SB(I,31,1)+(S(NPT,I-1,31,1)*S(NPT,I,32,1)/S(NPT,I-1,32,1))- &
                (SB(I-1,31,1)*SB(I,32,1)/SB(I-1,32,1))
            !--
            !--             Cattle Inventory
            !-- catinv=cbcijus+cvcijus+blcijus+stcijus+hfcojus+hfcmjus+hfcbjus+cmcijus;
            !--

                S(NPT,I,21,1)=SB(I,21,1)+(S(NPT,I,15,1)-SB(I,15,1))+(S(NPT,I,22,1)-SB(I,22,1)) &
                +(S(NPT,I,16,1)-SB(I,16,1)) &
                +(S(NPT,I,20,1)-SB(I,20,1))+(S(NPT,I,19,1)-SB(I,19,1))+(XS(NPT,I,8,1)- &
                XSB(I,8,1))+(S(NPT,I,17,1)-SB(I,17,1))+(XS(NPT,I,9,1)-XSB(I,9,1))
            !--
            !--                 ***HOG production EQUATIONS***
            !--
            !--         Difference in Sow Farrowing
            !--dswfalt= -700 + 85.17447*lag(rhogrec) + 39.33642 *lag2(rhogrec)+hogswf;
            !--dswfalt=hog10+hog11*d75+hog12*lag(rhogrec) +hog13*lag2(rhogrec)+hogswf;
            !--

                S(NPT,I,38,2)=SB(I,38,2)+LVP(3,2)*(S(NPT,I-1,36,2)-SB(I-1,36,2))+ &
                LVP(4,2)*(S(NPT,I-2,36,2)-SB(I-2,36,2))
            !--
            !--         Sow farrowing
            !--swfalt=lag(swfalt)+dswfalt;
            !--swfalt=lag(swfalt)+dswfalt+hogfudge;
            !--

                S(NPT,I,37,2)=SB(I,37,2)+(S(NPT,I-1,37,2)-SB(I-1,37,2))+ &
                (S(NPT,I,38,2)-SB(I,38,2))
            !--
            !--         Pig Crop
            !--pigcalt=swfalt*pslalt+PIGIMP;
            !--

                S(NPT,I,23,2)=SB(I,23,2)+(S(NPT,I,37,2)*XS(NPT,I,20,2)+XS(NPT,I,9,2))- &
                (SB(I,37,2)*XSB(I,20,2)+XSB(I,9,2))
            !--
            !--         Sow slaughter
            !--swkgnus= -692.784+.369626* swfalt+.809428 *swfalt*(1-(.975));
            !--swkgnus=hog30+hog31* swfalt+hog34*swfalt*(1-(firatio));
            !--

                S(NPT,I,27,2)=SB(I,27,2)+LVP(6,2)*(S(NPT,I,37,2)-SB(I,37,2))+ &
                LVP(7,2)*(1-LVP(24,6))*(S(NPT,I,37,2)-SB(I,37,2))
            !--
            !--         Hog Carcus Dressed Weight
            !--hoKCAUS=185+0.25*(year-1997);
            !--NOTHING CHANGES HERE

                S(NPT,I,32,2)=SB(I,32,2)
            !--
            !--                 ***BROILER Production EQUATIONS***
            !--
            !--         Hatchery supply flock
            !-- CHPBRhsf =  .99*LAG(CHPBRHSF)+ 280.5144*LAG(rbroilnr);
            !-- CHPBRhsf =BRF0+BRF1*LAG(CHPBRHSF)+BRF2*LAG(Rbroilnr)
            !--

                S(NPT,I,15,4)=SB(I,15,4)+LVP(2,4)*(S(NPT,I-1,15,4)-SB(I-1,15,4))+ &
                LVP(3,4)*(S(NPT,I-1,36,4)-SB(I-1,36,4))
            !--
            !--         Average broiler dressed weight
            !-- CYKDGAUS =  2.425356+ .011888*T+.000453 *T*T;
            !-- NOTHING CHANGES HERE

                S(NPT,I,33,4)=SB(I,33,4)
            !--
            !--                 ***TURKEY Production EQUATIONS***
            !--
            !--         Turkey Flock
            !--TYPFbird= 114597.9+ .799646*LAG(TYPFBIRD)+ 22248.87*LAG(rturknr)+ 493432.7*lag(ersturpr/(wAGEF));
            !--TYPFbird=TYF0+TYF1*LAG(TYPFBIRD)+TYF3*LAG(rturknr)+TYF5*lag(ersturpr/(wAGEF))+TYF6*d87;
            !--

                S(NPT,I,15,5)=SB(I,15,5)+LVP(2,5)*(S(NPT,I-1,15,5)-SB(I-1,15,5))+ &
                LVP(3,5)*(S(NPT,I-1,36,5)-SB(I-1,36,5))+ &
                LVP(4,5)*((XS(NPT,I-1,1,5)-XSB(I-1,1,5))/XAGB(I-1,4))
            !--
            !--         Turkey poult placements
            !--         TURPOULT=lag(Turpoult);
            !--

                S(NPT,I,23,5)=SB(I,23,5)+(S(NPT,I-1,23,5)-SB(I-1,23,5))
            !--
            !--         Average dressed weight
            !--TUKDGAUS = -9.70356+2.983226*TRNDROOT+ 36.3074*TYDWDUM1+ -4.38953*TYDWDUM1*trndroot+  -.20829 *TYDWDUM2*trndroot;
            !--TUKDGAUS =TYD0+TYD1*TRNDROOT+TYD2*TYDWDUM1+TYD3*TYDWDUM1*trndroot+TYD4*TYDWDUM2*trndroot;
            !--NOTHING CHANGES HERE

                S(NPT,I,33,5)=SB(I,33,5)
            !--
            !--         Turkey Slaughter
            !-- TURKI    =-22660.7+1.04069*TURPOULT;
            !-- TURKI    =TYS0+TYS1*TURPOULT;
            !--

                S(NPT,I,25,5)=SB(I,25,5)+LVP(12,5)*(S(NPT,I,23,5)-SB(I,23,5))
            !--
            !--         Difference in turkey production
            !--             DTURAI=.023609+.0047 *LAG(rturknr);
            !--             DTURAI=TP0+TP3*LAG(rturknr);
            !--

                S(NPT,I,40,5)=SB(I,40,5)+LVP(14,5)*(S(NPT,I-1,36,5)-SB(I-1,36,5))
            !--
            !--         Turkey Production
            !--         TURAI =LAG(TURAI)*(1+DTURAI);
            !--

                S(NPT,I,24,5)=SB(I,24,5)+((S(NPT,I-1,24,5)*(1+S(NPT,I,40,5)))- &
                (SB(I-1,24,5)*(1+SB(I,40,5))))
            !--
            !--         Per Capita Beef Consumption
            !--BCN=(BESCPUS+BECITUS+BESMTUS-BEUXTUS-BECOTUS)/(POPa)*.700;
            !--

                S(NPT,I,34,1)=SB(I,34,1)+((S(NPT,I,24,1)-SB(I,24,1))+(XS(NPT,I,10,1)- &
                XSB(I,10,1))+(XS(NPT,I,12,1)-XSB(I,12,1))-(XS(NPT,I,13,1)- &
                XSB(I,13,1))-(XS(NPT,I,11,1)-XSB(I,11,1)))/XAGB(I,3)*.700
            !--
            !--         Change in beef consumption
            !--         dbcn=(dif(BCN)/lag(BCN));
            !--

                S(NPT,I,35,1)=SB(I,35,1)+(((S(NPT,I,34,1)-S(NPT,I-1,34,1))/S(NPT,I-1,34,1))- &
                ((SB(I,34,1)-SB(I-1,34,1))/SB(I-1,34,1)))
            !--
            !--         Per Capita Turkey Consumption
            !-- TUCN=(TURAI*TURAZ-TURBK+TURHT-TURMX-TURHTE)/(POPa*1000);
            !--

                S(NPT,I,34,5)=SB(I,34,5)+(((S(NPT,I,24,5)*XS(NPT,I,22,5))-(SB(I,24,5)* &
                XSB(I,22,5)))-(XS(NPT,I,23,5)-XSB(I,23,5))+(XS(NPT,I,10,5)- &
                XSB(I,10,5))-(XS(NPT,I,13,5)-XSB(I,13,5))-(XS(NPT,I,11,5)- &
                XSB(I,11,5)))/(XAGB(I,3)*1000)
            !--
            !--         Change in turkey consumption
            !--         dtucn=(dif(TUCN)/lag(TUCN));
            !--

                S(NPT,I,35,5)=SB(I,35,5)+(((S(NPT,I,34,5)-S(NPT,I-1,34,5))/S(NPT,I-1,34,5))- &
                ((SB(I,34,5)-SB(I-1,34,5))/SB(I-1,34,5)))
            !--
      RETURN
                END SUBROUTINE PRESIM

      !********************************************************************************************************
      !update 2021
                SUBROUTINE PRINTTXT
                IMPLICIT NONE

            !    CHARACTER(32) :: OUTNEW
                CHARACTER(22) :: LABEL
                CHARACTER(48) :: TITLE
                CHARACTER(53) :: TTL1
                CHARACTER(61) :: TTL2
                CHARACTER(16) :: UNITS
                CHARACTER(3) :: MAT
                CHARACTER(3) :: NTVAL
                CHARACTER LINE(400)*1                            !!
                CHARACTER*3, DIMENSION(41) :: NANA
                DATA LINE /400*'-'/                              !!
                INTEGER :: IIYEAR(41),TOINT(41)
                REAL :: CRPNAT(41),PASTNAT(41),HAYNAT(41)
                !EIA add
                INTEGER :: NOLINES, NUMDASH2, NUMDASH1, IPAGE, ISTART, IEND, NYRSIM, NLVSK, NPRODS, NCRPS, JJ, LIJK, NODIG, J
                REAL :: SCALE
      INTEGER FILE_MGR
      EXTERNAL FILE_MGR
                CHARACTER*25 FNAME,FNAME3
      LOGICAL NEW
      INTEGER IUNIT1,IUNIT2,FILEUNIT
                INTEGER PRTPT !Which price point to print; usually mid pt

                HAYNAT = 0.0
                PRTPT=3
            !--
                Write( NTVAL, '(i3)' )  N   !THIS ASSIGNS NTVAL TO THE CHARACTER VERSION OF 'N' FOR NAMING OUTPUT STOCH FILES BELOW
            !--
            !--
            !--   VER. 2.0                                              3/21/97
            !--
            !--
            !--             INDEX(2) IS THE NUMBER OF CROPS IN POLYSYS [NCROPS]
                CLOSE(8)
                NCRPS = 12 !INDEX(2)
            !--
            !--             SET THE NUMBER OF PRODUCT CATEGORIES
            !--
                NPRODS = INDEX(43)
            !--
            !--             SET THE NUMBER OF LIVESTOCK CATEGORIES
            !--
                NLVSK = INDEX(5)
            !--
            !--             SET THE NUMBER OF YEARS SIMULATED
            !--
                NYRSIM = INDEX(1)
            !--
            !--             THIS SUBROUTINE PRINTS DATA FOR THE TWO YEARS PRIOR
            !--             TO THE FIRST YEAR SIMULATED (IE.,I BEGINS WITH 1,
            !--             RATHER THAN 3). THUS, ISTART IS SET TO 1 (GENERALLY).
            !--             (UNLESS PERCENTAGE CHANGES FROM BASELINE ARE BEING
            !--               PRINTED -- CHANGED BELOW WITH AN IF STATEMENT)
            !--
            !--
            !      ISTART = INDEX(30)-INDEX(27)+1
            !--
            !--             THE LAST YEAR IS THE NUMBER OF YEARS SIMULATED, NYRSIM,
            !--             PLUS THE TWO EXTRA YEARS AT THE BEGINNING.
            !--
                IEND = NYRSIM+(INDEX(30)-INDEX(27))+2
            !--
            !--
            !--             THE NAME OF THE FIRST YEAR PRINTED IS THE FIRST YEAR
            !--             SIMULATED - 2.
            !--             (UNLESS PERCENTAGE CHANGES FROM BASELINE ARE BEING
            !--               PRINTED -- CHANGED BELOW WITH AN IF STATEMENT)
            !--
                IYR = INDEX(30) - 2
                ISTART = INDEX(30)-INDEX(27)+3
            !--
            !--             Fill IIYEAR vector with names of years.
            !--
                DO I=ISTART-2,IEND
                    IIYEAR(I) = IYR
                    IYR=IYR+1
                END DO
            !--
            !--             Read the File containing the Tabs, Matrix, J values etc.
            !--
      FNAME='PSRESULTTB'
      NEW=.FALSE.
      IUNIT1=FILE_MGR('O',FNAME,NEW)
            !--
            !--             This is the output file
            !--
             !   OUTNEW = 'output/'//EXTT//'SIMOUT'//'_'//NTVAL//'.TXT'
            !--
     FNAME3='PSSIMOUT'
     NEW=.TRUE.
     IUNIT2=FILE_MGR('O',FNAME3,NEW)
     !if (npt.eq.1)  iunit2=554
            !--
            !--             Set page no. to zero.  IPAGE is passed to the subroutine each
            !--             time it is called
            !--
                IPAGE = 0
            !--
            !--             Format to Skip the instructions at the top of the input file RESULTTB.RMF
            !--
                6 FORMAT(/////////////)
                7 FORMAT(A48)
                9 FORMAT(A16)
                109 FORMAT('0',45X,A16)
                8 FORMAT('0',A48,', ',I4,'-',I4,/)
                98 FORMAT(' ',A48,', ',I4,'-',I4,/)
                100 FORMAT(' ',400A1)                                    !!
                71 FORMAT(A22,5X,A3,1x,I3,1x,I2,1x,I1,1x,F3.1,I2)
            !--
            !--             Variables to draw heading lines
            !--             First always, the second is times the number of years printed
            !--
                NUMDASH1=22
                NUMDASH2=7
            !--
            !--             Skip Instructions
            !--
                READ(IUNIT1,6)
            !--
            !--
            !--   *******************************************
            !--   *                                         *
            !--   *                CROPS                    *
            !--   *                                         *
            !--   *******************************************
            !--
            !--
            !--
            !--             Crops Section of Output
            !--             For this section, there is a Do loop to go through all crops.
            !--             However, a different number of tabs can be printed for each crop.
            !--
            !--             The Do Crop Loop
            !--
                DO K=1,NCRPS
!
!                Read Crop Specific Table Title
!
      READ(IUNIT1,7)TITLE
                    10 FORMAT(I3)
                    11 FORMAT(I3)
!
!                Read the Number of tabs (lines) in this crop's table.
!
      READ(IUNIT1,10)NOLINES
!
!                Start a new page with headers, page no. etc.
!
      CALL PAGETXT(IPAGE,IUNIT2)
!
!                Write the title of the crop's table attaching years to be printed
!
      WRITE(IUNIT2,8)TITLE,IIYEAR(ISTART),IIYEAR(IEND)
                    5 FORMAT(' ','        Item          ',45I7)                                     !22I7)
!
!                Write the Heading across the top, (Item and then each year)
!                with line above and below.
!
      WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
      WRITE(IUNIT2,5)(IIYEAR(I),I=ISTART,IEND)
      WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
      WRITE(IUNIT2,20)
                    20 FORMAT(' ')
                    16 FORMAT(A22,5X,A3,1X,I3,I2,1X,F10.0,1x,I2)
                    17 FORMAT(' ',A22,45I7)                                                        !22I7)
                    18 FORMAT(' ',A22,45F7.1)
                    19 FORMAT(' ',A22,45F7.2)
                    30 FORMAT(' ',A22,45F7.3)
                !--
                !--             Do loop spanning each line in the table
                !--
                    DO JJ=1,NOLINES
!
!                Read label, Matrix (C,X etc), Variable Index (J), Number of Digits
!                to print {0,1,2}, Multiplicative Scale (not operative 4/15/96)
!
      READ(IUNIT1,16)LABEL,MAT,J,NODIG,SCALE
!
!                If printing percentage deviations from baseline override number of digits
!                and force to 2
!
                        IF(INDEX(32)==2)NODIG=2
                    !--
                    !--             If the line to be printed is the computed stock to utilization ratio
                    !--             print it only if printing simulation values. Do not print if printing
                    !--             differences or percentages.
                    !--
                        IF(J==991)THEN
       IF(INDEX(32)==1)WRITE(IUNIT2,19)LABEL,((C(PRTPT,I,014,K)/C(PRTPT,I,013,K))&
                            ,I=ISTART,IEND)
         ELSE
                        !--
                        !--             C section of printout
                        !--
                            IF(MAT=='  C')THEN
                            !--
                            !--             If to print out with zero digits, set a new vector to the integer of
                            !--             of the C matrix elements and print as integers.
                            !--
                                IF(NODIG==0)THEN
                                    DO I = ISTART,IEND
                                        TOINT(I) = ANINT(C(PRTPT,I,J,K))
      END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
!
!                If want 1 digit to right of decimal point
!
                                ELSEIF(NODIG==1)THEN
           WRITE(IUNIT2,18)LABEL,(C(PRTPT,I,J,K),I=ISTART,IEND)
!
!                If want 2
!
                                ELSEIF(NODIG==2)THEN
           WRITE(IUNIT2,19)LABEL,(C(PRTPT,I,J,K),I=ISTART,IEND)
!
!                If want 3
!
                                ELSEIF(NODIG==3)THEN
           WRITE(IUNIT2,30)LABEL,(C(PRTPT,I,J,K),I=ISTART,IEND)
                                ENDIF
                            !--
                            !--
                            !--             If X, same deal.
                            !--
                            ELSEIF(MAT=='  X')THEN
                                IF(NODIG==0)THEN
                                    DO I = ISTART,IEND
                                        TOINT(I) = ANINT(X(I,J,K))
         END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                                ELSEIF(NODIG==1)THEN
           WRITE(IUNIT2,18)LABEL,(X(I,J,K),I=ISTART,IEND)
                                ELSEIF(NODIG==2)THEN
           WRITE(IUNIT2,19)LABEL,(X(I,J,K),I=ISTART,IEND)
                                ELSEIF(NODIG==3)THEN
           WRITE(IUNIT2,30)LABEL,(X(I,J,K),I=ISTART,IEND)
                                ENDIF
                            !--
                            !--             If EN, same deal.
                            !--
                            ELSEIF(MAT==' EN')THEN
                                IF(NODIG==0)THEN
                                    DO I = ISTART,IEND
                                        TOINT(I) = ANINT(EN(PRTPT,I,J,K))
      END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                                ELSEIF(NODIG==1)THEN
           WRITE(IUNIT2,18)LABEL,(EN(PRTPT,I,J,K),I=ISTART,IEND)
                                ELSEIF(NODIG==2)THEN
           WRITE(IUNIT2,19)LABEL,(EN(PRTPT,I,J,K),I=ISTART,IEND)
                                ELSEIF(NODIG==3)THEN
           WRITE(IUNIT2,30)LABEL,(EN(PRTPT,I,J,K),I=ISTART,IEND)
                                ENDIF
                ELSE
!
!                If neither C or X (in the crop section), assume its only a label
!                (which can be blank).
!
         WRITE(IUNIT2,17)LABEL
            END IF
         END IF
                    !--
                    !--             Done with this line; go do next.
                    END DO
!
!                Draw line at bottom of table
!
      WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
!
!                Done with this crop; go do next.
                END DO
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            !--   *******************************************
            !--   *                                         *
            !--   *               ALGAE                     *
            !--   *                                         *
            !--   *******************************************
            !--
            !--
            !--
                K=13  !DO K=16,17
            !--
            !--             Read Crop Specific Table Title
            !--
                READ(IUNIT1,7)TITLE
            !--
            !--             Read the Number of tabs (lines) in this crop's table.
            !--
                READ(IUNIT1,10)NOLINES
            !--
            !--             Start a new page with headers, page no. etc.
            !--
                CALL PAGETXT(IPAGE,IUNIT2)
            !--
            !--             Write the title of the crop's table attaching years to be printed
            !--
                WRITE(IUNIT2,8)TITLE,IIYEAR(ISTART),IIYEAR(IEND)
            !--
            !--             Write the Heading across the top, (Item and then each year)
            !--             with line above and below.
            !--
                WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
                WRITE(IUNIT2,5)(IIYEAR(I),I=ISTART,IEND)
                WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
                WRITE(IUNIT2,20)
            !--
            !--             Do loop spanning each line in the table
            !--
                DO JJ=1,NOLINES
                !--
                !--             Read label, Matrix (C,X etc), Variable Index (J), Number of Digits
                !--             to print {0,1,2}, Multiplicative Scale (not operative 4/15/96)
                !--
                    READ(IUNIT1,16)LABEL,MAT,J,NODIG,SCALE
                !--
                !--             If printing percentage deviations from baseline override number of digits
                !--             and force to 2
                !--
                    IF(INDEX(32)==2)NODIG=2
                !--
                !--             If the line to be printed is the computed stock to utilization ratio
                !--             print it only if printing simulation values. Do not print if printing
                !--             differences or percentages.
                !--
                    IF(J==991)THEN
                        IF(INDEX(32)==1)WRITE(IUNIT2,19)LABEL,((C(PRTPT,I,014,K)/C(PRTPT,I,013,K)) &
                        ,I=ISTART,IEND)
         ELSE
                    !--
                    !--             C section of printout
                    !--
                        IF(MAT=='  C')THEN
                        !--
                        !--             If to print out with zero digits, set a new vector to the integer of
                        !--             of the C matrix elements and print as integers.
                        !--
                            IF(NODIG==0)THEN
                                DO I = ISTART,IEND
                                    TOINT(I) = ANINT(C(PRTPT,I,J,K))
      END DO
                                WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                            !--
                            !--             If want 1 digit to right of decimal point
                            !--
                            ELSEIF(NODIG==1)THEN
                                WRITE(IUNIT2,18)LABEL,(C(PRTPT,I,J,K),I=ISTART,IEND)
                            !--
                            !--             If want 2
                            !--
                            ELSEIF(NODIG==2)THEN
                                WRITE(IUNIT2,19)LABEL,(C(PRTPT,I,J,K),I=ISTART,IEND)
                            !--
                            !--             If want 3
                            !--
                            ELSEIF(NODIG==3)THEN
                                WRITE(IUNIT2,30)LABEL,(C(PRTPT,I,J,K),I=ISTART,IEND)
                            ENDIF
                        !--
                        !--
                        !--             If X, same deal.
                        !--
                        ELSEIF(MAT=='  X')THEN
                            IF(NODIG==0)THEN
                                DO I = ISTART,IEND
                                    TOINT(I) = ANINT(X(I,J,K))
      END DO
                                WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                            ELSEIF(NODIG==1)THEN
                                WRITE(IUNIT2,18)LABEL,(X(I,J,K),I=ISTART,IEND)
                            ELSEIF(NODIG==2)THEN
                                WRITE(IUNIT2,19)LABEL,(X(I,J,K),I=ISTART,IEND)
                            ELSEIF(NODIG==3)THEN
                                WRITE(IUNIT2,30)LABEL,(X(I,J,K),I=ISTART,IEND)
                            ENDIF
                        !--
                        !--             If EN, same deal.
                        !--
                        ELSEIF(MAT==' EN')THEN
                            IF(NODIG==0)THEN
                                DO I = ISTART,IEND
                                    TOINT(I) = ANINT(EN(PRTPT,I,J,K))
      END DO
                                WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                            ELSEIF(NODIG==1)THEN
                                WRITE(IUNIT2,18)LABEL,(EN(PRTPT,I,J,K),I=ISTART,IEND)
                            ELSEIF(NODIG==2)THEN
                                WRITE(IUNIT2,19)LABEL,(EN(PRTPT,I,J,K),I=ISTART,IEND)
                            ELSEIF(NODIG==3)THEN
                                WRITE(IUNIT2,30)LABEL,(EN(PRTPT,I,J,K),I=ISTART,IEND)
                            ENDIF
            ELSE
                        !--
                        !--             If neither C or X (in the crop section), assume its only a label
                        !--             (which can be blank).
                        !--
                            WRITE(IUNIT2,17)LABEL
            END IF
         END IF
                !--
                !--             Done with this line; go do next.
      END DO
            !--
            !--             Draw line at bottom of table
            !--
                WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
            !--
            !--             Done with this crop; go do next.
            !C      END DO


            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            !--   *******************************************
            !--   *                                         *
            !--   *               MISCANTHUS                *
            !--   *                                         *
            !--   *******************************************
            !--
            !--
            !--
                K=16  !DO K=16,17
            !--
            !--             Read Crop Specific Table Title
            !--
                READ(IUNIT1,7)TITLE
            !--
            !--             Read the Number of tabs (lines) in this crop's table.
            !--
                READ(IUNIT1,10)NOLINES
            !--
            !--             Start a new page with headers, page no. etc.
            !--
                CALL PAGETXT(IPAGE,IUNIT2)
            !--
            !--             Write the title of the crop's table attaching years to be printed
            !--
                WRITE(IUNIT2,8)TITLE,IIYEAR(ISTART),IIYEAR(IEND)
            !--
            !--             Write the Heading across the top, (Item and then each year)
            !--             with line above and below.
            !--
                WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
                WRITE(IUNIT2,5)(IIYEAR(I),I=ISTART,IEND)
                WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
                WRITE(IUNIT2,20)
            !--
            !--             Do loop spanning each line in the table
            !--
                DO JJ=1,NOLINES
                !--
                !--             Read label, Matrix (C,X etc), Variable Index (J), Number of Digits
                !--             to print {0,1,2}, Multiplicative Scale (not operative 4/15/96)
                !--
                    READ(IUNIT1,16)LABEL,MAT,J,NODIG,SCALE
                !--
                !--             If printing percentage deviations from baseline override number of digits
                !--             and force to 2
                !--
                    IF(INDEX(32)==2)NODIG=2
                !--
                !--             If the line to be printed is the computed stock to utilization ratio
                !--             print it only if printing simulation values. Do not print if printing
                !--             differences or percentages.
                !--
                    IF(J==991)THEN
                        IF(INDEX(32)==1)WRITE(IUNIT2,19)LABEL,((C(PRTPT,I,014,K)/C(PRTPT,I,013,K)) &
                        ,I=ISTART,IEND)
         ELSE
                    !--
                    !--             C section of printout
                    !--
                        IF(MAT=='  C')THEN
                        !--
                        !--             If to print out with zero digits, set a new vector to the integer of
                        !--             of the C matrix elements and print as integers.
                        !--
                            IF(NODIG==0)THEN
                                DO I = ISTART,IEND
                                    TOINT(I) = ANINT(C(PRTPT,I,J,K))
      END DO
                                WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                            !--
                            !--             If want 1 digit to right of decimal point
                            !--
                            ELSEIF(NODIG==1)THEN
                                WRITE(IUNIT2,18)LABEL,(C(PRTPT,I,J,K),I=ISTART,IEND)
                            !--
                            !--             If want 2
                            !--
                            ELSEIF(NODIG==2)THEN
                                WRITE(IUNIT2,19)LABEL,(C(PRTPT,I,J,K),I=ISTART,IEND)
                            !--
                            !--             If want 3
                            !--
                            ELSEIF(NODIG==3)THEN
                                WRITE(IUNIT2,30)LABEL,(C(PRTPT,I,J,K),I=ISTART,IEND)
          ENDIF
                        !--
                        !--
                        !--             If X, same deal.
                        !--
                        ELSEIF(MAT=='  X')THEN
                            IF(NODIG==0)THEN
                                DO I = ISTART,IEND
                                    TOINT(I) = ANINT(X(I,J,K))
                                END DO
                                WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                            ELSEIF(NODIG==1)THEN
                                WRITE(IUNIT2,18)LABEL,(X(I,J,K),I=ISTART,IEND)
                            ELSEIF(NODIG==2)THEN
                                WRITE(IUNIT2,19)LABEL,(X(I,J,K),I=ISTART,IEND)
                            ELSEIF(NODIG==3)THEN
                                WRITE(IUNIT2,30)LABEL,(X(I,J,K),I=ISTART,IEND)
      ENDIF
                        !--
                        !--             If EN, same deal.
                        !--
                        ELSEIF(MAT==' EN')THEN
                            IF(NODIG==0)THEN
                                DO I = ISTART,IEND
                                    TOINT(I) = ANINT(EN(PRTPT,I,J,K))
        END DO
                                WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                            ELSEIF(NODIG==1)THEN
                                WRITE(IUNIT2,18)LABEL,(EN(PRTPT,I,J,K),I=ISTART,IEND)
                            ELSEIF(NODIG==2)THEN
                                WRITE(IUNIT2,19)LABEL,(EN(PRTPT,I,J,K),I=ISTART,IEND)
                            ELSEIF(NODIG==3)THEN
                                WRITE(IUNIT2,30)LABEL,(EN(PRTPT,I,J,K),I=ISTART,IEND)
                            ENDIF
         ELSE
                        !--
                        !--             If neither C or X (in the crop section), assume its only a label
                        !--             (which can be blank).
                        !--
                            WRITE(IUNIT2,17)LABEL
          END IF
        END IF
                !--
                !--             Done with this line; go do next.
                END DO
            !--
            !--             Draw line at bottom of table
            !--
                WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
            !--
            !--             Done with this crop; go do next.
            !C      END DO
            !--
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            !--   *******************************************
            !--   *                                         *
            !--   *               Ecane                     *
            !--   *                                         *
            !--   *******************************************
            !--
            !--
            !--
                K=17  !DO K=16,17
            !--
            !--             Read Crop Specific Table Title
            !--
                READ(IUNIT1,7)TITLE
            !--
            !--             Read the Number of tabs (lines) in this crop's table.
            !--
                READ(IUNIT1,10)NOLINES
            !--
            !--             Start a new page with headers, page no. etc.
            !--
                CALL PAGETXT(IPAGE,IUNIT2)
            !--
            !--             Write the title of the crop's table attaching years to be printed
            !--
                WRITE(IUNIT2,8)TITLE,IIYEAR(ISTART),IIYEAR(IEND)
            !--
            !--             Write the Heading across the top, (Item and then each year)
            !--             with line above and below.
            !--
                WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
                WRITE(IUNIT2,5)(IIYEAR(I),I=ISTART,IEND)
                WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
                WRITE(IUNIT2,20)
            !--
            !--             Do loop spanning each line in the table
            !--
                DO JJ=1,NOLINES
                !--
                !--             Read label, Matrix (C,X etc), Variable Index (J), Number of Digits
                !--             to print {0,1,2}, Multiplicative Scale (not operative 4/15/96)
                !--
                    READ(IUNIT1,16)LABEL,MAT,J,NODIG,SCALE
                !--
                !--             If printing percentage deviations from baseline override number of digits
                !--             and force to 2
                !--
                    IF(INDEX(32)==2)NODIG=2
                !--
                !--             If the line to be printed is the computed stock to utilization ratio
                !--             print it only if printing simulation values. Do not print if printing
                !--             differences or percentages.
                !--
                    IF(J==991)THEN
                        IF(INDEX(32)==1)WRITE(IUNIT2,19)LABEL,((C(PRTPT,I,014,K)/C(PRTPT,I,013,K)) &
                        ,I=ISTART,IEND)
               ELSE
                    !--
                    !--             C section of printout
                    !--
                        IF(MAT=='  C')THEN
                        !--
                        !--             If to print out with zero digits, set a new vector to the integer of
                        !--             of the C matrix elements and print as integers.
                        !--
                            IF(NODIG==0)THEN
                                DO I = ISTART,IEND
                                    TOINT(I) = ANINT(C(PRTPT,I,J,K))
                                END DO
                                WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                            !--
                            !--             If want 1 digit to right of decimal point
                            !--
                            ELSEIF(NODIG==1)THEN
                                WRITE(IUNIT2,18)LABEL,(C(PRTPT,I,J,K),I=ISTART,IEND)
                            !--
                            !--             If want 2
                            !--
                            ELSEIF(NODIG==2)THEN
                                WRITE(IUNIT2,19)LABEL,(C(PRTPT,I,J,K),I=ISTART,IEND)
                            !--
                            !--             If want 3
                            !--
                            ELSEIF(NODIG==3)THEN
                                WRITE(IUNIT2,30)LABEL,(C(PRTPT,I,J,K),I=ISTART,IEND)
                            ENDIF
                        !--
                        !--
                        !--             If X, same deal.
                        !--
                        ELSEIF(MAT=='  X')THEN
                            IF(NODIG==0)THEN
                                DO I = ISTART,IEND
                                    TOINT(I) = ANINT(X(I,J,K))
                                END DO
                                WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                            ELSEIF(NODIG==1)THEN
                                WRITE(IUNIT2,18)LABEL,(X(I,J,K),I=ISTART,IEND)
                            ELSEIF(NODIG==2)THEN
                                WRITE(IUNIT2,19)LABEL,(X(I,J,K),I=ISTART,IEND)
                            ELSEIF(NODIG==3)THEN
                                WRITE(IUNIT2,30)LABEL,(X(I,J,K),I=ISTART,IEND)
                            ENDIF
                        !--
                        !--             If EN, same deal.
                        !--
                        ELSEIF(MAT==' EN')THEN
                            IF(NODIG==0)THEN
                                DO I = ISTART,IEND
                                    TOINT(I) = ANINT(EN(PRTPT,I,J,K))
                                END DO
                                WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                            ELSEIF(NODIG==1)THEN
                                WRITE(IUNIT2,18)LABEL,(EN(PRTPT,I,J,K),I=ISTART,IEND)
                            ELSEIF(NODIG==2)THEN
                                WRITE(IUNIT2,19)LABEL,(EN(PRTPT,I,J,K),I=ISTART,IEND)
                            ELSEIF(NODIG==3)THEN
                                WRITE(IUNIT2,30)LABEL,(EN(PRTPT,I,J,K),I=ISTART,IEND)
               ENDIF
            ELSE
                        !--
                        !--             If neither C or X (in the crop section), assume its only a label
                        !--             (which can be blank).
                        !--
                            WRITE(IUNIT2,17)LABEL
                        END IF
                    END IF
                !--
                !--             Done with this line; go do next.
                END DO
            !--
            !--             Draw line at bottom of table
            !--
                WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
            !--
            !--             Done with this crop; go do next.
            !C      END DO
            !--
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            !--   *******************************************
            !--   *                                         *
            !--   *               Pennycress/corn           *
            !--   *                                         *
            !--   *******************************************
            !--
            !--
            !--
                K=18  !DO K=16,17
            !--
            !--             Read Crop Specific Table Title
            !--
                READ(IUNIT1,7)TITLE
            !--
            !--             Read the Number of tabs (lines) in this crop's table.
            !--
                READ(IUNIT1,10)NOLINES
            !--
            !--             Start a new page with headers, page no. etc.
            !--
                CALL PAGETXT(IPAGE,IUNIT2)
            !--
            !--             Write the title of the crop's table attaching years to be printed
            !--
                WRITE(IUNIT2,8)TITLE,IIYEAR(ISTART),IIYEAR(IEND)
            !--
            !--             Write the Heading across the top, (Item and then each year)
            !--             with line above and below.
            !--
                WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
                WRITE(IUNIT2,5)(IIYEAR(I),I=ISTART,IEND)
                WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
                WRITE(IUNIT2,20)
            !--
            !--             Do loop spanning each line in the table
            !--
                DO JJ=1,NOLINES
                !--
                !--             Read label, Matrix (C,X etc), Variable Index (J), Number of Digits
                !--             to print {0,1,2}, Multiplicative Scale (not operative 4/15/96)
                !--
                    READ(IUNIT1,16)LABEL,MAT,J,NODIG,SCALE
                !--
                !--             If printing percentage deviations from baseline override number of digits
                !--             and force to 2
                !--
                    IF(INDEX(32)==2)NODIG=2
                !--
                !--             If the line to be printed is the computed stock to utilization ratio
                !--             print it only if printing simulation values. Do not print if printing
                !--             differences or percentages.
                !--
                    IF(J==991)THEN
                        IF(INDEX(32)==1)WRITE(IUNIT2,19)LABEL,((C(PRTPT,I,014,K)/C(PRTPT,I,013,K)) &
                        ,I=ISTART,IEND)
               ELSE
                    !--
                    !--             C section of printout
                    !--
                        IF(MAT=='  C')THEN
                        !--
                        !--             If to print out with zero digits, set a new vector to the integer of
                        !--             of the C matrix elements and print as integers.
                        !--
                            IF(NODIG==0)THEN
                                DO I = ISTART,IEND
                                    TOINT(I) = ANINT(C(PRTPT,I,J,K))
                                END DO
                                WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                            !--
                            !--             If want 1 digit to right of decimal point
                            !--
                            ELSEIF(NODIG==1)THEN
                                WRITE(IUNIT2,18)LABEL,(C(PRTPT,I,J,K),I=ISTART,IEND)
                            !--
                            !--             If want 2
                            !--
                            ELSEIF(NODIG==2)THEN
                                WRITE(IUNIT2,19)LABEL,(C(PRTPT,I,J,K),I=ISTART,IEND)
                            !--
                            !--             If want 3
                            !--
                            ELSEIF(NODIG==3)THEN
                                WRITE(IUNIT2,30)LABEL,(C(PRTPT,I,J,K),I=ISTART,IEND)
               ENDIF
                        !--
                        !--
                        !--             If X, same deal.
                        !--
                        ELSEIF(MAT=='  X')THEN
                            IF(NODIG==0)THEN
                                DO I = ISTART,IEND
                                    TOINT(I) = ANINT(X(I,J,K))
                                END DO
                                WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                            ELSEIF(NODIG==1)THEN
                                WRITE(IUNIT2,18)LABEL,(X(I,J,K),I=ISTART,IEND)
                            ELSEIF(NODIG==2)THEN
                                WRITE(IUNIT2,19)LABEL,(X(I,J,K),I=ISTART,IEND)
                            ELSEIF(NODIG==3)THEN
                                WRITE(IUNIT2,30)LABEL,(X(I,J,K),I=ISTART,IEND)
            ENDIF
                        !--
                        !--             If EN, same deal.
                        !--
                        ELSEIF(MAT==' EN')THEN
                            IF(NODIG==0)THEN
                                DO I = ISTART,IEND
                                    TOINT(I) = ANINT(EN(PRTPT,I,J,K))
         END DO
                                WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                            ELSEIF(NODIG==1)THEN
                                WRITE(IUNIT2,18)LABEL,(EN(PRTPT,I,J,K),I=ISTART,IEND)
                            ELSEIF(NODIG==2)THEN
                                WRITE(IUNIT2,19)LABEL,(EN(PRTPT,I,J,K),I=ISTART,IEND)
                            ELSEIF(NODIG==3)THEN
                                WRITE(IUNIT2,30)LABEL,(EN(PRTPT,I,J,K),I=ISTART,IEND)
      ENDIF
                        !--
                        ELSEIF(MAT==' BS')THEN
                            IF(NODIG==0)THEN
                                DO I = ISTART,IEND
                                    TOINT(I) = ANINT(BIOSPLY(I,J))
                                END DO
                                WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                            ELSEIF(NODIG==1)THEN
                                WRITE(IUNIT2,18)LABEL,(BIOSPLY(I,J),I=ISTART,IEND)
                            ELSEIF(NODIG==2)THEN
                                WRITE(IUNIT2,19)LABEL,(BIOSPLY(I,J),I=ISTART,IEND)
                            ELSEIF(NODIG==3)THEN
                                WRITE(IUNIT2,30)LABEL,(BIOSPLY(I,J),I=ISTART,IEND)
            ENDIF
!--
      ELSEIF(MAT.EQ.' CB')THEN                              !OILSEEDS
         IF(NODIG.EQ.0)THEN
           DO I=ISTART,IEND
             TOINT(I)=ANINT(CRN(I,J,K,1))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
         ELSEIF(NODIG.EQ.1)THEN
           WRITE(IUNIT2,18)LABEL,(CRN(I,J,K,1),I=ISTART,IEND)
         ELSEIF(NODIG.EQ.2)THEN
           WRITE(IUNIT2,19)LABEL,(CRN(I,J,K,1),I=ISTART,IEND)
         ELSEIF(NODIG.EQ.3)THEN
           WRITE(IUNIT2,30)LABEL,(CRN(I,J,K,1),I=ISTART,IEND)
         ENDIF
         !!!!!
                        !--
         ELSE
                        !--
                        !--             If neither C or X (in the crop section), assume its only a label
                        !--             (which can be blank).
                        !--
                            WRITE(IUNIT2,17)LABEL
            END IF
         END IF
                !--
                !--             Done with this line; go do next.
      END DO
            !--
            !--             Draw line at bottom of table
            !--
                WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
            !--
            !--             Done with this crop; go do next.
            !C      END DO
            !--
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!--   *******************************************
!--   *                                         *
!--   *               CAMELINA/cotton/SOY         *
!--   *                                         *
!--   *******************************************
!--
!--
!--
      K=15  !DO K=16,17
      T=2
!--
!--             Read Crop Specific Table Title
!--
      READ(IUNIT1,7)TITLE
!--
!--             Read the Number of tabs (lines) in this crop's table.
!--
      READ(IUNIT1,10)NOLINES
!--
!--             Start a new page with headers, page no. etc.
!--
      CALL PAGETXT(IPAGE,IUNIT2)
!--
!--             Write the title of the crop's table attaching years to be printed
!--
      WRITE(IUNIT2,8)TITLE,IIYEAR(ISTART),IIYEAR(IEND)
!--
!--             Write the Heading across the top, (Item and then each year)
!--             with line above and below.
!--
      WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
      WRITE(IUNIT2,5)(IIYEAR(I),I=ISTART,IEND)
      WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
      WRITE(IUNIT2,20)
!--
!--             Do loop spanning each line in the table
!--
      DO JJ=1,NOLINES
!--
!--             Read label, Matrix (C,X etc), Variable Index (J), Number of Digits
!--             to print {0,1,2}, Multiplicative Scale (not operative 4/15/96)
!--
      READ(IUNIT1,16)LABEL,MAT,J,NODIG,SCALE
!--
!--             If printing percentage deviations from baseline override number of digits
!--             and force to 2
!--
      IF(INDEX(32)==2)NODIG=2
!--
!--             If the line to be printed is the computed stock to utilization ratio
!--             print it only if printing simulation values. Do not print if printing
!--             differences or percentages.
!--
      IF(J==991)THEN
       IF(INDEX(32)==1)WRITE(IUNIT2,19)LABEL,((C(NPT,I,014,K)/C(NPT,I,013,K)),I=ISTART,IEND)
      ELSE
!--
!--             C section of printout
!--
       IF(MAT=='  C')THEN
!--
!--             If to print out with zero digits, set a new vector to the integer of
!--             of the C matrix elements and print as integers.
!--
         IF(NODIG==0)THEN
           DO I = ISTART,IEND
           TOINT(I) = ANINT(C(NPT,I,J,K))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
!--
!--             If want 1 digit to right of decimal point
!--
         ELSEIF(NODIG==1)THEN
           WRITE(IUNIT2,18)LABEL,(C(NPT,I,J,K),I=ISTART,IEND)
!--
!--             If want 2
!--
         ELSEIF(NODIG==2)THEN
           WRITE(IUNIT2,19)LABEL,(C(NPT,I,J,K),I=ISTART,IEND)
!--
!--             If want 3
!--
         ELSEIF(NODIG==3)THEN
           WRITE(IUNIT2,30)LABEL,(C(NPT,I,J,K),I=ISTART,IEND)
         ENDIF
!--
!--
!--             If X, same deal.
!--
       ELSEIF(MAT=='  X')THEN
         IF(NODIG==0)THEN
           DO I = ISTART,IEND
           TOINT(I) = ANINT(X(I,J,K))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
         ELSEIF(NODIG==1)THEN
           WRITE(IUNIT2,18)LABEL,(X(I,J,K),I=ISTART,IEND)
         ELSEIF(NODIG==2)THEN
           WRITE(IUNIT2,19)LABEL,(X(I,J,K),I=ISTART,IEND)
         ELSEIF(NODIG==3)THEN
           WRITE(IUNIT2,30)LABEL,(X(I,J,K),I=ISTART,IEND)
         ENDIF
!--
!--             If EN, same deal.
!--
       ELSEIF(MAT==' EN')THEN
         IF(NODIG==0)THEN
           DO I = ISTART,IEND
           TOINT(I) = ANINT(EN(NPT,I,J,K))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
         ELSEIF(NODIG==1)THEN
           WRITE(IUNIT2,18)LABEL,(EN(NPT,I,J,K),I=ISTART,IEND)
         ELSEIF(NODIG==2)THEN
           WRITE(IUNIT2,19)LABEL,(EN(NPT,I,J,K),I=ISTART,IEND)
         ELSEIF(NODIG==3)THEN
           WRITE(IUNIT2,30)LABEL,(EN(NPT,I,J,K),I=ISTART,IEND)
         ENDIF
!--
       ELSEIF(MAT==' BS')THEN
         IF(NODIG==0)THEN
           DO I = ISTART,IEND
           TOINT(I) = ANINT(BIOSPLY(I,J))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
         ELSEIF(NODIG==1)THEN
           WRITE(IUNIT2,18)LABEL,(BIOSPLY(I,J),I=ISTART,IEND)
         ELSEIF(NODIG==2)THEN
           WRITE(IUNIT2,19)LABEL,(BIOSPLY(I,J),I=ISTART,IEND)
         ELSEIF(NODIG==3)THEN
           WRITE(IUNIT2,30)LABEL,(BIOSPLY(I,J),I=ISTART,IEND)
         ENDIF
!--
!--
      ELSEIF(MAT.EQ.' CB')THEN                              !OILSEEDS
         IF(NODIG.EQ.0)THEN
           DO I=ISTART,IEND
             TOINT(I)=ANINT(CRN(I,J,K,2))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
         ELSEIF(NODIG.EQ.1)THEN
           WRITE(IUNIT2,18)LABEL,(CRN(I,J,K,T),I=ISTART,IEND)
         ELSEIF(NODIG.EQ.2)THEN
           WRITE(IUNIT2,19)LABEL,(CRN(I,J,K,T),I=ISTART,IEND)
         ELSEIF(NODIG.EQ.3)THEN
           WRITE(IUNIT2,30)LABEL,(CRN(I,J,K,T),I=ISTART,IEND)
         ENDIF
         !!!!!
!--
       ELSE
!--
!--             If neither C or X (in the crop section), assume its only a label
!--             (which can be blank).
!--
         WRITE(IUNIT2,17)LABEL
       END IF
      END IF
!--
!--             Done with this line; go do next.
      END DO
!--
!--             Draw line at bottom of table
!--
      WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
!--
!--             Done with this crop; go do next.
!CC      END DO
!--
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!--   *******************************************
!--   *                                         *
!--   *               CARINATA/cotton/SOY         *
!--   *                                         *
!--   *******************************************
!--
!--
!--
      K=15  !DO K=16,17
      T=3
!--
!--             Read Crop Specific Table Title
!--
      READ(IUNIT1,7)TITLE
!--
!--             Read the Number of tabs (lines) in this crop's table.
!--
      READ(IUNIT1,10)NOLINES
!--
!--             Start a new page with headers, page no. etc.
!--
      CALL PAGETXT(IPAGE,IUNIT2)
!--
!--             Write the title of the crop's table attaching years to be printed
!--
      WRITE(IUNIT2,8)TITLE,IIYEAR(ISTART),IIYEAR(IEND)
!--
!--             Write the Heading across the top, (Item and then each year)
!--             with line above and below.
!--
      WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
      WRITE(IUNIT2,5)(IIYEAR(I),I=ISTART,IEND)
      WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
      WRITE(IUNIT2,20)
!--
!--             Do loop spanning each line in the table
!--
      DO JJ=1,NOLINES
!--
!--             Read label, Matrix (C,X etc), Variable Index (J), Number of Digits
!--             to print {0,1,2}, Multiplicative Scale (not operative 4/15/96)
!--
      READ(IUNIT1,16)LABEL,MAT,J,NODIG,SCALE
!--
!--             If printing percentage deviations from baseline override number of digits
!--             and force to 2
!--
      IF(INDEX(32)==2)NODIG=2
!--
!--             If the line to be printed is the computed stock to utilization ratio
!--             print it only if printing simulation values. Do not print if printing
!--             differences or percentages.
!--
      IF(J==991)THEN
       IF(INDEX(32)==1)WRITE(IUNIT2,19)LABEL,((C(NPT,I,014,K)/C(NPT,I,013,K))  ,I=ISTART,IEND)
      ELSE
!--
!--             C section of printout
!--
       IF(MAT=='  C')THEN
!--
!--             If to print out with zero digits, set a new vector to the integer of
!--             of the C matrix elements and print as integers.
!--
         IF(NODIG==0)THEN
           DO I = ISTART,IEND
           TOINT(I) = ANINT(C(NPT,I,J,K))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
!--
!--             If want 1 digit to right of decimal point
!--
         ELSEIF(NODIG==1)THEN
           WRITE(IUNIT2,18)LABEL,(C(NPT,I,J,K),I=ISTART,IEND)
!--
!--             If want 2
!--
         ELSEIF(NODIG==2)THEN
           WRITE(IUNIT2,19)LABEL,(C(NPT,I,J,K),I=ISTART,IEND)
!--
!--             If want 3
!--
         ELSEIF(NODIG==3)THEN
           WRITE(IUNIT2,30)LABEL,(C(NPT,I,J,K),I=ISTART,IEND)
         ENDIF
!--
!--
!--             If X, same deal.
!--
       ELSEIF(MAT=='  X')THEN
         IF(NODIG==0)THEN
           DO I = ISTART,IEND
           TOINT(I) = ANINT(X(I,J,K))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
         ELSEIF(NODIG==1)THEN
           WRITE(IUNIT2,18)LABEL,(X(I,J,K),I=ISTART,IEND)
         ELSEIF(NODIG==2)THEN
           WRITE(IUNIT2,19)LABEL,(X(I,J,K),I=ISTART,IEND)
         ELSEIF(NODIG==3)THEN
           WRITE(IUNIT2,30)LABEL,(X(I,J,K),I=ISTART,IEND)
         ENDIF
!--
!--             If EN, same deal.
!--
       ELSEIF(MAT==' EN')THEN
         IF(NODIG==0)THEN
           DO I = ISTART,IEND
           TOINT(I) = ANINT(EN(NPT,I,J,K))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
         ELSEIF(NODIG==1)THEN
           WRITE(IUNIT2,18)LABEL,(EN(NPT,I,J,K),I=ISTART,IEND)
         ELSEIF(NODIG==2)THEN
           WRITE(IUNIT2,19)LABEL,(EN(NPT,I,J,K),I=ISTART,IEND)
         ELSEIF(NODIG==3)THEN
           WRITE(IUNIT2,30)LABEL,(EN(NPT,I,J,K),I=ISTART,IEND)
         ENDIF
!--
       ELSEIF(MAT==' BS')THEN
         IF(NODIG==0)THEN
           DO I = ISTART,IEND
           TOINT(I) = ANINT(BIOSPLY(I,J))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
         ELSEIF(NODIG==1)THEN
           WRITE(IUNIT2,18)LABEL,(BIOSPLY(I,J),I=ISTART,IEND)
         ELSEIF(NODIG==2)THEN
           WRITE(IUNIT2,19)LABEL,(BIOSPLY(I,J),I=ISTART,IEND)
         ELSEIF(NODIG==3)THEN
           WRITE(IUNIT2,30)LABEL,(BIOSPLY(I,J),I=ISTART,IEND)
         ENDIF
!--
!--
      ELSEIF(MAT.EQ.' CB')THEN                              !OILSEEDS
         IF(NODIG.EQ.0)THEN
           DO I=ISTART,IEND
             TOINT(I)=ANINT(CRN(I,J,K,3))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
         ELSEIF(NODIG.EQ.1)THEN
           WRITE(IUNIT2,18)LABEL,(CRN(I,J,K,3),I=ISTART,IEND)
         ELSEIF(NODIG.EQ.2)THEN
           WRITE(IUNIT2,19)LABEL,(CRN(I,J,K,3),I=ISTART,IEND)
         ELSEIF(NODIG.EQ.3)THEN
           WRITE(IUNIT2,30)LABEL,(CRN(I,J,K,3),I=ISTART,IEND)
         ENDIF
         !!!!!
!--
       ELSE
!--
!--             If neither C or X (in the crop section), assume its only a label
!--             (which can be blank).
!--
         WRITE(IUNIT2,17)LABEL
       END IF
      END IF
!--
!--             Done with this line; go do next.
      END DO
!--
!--             Draw line at bottom of table
!--
      WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
!--
!--             **end oilseeds/cotton rotations**
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!--   *******************************************
!--   *                                         *
!--   *               Pennycress/corn           *
!--   *                                         *
!--   *******************************************
!--
!--
!--
      K=18  !DO K=16,17
      T=1
!--
!--             Read Crop Specific Table Title
!--
      READ(IUNIT1,7)TITLE
!--
!--             Read the Number of tabs (lines) in this crop's table.
!--
      READ(IUNIT1,10)NOLINES
!--
!--             Start a new page with headers, page no. etc.
!--
      CALL PAGETXT(IPAGE,IUNIT2)
!--
!--             Write the title of the crop's table attaching years to be printed
!--
      WRITE(IUNIT2,8)TITLE,IIYEAR(ISTART),IIYEAR(IEND)
!--
!--             Write the Heading across the top, (Item and then each year)
!--             with line above and below.
!--
      WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
      WRITE(IUNIT2,5)(IIYEAR(I),I=ISTART,IEND)
      WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
      WRITE(IUNIT2,20)
!--
!--             Do loop spanning each line in the table
!--
      DO JJ=1,NOLINES
!--
!--             Read label, Matrix (C,X etc), Variable Index (J), Number of Digits
!--             to print {0,1,2}, Multiplicative Scale (not operative 4/15/96)
!--
      READ(IUNIT1,16)LABEL,MAT,J,NODIG,SCALE
!--
!--             If printing percentage deviations from baseline override number of digits
!--             and force to 2
!--
      IF(INDEX(32)==2)NODIG=2
!--
!--             If the line to be printed is the computed stock to utilization ratio
!--             print it only if printing simulation values. Do not print if printing
!--             differences or percentages.
!--
      IF(J==991)THEN
       IF(INDEX(32)==1)WRITE(IUNIT2,19)LABEL,((C(NPT,I,014,K)/C(NPT,I,013,K)) ,I=ISTART,IEND)
      ELSE
!--
!--             C section of printout
!--
       IF(MAT=='  C')THEN
!--
!--             If to print out with zero digits, set a new vector to the integer of
!--             of the C matrix elements and print as integers.
!--
         IF(NODIG==0)THEN
           DO I = ISTART,IEND
           TOINT(I) = ANINT(C(NPT,I,J,K))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
!--
!--             If want 1 digit to right of decimal point
!--
         ELSEIF(NODIG==1)THEN
           WRITE(IUNIT2,18)LABEL,(C(NPT,I,J,K),I=ISTART,IEND)
!--
!--             If want 2
!--
         ELSEIF(NODIG==2)THEN
           WRITE(IUNIT2,19)LABEL,(C(NPT,I,J,K),I=ISTART,IEND)
!--
!--             If want 3
!--
         ELSEIF(NODIG==3)THEN
           WRITE(IUNIT2,30)LABEL,(C(NPT,I,J,K),I=ISTART,IEND)
         ENDIF
!--
!--
!--             If X, same deal.
!--
       ELSEIF(MAT=='  X')THEN
         IF(NODIG==0)THEN
           DO I = ISTART,IEND
           TOINT(I) = ANINT(X(I,J,K))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
         ELSEIF(NODIG==1)THEN
           WRITE(IUNIT2,18)LABEL,(X(I,J,K),I=ISTART,IEND)
         ELSEIF(NODIG==2)THEN
           WRITE(IUNIT2,19)LABEL,(X(I,J,K),I=ISTART,IEND)
         ELSEIF(NODIG==3)THEN
           WRITE(IUNIT2,30)LABEL,(X(I,J,K),I=ISTART,IEND)
         ENDIF
!--
!--             If EN, same deal.
!--
       ELSEIF(MAT==' EN')THEN
         IF(NODIG==0)THEN
           DO I = ISTART,IEND
           TOINT(I) = ANINT(EN(NPT,I,J,K))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
         ELSEIF(NODIG==1)THEN
           WRITE(IUNIT2,18)LABEL,(EN(NPT,I,J,K),I=ISTART,IEND)
         ELSEIF(NODIG==2)THEN
           WRITE(IUNIT2,19)LABEL,(EN(NPT,I,J,K),I=ISTART,IEND)
         ELSEIF(NODIG==3)THEN
           WRITE(IUNIT2,30)LABEL,(EN(NPT,I,J,K),I=ISTART,IEND)
         ENDIF
!--
       ELSEIF(MAT==' BS')THEN
         IF(NODIG==0)THEN
           DO I = ISTART,IEND
           TOINT(I) = ANINT(BIOSPLY(I,J))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
         ELSEIF(NODIG==1)THEN
           WRITE(IUNIT2,18)LABEL,(BIOSPLY(I,J),I=ISTART,IEND)
         ELSEIF(NODIG==2)THEN
           WRITE(IUNIT2,19)LABEL,(BIOSPLY(I,J),I=ISTART,IEND)
         ELSEIF(NODIG==3)THEN
           WRITE(IUNIT2,30)LABEL,(BIOSPLY(I,J),I=ISTART,IEND)
         ENDIF
!--
      ELSEIF(MAT.EQ.' CB')THEN                              !OILSEEDS
         IF(NODIG.EQ.0)THEN
           DO I=ISTART,IEND
             TOINT(I)=ANINT(CRN(I,J,K,1))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
         ELSEIF(NODIG.EQ.1)THEN
           WRITE(IUNIT2,18)LABEL,(CRN(I,J,K,1),I=ISTART,IEND)
         ELSEIF(NODIG.EQ.2)THEN
           WRITE(IUNIT2,19)LABEL,(CRN(I,J,K,1),I=ISTART,IEND)
         ELSEIF(NODIG.EQ.3)THEN
           WRITE(IUNIT2,30)LABEL,(CRN(I,J,K,1),I=ISTART,IEND)
         ENDIF
         !!!!!
!--
       ELSE
!--
!--             If neither C or X (in the crop section), assume its only a label
!--             (which can be blank).
!--
         WRITE(IUNIT2,17)LABEL
       END IF
      END IF
!--
!--             Done with this line; go do next.
      END DO
!--
!--             Draw line at bottom of table
!--
      WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
!--
!--             Done with this crop; go do next.
!CC      END DO
!--
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!--   *******************************************
!--   *                                         *
!--   *               CAMELINA/corn/SOY         *
!--   *                                         *
!--   *******************************************
!--
!--
!--
      K=18  !DO K=16,17
      T=2
!--
!--             Read Crop Specific Table Title
!--
      READ(IUNIT1,7)TITLE
!--
!--             Read the Number of tabs (lines) in this crop's table.
!--
      READ(IUNIT1,10)NOLINES
!--
!--             Start a new page with headers, page no. etc.
!--
      CALL PAGETXT(IPAGE,IUNIT2)
!--
!--             Write the title of the crop's table attaching years to be printed
!--
      WRITE(IUNIT2,8)TITLE,IIYEAR(ISTART),IIYEAR(IEND)
!--
!--             Write the Heading across the top, (Item and then each year)
!--             with line above and below.
!--
      WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
      WRITE(IUNIT2,5)(IIYEAR(I),I=ISTART,IEND)
      WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
      WRITE(IUNIT2,20)
!--
!--             Do loop spanning each line in the table
!--
      DO JJ=1,NOLINES
!--
!--             Read label, Matrix (C,X etc), Variable Index (J), Number of Digits
!--             to print {0,1,2}, Multiplicative Scale (not operative 4/15/96)
!--
      READ(IUNIT1,16)LABEL,MAT,J,NODIG,SCALE
!--
!--             If printing percentage deviations from baseline override number of digits
!--             and force to 2
!--
      IF(INDEX(32)==2)NODIG=2
!--
!--             If the line to be printed is the computed stock to utilization ratio
!--             print it only if printing simulation values. Do not print if printing
!--             differences or percentages.
!--
      IF(J==991)THEN
       IF(INDEX(32)==1)WRITE(IUNIT2,19)LABEL,((C(NPT,I,014,K)/C(NPT,I,013,K)) ,I=ISTART,IEND)
      ELSE
!--
!--             C section of printout
!--
       IF(MAT=='  C')THEN
!--
!--             If to print out with zero digits, set a new vector to the integer of
!--             of the C matrix elements and print as integers.
!--
         IF(NODIG==0)THEN
           DO I = ISTART,IEND
           TOINT(I) = ANINT(C(NPT,I,J,K))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
!--
!--             If want 1 digit to right of decimal point
!--
         ELSEIF(NODIG==1)THEN
           WRITE(IUNIT2,18)LABEL,(C(NPT,I,J,K),I=ISTART,IEND)
!--
!--             If want 2
!--
         ELSEIF(NODIG==2)THEN
           WRITE(IUNIT2,19)LABEL,(C(NPT,I,J,K),I=ISTART,IEND)
!--
!--             If want 3
!--
         ELSEIF(NODIG==3)THEN
           WRITE(IUNIT2,30)LABEL,(C(NPT,I,J,K),I=ISTART,IEND)
         ENDIF
!--
!--
!--             If X, same deal.
!--
       ELSEIF(MAT=='  X')THEN
         IF(NODIG==0)THEN
           DO I = ISTART,IEND
           TOINT(I) = ANINT(X(I,J,K))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
         ELSEIF(NODIG==1)THEN
           WRITE(IUNIT2,18)LABEL,(X(I,J,K),I=ISTART,IEND)
         ELSEIF(NODIG==2)THEN
           WRITE(IUNIT2,19)LABEL,(X(I,J,K),I=ISTART,IEND)
         ELSEIF(NODIG==3)THEN
           WRITE(IUNIT2,30)LABEL,(X(I,J,K),I=ISTART,IEND)
         ENDIF
!--
!--             If EN, same deal.
!--
       ELSEIF(MAT==' EN')THEN
         IF(NODIG==0)THEN
           DO I = ISTART,IEND
           TOINT(I) = ANINT(EN(NPT,I,J,K))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
         ELSEIF(NODIG==1)THEN
           WRITE(IUNIT2,18)LABEL,(EN(NPT,I,J,K),I=ISTART,IEND)
         ELSEIF(NODIG==2)THEN
           WRITE(IUNIT2,19)LABEL,(EN(NPT,I,J,K),I=ISTART,IEND)
         ELSEIF(NODIG==3)THEN
           WRITE(IUNIT2,30)LABEL,(EN(NPT,I,J,K),I=ISTART,IEND)
         ENDIF
!--
       ELSEIF(MAT==' BS')THEN
         IF(NODIG==0)THEN
           DO I = ISTART,IEND
           TOINT(I) = ANINT(BIOSPLY(I,J))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
         ELSEIF(NODIG==1)THEN
           WRITE(IUNIT2,18)LABEL,(BIOSPLY(I,J),I=ISTART,IEND)
         ELSEIF(NODIG==2)THEN
           WRITE(IUNIT2,19)LABEL,(BIOSPLY(I,J),I=ISTART,IEND)
         ELSEIF(NODIG==3)THEN
           WRITE(IUNIT2,30)LABEL,(BIOSPLY(I,J),I=ISTART,IEND)
         ENDIF
!--
!--
      ELSEIF(MAT.EQ.' CB')THEN                              !OILSEEDS
         IF(NODIG.EQ.0)THEN
           DO I=ISTART,IEND
             TOINT(I)=ANINT(CRN(I,J,K,2))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
         ELSEIF(NODIG.EQ.1)THEN
           WRITE(IUNIT2,18)LABEL,(CRN(I,J,K,2),I=ISTART,IEND)
         ELSEIF(NODIG.EQ.2)THEN
           WRITE(IUNIT2,19)LABEL,(CRN(I,J,K,2),I=ISTART,IEND)
         ELSEIF(NODIG.EQ.3)THEN
           WRITE(IUNIT2,30)LABEL,(CRN(I,J,K,2),I=ISTART,IEND)
         ENDIF
         !!!!!
!--
       ELSE
!--
!--             If neither C or X (in the crop section), assume its only a label
!--             (which can be blank).
!--
         WRITE(IUNIT2,17)LABEL
       END IF
      END IF
!--
!--             Done with this line; go do next.
      END DO
!--
!--             Draw line at bottom of table
!--
      WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
!--
!--             Done with this crop; go do next.
!CC      END DO
!--
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!--   *******************************************
!--   *                                         *
!--   *               CARINATA/corn/SOY         *
!--   *                                         *
!--   *******************************************
!--
!--
!--
      K=18  !DO K=16,17
      T=3
!--
!--             Read Crop Specific Table Title
!--
      READ(IUNIT1,7)TITLE
!--
!--             Read the Number of tabs (lines) in this crop's table.
!--
      READ(IUNIT1,10)NOLINES
!--
!--             Start a new page with headers, page no. etc.
!--
      CALL PAGETXT(IPAGE,IUNIT2)
!--
!--             Write the title of the crop's table attaching years to be printed
!--
      WRITE(IUNIT2,8)TITLE,IIYEAR(ISTART),IIYEAR(IEND)
!--
!--             Write the Heading across the top, (Item and then each year)
!--             with line above and below.
!--
      WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
      WRITE(IUNIT2,5)(IIYEAR(I),I=ISTART,IEND)
      WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
      WRITE(IUNIT2,20)
!--
!--             Do loop spanning each line in the table
!--
      DO JJ=1,NOLINES
!--
!--             Read label, Matrix (C,X etc), Variable Index (J), Number of Digits
!--             to print {0,1,2}, Multiplicative Scale (not operative 4/15/96)
!--
      READ(IUNIT1,16)LABEL,MAT,J,NODIG,SCALE
!--
!--             If printing percentage deviations from baseline override number of digits
!--             and force to 2
!--
      IF(INDEX(32)==2)NODIG=2
!--
!--             If the line to be printed is the computed stock to utilization ratio
!--             print it only if printing simulation values. Do not print if printing
!--             differences or percentages.
!--
      IF(J==991)THEN
       IF(INDEX(32)==1)WRITE(IUNIT2,19)LABEL,((C(NPT,I,014,K)/C(NPT,I,013,K)) ,I=ISTART,IEND)
      ELSE
!--
!--             C section of printout
!--
       IF(MAT=='  C')THEN
!--
!--             If to print out with zero digits, set a new vector to the integer of
!--             of the C matrix elements and print as integers.
!--
         IF(NODIG==0)THEN
           DO I = ISTART,IEND
           TOINT(I) = ANINT(C(NPT,I,J,K))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
!--
!--             If want 1 digit to right of decimal point
!--
         ELSEIF(NODIG==1)THEN
           WRITE(IUNIT2,18)LABEL,(C(NPT,I,J,K),I=ISTART,IEND)
!--
!--             If want 2
!--
         ELSEIF(NODIG==2)THEN
           WRITE(IUNIT2,19)LABEL,(C(NPT,I,J,K),I=ISTART,IEND)
!--
!--             If want 3
!--
         ELSEIF(NODIG==3)THEN
           WRITE(IUNIT2,30)LABEL,(C(NPT,I,J,K),I=ISTART,IEND)
         ENDIF
!--
!--
!--             If X, same deal.
!--
       ELSEIF(MAT=='  X')THEN
         IF(NODIG==0)THEN
           DO I = ISTART,IEND
           TOINT(I) = ANINT(X(I,J,K))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
         ELSEIF(NODIG==1)THEN
           WRITE(IUNIT2,18)LABEL,(X(I,J,K),I=ISTART,IEND)
         ELSEIF(NODIG==2)THEN
           WRITE(IUNIT2,19)LABEL,(X(I,J,K),I=ISTART,IEND)
         ELSEIF(NODIG==3)THEN
           WRITE(IUNIT2,30)LABEL,(X(I,J,K),I=ISTART,IEND)
         ENDIF
!--
!--             If EN, same deal.
!--
       ELSEIF(MAT==' EN')THEN
         IF(NODIG==0)THEN
           DO I = ISTART,IEND
           TOINT(I) = ANINT(EN(NPT,I,J,K))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
         ELSEIF(NODIG==1)THEN
           WRITE(IUNIT2,18)LABEL,(EN(NPT,I,J,K),I=ISTART,IEND)
         ELSEIF(NODIG==2)THEN
           WRITE(IUNIT2,19)LABEL,(EN(NPT,I,J,K),I=ISTART,IEND)
         ELSEIF(NODIG==3)THEN
           WRITE(IUNIT2,30)LABEL,(EN(NPT,I,J,K),I=ISTART,IEND)
         ENDIF
!--
       ELSEIF(MAT==' BS')THEN
         IF(NODIG==0)THEN
           DO I = ISTART,IEND
           TOINT(I) = ANINT(BIOSPLY(I,J))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
         ELSEIF(NODIG==1)THEN
           WRITE(IUNIT2,18)LABEL,(BIOSPLY(I,J),I=ISTART,IEND)
         ELSEIF(NODIG==2)THEN
           WRITE(IUNIT2,19)LABEL,(BIOSPLY(I,J),I=ISTART,IEND)
         ELSEIF(NODIG==3)THEN
           WRITE(IUNIT2,30)LABEL,(BIOSPLY(I,J),I=ISTART,IEND)
         ENDIF
!--
!--
      ELSEIF(MAT.EQ.' CB')THEN                              !OILSEEDS
         IF(NODIG.EQ.0)THEN
           DO I=ISTART,IEND
             TOINT(I)=ANINT(CRN(I,J,K,3))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
         ELSEIF(NODIG.EQ.1)THEN
           WRITE(IUNIT2,18)LABEL,(CRN(I,J,K,3),I=ISTART,IEND)
         ELSEIF(NODIG.EQ.2)THEN
           WRITE(IUNIT2,19)LABEL,(CRN(I,J,K,3),I=ISTART,IEND)
         ELSEIF(NODIG.EQ.3)THEN
           WRITE(IUNIT2,30)LABEL,(CRN(I,J,K,3),I=ISTART,IEND)
         ENDIF
         !!!!!
!--
       ELSE
!--
!--             If neither C or X (in the crop section), assume its only a label
!--             (which can be blank).
!--
         WRITE(IUNIT2,17)LABEL
       END IF
      END IF
!--
!--             Done with this line; go do next.
      END DO
!--
!--             Draw line at bottom of table
!--
      WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
!--
!--             Done with this crop; go do next.
!CC      END DO
!--
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            !--   *******************************************
            !--   *                                         *
            !--   *                 PRODUCTS                *
            !--   *                                         *
            !--   *******************************************
            !--
            !--             Read Table Title
            !--
                READ(IUNIT1,7)TITLE
            !   10 FORMAT(I2)
            !   11 FORMAT(I3)
!
!                Read the Number of tabs (lines) in this PRODUCT's table.
!
      READ(IUNIT1,10)NOLINES
!
!                Start a new page with headers, page no. etc.
!
      CALL PAGETXT(IPAGE,IUNIT2)
!
!                Write the title of the product's table attaching years to be printed
!
      WRITE(IUNIT2,8)TITLE,IIYEAR(ISTART),IIYEAR(IEND)
            !    5 FORMAT(' ','        Item          ',12I7)
!
!                Write the Heading across the top, (Item and then each year)
!                with line above and below.
!
      WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
      WRITE(IUNIT2,5)(IIYEAR(I),I=ISTART,IEND)
      WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
      WRITE(IUNIT2,20)
            !   20 FORMAT(' ')
                36 FORMAT(A22,A3,1X,I3,I2,1X,F10.0,1X,I1,1X,I1)
            !   17 FORMAT(' ',A22,12I7)
            !   18 FORMAT(' ',A22,12F7.1)
            !   19 FORMAT(' ',A22,12F7.2)
            !--
            !--             Do loop spanning each line in the table
            !--
                DO JJ=1,NOLINES
!
!                Read label, Matrix (PC,PX etc), Variable Index (J), Number of Digits
!                to print {0,1,2}, Multiplicative Scale (not operative 4/15/96)
!
      READ(IUNIT1,36)LABEL,MAT,J,NODIG,SCALE,K
!
!                If printing percentage deviations from baseline override number of digits
!                and force to 2
!
                    IF(INDEX(32)==2)NODIG=2
                !--
                !--             If the line to be printed is the computed stock to utilization ratio
                !--             print it only if printing simulation values. Do not print if printing
                !--             differences or percentages.
                !--
                    IF(J==991)THEN
                        DO I = ISTART,IEND
                        !c           CRMRB(I) = PX(I,5,1)*PXB(I,3,1)*PB(I,4,1)
                        !c     1               + PX(I,5,2)*PXB(I,3,2)*PB(I,4,2)/2000
                        !C           CRMR(I) = CRMR(I)+C(PRTPT,I,9,6)
                        !c            CRMR(I)  =  PX(I,5,1)*PX(I,3,1)*PC(PRTPT,I,4,1)
                        !c     1               + PX(I,5,2)*PX(I,3,2)*PC(PRTPT,I,4,2)/2000
                        ! cc            WRITE(*,*)crmr(i),I,'PRINTTXT'!px(i,5,1),px(i,3,1),PC(PRTPT,i,4,1)
                        !c            WRITE(*,*)px(i,5,2),px(i,3,2),PC(PRTPT,i,4,2),i
                        END DO
       IF(INDEX(32)==1.AND.MAT==' PC')WRITE(IUNIT2,19)LABEL &
                        ,((PC(PRTPT,I,008,K)/PC(PRTPT,I,006,K)),I=ISTART,IEND)
       IF(MAT==' PX')WRITE(IUNIT2,19)LABEL &
                        ,(CRMR(I),I=ISTART,IEND)
                    ELSEIF(J==992) THEN
                    !c         DO I = ISTART,IEND
                    !c            CRMRB(I) = PX(I,5,1)*PXB(I,3,1)*PB(I,4,1)
                    !c     1               + PX(I,5,2)*PXB(I,3,2)*PB(I,4,2)/2000 - B(I,9,6)
                    !c            CRMR(I)  =  PX(I,5,1)*PX(I,3,1)*PC(PRTPT,I,4,1)
                    !c     1               + PX(I,5,2)*PX(I,3,2)*PC(PRTPT,I,4,2)/2000 - C(PRTPT,I,9,6)                      ????????????????
                    !c         END DO
                        IF(MAT==' PX')WRITE(IUNIT2,19)LABEL &
                        ,(CRMR(I),I=ISTART,IEND)
            ELSE
                    !--
                    !--             PC section of printout
                    !--
                        IF(MAT==' PC')THEN
                        !--
                        !--             If to print out with zero digits, set a new vector to the integer of
                        !--             of the PC matrix elements and print as integers.
                        !--
                            IF(NODIG==0)THEN
                                DO I = ISTART,IEND
                                    TOINT(I) = ANINT(PC(PRTPT,I,J,K))
      END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
!
!                If want 1 digit to right of decimal point
!
                            ELSEIF(NODIG==1)THEN
           WRITE(IUNIT2,18)LABEL,(PC(PRTPT,I,J,K),I=ISTART,IEND)
!
!                If want 2
!
                            ELSEIF(NODIG==2)THEN
           WRITE(IUNIT2,19)LABEL,(PC(PRTPT,I,J,K),I=ISTART,IEND)
!
!                If want 3
!
                            ELSEIF(NODIG==3)THEN
           WRITE(IUNIT2,30)LABEL,(PC(PRTPT,I,J,K),I=ISTART,IEND)
!
      ENDIF
                        !--
                        !--             If PX, same deal.
                        !--
                        ELSEIF(MAT==' PX')THEN
                            IF(NODIG==0)THEN
                                DO I = ISTART,IEND
                                    TOINT(I) = ANINT(PX(I,J,K))
                                END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                            ELSEIF(NODIG==1)THEN
           WRITE(IUNIT2,18)LABEL,(PX(I,J,K),I=ISTART,IEND)
                            ELSEIF(NODIG==2)THEN
           WRITE(IUNIT2,19)LABEL,(PX(I,J,K),I=ISTART,IEND)
                            ELSEIF(NODIG==3)THEN
           WRITE(IUNIT2,30)LABEL,(PX(I,J,K),I=ISTART,IEND)
                            ENDIF
                        ELSE
!
!              If neither PC or PX (in the products section), assume its only a label
!              (which can be blank).
!
         WRITE(IUNIT2,17)LABEL
                        END IF
                    END IF
                !--
                !--             Done with this line; go do next.
                END DO
!
!                Draw line at bottom of table
!
      WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
!
!     End of Products Table
!
!
!      *******************************************
!      *                                         *
!      *                  LIVESTOCK              *
!      *                                         *
!      *******************************************
!
                31 FORMAT(A53)
                33 FORMAT(A61)
                32 FORMAT('0',A53,', ',I4,'-',I4)
                34 FORMAT('0',A61,', ',I4,'-',I4)
                12 FORMAT(' ',A22,22A7)
            !--
                IF(INDEX(32) == 2) THEN
                !--      DON'T CHANGE UNITS
                ELSE
                    DO I=1,IEND
                        NANA(I) = 'N/A'
                        XS(PRTPT,I,10,4) = XS(PRTPT,I,10,4)/100
                        S(PRTPT,I,24,4) =  S(PRTPT,I,24,4)/1000
                        S(PRTPT,I,39,4) =  S(PRTPT,I,39,4)/1000
                        XS(PRTPT,I,11,4) = XS(PRTPT,I,11,4)/100
                        XS(PRTPT,I,10,5) = XS(PRTPT,I,10,5)/1000
                        S(PRTPT,I,24,5) =  S(PRTPT,I,24,5)/1000
                        XS(PRTPT,I,13,5) = XS(PRTPT,I,13,5)/1000
                        XS(PRTPT,I,11,5) = XS(PRTPT,I,11,5)/1000
                    END DO
      ENDIF

!                Livestock Section is done differently than crops.
!
!                First read in the number of lines in the TOTAL livestock section
!                (there is no looping by livestock type, but still complete flexibility
!                to adjust what is printed.)
      READ(IUNIT1,11)NOLINES
!                Do Line by line
                DO JJ=1,NOLINES
                !--             If it is the first line, assume the line is the overall Livestock title.
                !--
                !--             Right now the first page of the livestock table has 63 lines, so at line
                !--             64, assume the line is the overall title again but "cont."
                !--
                    IF(INDEX(51) == 1)THEN                                      !CHAD ADDED
                        IF(JJ == 1 .OR. JJ == 49 .OR. JJ == 86 .OR. JJ == 141)THEN
                        !--
                        !--         First have to put in the running header, page no., etc.
                          CALL PAGENO2(IPAGE,IUNIT2)
                        !--         Read different length of title for first and second page so have
                        !--         IF for first and second page.
                            IF(JJ == 1)THEN
                            !--            Read and write of master livestock title
                                READ(IUNIT1,31)TTL1
!               Write title
               WRITE(IUNIT2,32)TTL1,IIYEAR(ISTART),IIYEAR(IEND)
        ELSE
!               IF JJ is 64 then do the other one (wouldn't be in broader IF unless JJ =1 or JJ= 64).
               READ(IUNIT1,33)TTL2
               WRITE(IUNIT2,34)TTL2,IIYEAR(ISTART),IIYEAR(IEND)
                            END IF
!            Draws lines and prints heading as before.
            WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
            WRITE(IUNIT2,5)(IIYEAR(I),I=ISTART,IEND)
            WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
                        END IF
        ELSE
                    !--              PAGE TITLES FOR DANIELS OUTPUT VERSION
                        IF(JJ == 1 .OR. JJ == 64)THEN                                   !SAME THING AS ABOVE
                            CALL PAGENO2(IPAGE,IUNIT2)
                            IF(JJ == 1)THEN
               READ(IUNIT1,31)TTL1
               WRITE(IUNIT2,32)TTL1,IIYEAR(ISTART),IIYEAR(IEND)
        ELSE
               READ(IUNIT1,33)TTL2
               WRITE(IUNIT2,34)TTL2,IIYEAR(ISTART),IIYEAR(IEND)
                            END IF
            WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
            WRITE(IUNIT2,5)(IIYEAR(I),I=ISTART,IEND)
            WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
                        END IF
         ENDIF
!      Since we do not loop by livestock type, need to know which one to print,
!      so for this section have to read in K as well.
!      Everything else as in the crop section.
      READ(IUNIT1,16)LABEL,MAT,J,NODIG,SCALE,K
                !      WRITE(*,*)LABEL,MAT,J,NODIG,SCALE,K
                    IF(J == 991)THEN
                        IF(INDEX(32) == 1)WRITE(IUNIT2,19)LABEL, &
                        ((((S(PRTPT,I,24,K)-S(PRTPT,I-1,24,K))/S(PRTPT,I-1,24,K))*100),I=ISTART+1,IEND)    ! WHY THIS 10/22/01
                    ELSE
                        IF(INDEX(32) == 2)NODIG=2
                        IF(MAT == '  S')THEN                                               !LEAVE OUT NONFAPRI NUMBERS
                            IF((((J==16 .OR. J==17 .OR. J==18 .OR. J==19 .OR. J==20 .OR. J==25 .OR. &
                            J==26 .OR. J==27 .OR. J==28) .AND. K==1) .OR. ((J==26 .OR. J==27 &
                             .OR. J==28) .AND. K==2)) .AND. INDEX(42)==0)THEN
                                WRITE(IUNIT2,12)LABEL,(NANA(I),I=ISTART,IEND)
                            ELSEIF(NODIG == 0)THEN
                                DO I = ISTART,IEND
                                    TOINT(I) = ANINT(S(PRTPT,I,J,K))
                                END DO
                                WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                            ELSEIF(NODIG == 1)THEN
                                WRITE(IUNIT2,18)LABEL,(S(PRTPT,I,J,K),I=ISTART,IEND)
                            ELSEIF(NODIG == 2)THEN
                                WRITE(IUNIT2,19)LABEL,(S(PRTPT,I,J,K),I=ISTART,IEND)
                            ELSEIF(NODIG == 3)THEN
                                WRITE(IUNIT2,30)LABEL,(S(PRTPT,I,J,K),I=ISTART,IEND)
         ENDIF
                        ELSEIF(MAT == ' XS')THEN
                            IF(NODIG == 0)THEN
                                DO I = ISTART,IEND
                                    TOINT(I) = ANINT(XS(PRTPT,I,J,K))
                                END DO
                                WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                            ELSEIF(NODIG == 1)THEN
                                WRITE(IUNIT2,18)LABEL,(XS(PRTPT,I,J,K),I=ISTART,IEND)
                            ELSEIF(NODIG == 2)THEN
                                WRITE(IUNIT2,19)LABEL,(XS(PRTPT,I,J,K),I=ISTART,IEND)
                            ELSEIF(NODIG == 3)THEN
                                WRITE(IUNIT2,30)LABEL,(XS(PRTPT,I,J,K),I=ISTART,IEND)
             ENDIF
                        ELSEIF(MAT == 'SAU')THEN                                          !
                            IF(NODIG == 0)THEN
                                DO I = ISTART,IEND
                                    TOINT(I) = ANINT(SAU(I,J,K))
                                END DO
                                WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                            ELSEIF(NODIG == 1)THEN
                                WRITE(IUNIT2,18)LABEL,(SAU(I,J,K),I=ISTART,IEND)
                            ELSEIF(NODIG == 2)THEN
                                WRITE(IUNIT2,19)LABEL,(SAU(I,J,K),I=ISTART,IEND)
                            ELSEIF(NODIG == 3)THEN
                                WRITE(IUNIT2,30)LABEL,(SAU(I,J,K),I=ISTART,IEND)
           ENDIF
                        ELSEIF(MAT == 'XCR')THEN
                            IF(NODIG == 0)THEN
                                DO I = ISTART,IEND
                                    TOINT(I) = ANINT(XCR(PRTPT,I,J))
         END DO
                                WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                            ELSEIF(NODIG == 1)THEN
                                WRITE(IUNIT2,18)LABEL,(XCR(PRTPT,I,J),I=ISTART,IEND)
                            ELSEIF(NODIG == 2)THEN
                                WRITE(IUNIT2,19)LABEL,(XCR(PRTPT,I,J),I=ISTART,IEND)
                            ELSEIF(NODIG == 3)THEN
                                WRITE(IUNIT2,30)LABEL,(XCR(PRTPT,I,J),I=ISTART,IEND)
             ENDIF
                        ELSEIF(MAT == '  C')THEN
                            IF(NODIG == 0)THEN
                                DO I = ISTART,IEND
                                    TOINT(I) = ANINT(C(PRTPT,I,J,K))
                                END DO
                                WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                            ELSEIF(NODIG == 1)THEN
                                WRITE(IUNIT2,18)LABEL,(C(PRTPT,I,J,K),I=ISTART,IEND)
                            ELSEIF(NODIG == 2)THEN
                                WRITE(IUNIT2,19)LABEL,(C(PRTPT,I,J,K),I=ISTART,IEND)
                            ELSEIF(NODIG == 3)THEN
                                WRITE(IUNIT2,30)LABEL,(C(PRTPT,I,J,K),I=ISTART,IEND)
           ENDIF
                        ELSE
                            WRITE(IUNIT2,17)LABEL
                        END IF
                    END IF
                !--
         END DO
                WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
            !--
                IF(INDEX(32) == 2)THEN
                !--     DON'T CHANGE UNITS
                ELSE
                    DO I=1,IEND
                        XS(PRTPT,I,10,4) = XS(PRTPT,I,10,4)*100
                        S(PRTPT,I,24,4)  = S(PRTPT,I,24,4)*1000
                        S(PRTPT,I,39,4)  = S(PRTPT,I,39,4)*1000
                        XS(PRTPT,I,11,4) = XS(PRTPT,I,11,4)*100
                        XS(PRTPT,I,10,5) = XS(PRTPT,I,10,5)*1000
                        S(PRTPT,I,24,5)  = S(PRTPT,I,24,5)*1000
                        XS(PRTPT,I,13,5) = XS(PRTPT,I,13,5)*1000
                        XS(PRTPT,I,11,5) = XS(PRTPT,I,11,5)*1000
                    END DO
                ENDIF
            !--
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            !--
            !--             *********This is the beginning the Aggregate section**********
            !--
            !--             Begins by reading the number of lines to be printed in the Aggregate table.
            !--
 !     READ(IUNIT1,10)NOLINES
!
!                Right now only set up to print from the "second page" of A and XA, so
!                set K = 2.
!
!                Most everything else repeats the pattern of before with the matrix names
!                replaced
!
!                One difference is that units are printed with the tabs in the crops and
!                livestock section.  Here the units are printed at the top and not printed
!                with any of the tabs.
!
!      K=2
!      DO JJ=1,NOLINES
!      IF(JJ==1)THEN
!        CALL PAGETXT(IPAGE,IUNIT2)
!        READ(IUNIT1,7)TITLE
!        READ(IUNIT1,9)UNITS
!        WRITE(IUNIT2,8)TITLE,IIYEAR(ISTART),IIYEAR(IEND)
!        WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
!        WRITE(IUNIT2,5)(IIYEAR(I),I=ISTART,IEND)
!        WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
!        WRITE(IUNIT2,109)UNITS
!      END IF
!      READ(IUNIT1,16)LABEL,MAT,J,NODIG,SCALE
!      IF(INDEX(32)==2)NODIG=2
!       IF(MAT=='  A')THEN
!         IF(NODIG==0)THEN
!           DO I = ISTART,IEND
!           TOINT(I) = ANINT(A(I,J,K))
!         END DO
!           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
!         ELSEIF(NODIG==1)THEN
 !          WRITE(IUNIT2,18)LABEL,(A(I,J,K),I=ISTART,IEND)
!         ELSEIF(NODIG==2)THEN
!           WRITE(IUNIT2,19)LABEL,(A(I,J,K),I=ISTART,IEND)
!         ELSEIF(NODIG==3)THEN
!           WRITE(IUNIT2,30)LABEL,(A(I,J,K),I=ISTART,IEND)
!         ENDIF
!       ELSEIF(MAT==' XA')THEN
!         IF(NODIG==0)THEN
!           DO I = ISTART,IEND
!           TOINT(I) = ANINT(XA(I,J,K))
!         END DO
!           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
!         ELSEIF(NODIG==1)THEN
!           WRITE(IUNIT2,18)LABEL,(XA(I,J,K),I=ISTART,IEND)
!         ELSEIF(NODIG==2)THEN
!           WRITE(IUNIT2,19)LABEL,(XA(I,J,K),I=ISTART,IEND)
!         ELSEIF(NODIG==3)THEN
!           WRITE(IUNIT2,30)LABEL,(XA(I,J,K),I=ISTART,IEND)
!          ENDIF
!       ELSE
!         WRITE(IUNIT2,17)LABEL
!       END IF
!         END DO
!      WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
!
!
!
!
!               ********** This is the beginning the section that prints out ************
!                ac., prices, exports, ending stocks for each crop
!                in one table
!
!                Begins by reading the number of lines to be printed.
!
!
      READ(IUNIT1,10)NOLINES  !22
!
!                Right now only set up to print from the "second page" of A and XA, so
!                set K = 2.
!
!                Most everything else repeats the pattern of before with the matrix names
!                replaced
!
!                One difference is that units are printed with the tabs in the crops and
!                livestock section.  Here the units are printed at the top and not printed
!                with any of the tabs.
!
    DO JJ=1,NOLINES
       IF(JJ==1)THEN
        CALL PAGETXT(IPAGE,IUNIT2)
        READ(IUNIT1,7)TITLE
        WRITE(IUNIT2,98)TITLE,IIYEAR(ISTART),IIYEAR(IEND)
        WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
        WRITE(IUNIT2,5)(IIYEAR(I),I=ISTART,IEND)
        WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
        WRITE(IUNIT2,20)
      END IF
      READ(IUNIT1,71)LABEL,MAT,J,K,NODIG,SCALE
      IF(INDEX(32)==2)NODIG=2
       IF(MAT=='  A')THEN
         IF(NODIG==0)THEN
           DO I = ISTART,IEND
           TOINT(I) = ANINT(A(PRTPT,I,J,K))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
         ELSEIF(NODIG==1)THEN
           WRITE(IUNIT2,18)LABEL,(A(PRTPT,I,J,K),I=ISTART,IEND)
         ELSEIF(NODIG==2)THEN
           WRITE(IUNIT2,19)LABEL,(A(PRTPT,I,J,K),I=ISTART,IEND)
         ELSEIF(NODIG==3)THEN
           WRITE(IUNIT2,30)LABEL,(A(PRTPT,I,J,K),I=ISTART,IEND)
      ENDIF
       ELSEIF(MAT=='  C')THEN
         IF(NODIG==0)THEN
           DO I = ISTART,IEND
           TOINT(I) = ANINT(C(PRTPT,I,J,K))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
         ELSEIF(NODIG==1)THEN
           WRITE(IUNIT2,18)LABEL,(C(PRTPT,I,J,K),I=ISTART,IEND)
         ELSEIF(NODIG==2)THEN
           WRITE(IUNIT2,19)LABEL,(C(PRTPT,I,J,K),I=ISTART,IEND)
         ELSEIF(NODIG==3)THEN
           WRITE(IUNIT2,30)LABEL,(C(PRTPT,I,J,K),I=ISTART,IEND)
      ENDIF
       ELSEIF(MAT=='  X')THEN
         IF(NODIG==0)THEN
           DO I = ISTART,IEND
           TOINT(I) = ANINT(X(I,J,K))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
         ELSEIF(NODIG==1)THEN
           WRITE(IUNIT2,18)LABEL,(X(I,J,K),I=ISTART,IEND)
         ELSEIF(NODIG==2)THEN
           WRITE(IUNIT2,19)LABEL,(X(I,J,K),I=ISTART,IEND)
         ELSEIF(NODIG==3)THEN
           WRITE(IUNIT2,30)LABEL,(X(I,J,K),I=ISTART,IEND)
      ENDIF
       ELSEIF(MAT==' XA')THEN
         IF(NODIG==0)THEN
           DO I = ISTART,IEND
           TOINT(I) = ANINT(XA(I,J,K))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
         ELSEIF(NODIG==1)THEN
           WRITE(IUNIT2,18)LABEL,(XA(I,J,K),I=ISTART,IEND)
         ELSEIF(NODIG==2)THEN
           WRITE(IUNIT2,19)LABEL,(XA(I,J,K),I=ISTART,IEND)
         ELSEIF(NODIG==3)THEN
           WRITE(IUNIT2,30)LABEL,(XA(I,J,K),I=ISTART,IEND)
      ENDIF
!!!
       ELSEIF(MAT==' PC')THEN
         IF(NODIG==0)THEN
           DO I = ISTART,IEND
           TOINT(I) = ANINT(PC(PRTPT,I,J,K))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
         ELSEIF(NODIG==1)THEN
           WRITE(IUNIT2,18)LABEL,(PC(PRTPT,I,J,K),I=ISTART,IEND)
         ELSEIF(NODIG==2)THEN
           WRITE(IUNIT2,19)LABEL,(PC(PRTPT,I,J,K),I=ISTART,IEND)
         ELSEIF(NODIG==3)THEN
           WRITE(IUNIT2,30)LABEL,(PC(PRTPT,I,J,K),I=ISTART,IEND)
      ENDIF
!!!!!
      ELSEIF(MAT.EQ.' CB')THEN                              !OILSEEDS
         IF(NODIG.EQ.0)THEN
           DO I=ISTART,IEND
             TOINT(I)=ANINT(CRN(I,J,K,T))
           END DO
           WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
         ELSEIF(NODIG.EQ.1)THEN
           WRITE(IUNIT2,18)LABEL,(CRN(I,J,K,T),I=ISTART,IEND)
         ELSEIF(NODIG.EQ.2)THEN
           WRITE(IUNIT2,19)LABEL,(CRN(I,J,K,T),I=ISTART,IEND)
         ELSEIF(NODIG.EQ.3)THEN
           WRITE(IUNIT2,30)LABEL,(CRN(I,J,K,T),I=ISTART,IEND)
         ENDIF
         !!!!!
!!!
       ELSE
         WRITE(IUNIT2,17)LABEL
       END IF
    END DO
      WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)


!
!      ********************************************
!      *        BIOPRODUCTS OUTPUT                *
!      ********************************************
!
                DO I=ISTART,IEND
                    BIODMND(I,1)=BIODMND(I,1)/1000000000
                    BIOSPLY(I,1)=BIOSPLY(I,1)/1000000000
                    BIODMND(I,2)=BIODMND(I,2)/1000000000
                    BIOSPLY(I,2)=BIOSPLY(I,2)/1000000000
                    BIODMND(I,3)=BIODMND(I,3)/1000000000
                    BIOSPLY(I,3)=BIOSPLY(I,3)/1000000000
                    BIODMND(I,4)=BIODMND(I,4)/1000000
                    BIOSPLY(I,4)=BIOSPLY(I,4)/1000000
                    BIODMND(I,5)=BIODMND(I,5)/1000000
                    BIOSPLY(I,5)=BIOSPLY(I,5)/1000000
                    BIODMND(I,6)=BIODMND(I,6)/1000000
                    BIOSPLY(I,6)=BIOSPLY(I,6)/1000000
                    BIODMND(I,7)=BIODMND(I,7)/1000000
                !C        BIOSPLY(I,7)=BIOSPLY(I,7)/1000000  !SEE SUMBIO.FOR ALREADY IN MIL TONS
                   DO K=1,7
                        DO J=1,14 !update from UT 2019
                            FDSTK(I,J,K)=FDSTK(I,J,K)/1000000
                        END DO
                    !C         FDSTK(I,4,8)=FDSTK(I,4,8) + FDSTK(I,4,K) !**NOW IN RMAIN**!  !GET TOTAL CORN GRAIN FOR BIOPRODUCTS FOR REPORTING BELOW
                    !C         FDSTK(I,6,8)=FDSTK(I,6,8) + FDSTK(I,6,K) !**NOW IN RMAIN**!  !WOOD FOR REPORTING BELOW
                        DO J=1,3
                            BIOCST(I,J,K)=BIOCST(I,J,K)/1000000
      ENDDO
                    ENDDO
                !--   ***FIGURE NATIONAL CRP ACRES IN***
                    CRPNAT(I) = 0.0
                    PASTNAT(I)= 0.0
                    DO CRDL=1,305
                        CRPNAT(I) = CRPNAT(I) +0! CRPOUT(I,CRDL)
                        PASTNAT(I)=PASTNAT(I) +0!(PASTOUT(I,CRDL)-HAYIN(I,CRDL))
                        HAYNAT(I) = HAYNAT(I) +0! HAYIN(I,CRDL)
                    END DO
                    DLOOP=1
                    CRPNAT(I) = CRPNAT(I) / 1000000
                    PASTNAT(I)= PASTNAT(I)/ 1000000
                    HAYNAT(I) = HAYNAT(I) / 1000000
                    AVSTVR(I,DLOOP) = AVSTVR(I,DLOOP) / 1000000
                   AVSTW(I,DLOOP)  =  AVSTW(I,DLOOP) / 1000000
                   AVSWTCH(I,DLOOP)=AVSWTCH(I,DLOOP) / 1000000
                   AVWOOD(I) = AVWOOD(I) / 1000000
                   AVPOP(I,DLOOP) = AVPOP(I,DLOOP) /1000000
                   AVWIL(I,DLOOP) = AVWIL(I,DLOOP) /1000000
                   AVSWEET(I,DLOOP)=AVSWEET(I,DLOOP)/1000000
                   AVCRP(I,DLOOP)=AVCRP(I,DLOOP)/1000000
                   AVMISCAN(I,DLOOP)=AVMISCAN(I,DLOOP)/1000000
                   AVECANE(I,DLOOP)=AVECANE(I,DLOOP)/1000000
                END DO

!
      READ(IUNIT1,11)NOLINES

                DO JJ=1,NOLINES
                    IF(JJ == 1)THEN
         CALL PAGENO2(IPAGE,IUNIT2)
         READ(IUNIT1,31)TTL1
         WRITE(IUNIT2,32)TTL1,IIYEAR(ISTART),IIYEAR(IEND)
         WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
         WRITE(IUNIT2,5)(IIYEAR(I),I=ISTART,IEND)
         WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
      ENDIF
       READ(IUNIT1,16)LABEL,MAT,J,NODIG,SCALE,K


                    IF(MAT == ' BD')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                                TOINT(I)=ANINT(BIODMND(I,K))
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                            WRITE(IUNIT2,18)LABEL,(BIODMND(I,K),I=ISTART,IEND)
                        ELSEIF(NODIG == 2)THEN
                            WRITE(IUNIT2,19)LABEL,(BIODMND(I,K),I=ISTART,IEND)
                        ELSEIF(NODIG == 3)THEN
                            WRITE(IUNIT2,30)LABEL,(BIODMND(I,K),I=ISTART,IEND)
      ENDIF
                    ELSEIF(MAT == ' BS')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                                TOINT(I)=ANINT(BIOSPLY(I,K))
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                            WRITE(IUNIT2,18)LABEL,(BIOSPLY(I,K),I=ISTART,IEND)
                        ELSEIF(NODIG == 2)THEN
                            WRITE(IUNIT2,19)LABEL,(BIOSPLY(I,K),I=ISTART,IEND)
                        ELSEIF(NODIG == 3)THEN
                            WRITE(IUNIT2,30)LABEL,(BIOSPLY(I,K),I=ISTART,IEND)
      ENDIF
                    ELSEIF(MAT == ' BC')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                                TOINT(I)=ANINT(BIOCST(I,J,K))
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                            WRITE(IUNIT2,18)LABEL,(BIOCST(I,J,K),I=ISTART,IEND)
                        ELSEIF(NODIG == 2)THEN
                            WRITE(IUNIT2,19)LABEL,(BIOCST(I,J,K),I=ISTART,IEND)
                        ELSEIF(NODIG == 3)THEN
                            WRITE(IUNIT2,30)LABEL,(BIOCST(I,J,K),I=ISTART,IEND)
      ENDIF
                    ELSEIF(MAT == ' FS')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                                TOINT(I)=ANINT(FDSTK(I,J,K))
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                            WRITE(IUNIT2,18)LABEL,(FDSTK(I,J,K),I=ISTART,IEND)
                        ELSEIF(NODIG == 2)THEN
                            WRITE(IUNIT2,19)LABEL,(FDSTK(I,J,K),I=ISTART,IEND)
                        ELSEIF(NODIG == 3)THEN
                            WRITE(IUNIT2,30)LABEL,(FDSTK(I,J,K),I=ISTART,IEND)
      ENDIF
                    ELSEIF(MAT == '  C')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                                TOINT(I)=ANINT(C(PRTPT,I,J,K))
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                            WRITE(IUNIT2,18)LABEL,(C(PRTPT,I,J,K),I=ISTART,IEND)
                        ELSEIF(NODIG == 2)THEN
                            WRITE(IUNIT2,19)LABEL,(C(PRTPT,I,J,K),I=ISTART,IEND)
                        ELSEIF(NODIG == 3)THEN
                            WRITE(IUNIT2,30)LABEL,(C(PRTPT,I,J,K),I=ISTART,IEND)
      ENDIF
                    ELSEIF(MAT == ' PC')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                                TOINT(I)=ANINT(PC(PRTPT,I,J,K))
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                            WRITE(IUNIT2,18)LABEL,(PC(PRTPT,I,J,K),I=ISTART,IEND)
                        ELSEIF(NODIG == 2)THEN
                            WRITE(IUNIT2,19)LABEL,(PC(PRTPT,I,J,K),I=ISTART,IEND)
                        ELSEIF(NODIG == 3)THEN
                            WRITE(IUNIT2,30)LABEL,(PC(PRTPT,I,J,K),I=ISTART,IEND)
      ENDIF
                    ELSEIF(MAT == ' CR')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                                TOINT(I)=ANINT(CRPNAT(I))
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                            WRITE(IUNIT2,18)LABEL,(CRPNAT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 2)THEN
                            WRITE(IUNIT2,19)LABEL,(CRPNAT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 3)THEN
                            WRITE(IUNIT2,30)LABEL,(CRPNAT(I),I=ISTART,IEND)
      ENDIF
                    ELSEIF(MAT == ' PA')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                                TOINT(I)=ANINT(PASTNAT(I))
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                            WRITE(IUNIT2,18)LABEL,(PASTNAT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 2)THEN
                            WRITE(IUNIT2,19)LABEL,(PASTNAT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 3)THEN
                            WRITE(IUNIT2,30)LABEL,(PASTNAT(I),I=ISTART,IEND)
      ENDIF
                    ELSEIF(MAT == ' HA')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                                TOINT(I)=ANINT(HAYNAT(I))
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                            WRITE(IUNIT2,18)LABEL,(HAYNAT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 2)THEN
                            WRITE(IUNIT2,19)LABEL,(HAYNAT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 3)THEN
                            WRITE(IUNIT2,30)LABEL,(HAYNAT(I),I=ISTART,IEND)
      ENDIF
                    ELSEIF(MAT == ' CN')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                                TOINT(I)=ANINT(AVSTVR(I,DLOOP))
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                            WRITE(IUNIT2,18)LABEL,(AVSTVR(I,DLOOP),I=ISTART,IEND)
                        ELSEIF(NODIG == 2)THEN
                            WRITE(IUNIT2,19)LABEL,(AVSTVR(I,DLOOP),I=ISTART,IEND)
                        ELSEIF(NODIG == 3)THEN
                            WRITE(IUNIT2,30)LABEL,(AVSTVR(I,DLOOP),I=ISTART,IEND)
      ENDIF
                    ELSEIF(MAT == ' WH')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                                TOINT(I)=ANINT(AVSTW(I,DLOOP))
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                            WRITE(IUNIT2,18)LABEL,(AVSTW(I,DLOOP),I=ISTART,IEND)
                        ELSEIF(NODIG == 2)THEN
                            WRITE(IUNIT2,19)LABEL,(AVSTW(I,DLOOP),I=ISTART,IEND)
                        ELSEIF(NODIG == 3)THEN
                            WRITE(IUNIT2,30)LABEL,(AVSTW(I,DLOOP),I=ISTART,IEND)
                        ENDIF
                    ELSEIF(MAT == ' WR')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                                TOINT(I)=ANINT(AVWOOD(I))
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                            WRITE(IUNIT2,18)LABEL,(AVWOOD(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 2)THEN
                            WRITE(IUNIT2,19)LABEL,(AVWOOD(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 3)THEN
                            WRITE(IUNIT2,30)LABEL,(AVWOOD(I),I=ISTART,IEND)
                        ENDIF
                    ELSEIF(MAT == ' WD')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                                TOINT(I)=ANINT(WD(I))
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                        !C           WRITE(IUNIT2,18)LABEL,(WOODPRC(I),I=ISTART,IEND) !EIA CHAD 2017
                        ELSEIF(NODIG == 2)THEN
                        !C           WRITE(IUNIT2,19)LABEL,(WOODPRC(I),I=ISTART,IEND) !EIA CHAD 2017
                        ELSEIF(NODIG == 3)THEN
                        !C           WRITE(IUNIT2,30)LABEL,(WOODPRC(I),I=ISTART,IEND) !EIA CHAD 2017
                        ENDIF
                    ELSEIF(MAT == 'CRP')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                                TOINT(I)=ANINT(AVCRP(I,DLOOP))
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                            WRITE(IUNIT2,18)LABEL,(AVCRP(I,DLOOP),I=ISTART,IEND)
                        ELSEIF(NODIG == 2)THEN
                            WRITE(IUNIT2,19)LABEL,(AVCRP(I,DLOOP),I=ISTART,IEND)
                        ELSEIF(NODIG == 3)THEN
                            WRITE(IUNIT2,30)LABEL,(AVCRP(I,DLOOP),I=ISTART,IEND)
      ENDIF
                    ELSEIF(MAT == ' SW')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                                TOINT(I)=ANINT(AVSWTCH(I,DLOOP))
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                            WRITE(IUNIT2,18)LABEL,(AVSWTCH(I,DLOOP),I=ISTART,IEND)
                        ELSEIF(NODIG == 2)THEN
                            WRITE(IUNIT2,19)LABEL,(AVSWTCH(I,DLOOP),I=ISTART,IEND)
                        ELSEIF(NODIG == 3)THEN
                            WRITE(IUNIT2,30)LABEL,(AVSWTCH(I,DLOOP),I=ISTART,IEND)
      ENDIF
                    !--
                    ELSEIF(MAT == ' MS')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                                TOINT(I)=ANINT(AVMISCAN(I,DLOOP))
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                            WRITE(IUNIT2,18)LABEL,(AVMISCAN(I,DLOOP),I=ISTART,IEND)
                        ELSEIF(NODIG == 2)THEN
                            WRITE(IUNIT2,19)LABEL,(AVMISCAN(I,DLOOP),I=ISTART,IEND)
                        ELSEIF(NODIG == 3)THEN
                            WRITE(IUNIT2,30)LABEL,(AVMISCAN(I,DLOOP),I=ISTART,IEND)
      ENDIF
                    ELSEIF(MAT == ' EC')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                                TOINT(I)=ANINT(AVECANE(I,DLOOP))
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                            WRITE(IUNIT2,18)LABEL,(AVECANE(I,DLOOP),I=ISTART,IEND)
                        ELSEIF(NODIG == 2)THEN
                            WRITE(IUNIT2,19)LABEL,(AVECANE(I,DLOOP),I=ISTART,IEND)
                        ELSEIF(NODIG == 3)THEN
                            WRITE(IUNIT2,30)LABEL,(AVECANE(I,DLOOP),I=ISTART,IEND)
                        ENDIF
                    !--
                    !--
                    ELSEIF(MAT == ' SS')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                                TOINT(I)=ANINT(AVSWEET(I,DLOOP))
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                            WRITE(IUNIT2,18)LABEL,(AVSWEET(I,DLOOP),I=ISTART,IEND)
                        ELSEIF(NODIG == 2)THEN
                            WRITE(IUNIT2,19)LABEL,(AVSWEET(I,DLOOP),I=ISTART,IEND)
                        ELSEIF(NODIG == 3)THEN
                            WRITE(IUNIT2,30)LABEL,(AVSWEET(I,DLOOP),I=ISTART,IEND)
      ENDIF
                    ELSEIF(MAT == ' PL')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                                TOINT(I)=ANINT(AVPOP(I,DLOOP))
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                            WRITE(IUNIT2,18)LABEL,(AVPOP(I,DLOOP),I=ISTART,IEND)
                        ELSEIF(NODIG == 2)THEN
                            WRITE(IUNIT2,19)LABEL,(AVPOP(I,DLOOP),I=ISTART,IEND)
                        ELSEIF(NODIG == 3)THEN
                            WRITE(IUNIT2,30)LABEL,(AVPOP(I,DLOOP),I=ISTART,IEND)
      ENDIF
                    ELSEIF(MAT == ' WL')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                                TOINT(I)=ANINT(AVWIL(I,DLOOP))
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                            WRITE(IUNIT2,18)LABEL,(AVWIL(I,DLOOP),I=ISTART,IEND)
                        ELSEIF(NODIG == 2)THEN
                            WRITE(IUNIT2,19)LABEL,(AVWIL(I,DLOOP),I=ISTART,IEND)
                        ELSEIF(NODIG == 3)THEN
                            WRITE(IUNIT2,30)LABEL,(AVWIL(I,DLOOP),I=ISTART,IEND)
                        ENDIF
                    !--
                    !--
                    ELSEIF(MAT == ' EN')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                                TOINT(I)=ANINT(EN(PRTPT,I,J,K))
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                            WRITE(IUNIT2,18)LABEL,(EN(PRTPT,I,J,K),I=ISTART,IEND)
                        ELSEIF(NODIG == 2)THEN
                            WRITE(IUNIT2,19)LABEL,(EN(PRTPT,I,J,K),I=ISTART,IEND)
                        ELSEIF(NODIG == 3)THEN
                            WRITE(IUNIT2,30)LABEL,(EN(PRTPT,I,J,K),I=ISTART,IEND)
      ENDIF
                    ELSEIF(MAT == '  X')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                                TOINT(I)=ANINT(X(I,J,K))
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                            WRITE(IUNIT2,18)LABEL,(X(I,J,K),I=ISTART,IEND)
                        ELSEIF(NODIG == 2)THEN
                            WRITE(IUNIT2,19)LABEL,(X(I,J,K),I=ISTART,IEND)
                        ELSEIF(NODIG == 3)THEN
                            WRITE(IUNIT2,30)LABEL,(X(I,J,K),I=ISTART,IEND)
      ENDIF
                    ELSEIF(MAT == ' PO')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                                TOINT(I)=ANINT(POOP(I,K))
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                            WRITE(IUNIT2,18)LABEL,(POOP(I,K),I=ISTART,IEND)
                        ELSEIF(NODIG == 2)THEN
                            WRITE(IUNIT2,19)LABEL,(POOP(I,K),I=ISTART,IEND)
                        ELSEIF(NODIG == 3)THEN
                            WRITE(IUNIT2,30)LABEL,(POOP(I,K),I=ISTART,IEND)
      ENDIF
         ELSE
                        WRITE(IUNIT2,17)LABEL
         ENDIF
                END DO
                WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
            !C      CLOSE(8)
            !--
            !--
                DO I=ISTART,IEND
                    BIODMND(I,1)=BIODMND(I,1)*1000000000
                    BIOSPLY(I,1)=BIOSPLY(I,1)*1000000000
                    BIODMND(I,2)=BIODMND(I,2)*1000000000
                    BIOSPLY(I,2)=BIOSPLY(I,2)*1000000000
                    BIODMND(I,3)=BIODMND(I,3)*1000000000
                    BIOSPLY(I,3)=BIOSPLY(I,3)*1000000000
                    BIODMND(I,4)=BIODMND(I,4)*1000000
                    BIOSPLY(I,4)=BIOSPLY(I,4)*1000000
                    BIODMND(I,5)=BIODMND(I,5)*1000000
                    BIOSPLY(I,5)=BIOSPLY(I,5)*1000000
                    BIODMND(I,6)=BIODMND(I,6)*1000000
                    BIOSPLY(I,6)=BIOSPLY(I,6)*1000000
                    BIODMND(I,7)=BIODMND(I,7)*1000000
                !C        BIOSPLY(I,7)=BIOSPLY(I,7)*1000000 !SEE SUMBIO.FOR ALREADY IN MIL TONS
                    DO K=1,7
                        DO J=1,13 !6
                            FDSTK(I,J,K)=FDSTK(I,J,K)*1000000
                        END DO
                        DO J=1,3
                            BIOCST(I,J,K)=BIOCST(I,J,K)*1000000
        ENDDO
       ENDDO
                    CRPNAT(I) = CRPNAT(I) * 1000000
                    PASTNAT(I)= PASTNAT(I)* 1000000
                    HAYNAT(I) = HAYNAT(I) * 1000000
                    AVSTVR(I,DLOOP) = AVSTVR(I,DLOOP) * 1000000
                    AVSTW(I,DLOOP)  =  AVSTW(I,DLOOP) * 1000000
                    AVSWTCH(I,DLOOP)=AVSWTCH(I,DLOOP) * 1000000
                    AVWOOD(I) = AVWOOD(I) * 1000000
                    AVPOP(I,DLOOP) = AVPOP(I,DLOOP) * 1000000
                    AVWIL(I,DLOOP) = AVWIL(I,DLOOP) * 1000000
                    AVSWEET(I,DLOOP)=AVSWEET(I,DLOOP)*1000000
                    AVCRP(I,DLOOP)=AVCRP(I,DLOOP)*1000000
                    AVMISCAN(I,DLOOP)=AVMISCAN(I,DLOOP)*1000000
                    AVECANE(I,DLOOP)=AVECANE(I,DLOOP)*1000000
                END DO
            !--
            !-- *********************END OF BIO-PRODUCTS SECTION******** p23 *******************************
            !--
            !--     ******RESIDUES PRODUCTION********
            !--
                READ(IUNIT1,11)NOLINES
                DO JJ=1,NOLINES
                    IF(JJ == 1)THEN
                        CALL PAGENO2(IPAGE,IUNIT2)
                        READ(IUNIT1,31)TTL1
                        WRITE(IUNIT2,32)TTL1,IIYEAR(ISTART),IIYEAR(IEND)
                        WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
                        WRITE(IUNIT2,5)(IIYEAR(I),I=ISTART,IEND)
                        WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
      ENDIF
                    READ(IUNIT1,16)LABEL,MAT,J,NODIG,SCALE,K
                    IF(MAT == ' EN')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                                TOINT(I)=ANINT(EN(PRTPT,I,J,K))
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                            WRITE(IUNIT2,18)LABEL,(EN(PRTPT,I,J,K),I=ISTART,IEND)
                        ELSEIF(NODIG == 2)THEN
                            WRITE(IUNIT2,19)LABEL,(EN(PRTPT,I,J,K),I=ISTART,IEND)
                        ELSEIF(NODIG == 3)THEN
                            WRITE(IUNIT2,30)LABEL,(EN(PRTPT,I,J,K),I=ISTART,IEND)
      ENDIF
                    ELSE
                        WRITE(IUNIT2,17)LABEL
      ENDIF
                END DO
                WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
            !--
            !--
            !--
            !--
            !--
            !-- ****START CARBON AND TILLAGE OUTPUT****
            !--
                66 FORMAT(A22,5X,A3,1X,I3,I2,1X,F10.0,1x,I2,1x,I1)
            !--
                READ(IUNIT1,11)NOLINES
                DO JJ=1,NOLINES
                    IF(JJ == 1)THEN
                        CALL PAGENO2(IPAGE,IUNIT2)
                        READ(IUNIT1,31)TTL1
                        WRITE(IUNIT2,32)TTL1,IIYEAR(ISTART),IIYEAR(IEND)
                        WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
                        WRITE(IUNIT2,5)(IIYEAR(I),I=ISTART,IEND)
                        WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
      ENDIF
                    READ(IUNIT1,66)LABEL,MAT,J,NODIG,SCALE,K,T
                    IF(MAT == ' CB')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                                TOINT(I)=ANINT(CRN(I,J,K,T))
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                            WRITE(IUNIT2,18)LABEL,(CRN(I,J,K,T),I=ISTART,IEND)
                        ELSEIF(NODIG == 2)THEN
                            WRITE(IUNIT2,19)LABEL,(CRN(I,J,K,T),I=ISTART,IEND)
                        ELSEIF(NODIG == 3)THEN
                            WRITE(IUNIT2,30)LABEL,(CRN(I,J,K,T),I=ISTART,IEND)
      ENDIF
                    ELSEIF(MAT == ' PT')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                                TOINT(I)=ANINT(PTTOTAL(I))
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                            WRITE(IUNIT2,18)LABEL,(PTTOTAL(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 2)THEN
                            WRITE(IUNIT2,19)LABEL,(PTTOTAL(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 3)THEN
                            WRITE(IUNIT2,30)LABEL,(PTTOTAL(I),I=ISTART,IEND)
      ENDIF
                    ELSEIF(MAT == ' CT')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                                TOINT(I)=ANINT(CARBTOT(I,J))
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                            WRITE(IUNIT2,18)LABEL,(CARBTOT(I,J),I=ISTART,IEND)
                        ELSEIF(NODIG == 2)THEN
                            WRITE(IUNIT2,19)LABEL,(CARBTOT(I,J),I=ISTART,IEND)
                        ELSEIF(NODIG == 3)THEN
                            WRITE(IUNIT2,30)LABEL,(CARBTOT(I,J),I=ISTART,IEND)
      ENDIF
                    ELSEIF(MAT == ' XI')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                                TOINT(I)=ANINT(CENT(I,J))       !INCENTIVES TO NATIONAL LEVEL
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                            WRITE(IUNIT2,18)LABEL,(CENT(I,J),I=ISTART,IEND)
                        ELSEIF(NODIG == 2)THEN
                            WRITE(IUNIT2,19)LABEL,(CENT(I,J),I=ISTART,IEND)
                        ELSEIF(NODIG == 3)THEN
                            WRITE(IUNIT2,30)LABEL,(CENT(I,J),I=ISTART,IEND)
      ENDIF
                    ELSEIF(MAT == ' EN')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                                TOINT(I)=ANINT(EN(PRTPT,I,J,K))
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                            WRITE(IUNIT2,18)LABEL,(EN(PRTPT,I,J,K),I=ISTART,IEND)
                        ELSEIF(NODIG == 2)THEN
                            WRITE(IUNIT2,19)LABEL,(EN(PRTPT,I,J,K),I=ISTART,IEND)
                        ELSEIF(NODIG == 3)THEN
                            WRITE(IUNIT2,30)LABEL,(EN(PRTPT,I,J,K),I=ISTART,IEND)
      ENDIF
                    ELSEIF(MAT == ' FF')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                            !C             TOINT(I)=ANINT(FRETN(I,J,K)) !EIA CHAD 2017
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                        !C           WRITE(IUNIT2,18)LABEL,(FRETN(I,J,K),I=ISTART,IEND) !EIA CHAD 2017
                        ELSEIF(NODIG == 2)THEN
                        !C           WRITE(IUNIT2,19)LABEL,(FRETN(I,J,K),I=ISTART,IEND) !EIA CHAD 2017
                        ELSEIF(NODIG == 3)THEN
                        !C           WRITE(IUNIT2,30)LABEL,(FRETN(I,J,K),I=ISTART,IEND) !EIA CHAD 2017
                        ENDIF
                    !--
                    ELSEIF(MAT == 'CRP')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                            !C             TOINT(I)=ANINT(CRPTOT(I,J,K)) !EIA CHAD 2017
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                        !C           WRITE(IUNIT2,18)LABEL,(CRPTOT(I,J,K),I=ISTART,IEND) !EIA CHAD 2017
                        ELSEIF(NODIG == 2)THEN
                        !C           WRITE(IUNIT2,19)LABEL,(CRPTOT(I,J,K),I=ISTART,IEND) !EIA CHAD 2017
                        ELSEIF(NODIG == 3)THEN
                        !C           WRITE(IUNIT2,30)LABEL,(CRPTOT(I,J,K),I=ISTART,IEND) !EIA CHAD 2017
      ENDIF
                    !--
                    ELSE
                        WRITE(IUNIT2,17)LABEL
                    END IF
                END DO
                WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
            !--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            !--
            !--
            !--
            !-- ****START CRP ACREAGE OUTPUT****
            !--
                92 FORMAT(A22,5X,A3,1X,I3,I2,1X,F10.0,1x,I2,1x,I1)
            !--
                READ(IUNIT1,11)NOLINES
                DO JJ=1,NOLINES
                    IF(JJ == 1)THEN
                        CALL PAGENO2(IPAGE,IUNIT2)
                        READ(IUNIT1,31)TTL1
                        WRITE(IUNIT2,32)TTL1,IIYEAR(ISTART),IIYEAR(IEND)
                        WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
                        WRITE(IUNIT2,5)(IIYEAR(I),I=ISTART,IEND)
                        WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
      ENDIF
                    READ(IUNIT1,92)LABEL,MAT,J,NODIG,SCALE,K,T
                    IF(MAT == 'CRP')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                            !C             TOINT(I)=ANINT(CRPTOT(I,J,K)) !EIA CHAD 2017
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                        !C           WRITE(IUNIT2,18)LABEL,(CRPTOT(I,J,K),I=ISTART,IEND) !EIA CHAD 2017
                        ELSEIF(NODIG == 2)THEN
                        !C           WRITE(IUNIT2,19)LABEL,(CRPTOT(I,J,K),I=ISTART,IEND) !EIA CHAD 2017
                        ELSEIF(NODIG == 3)THEN
                        !C           WRITE(IUNIT2,30)LABEL,(CRPTOT(I,J,K),I=ISTART,IEND) !EIA CHAD 2017
                        ENDIF

                    ELSEIF(MAT == 'INF')THEN
                        IF(NODIG == 0)THEN
                            DO I=ISTART,IEND
                                TOINT(I)=ANINT(INFL(I,J,K))
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG == 1)THEN
                            WRITE(IUNIT2,18)LABEL,(INFL(I,J,K),I=ISTART,IEND)
                        ELSEIF(NODIG == 2)THEN
                            WRITE(IUNIT2,19)LABEL,(INFL(I,J,K),I=ISTART,IEND)
                        ELSEIF(NODIG == 3)THEN
                            WRITE(IUNIT2,30)LABEL,(INFL(I,J,K),I=ISTART,IEND)
                        ENDIF
                    ELSE
                        WRITE(IUNIT2,17)LABEL
                    END IF
                END DO
                WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
            !--
            !-- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            !--
            !--             *********This is the beginning the Aggregate section**********
            !--
            !--             Begins by reading the number of lines to be printed in the Aggregate table.
            !--
                READ(IUNIT1,10)NOLINES
            !--
            !--             Right now only set up to print from the "second page" of A and XA, so
            !--             set K = 2.
            !--
            !--             Most everything else repeats the pattern of before with the matrix names
            !--             replaced
            !--
            !--             One difference is that units are printed with the tabs in the crops and
            !--             livestock section.  Here the units are printed at the top and not printed
            !--             with any of the tabs.
            !--
                K=2
                DO JJ=1,NOLINES
                    IF(JJ==1)THEN
                        CALL PAGETXT(IPAGE,IUNIT2)
                        READ(IUNIT1,7)TITLE
                        READ(IUNIT1,9)UNITS
                        WRITE(IUNIT2,8)TITLE,IIYEAR(ISTART),IIYEAR(IEND)
                        WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
                        WRITE(IUNIT2,5)(IIYEAR(I),I=ISTART,IEND)
                        WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
                        WRITE(IUNIT2,109)UNITS
                    END IF
                    READ(IUNIT1,16)LABEL,MAT,J,NODIG,SCALE
                    IF(INDEX(32)==2)NODIG=2
                    IF(MAT=='  A')THEN
                        IF(NODIG==0)THEN
                            DO I = ISTART,IEND
                                TOINT(I) = ANINT(A(PRTPT,I,J,K))
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG==1)THEN
                            WRITE(IUNIT2,18)LABEL,(A(PRTPT,I,J,K),I=ISTART,IEND)
                        ELSEIF(NODIG==2)THEN
                            WRITE(IUNIT2,19)LABEL,(A(PRTPT,I,J,K),I=ISTART,IEND)
                        ELSEIF(NODIG==3)THEN
                            WRITE(IUNIT2,30)LABEL,(A(PRTPT,I,J,K),I=ISTART,IEND)
                        ENDIF
                    ELSEIF(MAT==' XA')THEN
                        IF(NODIG==0)THEN
                            DO I = ISTART,IEND
                                TOINT(I) = ANINT(XA(I,J,K))
                            END DO
                            WRITE(IUNIT2,17)LABEL,(TOINT(I),I=ISTART,IEND)
                        ELSEIF(NODIG==1)THEN
                            WRITE(IUNIT2,18)LABEL,(XA(I,J,K),I=ISTART,IEND)
                        ELSEIF(NODIG==2)THEN
                            WRITE(IUNIT2,19)LABEL,(XA(I,J,K),I=ISTART,IEND)
                        ELSEIF(NODIG==3)THEN
                            WRITE(IUNIT2,30)LABEL,(XA(I,J,K),I=ISTART,IEND)
                        ENDIF
                    ELSE
                        WRITE(IUNIT2,17)LABEL
                    END IF
                END DO
                WRITE(IUNIT2,100)(LINE(LIJK),LIJK=1,NUMDASH1+NUMDASH2*NYRSIM)
            !--
            !--
            !--
            !--
            !--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                IF(INDEX(88)==1) GOTO 1212
                1212 CONTINUE


                IUNIT2=FILE_MGR('C',FNAME,NEW)
              ! CLOSE(IUNIT2)
                IUNIT1=FILE_MGR('C',FNAME,NEW)
                RETURN
                END SUBROUTINE PRINTTXT
            !     Last change:  CH   22 Nov 2005   10:27 am
                SUBROUTINE PRODUCTS
                IMPLICIT NONE

                !EIA add
                INTEGER :: NPRODS
            !--
            !-- ************************************************************************
            !-- *********************  PRODUCTS SUBROUTINE  ****************************
            !-- ************************************************************************
            !--
            !-- THIS IS A SUBROUTINE TO INTEGRATE AGRICULTURAL PRODUCST LIKE THE SOYBEAN
            !-- OIL & MEAL AND SUGAR INTO POLYSYS
            !-- THE FOLLOWING IS THE MATRIX AND VARIABLE DEFINITIONS
            !-- DEFINE II AS THE INDEX TO BE USED FOR LAG VARIABLES
            !--


            !--
            !-- Number of PRODUCTS in POLYSYS
            !--
                NPRODS = INDEX(43)
            !--
            !--   Loop on model PRODUCTS
            !--
                NPRODS = 2   ! BECAUSE WE ARE NOT LOOKING AT SUGAR
                DO K =1, NPRODS
                !--


                !--   *****************
                !--   ***   SUPPLY  ***
                !--   *****************
                !--
                !--   BEGINNING STOCKS
                !--
                    PC(NPT,I,7,K) = PC(NPT,I-1,8,K)
                !--
                !--   PRODUCTION
                !--
                    IF(K == 3) THEN
                        SGC(I,1) = SGB(I,1) + PX(I,3,3) * (C(NPT,I,3,10)-B(I,3,10))     ! Sugar from cane
                        SGC(I,2) = SGB(I,2) + PX(I,4,3) * (C(NPT,I,3,11)-B(I,3,11))     ! Sugar from beets
                        PC(NPT,I,1,3) = SGC(I,1) + SGC(I,2)                             ! Total sugar production
                        PX(I,2,3) = SGC(I,3) + SGX(I,1)                             ! Total sugar imports = quota + otherimports
                    !--
                    ELSE
                    !--

                    !--
                        PC(NPT,I,1,K) = PB(I,1,K) + PX(I,3,K)*(C(NPT,I,10,6)-B(I,10,6))
      ENDIF
                !--
                !--   EFFECTIVE SUPPLY
                !--
                    IF(K == 1) THEN
                        PC(NPT,I,5,K) = PC(NPT,I,1,K) + PX(I,2,K) + PC(NPT,I,7,K)
                    ELSEIF(K == 2)THEN
                        PC(NPT,I,5,K) = PC(NPT,I,1,K) + PX(I,2,K) + PC(NPT,I,7,K) &
                        + BIOPRD(I,52) * 1000 / 2000                     !BIODIESEL FROM WHATIF.FOR (MIL LBS TO THOUS TONS)
                    ELSE
                        PC(NPT,I,5,K) = PC(NPT,I,1,K) + PX(I,2,K) + PC(NPT,I,7,K)
      ENDIF
                !--
                !--   *****************
                !--   ***   DEMAND  ***
                !--   *****************
                !--
                !--   DOMESTIC DEMAND:
                !--   the estimated price elasticity was -.15 but we replaced it by .30
                !--

                !--
                    IF(K==2 .AND. INDEX(51)==1)THEN
                        PC(NPT,I,2,K)= PB(I,2,K) * ( 1.0 &
                        + EGP(1,K) * (PC(NPT,I,4,K) - PB(I,4,K)) / PB(I,4,K) &
                        + EGP(03,K) * (A(NPT,I,20,3) - AB(I,20,3)) / AB(I,20,3) &
                    !     3   + EGP(04,K) * (A(NPT,I,05,2) - AB(I,05,2)) / AB(I,05,2)             !!USING GCAU'S INSTEAD
                        + EGP(04,K) * (SAU(I,13,2) - SAUB(I,13,2)) / SAUB(I,13,2) &
                        ) + AJP(1,K) * (PC(NPT,I-1,2,K) - PB(I-1,2,K))
                    !C     5   - (1-27/49) * (0.2)*BIOPRD(I,50) / 2000 / 1000                   !% OF MEAL THAT DDG SUBST * TONS DDG /1000 = THOUS TONS
                    ELSE
                        PC(NPT,I,2,K)= PB(I,2,K) * ( 1.0 &
                        + EGP(1,K) * (PC(NPT,I,4,K) - PB(I,4,K)) / PB(I,4,K) &
                        + EGP(03,K) * (A(NPT,I,20,3) - AB(I,20,3)) / AB(I,20,3) &
                        + EGP(04,K) * (A(NPT,I,05,2) - AB(I,05,2)) / AB(I,05,2)                            & !!USING GCAU'S INSTEAD
                        ) + AJP(1,K) * (PC(NPT,I-1,2,K) - PB(I-1,2,K))
                    ENDIF
                !--
                !--   EXPORTS
                !--

                        PC(NPT,I,3,K)= PB(I,3,K)*(1+EGP(2,K)*(PC(NPT,I,4,K)-PB(I,4,K))/PB(I,4,K)) &
                        + AJP(2,K)*(PC(NPT,I-1,3,K)-PB(I-1,3,K))

                !--
                !--   TOTAL USE
                !--
                    PC(NPT,I,6,K) = PC(NPT,I,2,K) + PC(NPT,I,3,K) + PX(I,1,K)

                    IF(PC(NPT,I,6,K)+10.0 > PC(NPT,I,5,K))THEN                          !!!WATCH OUT HERE!!
                        PC(NPT,I,2,K)=PC(NPT,I,2,K)-(PC(NPT,I,6,K)-PC(NPT,I,5,K)+10)              !!CHAD MADE SURE TOTAL USE CANNOT EXCEED TOTAL SUPPLY
                        PC(NPT,I,6,K) = PC(NPT,I,2,K) + PC(NPT,I,3,K) + PX(I,1,K)             !!MINUMUM OF 10 DIFFERENCE
                    ENDIF
                !--
                !--   ***********************
                !--   SOLVING FOR THE PRICE
                !--   ***********************
                !--

                !--
                !--   Soybean Oil and Sugar
                !--
                !C      PC(NPT,I,4,K)= PB(I,4,K) * (1.0 + EGP(5,K) *
                !C     1 (((PC(NPT,I,5,K)-PB(I,5,K))- (PC(NPT,I,6,K)-PB(I,6,K)))/PB(I,5,K)))
                !--
                    IF(K == 2)THEN
                    !--
                    !--  Soybean Meal
                    !--
                        PC(NPT,I,4,K)=PB(I,4,K)
                        PC(NPT,I,4,K)= PB(I,4,K) * (1.0 + EGP(5,K) * &
                        (((2/PX(I,3,2))*((PC(NPT,I,5,K)-PB(I,5,K)) - (PC(NPT,I,6,K)-PB(I,6,K))) &
                        + (C(NPT,I,08,6)-B(I,08,6)) - (C(NPT,I,13,6)-B(I,13,6))) /((2/PX(I,3,2)) &
                        * PB(I,5,K)+C(NPT,I,08,K))))
                    !--
                    END IF
                    IF(PC(NPT,I,4,K) <= 0.05)PC(NPT,I,4,K)=0.05                                  !!!BOTTOM LIMIT TO PRICE FALL
                !--
                !--
                !--   *********************
                !--   *** ENDING STOCKS ***
                !--   *********************
                !--
                    PC(NPT,I,8,K) = PC(NPT,I,05,K) - PC(NPT,I,06,K)
                !--
                END DO            ! End of PRODUCTS Loop
            !--
            !--                                                                          !commented oil above, this is to keep net margin
                PC(NPT,I,4,1)=PB(I,4,1) +                                                   & !steady, meal price goes down and oil price
                ((C(NPT,I,9,6)-B(I,9,6))-((PC(NPT,I,4,2)-PB(I,4,2))/2000*45.5))/11     !must go up to cover increase in soybean price
            !--
            !--   Crushing Margin for Soybeans
            !--
            !      CRMRB(I)=PB(I,4,1)*PXB(I,3,1)+PXB(I,3,2)*PB(I,4,2)/2000 - B(I,9,6)
            !      CRMR(I)= PC(NPT,I,4,1)*PX(I,3,1) + PX(I,3,2)*PC(NPT,I,4,2)/2000 - C(NPT,I,9,6)
            ! c      CRMRB(I)=PB(I,4,1)*PXB(I,3,1)+PXB(I,3,2)*PB(I,4,2)/2000
            ! c      CRMR(I)= PC(NPT,I,4,1)*PX(I,3,1) + PX(I,3,2)*PC(NPT,I,4,2)/2000
                CRMRB(I) = (PB(I,4,1)*PXB(I,3,1)+PXB(I,3,2)*PB(I,4,2)/2000) &
                - B(I,9,6)                                                    !chad commented 7/12/05
                CRMR(I) = (PC(NPT,I,4,1)*PX(I,3,1) + PX(I,3,2)*PC(NPT,I,4,2)/2000) &
                - C(NPT,I,9,6)                                                     !chad commented 7/12/05
            !--
                RETURN
                END SUBROUTINE PRODUCTS

        
            !     Last change:  2021
               SUBROUTINE REGOUT
                IMPLICIT NONE

                REAL :: FIGGROWER
                !EIA add
                INTEGER :: J, NCROPS, IISTART, IYEAR1

            !--
                IISTART = INDEX(30) - INDEX(27) + 3               ! First I period to start simulation
                IYEAR1 = INDEX(30)                                ! First marketing year of Simulation
                NCROPS = INDEX(2)                                 ! Number of crops
                CNTY = INDEX(33)                                  ! Number of counties
            !--
                DO CTY = 1,CNTY
                    DO K = 1,NCROPS
                        DO T= 1,3

                        !--      FIGURE NET CASH market RETURNS (TOTAL)
                            IF(CY(4,K,T,CTY) > 0.0) THEN
                                IF(K == 8) THEN
                                    CY(24,K,T,CTY)= (CY(4,K,T,CTY)*CY(5,K,T,CTY)      & !C(I,9,K)*CYX(3,K,T,CTY)
                                    / 100) &
                                    - (CY(1,K,T,CTY)*CYX(23,K,T,CTY))
                                ELSEIF(K == 1 .OR. K == 5)THEN                                            !net cash income
                                    CY(24,K,T,CTY)= (CY(4,K,T,CTY)*CY(5,K,T,CTY))  & !*C(NPT,I,9,K)*CYX(3,K,T,CTY))
                                    - (CY(1,K,T,CTY)*CYX(23,K,T,CTY))
                                !C     2                        + REN(14,K,CRDL)*RC(2,K,CRDL)                    !ADD PROFIT FROM RESIDUE HARVESTING  !KEEPING SEPARATE AND THEN ADD IN RESIDUE WHEN OUTPUT AT COUNTY LEVEL
                                !c           ELSEIF(K.GE.9.OR.K.LE.11)THEN
                                !c             CY(24,K,T,CTY)= CY(7,K,T,CTY) * CY(1,K,T,CTY)                        !ANUITY (figured in npvalue) * PLANTED ACRES
                                !--
                                ELSE
                                    CY(24,K,T,CTY)= (CY(4,K,T,CTY)*C(NPT,I,9,K)*CYX(3,K,T,CTY)) &
                                    - (CY(1,K,T,CTY)*CYX(23,K,T,CTY))
                                !--
                                END IF
                            ELSE
                                CY(24,K,T,CTY) = 0.0
                            END IF
                        !--
                        !--      --BIOMASS CROPS NET RETURNS EQUAL ANUITY--
                            IF((K >= 9 .AND. K <= 11) .OR. K == 16 .OR. K == 17)THEN
                                CY(24,K,T,CTY)= CY(7,K,T,CTY) * CY(1,K,T,CTY)                        !ANUITY (figured in npvalue) * PLANTED ACRES
                            ENDIF
                        !--
                        !--      --FORAGE NET RETURNS ZERO--
                            IF(K == 12 .AND. T == 2)THEN
                                CY(24,K,T,CTY)=0.0                           !!!!HAY NET RETURNS SHOULD BE ZERO ON LAND BROUGHT IN, BECAUSE WILL MEET DISPLACED FORAGE DEMAND AND NOT SOLD ON NATIONAL MARKET
                                CY(6,K,T,CTY)=0.0
                            ENDIF
                        !--
                        !--      FIGURE LDP'S AND CCP'S
                            IF(C(NPT,I,3,K) == 0.0)THEN
                                CY(22,K,T,CTY)=0.0
                                CY(23,K,T,CTY)=0.0
                            ELSE
                                IF(K == 7)THEN
                                    CY(22,K,T,CTY) = (CY(4,K,T,CTY)/1000000/480)/C(NPT,I,3,K) &
                                    * C(NPT,I,20,K)
                                    CY(23,K,T,CTY) = (CY(4,K,T,CTY)/1000000/480)/C(NPT,I,3,K) &
                                    * C(NPT,I,32,K)
                                ELSEIF(K == 8)THEN
                                    CY(22,K,T,CTY) = (CY(4,K,T,CTY)/1000000/100)/C(NPT,I,3,K) &
                                    * C(NPT,I,20,K)
                                    CY(23,K,T,CTY) = (CY(4,K,T,CTY)/1000000/100)/C(NPT,I,3,K) &
                                    * C(NPT,I,32,K)
                                ELSE
                                    CY(22,K,T,CTY) = (CY(4,K,T,CTY)/1000000)/(C(NPT,I,3,K)) &
                                    * (C(NPT,I,20,K))
                                    CY(23,K,T,CTY) = (CY(4,K,T,CTY)/1000000)/(C(NPT,I,3,K)) &
                                    * (C(NPT,I,32,K))
                                ENDIF
                            ENDIF

                        !--
                            DO J=1,30

                                IF(J == 8)CY(8,K,T,CTY)=CYX(1,1,T,CTY)         !fips
                                IF(J == 9)CY(9,K,T,CTY)=CYX(2,1,T,CTY)         !poly reg
                            !--
                            ENDDO
                            IF(CY(2,K,T,CTY) > 0.0)THEN
                                CY(3,K,T,CTY) = CY(4,K,T,CTY)/CY(2,K,T,CTY)  !YIELD
                            ELSE
                                CY(3,K,T,CTY) = 0.0
      ENDIF
                            CY(32,K,T,CTY) = NPV(NPT,I,K,T,CTY)
                        ENDDO
                    ENDDO
                ENDDO
            !--
            !--
                DO K=1,NCROPS
                    FIGGROWER=0.0
                    DO J=1,26
                        DO T=1,3
                            CRN(I,J,K,T) = 0.0
                            DO CTY=1,CNTY
                            !--       SUM CARBON AND PRODUCTION DATA TO NATIONAL LEVEL
                                IF(J <= 7 .OR. J >= 10)THEN
                                    CRN(I,J,K,T)=CRN(I,J,K,T) + CY(J,K,T,CTY)/1000000.0
                                !c      if(cy(1,13,3,cty).gt.0.0)then
                                !c      write(*,*)crn(i,j,k,t),cy(1,13,3,cty),'regoout'
                                !c      endif
                                ENDIF
                            !--
                                IF(J == 1 .AND. CY(1,K,T,CTY) > 0.0)THEN
                                    FIGGROWER=figgrower + CY(30,K,T,CTY)*CY(1,K,T,CTY)   !FOR FIGURING  AVERAGE GROWER PAYMENTS 'per acre' FOR ONLY T=1
                                ENDIF
                            !--
                            !C          IF(INDEX(87).EQ.0.0)CARBB(I,J,K,T)=CARB(I,J,K,T) !SET BASELINE
                            !--
                            !c           IF (J.EQ.6)THEN
                            !c             CRN(I,J,K,T)= CRN(I,J,K,T)
                            !C     1                   + (INCENT(6,K,T,CTY)+INCENT(11,K,T,CTY)  !FOR NATIONAL LEVEL, ADD IN ADDITONAL COSTS FROM CARBON INPUT COST INCREASES TO CROP AND RESIDUE PRODUCTION
                            !C     1                   + INCENT(16,K,T,CTY)+INCENT(21,K,T,CTY) ) !ENERGY COST INCREASES
                            !C     1                   /1000000.0
                            !c           ENDIF
                            ENDDO !END CTY
                        ENDDO  !END T
                    ENDDO   !END J
                !--
                !--    NATIONAL WEIGHTED AVERAGE GROWER PAYMENT
                    IF(C(NPT,I,34,K) > 0.0) C(NPT,I,50,K)=FIGGROWER/(C(NPT,I,34,K)*1000000)
                !--
                ENDDO    !END K
! 2021 update
!--   FIGURE YIELDS
      DO K=1,NCROPS
       DO T=1,3
           IF(CRN(I,2,K,T).GT.0.0)THEN
              CRN(I,3,K,T) = CRN(I,4,K,T)/CRN(I,2,K,T)
           ENDIF
       ENDDO
      ENDDO
            !--
            !--         *** INTENSIFICATION TOTALS  ***
            !--
            !C      DO K=1,16
            !C       DO J=1,7
                PTTOTAL(I)=0.0
                DO CTY=1,CNTY
                    PTTOTAL(I) = PTTOTAL(I) + PT(NPT,I,1,28,CTY)/1000000.0
                ENDDO
            !C         ENDDO
            !C        ENDDO
            !--
            !--
            !--      SUM ALL NATIONAL NUMBERS TO NATIONAL TOTAL FOR CATAGORY
                DO J=1,26
                    CARBTOT(I,J) = 0.0
                    IF(J <= 7 .OR. J >= 10)THEN
                        DO K=1,NCROPS
                            DO T=1,3
                                CARBTOT(I,J)= CARBTOT(I,J) + CRN(I,J,K,T)                     !PRINT THIS OUT IN PRINTTXT.FOR
                            ENDDO
                        ENDDO
      ENDIF
                    IF(J == 10 .OR. J == 12 .OR. J == 14 .OR. J == 16 .OR. J == 20)THEN
                        CARBTOT(I,J)=CARBTOT(I,J)/1000000000            !ENERGY TO QUADS
      ENDIF
                !C       IF(J.EQ.6.OR.J.EQ.7.OR.J.EQ.24.OR.J.EQ.26)THEN
                !C             CARBTOT(I,J)=CARBTOT(I,J)/1000                  !$ VALUES TO BILLIONS
                !C       ENDIF
                ENDDO
            !--     ADD IN RESIDUE EMISSIONS TO THE TOTALS FOR REPORTING IN SUMMARY OUTPUT
                DO K=1,NCROPS
                    CARBTOT(I,10) = CARBTOT(I,10) + EN(NPT,I,12,K)/1000000000    !TO QUADS  !DIRECTe
                    CARBTOT(I,11) = CARBTOT(I,11) + EN(NPT,I,13,K)                          !DIRECTc
                    CARBTOT(I,12) = CARBTOT(I,12) + EN(NPT,I,14,K)/1000000000    !TO QUADS  !EMBODeFERT
                    CARBTOT(I,13) = CARBTOT(I,13) + EN(NPT,I,15,K)                          !EMBODcFERT
                    CARBTOT(I,18) = CARBTOT(I,18) + EN(NPT,I,16,K)                          !CfromN
                    CARBTOT(I,20) = CARBTOT(I,20) + EN(NPT,I,17,K)/1000000000   !TO QUADS   !TOTALe
                    CARBTOT(I,21) = CARBTOT(I,21) + EN(NPT,I,18,K)                          !TOTALc
                ENDDO
            !--
            !--
            !--        SUM INCENTIVES TO NATIONAL LEVEL ACROSS ALL K AND T
                DO J=2,26
                    CENT(I,J)=0.0
                    DO K=1, NCROPS
                        DO T=1,3
                            DO CTY=1,CNTY
                                CENT(I,J)= CENT(I,J) &
                                + INCENT(J,K,T,CTY)*CY(1,K,T,CTY)/1000000    !PER ACRE ADDITION * ACREAGE /1000000
                            ENDDO
                        ENDDO
                    ENDDO
                ENDDO
            !--
                RETURN
                END SUBROUTINE REGOUT

                !2021

                 SUBROUTINE RESDCNTY
                IMPLICIT NONE

                CHARACTER(34) :: RESIDUES
                CHARACTER(16) :: CNTNAME
                CHARACTER(2) :: STNAME
                CHARACTER(5) :: SK
                REAL :: CRNRATIO
                REAL :: EFFRATE(4,5),EFFYIELD(4,5)
                INTEGER :: FIPPS,POLLY,JJ,KK
                INTEGER :: IYYEAR(41)
                DOUBLE PRECISION :: RESCARB(2,3)
                !EIA add
                INTEGER :: FF, J, H, G, II, COUNTY, IYYR, ISTART, IEND, NYRSIM, NCROPS, HH, IISTART
                INTEGER FILE_MGR
                EXTERNAL FILE_MGR
                CHARACTER*35 FNAME
                LOGICAL NEW
                INTEGER IUNIT1, FILEUNIT
           !--
            !      DOUBLE PRECISION RCNTX(35,306,3200),RCNT(35,306,3200)
                IISTART = INDEX(30) - INDEX(27) + 3
                NCROPS = INDEX(2)
                POLY=INDEX(63)
                CNTY=INDEX(33)
                NCROPS = INDEX(2)
            !--
                NYRSIM = INDEX(1)
                ISTART = INDEX(30)-INDEX(27)+3
                IEND = NYRSIM+(INDEX(30)-INDEX(27))+2
                IYYR = INDEX(30) - 2
            !--
                DO II=ISTART-2,IEND
                    IYYEAR(II) = IYYR
                    IYYR = IYYR + 1
                END DO
            !--
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                IF(I == 3 .AND. bioiter == 1)THEN                            !ONLY NEED TO READ ONCE
                !--
                !--             **OPEN RESIDUAL SUPPLY CONSTRAINT DATA**
                !--
                    IF(INDEX(83) == 0)THEN
                        FNAME='PSRAIN'
                        NEW=.FALSE.
                        IUNIT1=FILE_MGR('O',FNAME,NEW)
                        !OPEN(UNIT=72,FILE='RAIN.PRN')
                    !--
                    !--
                        READ(IUNIT1,*)
                      !  DO CLN=1,CNTY
                        DO CLN=1,alwaysCNTY !(region change version)
                            READ(IUNIT1,*)CNTNAME,STNAME, &
                            RCNTX(3,1,1,CLN),RCNTX(2,1,1,CLN), &
                            RCNTX(5,1,1,CLN),RCNTX(5,1,2,CLN),RCNTX(5,1,3,CLN), &
                            RCNTX(6,1,1,CLN),RCNTX(6,1,2,CLN),RCNTX(6,1,3,CLN), &
                            RCNTX(5,5,1,CLN),RCNTX(5,5,2,CLN),RCNTX(5,5,3,CLN), &
                            RCNTX(6,5,1,CLN),RCNTX(6,5,2,CLN),RCNTX(6,5,3,CLN)
                        ENDDO
                       ! CLOSE(72)
                         IUNIT1=FILE_MGR('C',FNAME,NEW)
                    !--
                        FNAME='PSWIND'
                        NEW=.FALSE.
                        IUNIT1=FILE_MGR('O',FNAME,NEW)
                     !   OPEN(UNIT=72,FILE='WIND.PRN')
                    !--
                    !--
                        READ(IUNIT1,*)
                       !  DO CLN=1,CNTY
                        DO CLN=1,alwaysCNTY !(region change version)
                            READ(IUNIT1,*)CNTNAME,STNAME,RCNTX(3,1,1,CLN),RCNTX(2,1,1,CLN), &
                            RCNTX(7,1,1,CLN),RCNTX(7,1,2,CLN),RCNTX(7,1,3,CLN), &
                            RCNTX(7,5,1,CLN),RCNTX(7,5,2,CLN),RCNTX(7,5,3,CLN)
                        !--
                            DO K=1,NCROPS
                                DO T=1,4
                                    RCNTX(3,K,T,CLN) = RCNTX(3,1,1,CLN)    !SET FIPS FOR ALL TILLAGE AND CROPS
                                    RCNTX(2,K,T,CLN) = RCNTX(2,1,1,CLN)    !SET POLYSYS REGIONS FOR ALL T AND K
                                    RCNTX(8,K,T,CLN) = RCNTX(7,K,T,CLN)    !SET WIND 'ROTATION' CONSTRAINTS SAME AS WIND 'CONTINUOUS'
                                    RCNTX(1,K,T,CLN) = CLN                 !SET COUNTY NUMBER TO CLN
                                END DO
                            END DO

                        ENDDO
                      !  CLOSE(72)
                         IUNIT1=FILE_MGR('C',FNAME,NEW)
                    !--
                    !--           ***OPEN RESIDUE HARVESTING CARBON DATA ***
                    !--
                     FNAME='./input/RESIDCARB.TXT'
                       ! FNAME='RESIDCARB.TXT'
                    NEW=.FALSE.
                  !  IUNIT1=FILE_MGR('O',FNAME,NEW)
                     IUNIT1=FILEUNIT()
                    OPEN(UNIT=IUNIT1,file=FNAME)
                     !   OPEN(UNIT=75,FILE=TRIM(ADJUSTL(USERDEFPATH))// &
                     !   'input/resid/RESIDCARB.TXT')
                    !--
                        READ(IUNIT1,*)
                        READ(IUNIT1,*)STNAME,RCNTX(12,1,1,1),RCNTX(13,1,1,1)               & !DIRECTe,DIRECTc,EMBODeFERT,EMBODcFERT,cFROMn,TOTALe,TOTALc
                        ,RCNTX(14,1,1,1),RCNTX(15,1,1,1),RCNTX(16,1,1,1) &
                        ,RCNTX(17,1,1,1),RCNTX(18,1,1,1),RCNTX(11,1,1,1)   !J=11=SOIL CARBON REDUCTION
                        READ(IUNIT1,*)STNAME,RCNTX(12,5,1,1),RCNTX(13,5,1,1)               & !DIRECTe,DIRECTc,EMBODeFERT,EMBODcFERT,cFROMn,TOTALe,TOTALc
                        ,RCNTX(14,5,1,1),RCNTX(15,5,1,1),RCNTX(16,5,1,1) &
                        ,RCNTX(17,5,1,1),RCNTX(18,5,1,1),RCNTX(11,5,1,1)   !J=11=SOIL CARBON REDUCTION
                        CLOSE(UNIT=IUNIT1)
                       !  IUNIT1=FILE_MGR('C',FNAME,NEW)
                        !  DO CLN=1,CNTY
                        DO CLN=1,alwaysCNTY !(region change version)
                            DO T=1,3
                                DO J=11,18
                                    RCNTX(J,1,T,CLN)=RCNTX(J,1,1,1)  !ALL TILLAGES AND COUNTIES HAVE SAME EMISSIONS PER DT
                                    RCNTX(J,5,T,CLN)=RCNTX(J,5,1,1)
                                END DO
                            END DO
                        ENDDO
                    !--
                    !--     RESIDUES CONSTRAINED TO CARBON NEUTRAL LEVEL
                        IF(INDEX(69) == 1)THEN
                            RESCARB(1,1) = 3.38   !CONTINUOUS CONVENTIONAL
                            RESCARB(1,2) = 3.38   !CONTINOUS  REDUCED
                            RESCARB(1,3) = 2.34   !CONTINUOUS NOTILL
                            RESCARB(2,1) = 5.58   !ROTATIONAL CONVENTIONAL
                            RESCARB(2,2) = 5.58   !ROTATIONAL REDUCED
                            RESCARB(2,3) = 3.52   !ROTATIONAL NOTILL
                        ELSE
                            DO J=1,2
                                DO T=1,3
                                    RESCARB(J,T) = 0.0
                                ENDDO
                            ENDDO
      ENDIF
                    !--
                    ELSEIF(INDEX(83) == 1)THEN     !READ IN MUTH RULSE2 CONSTRAINTS
                    !--
                    IUNIT1=FILEUNIT()
                        DO K=1,8
                            DO T=1,3
                                DO J=1,2
                                !--             BASE CASE YIELDS
                                    IF(K == 1 .AND. T == 1 .AND. J == 1)THEN
                                        FNAME='./input/MUTH1CTBAS.txt'
                                        OPEN(UNIT=IUNIT1,FILE=FNAME,ERR=666)
                                    ELSEIF(K == 1 .AND. T == 2 .AND. J == 1)THEN
                                        FNAME='./input/MUTH1RTBAS.txt'
                                       OPEN(UNIT=IUNIT1,FILE=FNAME,ERR=666)
                                    ELSEIF(K == 1 .AND. T == 3 .AND. J == 1)THEN
                                        FNAME='./input/MUTH1NTBAS.txt'
                                      OPEN(UNIT=IUNIT1,FILE=FNAME,ERR=666)
                                    ELSEIF(K == 2 .AND. T == 2 .AND. J == 1)THEN
                                        FNAME='./input/MUTH2RTBAS.txt'
                                     OPEN(UNIT=IUNIT1,FILE=FNAME,ERR=666)
                                    ELSEIF(K == 2 .AND. T == 3 .AND. J == 1)THEN
                                        FNAME='./input/MUTH2NTBAS.txt'
                                      OPEN(UNIT=IUNIT1,FILE=FNAME,ERR=666)
                                    ELSEIF(K == 3 .AND. T == 2 .AND. J == 1)THEN
                                        FNAME='./input/MUTH3RTBAS.txt'
                                     OPEN(UNIT=IUNIT1,FILE=FNAME,ERR=666)
                                    ELSEIF(K == 3 .AND. T == 3 .AND. J == 1)THEN
                                        FNAME='./input/MUTH3NTBAS.txt'
                                     OPEN(UNIT=IUNIT1,FILE=FNAME,ERR=666)
                                    ELSEIF(K == 4 .AND. T == 2 .AND. J == 1)THEN
                                        FNAME='./input/MUTH4RTBAS.txt'
                                       OPEN(UNIT=IUNIT1,FILE=FNAME,ERR=666)
                                    ELSEIF(K == 4 .AND. T == 3 .AND. J == 1)THEN
                                        FNAME='./input/MUTH4NTBAS.txt'
                                      OPEN(UNIT=IUNIT1,FILE=FNAME,ERR=666)
                                    ELSEIF(K == 5 .AND. T == 2 .AND. J == 1)THEN
                                         FNAME='./input/MUTH5RTBAS.txt'
                                        OPEN(UNIT=IUNIT1,FILE=FNAME,ERR=666)
                                    ELSEIF(K == 5 .AND. T == 3 .AND. J == 1)THEN
                                        FNAME='./input/MUTH5NTBAS.txt'
                                        OPEN(UNIT=IUNIT1,FILE=FNAME,ERR=666)
                                    !--         HIGH YIELDS CASE
                                    ELSEIF(K == 1 .AND. T == 1 .AND. J == 2)THEN
                                        FNAME='./input/MUTH1CTHIGH.txt'
                                       OPEN(UNIT=IUNIT1,FILE=FNAME,ERR=666)
                                    ELSEIF(K == 1 .AND. T == 2 .AND. J == 2)THEN
                                        FNAME='./input/MUTH1RTHIGH.txt'
                                    OPEN(UNIT=IUNIT1,FILE=FNAME,ERR=666)
                                    ELSEIF(K == 1 .AND. T == 3 .AND. J == 2)THEN
                                        FNAME='./input/MUTH1NTHIGH.txt'
                                       OPEN(UNIT=IUNIT1,FILE=FNAME,ERR=666)
                                    ELSEIF(K == 2 .AND. T == 2 .AND. J == 2)THEN
                                       FNAME='./input/MUTH2RTHIGH.txt'
                                     OPEN(UNIT=IUNIT1,FILE=FNAME)
                                    ELSEIF(K == 2 .AND. T == 3 .AND. J == 2)THEN
                                       FNAME='./input/MUTH2NTHIGH.txt'
                                       OPEN(UNIT=IUNIT1,FILE=FNAME,ERR=666)
                                    ELSEIF(K == 3 .AND. T == 2 .AND. J == 2)THEN
                                       FNAME='./input/MUTH3RTHIGH.txt'
                                      OPEN(UNIT=IUNIT1,FILE=FNAME,ERR=666)
                                    ELSEIF(K == 3 .AND. T == 3 .AND. J == 2)THEN
                                       FNAME='./input/MUTH3NTHIGH.txt'
                                     OPEN(UNIT=IUNIT1,FILE=FNAME,ERR=666)
                                    ELSEIF(K == 4 .AND. T == 2 .AND. J == 2)THEN
                                       FNAME='./input/MUTH4RTHIGH.txt'
                                      OPEN(UNIT=IUNIT1,FILE=FNAME,ERR=666)
                                    ELSEIF(K == 4 .AND. T == 3 .AND. J == 2)THEN
                                       FNAME='./input/MUTH4NTHIGH.txt'
                                      OPEN(UNIT=IUNIT1,FILE=FNAME,ERR=666)
                                    ELSEIF(K == 5 .AND. T == 2 .AND. J == 2)THEN
                                       FNAME='./input/MUTH5RTHIGH.txt'
                                       OPEN(UNIT=IUNIT1,FILE=FNAME,ERR=666)
                                    ELSEIF(K == 5 .AND. T == 3 .AND. J == 2)THEN
                                       FNAME='./input/MUTH5NTHIGH.txt'
                                       OPEN(UNIT=IUNIT1,FILE=FNAME,ERR=666)
                                    ELSE
                                        DO II=1,IEND !(region change version) update from UT 2019
                                            DO CLN=1,alwaysCNTY
                                                MUTH(II,J,K,T,CLN)=10.00
                                            ENDDO
                                        ENDDO
                                        GOTO 101
                                    ENDIF
                                    666 continue
                                !--
                                !--
                                    READ(IUNIT1,*)
                                   !  DO CLN=1,CNTY
                                     DO CLN=1,alwaysCNTY !(region change version)
                                        READ(IUNIT1,*)COUNTY,CNTNAME,STNAME,RCNTX(3,K,T,CLN),                           & !COUNTY NUMBER, CNTY NAME,STABBREV,FIPSCODE,POLYREG,MUTHFIPS,2009DATA...2030DATA
                                        RCNTX(2,K,T,CLN),SK,sk,sk,sk,sk,sk,MUTH(3,J,K,T,CLN), &
                                        MUTH(4,J,K,T,CLN),MUTH(5,J,K,T,CLN), &
                                        MUTH(6,J,K,T,CLN),MUTH(7,J,K,T,CLN),MUTH(8,J,K,T,CLN), &
                                        MUTH(9,J,K,T,CLN),MUTH(10,J,K,T,CLN),MUTH(11,J,K,T,CLN), &
                                        MUTH(12,J,K,T,CLN),MUTH(13,J,K,T,CLN),MUTH(14,J,K,T,CLN), &
                                        MUTH(15,J,K,T,CLN),MUTH(16,J,K,T,CLN),MUTH(17,J,K,T,CLN), &
                                        MUTH(18,J,K,T,CLN),MUTH(19,J,K,T,CLN),MUTH(20,J,K,T,CLN), &
                                        MUTH(21,J,K,T,CLN),MUTH(22,J,K,T,CLN),MUTH(23,J,K,T,CLN), &
                                        MUTH(24,J,K,T,CLN),MUTH(25,J,K,T,CLN),MUTH(26,J,K,T,CLN) &
                                        ,MUTH(27,J,K,T,CLN),MUTH(28,J,K,T,CLN),MUTH(29,J,K,T,CLN)
                                    !--
                                        if(county /= cln)then
                                            write(*,*)'readin problem in',k,t,county,cln
                                           ! pause
                                        endif
                                    !--
                                        DO II=30,PSYEARS !32  !!TD Chad fix
                                            MUTH(II,J,K,T,CLN)=MUTH(29,J,K,T,CLN)
                                        ENDDO
                                    !--
                                    ENDDO
                                    close(Iunit1)
                                     !  IUNIT1=FILE_MGR('C',FNAME,NEW)
                                !--
                                !--
                                    101 CONTINUE
                                !--
                                ENDDO !J
                            ENDDO  !T
                        ENDDO   !K
                    !--
                    ENDIF
                !--
                !--         ***OPEN PERCENTAGE ACRES IN ROTATION DATA***
                !--
                 FNAME='./input/ROTATION.txt'
                 NEW=.FALSE.
                 !  IUNIT1=FILE_MGR('O',FNAME,NEW)
                     OPEN(UNIT=IUNIT1,file=FNAME)
                  !  OPEN(UNIT=76,FILE=TRIM(ADJUSTL(USERDEFPATH))// &
                   ! 'input/resid/ROTATION.PRN')
                !--
                    READ(IUNIT1,*)
                    !  DO CLN=1,CNTY
                        DO CLN=1,alwaysCNTY !(region change version)
                        READ(IUNIT1,*)CNTNAME,STNAME,SK,SK,RCNTX(9,1,1,CLN), &
                        RCNTX(10,1,1,CLN),RCNTX(9,5,1,CLN), &
                        RCNTX(10,5,1,CLN)
                        DO T=2,3
                            RCNTX(9,1,T,CLN) = RCNTX(9,1,1,CLN)   !RATIO IN CONTINUOUS SAME FOR ALL TILLAGES
                            RCNTX(10,1,T,CLN)= RCNTX(10,1,1,CLN)  !RATION IN ROTATION SAME FOR ALL TILLAGES
                            RCNTX(9,5,T,CLN)= RCNTX(9,5,1,CLN)
                            RCNTX(10,5,T,CLN)= RCNTX(10,5,1,CLN)
                        END DO

                    END DO
                    CLOSE(IUNIT1)
                !  IUNIT1=FILE_MGR('C',FNAME,NEW)
                !--
                !--     ***READ IN HARVEST TECH EFFICIENCY CONSTRAINTS (CORN)***
                !--
                FNAME='./input/RESefficiency_corn.txt'
                 NEW=.FALSE.
                 !  IUNIT1=FILE_MGR('O',FNAME,NEW)
                     OPEN(UNIT=IUNIT1,file=FNAME)
                   ! OPEN(UNIT=76,FILE=TRIM(ADJUSTL(USERDEFPATH))// &
                   ! 'input/resid/RESefficiency_corn.PRN')
                    READ(IUNIT1,*)
                    READ(IUNIT1,*) SK,RESEFF(1,1,1),EFFRATE(1,1),EFFYIELD(1,1)    !reseff(i,f,k)  i=year, f=tech levels(4), k=crop   tech level "5" is the final that is used
                    READ(IUNIT1,*) SK,RESEFF(1,2,1),EFFRATE(2,1),EFFYIELD(2,1)    !effrate(f,k) ...rate of yearly increase in efficency
                    READ(IUNIT1,*) SK,RESEFF(1,3,1),EFFRATE(3,1),EFFYIELD(3,1)    !effyield(f,k)...yield levels that define different tech levels
                    READ(IUNIT1,*) SK,RESEFF(1,4,1),EFFRATE(4,1),EFFYIELD(4,1)
                    CLOSE(IUNIT1)
                 !  IUNIT1=FILE_MGR('C',FNAME,NEW)
                !--
                !--     ***READ IN HARVEST TECH EFFICIENCY CONSTRAINTS (WHEAT)***
                !--
                 FNAME='./input/RESefficiency_WHEAT.txt'
                 NEW=.FALSE.
                 !  IUNIT1=FILE_MGR('O',FNAME,NEW)
                    OPEN(UNIT=IUNIT1,file=FNAME)
                  !  OPEN(UNIT=76,FILE=TRIM(ADJUSTL(USERDEFPATH))// &
                 !   'input/resid/RESefficiency_WHEAT.PRN')
                    READ(IUNIT1,*)
                    READ(IUNIT1,*) SK,RESEFF(1,1,5),EFFRATE(1,5),EFFYIELD(1,5)
                    READ(IUNIT1,*) SK,RESEFF(1,2,5),EFFRATE(2,5),EFFYIELD(2,5)
                    READ(IUNIT1,*) SK,RESEFF(1,3,5),EFFRATE(3,5),EFFYIELD(3,5)
                    READ(IUNIT1,*) SK,RESEFF(1,4,5),EFFRATE(4,5),EFFYIELD(4,5)
                    CLOSE(IUNIT1)
                     !  IUNIT1=FILE_MGR('C',FNAME,NEW)
                !--
                !--
                if(index(117).EQ.1.or.index(117).eq.2)call EIAresid !CONVERTS ALL READ IN DATA TO ONLY 16 REGIONS  (region change version)

                !--
                ENDIF          !END OF READ IN DATA IN FIRST YEAR
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            !--
            !--    *** INFLATE COSTS EVERY YEAR ***
            !--
                DO G=1,14
                    DO H=1,50
                        DO J=2,10 !j=1 is the yield per dt/ac
                            DO K=1,12 !NCROPS !18
                                CSX(G,H,J,K)=CSXB(G,H,J,K)*INFL(I,1,1)  !INFLATE OLD WAY USING USDA VARIABLE COST
                            !           CSX(G,H,J,K)=CSX(G,H,J,K)*PPI(I)    !NEW WAY WITH PPI-CRM INDEX
                            ENDDO
                        ENDDO
       ENDDO
      ENDDO
            !--
            !--     *** SET TECH CONSTRAINTS EVERY YEAR ***
                DO FF=1,4 !TECH LEVELS
                    IF(I >= 5)THEN
                        RESEFF(I,FF,1)=(RESEFF(3,FF,1)*(1-(I-4)*EFFRATE(FF,1)))
                        RESEFF(I,FF,5)=(RESEFF(3,FF,5)*(1-(I-4)*EFFRATE(FF,5)))
                    ELSE
                        RESEFF(I,FF,1)=RESEFF(1,FF,1) !IF I LESS THAN 5
                        RESEFF(I,FF,5)=RESEFF(1,FF,5)
                    ENDIF
                ENDDO
            !--
            !-- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!START COUNTY LOOP!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            !--

                IF(IYYEAR(I) >= YRRESID)THEN
                !--
                !--   START COUNTY LOOP
                    DO CTY=1,CNTY
                    !--
                    !--   ****ADJUST COST OF PRODUCTION DATA BY YEARLY CARBON AND ENERGY PRICE CHANGES*****
                        DO K=1,NCROPS
                            DO T=1,3

                            !--        **residues!! FIGURE ADDITIONAL COSTS FROM CARBON PRICE**
                                INCENT(12,K,T,CTY) = RCNTX(13,K,T,CTY)*CARBINCT(I) !DIRECT INPUTS  tC PER ACRE * $ PER tC
                                IF(INDEX(75) == 1)THEN !IF FERT EXEMPT
                                    INCENT(13,K,T,CTY) = 0.0
                                ELSE
                                    INCENT(13,K,T,CTY) = RCNTX(15,K,T,CTY)*CARBINCT(I) !FERTILIZERS                        !!!####fertilizers subsidized to keep carbon price zero in legislation###!!!!!!
                                ENDIF

                                INCENT(16,K,T,CTY) = INCENT(12,K,T,CTY) + INCENT(13,K,T,CTY)
                            !--
                            !--       **residues!! FIGURE ADDITIONAL COSTS FROM ENERGY PRICE INCREASES**
                                BENERGY = 23.00   ! $ PER MILLION BTU's !BASELINE ENERGY COST IN BUDGETS (EQUAL TO $3.00 PER GALLON DIESEL)
                            !--
                                INCENT(17,K,T,CTY) = RCNTX(12,K,T,CTY)* BENERGY * ENGY  ! = BTU'S * $perBTU * %CHANGE IN ENERGY COST = $/AC CHANGE IN COST OF PRODUCTION  !DIRECT INPUTS
                                INCENT(18,K,T,CTY) = RCNTX(14,K,T,CTY)* BENERGY * ENGY  ! FERTILIZERS
                                INCENT(21,K,T,CTY)= INCENT(17,K,T,CTY) + INCENT(18,K,T,CTY)
                            ENDDO
                        ENDDO
                    !--   **********************************************************************************
                    !--
                    !--   FIND RESIDUES FOR SORGHUM, BARLEY AND OATS
                        CALL OTHRESDCNTY                                                                                            !!TO TURN ON 'OTHER' RESIDUE FEEDSTOCKS!!!!
                    !--
                    !--   Set Residue profit per acre to zero for each year and region (DON'T DO IT BEFORE HERE, LAG USED IN NPVALUE)
                    !      REN(14,1,CRDL) = 0.0
                    !      REN(14,5,CRDL) = 0.0
                    !--
                    !C      RCNT(11,1,4,CTY) = 0.0   !REGIONAL SUM OF RESIDUE HARVESTED TO ZERO TO SUM
                    !C      RCNT(11,5,4,CTY) = 0.0
                    !--
                        DO T=1,4
                            RCNT(10,1,T,CTY) = 0.0
                            RCNT(10,5,T,CTY) = 0.0
                            RCNT(11,1,T,CTY) = 0.0
                            RCNT(11,5,T,CTY) = 0.0
                            DO J=12,19 !!!TDTD added 19 to clear harvested variable
                                RCNT(J,1,T,CTY) = 0.0     !CARBON AND ENERGY
                                RCNT(J,5,T,CTY) = 0.0
                            END DO
                        END DO
                    !--
                    !--
                        IF((CY(2,1,1,CTY)+CY(2,1,2,CTY)+CY(2,1,3,CTY)+ &
                        CY(2,5,1,CTY)+CY(2,5,2,CTY)+CY(2,5,3,CTY)) <= 0.0)THEN      !IF NO CORN OR WHEAT ACRES
                            CONTINUE
                        ELSE
                        !--
                            DO T=1,3
                            !--
                            !--      *** HARVESTABLE RESIDUE PER ACRE = YIELD CONVERTED TO TONS * SRG RATIO - MINIMUM THAT MUST REMAIN(FROM ROBIN)
                            !--      moisture fraction must be deducted: 15.5% and 13.5%: Anthony Turhollow (2008)
                            !--
                            !--      TOTAL RESIDUE YIELD (WITHOUT CONSTRAINTS)
                                IF(INDEX(84) == 1)THEN
                                    CRNRATIO = 1 !-((I-4)*0.014286)  !TO 0.7 BY 2030  !now stays at 1.0 (march,2010)
                                ELSE
                                    CRNRATIO = 1 !-((I-4)*0.004762)  !TO 0.9 BY 2030  !now stay at 1.0
                                ENDIF
                                RCNT(3,1,T,CTY)=(CYX(25,1,T,CTY)*56/2000)*CRNRATIO*(1-.155)      !1 is stover to yield ratio, .155 in moisture fraction (Turhollow,2008)
                                RCNT(3,5,T,CTY)=(CYX(25,5,T,CTY)*60/2000)*1.57*(1-.135)          !1.57 is winter wheat straw to yield ratio, .135 is moisture fraction(Turhollow,2008)  !!changed ratio to 1.3!!
                            !--
                            !--      *** PICK LARGEST CONSTRAINT FOR CORN AND WHEAT FOR EACH TILLAGE AND ROTATION
                            !--          (old way); 62% and 55% residues must remain tech constraint: Anthony Turhollow (2008)
                            !--
                                IF(INDEX(83) == 1)THEN    !!!!!IF USING MUTH DATA!!!!!!!!
                                    IF(INDEX(84) == 1)THEN
                                        J=2                  !HIGH YIELD
                                    ELSE
                                        J=1                  !BASE CASE YIELD
                                    ENDIF
                                !--     FIGURE YIELD DETERMINED TECHNICAL CONSTRAINT OF RESIDUE REMOVAL
                                !--        (CORN)
                                    IF(CYX(25,1,T,CTY) <= EFFYIELD(1,1))THEN
                                        RESEFF(I,5,1)=RESEFF(I,1,1)         !RESEFF(I,'5'  IS THE FINAL % CONSTRAINT THAT GOES TO THE 'MAX' STATEMENT BELOW
                                    ELSEIF(CYX(25,1,T,CTY) <= EFFYIELD(2,1))THEN
                                        RESEFF(I,5,1)=RESEFF(I,2,1)
                                    ELSEIF(CYX(25,1,T,CTY) <= EFFYIELD(3,1))THEN
                                        RESEFF(I,5,1)=RESEFF(I,3,1)
                                    ELSEIF(CYX(25,1,T,CTY) > EFFYIELD(3,1))THEN
                                        RESEFF(I,5,1)=RESEFF(I,4,1)
                                    ENDIF
                                !--        (WHEAT)
                                    IF(CYX(25,5,T,CTY) <= EFFYIELD(1,5))THEN
                                        RESEFF(I,5,5)=RESEFF(I,1,5)         !RESEFF(I,'5'  IS THE FINAL % CONSTRAINT THAT GOES TO THE 'MAX' STATEMENT BELOW
                                    ELSEIF(CYX(25,5,T,CTY) <= EFFYIELD(2,5))THEN
                                        RESEFF(I,5,5)=RESEFF(I,2,5)
                                    ELSEIF(CYX(25,5,T,CTY) <= EFFYIELD(3,5))THEN
                                        RESEFF(I,5,5)=RESEFF(I,3,5)
                                    ELSEIF(CYX(25,5,T,CTY) > EFFYIELD(3,5))THEN
                                        RESEFF(I,5,5)=RESEFF(I,4,5)
                                    ENDIF
                                !--

                                    RCNT(1,1,T,CTY) = MAX(MUTH(I,J,1,T,CTY),RCNTX(7,1,T,CTY),    & !max of muth, wind or tech constraint
                                    RESEFF(I,5,1)*RCNT(3,1,T,CTY))
                                    RCNT(1,5,T,CTY) = MAX(MUTH(I,J,5,T,CTY),RCNTX(7,5,T,CTY), &
                                    RESEFF(I,5,5)*RCNT(3,5,T,CTY))
                                    RCNT(2,1,T,CTY) = MAX(MUTH(I,J,1,T,CTY),RCNTX(7,1,T,CTY), &
                                    RESEFF(I,5,1)*RCNT(3,1,T,CTY))
                                    RCNT(2,5,T,CTY) = MAX(MUTH(I,J,5,T,CTY),RCNTX(7,5,T,CTY), &
                                    RESEFF(I,5,5)*RCNT(3,5,T,CTY))
                                !--
                                ELSE
                                !--                                                                         !CARBON CONSTRAINED (FROM kARLEN ET AL.) IF INDEX 69=1 IN SIM.INS
                                    RCNT(1,1,T,CTY) = MAX(RESCARB(1,T),RCNTX(5,1,T,CTY),              & !CONT CORN (WIND,RAIN,OPERATION CONSTRAINTS)
                                    RCNTX(7,1,T,CTY),0.62*CYX(25,1,T,CTY)*56/2000*1)
                                    RCNT(1,5,T,CTY) =MAX(RESCARB(1,T),RCNTX(5,5,T,CTY),               & !CONT WHEAT
                                    RCNTX(7,5,T,CTY),0.55*CYX(25,5,T,CTY)*60/2000*1.57)
                                !--                                                                         !CARBON CONSTRAINED  (FROM kARLEN ET AL.) IF INDEX 69=1 IN SIM.INS
                                    RCNT(2,1,T,CTY) =MAX(RESCARB(2,T),RCNTX(6,1,T,CTY),               & !ROTATION CORN
                                    RCNTX(7,1,T,CTY),0.62*CYX(25,1,T,CTY)*56/2000*1)                   !(7...USE CONTINUOUS WIND CONSTRAINT FOR 'ROTATION' ALSO)
                                    RCNT(2,5,T,CTY) =MAX(RESCARB(2,T),RCNTX(6,5,T,CTY),               & !ROTATION WHEAT
                                    RCNTX(7,5,T,CTY),0.55*CYX(25,5,T,CTY)*60/2000*1.57)
                                ENDIF
                            !--
                            !--
                            !--
                            !--      *** TOTAL POTENTIAL HARVESTABLE YIELD (WITH CONSTRAINTS)
                                RCNT(4,1,T,CTY)=RCNT(3,1,T,CTY)-RCNT(1,1,T,CTY)   !CONTINUOUS CORN
                                RCNT(4,5,T,CTY)=RCNT(3,5,T,CTY)-RCNT(1,5,T,CTY)   !CONTINUOUS WHEAT
                                RCNT(5,1,T,CTY)=RCNT(3,1,T,CTY)-RCNT(2,1,T,CTY)   !ROTATIONAL CORN
                                RCNT(5,5,T,CTY)=RCNT(3,5,T,CTY)-RCNT(2,5,T,CTY)   !ROTATIONAL WHEAT
                            !--
                                DO J=4,5
                                    IF(RCNT(J,1,T,CTY) <= 0.0)RCNT(J,1,T,CTY)=0.0   !IF NEGATIVE AVAILABLE, SET TO ZERO
                                    IF(RCNT(J,5,T,CTY) <= 0.0)RCNT(J,5,T,CTY)=0.0
                                END DO
                            !--
                            !--      TOTAL WEIGHTED POTENTIAL HARVESTABLE YIELD (WEIGHTED BY CONTINUOUS AND ROTATION RATIOS)
                                RCNT(6,1,T,CTY) = RCNT(4,1,T,CTY)*RCNTX(9,1,T,CTY)+ &
                                RCNT(5,1,T,CTY)*RCNTX(10,1,T,CTY)
                                RCNT(6,5,T,CTY) = RCNT(4,5,T,CTY)*RCNTX(9,5,T,CTY)+ &
                                RCNT(5,5,T,CTY)*RCNTX(10,5,T,CTY)
                            !--
                            !--      ASSIGN YIELD ADJUSTED COST OF PRODUCTION FOR CORN
                                DO H=1,50                                           !NUMBER OF DIFFERENT COSTS BASED ON YIELD/AC
                                    IF(RCNT(6,1,T,CTY) <= CSX(10,H,1,1))THEN           !IF HARVESTABLE YIELD IS LESS THAN OR EQUAL TO YIELD IN ONE OF 50 COST STRUCTURES

                                            RCNT(7,1,T,CTY)=CSX(10,H,10,1)+CSX(14,1,10,1) !RUS...RESTOF US. 10           !EIA16 COMMENTED ALL REGIONS AND ONLY USING 'REST OF COUNTRY
                                            J=10
                                            GOTO 43

                                    ENDIF
                                END DO
                             !   IF(H == 51)THEN
                                    H=50 !IF YIELD OFF THE CHARTS WE USE LAST LINE OF RESCOST
                                !    write(666,*) 'off the chart',curcalyr,NPT,T,CTY
                                    RCNT(7,1,T,CTY)=CSX(10,H,9,1)+CSX(14,1,9,1)
                                    J=9 !(region change version)
                           !     ENDIF
                            !--
                                43 CONTINUE
                            !--
                            !--      ASSIGN YIELD ADJUSTED COST OF PRODUCTION FOR WHEAT
                                DO HH=1,50                                           !NUMBER OF DIFFERENT COSTS BASED ON YIELD/AC
                                    IF(RCNT(6,5,T,CTY) <= CSX(10,HH,1,5))THEN           !IF HARVESTABLE YIELD IS LESS THAN OR EQUAL TO YIELD IN ONE OF 50 COST STRUCTURES
 ! section commented in region change version
 !                                       52 IF(RCNTX(2,5,T,CTY) <= 37 .or.index(117).ge.1)  THEN                 !FIND RIGHT REGION AND ASSIGN COST OF PRODUCTION. CSX(14...) IS NUTRIENT REPLACEMENT COSTS(N-P-K)
 !                                           RCNT(7,5,T,CTY)=CSX(10,HH,4,5)+CSX(14,1,4,5)   !NE... 4
 !                                           JJ=4                                             !NE...NORTHEAST
 !                                           GOTO 44                                         !GOT IT, SO NO NEED TO GO FURTHER...EXIT LOOP
 !                                       ELSEIF(RCNTX(2,5,T,CTY) <= 67)THEN
 !                                           RCNT(7,5,T,CTY)=CSX(10,HH,5,5)+CSX(14,1,5,5)   !APP...APPALACHIA. 5
 !                                           JJ=5
 !                                           GOTO 44
 !                                       ELSEIF(RCNTX(2,5,T,CTY) <= 119)THEN
 !                                           RCNT(7,5,T,CTY)=CSX(10,HH,6,5)+CSX(14,1,6,5)   !SE...SOUTHEAST.  6
 !                                           JJ=6
 !                                           GOTO 44
 !                                       ELSEIF(RCNTX(2,5,T,CTY) <= 164)THEN
 !                                           RCNT(7,5,T,CTY)=CSX(10,HH,3,5)+CSX(14,1,3,5)   !CB...OHIO,INDIANA,ILLINOIS. 3
 !                                           JJ=3
 !                                           GOTO 44
 !                                       ELSEIF(RCNTX(2,5,T,CTY) <= 191)THEN
 !                                           RCNT(7,5,T,CTY)=CSX(10,HH,2,5)+CSX(14,1,2,5)   !LS...LAKESTATES. 2
 !                                           JJ=2
 !                                           GOTO 44
 !                                       ELSEIF(RCNTX(2,5,T,CTY) <= 226)THEN
 !                                           RCNT(7,5,T,CTY)=CSX(10,HH,7,5)+CSX(14,1,7,5)   !NP...MIDWEST.  7
 !                                           JJ=7
 !                                           GOTO 44
 !                                       ELSEIF(RCNTX(2,5,T,CTY) <= 250)THEN
 !                                           RCNT(7,5,T,CTY)=CSX(10,HH,8,5)+CSX(14,1,8,5)   !SP...TEXAS OKLAHOMA.  8
 !                                           JJ=8
 !                                           GOTO 44
 !                                       ELSEIF(RCNTX(2,5,T,CTY) <= 287 .OR. (RCNTX(2,5,T,CTY) &
 !                                            >= 298 .AND. RCNTX(2,1,T,CTY) <= 305))THEN

                                            RCNT(7,5,T,CTY)=CSX(10,HH,10,5)+CSX(14,1,10,5) !RUS...RESTOF US. 10
                                            JJ=10
                                            GOTO 44

                                    ENDIF
                                END DO
                              !  IF(HH == 51)THEN
                           !   write(666,*) 'off the chart here2',curcalyr,npt,t,cty
                                    HH=50 !IF YIELD OFF THE CHARTS WE USE LAST LINE OF RESCOST
                                   ! RCNT(7,5,T,CTY)=CSX(10,HH,9,1)+CSX(14,5,9,1)  ! (change region version)
                                   RCNT(7,5,T,CTY)=CSX(10,HH,9,5)+CSX(14,5,9,5) ! (change region version)
                                   JJ=9  ! (change region version)
                              !  ENDIF
                            !--
                                44 CONTINUE
                            !--
                            ! update from UT 2019
                                RCNT(8,1,T,CTY)=EN(NPT,I,3,1)                            !national PRICE PER TON READ INTO WHATIF transfer to regions!!!!!!
                                RCNT(8,5,T,CTY)=EN(NPT,I,3,5)
                                IF(NEWPRC(NPT,I,CTY).GT.0.0)RCNT(8,1,T,CTY)=NEWPRC(NPT,I,CTY)  !FOR BIOMASS REGIONAL MODULE
                                IF(NEWPRC(NPT,I,CTY).GT.0.0)RCNT(8,5,T,CTY)=NEWPRC(NPT,I,CTY)
                                IF(INDEX(107).EQ.0) THEN  !IF NOT INCLUDING RESIDUES
                                   RCNT(8,1,T,CTY)=0.0
                                   RCNT(8,5,T,CTY)=0.0
                                ENDIF
!C--

                            !--
                            !--      FIGURE GROWER PAYMENT (PRICE PER DT - COST PER DT)
                                IF(RCNT(8,1,T,CTY) > RCNT(7,1,T,CTY))THEN                !nutrition replacement costs are $25
                                    RCNT(20,1,T,CTY)=RCNT(8,1,T,CTY)- CSX(10,H,J,1) !(RCNT(7,1,T,CTY)-20)
                                ENDIF
                                IF(RCNT(8,5,T,CTY) > RCNT(7,5,T,CTY))THEN
                                    RCNT(20,5,T,CTY)=RCNT(8,5,T,CTY)- CSX(10,HH,JJ,5)   !(RCNT(7,5,T,CTY)-20)
                                ENDIF
                            !--
                            !--      POTENTIAL RETURNS PER ACRE IF HARVEST
                                RCNT(9,1,T,CTY) = (RCNT(8,1,T,CTY)*RCNT(6,1,T,CTY)) &
                                - ((RCNT(7,1,T,CTY)+INCENT(16,1,T,CTY)+INCENT(21,1,T,CTY))   & ! ADD IN CARBON AND ENERGY COST INCREASES
                                * RCNT(6,1,T,CTY))
                                RCNT(9,5,T,CTY) = (RCNT(8,5,T,CTY)*RCNT(6,5,T,CTY)) &
                                - ((RCNT(7,5,T,CTY)+INCENT(16,5,T,CTY)+INCENT(21,5,T,CTY)) &
                                * RCNT(6,5,T,CTY))
                            !--
                            !--      RETURNS PER ACRE OF HARVESTED
                                IF (RCNT(9,1,T,CTY) > 0.0) THEN
                                    RCNT(10,1,T,CTY)=RCNT(9,1,T,CTY)
                                END IF
                                IF (RCNT(9,5,T,CTY) > 0.0) THEN
                                    RCNT(10,5,T,CTY)=RCNT(9,5,T,CTY)
                                END IF
                                IF(INCENT(1,1,T,CTY) > 0.0)RCNT(10,1,T,CTY)=0.0        !IF TAKING CARBON CREDIT, THEN CANNOT HARVEST      !!
                                    IF(INCENT(1,5,T,CTY) > 0.0)RCNT(10,5,T,CTY)=0.0
                                !--
                                !--      PROFITABLY HARVESTED PRODUCTION IN COUNTY(BY TILLAGE)
                                    IF(RCNT(9,1,T,CTY) > 0.0)THEN
                                        RCNT(11,1,T,CTY) = RCNT(6,1,T,CTY)*CY(2,1,T,CTY)
                                        RCNT(19,1,T,CTY) = CY(2,1,T,CTY)                !CAPTURE HARVESTED ACRES FOR RESIDUES CORN
                                    ENDIF
                                    IF(RCNT(9,5,T,CTY) > 0.0)THEN
                                        RCNT(11,5,T,CTY) = RCNT(6,5,T,CTY)*CY(2,5,T,CTY)
                                        RCNT(19,5,T,CTY) = CY(2,5,T,CTY)                !CAPTURE HARVESTED ACRES FOR RESIDUES WHEAT
                                    ENDIF
                                    IF(INCENT(1,1,T,CTY) > 0.0)RCNT(11,1,T,CTY)=0.0        !IF TAKING CARBON CREDIT, THEN CANNOT HARVEST      !!
                                        IF(INCENT(1,5,T,CTY) > 0.0)RCNT(11,5,T,CTY)=0.0
                                    !--
                                    !--      IF NOT HARVESTING SET 'ADDITIONAL CARBON AND ENERGY COSTS' TO ZERO
                                        IF(RCNT(9,1,T,CTY) < 1.0)THEN
                                            DO J=12,21
                                                INCENT(J,1,T,CTY) = 0.0
                                            ENDDO
                                        ENDIF
                                        IF(RCNT(9,5,T,CTY) < 1.0)THEN
                                            DO J=12,21
                                                INCENT(J,5,T,CTY) = 0.0
                                            ENDDO
                                        ENDIF
                                    !--
                                    !--      HARVESTED PRODUCTION IN COUNTY (ALL TILLAGES)
                                        RCNT(11,1,4,CTY) = RCNT(11,1,4,CTY)+RCNT(11,1,T,CTY)
                                        RCNT(11,5,4,CTY) = RCNT(11,5,4,CTY)+RCNT(11,5,T,CTY)
                                      !  IF(REGBIO(CTY).NE.DLOOP.and.index(119).eq.1)RCNT(8,1,T,CTY)=0.0  !FOR BIOMASS REGIONAL MODULE update from UT 2019
                                      !  IF(REGBIO(CTY).NE.DLOOP.and.index(119).eq.1)RCNT(8,5,T,CTY)=0.0  !update from UT 2019 but index(119)=0

                                    !--      CARBON AND ENERGY IN COUNTY
                                        DO J=12,18
                                            RCNT(J,1,T,CTY) = RCNTX(J,1,T,CTY)*RCNT(11,1,T,CTY)   !PER DT * DT
                                            RCNT(J,5,T,CTY) = RCNTX(J,5,T,CTY)*RCNT(11,5,T,CTY)
                                        !--
                                        !--       CARBON AND ENERGY IN COUNTY (ALL TILLAGES)
                                            RCNT(J,1,4,CTY) = RCNT(J,1,4,CTY) + RCNT(J,1,T,CTY)   !SUM OVER ALL TILLAGES
                                            RCNT(J,5,4,CTY) = RCNT(J,5,4,CTY) + RCNT(J,5,T,CTY)
                                        !--
                                        END DO
                                    !--
                                    ENDDO !T LOOP
                                !--
                                !--
                                ENDIF
                            !--
                            !--
                            !--    !!NOW PRINTING IN PRINTRESID.FOR!!
                            !--
                            !C      GOTO 493
                            !--     PRINT RESIDUE DATA BY COUNTY
                            !c   78 FORMAT(29A)
                            !c   79 FORMAT(I4,';',A4,';',F6.0,';',I3,';',I3,';',F20.3,';'
                            !c     1,F20.3,';',F20.3,';',F20.3,';',F20.3,';',F20.3,';',F20.3,';'
                            !c     1,F20.3,';',F20.3,';',F20.3,';',F20.3,';',F20.3,';',F20.3,';',
                            !c     1 F20.3,';',F20.3,';',F20.3,';',F20.3,';',F20.3,';')
                            !--
                            !c       IF(CTY.EQ.3109)THEN
                            !c          RESIDUES = 'output/'//EXTT//'RESIDUES.TXT'
                            !c          IF(I.EQ.ISTART)THEN
                            !c             OPEN(UNIT=59,FILE = RESIDUES)
                            !--
                            !c              WRITE(59,78)'YEAR;SIM;FIPS;K;T;TOTALYIELD;TOTPOTENTHARV
                            !c     1;CSTDT;PRICE;GROWERPAYMENT;RETURNSPERAC;totresreturns;HARVACRES
                            !c     1;HARVPROD;DIRECTe
                            !c     1;DIRECTc;FERTe;FERTc;CfromN;TOTe;TOTc;
                            !c     1ADCARBCOST;ADENERGYCOST'
                            !c          ELSE
                            !c             OPEN(UNIT=59,FILE = RESIDUES,POSITION='APPEND')
                            !c          ENDIF
                            !--
                            !c         DO CLN=1,3109
                            !c           DO K=1,5
                            !C            IF(K.EQ.1.OR.K.EQ.5)THEN
                            !c             DO T=1,3
                            !c              WRITE(59,79)IYYEAR(I),EXT,RCNTX(3,K,3,CLN),K,T
                            !c     1               ,RCNT(3,K,T,CLN),RCNT(6,K,T,CLN),RCNT(7,K,T,CLN)
                            !c     1               ,RCNT(8,K,T,CLN),RCNT(20,K,T,CLN)
                            !c     1               ,RCNT(10,K,T,CLN),RCNT(10,K,T,CLN)*RCNT(19,K,T,CLN)
                            !c     1               ,RCNT(19,K,T,CLN),RCNT(11,K,T,CLN)
                            !c     1               ,RCNT(12,K,T,CLN),RCNT(13,K,T,CLN)
                            !c     1               ,RCNT(14,K,T,CLN),RCNT(15,K,T,CLN),RCNT(16,K,T,CLN)
                            !c     1               ,RCNT(17,K,T,CLN),RCNT(18,K,T,CLN)
                            !c     1               ,INCENT(16,K,T,CLN),INCENT(21,K,T,CLN)
                            !c             END DO
                            !C            ENDIF
                            !c           END DO
                            !c         ENDDO
                            !c        CLOSE(UNIT=59)
                            !c       ENDIF
                            !--
                            !--
                                493 CONTINUE
                            !--
                            ENDDO      !END CTY LOOP
                        !--
                        ENDIF !END IF YRRESID GE VALUE DEFINED IN SIM.INS
                    !--
      RETURN
                        END SUBROUTINE RESDCNTY
                        !***********************************************************************************************

                        SUBROUTINE RMAIN
                        IMPLICIT NONE

                        INTEGER :: PERIOD,ICTY,DLOOP
                       ! CHARACTER(20) :: FILENAME !12
                        CHARACTER(8) :: CRPFILE
                        CHARACTER(1) :: NPERIOD
                        REAL :: RESGROWER

                        !EIA add
                         INTEGER IISTART,NCROPS,IYEAR1,IDB,J
                        INTEGER FILE_MGR
                        EXTERNAL FILE_MGR
                        !CHARACTER*25 FNAME
                        CHARACTER*35 FNAME
                        LOGICAL NEW
                        INTEGER IUNIT1,FILEUNIT
                       REAL ::      IDLE(PSYEARS,3111)
                        REAL :: RENB


                    !--
                    !--
                    !--   ***********************************************************************
                    !--         This subroutine drives all internal operations of SUPPLY MODULE
                    !--                     and it is called from MAIN
                    !--   ***********************************************************************
                    !--
                    !--
                    !--     ******* INITIALIZATION AND DEBUGGING STATEMENTS **********
                    !--
                    !--             AUXILLARY WRITE UNITS
                    !--
                        IISTART = INDEX(30) - INDEX(27) + 3
                        NCROPS = INDEX(2)
                        POLY=INDEX(63)
                        CNTY=INDEX(33)
                        L=I-1
                    !   87 FORMAT('+','Year -> ',I4)
                        87 FORMAT(' ','Year -> ',I4)
                    !      IF(N<=10)write(*,87)CY
                    !--   FIRST YEAR OF SIMULATION
                        IYEAR1 = INDEX(30)
                    !--   AUXILLARY WRITE STATEMENTS (UNIT NO., 0 SCREEN, -1 OFF)

                        IDB = INDEX(25)

                    !--
                    !--  *************************************************************************
                    !--             ********** PROCESSING STATEMENTS **********
                    !--   When the program is creating the baseline then we need to call READDATA.
                    !--   If the baseline is already computed skip READDATA.
                        BASELINEDONE = 0
                        IF(BASELINEDONE<1) GOTO 1119
                        1117 CONTINUE
                        BASELINEDONE = 1
                        1119 CONTINUE

                  ! the baseline files get read multiple times - check to see if this is needed


                   !EIA add
                   ! get a unit number from file manager
                   IUNIT1=FILEUNIT()
                   !***************************

                  FNAME='./input/PSBASE'//YEARNAME(I)//'.'//'UNF'

                 OPEN(UNIT=IUNIT1,FORM='UNFORMATTED',FILE=FNAME)
                 READ(IUNIT1) RENB,CYB,CYXB,PlAcB,AdjFac,STATE,BSHIFT,bb &
                            ,WEST,IDLE,PASTRETRN,NPVB,PASTRENT,LANDRENT,PPI &
                            ,(BLAVCS(I,K),K=1,18),(BLTVCS(I,K),K=1,18) &
                             ,PRCOEF,PSHIFT,bigindex,CYBACKUP !,NPVB!,CSXB  !region change version


                  CLOSE(IUNIT1)

                  IF(SHRINK_BASE==1) THEN !only run this if you are Shrinking the BASELINE passed from UT; do once and then replace files in PSBASEUNF.zip
                  FNAME='PSBASE'//YEARNAME(I)//'.'//'UNF'
                  OPEN(UNIT=IUNIT1,FORM='UNFORMATTED',FILE=FNAME)
                  WRITE(IUNIT1) RENB,CYB(:,:,:,1:16),CYXB(:,:,:,1:16) ,PlAcB,AdjFac,STATE,BSHIFT,bb &
                            ,WEST,IDLE,PASTRETRN,NPVB,PASTRENT(:,1:16),LANDRENT,PPI &
                            ,(BLAVCS(I,K),K=1,18),(BLTVCS(I,K),K=1,18) &
                             ,PRCOEF,PSHIFT,bigindex,CYBACKUP
                   CLOSE(IUNIT1)
                   ENDIF

                   FNAME='./input/PSBIOMASSB.'//YEARNAME(I)//'.unf'
                   OPEN(UNIT=IUNIT1,FORM='UNFORMATTED',FILE=FNAME)
                   READ(IUNIT1)CMX,IRTLN,HARVC,HARVESTCOST,BIOEF,RRR,NUT
                   CLOSE(IUNIT1)

                  IF(SHRINK_BASE==1) THEN !only run this if you are Shrinking the BASELINE passed from UT; do once and then replace files in PSBASEUNF.zip
                  FNAME='QPSBIOMASSB.'//YEARNAME(I)//'.unf'
                  OPEN(UNIT=IUNIT1,FORM='UNFORMATTED',FILE=FNAME)
                  WRITE(IUNIT1) CMX(:,:,:,1:16),IRTLN,HARVC,HARVESTCOST,BIOEF,rrr(:,1:16),NUT
                  CLOSE(IUNIT1)
                  ENDIF


                   CSX=CSXB


                    !--
                        1958 CONTINUE
                        CALL RWHATIF
                        CALL GET_PRICE_MULTS          ! call eia routine to overwrite price index with price multipliers
!
                    !--
                        IF(INDEX(106) >= 2) CALL INFLATEBIO  !IF SIMULATION
                    !      WRITE(*,*)'NUM2',ADJPRC,CYX(25,1,1,1345),CYXB(25,1,1,1345)
                    !--
                    !c      CALL ADJCYI
                        DO CTY = 1,CNTY
                            DO DLOOP=1,10
                                 IF(REGBIODMD(I,2,DLOOP).LE.0.0.AND.REGBIO(CTY).EQ.DLOOP)THEN
                                     NEWPRC(NPT,I,CTY)=0.0
                                 ENDIF
                            ENDDO

                            ICOUNTER = 0
                            IBASEFLAG = 0
                            CALL BIOHARV        !FIGURE BIOMASS HARVEST COSTS BASED ON YIELDS
                            CALL COSTCHG    !FIGURE COST OF PRODUCTION CHANGES FROM CARBON COST AND ENERGY PRICE INCREASES
                            520 CALL NPVALUE
                            CALL INPUT2LP
                            CALL LPSIM
                        ! stoch update from ut 2019
                                   !  IF(INDEX(99).EQ.1.AND.INDEX(87).EQ.1.AND.ADJPRC.EQ.0) &  !IF ADJPRC OF BIOMASS IN SAME YEAR NO NEED TO READ AGAIN
                                   !   CALL DEVYCTY    !EIA CHAD 2017     !YIELD PART OF STOCHASTIC MODEL!!
                            CALL OUTFRMLP
                            CALL BIOTRACK
                            CALL PASTLP
                                  !  IF(INDEX(103).EQ.1)CALL CRPLP     !IF INCLUDING CRP !EIA CHAD 2017
                            IF(IBASEFLAG>0)GOTO 520
                        END DO
                    !--
                    !--
                    !--   FIGURE HARVESTED ACRES, RETURNS AND PRODUCTION
                        CALL HARVEST
                    !--   DECIDE IF HARVEST RESIDUES
                        IF(INDEX(87) == 1)THEN
                            CALL RESDCNTY                                    !RESIDUES                     !MAYBE MOVE UP INTO CROP LOOP TO SPEED UP RUNTIME?!!!!!!!
                        ENDIF
                    !--   FIGURE CARBON AND EMISSIONS
                        CALL CARB
                    !--

                    !--
                    !--   When computing the baseline the following statements write all data to it.

                        !--
                        !--
                        !--     This statements compute the national simulated values for acreage, yield,
                        !--     and cost of production. These variables then will feed the POLYSYS supply
                        !--     sub-routine. Deffiency Payments are computed in the OUTREG subroutine.
                            A(NPT,I,19,2) = 0.0
                            A(NPT,I,25,2) = 0.0
                            A(NPT,I,29,2) = 0.0
                            XA(I,10,2) = 0.0
                            XA(I,02,2) = 0.0
                            XA(I,03,2) = 0.
                            DO DLOOP=1,10
                               AVSTVR(I,DLOOP) = 0.0
                               AVSTW(I,DLOOP)  = 0.0
                               AVSWTCH(I,DLOOP)=  0.0
                               AVPOP(I,DLOOP)  =  0.0
                               AVWIL(I,DLOOP)  =  0.0
                               AVSWEET(I,DLOOP)=  0.0
                               AVCRP(I,DLOOP) = 0.0
                               AVMISCAN(I,DLOOP)= 0.0
                               AVECANE(I,DLOOP) = 0.0
                            ENDDO

                            DO K = 1,NCROPS
                                C(NPT,I,1,K)   = 0.0                 ! Harvested Acres
                                C(NPT,I,3,K)   = 0.0                 ! Production
                                C(NPT,I,34,K)  = 0.0                 ! Planted Acres
                                X(I,3,K)   = 0.0
                                SMAVCS(I,K) = 0
                                SMTVCS(I,K) = 0
                                EN(NPT,I,1,K) = 0.0                  !RESIDUE PRODUCTION
                                EN(NPT,I,8,K) = 0.0
                                EN(NPT,I,10,K)= 0.0                  !RESIDUE PROFIT
                                DO J=12,20
                                    EN(NPT,I,J,K)=0.0                   !ENERGY AND CARBON EMISSIONS FROM RESIDUES
                                END DO
                                RESGROWER=0.0
                            !--
                                DO CTY = 1,CNTY
                                    DO T=1,3                                   !! CRP ADDED  BELOW  !!!
                                        C(NPT,I,01,K) = C(NPT,I,01,K) + CY(2,K,T,CTY)    ! harvested acres
                                !        write(668,*) 'harvest',C(NPT,I,01,K) , CY(2,K,T,CTY) ,t, cty
                                        C(NPT,I,03,K) = C(NPT,I,03,K) + CY(4,K,T,CTY)    ! production
                                        C(NPT,I,34,K) = C(NPT,I,34,K) + CY(1,K,T,CTY)    ! planted
                                     !!!!!!!!!!   FOR REGIONAL BIOFUEL DEMANDS !!!!!!!!!!!!!!!!!

                                        IF(INDEX(119).EQ.1)THEN
                                         DO DLOOP=1,10
                                           IF(REGBIO(CTY).EQ.DLOOP)THEN
                                             IF(K.EQ.9)THEN
                                               AVSWTCH(I,DLOOP)=AVSWTCH(I,DLOOP)+ CY(4,K,T,CTY)

                                             ELSEIF(K.EQ.10)THEN
                                               AVPOP(I,DLOOP)= AVPOP(I,DLOOP) + CY(4,K,T,CTY)
                                             ELSEIF(K.EQ.11)THEN
                                               AVWIL(I,DLOOP)=AVWIL(I,DLOOP)+ CY(4,K,T,CTY)
                                             ELSEIF(K.EQ.15)THEN
                                               AVSWEET(I,DLOOP)= AVSWEET(I,DLOOP) + CY(4,K,T,CTY)
                                             ELSEIF(K.EQ.16)THEN
                                               AVMISCAN(I,DLOOP)= AVMISCAN(I,DLOOP) + CY(4,K,T,CTY)
                                             ELSEIF(K.EQ.17)THEN
                                               AVECANE(I,DLOOP)=  AVECANE(I,DLOOP)+ CY(4,K,T,CTY)
                                            ELSEIF(K.EQ.1)THEN !RESIDUES
                                              AVSTVR(I,DLOOP)=AVSTVR(I,DLOOP)+RCNT(11,K,T,CTY)
                                            ELSEIF(K.EQ.5)THEN !RESIDUES
                                              AVSTW(I,DLOOP) =AVSTW(I,DLOOP)+RCNT(11,K,T,CTY)
                                           ENDIF
                                         ENDIF
                                       ENDDO
                                     ENDIF


                                        SMAVCS(I,K) = SMAVCS(I,K)+CY(6,K,T,CTY)
                                        SMTVCS(I,K) = SMTVCS(I,K)+CY(6,K,T,CTY)

                                        EN(NPT,I,1,K) = EN(NPT,I,1,K) + RCNT(11,K,T,CTY)/1000000            !HARVESTED RESIDUES TO NATIONAL LEVEL
                                        EN(NPT,I,8,K) = EN(NPT,I,8,K) + RCNT(19,K,T,CTY)/1000000            !acres of harvested residues to national level
                                    !--
                                        EN(NPT,I,10,K) = EN(NPT,I,10,K) + RCNT(10,K,T,CTY)*CY(2,K,T,CTY) / 1000000 !RESIDUE PROFITS TO NATIONAL LEVEL
                                     !   if (NPT.eq.3) write(666,*) 'debug profits', CURIYR+1989,K,T,CTY,EN(NPT,I,10,K),RCNT(10,K,T,CTY),CY(2,K,T,CTY)

                                        DO J=12,19
                                            EN(NPT,I,J,K) = EN(NPT,I,J,K) + RCNT(J,K,T,CTY)/1000000          !ENERGY AND CARBON EMISSIONS FROM RESIDUES
                                        END DO
                                    !--
                                        RESGROWER = RESGROWER + RCNT(20,K,T,CTY) &
                                        * RCNT(19,K,T,CTY)                     !GROWER PAYMENT * TOTAL harvested acres
                                    ENDDO
                                END DO !end cty loop
                            !--
                            ! INDEX 103 always 0 in NEMS
                              !  IF(INDEX(103) == 1 .AND. K <= 12) THEN   !IF CRP ON, THEN ADD ACRES TO TOTAL FOR NATIONAL SUPPLY/DEMAND PRICE DETERMINATION
                              !                 C(NPT,I,01,K) = C(NPT,I,01,K) + CRPTOT(I,7,K+10)*1000000    ! harvested acres
                              !                 C(NPT,I,03,K) = C(NPT,I,03,K) + CRPTOT(I,5,K+10)*1000000    ! production
                              !                 C(NPT,I,34,K) = C(NPT,I,34,K) + CRPTOT(I,1,K+10)*1000000    ! planted
                              !  ENDIF
                            !--
                            !--
                            !--         FIGURE GROWER PYMNT
                                IF(EN(NPT,I,1,K) > 0.0)THEN
                                    EN(NPT,I,20,K) = RESGROWER/(EN(NPT,I,19,K)*1000000)
                                ENDIF
                            !--
                            !--         Change units in total planted and harvested acreages
                                C(NPT,I,34,K) = (C(NPT,I,34,K)/1000000)
                                C(NPT,I,1,K) = (C(NPT,I,1,K)/1000000)
                            !--         Compute average and total variable costs and change units.
                                IF(B(I,5,K)==0.0) B(I,5,K) = BLAVCS(I,K)
                                IF(B(I,6,K)==0.0) B(I,6,K) = BLTVCS(I,K)
                                SMAVCS(I,K) = (SMAVCS(I,K)/C(NPT,I,1,K))/1000000
                                SMTVCS(I,K) = SMTVCS(I,K)/1000000
                            !c            C(NPT,I,6,K) = B(I,6,K) + SMTVCS(I,K) - BLTVCS(I,K) ! Does not include cost of set aside
                            !--         COMPUTE TOTAL OF EIGTH CROP ACREAGES
                                A(NPT,I,25,2) = A(NPT,I,25,2) + C(NPT,I,34,K)
                                A(NPT,I,29,2) = A(NPT,I,29,2) + C(NPT,I,01,K)
                            !--         Change units in production
                                C(NPT,I,3,K) = (C(NPT,I,3,K)/1000000)
                            !--         Calculate yields = production/harvested acreage
                                IF(C(NPT,I,1,K)>0.0) THEN
                                    C(NPT,I,2,K) = C(NPT,I,3,K)/C(NPT,I,1,K)
                                ELSE
                                    C(NPT,I,2,K) = 0.0
                                END IF
                            !--         For cotton and rice change production units from pounds to bales and cwt respectively
                                IF(K == 7) C(NPT,I,3,K) = ( C(NPT,I,3,K) / 480.0 )     ! 1 bale = 480 pounds
                                IF(K == 8) C(NPT,I,3,K) = ( C(NPT,I,3,K) / 100.0 )     ! 1 cwt  = 100 pounds (hundred weight)
                                IF(CFIXED(I,3,K)>0.0)THEN                                            !!!TO FIX PRODUCTION
                                    C(NPT,I,3,K) = CFIXED(I,3,K)
                                    IF(CFIXED(I,2,K)>0)THEN
                                        C(NPT,I,2,K) = CFIXED(I,2,K)
                                        C(NPT,I,1,K) = C(NPT,I,3,K)/C(NPT,I,2,K)
                                    ENDIF
                                ENDIF
                            ! c      WRITE(*,*)C(NPT,I,3,k),b(i,3,k),i,k,'rmain'                      !!!AND CHANGE OTHER NUMBERS
                            !--         ***************
                            !--         BEGINNING STOCK
                            !--         ***************
                            !-          DEFINED AS PREVIOUS YEAR ENDING STOCK
                                C(NPT,I,25,K) = C(NPT,L,14,K)
                            !--         ***********************
                            !--         TOTAL SUPPLY IDENTITIES
                            !--         ***********************
                                C(NPT,I,07,K) = C(NPT,I,25,K) + C(NPT,I,03,K) + X(I,01,K)
                            !--         ***************************
                            !--         EFFECTIVE SUPPLY IDENTITIES
                            !--         ***************************
                            !--         DEFINED AS THE SUPPLY MINUS GOVERNMENT STOCKS
                            !--         THAT ARE ISOLATED FROM THE MARKET.
                            !--         CURRENT YEAR BASELINE VALUES ARE USED AS AN ESTIMATE OF ENDING
                            !--         YEAR F-O-R AND CCC STOCK VALUES.
                                C(NPT,I,08,K)= C(NPT,I,07,K)-C(NPT,L,15,K)-C(NPT,L,16,K)-C(NPT,L,36,K)-C(NPT,L,37,K)
                            !--
                            !--     NET PRESENT VALUE GENERATED BY BIOMASS CROPS AND TRANSLATED INTO ANNUITY   !CHAD ADDED THIS PART
                                IF(K>8 .AND. K<12) THEN                                                           !2/17/04
                                    totalnpv(i,k)=0.0
                                    DO ICTY=1,CNTY
                                        TOTALNPV(I,K)=TOTALNPV(I,K) &
                                        +(BIOPL(NPT,I,k-8,1,ICTY)+BIOPL(NPT,I,k-8,2,ICTY)+BIOPL(NPT,I,K-8,3,ICTY)) &
                                        *NPV(NPT,I,K,1,ICTY)
                                    END DO
                                    IF(ICTY >= index(33))THEN
                                        ANPV(I,K)= TOTALNPV(I,K) * (DRATE*(1+DRATE)**INPV)/ &
                                        (((1+DRATE)**INPV)-1)
                                        ANPV(I,K) = ANPV(I,K)/1000000.0
                                    END IF
                                END IF
                            !--      SAME FOR MISCAN
                                IF(K == 16) THEN
                                    totalnpv(i,k)=0.0
                                    DO ICTY=1,CNTY
                                        TOTALNPV(I,K)=TOTALNPV(I,K) &
                                        +(BIOPL(NPT,I,k-12,1,ICTY)+BIOPL(NPT,I,k-12,2,ICTY)+BIOPL(NPT,I,K-12,3,ICTY)) &
                                        *NPV(NPT,I,K,1,ICTY)
                                    END DO
                                    IF(ICTY >= index(33))THEN
                                        ANPV(I,K)= TOTALNPV(I,K) * (DRATE*(1+DRATE)**INPV)/ &
                                        (((1+DRATE)**INPV)-1)
                                        ANPV(I,K) = ANPV(I,K)/1000000.0
                                    END IF
                                END IF
                            !--      SAME FOR ecane
                                IF(K == 17) THEN
                                    totalnpv(i,k)=0.0
                                    DO ICTY=1,CNTY
                                        TOTALNPV(I,K)=TOTALNPV(I,K) &
                                        +(BIOPL(NPT,I,k-12,1,ICTY) )  & !+BIOPL(NPT,I,k-12,2,ICTY)+BIOPL(NPT,I,K-12,3,ICTY))
                                        *NPV(NPT,I,K,1,ICTY)
                                    END DO
                                    IF(ICTY >= index(33))THEN
                                        ANPV(I,K)= TOTALNPV(I,K) * (DRATE*(1+DRATE)**INPV)/ &
                                        (((1+DRATE)**INPV)-1)
                                        ANPV(I,K) = ANPV(I,K)/1000000.0
                                    END IF
                                END IF
                            !--
                            !--         ********************            |09 CORN PRICE, SOYBEAN PRICE
                            !--         INDEX OF FEED PRICES            |03 CORN & SOYBEAN PRODUCTION
                            !--         ********************            |13 GNP DEFLATOR -->1982=100
                            !--         <<<<<>>>>> UNTIL CAN GET INDEX IN LOOP
                                A(NPT,L,26,3) = AB(L,26,3)
                                A(NPT,I,24,3) = 7.2734166+13.92004*C(NPT,L,9,1)+7.094674*C(NPT,L,9,6) &
                                - 0.0030873*((C(NPT,I,03,01)+C(NPT,I,03,06))-(C(NPT,L,03,01) &
                                + C(NPT,L,03,06)))+0.3318033*A(NPT,L,26,3)

                            END DO
                        !--

                    !--   The subroutine which writes the output files,OUTREG, is called from MAIN.
                        5000 CONTINUE
                        RETURN
                        END SUBROUTINE RMAIN
                    !     **************************************************************************************************
                        SUBROUTINE RWHATIF
      IMPLICIT NONE

                        REAL  VAL
                        REAL CHANGE(12)
                        REAL RYLDADJ
                        CHARACTER(2)  MM
                        CHARACTER TG
                        INTEGER YR,SIMYR,DREG,REGCTY,begyear

                        !EIA add
                        INTEGER :: IOS1,IOS, TL, J, NCROPS, IDB, IYEAR1
                        INTEGER FILE_MGR
                        EXTERNAL FILE_MGR
                        CHARACTER*25 FNAME
                        LOGICAL NEW
                        INTEGER IUNIT1,FILEUNIT
                    !--
                    !--
                    !--  ******************************************************************************
                    !--        This subrotuine reads and inputs the changes to be simulated,
                    !--                     it is called from INPUT2LP.
                    !--  ******************************************************************************
                    !--
                    !--             AUXILLARY WRITE UNITS
                    !--
                    !--             FIRST YEAR OF SIMULATION
                    !--
                        IYEAR1 = INDEX(27)
                    !--
                        SIMYR = IYEAR1+I-3
                    !--             AUXILLARY WRITE STATEMENTS (UNIT NO., 0 SCREEN, -1 OFF)
                    !--

                        IDB  = INDEX(25)
                    !--
                        NCROPS = INDEX(2)
                        POLY  =  INDEX(63)
                        CNTY  =  INDEX(33)
                        BEGYEAR=INDEX(30)-1
                    !--

                    !--
                    !--   THIS SUBROUTINE STARTS BY SETTING CYX=CYXB FOR COUNTIES
                    !--   ASSIGN XB TO X FOR CRD OR REGIONAL EXOGENOUS VARIABLES
                        DO K = 1, NCROPS
                            DO TL=1,3
                                DO J = 1, INDEX(65)  !37
                                    DO CTY = 1, CNTY
                                        IF(J == 25 .AND. ADJPRC == 1)THEN   !IF ADJUSTING PRICE OF BIOMASS, USE ALREADY ADJUSTED PRICE
                                            CONTINUE
                                        ELSE
                                            CYX(J,K,TL,CTY) = CYXB(J,K,TL,CTY)
                                        !C      IF(CYX(1,K,TL,CTY).EQ.19001.AND.K.EQ.1)THEN
                                        !C        WRITE(*,*)CYX(4,K,TL,CTY),K,TL,CTY ,'RWHATIF'
                                        !C       ENDIF
      ENDIF
                                    END DO
                                END DO
                            ENDDO   !TILLAGE
                        END DO
                    !--
                        DO J = 1,8
                            DO TL=1,4
                                DO K = 1,NCROPS
                                    DO CTY = 1,CNTY
                                        PlAc(J,K,TL,CTY) = PlAcB(J,K,TL,CTY)
                                    END DO
                                END DO
                            ENDDO !TILLAGE
                        END DO
                    !--
                    !-- IF UPDATING BASELINE SKIP FILE READING
                    !--

                    !--
                    !--
                    !--   POLYSYS REGION CHANGES FROM WHATIFRR.RMF FILE
                    !--
                    goto 1005 !not using whatif files -- TD
                    FNAME='PSWHATIFRG'
                     NEW=.FALSE.
                    IUNIT1=FILE_MGR('O',FNAME,NEW)
                       ! OPEN(UNIT=888,FILE='whatif/WHATIFRG.'//EXTT)
                        7 FORMAT(//////////////////)
                        READ(IUNIT1,7,IOSTAT=ios)
                        IF(ios<=-1) GOTO 1000
                        1001 CONTINUE
                        READ(IUNIT1,*,IOSTAT=ios)YR,MM,J,K,crdl,TG,T,VAL
                    !--
                        IF(ios<=-1) GOTO 1000
                    !--
                    !-- Read changes for RX matrix
                    !--
                    !--
                        IF(MM=='RX' .AND. TG=='P')THEN
                        !--
                            IF(YR == 9999 .AND. CRDL == 999)THEN
                            !--
                                DO CTY=1,CNTY
                                    CYX(J,K,T,CTY) = (1+VAL*(SIMYR-BEGYEAR))*(CYXB(J,K,T,CTY))     !THIS IS FOR BIOMASS CROP YIELD INCREASES WHICH START IN 2015
                                ENDDO
                                IF(K == 10)POPINCRES=VAL   !VALUE TO INCREASE THE FUTURE YIELD PROJECTION BY IN NPVALUES
                            !--
                            ELSEIF(YR == 9999 .AND. CRDL /= 999)THEN
                            !--
                                DO CTY=1,CNTY
                                    IF(CYXB(2,K,T,CTY) == CRDL)THEN
                                        CYX(J,K,T,CTY) = (1+VAL*(SIMYR-BEGYEAR))*(CYXB(J,K,T,CTY))  !THIS INCREASES THE YIELD CHANGE YEARLY
      ENDIF
                                END DO
                            !--
                            !--
                            ELSEIF(YR /= 9999 .AND. CRDL == 999)THEN  !IF SPECIFIC ON YEAR OF INCREASE, BUT WANT TO APPLY TO ALL REGIONS
                            !--
                                IF(YR == SIMYR)THEN
                                    DO CTY=1,CNTY
                                        CYX(J,K,T,CTY) = (1+VAL)*(CYXB(J,K,T,CTY))  !THIS INCREASES THE YIELD CHANGE only for particular years
                                    END DO
      ENDIF
                            !--
                            ELSE
                            !--
                                IF(YR == SIMYR)THEN
                                    DO CTY=1,CNTY
                                        IF(CYXB(2,K,T,CTY) == CRDL)THEN
                                            CYX(J,K,T,CTY) = (1+VAL)*(CYXB(J,K,T,CTY))  !THIS INCREASES THE YIELD CHANGE only for particular years
      ENDIF
                                    END DO
      ENDIF
      ENDIF
      ENDIF


                    !--
                    !C      IF(MM=='EN'.AND.(TG=='P'.OR.T=='V').AND.J.LT.8)    !THIS IS IF CHANGING REGIONAL % TILLAGE
                    !C     1       REN(J,K,crdl) = VAL
                    !--
                    !C      IF(MM=='EN'.AND.(TG=='P'.OR.T=='V').AND.J.GT.16)   !THIS IS IF CHANGING REGIONA % ROTATION
                    !C     1       RENX(J,K,crdl) = VAL
                    !--
                        999 GOTO 1001
                        1000 CONTINUE
                    !    IF(ios<=-1) THEN
                        !        CLOSE(888,STATUS='DELETE')
                   !!     ELSE
                            !CLOSE(IUNIT1)
                     !        IUNIT1=FILE_MGR('C',FNAME,NEW)
                      !  END IF
                        1006 continue
                    !--
                    !--   NATIONAL CHANGES FROM WHATIFUS.RMF FILE
                    !--
                      FNAME='PSWHATIFUS'
                       NEW=.FALSE.
                      IUNIT1=FILE_MGR('O',FNAME,NEW)
                      !  OPEN(UNIT=888,FILE='whatif/WHATIFUS.'//EXTT)
                    !--
                    !--   SKIP 14 LINES BEFORE READING DATA
                    !--
                        YR=0
                        MM='ZZ'
                        J=0
                        K=0
                        VAL=0
                        8 FORMAT(/////////////)
                        READ(IUNIT1,8,IOSTAT=ios1)
                          IF(ios1<=-1) GOTO 1003
                        1002 CONTINUE
                        READ(IUNIT1,*,IOSTAT=ios1)YR,MM,J,K,VAL

                    !--
                        IF(ios1<=-1) GOTO 1003
                    !--
                        IF(YR>SIMYR) GOTO 1003
                        IF(YR/=SIMYR) GOTO 1004
                    !--
                    !--
                        IF(MM=='RX') THEN                                    !!25X25 THIS IS TO INCREASE YIELDS BY 50% ABOVE BASELINE RATE OF INCREASE

                            IF(J == 25)THEN

                                RYLDADJ=VAL/B(I,2,K)                                !READ IN NATIONAL AVERAGE AND APPLY %CHANGE TO ALL REGIONS
                            !C        WRITE(*,*)RYLDADJ,VAL,B(I,2,K),I
                            !C        PAUSE
                                DO CTY = 1,CNTY
                                    DO T=1,3
                                        CYX(J,K,T,CTY)=RYLDADJ*CYXB(J,K,T,CTY)
                                    !C      WRITE(*,*)I,J,K,CRDL,RX(J,K,CRDL),RXB(J,K,CRDL),RYLDADJ
                                    !C              RX(J,K,crdl)=(1+VAL)*RXB(J,K,crdl)
                                    ENDDO
                                END DO
                            !--
                            ELSE
                                DO CTY = 1,CNTY
                                    DO T=1,3
                                        CYX(J,K,T,CTY)=(1+VAL)*CYXB(J,K,T,CTY)

                                    ENDDO
                                END DO
      ENDIF
                        !--
                        ENDIF  !END RX LOOP
                    !--
                        IF(MM=='EN' .AND. J < 8)THEN    !THIS IS IF CHANGING NATIONAL % TILLAGE
                            DO CRDL=1,305
                            !C          REN(J,K,crdl) = VAL
                            ENDDO
      ENDIF
                    !--
                        IF(MM=='EN' .AND. J > 16)THEN   !THIS IS IF CHANGING NATIONAL % ROTATION
                            DO CRDL=1,305
                            !C            RENX(J,K,crdl) = VAL
                            ENDDO
      ENDIF
                    !--
                        1004 CONTINUE
                    !--
                        GOTO 1002
                    !--
                        1003 CONTINUE

                         IUNIT1=FILE_MGR('C',FNAME,NEW)

                        1005 CONTINUE

                    !******************* new code update from UT 2019
                    ! commenting out until input file is set up

    !  OPEN(UNIT=888,FILE='whatif/whatifcty.'//EXT)
   !11 FORMAT(/////////)
   !   READ(888,11,IOSTAT=ios2)
   !   IF(ios2<=-1) GOTO 1010
! 1011 CONTINUE
 !
  !    READ(888,*,IOSTAT=ios2)DREG,REGCTY
!
 !     IF(ios2.le.-1) GOTO 1010
!
 !             REGBIO(REGCTY)=DREG
!
 !     GOTO 1011
 !1010 CONTINUE
!
 !       CLOSE(888)

 !1016   continue
!C--
!C--  **********************************************************************************************


      RETURN
                        END SUBROUTINE RWHATIF







        !     Last change:  CH   26 May 2006   11:41 am
            SUBROUTINE STGAUS
      IMPLICIT NONE

            !EIA add
            INTEGER ::  IDB, NGAUS1, NCROPS, J, NGAUS2, NPRODS
      !      !!! INCLUDE 'psFORLOG'
        !--
        !--   VER. 1.0
        !--
        !--                     *****************
        !-- ******************  STGAUS SUBROUTINE **********************
        !--                     *****************
        !--     ************************
        !--     * CALLED FROM MAIN.FOR *
        !--     ************************
        !--     ***** SET ENDOG VARIABLES TO BASELINE TO START GAUSS *****
        !--
        !--             AUXILLARY WRITE STATEMENTS (UNIT NO., 0 SCREEN, -1 OFF)
        !--

            IDB = INDEX(25)
        !--
        !--

        !--
        !--   *****************************************
        !--   **                                     **
        !--   **        CROPS IGAUS1 VARIABLES       **
        !--   **                                     **
        !--   *****************************************
        !--
            NGAUS1 = INDEX(19)     ! NUMBER OF CROP VARIABLES IN GAUSS ROUTINE
            NCROPS = INDEX(2)      ! NUMBER OF CROPS IN POLYSYS
        !--
            DO K = 1,NCROPS
                DO J = 1,NGAUS1
                !--
                !--             IGAUS1(J) IS A NGAUS1 ELEMENT ARRAY CONTAINING THE
                !--             CODES FOR THE VARIABLES TO BE PASSED TO GAUSS.
                !--                     IGAUS1(1) =  4   EXPORTS
                !--                           (2) =  9   PRICE
                !--                           (3) = 10   DOMESTIC DEMAND 1 (FEED)
                !--                           (4) = 11   DOMESTIC DEMAND 2 (FOOD)
                !--                           (5) = 40   INDUSTRIAL DEMAND (INDU)
                !--

                        C(NPT,I,IGAUS1(J),K) = B(I,IGAUS1(J),K)

                END DO                    ! End of J Loop
            !--
                IF(CFIXED(I,04,K)>0.001)THEN
                    C(NPT,I,04,K) = CFIXED(I,04,K)
      ENDIF
            !--
                IF(CFIXED(I,10,K)>0.001)THEN
                    C(NPT,I,10,K) = CFIXED(I,10,K)
      ENDIF
            !--
                IF(CFIXED(I,11,K)>0.001)THEN
                    C(NPT,I,11,K) = CFIXED(I,11,K)
                END IF
                IF(CFIXED(I,40,K)>0.001)THEN
                    C(NPT,I,40,K) = CFIXED(I,40,K)
      ENDIF
            !--
            !--
            !--             ALSO INITIALIZE TOTAL USE VARIABLE FOR USE IN FLEXGR
            !--


                    C(NPT,I,15,K) = C(NPT,L,15,K)
                    C(NPT,I,16,K) = B(I,16,K)
                    C(NPT,I,36,K) = C(NPT,L,36,K)
                    C(NPT,I,37,K) = C(NPT,L,37,K)
                    C(NPT,I,13,K) = B(I,4,K) + B(I,10,K) + B(I,11,K) + B(I,40,K) &
                    + X(I,02,K)
                    C(NPT,I,17,K) = B(I,14,K)-B(I,15,K)-B(I,16,K)-B(I,36,K) &
                    - B(I,37,K)-B(I,38,K)

            END DO                    ! End of K Loop for Crops
        !--
        !--   *****************************************
        !--   **                                     **
        !--   **       PRODUCTS IGAUS2 VARIABLES     **
        !--   **                                     **
        !--   *****************************************
        !--
            NGAUS2 = INDEX(44)     ! NUMBER OF PRODUCTS VARIABLES IN GAUSS SUBROUTINE
            NPRODS = INDEX(43)     ! NUMBER OF PRODUCTS IN POLYSYS
        !--
            DO K = 1,NPRODS
                DO J = 1,NGAUS2
                !--
                !--             IGAUS1(J) IS A NGAUS1 ELEMENT ARRAY CONTAINING THE
                !--             CODES FOR THE VARIABLES TO BE PASSED TO GAUSS.
                !--                     IGAUS2(1) =  3   EXPORTS
                !--                           (2) =  4   PRICE
                !--                           (3) =  2   DOMESTIC DEMAND 1
                !--
                    PC(NPT,I,IGAUS2(J),K) = PB(I,IGAUS2(J),K)
                !--
                END DO                    ! End of J Loop
            !--
                IF(PCFIXED(I,03,K)>0.001)THEN
                    PC(NPT,I,03,K) = PCFIXED(I,03,K)
      ENDIF
            !--
            !--      ALSO INITIALIZE PRODUCTS TOTAL USE AND TOTAL SUPPLY VARIABLES
            !--       FOR USE IN FLEXGR. TOTAL SUPPLY FOR CROPS IS INITIALIZED
            !--         IN RMAIN SUBROUTINE
            !--
            !--
                PC(NPT,I,06,K) = PB(I,03,K) + PB(I,02,K) + PX(I,01,K)
                PC(NPT,I,05,K) = PB(I,07,K) + PB(I,01,K) + PX(I,02,K)
            !--
            END DO                    ! End of K Loop for PRODUCTS
        !--
        !--
            KSAVE = 1
            RETURN
            END SUBROUTINE STGAUS
        !     Last change:  2021
           SUBROUTINE STKCHK
            IMPLICIT NONE

            REAL :: STOCKMIN(18)
            !EIA add
            INTEGER :: NPRODS, NCROPS, IYEAR1, IDB, IO
        !--                     *****************
        !-- ******************* STKCHK SUBROUTINE *********************
        !--                     *****************
        !--             ***** CROP DEMAND EQUATIONS *****
        !--           ******************************
        !--           * THIS ROUTINE IS CALLED FROM:
        !--           * MAIN
        !-            ******************************
        !--           * SUBROUTINES CALLS:
        !--           * PRODUCTS
        !--           ******************************
            STOCKMIN(1) = 100!275 !300.0   !10
            STOCKMIN(2) = 10 !15.0
            STOCKMIN(3) = 20 !update from UT 2019 ;aug 2020 update; !baseline in 2017 was below 35
            STOCKMIN(4) = 25 !50.0
            STOCKMIN(5) = 150 !280.0
            STOCKMIN(6) = 50 !100.0
            STOCKMIN(7) = 2.0
            STOCKMIN(8) = 10 !18.0
            STOCKMIN(9) = 0
            STOCKMIN(10) =0
            STOCKMIN(11) =0
            STOCKMIN(12) =0
            STOCKMIN(13) =0
            STOCKMIN(14) =0
            STOCKMIN(15) =0
            STOCKMIN(16) =0
            STOCKMIN(17) =0
            STOCKMIN(18) =0
            NCROPS = INDEX(2)      ! NUMBER OF CROPS IN POLYSYS
            NPRODS = INDEX(43)     ! NUMBER OF PRODUCTS IN POLYSYS
            IYEAR1 = INDEX(30)     ! FIRST YEAR OF SIMULATION
        !--             AUXILLARY WRITE STATEMENTS (UNIT NO., 0 SCREEN, -1 OFF)

            IDB = INDEX(25)
            IO = INDEX(21)

        !--   ************************
        !--   CALL PRODUCTS SUBROUTINE
        !     CALL PRODUCTS
        !--   **************************
            DO K = 1,NCROPS
                C(NPT,I,17,K)=C(NPT,I,14,K)-C(NPT,I,15,K)-C(NPT,I,16,K)-C(NPT,I,36,K)-C(NPT,I,37,K)

                2999 CONTINUE
                IF(C(NPT,I,17,K)<STOCKMIN(K))THEN
                !c      WRITE(*,*)'stkchk',C(NPT,I,17,k),C(NPT,I,9,k),i,k

                    C(NPT,I,9,K)=C(NPT,I,9,K)*1.02
                !--            *************                   |14 OWN PRICE
                !--            EXPORT DEMAND
                !--            *************
                !c            C(NPT,I,04,K) = B(I,04,K) * (1.0
                !c     1            + EGC(14,K)*(C(NPT,I,09,K)-B(I,09,K)) / B(I,09,K))
                !c     2            + EGC(15,K) * (C(NPT,I,09,1) - B(I,09,1)) / B(I,09,1)
                    IF(K<=8)THEN
                    !      IF(k==1)then
                    !      WRITE(*,*)b(i,4,k),C(NPT,I,4,k),cfixed(i,4,k),i,k,j,'adfd'
                    !      endif
                        C(NPT,I,04,K) = B(I,04,K) * (1.0 &
                        + EGC(14,K) * &
                        ( (C(NPT,I,09,K)*X(I,36,K)) - (B(I,09,K)*XB(I,36,K)) ) &
                        / (B(I,09,K)*XB(I,36,K)) &
                        + EGC(15,K) * (C(NPT,I,09,1) - B(I,09,1)) / B(I,09,1) &
                        ) + AJC(04,K) * (C(NPT,L,04,K) - B(L,04,K))
                    ELSE
                        C(NPT,I,4,K)=0
                    ENDIF
                    IF(CFIXED(I,4,K) > 0.0)C(NPT,I,4,K) = CFIXED(I,4,K) !added sept 2016

                !--         ***********                     |07 OWN PRICE
                !--         FEED DEMAND                     |08 INDEX LIVES PRICES
                !--         ***********                     |09 SOYBEAN BY PRODUCTS MARGIN
                !--                                         |10 LIVES PROD UNITS
                !--                                         |11 CORN PRICE
                !--             OF COURSE, 11 NOT USED FOR CORN, I.E., EGC(11,K) = 0.0
                    IF(K==6) THEN
                    !C            CRMRB(I) = 1
                    !C            CRMR(I) = CRMRB(I)
                        C(NPT,I,10,K) = B(I,10,K) * ( 1.0 &
                        + EGC(07,K)*(C(NPT,I,09,K)-B(I,09,K)) / B(I,09,K) &
                        + EGC(08,K) * (A(NPT,I,20,3)-AB(I,20,3)) / AB(I,20,3) &
                        + EGC(09,K) * (CRMR(I) - CRMRB(I)) / CRMRB(I) &
                    !     4                + EGC(10,K) * (A(NPT,I,05,2)-AB(I,05,2)) / AB(I,05,2)
                        + EGC(10,K) * (SAU(I,13,2)-SAUB(I,13,2)) / SAUB(I,13,2) &
                        + EGC(11,K) * (C(NPT,I,09,1) - B(I,09,1)) / B(I,09,1) &
                        ) + AJC(10,K) * (C(NPT,L,10,K) - B(L,10,K))
                    ELSEIF(K >= 9) THEN
                        C(NPT,I,10,K) = C(NPT,I,03,K) !b(i,10,k)
                    ELSE
                        C(NPT,I,10,K) = B(I,10,K) * ( 1.0 &
                        + EGC(07,K)*(C(NPT,I,09,K)-B(I,09,K))/B(I,09,K) &
                        + EGC(08,K) * (A(NPT,I,20,3)-AB(I,20,3)) / AB(I,20,3) &
                        + EGC(09,K) * (PC(NPT,I,4,2) - PB(I,4,2)) / PB(I,4,2) &
                    !     4                + EGC(10,K) * (A(NPT,I,05,2)-AB(I,05,2)) / AB(I,05,2)
                        + EGC(10,K) * (SAU(I,13,1)-SAUB(I,13,1)) / SAUB(I,13,1) &
                        + EGC(11,K) * (C(NPT,I,09,1) - B(I,09,1)) / B(I,09,1) &
                        ) + AJC(10,K) * (C(NPT,L,10,K) - B(L,10,K))
                    END IF
         IF(CFIXED(I,10,K)>0.0) C(NPT,I,10,K) = CFIXED(I,10,K) !2021 update
                !--
                    IF(INDEX(51)==1) THEN                    ! IF USING ERS LIVESTOCK MODEL THEN
                        IF(K == 1)C(NPT,I,10,1)=XCR(NPT,I,13)         ! CORN DEMAND FROM ERS LIVESTOCK MODEL EQUATION (GOOD!)
                    !           C(NPT,I,10,2)=XCR(NPT,I,15)                   ! THE REST HERE ARE SIMPLY SAME % CHANGE AS
                    !           C(NPT,I,10,3)=XCR(NPT,I,17)                   ! GCAU'S FROM ERS MODEL
                    !           C(NPT,I,10,4)=XCR(NPT,I,16)                   ! NEED TO FIND OR ESTIMATE NEW EQUATIONS LINKING
                    !--         C(NPT,I,10,5)=XCR(NPT,I,18)                   ! GCAUS'S OR HCAU'S AND OTHER VARIABLES TO FEED DEMAND
                               if (k.eq.6) C(NPT,I,10,6)=XCR(NPT,I,14)  !aug 2020 update
                    END IF
                    IF(K == 1)THEN
                        DRYGSUB=BIOPRD(I,50)/2000*35.65/1000000     !DISTILLERS DRY GRAINS FROM ETHANOL REDUCES CORN FEED DEMAND
                        IF(C(NPT,I,10,1) >= DRYGSUB)THEN               !ONE TON OF DISTILLERS GRAINS SUBSTITUTES FOR 35.65 BUSHELS OF CORN (Delucchi, 1998)
                            C(NPT,I,10,1)=C(NPT,I,10,1)-DRYGSUB              !THIS WILL LOWER PRICE OF CORN, THEREBY EFFECTING LIVESTOCK DEMAND
                        ELSE                                       !ASSUMING DRY GRAINS WILL SELL JUST ALITTLE CHEAPER THAN CORN FOR FEED.
                            C(NPT,I,10,1) = 0.0
      ENDIF
                    ELSEIF(K == 6)THEN
                        CONTINUE
                    ELSE                                           !!!!!!!!!!!!!!
                        C(NPT,I,10,k) = C(NPT,I,10,k)                       !!!!!this was = b(i,10,k) in nri project!!but messed up later years in 25yrversion
                    ENDIF                                          !!!!!!!!!!!!!
                !--         ********************************
                !--         WHEAT, RICE, FOOD DEMAND     |09 OWN PRICE
                !--         ********************************
                !c            IF(K==5.OR.K==8) C(NPT,I,11,K) = B(I,11,K) * (1.0
                !c     1               + EGC(12,K) * (C(NPT,I,09,K) - B(I,09,K))/B(I,09,K))
                    IF(K==5 .OR. K==8)C(NPT,I,11,K) = B(I,11,K) * (1.0 &
                    + EGC(12,K)*(C(NPT,I,09,K)-B(I,09,K))/B(I,09,K) &
                    ) + AJC(11,K) * (C(NPT,L,11,K) - B(L,11,K))
                !--         **********************
                !--         CORN INDUSTRIAL DEMAND     |09 OWN PRICE
                !--         **********************
                !c            IF(K==1)C(NPT,I,40,K) = B(I,40,K) * (1.0
                !c     1                     + EGC(13,K)*(C(NPT,I,09,K)-B(I,09,K))/B(I,09,K))
                    IF(K == 1)THEN
                        C(NPT,I,40,K) = B(I,40,K) * (1.0 &
                        + EGC(13,K)*(C(NPT,I,09,K)-B(I,09,K))/B(I,09,K) &
                        ) + AJC(09,K) * (C(NPT,L,40,K) - B(L,40,K))
                    ENDIF
                !--
                    IF(K == 1)CALL ETHTRADE
                    IF(K == 6)CALL BIODIESTRADE


                !--         *********                      |10   FEED DEMAND
                !--         TOTAL USE                      |11   FOOD DEMAND (WHEAT AND RICE ONLY)
                !--         *********                      |04   EXPORTS
                !--                                        |02   OTHER DEMAND
                    IF(K == 1)THEN
                        C(NPT,I,13,K) = C(NPT,I,10,K)+C(NPT,I,11,K)+C(NPT,I,04,K)+X(I,02,K)
                    ELSE
                        C(NPT,I,13,K) = C(NPT,I,10,K)+C(NPT,I,11,K)+C(NPT,I,04,K)+C(NPT,I,40,K)+X(I,02,K)
                    ENDIF
                !--         ***************************    |07   SUPPLY
                !--         TOTAL ENDING YEAR INVENTORY    |13   TOTAL USE
                !--         ***************************
                    C(NPT,I,14,K) = C(NPT,I,07,K) - C(NPT,I,13,K)
                !--         ********************************  |14  TOTAL ENDING STOCK
                !--         COMMERICAL ENDING YEAR INVENTORY  |15  F-O-R ENDING STOCK
                !--         ********************************  |16  CCC ENDING STOCK
                    C(NPT,I,17,K)=C(NPT,I,14,K)-C(NPT,I,15,K)-C(NPT,I,16,K)-C(NPT,I,36,K)-C(NPT,I,37,K) &
                    - C(NPT,I,38,K)
                !--         ******************
                !--         STOCK TO USE RATIO
                !--         ******************
                    IF(C(NPT,I,13,K)==0.0)THEN
                        C(NPT,I,12,K) = 0.0
                    ELSE
                        C(NPT,I,12,K) = C(NPT,I,17,K)/C(NPT,I,13,K)
      ENDIF
                    3000 CONTINUE
                END IF
                IF(C(NPT,I,17,K)<STOCKMIN(K)) GOTO 2999
            !C      IF(K==2.AND.C(I,9,2)>C(I,9,1))C(NPT,I,9,2) = 0.95*C(NPT,I,9,1)  !!MAKES SURE SORGHUM LESS THAN CORN PRICE
      !2021 update
      IF(K==2.AND.(C(NPT,I,9,2)-C(NPT,I,9,1)).GE.-0.05)C(NPT,I,9,2)=C(NPT,I,9,1)-0.05
            !--
            !--
            !!!!!!!!!!!!!chad added this march 2017 to see if solves better!!!!!!!!!!!!!!!!!!
            !--    ***IMPORTANT**THIS IS 2ND FIGURING OF C(13)**OTHER ABOVE**
                IF(K == 1)THEN
                    C(NPT,I,13,K) = C(NPT,I,10,K)+C(NPT,I,11,K)+C(NPT,I,04,K)+X(I,02,K)
                ELSE
                    C(NPT,I,13,K) = C(NPT,I,10,K)+C(NPT,I,11,K)+C(NPT,I,04,K)+C(NPT,I,40,K)+X(I,02,K)  !DONT TAKE DIFFERENCE!!!!
                ENDIF
            !--
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            !--
            !--
      END DO
      RETURN
            END SUBROUTINE STKCHK
        !     Last change: 2021
        SUBROUTINE SUMBIO
        IMPLICIT NONE

    !--
    !--      SUM CORN GRAIN AND WOODY BIOMASS
        DO K=1,7
            FDSTK(I,4,8)=FDSTK(I,4,8) + FDSTK(I,4,K) !(BU)    !GET TOTAL CORN GRAIN FOR BIOPRODUCTS FOR REPORTING BELOW
            FDSTK(I,6,8)=FDSTK(I,6,8) + FDSTK(I,6,K) !(TONS)  !WOOD FOR REPORTING BELOW
            FDSTK(I,11,8)=FDSTK(I,11,8)+FDSTK(I,11,K)/1000000 !(TONS) !CRP BIOMASS FOR REPORTING IN RESULTS
        ENDDO
    !--
    !--      SUM TOTAL BIOMASS SUPPLY
        IF(INDEX(74) == 0)FDSTK(I,6,8)=FDSTK(I,6,8)/1000000
        if (npt.eq.3) then !sum for report writer
          BIOSPLY(I,7)= (FDSTK(I,11,8)+FDSTK(I,6,8)+EN(NPT,I,1,1)+EN(NPT,I,1,5)       & !FKSTK(CRP)+FDSTK(8WOODY)+EN(1CORNRES)+EN(5WHEATRES)
          + C(NPT,I,3,9)+C(NPT,I,3,10)+C(NPT,I,3,11)+C(NPT,I,3,15) &
          + C(NPT,I,3,16)+ C(NPT,I,3,17))
    !-- 2021 update
           BIOSPLY(I,8) = (CRN(I,3,15,1)+CRN(I,3,18,1))/5.63/1000   !PENNYCRESS  !MIL LBS TO BIL OF GAL   !JET FUEL SUPPLY THERE IS 5.63 LBS OF PENNYCRESS IN ONE GALLON OF JET FUEL  
           BIOSPLY(I,9) = (CRN(I,3,15,2)+CRN(I,3,18,2))/5.63/1000   !CAMELINA
           BIOSPLY(I,10)= (CRN(I,3,15,3)+CRN(I,3,18,3))/5.63/1000  !CARINATA
    !--
	    endif
        RETURN
        END SUBROUTINE SUMBIO


    !     Last change:  CH   11 Jul 2006   12:08 pm
        SUBROUTINE SUPPLY2
      IMPLICIT NONE

        REAL :: HOLDPR(18),HBASPR(18)
        REAL :: EL1(18),EL2(18),EL3(18),EL4(18),EL5(18),EL6(18),EL7(18), &
        EL8(18),EG1(18),EG2(18),EG3(18),EG4(18),EG5(18),AJ1(18), &
        AJ2(18),AJ5(18)
        !EIA add
        REAL :: AJ, TEMP
        INTEGER :: J, IDB, IYEAR1, NCROPS
    !--
    !--
    !--                     *****************
    !-- ******************  SUPPLY SUBROUTINE  ********************
    !--                     *****************
    !--
    !--     **********
    !--     * THIS SUBROUTINE IS CALLED FROM
    !--     * MAIN.FOR
    !--     **********
    !--
    !--
    !--     ***** ACREAGE, YIELD, PRODUCTION AND SUPPLY EQUATIONS *****
    !--
    !--                *** FOR EACH POLYSYS CROP ***
    !--
    !--
    !--
        NCROPS = INDEX(2)

    !--
    !--             CHANGE BASE COTTON YIELD FROM LBS TO BALES
    !--               FOR COMPUTING PRODUCTION
    !--
    !--             AUXILLARY WRITE UNITS
    !--
    !--             FIRST YEAR OF SIMULATION
    !--
        IYEAR1 = INDEX(30)
    !--
    !--             DIRECT AND CROSS ACREAGE ELASTICITIES FOR MODEL CROPS
    !--                         [EAC(7,7)]
    !--
    !-- -------------------------------------------------------------------
    !-- AC     PR-> CORN    G.S.  OATS  BARL WHEAT  SOYB  COTN    RICE
    !-- -------------------------------------------------------------------
    !--             CORN
    !      DATA EL1/  0.15, -0.03, -0.0, -0.0, -0.0, -0.09, -0.01, -0.0,
    !     1           0.00,  0.00, 0.00, 0.00,0.00/
    !--             GRAIN SORGHUM
    !      DATA EL2/ -0.15,  0.27, -0.0, -0.0,-0.04,  -0.0, -0.04, -0.0,
    !     1           0.00,  0.00, 0.00, 0.00,0.00/
    !--             OATS
    !      DATA EL3/ -0.25,  -0.0, 1.05,-0.31, -0.0, -0.21, -0.00, -0.0,
    !     1           0.00,  0.00, 0.00, 0.00,0.00/
    !--             BARLEY
    !      DATA EL4/ -0.0,   -0.0,-0.32, 0.53,-0.33,  -0.0, -0.00, -0.0,
    !     1           0.00,  0.00, 0.00, 0.00,0.00/
    !--             WHEAT
    !      DATA EL5/ -0.0,  -0.06,-0.00,-0.08, 0.24,  -0.0, -0.00, -0.0,
    !     1           0.00,  0.00, 0.00, 0.00,0.00/
    !--             SOYBEANS
    !      DATA EL6/ -0.15,  -0.0, -0.0, -0.0, -0.0,  0.31, -0.05, -0.0,
    !     1           0.00,  0.00, 0.00, 0.00,0.00/
    !--             COTTON
    !      DATA EL7/ -0.0,  -0.28, -0.0, -0.0, -0.0, -0.14,  0.30, -0.0,
    !     1           0.00,  0.00, 0.00, 0.00,0.00/
    !--             RICE
    !      DATA EL8/ -0.0,  -0.00, -0.0, -0.0, -0.0, -0.00,  0.00,  0.3,
    !     1           0.00,  0.00, 0.00, 0.00,0.00/
    !--
    !-- -------------------------------------------------------------------
    !-- AC     PR-> CORN    G.S.  OATS  BARL WHEAT  SOYB  COTN    RICE
    !-- -------------------------------------------------------------------
    !--             CORN
        DATA EL1 /  0.35, -0.03, -0.00, -0.00, -0.00, -0.09, -0.01, -0.00, &
        &             0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00, &
        &             0.00,  0.00 /
    !--             GRAIN SORGHUM
        DATA EL2 / -0.15,  0.35, -0.00, -0.00, -0.04, -0.00, -0.04, -0.00, &
        &             0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00, &
        &             0.00,  0.00 /
    !--             OATS
        DATA EL3 / -0.25, -0.00,  1.05, -0.31, -0.00, -0.21, -0.00, -0.00, &
        &             0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00, &
        &             0.00,  0.00 /
    !--             BARLEY
        DATA EL4 / -0.00, -0.00, -0.32,  0.53, -0.33, -0.00, -0.00, -0.00, &
        &             0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00, &
        &             0.00,  0.00 /
    !--             WHEAT
        DATA EL5 / -0.00, -0.06, -0.00, -0.08,  0.25, -0.00, -0.00, -0.00, &
        &             0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00, &
        &             0.00,  0.00 /
    !--             SOYBEANS
        DATA EL6 / -0.15, -0.00, -0.00, -0.00, -0.00,  0.40, -0.05, -0.00, &
        &             0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00, &
        &             0.00,  0.00 /
    !--             COTTON
        DATA EL7 / -0.00, -0.28, -0.00, -0.00, -0.00, -0.14,  0.40, -0.00, &
        &             0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00, &
        &             0.00,  0.00 /
    !--             RICE
        DATA EL8 / -0.00, -0.00, -0.00, -0.00, -0.00, -0.00,  0.00,  0.45, &
        &             0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00, &
        &             0.00,  0.00 /
    !--
    !-- ------------------------------------------------------------------
    !--             CORN    G.S.  OATS  BARL  WHEAT  SOYB   COTN  RICE
    !-- ------------------------------------------------------------------
    !--             ACREAGE WRT PRICES PAID [EGC(1,K)]
        DATA EG1 / -0.00, -0.00, -0.00, -0.00, -0.00, -0.00, -0.00, -0.00, &
        &             0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00, &
        &             0.00,  0.00 /
    !--             YIELD WRT OWN-PRICE [EGC(2,K)]
        DATA EG2 /  0.01,  0.01,  0.01,  0.01,  0.01,  0.01,  0.01,  0.01, &
        &             0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00, &
        &             0.00,  0.00 /
    !--             YIELD WRT PRICES PAID [EGC(3,K)]
        DATA EG3 / -0.00, -0.00, -0.00, -0.00, -0.00, -0.00, -0.00,  0.00, &
        &             0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00, &
        &             0.00,  0.00 /
    !--             VARIABLE EXP/AC WRT OWN-PRICE [EGC(4,K)]
        DATA EG4 /  0.01,  0.01,  0.01,  0.01,  0.01,  0.02,  0.03,  0.01, &
        &             0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00, &
        &             0.00,  0.00 /
    !--             VARIABLE EXP/AC WRT PRICES PAID [EGC(5,K)]
        DATA EG5 / -0.00, -0.00, -0.00, -0.00, -0.00, -0.00, -0.00,  0.00, &
        &             0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00, &
        &             0.00,  0.00 /
    !--
    !--             ADJUSTMENT COEFFICIENTS FOR MODEL CROP EQUATIONS
    !--                     (WILL BE CONVERTED TO 1 - ADJ LATER)
    !--             (A ONE IN THIS TABLE MEANS LR = SR; .10 MEANS LR
    !--             MUCH LARGER THAN SR; I.E.THESE ARE COEF ON LAGGED DEP)
    !-- ------------------------------------------------------------------
    !--             CORN    G.S.  OATS  BARL  WHEAT  SOYB   COTN  RICE
    !-- ------------------------------------------------------------------
    !--             ACREAGE EQNS (THESE WILL CORRESPOND
    !--             TO ORDER VARIABLES IN C MATRIX)
        DATA AJ1 /  0.50,  1.00,  1.00,  1.00,  0.50,  0.50,  1.00,  1.00, &
        &             1.00,  1.00,  1.00,  1.00,  1.00,  1.00,  1.00,  1.00, &
        &             1.00,  1.00 /
    !--             YIELD EGNS
        DATA AJ2 /  1.00,  1.00,  1.00,  1.00,  1.00,  1.00,  1.00,  1.00, &
        &             1.00,  1.00,  1.00,  1.00,  1.00,  1.00,  1.00,  1.00, &
        &             1.00,  1.00 /
    !--             VARIABLE COSTS PER ACRE
        DATA AJ5 /  1.00,  1.00,  1.00,  1.00,  1.00,  1.00,  1.00,  1.00, &
        &             1.00,  1.00,  1.00,  1.00,  1.00,  1.00,  1.00,  1.00, &
        &             1.00,  1.00 /
    !-- -----------------------------------------------------------------
    !--
        DO K = 1,NCROPS
        !--
        !--             EAC(NCROPS,NCROPS) OF OWN AND CROSS ACREAGE SUPPLY
        !--                     ELASTICITIES
        !--
        !--             CORN ACREAGE WRT PRICES IN USUAL CROP ORDER
            EAC(01,K) = EL1(K)
        !--             G.S. AC
            EAC(02,K) = EL2(K)
        !--             OAT AC
            EAC(03,K) = EL3(K)
        !--             BARLEY AC
            EAC(04,K) = EL4(K)
        !--             WHEAT AC
            EAC(05,K) = EL5(K)
        !--             SOYBEAN AC
            EAC(06,K) = EL6(K)
        !--             COTTON AC
            EAC(07,K) = EL7(K)
        !--
        !--             EGC(J,NCROPS) OF GENERAL CROP ELASTICITIES
        !--
        !--             ACREAGE WRT PRICE PD IN USUAL CROP ORDER
        !--                     (EGC(01,1) IS FOR CORN ...
            EGC(01,K) = EG1(K)
        !--             YIELD WRT TO OWN-PRICE
            EGC(02,K) = EG2(K)
        !--             YIELD WRT TO PRICES PD
            EGC(03,K) = EG3(K)
        !--             VARIABLE EXP/AC WRT OWN-PRICE
            EGC(04,K) = EG4(K)
        !--             VARIABLE EXP/AC WRT PRICE PD
            EGC(05,K) = EG5(K)
        !--
        !--             ADJUSTMENT COEFFICENTS CONVERTED TO 1 - ADJ
        !--             AJC(J,NCROPS) WHERE J DEFINED SAME AS IN C
        !--
        !--             CROPS IN USUAL ORDER
        !--             ACREAGE EQNS (1-ADJ) AJC(1,1) FOR CORN ....
            AJC(01,K) = 1.0 - AJ1(K)
        !--             YIELD EQNS
            AJC(02,K) = 1.0 - AJ2(K)
        !--             VARIABLE EXP PER ACRE
            AJC(05,K) = 1.0 - AJ5(K)
        END DO
    !--
    !--             AUXILLARY WRITE STATEMENTS (UNIT NO., 0 SCREEN, -1 OFF)
    !--

        IDB = INDEX(25)
    !--

    !--
        3 FORMAT(' ','*** BASELINE ***')
        4 FORMAT(' ','*** SIMULATED ***')
        5 FORMAT(' ',T3,'CROP',T8,'RESP',T13,'HAR AC' &
        ,T20,'YLD',T25,'PRODUCTION ',T36,'CARRY IN',T46,'IMP' &
        ,T51,'SUPPLY',T59,'COM BEG',T68,'EFCTV SUP')
        6 FORMAT(' ',T4,I2,T6,F6.2,F6.1,F6.1,F9.1,F10.1,F6.1,F8.1,F8.1 &
        ,F10.1)
    !--
        14 FORMAT(' ','*** BASELINE ****',/,T3,'CROP',T14,'FEED' &
        ,T24,'FOOD',T31,'EXPORTS',T39,'TOTAL USE',T53,'PRICE' &
        ,T61,'TOT END',T71,'COM END')
        16 FORMAT(' ',T4,I2,T7,4F10.1,F10.2,2F10.1)
    !--
        IF(IDB >= 0)THEN
            WRITE(IDB,3)
            WRITE(IDB,5)
            DO K = 1,NCROPS
                WRITE(IDB,6)K,B(L,09,K),B(I,01,K),B(I,02,K),B(I,03,K) &
                ,B(L,14,K),XB(I,01,K),B(I,07,K),B(L,17,K),B(I,08,K)
            END DO
      ENDIF
    !--
        IF(ARPTEST(I) > 0) THEN
            DO K = 1,NCROPS
                IF(ARP(I,K) > XB(I,26,K)) X(I,26,K) = ARP(I,K)
            END DO
        END IF
    !--
    !--     NOTE: IF COTTON YIELD NEEDS TO BE IN TERMS OF BALES
    !--     ++++  FOR USE IN A SUBROUTINE, IT WILL BE CONVERTED IN
    !--           THAT SUBROUTINE AND THEN CONVERTED BACK BEFORE
    !--           RETURNING. THIS IS INEFFICIENT, ESPECIALLY SINCE
    !--           THIS SUBROUTINE USES LAGGED YIELDS WHICH MUST BE
    !--           RECONVERTED ALL OVER AGAIN.  HOWEVER, IT WILL HELP
    !--           KEEP US OUT OF TROUBLE!
    !--
    !--             I INDEXES THE OBSERVATION BEING SIMULATED
    !--
    !--             ALSO NEED TO CONVERT THE PREVOUS YEAR YIELDS
    !--             SINCE THESE ARE USED IN THE LAST LINE OF THE
    !--             YIELD EQUATION.
    !--             L = I - 1
    !--
        B(I,02,7) = B(I,02,7) / 480.0
        B(L,02,7) = B(L,02,7) / 480.0
        C(NPT,L,02,7) = C(NPT,L,02,7) / 480.0
        B(I,02,8) = B(I,02,8) / 100.0
        B(L,02,8) = B(L,02,8) / 100.0
        C(NPT,L,02,8) = C(NPT,L,02,8) / 100.0
    !--
        CFIXED(I,02,7) = CFIXED(I,02,7) / 480.0
        CFIXED(I,02,8) = CFIXED(I,02,8) / 100.0
    !--             LOOP ACROSS CROPS
        DO K = 1,NCROPS
        !--
        !--             STORE PREVIOUS YEAR PRICES FOR ALL K CROPS
        !--               IN HOLDING ARRAY.
        !--
            HOLDPR(K) = C(NPT,L,09,K)
            HBASPR(K) = B(L,09,K)
        !--
        !--             IF CURRENT YEAR LOAN RATE FOR CROP K IS GREATER THAN
        !--               IT'S PREVIOUS YEAR PRICE, USE LOAN RATE AS SUPPLY
        !--               RESPONSE PRICE.  SIMILARLY FOR BASE (LOAN RATE WAS
        !--               WAS THE RESPONSE PRICE IN BASE IF BASE LOAN RATE
        !--               EXCEEDS PREVIOUS YEAR PRICE)  HOWEVER, IF USE BASE
        !--               LOAN RATE WHEN SIMULATING 'A NO LOAN RATE' PROGRAM
        !--               WILL GIVE ERRONEOUS RESULTS, SO ALSO CHECK TO SEE
        !--               CURRENT LOAN RATE HAS NOT BEEN ZEROED OUT (COULD
        !--               ZERO OUT XB AND X LOAN RATES).
        !--
            IF(X(I,11,K) > C(NPT,L,09,K)) C(NPT,L,09,K) = X(I,11,K)
            IF(XB(I,11,K) > B(L,09,K) .AND. X(I,11,K) /= 0.0) &
            B(L,09,K) = XB(I,11,K)
        END DO
    !--
    !--
    !--             LOOP ACROSS CROPS
        A(NPT,I,25,2) = 0.0
        A(NPT,I,29,2) = 0.0
        XA(I,02,2) = 0.0
        DO K = 1, NCROPS
            IF(K<=8 .OR. K==12) THEN
            !--
            !--             IF ACREAGE PREDETERMINED, SET VALUE AND SKIP
            !--
            !--             - CFIXED(I,J,K) IS NYRSIM+2 X 5 X NCROPS MATRIX OF
            !--               PREDETERMINED ENDOGENOUS CROP VALUES.
            !--               MAY PREDETERMINE A VALUE FOR ANY OF THE YEARS
            !--               SIMULATED FOR ANY OF THE FIRST 5 VARIABLES IN
            !--               C (ENDOGENOUS CROP VARIABLES) FOR ANY OF THE
            !--               CROPS.  J IS IN USUAL VARIABLE ORDER FROM C
            !--               MATRIX.  K IS IN USUAL CROP ORDER.
            !--               VALUES ARE ZERO IF NOT PREDETERMINED.
            !--
                IF(CFIXED(I,01,K) > 001) C(NPT,I,01,K) = CFIXED(I,01,K)

                IF(CFIXED(I,01,K) > 001)GO TO 120
                TEMP = 0.0
                DO J = 1, NCROPS
                    IF(J<=8 .OR. J==12) THEN
                    !--     *****************
                    !--     ACREAGE EQUATIONS
                    !--     *****************
                    !--
                    !--             COMPUTE THE EFFECT ON ACREAGE DUE TO CHANGES IN
                    !--               RESPONSE PRICES FOR EACH OF THE CROPS.
                    !--             THAT IS, COMPUTE THE SUM OF PRODUCTS OF ACREAGE
                    !--               ELASTICITIES AND % CHANGE IN CROP PRICES FOR
                    !--               EACH THE NCROPS CROPS.
                    !--
                    !--             - EAC(K,J) IS A NCROPS X NCROPS MATRIX OF ACREAGE
                    !--               ELASTICITIES -- ELASTICITY OF CROP K ACREAGE WITH
                    !--               RESPECT TO CROP J RESPONSE PRICE.
                    !--


                            TEMP=TEMP+EAC(K,J)*(C(NPT,L,9,J)-B(L,9,J))/B(L,9,J)

                    !c                  IF(K.GT.8)TEMP = 0.0
                    END IF
                END DO
            !--
            !--             - EGC(K,J) IS A NEGC X NCROPS MATRIX OF ELASTICITIES
            !--               FOR CROPS.  EACH ROW IS A PARTICULAR ELASTICITY
            !--               TYPE.  J IS IN USUAL CROP ORDER.  EGC(1,1) IS THE
            !--               ELASTICITY OF CORN ACREAGE WITH RESPECT TO THE PRICES
            !--               PAID INDEX.  EGC(1,2) IS THE SAME ELASTICITY BUT FOR
            !--               GRAIN SORGHUM.
            !--
            !--             - AJC(K,J) IS A 11 X NCROPS MATRIX OF ONE MINUS
            !--               ADJUSTMENT COEFFICENTS.  ROW FOR EACH OF
            !--               THE FIRST 11 ENDOGENOUS CROP VARIABLES AS LISTED
            !--               IN THE C MATRIX.   (EVEN THOSE THAT ARE COMPUTED
            !--               FROM IDENTITIES OR DO NOT HAVE A DISTRIBUTED LAG).
            !--               J IS IN USUAL CROP ORDER.  AJC(1,1) IS 1.0 -
            !--               ADJUSTMENT COEFFICIENT FOR THE CORN ACREAGE
            !--               EQUATION.
            !--
            !--



                    C(NPT,I,01,K) = B(I,01,K) * (1.0 + TEMP &
                    + EGC(01,K) * (A(NPT,L,23,3) - AB(L,23,3)) / AB(L,23,3)) &
                    + AJC(1,K) * (C(NPT,L,01,K) -  B(L,01,K))



            !--
            !--             ADJUST BASELINE ACREAGE SO WHEN IT IS USED NEXT YEAR AS
            !--             A LAGGED VALUE, IT WILL REFLECT ONLY MARKET CHANGES
            !--             NOT DISTRIBUTED RESPONSE TO A CHANGE IN DIVERTED AC.
            !--

                    B(I,01,K) = B(I,01,K) - AJ

            !--
            !--             COMPUTE TOTAL OF SEVEN CROP ACREAGES
            !--
                120 CONTINUE
                A(NPT,I,29,2) = A(NPT,I,29,2) + C(NPT,I,01,K)
            !--
            !--    COMPUTE TOTAL UNPAID AND PAID DIVERSION AND 0/92 OR 50/92
            !--
                XA(I,02,2)= XA(I,02,2) + X(I,03,K) + X(I,04,K) + X(I,24,K)
            !--
            !--     ***************
            !--     YIELD EQUATIONS
            !--     ***************
            !--
            !      IF(CFIXED(I,02,K).GT.001)B(I,02,K) = CFIXED(I,02,K)
                C(NPT,I,02,K) = B(I,02,K)  ! * (1.0
            !     1 + EGC(02,K) * (C(NPT,L,09,K) - B(L,09,K)) / B(L,09,K)
            !     2 + EGC(03,K) * (A(NPT,L,23,3) - AB(L,23,3)) / AB(L,23,3)
            !     3 ) + AJC(02,K) * (C(NPT,L,02,K) - B(L,02,K))
            !      IF(K>8.AND.I>INDEX(27)) C(NPT,I,02,K) = B(I-1,02,K)
            !--
            !--             IF PREDETERMINED, SET VALUE
            !--             THIS APPROACH IS NOT VERY ELEGANT BUT MINIMIZES
            !--             STATEMENTS AND, SINCE IN MOST CASES PREDETERMINED
            !--             VALUES ARE NOT USED ANYWAY, UNNECESSARY COMPUTATIONS
            !--             ARE NOT VERY FREQUENT.
            !--
                IF(CFIXED(I,02,K) > 001)C(NPT,I,02,K) = CFIXED(I,02,K)
            !--
            !--     *********************
            !--     PRODUCTION IDENTITIES
            !--     *********************
            !--
                C(NPT,I,03,K) = C(NPT,I,01,K) * C(NPT,I,02,K)
            !--
            !--             IF PREDETERMINDED, SET VALUE
            !--
                IF(CFIXED(I,03,K) > 001) C(NPT,I,03,K) = CFIXED(I,03,K)
            !--
            !       END IF
            !--   ***********************************************************************
            !--    THE ABOVE END IF SETS THE END OF THE DECISION BRANCH ON WHETER TO
            !--    USE REGIONAL SUPPLY OR NATIONAL SUPPLY STATEMENTS TO CALCULATE ACRES,YIELD,AND PRODUCTION.
            !--   ************************************************************************
            !--
            !--     ***************
            !--     BEGINNING STOCK
            !--     ***************
            !--
            !--              DEFINED AS PREVIOUS YEAR ENDING STOCK
            !--
                C(NPT,I,25,K) = C(NPT,L,14,K)
            !--
            !--     ***********************
            !--     TOTAL SUPPLY IDENTITIES
            !--     ***********************
            !--
                C(NPT,I,07,K) = C(NPT,I,25,K) + C(NPT,I,03,K) + X(I,01,K)
            !--
            !--     ***************************
            !--     EFFECTIVE SUPPLY IDENTITIES
            !--     ***************************
            !--
            !--             DEFINED AS THE SUPPLY MINUS GOVERNMENT STOCKS
            !--             THAT ARE ISOLATED FROM THE MARKET.
            !--****************CURRENT YEAR
            !--             BASELINE VALUES ARE USED AS AN ESTIMATE OF ENDING
            !--             YEAR F-O-R AND CCC STOCK VALUES.
            !--
            !      C(NPT,I,08,K) = B(I,08,K) + (C(NPT,I,07,K) - B(I,07,K))
            !     1           + (B(I,15,K) - C(NPT,I,15,K)) + (B(I,16,K) - C(NPT,I,16,K))
            !     1           + (B(L,15,K) - C(NPT,L,15,K)) + (B(L,16,K) - C(NPT,L,16,K))
            !      C(NPT,I,08,K) = C(NPT,I,03,K)+X(I,01,K)+C(L,14,K)-C(NPT,I,15,K)-C(NPT,I,16,K)
                C(NPT,I,08,K) = C(NPT,I,07,K)-C(NPT,L,15,K)-C(NPT,L,16,K)


            END IF                                                               !!!
        END DO
    !--             CONVERT COTTON AND RICE YIELD BACK TO LBS / ACRE
        C(NPT,I,02,07) = C(NPT,I,02,07) * 480.0
        C(NPT,L,02,07) = C(NPT,L,02,07) * 480.0
        B(I,02,07) = B(I,02,07) * 480.0
        B(L,02,07) = B(L,02,07) * 480.0
        CFIXED(I,02,07) = CFIXED(I,02,07) * 480.0
        C(NPT,I,02,08) = C(NPT,I,02,08) * 100.0
        C(NPT,L,02,08) = C(NPT,L,02,08) * 100.0
        B(I,02,08) = B(I,02,08) * 100.0
        B(L,02,08) = B(L,02,08) * 100.0
        CFIXED(I,02,08) = CFIXED(I,02,08) * 100.0
        IF(IDB >= 0)THEN
            WRITE(IDB,4)
            WRITE(IDB,5)
            DO 18 K = 1,NCROPS
                WRITE(IDB,6)K,C(NPT,L,09,K),C(NPT,I,01,K),C(NPT,I,02,K),C(NPT,I,03,K) &
                ,C(NPT,L,14,K),X(I,01,K),C(NPT,I,07,K),C(NPT,L,17,K),C(NPT,I,08,K)
            18 END DO
            WRITE(IDB,14)
            DO 28 K = 1,NCROPS
                WRITE(IDB,16)K,B(I,10,K),B(I,11,K),B(I,04,K),B(I,13,K) &
                ,B(I,09,K),B(I,14,K),B(I,17,K)
            28 END DO
      ENDIF
    !--             PUT PREVIOUS YEAR PRICE BACK INTO C
        DO K = 1,NCROPS
            C(NPT,L,09,K) = HOLDPR(K)
            B(L,09,K) = HBASPR(K)
        END DO
    !--
        A(NPT,I,25,2)=0.0
        DO K = 1,NCROPS

                C(NPT,I,34,K) = (B(I,34,K)/B(I,01,K))*C(NPT,I,01,K)

            IF(k<=8 .OR. k == 12)then
                A(NPT,I,25,2) = A(NPT,I,25,2) + C(NPT,I,34,K)

      ELSE
                CONTINUE
      ENDIF
        END DO
    !--     ********************            |09 CORN PRICE, SOYBEAN PRICE
    !--     INDEX OF FEED PRICES            |03 CORN & SOYBEAN PRODUCTION
    !--     ********************            |13 GNP DEFLATOR -->1982=100
    !--   <<<<<>>>>> UNTIL CAN GET INDEX IN LOOP
        A(NPT,L,26,3) = AB(L,26,3)
        A(NPT,I,24,3) = 7.2734166+13.920039*C(NPT,L,09,01)+7.0946739*C(NPT,L,09,06) &
        - 0.0030873*((C(NPT,I,03,01)+C(NPT,I,03,06))-(C(NPT,L,03,01) &
        + C(NPT,L,03,06)))+0.3318033*A(NPT,L,26,3)
    !--

    !--
      RETURN
        END SUBROUTINE SUPPLY2


    !     Last change:  2021
      SUBROUTINE WHATIF
      IMPLICIT NONE

        REAL :: VAL
        CHARACTER(3) :: MM
        CHARACTER TG
        INTEGER :: YR
        CHARACTER(70) :: TXT

        !EIA add
         INTEGER :: IDB,NYRSIM,IEND,NCROPS,NVARX,NLVSK
        INTEGER :: NVARXS,NPGXA,NVARXA,NPRODS,NVARPX
        INTEGER :: J,IYEAR1,TL,IOS,KK
        INTEGER FILE_MGR
        EXTERNAL FILE_MGR
        CHARACTER*25 FNAME
        LOGICAL NEW
        INTEGER IUNIT1,FILEUNIT

        !BRENT_DIFF STARTS in POLY BASE YR, cureently 2021
        ! these valuse are obtained by taking the difference in brent price between reference case and high and low case runs
        real brent_diff(2021:2050,3)
        DATA BRENT_DIFF( :,1) /1.0,	0.480261,0.466829,0.516015,0.526089,0.530332,0.530248,0.526257,0.525759,0.525251,0.525504,0.533116,0.536617,0.534191,0.539056,0.541164,0.540373,0.535297,0.531971,0.51315,0.507327,0.505824,0.4984,0.492868,0.491266,0.489255,0.487119,0.487374,0.487422,0.495959 / !low
        DATA BRENT_DIFF( :,2) /30*0.0 / !ref
        DATA BRENT_DIFF(:,3) /1.0,1.760279,1.965498,1.979879,1.977292,1.999767,2.000864,2.001184,1.98983,1.953824,1.942681,1.915007,1.896804,1.876158,1.898913,1.895293,1.897886,1.884112,1.886936,1.876768,1.86118,1.89371,1.890663,1.870585,1.867712,1.864073,1.87964,1.865455,1.867578,1.892984/ !high
        
    !--
    !--
    !--                     *****************
    !-- ******************* WHATIF SUBROUTINE *********************
    !--                     *****************
    !--
    !--  ***** USER PROVIDED INFORMATION FOR THIS SIMULATION *****
    !--             FIRST YEAR OF SIMULATION
    !--
    !--             AUXILLARY WRITE STATEMENTS (UNIT NO., 0 SCREEN, -1 OFF)
    !--

        IDB  = INDEX(25)
        ! set cost increase variable ENGY based on oil price case
      !  ENGY=BRENT_DIFF(POLYCURIYR,WWOP)
      
    !--
    !--

    !--
        NYRSIM = INDEX(1)
        IEND = NYRSIM+(INDEX(30) - INDEX(27)) + 2
        ISTART=(INDEX(30) - INDEX(27))+3
    !--
    !--             NUMBER OF CROPS IN POLYSYS
    !--
        NCROPS = INDEX(2)
    !--
    !--             NUMBER OF CROP EXOGENOUS VARIABLES
    !--
        NVARX = INDEX(4)

    !--
    !--             NUMBER OF MODEL LIVESTOCK COMMODITIES IN POLYSYS
    !--
        NLVSK = INDEX(5)
    !--
    !--             NUMBER OF VARIABLES IN XS (2ND SUBSCRIPT)
    !--
        NVARXS = INDEX(7)

    !--
    !--             NUMBER OF PAGES IN XA (3RD SUBSCRIPT)
    !--
        NPGXA = INDEX(8)
    !--
    !--             NUMBER OF VARIABLES IN XA (2ND SUBSCRIPT)
    !--
        NVARXA = INDEX(14)
    !--
    !--             NUMBER OF PRODUCT IN POLYSYS
    !--
        NPRODS = INDEX(43)
    !--
    !--             NUMBER OF EXOGENOUS PRODUCT VARIABLES IN PX (2ND SUBSCRIPT)
    !--
        NVARPX = INDEX(46)
    !--
    !--             CAN RESET SETUP DEBUG STATEMENTS FOR CALUCATION
    !--             PORTION OF SIMULATOR HERE
    !--
    !--             AT THIS POINT ASK IF WANT TO PRINT-OUT OF BASELINE INFO
    !--             IF ANSWER IS NO (IPRTBS = 0) GO AROUND
    !--
    !--             SET ALL X VALUES TO THEIR ORIGINAL VALUES FIRST
    !--             SET X TO XB ETC.
    !--
        DO I = 1,IEND
            DO J = 1,NVARX
                DO K = 1,NCROPS
                    X(I,J,K) = XB(I,J,K)
                END DO
            END DO
            DO J = 1,NVARXS
                DO K = 1,NLVSK
                    XS(NPT,I,J,K)= XSB(I,J,K)
                END DO
            END DO
        !--
            DO J = 1,14
                XAG(I,J)=XAGB(I,J)
            END DO
        !--
            DO J = 1,18
                XCR(NPT,I,J)=XCRB(I,J)
            END DO
        !--
            DO J = 1,NVARXA
                DO K = 1,NPGXA
                    XA(I,J,K)=XAB(I,J,K)
                END DO
            END DO
            DO J = 1,NVARPX
                DO K = 1,NPRODS
                    PX(I,J,K)=PXB(I,J,K)
                END DO
            END DO
            DO J = 1, 8
                TRDVAR(I,J)=TRDVARB(I,J)
            ENDDO
            DO J = 1, 10
                DO K = 1,NCROPS
                    BTRD(I,J,K)=BTRDB(I,J,K)
                ENDDO
            ENDDO
        !--
            DO K =1,NCROPS
                DRATEK(I,K) = 0.065                    !this is for switchgrass npv
                FRATEK(I,K) = 0.040
                AFCTRK(I,K) = 0.050
            END DO
        END DO
    !--
    !--
        VAL =0.0
    !--
    !--
    !--   IF UPDATING BASELINE OF POLYSYS NO NEED TO GO ANY FURTHER
    !--

    !--
    !--             A LOOP COULD GO HERE TO ALLOW MORE THAN ONE
    !--             SIMULATION PER RUN OF POLYSYS.
    !--
    !--             AT THIS POINT INCLUDE VALUES FOR X TO BE USED IN
    !--             SIMULATION
    !--             SET VALUES FOR YIELD, ACREAGE, ETC, OR DRAW THEM FROM
    !--             A DISTRIBUTION
    !--
    ! Update from UT 2019
              FNAME='PSWHATIFUS'
              NEW=.FALSE.
              IUNIT1=FILE_MGR('O',FNAME,NEW)
              FNAME='./input/PSINFLATE.USD'  !READ IN INFLATION INDEX COMPUTED IN BASELINE 'INFLAT.FOR'
             OPEN(UNIT=IUNIT1,FORM='UNFORMATTED',FILE=FNAME)
              READ(IUNIT1) INFL
          !    write(666,*) 'inflate=',infl(1:50,1,1)
             CLOSE(IUNIT1)



    !--   READ VALUES TO SIMULATE FROM 'WHATIF.RMF'.
    !--
      
       

        goto 2000 !not using whatif file TD
        FNAME='PSWHATIFUS'
         NEW=.FALSE.
  IUNIT1=FILE_MGR('O',FNAME,NEW)
      !  IUNIT1=FILEUNIT()
       !OPEN(UNIT=IUNIT1,FILE=FNAME)
    !--
        7 FORMAT(///////////////)
        READ(IUNIT1,7,IOSTAT=ios)
        IF(ios<=-1) GOTO 1000
    !--
        1001 CONTINUE
    !--
        READ(IUNIT1,*,IOSTAT=ios)YR,MM,J,K,TG,VAL
        IF(ios<=-1) GOTO 1000
    !--
    !--   This statement converts calendar year to simulation year code (I).The INDEX(30)
    !--   indicates the first year of baseline, read from datatb.rmf.
    !--
        I= YR - INDEX(27) + 3
         IF(YR.LT.INDEX(27)) GOTO 1001  !MAKE SURE YEARS IN WHATIF AREN'T PAST YEARS NOT IN SIMULATION !aug 2020 update


    !--
    !--   First check whether simulation changes are in % (P) or straigth values (V).
    !--   If changes are % from baseline then go around 'till line 500.
    !--   If changes are straigth values then continue to next IF statement.
    !--
        IF (TG== 'V' .OR. TG=='F') THEN
        !--
            IF (MM =='X ' .OR. MM==' X')THEN
                X(I,J,K) = VAL
            ELSE IF(MM == 'CF') then
                 IF((J.EQ.9).and.(k.ne.9)) THEN
                   CFIXED(I,J,K) = VAL * INFL(I,1,1)  !INFLATE PRICES update from UT 2019 (not the same as EIA deflator)
              !     write(666,*) 'inflate2=',I,INFL(I,1,1)
               ELSE
                   CFIXED(I,J,K) = VAL
                ENDIF
!2021 update
               IF(K.EQ.18) CRN(I,5,18,1) = CFIXED(I,J,K)
               IF(K.EQ.19) CRN(I,5,18,2) = CFIXED(I,J,K)
               IF(K.EQ.20) CRN(I,5,K,3) = CFIXED(I,J,K)             
                IF(K == 9 .AND. INDEX(108) == 0)CFIXED(I,J,K)=0.0   !SWITCH
                IF(K == 10 .AND. INDEX(109) == 0)CFIXED(I,J,K)=0.0  !POPLAR
                IF(K == 11 .AND. INDEX(110) == 0)CFIXED(I,J,K)=0.0  !WILLON
                IF(K == 15 .AND. INDEX(111) == 0)CFIXED(I,J,K)=0.0  !SWEET SORGH
                IF(K == 16 .AND. INDEX(112) == 0)CFIXED(I,J,K)=0.0  !MISCAN
                IF(K == 17 .AND. INDEX(113) == 0)CFIXED(I,J,K)=0.0  !ECANE
            !c              IF(K.EQ.9)CFIXED(I,J,10) = VAL                  !POPLARS TOO
            !c              IF(K.EQ.9)CFIXED(I,J,11) = VAL                  !WILLOWS TOO
            !C              IF(K.EQ.9)CFIXED(I,J,15) = VAL                  !SWEET SORGHUM TOO
            !c              IF(K.EQ.9)CFIXED(I,J,9) = 0.0                   !to stop
           ELSEIF(MM.EQ.'CB')THEN
               CRN(I,J,K,T) = VAL   !FOR OILSEED PRICE READIN (J=5)
         !!  ELSE IF(MM.EQ.'WD')THEN   !WOODY BIOMASS PRICE (FOREST RESIDUES AND WHOLE LOGS) WOODY. (not used in NEMS)
          !!     WOODPRC(I) = VAL !* INFL(I,1,1) !update from UT 2019

            ELSE IF(MM == 'XS') THEN
                XS(NPT,I,J,K) = VAL
                IF(J==11 .AND. K==4)XS(NPT,I,J,K)=XS(NPT,I,J,K)*100
                IF(J==13 .AND. K==5)XS(NPT,I,J,K)=XS(NPT,I,J,K)*1000
                IF(J==11 .AND. K==5)XS(NPT,I,J,K)=XS(NPT,I,J,K)*1000
            ELSE IF(MM == 'XG') THEN
                XAG(I,J) = VAL
            ELSE IF(MM == 'XC') THEN
                XCR(NPT,I,J) = VAL
            ELSE IF(MM == 'SF') THEN
                SFIXED(I,J,K) = VAL
            ELSE IF(MM == 'XA') THEN
                XA(I,J,K) = VAL
            ELSE IF(MM == 'PX') THEN
                PX(I,J,K) = VAL
            ELSE IF(MM == 'EN') THEN
                IF(J.EQ.3)  then
                  if ((k.ne.5).and.(k.ne.1)) then
                       EN(NPT,I,J,K) = VAL * INFL(I,1,1)  !INFLATE PRICES
                  else
                    EN(NPT,I,J,K) = VAL
                  endif
               ELSE
                   EN(NPT,I,J,K) = VAL
                ENDIF
                IF(INDEX(107) == 0)EN(NPT,I,J,K)=0.0   !RESIDUES

            ELSE IF(MM == 'BP') THEN      !BIOPRODUCTS
              IF(K.GT.0)THEN !update from UT 2019
                  REGBIODMD(I,J,K)=VAL !*1000000000  !WHERE K IS THE REGION FOR LOCAL DEMAND, and j is 2 is ethanol
              ELSE
                  BIOPRD(I,J) = VAL
              ENDIF
            ELSE IF(MM == 'FS') THEN      !FEEDSTOCK QUANTITIES (CORN GRAIN AND SOYBEANS ONLY)
                FDSTK(I,J,K) = VAL
            ELSE IF(MM == 'TR') THEN      !ETHANOL TRADE  MODULE (Update from UT 2019)
              TRDVAR(I,J) = VAL
            ELSE IF(MM == 'BT') THEN      !ETHANOL TRADE MODULE (Update from UT 2019)
              BTRDFIX(I,J,K) = VAL

            ELSE IF(MM == 'IN')THEN
                IF(J == 1)THEN
                    CARBINCT(I) = VAL !* 2         !THIS IS THE VALUE OF CARBON (AND THEREFORE THE CARBON INCENTIVE !increases price by 2x for model
                ELSEIF(J == 2)THEN
                    ENGY = VAL                 !THIS IS THE % CHANGE IN ENERGY COSTS NATIONALLY
               ENDIF

            END IF
                     ELSE
            IF (MM =='X ')THEN
                X(I,J,K) = (1+VAL)*XB(I,J,K)
            ELSE IF(MM == 'CF') THEN
                CFIXED(I,J,K) = (1+VAL)*B(I,J,K)
            ELSE IF(MM == 'XS') THEN
                XS(NPT,I,J,K) = (1+VAL)*XSB(I,J,K)
            ELSE IF(MM == 'SF') THEN
                SFIXED(I,J,K) = (1+VAL)*SB(I,J,K)
            ELSE IF(MM == 'XA') THEN
                XA(I,J,K) = (1+VAL)*XAB(I,J,K)
            ELSE IF(MM == 'PX') THEN
                PX(I,J,K) = (1+VAL)*PXB(I,J,K)
            ELSE IF(MM == 'XG') THEN
                XAG(I,J) = (1+VAL)*XAGB(I,J)
            ELSE IF(MM == 'XC') THEN
                XCR(NPT,I,J) = (1+VAL)*XCRB(I,J)
            ELSEIF(MM == 'CRP')THEN
                DO KK=1,18
                  CRPPERCENT(KK)=VAL          !PERCENTAGE OF NORMAL YIELD THAT WILL OCCUR ON CRPLANDS  !EIA CHAD 2017 (update from UT 2019)
                ENDDO
            ELSE IF(MM == 'TR') THEN      !ETHANOL TRADE MODULE (update from UT 2019)
              TRDVAR(I,J) = (1+VAL)*TRDVARB(I,J)
           ELSE IF(MM == 'BT') THEN      !ETHANOL TRADE MODULE (update from UT 2019)
              BTRDFIX(I,J,K) = (1+VAL)*BTRDB(I,J,K)

            ELSE IF(MM == 'IN')THEN
            !c             IF(J.EQ.1)THEN
            !c              CARBINCT(I) = VAL !* 2         !THIS IS THE VALUE OF CARBON (AND THEREFORE THE CARBON INCENTIVE !increases price by 2x for model
                IF(J == 2)THEN
                    ENGY = VAL                 !THIS IS THE % CHANGE IN ENERGY COSTS NATIONALLY
               ENDIF
           ELSEIF(MM.EQ.'BC')THEN  !(update from UT 2019)
               BIOCOSTADJ(I,K) = VAL         ! tHIS IS TO ENTER A BIOMASS COST ADJUSMENT PERCENTAGE THAT CHANGES THE CMX MATRIX VALUES (THEREFORE TOTAL COST) IN BIOHARV.FOR
!C--

            END IF
        END IF
    !--
        GOTO 1001
        1000 CONTINUE
    !--

        !CLOSE(IUNIT1)
         IUNIT1=FILE_MGR('C',FNAME,NEW)

    !--
        DO I=1,IEND
        !--
            X(I,2,1) = XB(I,2,1) + (X(I,5,1)-XB(I,5,1)) !CHANGES IN ETHANOL CHANGE OTHER CORN DEMANDS
        !--
            IF(X(I,5,1) < XB(I,5,1))THEN
                BIOPRD(I,2)= BIOPRD(I,2)+(XB(I,5,1)-X(I,5,1))    & !IF DROPING CORN GRAIN FOR ETHANOL BELOW BASELINE, THEN ADD THIS ETH DEMAND TO GENERAL TO BE FILLED WITH OTHER FEEDSTOCKS
                * BIOPRD(I,27)/1000
            ENDIF
        !--
        !c        X(I,2,6) = X(I,2,6) + FDSTK(I,5,3)                 !SOYBEANS FOR BIODIESEL
        !--
        !--      FIGURE BI-PRODUCT QUANTITIES
        !C        BIOPRD(I,50) = FDSTK(I,4,2) * BIOPRD(I,28)       !DISTILLERS DRY GRAINS FROM CORN ETHANOL PRODUCTION (lbs) !now in bioprod2.for
        !c        BIOPRD(I,51) = FDSTK(I,5,3) * BIOPRD(I,31)         !SOY OIL LBS  FROM BIODIESEL PRODUCTION
        !c        BIOPRD(I,52) = FDSTK(I,5,3) * BIOPRD(I,32)         !SOY MEAL LBS FROM BIODIESEL PRODUCTION (MIL LBS)
        ENDDO
    !--
        2000 CONTINUE
    !--
      RETURN
        END SUBROUTINE WHATIF

    !     Last change:  DTU   5 Jun 100    4:02 pm
        SUBROUTINE XTENSION
      IMPLICIT NONE

    !--
    !--             **********************************
    !--             * THIS SUBROUTINE IS CALLED FROM *
    !--             * MAIN.FOR                       *
    !--             **********************************
    !--
    !--
    !--             AUXILLARY WRITE STATEMENTS (UNIT NO., 0 SCREEN, -1 OFF)
    !--

    !--
    !--

    !--
        EXTT = TRIM(ADJUSTL(EXTPRE))//TRIM(ADJUSTL(EXTSUF))
    !    IF(EXTSUF == '000')INDEX(39)=0

      !  READ (EXTSUF,'(g3.0)')INDEX(39)
        INDEX(39)=3

    !--
      RETURN
        END SUBROUTINE XTENSION


 !************************************************************************************************
!
!********************************************
! Get price multipliers by coal region and map to poly regions
!********************
!
SUBROUTINE GET_PRICE_MULTS
IMPLICIT NONE

INCLUDE 'parametr'
INCLUDE 'emmparm'
INCLUDE 'wrenew'
INCLUDE 'wrenio'
INCLUDE 'wwdcomon'


integer ii,iy,irg

real poly_prod(npolyreg,3,25),price_mults(ndreg)
       real wodsup(16,50,48)
       real gdpmults(50)

       COMMON /wodsupp/ wodsup,price_mults,gdpmults

common /prod/poly_prod


  DO IRG = 1 , NDREG
   PRICE_MULTS(IRG) = POLYPRMULT(IRG)
  ENDDO
          !debug7  write(7,*) ' Inside Subroutine ',' GETPRICEMULT '

  DO CRDL = 1 , NPOLYREG
! write(iorndump,*) ' price index bef overw crdl ',I,CRDL,COAL_MAP(CRDL),RXB(2,9,crdl),RX(2,9,crdl)

    CYX(3,9,:,crdl) = CYX(3,9,:,crdl) * PRICE_MULTS(COAL_MAP(CRDL))
   ! CYXB(2,9,:,crdl) = CYXB(2,9,:,crdl) * PRICE_MULTS(COAL_MAP(CRDL))
  !  CYX(2,9,:,crdl) = CYX(2,9,:,crdl) * PRICE_MULTS(COAL_MAP(CRDL))
 !write(iorndump,*) ' price index aft overw crdl ',PRICE_MULTS(COAL_MAP(CRDL)),RXB(2,9,crdl),RX(2,9,crdl)
 !f (jj.eq.3) write(666,*) 'CYX assigned by NEMS',jj,curcalyr,crdl,PRICE_MULTS(COAL_MAP(CRDL)),CYX(3,9,1:3,crdl)
  ENDDO




RETURN
END SUBROUTINE GET_PRICE_MULTS




 !*********************************
      ! copy NEMS price variables to Polysys variables
      SUBROUTINE FROM_NEMS(jj)
      IMPLICIT NONE

      INCLUDE 'PARAMETR'
      INCLUDE 'NCNTRL'
      INCLUDE 'EMMPARM'
      INCLUDE 'MACOUT'  !NEMS include file
      INCLUDE 'INTOUT'  !NEMS include file
      INCLUDE 'WRENEW'  !NEMS include file
      INCLUDE 'WWDCOMON'
      INCLUDE 'WRENIO'
      INCLUDE 'MCDETAIL'


      integer jj !which point on the supply curve
      integer ir !region
      real bprice ! biomass price from NEMS
      real poly_inflate(MNUMYR)
      DATA poly_inflate / 1.02724,1.03649,1.04582,1.05523,1.06473,1.07431,1.08398,1.09374,1.10358,1.11351,1.12354,1.13365,1.14385,1.15415, &
                          1.16453,1.17501,1.18559,1.19626,1.20703,1.21789,1.22885,1.23991,1.25107,1.26233,1.27369,1.28516,1.29672, &
                          1.30839,1.32017,1.33205,1.34393,1.35846,1.37826,1.39410,1.41258,1.42842,1.43635,1.45219,1.46671,1.47991, &
                          1.49443,1.50895,1.52348,1.53800,1.55120,1.56572,1.58024,1.59477,1.60797,1.62249,1.63701,1.65153,1.66473, &
                          1.67926,1.69378,1.70830,1.72150,1.73602,1.75055,1.76507,1.77827 /


!*** notes ***
! Polysys prices are in nominal dollars
!polyptp(maxpolypt,ndreg) is the national average price
!polyprmult(ndreg) - price multiplers
!polyptp is in 1987$/mmbtu


    !  write(555,*) 'debug from NEMS price',jj,curcalyr,',',polyptp(jj,0,curiyr),polyptp(jj,0,curiyr)*15.4*mc_jpgdp(curiyr)
      do ir=0,NDREG
         polyptpfix(jj,ir,curiyr)= polyptp(jj,ir,curiyr) !save original price
      enddo
           bprice=polyptp(jj,0,curiyr)*15.4*  (MC_DETAIL(100,curiyr)/(MC_DETAIL(100,1)*0.97))! $1990 is first year MC_DETAIL is available so scale it back to $87
         !  write(666,*) 'nems deflator', (MC_DETAIL(100,curiyr)/(MC_DETAIL(100,1)*0.97)),MC_DETAIL(100,curiyr),MC_DETAIL(100,1)*0.97,infl(POLYCURIYR,1,1)
           CFIXED(I,9,9) =bprice  !switchgrass
      C(NPT,I,9,9) =bprice  !switchgrass farm price
       EN(NPT,I,3,5) = bprice  !wheat
       EN(NPT,I,3,1) = bprice !corn
      write(IORNDUMP,3753) 'POLY PRICE=',NPT,CURIYR+1989,bprice
3753 format(a,2I5,2x,F10.3)

      RETURN
      END SUBROUTINE FROM_NEMS

!**********************************
! copy polysys Q variables to NEMS variables

     SUBROUTINE BACKTO_NEMS(jj)
      IMPLICIT NONE

      INCLUDE 'PARAMETR'
      INCLUDE 'NCNTRL'
      INCLUDE 'EMMPARM'
      INCLUDE 'MACOUT'  !NEMS include file
      INCLUDE 'WRENEW'  !NEMS include file
      INCLUDE 'WWDCOMON'
      INCLUDE 'WRENIO'
      INCLUDE 'MCDETAIL'

        integer jj,iii ! which point on the curve
      integer creg  !,iend,istart
      integer cmap


      REAL ARENNDREG(50,9,NDREG+1)
      REAL NALLREN(50,30,15,npolyreg,1) !,NRCI(50,5,15,npolyreg)
       real poly_inflate(MNUMYR)

        ARENNDREG(I,:,:)= 0.0

         DO CRDL =1,npolyreg
            CMAP = COAL_MAP(CRDL)
            NALLREN(I,3,1,CRDL,1)= SUM(RCNT(11,1,1:3,CRDL))/1000000.0!CY(4,1,1,CRDL)/1000000.0  !ALLREN(I,3,1,CRDL,1)/1000000.0 !corn residue--  td changed variable
            NALLREN(I,3,5,CRDL,1)= SUM(RCNT(11,5,1:3,CRDL))/1000000.0!CY(4,5,1,CRDL)/1000000.0  !ALLREN(I,3,5,CRDL,1)/1000000.0 !wheat residue-- td changed variable
            NALLREN(I,3,9,CRDL,1)= sum(CY(4,9,1:3,CRDL))/1000000.0 !CY(4,9,1,CRDL)/1000000.0  !switchgrass- td changed variable
            NALLREN(I,3,2,CRDL,1)= sum(CY(4,1,1:3,CRDL))/1000000.0 ! !corn
            NALLREN(I,3,6,CRDL,1)= sum(CY(4,6,1:3,CRDL))/1000000.0 !  !soy


            ARENNDREG(I,1,CMAP) = ARENNDREG(I,1,CMAP) + NALLREN(I,3,1,CRDL,1)
            ARENNDREG(I,5,CMAP) = ARENNDREG(I,5,CMAP) + NALLREN(I,3,5,CRDL,1)
            ARENNDREG(I,9,CMAP) = ARENNDREG(I,9,CMAP) + NALLREN(I,3,9,CRDL,1) !td added
            ARENNDREG(I,2,CMAP) = ARENNDREG(I,2,CMAP) + NALLREN(I,3,2,CRDL,1) !td added
            ARENNDREG(I,6,CMAP) = ARENNDREG(I,6,CMAP) + NALLREN(I,3,6,CRDL,1) !td added

            ARENNDREG(I,1,NDREG+1) = ARENNDREG(I,1,NDREG+1) + NALLREN(I,3,1,CRDL,1)
            ARENNDREG(I,5,NDREG+1) = ARENNDREG(I,5,NDREG+1) + NALLREN(I,3,5,CRDL,1)
            ARENNDREG(I,9,NDREG+1) = ARENNDREG(I,9,NDREG+1) + NALLREN(I,3,9,CRDL,1) !td added
            ARENNDREG(I,2,NDREG+1) = ARENNDREG(I,2,NDREG+1) + NALLREN(I,3,2,CRDL,1) !td added
            ARENNDREG(I,6,NDREG+1) = ARENNDREG(I,6,NDREG+1) + NALLREN(I,3,6,CRDL,1) !td added

         END DO



 !PLYSUPQ_PT - convert million dry tons to trillion btu
     I=POLYCURIYR
     !! note from cga,  plysupq_pt is dimensioned maxpolypt,0:ndreg.  The 0 dimension is for the total value
     PLYSUPQ_PT(jj,0,curiyr)=0.0

     do creg=1,NDREG

        PLYSUPQ_PT(jj,creg,curiyr)=&
       (ARENNDREG(I,1,CREG) +& !corn
        ARENNDREG(I,5,CREG)+& !wheat
        ARENNDREG(I,9,CREG))*15.4  !switchgrass

        PLYSUPQ_PT(jj,0,curiyr)= PLYSUPQ_PT(jj,0,curiyr) + &
       (ARENNDREG(I,1,CREG) +& !corn
        ARENNDREG(I,5,CREG)+& !wheat
        ARENNDREG(I,9,CREG))*15.4  !switchgrass

Write(IORNDUMP,2753) 'components back to nems',CREG,CURIYR+1989,' CORN ',ARENNDREG(I,1,CREG)*15.4,' WHEAT ',ARENNDREG(I,5,CREG)*15.4,' SWGR ',ARENNDREG(I,9,CREG)*15.4,plysupq_pt(jj,creg,curiyr)
      enddo

!   Fill in Corn and Soy variables for LFMM  ?? add polysys point to array,
!
    DO CREG = 1 , NDREG + 1
      CRNSUP_TOT_Q(JJ,CREG,CURIYR) =  ARENNDREG(I,2,CREG)  !RCIPNDREG(I,1,CREG)
      SOYSUP_TOT_Q(JJ,CREG,CURIYR) =  ARENNDREG(I,6,CREG) !RCIPNDREG(I,6,CREG)


   !   POLY uses nominal dollars
   !write(666,*) 'debug inflator poly,gdp',poly_inflate(curiyr),MC_JPGDP(CURIYR) 
        CRNSUP_P(JJ,CREG,CURIYR) = C(NPT,I,9,1) /  (MC_DETAIL(100,curiyr)/(MC_DETAIL(100,1)*0.97))! $1990 !poly_inflate(curiyr) !MC_JPGDP(CURIYR)
        SOYSUP_P(JJ,CREG,CURIYR) = C(NPT,I,9,6) /   (MC_DETAIL(100,curiyr)/(MC_DETAIL(100,1)*0.97))! $1990!poly_inflate(curiyr) !MC_JPGDP(CURIYR)


   write(iorndump,2576) ' corn&soy run itr yr rg pnt cq sq cp sp ',curiRUN,curitr,curiyr,creg,jj,crnsup_tot_q(jj,creg,curiyr),  &
                soysup_tot_q(jj,creg,curiyr),C(NPT,I,9,1),crnsup_p(jj,creg,curiyr),C(NPT,I,9,6),soysup_p(jj,creg,curiyr)
  2576 format(a,5(I4),2(F12.3),4(F10.5))
    ENDDO

    ! CRNSUP_ETH_Q(jj,NDREG+1,CURIYR) = C(NPT,I,35,1)             ! ethanol
     CRNSUP_ETH_Q(jj,NDREG+1,CURIYR) = X(I,44,1) ! domestic ethanol
     SOYOILSUP_BIOD_Q(jj,NDREG+1,CURIYR) = BIOPRD(I,51)   ! !SOY OIL LBS  FROM BIODIESEL PRODUCTION

     SOYOILSUP_TOT_Q(jj,NDREG+1,CURIYR) = PC(NPT,I,1,1)
 !   POLY uses nominal dollars
        SOYOILSUP_P(jj,NDREG+1,CURIYR) = PC(NPT,I,4,1) /  (MC_DETAIL(100,curiyr)/(MC_DETAIL(100,1)*0.97))! $1990 !poly_inflate(curiyr) !MC_JPGDP(CURIYR)

    write(iorndump,2572) ' soyoil q p ethq ',curirun,curitr,curiyr,creg,jj,soyoilsup_tot_q(jj,NDREG+1,curiyr),    &
                      PC(NPT,I,4,1),soyoilsup_p(jj,ndreg+1,curiyr),crnsup_eth_q(jj,ndreg+1,curiyr),soyoilsup_biod_q(jj,ndreg+1,curiyr),biosply(I,3)
  2572 format(a,5I4,6(2x,F15.4))



! q's are sometime too close or cross at the high prices which can cause a problem with the interpolation while creating the wodsup matrix
  do creg=1,NDREG
    if (jj.eq.5) then
          if (plysupq_pt(3,creg,curiyr).gt.plysupq_pt(4,creg,curiyr)) plysupq_pt(4,creg,curiyr)=plysupq_pt(3,creg,curiyr)
          if (plysupq_pt(1,creg,curiyr).gt.plysupq_pt(2,creg,curiyr)) plysupq_pt(2,creg,curiyr)=plysupq_pt(1,creg,curiyr)
          if (plysupq_pt(4,creg,curiyr).gt.plysupq_pt(5,creg,curiyr)) plysupq_pt(5,creg,curiyr)=plysupq_pt(4,creg,curiyr)
    endif
  enddo

 2753 format(a,2I5,3(A,F10.3),2x,F10.3)

 write(IORNDUMP,*)  'debug back to nems Q Total',jj,curcalyr,',',PLYSUPQ_PT(jj,0,curiyr)
 do iii=1,NDREG
   write(IORNDUMP,*) 'debug back to nems Q reg',PLYSUPQ_PT(jj,iii,curiyr),jj,curcalyr
  enddo
  write(IORNDUMP,*)
 !write(IORNDUMP,*) 'debug back to nems Q reg',PLYSUPQ_PT(jj,1:NDREG,curiyr),jj,curcalyr


      RETURN
      END SUBROUTINE BACKTO_NEMS

!  new with region change version
!update from UT 2019
      SUBROUTINE EIAresid
       IMPLICIT NONE

      INTEGER eia, ctyy,j,k,t,ii,iend
      REAL sumrcntx(18,5,3,305) !16)
      real rescount(18,5,3,305) !16)
      real summuth(41,2,9,3,305) !16)
      real muthcount(41,2,9,3,305) !16)
!--
!--
!--    ************************************************************************
!--    This subrotuine takes the read in country level matrices,
!--         sums, wieghts, and averages the values to the 16 coal region EIA regions,
!--     saves to a temperary matrices
!--    then reassigns to the original matrices but on the first 16 slots
!--    ************************************************************************
!--
!--
!--             AUXILLARY STATEMENTS AND WRITE UNITS
!--   Number of POLYSYS regions
!TD      POLY = INDEX(63)
!--   Number of COUNTIES
      ALWAYSCNTY = INDEX(118)
!--   Number of crops
      NCROPS = INDEX(2)
!--             FIRST YEAR OF SIMULATION
 !     IYEAR1 = INDEX(30)
  !    NYRSIM = INDEX(1)
    !  ISTART = INDEX(30)-INDEX(27)+3
      IEND = INDEX(1)+(INDEX(30)-INDEX(27))+2
!--
!--
!!!!!!!!!!!!!!!!!!!rnctx matrix !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!--
!--   **rnctx matrix***
!      numbcnty=0.0
     ! sumcntx=0.0  check this with CHAD
      sumrcntx=0.0
      rescount=0.0
      do ctyy=1,ALWAYScnty
       do eia=1,cnty !should be 16
          if(bigindex(10,ctyy).eq.eia)then
               do j=1,18
                do k=1,5
                 do t=1,3
                    if(rcntx(j,k,t,ctyy).eq.0)then             !by excluding some zero counties, may skew toward higher constraints....especially for wind contraints!!
                        continue                               !simply dividing by counties, if want weight should multiply sum by planted acres and then sum planted acres and divid the two.
      else
                     rescount(j,k,t,eia)= rescount(j,k,t,eia)+1
                     sumrcntx(j,k,t,eia)= sumrcntx(j,k,t,eia)  + rcntx(j,k,t,ctyy)
      endif
                 enddo !t
                enddo !k
               enddo !j
    endif
       enddo !eia
      enddo !cty

!--        *******************************************
!--
!--         ASSIGN BACK TO rcntx
       do eia=1,cnty
          do j=1,18
           do k=1,5
            do t=1,3
              if(rescount(j,k,t,eia).gt.0.0)then
               rcntx(j,k,t,eia) = sumrcntx(j,k,t,eia)   / rescount(j,k,t,eia)
              else
               rcntx(j,k,t,eia)=0.0
    endif
            enddo !t
           enddo !k
          enddo !j
      enddo !eia
!--     ********************************************
!--
!!!!!!!!!!!!!!!!!!!muth matrix !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!--
!--
      summuth=0.0
      muthcount=0.0
      do ctyy=1,ALWAYScnty
       do eia=1,cnty
          if(bigindex(10,ctyy).eq.eia)then
              do ii=1,iend !update from UT 2019
               do j=1,2
                do k=1,9
                 do t=1,3                                              !k.ne.5....wheat over estimates so this makes sure to weight constraints down.
                    if(muth(ii,j,k,t,ctyy).eq.10.0)then !.and.k.ne.5)then             !by excluding some zero counties, may skew toward higher constraints....especially for wind contraints!!
                        continue                               !simply dividing by counties, if want weight should multiply sum by planted acres and then sum planted acres and divid the two.
                    else
                     muthcount(ii,j,k,t,eia)= muthcount(ii,j,k,t,eia) + CYBACKUP(K,T,CTYY) !cyb(1,k,t,ctyy)  !1
                     summuth(ii,j,k,t,eia)= summuth(ii,j,k,t,eia) + muth(ii,j,k,t,ctyy)*CYBACKUP(K,T,CTYY) !cyb(1,k,t,ctyy)
    endif
                 enddo !t
                enddo !k
               enddo !j
              enddo !ii
    endif
       enddo !eia
      enddo !cty

!--        *******************************************
!--
!--         ASSIGN BACK TO muth
       do eia=1,cnty
         do ii=1,iend
          do j=1,2
           do k=1,9
            do t=1,3
              if(muthcount(ii,j,k,t,eia).gt.0.0)then
               muth(ii,j,k,t,eia) = summuth(ii,j,k,t,eia) &
                               / muthcount(ii,j,k,t,eia)
              else
               muth(ii,j,k,t,eia)=10.0
    endif
            enddo !t
           enddo !k
          enddo !j
         enddo !ii
      enddo !eia
      RETURN
      END SUBROUTINE EIAresid


      !change region version
      SUBROUTINE EIApast
      IMPLICIT NONE

      INTEGER eia,ctyy
      REAL sumptb(41,7,28,305) !16)
      real sumeast(305)
      real pastcount(305) !16)
!--
!--
!--    ************************************************************************
!--    This subrotuine takes the read in country level matrices,
!--         sums, wieghts, and averages the values to the 16 coal region EIA regions,
!--     saves to a temperary matrices
!--    then reassigns to the original matrices but on the first 16 slots
!--    ************************************************************************
!--
!--
!--             AUXILLARY STATEMENTS AND WRITE UNITS
!--   Number of POLYSYS regions
      POLY = INDEX(63)
!--   Number of COUNTIES
      ALWAYSCNTY = INDEX(118)
!--   Number of crops
      NCROPS = INDEX(2)
!--             FIRST YEAR OF SIMULATION
      !IYEAR1 = INDEX(30)
!--
!--
!!!!!!!!!!!!!!!!!!!PTB(41,7,28,3111) matrix !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!--

!--   **cmx matrix***
    !  numbcnty=0.0
      sumptb=0.0
      sumeast=0.0
      pastcount=0.0
      do ctyy=1,ALWAYScnty
       do eia=1,cnty
          if(bigindex(10,ctyy).eq.eia)then
              pastcount(eia)=pastcount(eia)+1
               do j=1,7
                do k=1,28
                  sumptb(i,j,k,eia)=sumptb(i,j,k,eia)+ptb(i,j,k,ctyy)
                enddo !k
               enddo !j
               sumeast(eia) = sumeast(eia) + east(ctyy)
          endif
       enddo !eia
      enddo !cty
!--        *******************************************
!--
!--         ASSIGN BACK TO ptb
       do eia=1,cnty
          do j=1,7

             do k=1,28
              if(j.eq.4)then
               if(pastcount(eia).le.0.0)then
                ptb(i,j,k,eia) = 0.0
               else
                ptb(i,j,k,eia) = sumptb(i,j,k,eia)/pastcount(eia)
               endif
              else
               ptb(i,j,k,eia)=sumptb(i,j,k,eia)
              endif
             enddo

          enddo
          if(pastcount(eia).le.0.0)then
              east(eia)=0.0
          else
             east(eia) = sumeast(eia)/pastcount(eia)
          endif
          if(east(eia).ge.0.5)then
           east(eia)=1.0
          else
           east(eia)=0.0
          endif
      enddo !eia
!--     ********************************************
      RETURN
      END SUBROUTINE EIApast

      END SUBROUTINE POLYMAIN   ! closes the contains structure
!*********************************************************************************

! interpolation function
!function q_interp(p_right,p_left,q_right,q_left,p)
!implicit none

!real p_right,p_left,q_right,q_left,p,q_interp

!      write(666,*) 'calling q_interp', p_right,p_left,q_right,q_left,p, curcalyr
!q_interp = ( ( p_right - p) * q_left + ( p - p_left ) * q_right )  / ( p_right - p_left )
!write(666,*) 'exiting q_interp', q_interp

!return
!end

!***************************************************
!function to get a unit number from file manager when the file does not exist in the array list
INTEGER FUNCTION FILEUNIT
IMPLICIT NONE

      INTEGER FILE_MGR
      EXTERNAL FILE_MGR
      CHARACTER*25 FNAME4
      LOGICAL NEW
      INTEGER IUNIT1

      FNAME4='PSSIM'
      NEW=.FALSE.
      IUNIT1=FILE_MGR('O',FNAME4,NEW)
      IUNIT1=FILE_MGR('C',FNAME4,NEW)
      FILEUNIT=IUNIT1

END FUNCTION FILEUNIT


