! $Header: M:/default/source/RCS/ind.f,v 1.495 2021/04/16 17:00:02 KPE Exp $
!
!  NEMS INDUSTRIAL MODULE
!
!  ORDER OF INDUSTRIES:
!
!  NON-MANUFACTURING
!    1  AGRICULTURE - CROPS
!    2  AGRICULTURE - OTHER
!    3  COAL MINING
!    4  OIL AND GAS
!    5  METAL AND OTHER NON-METALLIC MINING
!    6  CONSTRUCTION
!  MANUFACTURING
!    7  FOOD AND KINDRED PRODUCTS  (NAICS 311, SIC 20)
!    8  PAPER AND ALLIED PRODUCTS  (NAICS 322, SIC 26)
!    9  CHEMICALS AND ALLIED PRODUCTS  (NAICS 325, SIC 28)
!         INORGANIC CHEMICALS  (NAICS 32512 to 32518, SIC 281)
!         ORGANIC CHEMICALS  (NAICS 32511 & 32519, SIC 286)
!         RESINS AND SYNTHETICS  (NAICS 3252, SIC 282)
!         AGRICULTURAL CHEMICALS (NAICS 3253, SIC 287)
!         OTHER CHEMICALS
!***
!*** COMBINE Inorganic, Organic, Resins, and AgChem TO CREATE THE BULK CHEMICALS
!*** INDUSTRY===INDUSTRY 9
!***
!  STONE,CLAY, AND GLASS PRODUCTS  (NAICS 327, SIC 32)
!    10   GLASS AND GLASS PRODUCTS  (NAICS 3272, SIC 321,322,323)
!    11   CEMENT  (NAICS 32731, SIC 324)
!  PRIMARY METALS INDUSTRIES  (NAICS 331, SIC 33)
!    12   IRON AND STEEL INDUSTRY (NAICS 3311 &3312)
!    13   ALUMINUM INDUSTRY (NAICS 3313)
!  Formerly METALS-BASED DURABLES  (NAICS 332 to 336, SICs 34-38)
!    14   Fabricated Metal Products                           332
!    15   Machinery                                           333
!    16   Computer and Electronic Products                    334
!    17   Transportation equipment                            336
!    18   Electrical Equip., Appliances, and Components       335
!  Formerly Balance of Manufacturing
!    19   Wood Products                                       321
!    20   Plastic and Rubber Products                         326
!    21   BOM-Other
!                                                             312    Beverage and Tobacco Products
!                                                             313    Textile Mills
!                                                             314    Textile Product Mills
!                                                             315    Apparel
!                                                             316    Leather and Allied Products
!                                                             323    Printing and Related Support
!                                                             324 nec  Other Petroleum and Coal Products
!                                                             325 nec  Other Chemicals
!                                                             327 nec  Other SCG
!                                                             331 nec  Other Primary Metals
!                                                             337    Furniture and Related Products
!                                                             339    Miscellaneous


!
!  ORDER OF ENERGY SOURCES: (NOT FOR BUILDINGS)
!
!  THE MAIN QUANTITY ARRAY:  QTYMAIN(22,5)
!   1.  ELECTRICITY - (FROM PA AND BLD COMPONENTS)
!   2.              - Not Used
!   3.  NATURAL GAS - CORE (NEC) (FROM PA AND BLD COMPONENTS)
!   4.              - NONCORE (FROM BSC COMPONENT)
!   5.              - FEEDSTOCK
!   6.              - LEASE & PLANT
!   7.  COAL        - STEAM COAL
!   8.              - COKING COAL
!   9.              - COAL COKE (THIS IS NET COAL COKE IMPORTS)
!  10.  PETROLEUM   - RESIDUAL OIL
!  11.              - DISTILLATE OIL
!  12.              - LPGS FOR HEAT AND POWER
!  13.              - LPGS FOR FEEDSTOCKS
!  14.              - MOTOR GASOLINE
!  15.              - STILL GAS
!  16.              - PETROLEUM COKE
!  17.              - ASPHALT & ROAD OIL
!  18.              - LUBES & WAXES
!  19.              - PETROCHEMICAL FEEDSTOCKS
!  20.              - KEROSENE
!  21.              - OTHER PETROLEUM FEEDSTOCKS
!  22.              - OTHER PETROLEUM
!  THE INTERMEDIATE PRODUCTS QUANTITY ARRAY:  QTYINTR(6,5)
!   1.  STEAM                           (31)
!   2.  COKE OVEN GAS                   (32)
!   3.  BLAST FURNACE GAS               (33)
!   4.  OTHER BYPRODUCT GAS             (34)
!   5.  WASTE HEAT                      (35)
!   6.  COKE                            (36)
!  THE RENEWABLES QUANTITY ARRAY:  QTYRENW(8,5)
!   1.  HYDROPOWER                      (41)
!   2.  BIOMASS-WOOD                    (42)
!   3.  BIOMASS-PULPING LIQUOR          (43)
!   4.  GEOTHERMAL                      (44)
!   5.  SOLAR                           (45)
!   6.  PHOTOVOLTAIC                    (46)
!   7.  WIND                            (47)
!   8.  MUNICIPAL SOLID WASTE           (48)
!****
!  ENERGY SOURCES FOR BUILDINGS: (USED IN THE INPUT FILE ENPROD)
!
!   1.  ELECTRICITY
!   2.  NATURAL GAS
!   3.  STEAM

!****
!  VINTAGES:
!
!  VARIABLES ARE DIMENSIONED WITH 4 OR 3 VINTAGES.
!  1 = OLD (2006 AND EARLIER)
!  2 = MID (2007 TO OR THROUGH THE CURRENT FORECAST YEAR
!  3 = NEW (THE CURRENT FORECAST YEAR)
!  4 = ALL OR TOTAL
!****

!****
!  LAGS:
!****
!  SOME VARIABLES ARE DIMENSIONED FOR CURRENT YEAR AND LAG YEAR.
!  1 = CURRENT YEAR
!  2 = LAG YEAR
!  NOTE THAT THERE ARE ALSO SOME VARIABLES THAT ARE LAGGED
!  BY USING A DIFFERENT VARIABLE NAME.
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

! Variable sharing module
      module i_
      implicit none
      include 'parametr'
      include 'ncntrl'
      include 'emmparm'
      include 'macout'
      include 'qblk'
      include 'mpblk'    ! prices, unadjusted for any carbon price
      include 'intout'
      include 'epmmpblk' ! prices, adjusted for any carbon price (same common as ampblk)
      include 'qsblk'
      include 'eusprc'
      include 'indout'
      include 'cogen'
      include 'indrep'
      include 'bifurc'
      include 'wrenew'
      include 'ogsmout'
      include 'pmmrpt'
      include 'pmmout'   ! refinery methanol demand
      include 'ngtdmrep' ! added by AEL
      include 'comparm'  ! added by ESE for Ag Comm vars
      include 'tranrep'
      include 'cdsparms'
      include 'coalout'
      include 'coalrep'
      include 'convfact' ! to convert refinery methanol demand for use by lime model
      include 'lfmmout'
      include 'emeblk'
      include 'ab32'

      real DiffCon(18,mnumyr),scalfac(18,mnumyr),nonref(18,mnumyr)

!=========================================================================================
! Common Declarations for the Industrial Module
!
      integer numind
      parameter(numind=21)

      INTEGER techstrtyr
      PARAMETER (techstrtyr=2017)      
      INTEGER INUMREG      !number of regions
      PARAMETER (INUMREG=4)

! indctrl
! CONTROL VARIABLES AND RUNTIME PARAMETERS

      INTEGER IYR      ! Current year
      INTEGER IBYR     ! base year
      INTEGER IBYR2    ! base year for end-use industries
      PARAMETER (IBYR=2018) ! base year parameter - to be changed with each new MECS update. POT_07/31/2013
      PARAMETER (IBYR2=2017) ! base year for end-use industries is a year before the most recent MECS - to be changed with each new MECS update NSK 6/23/20
      INTEGER ICURIYR        ! current base year index
      INTEGER ICURIYR2       ! base year index for process-flow industries
      PARAMETER (ICURIYR=29) ! current MECS base year - to be changed with each new MECS update
      PARAMETER (ICURIYR2=28) ! current MECS base year - to be changed with each new MECS update

      INTEGER IEYR     ! last year
      INTEGER IWDBG    ! debug switch
      INTEGER ISUBTR   ! subroutine trace option
      INTEGER INDNUM   ! index number for industry
      INTEGER INDMAX   ! max industries
      INTEGER INDDIR   ! industry number identifier
      INTEGER IWRSUM   ! option to write summary tables
      INTEGER IOPEN    ! flag indicating file status
      INTEGER INDREG   ! industry region index
      INTEGER IPRICE   ! flag to run price sensitivities
      REAL ELEC        ! Electricity price sensitivity factor
      REAL FGAS        ! Firm gas price sensitivity factor
      REAL INTGAS      ! Interruptible gas price sensitivity factor
      REAL COAL        ! Coal price sensitivity factor
      REAL RESID       ! Resid price sensitivity factor
      REAL DIST        ! Dist price sensitivity factor
      REAL LPG         ! LPG price sensitivity factor

	  REAL ngfeedcalibfact ! for natural gas feedstock calibration to be applied to projections beyond STEOLASTYR (PGR)
	  REAL LPGFEEDCALIBFACT ! FOR LPG FEEDSTOCK CALIBRATION TO BE APPLIED TO 1 BEYOND STEOLASTYR (PGR)
	  REAL PCFFEEDCALIBFACT ! for PCF feedstock calibration
	  REAL NGFEEDTARGET(5)  ! natural gas feedstock target based on history vs. model results
	  REAL LPGFEEDTARGET(5) ! LPG feedstock target based on history vs. model results
	  REAL PCFFEEDTARGET(5, MNUMYR) ! PCF feedstock target based on history vs. model results

      INTEGER ITPC     ! Flag to run tpc sensitivity case
      REAL TPC1        ! Sensitivity factor for tpc for old equipment
      REAL TPC2        ! Sensitivity factor for tpc for new equipment

      INTEGER IRETIRE  ! flag to run retirement rate sensitivity
      REAL RETRATE     ! retirement rate sensitivity factor

      INTEGER FRZTECH  ! frozen technology case flag
      INTEGER HITECH   ! high technology case flog
      INTEGER EETECH   ! POT_EE Energy Efficient case iflag
      INTEGER PRICEPA  ! Option to use Process/Assembly Price Sensitivity Routine
      INTEGER LOOKAHEAD! Number of lookahead years for CHP and Motors

      REAL COGFACTOR   ! Option to specify cogfactor. Default=1.0


      INTEGER IUNIT1  ! unit numbers used as file identifiers
      INTEGER IUNIT2
      INTEGER IUNIT3
      INTEGER IUNIT4
      INTEGER IUNIT5
      INTEGER IUNIT6
      INTEGER IUNIT7
      INTEGER IUNIT8
      INTEGER IUNITBUG, IUNITBENCH, IUNITOUTF, IFACTOUT, IFACTIN, IFEEDOUT

      INTEGER IUNITFEED
      INTEGER IUNITFAER
      INTEGER IUNITFRACETH
      INTEGER IUNITFRACPROP
	  INTEGER IUNITCOAL
     

      INTEGER LENGTHIND(50)
      INTEGER FSTITER  ! first iteration
      INTEGER LSTITER  ! last iteration

      INTEGER SedsLastYr
      PARAMETER (SedsLastYr=2020)

      INTEGER STEOLastYr
      PARAMETER (STEOLastYr=2023)
      
      Integer, parameter:: END_YR_QCR=2021     	    ! Last year of qcr data in ind_coal.csv; 2020 as of AEO2022
	  Integer, parameter:: END_YR_ASM=2019          ! Last year of qcr data in ind_electric.csv; 2019 as of AEO2022
   
       real ln2
       PARAMETER (ln2=0.6931471806)

!====================================

! indpa
! Process/Assembly Variables
      integer maxlinks              ! parameter--maximum number of downsteps or links for any process
      parameter(maxlinks=6)
      integer maxstep
      parameter(maxstep=32)         ! maximum number of process assembly steps -- for dimensioning.
      integer maxtech
      parameter(maxtech=11)         ! maximum number of technologies -- for dimensioning.

      CHARACTER*40 INDNAME ! captures industry name from input
      CHARACTER*24 INDSTEPNAME(maxstep+1)! captures process step name from input
      CHARACTER*18 NFILE(5) ! identifies model intermediary file for temporary storage

      REAL    PHDRAT                ! factor used to convert industrial output from physical to dollar units
      REAL    PRODCUR(4,maxstep)    ! production capacity by region and process/assembly step

      REAL    IDLCAP(maxstep)       ! Idle Capacity by process step
      REAL    IDLCAPLAG(maxstep)    ! Idle Capacity by process step, lag year
      REAL    PRODLAG(4,maxstep)    ! lag year production capacity by vintage,process
      REAL    PRODFLOW(2,maxstep,maxlinks) ! production flow coefficients by vintage,process,link
      REAL    PRODFLOW_IBYR(INUMREG,2,maxstep,maxlinks) ! production flow coefficients by vintage,process,link for ibyr2
      REAL    PRODRETR(maxstep)     ! retirement rates by process step
      INTEGER NTMAX(maxstep)        ! max number of links per process step
      INTEGER IPASTP(maxstep,maxlinks)     ! stores 0-1 values indicating process flow links
      INTEGER MPASTP                ! number of process steps
      INTEGER IDVAL                 ! value indicating industrial output units (physical/dollar value)
      INTEGER IFMAX(maxstep+1)        ! max number of fuels per process step
      INTEGER IFLOC(15,maxstep+1)     ! stores fuel identifier numbers per process step
      INTEGER NumRptGrps                  ! Number of Reporting SubGroups for Process Assembly Energy reporting (used in Chemicals for Subindustry rpt), max:11, min:0
      INTEGER NumRptGrpSteps(12)          ! Number of steps in each reporting SubGroup for P/A
      INTEGER RptGrpSteps(12,maxstep)     ! Identification of step numbers included in each reporting subgroup in P/A
      Character*24 RptGrpNames(12)        ! Reporting group names
      Character*24 RptGrpSName(12,maxstep+1)! Reporting labels for step names
      REAL    ENPINT(3,15,maxstep)  ! vintaged unit energy consumption values by fuel,process
      REAL    ENPQTY(4,16,maxstep)  ! energy consumption by region,fuel,process    !not by region but by vintage; 4 is total = correction by AE!
      REAL    ENPMQTY(23)           ! energy consumption of main fuels
      REAL    ENPMQTY_old(23)       ! energy consumption of main fuels
      REAL    ENPIQTY(7)            ! energy consumption of intermediate fuels
      REAL    ENPRQTY(9)            ! energy consumption of renewables
      INTEGER ITYPE(15,maxstep)     ! variable indicating whether or not uec value will be estimating using process flow method,econometric,or constant uec
      REAL    SUMPINT(15,maxstep)   !
      REAL    BCSC(3,15,maxstep)    ! technological possibility coefficient applied to energy intensive industries
      REAL    EINTER(3,15,maxstep)  ! intercept term for unit energy consumption values
      REAL    ENPINTLAG(3,15,maxstep) ! lag year values to vintaged unit energy consumption by fuel,process
      REAL    BYPINTLAG(3,5,maxstep)! lag year vintaged byproduct unit energy consumption values by fuel,process
   !
      INTEGER IFBYP(maxstep)        !
      INTEGER IFLOCBY(10,maxstep)   !
      REAL    BYPINT(3,5,maxstep)   ! vintaged byproduct unit energy consumption by region,process
      REAL    BYPCSC(3,5,maxstep)   ! vintage byproduct efficiency coefficients by region,process
      REAL    BYPQTY(4,6,maxstep)   ! vintaged byproduct energy consumption by fuel, process
      REAL    ENBYPM(23,4)     ! stores main fuels consumption used in process/assembly and bsc from which byproducts are produced
      REAL    ENBYPI(7,4)      ! stores intermediate fuels used in process/assembly and bsc to from which byproducts are produced
      REAL    ENBYPR(9,4)      ! stores renewables used in process/assembly and bsc to from which byproducts are produced

! Global for Motor Energy
      integer NI                 ! number of industries programmed for motors
      parameter(NI=10)
      integer motorsizes,dimreg,mind
      parameter(motorsizes=7,dimreg=5)
      real    TotAdjMotorEnergy(NI+1,motorsizes+1,dimreg,mnumyr)! Total adjusted energy consumption: 4 industries, 7 motor sizes + total, number of model years

! glass
      integer GL_MAXSTPS
      PARAMETER (GL_MAXSTPS=14)

      real GL_OXY(3,4)
      real GL_MECS(2)
      real GL_CRYO
      real GL_ALPHA_DECAY(GL_MAXSTPS,4,2)
      real glassIBYR(5)             ! 2006 shipping from macro -  Total,flat,blown,container,fiber

!   glass Oxy fuel variables

       real gl_add_elec(4)      ! Additional electric energy per tonne of glass
       real gl_oshares(maxtech)      ! Oxy shares

!   glass Shipment variables
       real gl_hist_ship(6,4)  !historical shipping shares by glass type for 6 historical years
       real gl_ship(4)         ! ! U.S. flat glass shipments, flat, blown, container,glass products
       real gl_mecsbench(INUMREG,9)! mecs benchmark factors

! aluminum
      real ALUMIBYR                    ! Aluminum base year production
      integer AL_MAXSTPS
      PARAMETER (AL_MAXSTPS=5)
      integer ALUMINA_IN
      PARAMETER (ALUMINA_IN=2010-BASEYR+1)     ! first alumina percent year in input file

      real al_non_met                    !Non-Metallic use of alumina
      real al_mass_loss                  !Mass loss converting alumina to aluminum
      real al_alpha_decay(AL_MAXSTPS,4,2)
      real primprod_percent(16:mnumyr)         !Primary Production Percentage ;
      real alumina_percent(ALUMINA_IN:mnumyr)         !Alumina domestic use Percentage ;
      REAL IND_FLOW_SHARE(8:13,33,4)      !shares energy use out to regions
      real tot_production_tech(8:13,maxtech)      ! Total production by Technology
      real AnodeRatio(7)
      real al_pf_fuel(2)                    !product formation fuel
      real al_mecsbench(INUMREG,9)! mecs benchmark factors

! cement    POT_INPUT
    REAL cm_logit_coeff_b(6) ! Calibration coefficients for burner fixed cost, fuel cost, emissions, particulate emissions
    REAL cm_logit_coeff_r(6) ! Calibration coefficients for raw grinding allocation fixed cost, fuel cost, emissions, heat service
    REAL cm_logit_coeff_k(6) ! Calibration coefficients for kiln allocation fixed cost, fuel cost, emissions, heat service
    REAL cm_lifetimek, cm_lifetimeb,cm_lifetimer, cm_lifetimef, cm_baselifek, cm_baselifedry, cm_baselifewet, cm_baselifeb, cm_baselifer, cm_baselifef ! lifetime new technology and baselife existing technology for k (kiln) b (burner) r (raw grind) f (finish grind)
    REAL lm_lifetime(3),lm_baselife ! Lime lifetime and baselife
    REAL lm_logit_coeff(3)          ! Lime calibration coefficients for fixed cost, fuel cost, emissions
    REAL CO2_Process                !lime CO2

    integer CM_MAXSTPS
    PARAMETER (CM_MAXSTPS=4)
    real c_mass_loss                  !Mass loss rate
    real cm_alpha_decay(CM_MAXSTPS,4,2)
    real cm_baselifewet2(CM_MAXSTPS)
    integer CM_BASELIFECR(CM_MAXSTPS)
	real CM_LIFETIME(CM_MAXSTPS)
    integer CM_CALIB(CM_MAXSTPS)
	real CM_WACC(CM_MAXSTPS)
	integer CM_FISYR(CM_MAXSTPS)
    real cm_capshr(2)                 ! Share of baseline kiln capacity accommodated by Wet(1) and Dry(2) Process kilns
    real cm_import_clink              ! Percent of Finish Grinding tonnes composed of imported clinker
    real cm_combco2(3:4,maxtech)        ! cement combustion CO2 (T/GJ ofr heat service demand) for step 3 of cement (burners)
    real cm_heatsrv(maxtech)                ! cement  kiln heat service (GJ/T)
    real cm_heatsrv_fuel(maxtech)           ! cement  kiln heat service total fuel needs (MMBtu fuel/GJ heat service)    
    real CM_ADD                     !Percent additives for cement
    real cm_heatdcoef        !Heat demand:  GJ per metric ton of clinker
    real cm_wetcoef(maxtech)             !Allocation by Burner Type (Wet Process)
    real cm_wetcoef2(maxtech)             !Allocation by Type (Raw Grinding Wet Process)
    real cm_rawtech(maxtech)
    real cm_fuelmix(7,5)       ! burner fuel mix
    integer scenario                             !NEMS scenario; REF,HITECH,FRZTECH,EETECH
 ! previously in incement
   integer NUMROT ! 3 rotary kilns + Rotary PM
   parameter (NUMROT=4)
   integer NUMTYP !7 burner types ng1,ng2,oil1,oil2,coal,petcoke,multi-channel
   parameter (NUMTYP=7)
   integer NUMTYPg !raw grinder types: ball mill, roller mill, mill_PM
   parameter (NUMTYPg=3)
   integer NUMFUELB             ! Number of burner fuels
   parameter(NUMFUELB=5)
   real cm_eleccoef(numrot+1)
   real cm_heatcoef(numrot+1)
   real grinding_tonnes         !finish grinding
   real wet_process(MNUMYR)             !kilns
   real process_outputk         !kilns
   real heat_req(NUMROT+1)      !kilns
   real heat_demand             !kilns
   real tot_burner_fuel(NUMFUELB) !burner
   real burner_fuel(NUMTYP,NUMFUELB) !burner
   real dry_heat_req
   real tot_prodg(NUMTYPG)      !raw grinder
   real elec_use_rpt(NUMTYPG)   !raw grinder
   real wet_elecg(NUMTYPG)      !raw grinder
   real ng_use_rpt(NUMTYPG)     !raw grinder
   real raw_material
   real part_matter(CM_MAXSTPS,maxtech)   ! particulate matter for each cement step and technology
   real ht_serv(NUMROT)
   real comb_co2b(NUMTYP)
   real fuel_useb(NUMTYP)
   real fuel_mixbd(NUMTYP,NUMFUELB)
   real cm_mecsbench(INUMREG,9)! mecs benchmark factors
   real cm_hfoshr(3)        ! cement share out hfo: resid,dist,other
   real lm_hfoshr(3)        ! lime share out hfo: resid,dist,other
! paper and pulp
      integer PP_MAXSTPS
      PARAMETER (PP_MAXSTPS=26)
	  real pp_chip  !electric fuel use for wood prep chip
     ! real El_Adj   !Electricity Bench Factor; used to benchmark fuel use before model runs to ultimately bench to MECS
      real PP_STM_RYCL !percent steam that is recycled (pulp and paper)
	  real pp_steam(maxstep,maxtech)    !paper steam (units/kT)
	  real pp_blkliq(maxstep,maxtech)   !paper balck liquor
      real pp_hogfuel                   !paper hog fuel
	  real pp_hog(maxstep,maxtech)      !hog fuel for paper industry (GJ/kT)
	  REAL Paper_Share(5,17:MNUMYR)                    ! Allocation shares for Paper Production (5 Paper Types)
      REAL Mech_Share(17:MNUMYR)                       ! Allocation share between Mechanical and Thermo-mechanical Pulping Technologies
      REAL PP_ProxyDat(17:MNUMYR)                    ! Data from the Macro Model that will hopefully be directly passed to the IDM  (2006-2040) to 2050
      real sumprodcur(8:13,PP_MAXSTPS)                      !national prodcur by step
      REAL Paper_PriceIBYR(inumreg)
      real pp_stmfuel_chp(9,5)                !chp fuel use for paper steam
      real pp_stmfuel_bl(9,5)                 !boiler fuel use for paper steam
	  real ppst_shrstart(17,2)                !starting shares for paper steam
	  real ppst_shrfinal(17,2)                !final shares for paper steam
	  real pp_BioBoilEff                      !IDM Boiler Efficency (Biomass)
      real hog_pulp                           !Tons Wood/Ton of Pulp
	  real hog_heat                           !HOG Net Heat Content
	  real hog_waste                          !% of waste to hog fuel
      real pulpshare(2,2:5)                    !shares to distribute wash and dry fuels
      real PP_ElecGen(4)                     ! Paper Electric Generation by fuel
      real BldCHPShr                         ! bld CHP share
      real CapFacAvg(2,4)                      !capacity factor weighted average
      real pp_cogshr                        !share of total steam generated by cogen
      real pp_hfoshr(4)                     ! share out hfo: resid,pet coke,dist,other
	  real pp_mecsbench(INUMREG,9) ! mecs benchmark factors
	  real pp_IBYRvals(5,7) !baseyear model results by region and fuel
      real PAPER_BLIQ            ! KPE variable -- to keep track of black liquor in steps 1-23
      real PAPER_BLIQQ            ! KPE variable -- kilotonnes black liquor using energy from steps 2 & 3	  

!iron and steel parameters
	  integer IS_MAXSTPS
      PARAMETER (IS_MAXSTPS=8)

	  integer IS_MAXFUEL
      PARAMETER (IS_MAXFUEL=7)

      REAL PRODX_Steel(inumreg)               ! Regional Steel Production
      REAL PRODX_Paper(inumreg)               ! Regional Paper Production
	  INTEGER N_Boil_Tech                                ! Number of Conventional Boiler Technologies
      PARAMETER (N_Boil_Tech=5)
	  INTEGER N_CHP_Tech                                  ! Number of CHP Technologies
      PARAMETER (N_CHP_Tech=4)
	  REAL PAPER_STEAM(maxstep,mnumyr)                    ! Steam Paper--used for energy use (-100 & +100 steam = 0 no energy use
	  REAL PAPER_STEAM_GRS(maxstep,mnumyr)		          ! KPE "Gross Steam" -- absolute total steam value (abs(-100) + 100) = 200 steam demand  
	  REAL PAPER_BLIQUOR(maxstep,mnumyr)                  !Paper Black Liquor
      REAL PAPER_HOG(maxstep,mnumyr)                      !Paper Hog FuelBlack Liquor
      real PP_Steam_Cogen(6) !paper steam cogen by fuel -- uses PAPER_STEAM_GRS
      real PP_Steam_Boiler(6) !paper steam boiler by fuel --uses PAPER_STEAM_GRS

      !MECS benchmark variables
      real MECS_Data(8:13,1:5,1:9) !MECS Data for ibyr2; read from ironstl

! variables for technology choice industries
	  real is_shares(8:13,maxstep,maxtech,MNUMYR)        ! Shares stored by year
      real tot_prd_rpt(8:13,maxstep,maxtech,MNUMYR)        ! total production for each technology for reporting

! technology choice industries common variables for consumption
	  REAL NgCons(maxstep,mnumyr)                      ! NG Consumption for for Tech industries (Trils)
      REAL HFOCons(maxstep,mnumyr)                     ! HFO Consumption for Tech industries (Trils)
      REAL ElecCons(maxstep,mnumyr)                    ! Electricity Consumption for Tech industries
	  REAL ElecGen_pap26(maxstep,mnumyr)					! KPE electric generation for CHP technologies-paper step 26 only
      REAL CO2_Tech(maxstep,mnumyr)                   ! CO2 Emissions for tech industries (million tonnes)
      REAL CoalSCons(maxstep,mnumyr)                 ! Coal (Sub-Bituminous) Consumption for Tech industries
      REAL CoalMCons(maxstep,mnumyr)                 ! Coal (Metallurgical) Consumption for Tech industries
      REAL PetCons(maxstep,mnumyr)                 ! Pet Coke Consumption for Tech industries
      REAL OPetCons(maxstep,mnumyr)                 ! Other Pet Coke Consumption for Tech industries

      REAL PRODX_Base(8:13,INUMREG)        ! Base year  Production (Tonnes) from ENPROD input
      real is_production(8:13,maxstep)                   ! historical Step production (1000 tonnes), (aka PRODCUR)
	  ! real is_productionUD(8:13,maxstep)	! updated 2016 production --- kpe add
      real IBYR_survcap(8:13,maxstep)            !base year surviving capacity
      real is_BldCHPShr                         ! bld CHP share
      real is_CapFacAvg(4)
      REAL is_CHP_Consump(5)                     ! CHP consumption by fuel
      real is_ElecGen(5)                     ! Steel Electric Generation by fuel  (1)NG, (2)HFO, (3)Elec, (4)Coal, (5)CO2
      real prod_adjust_fact

      common /prodbase/PRODX_Base
      REAL    prodcurrpt(IS_MAXSTPS,mnumyr)  !save iron and steel prodcur by year for reporting
      REAL    pp_prodcurrpt(PP_MAXSTPS,mnumyr)  !save paper prodcur by year for reporting
      REAL    al_prodcurrpt(Al_MAXSTPS,mnumyr)  !save aluminum prodcur by year for reporting
      REAL    cm_prodcurrpt(CM_MAXSTPS,mnumyr)  !save cement prodcur by year for reporting
      REAL    gl_prodcurrpt(GL_MAXSTPS,mnumyr)

	  ! variables to split prodcure for DRI	(steel industry)
      REAL DRI_EAF(inumreg)                   ! Regional Tonnage of DRI devoted to EAF
      REAL DRI_BOF(inumreg)                   ! Regional Tonnage of DRI devoted to BOF
	  REAL IS_IND_FLOW(8,5)
      Common /dri/dri_bof,dri_eaf ,is_ind_flow
	  REAL MinBOF
	  REAL MaxEAF

	  REAL CHP_SHARE                                        ! Share of steam produced by CHP Systems (GJ)
	  real STEAM_Total   ! Total Steam Demand
	  REAL is_fsteam(5)                                      !Total fuel for steam; use quad BTU
	  real SteamRgShr(8:13,inumreg)                               ! steam regional shares for steel

	   !********* Production & Capacity *******************
      real is_basecap(8:13,maxstep)                      ! Baseline capacity
      real is_surviving_cap(8:13)                            ! Surviving capacity
	  integer is_FISYR(8:13)                              !first calculated year
      integer is_baselifecr(8:13)                         ! Baseline capacity lifetime
    integer is_calib(8:13)                              ! Technology Survival Curve Calibration Constant(user-specified)
	  real is_logit_coeff(8:13,6,maxstep)                        ! Logit Coefficients for fixed costs, fuel costs, and emissions
     !********* Technology Characteristics **************
      real is_av_OM(8:13,maxstep,maxtech)             ! Technology O&M Cost($/1000 Tonnes)
      real is_capcost(8:13,maxstep,maxtech)           ! Technology Capital Cost ($/1000 Tonnes)
      real is_wacc(8:13)                                  ! Weighted Average Cost of Capital (WACC) User Input: 10%
      real is_lifetime(8:13)                              ! Technology Lifetime (Yrs)
      real IS_emiss(8:13,maxstep,maxtech)             ! Technology CO2 Emissions (T/kT)
      real obsoleteyr(8:13,maxstep,maxtech)             ! technology obsolescence year
      real IS_nfuel_use(8:13,maxstep,2,maxtech)  ! non Fuel Intensity 1=oxygen 2=steam (MMBTU/kt)
	  real IS_fuel_use(8:13,maxstep,IS_MAXFUEL,maxtech)  ! Fuel Intensity 1=elec 2=ng 3=hfo 4=coal (MMBTU/kt)
	  real is_alpha(8:13,maxstep,maxtech)             ! Alternative-Specific Constant
      real is_rei(8:13,maxstep,maxtech)             ! REIs read from ironstlx
      real SOA_adj(8:13,maxstep,maxtech)             ! SOA adjustment
      ! real t_IS_ALPHA_DECAY(4,8:13,maxstep,2,maxtech) !temp variable to store aggregated alpha_decay
      real is_alpha_decay(8:13,2)                        ! Alpha decay factor (reduces alternative specific constants)
      real is_base_tech_share(8:13,maxstep,maxtech)   ! Share for each baseline technology
      real is_add_tech_share(8:13,maxstep,maxtech)    ! Share for each added technology
      real is_co2penalty(8:13,21:MNUMYR)               ! CO2 penalty starting with 2010 (index year=21)
      REAL is_Alpha_Furnace(inumreg)                ! Sensitivity Parameter (Currently uniform across regions/fuels, for simplicity)
      REAL is_Max_Delta(inumreg)                       ! Constraint on annual changes to EAF/BOF shares
      real is_steam_adj                              !SIMS Steam adjustment factor, read from ironstl.xml
      real is_ecalib(8:13,maxtech)                    !electricity calibration ; read from ironstl.xml
      real is_delta(8:13,maxstep,maxtech)             !Potential efficiency improvements = % difference between best practice and current practice; ironstl.xml
      integer*4 is_numtech(8:13,maxstep)                !number of technologies in each step
      integer*2 is_numfuel(8:13,maxstep)                !number of fuels in each step

      ! variables for SOA_adj calculation( to be added to ironstlx for each industry)
      integer SOA_Offset
      real SOA_Inflection
      real SOA_Beta
       
	  ! I&S continuous casting : no tech choice data
      real cc_shrstart(2)                  ! starting shares and year to forecast future shares
      real cc_shrfinal(2)                  ! ending shares and year to forecast future shares
      real cc_ngas(4)                      !ng,hfo,elec,co2
      real cc_oil(4)                       !ng,hfo,elec,co2
	
! ******************* input variables for  I&S Hot Roll with no tech choice
      real formshares(3)                  !hot roll shares for blooms, billets and slabs
      real shrstart(12)                  ! starting shares and year to forecast future shares
      real shrfinal(12)                  ! ending shares and year to forecast future shares
      real bloomtubes(4)
      real bloomstruct(4)
      real billbar(4)
      real billrod(4)
      real billshape(4)
      real slabtech1(2)
      real slabtech2(2)
      real slabskin(2)


! Steel MECS benchmark
	  real is_mecsbench(INUMREG,9) ! mecs benchmark factors for elec,ng,resid,steam coal. met coal
	  real is_IBYRvals(5,5) !baseyear model results by region and fuel

! STEAM inputs for Steel
	  REAL B_YEAR(2)                                        ! Initial & Final years to calculate shares of conventional boilers
      REAL B_SHR(2)                                         ! Initial & Final shares of conventional boilers

      REAL B_T_YEAR(2)
      REAL B_T_Start(N_Boil_Tech)                         ! Initial shares of each boiler technology & Initial year
      REAL B_T_Final(N_Boil_Tech)                         ! Final shares of each boiler technology & Final year

      REAL C_T_YEAR(2)
      REAL C_T_Start(N_CHP_Tech)                          ! Initial shares of each CHP technology & Initial year
      REAL C_T_Final(N_CHP_Tech)                          ! Final shares of each CHP technology & Final year

      REAL BOIL_Intensity(5,N_Boil_Tech)                    ! Fuel and CO2 Intensity factors for conventional boilers
      REAL CHP_Intensity(5,N_CHP_Tech)                      ! Fuel and CO2 Intensity factors for CHP systems

! I&S Coke variables
      real STM_Steel(maxstep)              ! steam
      REAL IS_cenergy_use(7)   ! Coke Energy Use (MMBtu/kt)
      REAL IS_CProcess(4) ! Coke Process Output factors; breeze,cog,tars,light oils
      REAL NI_Coke(17:MNUMYR)                 ! minimum negative value of NI_Coke (i.e., maximum exports)

      DATA NI_COKE(17:24)/2224, 922, 1491, -871, -226, 406, 146, -637/   ! Net Coke Imports (kT), 2006-2013 History


!****** Variables for EAF/BOF Adjustment ********
      REAL Base_EAF(inumreg)                  ! Regional Base-Year (2010) Value for EAF Element
      REAL Base_BOF(inumreg)                  ! Regional Base-Year (2010) Value for BOF Element
      REAL DRI_Tot_Phase1(inumreg)              ! Total Production of DRI in Initial Year (Tentatively, 2015)
      REAL DRI_Tot_Phase2(inumreg)            ! Total Production of DRI in Later Year (Tentatively, 2020)
      !****** Variables for DRI Factors ***************
      INTEGER*2 Phase1_YR(inumreg)              ! Initial Year of DRI capacity addition
      INTEGER*2 Phase2_YR(inumreg)              ! Final Year of DRI capacity addition
      INTEGER ndx(4)       ! Indirect index reference for the 4 proxy variables

!  Cold Roll inputs ****************
      Real Base_Cold(inumreg)                 ! Regional Cold-Rolled Share in Base Year (2010)
      real iscr_shares(2:6)               ! Shares of cold rolled steel by sub process (Percent)
      REAL NG_Share                           ! Share of Cold-Rolled Steel production using NG Technologies (Percent)
      REAL HFO_Share                          ! Share of Cold-Rolled Steel production using HFO Technologies (Percent)
      REAL Intensity(3,6)                     ! Energy intensity by fuel and Sub-Process (MMBtu/kT) (NG,Elec,HFO)
      REAL CO2_Intensity(6,2)                 ! Emissions of CO2, by Sub-Process (Tonnes/kT of production)


 !********* Coke inputs ****************
      REAL Base_Coke(inumreg)                  ! Regional Base-Year (2010) Value of Coke PRODFLOW Element
	  real IS_incr_adds(8:13,maxstep,ICURIYR2:MNUMYR)                 !incremental capacity additions

      DATA ndx/14,15,17,6/                           ! Macro indices corresponding to the 4 Proxy indices
!====================================




! Energy price variables
  Real Prcxlag(50,5,3)     ! energy price lags by fuel and region, 2==>  carbon price adjusted(1), unadjusted(2), 3: current industry's avg



!====================================

! indbld
! VARIABLES USED FOR ESTIMATING BUILDINGS ENERGY CONSUMPTION

      REAL ENBINT(4,5)  !
      REAL ENBQTY(5,5)  !


!====================================

! indmacro
! INDUSTRIAL MODULE INDUSTRY MACROECONOMIC VARIABLES

      REAL OUTIND(numind+2,11)        ! industrial output by census division, add 2 ind breakouts for cement & lime
      REAL OUTINDIBYR(11)             ! base year industrial output by census division for paper
      REAL CHEMSHIP(5,5,2002:endyr) ! chemical shipments by 4 chem sub industries& total, census region/total, year
      REAL FOODSHIP(5,5,2010:endyr) ! Food shipments by 4 food sub industries & total, census region/total, year  POT_07/31/2013
      REAL EMPIND(22,11)        ! industrial employment by census division
      REAL PRODX                ! production (tons or dollars depending on industry)
      REAL PRODXLAG             ! lag year production
      REAL PRODXBSYR            ! base year production
      REAL EMPLX                ! employment
      REAL EMPLXLAG             ! lag year employment
      REAL PRCX(50,5,3)         ! energy prices by fuel and region, 2==>  carbon price adjusted(1), unadjusted(2), 3: current industry's avg
      REAL PRCXYR(50,4,9:MNUMYR,3)  ! Saves prices for all fuels by region and year 1998 to endyr
      REAL PRCXIBYR(4,4)        ! Saves base year prices for coal, oil, and gas and electricity (new afor AE02023) by census region
      REAL PRODVX               ! production capacity (dollars)
      REAL PRODVXLAG            ! lag year production capacity (dollars)
      REAL BUSHEL(MNUMYR,5)     ! corn used for incremental ethanol production by census region
      INTEGER region(11)/1,1,2,2,3,3,3,4,4,4,5/  ! Maps Census divisions to Census regions
      REAL LIMEIBYR
      REAL CEMENTIBYR
    !adjustment factors to convert shipments in $2009 to shipments in $2005 as a quick fix SUSAN 07/11/2014
    REAL MC_REVIND_ADJ(1:48) / &   ! changing to 1--no longer needed b/c shipments always current
                1.0  , &  !1 = Food Products1
                1.0  , &  !2 = Grain and Oil Seed Milling
                1.0  , &  !3 = Dairy Products
                1.0  , &  !4 = Animal Slaughter
                1.0  , &  !5 = Other Food Products
                1.0  , &  !6 = Beverage and Tobacco Products
                1.0  , &  !7 = Textiles, Apparel and Leather
                1.0  , &  !8 = Wood Products
                1.0  , &  !9 = Furniture and Related Products
                1.0  , &  !10 = Paper Products
                1.0  , &  !11 = repeat Paper Products for pulp and paper mills
                1.0  , &  !12 = repeat Paper Products for paperboard
                1.0  , &  !13 = repeat Paper Products for other paper
                1.0  , &  !14 = Printing
                1.0  , &  !15 = Basic Inorganic Chemicals
                1.0  , &  !16 = Basic Organic Chemicals
                1.0  , &  !17 = repeat Basic Organic Chemicals for ethanol
                1.0  , &  !18 = Resins and Synthetics
                1.0  , &  !19 = Agricultural Chemicals
                1.0  , &  !20 = Other Chemical Products
                1.0  , &  !21 = Pharma Products
                1.0  , &  !22 = Paint Products
                1.0  , &  !23 = Soaps and Cleaning Products
                1.0  , &  !24 = Other Chemical Products
                1.0  , &  !25 = Petroleum Refining
                1.0  , &  !26 = Other Petroleum and Coal Products
                1.0  , &  !27 = Plastics and Rubber Products
                1.0  , &  !28 = Glass and Glass Products
                1.0  , &  !29 = repeat Glass and Glass Products for flat glass
                1.0  , &  !30 = Cement Manufacturing
                1.0  , &  !31 = prepeat Other Nonmetallic Mineral Products for lime
                1.0  , &  !32 = Other Nonmetallic Mineral Products
                1.0  , &  !33 = Iron and Steel Products
                1.0  , &  !34 = Alumina and Aluminum Products
                1.0  , &  !35 = Other Primary Metals
                1.0  , &  !36 = Fabricated Metal Products
                1.0  , &  !37 = Machinery
                1.0  , &  !38 = Computers and Electronic Products
                1.0  , &  !39 = Transportation Equipment
                1.0  , &  !40 = Appliance and Electrical Equipment
                1.0  , &  !41 = Miscellaneous Manufacturing
                1.0  , &  !42 = Crop Production
                1.0  , &  !43 = Animal Production
                1.0  , &  !44 = Other Agriculture
                1.0  , &  !45 = Coal Mining
                1.0  , &  !46 = Oil and Gas Extraction
                1.0  , &  !47 = Other Mining
                1.0  /    !48 = Construction


!====================================

! indbsc
! BOILER,STEAM,COGENERATION COMPONENT variables

      INTEGER IFSBYP       ! Number of byproducts consumed
      INTEGER IFSLOCBY(6)  ! Stores fuel id number byproduct fuel j
      REAL    BYSINT(11)    ! Boiler Efficiency for byproduct fuel j
      REAL    BYBSCSC(6)   ! Conservation supply coefficient for byproduct fuel j in the BSC
      REAL    BYPBSCM(23)  ! Byproduct consumption of main fuel j
      REAL    BYPBSCI(7)   ! Byproduct consumption of intermediate fuel j
      REAL    BYPBSCR(9)   ! Byproduct consumption of renewable fuel j
      REAL    BYPSTM       ! Amount of steam generated from all byproduct fuels
      REAL    BYPSTMM      ! Amount of steam produced using main fuels
      REAL    BYPSTMI      ! Amount of steam produced using intermediate fuels
      REAL    BYPSTMR      ! Amount of steam produced using renewable fuels

      INTEGER IFSMAX       ! Number of fuels consumed in the bsc
      INTEGER IFSLOC(11)  ! Stores fuel id number for main fuel j
      REAL    ENSQTY(11)   ! Consumption of fuel j to generate steam--added one dimension for electricity
      REAL    BSSHR(11)    ! Boiler share of fuel j
      REAL    BSSHRLAG(11) ! Lag year boiler share
      REAL    STEMCUR      ! Steam demand from process/assembly and buildings
      real cogsteam          ! total steam from cogen
      real noncogsteam       ! stemcur-cogsteam, or the non cogenerated steam
      real biosteam          ! steam from availbiomass (this is non cogen biomass steam)
      real noncogfossteam    ! Non-cogen steam from fossill (=noncogsteam-biosteam)
      real fuelfossteam(11)  ! fuel used to generate noncogfossteam, by type *kpe redimension these variables
      real CogBoilFuel(11)   ! Cogen Boiler Fuel Use (fossil only)

      REAL    BSFUELSHR(numind,4,15)   ! Stores share of oil based fuel i of total oil consumed
      REAL    TLBSHR(numind,4,7)       ! stores boiler share logit coefficients--ADDED dimension for electric kpe 9/30/22
      Real FosFuelSteamSize(numind,10,2,5) ! Boiler consumption by industry, fuel, size, and region
      Real sizeshr(numind+1,10,2)       ! Boiler size shares by industry, fuel, for two groups sm<=10mmbtu/hr, lr>10mmbtu/hr

!====================================

! indcogen
! COGENERATION variables

      REAL STEMCURLAG        ! holds stemcur in prior year;used in calgen and then calbsc
      REAL ELOWN             ! Own use electricity gwh
      REAL ELSALE            ! Electricity sold to the grid trill btu
      REAL GENFUEL(5)        ! CHP fuel consumption by fuel
      REAL RPTGEN(5)         ! CHP generation by fuel GWHa
      REAL RPTCAP(5)         ! CHP capacity by fuel MW

      integer numfl  ! 1:coal,2:oil,3:ngas,4:hydro,5:geoth,6:msw,7:biomass,8:solar,9:othergas,10:electricity, 11:other (total?) !kpe change
      parameter(numfl=11) 
	  integer numflchp
	  parameter(numflchp=10) ! numflchp is one less because electric boilers aren't chp units
      REAL GENGWH(11,numflchp,2)    ! Generation by division,fuel,grid/own use
      REAL DIVFUEL(11,numflchp,2)   ! Fuel consumption for generation by division,fuel, grid/own
      REAL CAPGW(11,numflchp,2)     ! Capacity by division, fuel,grid/own
      REAL cogcap(11,1:mnumyr,numind+1,numflchp+1) ! Cogen capacity by division,year,industry,and fuel   (mw)
      REAL coggen(11,1:mnumyr,numind+1,numflchp+1) ! Cogen generation by division,year,industry,and fuel (gwh)
      REAL cogelf(11,1:mnumyr,numind+1,numflchp+1) ! cogen fuel for electricity
      REAL cogthr(11,1:mnumyr,numind+1,numflchp+1) ! cogen fuel for thermal
      real coggrd(11,1:mnumyr,numind+1,numflchp+1) ! cogen gridshare of generation by division, year, industry and fuel
      REAL RegCHPutil(4,numind)                 ! CHP utilization fraction by census region and industry  POT_08/01/2013
      REAL maxRegCHPutil(4,numind)              ! Max CHP utilization fraction by census region and industry POT_08/01/2013
      INTEGER MAXCOGYR             ! maximum number of cogen data years
      REAL BSCIBYR(numind+1,5,numfl+1)  ! Latest MECS boiler/steam/cogen fuel (aka, indirect fuels) in trill. btu
      REAL BOILIBYR(numind+1,5,numfl+1) ! Estimated base year boiler fuel after subtracting CHP fuel use (same year) from Form 860b data
      REAL CHPIBYR(numind+1,5,numflchp+1)  ! Base year CHP fuel use from Form 860b data, at 4 region level
      REAL COGSTEAMIBYR(numind+1,5) ! Base year steam from chp
      real STEMCURIBYR(numind+1,5)  ! Base year total steam load
      real BIOSTEAMIBYR(numind+1,5)
      real noncogfosstmIBYR(numind+1,5)
      REAL CALIBIBYR_BIO(numind+1,5)  ! MECS/860B BSC BIO/Other Calibration
      real CALIBIBYR_FOS(numind+1,5) ! MECS/860B BSC Fossil
	  real ELOWNX(8:12,4)		        ! regional ELOWN for steel and paper  kpe added
	  real ELSALEX(8:12,4)				! ELSALE FOR STEEL AND PAPER, WHICH WERE PREVIOUSLY ONLY AVAILABLE NATIONALLY kpe added
	  
! data structure to hold information on planned additions compactly
      type plancap !  hold characteristics of each build in plancap.txt
        SEQUENCE   ! forces order/alignment given here--required for common block storage
        integer year         !         cogadd(iadd).year
        integer industry     ! cogadd(iadd).industry
        integer censusdiv    ! cogadd(iadd).censusdiv
        integer fuelind      ! c2ogadd(iadd).fuelind
        real gen             ! cogadd(iadd).gen
        real cap             ! cogadd(iadd).cap
        real thr             ! cogadd(iadd).thr
        real elc             ! cogadd(iadd).elc
        real grd             ! cogadd(iadd).grd
      end type plancap
      integer maxadd,nadds,iadd
      parameter(maxadd=100)
      type (plancap) :: cogadd(maxadd)  ! up to 50 allowed; increase if more records added next year

!  cogen market penetration assumptions

      integer nsys,nload
      parameter(nsys=8)        ! number of systems
      parameter(nload=8)       ! number of load segments

      real CogFuelPrice        !  Price for cogen system fuel
      real CogElecPrice        !  $/mmbtu Price at which cogenerated electricity is valued (ie., sale price or purchased price net of standby charges)
      real StandByFrac         !  Fraction of CogElecPrice representing standby charges
      real DollarYearCHP       !  Year CHP capital cost dollars are in (e.g., the 2020 update was in 2018$)
      real CogCapCostKW(nsys)  !  Capital cost/kw for the entire cogen system (not just electric system)
      real CapCostYearly(2003:endyr,nsys)   !  Capital cost/kw assumptions
      real ElecSizeMWH(nsys)   !  annual generation from the cogeneration system in mwh.
      real CogSizeKW(nsys)     !  Generating capacity of the cogen system in kw
      real CapFac(nsys)        !  Capacity factor of the cogeneration system
      real PowerSteam(nsys)    !  Ratio of electrical output (btus) to steam output (btus). or fraction elec out/fraction steam out
      real CHeatRate(nsys)     !  Btus in per unit of cogenerated electricity out (btus/kwh)
      real CHeatRateYearly(2003:endyr,nsys) !  heatrate assumptions by year, system
      real ElecGenEff(nsys)    !  Electric generation efficiency (electricity in btus/fuel in)
      real OverAllEff(nsys)    !  Overall efficiency of cogen system (useful energy out/fuel in)
      real OverAllEffYearly(2003:endyr,nsys) !  Overall efficiency by year
      real FuelUse(nsys)       !  Annual Fuel used by the Cogen system in million BTUs
      real SteamOutput(nsys)   !  Annual thermal heat output of the cogen system mmbtu

      real RapidCapCostYr(2003:endyr,nsys)     !  Capital cost/kw assumptions for HiTech runs
      real CRapidHeatRateYr(2003:endyr,nsys)   !  heatrate assumptions by year, system for HiTech runs
      real RapidOrAllEffYr(2003:endyr,nsys)    !  Overall efficiency by year for HiTech runs

      integer CogSys(nload)    !  Cogen system # (from 1 to nsys) to serve a given load segment
 !     real ThermalCap(nload)   !  Cogen thermal cap--selected to match average boiler size in a load segment
      real EBoilEff(nload)     !  ratio of useful heat out to heat in for the conventional boiler (not the cogen boiler)
      real BoilerCost(nload)   !  not used yet
      real Investment(nload)   !  Capital cost of the cogeneration system,  $
      real FuelCost(nload)     !  Annual cost of fuel for the cogen system ($)
!      real SteamLoad(nload)    !  Average Steam load within a load segment
      real ExistFuelUse(nload) !  Annual Fuel used by a conventional boiler to produce thermal energy equal to the cogen system
      real ExistFuelCost(nload)!  Annual cost of fuel for a conventional boiler
      real Elecvalue(nload)    !  Value of cogenerated electricity
      real IncrFuelCost(nload) !  Increase in fuel cost for cogeneration compared to conventional boiler
      real OperProfit(nload)   !  Savings/Earnings in fuel from the cogeneration system
      real CPayBack(nload)     !  Number of years of operprofit to payback cogen investment
      real EconFrac(nload)     !  Economic fraction based on payback and acceptance curve
      real Penetration(nload)  !  Annual Penetration Fraction

      real SteamSeg_Food(nload) ! Percent of Steam Loads by Load Segment , Food Industry (etc)
      real SteamSeg_Paper(nload)
      real SteamSeg_Chem(nload)
      real SteamSeg_Steel(nload)
      real SteamSeg_Other(nload)
      real SteamSeg_refin(nload)

      real AcceptFrac(13)      ! Fraction of firms willing to accept a payback period of N years or longer, n=0..12 (13 points on the 'curve')
      real AcceptFrac2(13)     ! Same as AcceptFrac, but applies to Largest Load Segment (used to distinguish merchant IPP from industrial
      real cogsteamhist(numind,4)    ! Steam generated by existing cogen as of last year available in exstcap.txt.  Assumed to remain constant.

      real CapCostMult(nsys)     ! Capital cost multiplier--used to implement policy options such as an invest tax credit. normally=1.
      integer*2 CapCostMultStart ! Starting year in which CapCostMult goes into effect
      integer*2 CapCostMultEnd   ! Starting year in which CapCostMult goes into effect

!====================================

! indcon
! AGGREGATION Variables
! i.e., TOTAL CONSUMPTION FOR MFG, NON-MFG HEAT AND POWER, FEEDSTOCKS
! CONSUMPTION IN EACH OF THE ENERGY INTENSIVE INDUSTRIES
! TOTAL CONSUMPTION BY FUEL BY CENSUS DIVISION, TOTAL CONSUMPTION BY FUEL
! BY CENSUS REGION

      REAL QTYMAIN(23,5)    ! Consumption of main fuel j in region k
      REAL QTYINTR(7,5)     ! Consumption of intermediate fuel j in region k
      REAL QTYRENW(9,5)     ! Consumption of renewable fuel j in region k
      REAL TQMAIN(23,5)     ! Total consumption of main fuel j in region k
      REAL TQINTR(7,5)      ! Total consumption for intermediate fuel k
      REAL TQRENW(9,5)      ! Total consumption of renewable fuel j in region k
                            ! see industrial code for fuel ordering

      real xelin(3,4)       ! accumulate totals for 3 electricity groups
      real xelinshr(3,4)    ! shares of total for 3 electricity groups
                            ! 1=primary,2=metal based,3=misc

!=============================================================================
! NEW CO2 VARIABLES TO TRACK C02 BY INDUSTRY AND Fuel

	  ! CO2 EMISSION FACTOR FOR CURRENT YEAR
	  REAL AGCO2(18,MNUMYR), MINECO2(18,MNUMYR), CONSTCO2(18,MNUMYR), FOODCO2(18,MNUMYR)
	  REAL PAPERCO2(18,MNUMYR), CHEMCO2(18,MNUMYR), GLASSCO2(18,MNUMYR), CEMENTCO2(18,MNUMYR)
	  REAL STEELCO2(18,MNUMYR), ALUMCO2(18,MNUMYR), FABMETALCO2(18,MNUMYR), MACHINECO2(18,MNUMYR)
	  REAL COMPUTECO2(18,MNUMYR), TRANEQUIPCO2(18,MNUMYR), ELECEQUIPCO2(18,MNUMYR), WOODPRODCO2(18,MNUMYR)
	  REAL PLASTICCO2(18,MNUMYR), BOMOTHCO2(18,MNUMYR), CO2EM(18,MNUMYR), REFCO2(18,MNUMYR)

      COMMON/CO2VARS/AGCO2, MINECO2, CONSTCO2, FOODCO2, PAPERCO2, CHEMCO2, GLASSCO2, CEMENTCO2, &
	            STEELCO2, ALUMCO2, FABMETALCO2, MACHINECO2, COMPUTECO2, TRANEQUIPCO2, ELECEQUIPCO2, &
				WOODPRODCO2, PLASTICCO2, BOMOTHCO2, CO2EM, REFCO2
!
!====================================
! Carbon-Accounting Industry Assumption
      real Carbshr(numind)      ! Share of each industry's fossil consumption subject to carbon allowance costs.
      real QtyByInd(18,numind)  ! sum of qtymain, qtyrenw into 18 reporting fuel categories by industry
      real clinkFac/0.12545/      ! factor to convert tons of clinker production to metric tons of C
      real CARBSHRCA(numind),CARBSHR_AB(numind,5)  ! Share of each industry's fossil consumption for AB32.
!============================
! pass cement-related and lime-related co2 process emissions from IND to EPM for use in GHG accounting
! used by epm.f:
      real co2_clink(MNUMYR,5) ! clinker process co2 emissions in metric tons C, by year and region
      real co2_lime(MNUMYR,5) ! lime production process co2 emissions in metric tons C, by year and region
      common/indepm/co2_clink,co2_lime
!==============================
! indbench
! BENCHMARKING - Related variables

! SUSAN SOME CHANGES TO BENCHMARKING RELATED VARIABLES
      INTEGER ISEDS        ! Option from file indrun:  1=Benchmark to SEDS, 0:don't benchmark
      REAL BF(MNUMYR,22,5)          !DEFINED WITH YEAR DIMENSION POT_2050 51 to MNUMYR
      REAL RBF(MNUMYR,8,5)          ! POT_2050 51 to MNUMYR
! BENCHFAC IS THE OLD WEXOG BENCHMARK FACTOR ARRAY. NEEDS REVISION
      REAL BENCHFAC(17,5) ! Benchmark factors for 15 main fuels and 2 biomass fuels by Census Division
      REAL STEOQ(STEOLastYr-6:STEOLastYr,21)  ! STEO History and projections by year, 21 fuel
      REAL BMFOVR(17,2008:2009)  ! Benchmark Override Array (fuel,year) (3/4/09-EDS)
      INTEGER ICALIBRATE
	  REAL HISTBF(70,22,4) ! BENCHMARK FACTORS READ IN FROM IBFACTRI.CSV
      REAL RHISTBF(70,8,4) ! RENEWABLE BENCHMARK FACTORS READ IN FROM IBFACTRI.CSV

! Define Data Type BUFYEAR to hold all input/output varying by industry and region for a single year
      TYPE COPY_BY_IND_REG
      SEQUENCE  ! forces order/alignment given here--required for common block storage
      REAL    ENPMQTY(23)
      REAL    ENPIQTY(7)
      REAL    ENPRQTY(9)
      REAL    PRODX
      REAL    PRODXLAG
      REAL    PRODVX
      REAL    PRODVXLAG
      REAL    EMPLX
      REAL    EMPLXLAG
      REAL    ENBINT(4,5)
      REAL    ENBQTY(5,5)
      REAL    ENSQTY(11)
      REAL    BSSHR(11)
      REAL    BSSHRLAG(11)
      REAL    STEMCUR
      REAL    STEMCURLAG
      REAL    COGSTEAM
      REAL    NONCOGSTEAM
      REAL    BIOSTEAM
      REAL    NONCOGFOSSTEAM
      REAL    FUELFOSSTEAM(11)
      REAL    COGBOILFUEL(11)
      REAL    ELOWN
      REAL    ELSALE
      REAL    GENFUEL(5)        ! CHP fuel consumption by fuel
      REAL    RPTGEN(5)         ! CHP generation by fuel GWH
      REAL    RPTCAP(5)         ! CHP capacity by fuel MW
      REAL    QTYMAIN(23)  ! these are for the copybuf commmands
      REAL    QTYINTR(7)
      REAL    QTYRENW(9)
      REAL    BYPBSCM(23)
      REAL    BYPBSCI(7)
      REAL    BYPBSCR(9)
      REAL    PRODRETR(maxstep)
      REAL    PRODCUR(4,maxstep)
      REAL    PRODLAG(4,maxstep)
      REAL    PRODFLOW(2,maxstep,MAXLINKS)
      REAL    ENPINT(3,15,maxstep)
      REAL    ENPINTLAG(3,15,maxstep)
      REAL    ENPQTY(4,16,maxstep)
      REAL    BYPINT(3,5,maxstep)
      REAL    BYPINTLAG(3,5,maxstep)
      REAL    BYPQTY(4,6,maxstep)
      REAL    IDLCAP(maxstep)
      REAL    IDLCAPLAG(maxstep)
      INTEGER INDMAX
      INTEGER MPASTP
      REAL    PHDRAT
      INTEGER INDDIR
      INTEGER IDVAL
      INTEGER IFSMAX
      INTEGER IFSLOC(11)
      INTEGER IFSBYP
      INTEGER IFSLOCBY(6)
      REAL    GENEQPHTRT(4)
      INTEGER NTMAX(maxstep)
      INTEGER IFMAX(maxstep+1)
      INTEGER IPASTP(maxstep,MAXLINKS)
      INTEGER IFLOC(15,maxstep+1)
      INTEGER ITYPE(15,maxstep)
      REAL    BCSC(3,15,maxstep)
      INTEGER IFBYP(maxstep)
      INTEGER IFLOCBY(10,maxstep)
      REAL    BYPCSC(3,5,maxstep)
      REAL    EINTER(3,15,maxstep)
      INTEGER NumRptGrps                  ! Number of Reporting SubGroups for Process Assembly Energy reporting (used in Chemicals for Subindustry rpt), max:11, min:0
      INTEGER NumRptGrpSteps(12)          ! Number of steps in each reporting SubGroup for P/A
      INTEGER RptGrpSteps(12,maxstep)     ! Identification of step numbers included in each reporting subgroup in P/A
      Character*24 RptGrpNames(12)        ! Reporting group names
      Character*24 RptGrpSName(12,maxstep+1)! Reporting labels for step names
      CHARACTER*40 INDNAME
      CHARACTER*24 INDSTEPNAME(maxstep+1)


 END TYPE COPY_BY_IND_REG

      TYPE (COPY_BY_IND_REG) :: COPYBUF(4,numind)

!  DECLARATIONS FOR FILE MANAGER ROUTINE.
!
      INTEGER FILE_MGR
      EXTERNAL FILE_MGR
      CHARACTER*18 FNAME
      LOGICAL NEW

      logical isinf
      external isinf

! Other
      INTEGER IR,ID,IF,I,J,YR,ibif
      REAL DPRCX(30,11,3) ! division prices by fuel, region+US, by Carbon-Adjusted(1),Unadjusted(2), Current Industry's average (3)
      REAL DCONX(30,11)
      CHARACTER*40 INAMECK(numind),INAME(numind),LINDNAME  ! for enprod reads in subr iedata
      integer IOS,IOSTAT

!*********************************************************************************AE
      REAL DPRCXLAG(30,11,3) ! LAGGED division prices by fuel, region+US, by Carbon-Adjusted(1),Unadjusted(2), Current Industry's average (3)

      
common/ind_easy/INDETTCBUS, INDC4TCBUS, INDPRTCBUS, INDPPTCBUS, INDDFTCBUS, INDRFTCBUS, INDMGTCBUS, &
                  INDFETCBUS, INDARTCBUS, INDLUTCBUS, INDPCTCBUS, INDWXTCBUS, INDABTCBUS, INDUOTCBUS, INDMSTCBUS, INDSNTCBUS, &
                  INDNGNUKUS, INDNGINX, INDZSAJQUS, INDCLYCBUS, INDCLKCBUS, INDCCNIBUS, INDEXICPUS, INDHVICBUS, INDHVCCBUS, INDWWICBUS, INDOWICBUS, INDPCEPCONB
      
    real INDETTCBUS(mnumyr)   ! Ethane/Ethylene Product Supplied
    real INDC4TCBUS(mnumyr)   ! Butanes/Butylenes Product Supplied
    real INDPRTCBUS(mnumyr)   ! Propane/Propylene Product Supplied
!    real INDC3TCPUS(mnumyr)   ! Propane Consumption (million barrels)
    real INDPPTCBUS(mnumyr)   ! Natural Gasoline (Pentanes Plus) Product Supplied
    Real INDDFTCBUS(mnumyr)   ! Distillate Fuel Oil Product Supplied
    Real INDRFTCBUS(mnumyr)    ! Residual Fuel Oil Product Supplied
    Real INDMGTCBUS(mnumyr)    ! Motor Gasoline Product Supplied
    Real INDFETCBUS(mnumyr)    ! Petrochemical Feedstocks Product Supplied
    Real INDARTCBUS(mnumyr)    ! Asphalt and Road Oil Product Supplied
    Real INDLUTCBUS(mnumyr)    ! Total lubricants consumed
    Real INDPCTCBUS(mnumyr)    ! Petroleum Coke Product Supplied
    Real INDWXTCBUS(mnumyr)    ! Total waxes consumed
    Real INDABTCBUS(mnumyr)    ! Aviation Gasoline Blend Components Refinery Input
    Real INDUOTCBUS(mnumyr)    ! Unfinished Oils Product Supplied
    Real INDMSTCBUS (mnumyr)   ! Miscellaneous petroleum products consumed
    Real INDSNTCBUS(mnumyr)    ! Special naphthas consumed
    Real INDNGNUKUS(mnumyr)    ! Btu/cubic foot natural gas, U.S. Total
    Real INDNGINX(mnumyr)      ! Natural Gas Consumption Industrial Sector, U.S. Total (Bcf/d)
    Real INDZSAJQUS(mnumyr)    ! Days in year
    Real INDCLYCBUS(mnumyr)    ! Other Industrial Coal Consumption
    Real INDCLKCBUS(mnumyr)    ! Coke Plants Coal Consumption
    Real INDCCNIBUS(mnumyr)    ! Coal coke net imports into the United States
    Real INDEXICPUS(mnumyr)    ! Electricity consumed by (i.e., sold to) the industrial sector
    Real INDHVICBUS(mnumyr)    ! Industrial sector consumption of conventional hydroelectric energy
    Real INDHVCCBUS(mnumyr)    ! Commercial sector consumption of conventional hydroelectric energy
    Real INDWWICBUS(mnumyr)    ! Industrial sector consumption of wood and wood waste biomass energy
    Real INDOWICBUS(mnumyr)    ! Industrial sector consumption of non-wood waste biomass energy (municipal solid waste)
    Real INDPCEPCONB(mnumyr)    ! Electricity sector consumption of petcoke
    
    REAL qcrdata(mnumyr, numind, 5)    ! coal data read in from Quarterly Coal Report file (ind_coal.csv); function of index year, industry, and census region
    REAL asmdata(mnumyr, numind, 5)    ! electicity data read in from Annual Survey of Manufacturers file (ind_electric.csv); function of index year, industry, and census region
    
!===============================================================================================
! END OF Global Declarations for Subroutine IND
!===============================================================================================

      end module i_

      SUBROUTINE IND
      use i_
      IMPLICIT NONE
!
!******
!  ASSIGN YEAR PARAMETERS.
!******
!     IBYR=2006          comment out for now POT_07/31/2013  indy starts in 2006, regardless,                      ! indy starts in 2006, regardless,
      FSTITER=CURITR                       ! Iter vars must be defined to initialize ICHEM
      LSTITER=FCRL


      Call INDEASY    ! Obtain STEO variables from STEOblock file
        !INDCLKCBUS(32)=407.0       ! Hardcode to fix weird STEO value. Eliminate this line for AEO2022. NSK 11/18/20

      
!**
! read cogeneration input files for all years (once).  Code is here so that 1990-2005 data will be included in output even
! though model starts in 2006
      call ircogen
!
      call addupcogs ! sum cogen data variables across fuels, regions, industries for the current year
      CALL INDCGN    ! copy cogen data variables to NEMS global variables for the current year.  Because this
                     ! is done prior to the actual model start year, and is done for the reporting loop,
                     ! assignments to cgindcap, cgindgen, and cgindq will override history reads of these vars within the EMM


      IF(CURCALYR.LT. ibyr2) then
! zero reporting variables prior to base year

        MANHP(:,:,curiyr)    =0.
        NONHP(:,:,curiyr)    =0.
        AGCON(:,:,curiyr)    =0.
        CONSTCON(:,:,curiyr) =0.
        MINECON(:,:,curiyr)  =0.
        FOODCON(:,:,curiyr)  =0.
        PAPERCON(:,:,curiyr) =0.
        CHEMCON(:,:,curiyr)  =0.
        GLASSCON(:,:,curiyr) =0.
        CEMENTCON(:,:,curiyr)=0.
        STEELCON(:,:,curiyr) =0.
        ALUMCON(:,:,curiyr)  =0.
        FABMETALCON(:,:,curiyr)=0.
        MACHINECON(:,:,curiyr)=0.
        COMPUTECON(:,:,curiyr)=0.
        TRANEQUIPCON(:,:,curiyr)=0.
        ELECEQUIPON(:,:,curiyr)=0.
        WOODPRODCON(:,:,curiyr)=0.
        PLASTICCON(:,:,curiyr)=0.
        BOMOTHCON(:,:,curiyr)=0.
! Fill global variables with SEDS historical data
! Peter added pentanes plus to lpg feedstock.  July 9 2014
! 9 lines down ... QSPPIN.  Previously this pentanes plus
! was included in misc petroleum.  It is now included in LPG
! feedstock ... where it should be.

        DO ID=1,11
           QELIN(ID,curiyr)=QSELIN(ID,curiyr)
           QGFIN(ID,curiyr)=QSGFIN(ID,curiyr)
           QGIIN(ID,curiyr)=QSGIIN(ID,curiyr)
           QNGIN(ID,curiyr)=QSNGIN(ID,curiyr)
           QLPIN(ID,curiyr)=QSLPIN(ID,curiyr)
           QCLIN(ID,curiyr)=QSCLIN(ID,curiyr)
           QMCIN(ID,curiyr)=QSMCIN(ID,curiyr)
           QRLIN(ID,curiyr)=QSRSIN(ID,curiyr)
           QDSIN(ID,curiyr)=QSDSIN(ID,curiyr)
           QLGIN(ID,curiyr)=QSLGIN(ID,curiyr)+QSPPIN(ID,curiyr)
           QMGIN(ID,curiyr)=QSMGIN(ID,curiyr)
           QSGIN(ID,curiyr)=QSSGIN(ID,curiyr)
           QPCIN(ID,curiyr)=QSPCIN(ID,curiyr)
           QASIN(ID,curiyr)=QSASIN(ID,curiyr)
           QOTIN(ID,curiyr)=QSOTIN(ID,curiyr)
           QPFIN(ID,curiyr)=QSPFIN(ID,curiyr)
           QKSIN(ID,curiyr)=QSKSIN(ID,curiyr)
           QLUIN(ID,curiyr)=QSLUIN(ID,curiyr)
           QHOIN(ID,curiyr)=QSHOIN(ID,curiyr)
           QBMIN(ID,curiyr)=QSBMIN(ID,curiyr)
           QMSIN(ID,curiyr)=QSMSIN(ID,curiyr)
           QPRIN(ID,curiyr)=QSPRIN(ID,curiyr)
           
        ENDDO
      ENDIF

      if(curcalyr.lt.ibyr2) return   ! Exit industrial if earlier than base year

      IYR=CURCALYR                         ! calender year
      IEYR=LASTYR+baseyr-1                 ! typically ijumpcalyr, but can be sooner

!******
!  ASSIGN ITERATION PARAMETERS.
!  Except for iter vars which had to be defined earlier
!******
! ALWAYS OPEN THESE FILES:
      FNAME='INDBENCH           '
      NEW=.TRUE.
      IUNITBENCH=FILE_MGR('O',FNAME,NEW)

	  FNAME='IBFACTRO           '
	  NEW=.TRUE.
	  IFACTOUT=FILE_MGR('O',FNAME,NEW)

!	OPEN BENCHMARK FACTOR INPUT FILE
	  FNAME='IBFACTRI           '
      NEW=.FALSE.
      IFACTIN=FILE_MGR('O',FNAME,NEW)

      FNAME='IFEEDDBG           '
      NEW=.TRUE.
      IFEEDOUT=FILE_MGR('O',FNAME,NEW)

! OPEN THESE FILES IF THE SCEDES FLAG PRTDBGI IS SET TO 2 OR GREATER
! THESE FILES ARE BIG AND ONLY NEEDED WHEN DOING SERIOUS DEBUGGING

      IF (PRTDBGI .GE. 2) THEN    !SUSAN_UPDATE
         FNAME='INDOUTF            '
         NEW=.TRUE.
         IUNITOUTF=FILE_MGR('O',FNAME,NEW)
!        CALL CHECK_FOR_STUFF  THIS MAY HAVE BEEN CALLED IN WRONG SPOT
      ENDIF

      FNAME='INDBUG             '
      NEW=.TRUE.
      IUNITBUG=FILE_MGR('O',FNAME,NEW)
!     CALL CHECK_CON_VARS   DITTO COMMENT ABOVE

! NCRL FLAG INDICATES THAT THE YEAR PROCESSING IS DONE
      IF(NCRL.EQ.1) THEN
        IF (ICALIBRATE .EQ. 1) CALL CALIBRATE
        CALL CO2CALC

        if (curcalyr.gt.ibyr2) then
            CALL INDUSREPORT
        endif
        IF (PRTDBGI .GE. 2) THEN
           CALL CHECK_FOR_STUFF
           CALL CHECK_CON_VARS
        ENDIF

        RETURN
      ENDIF

      IF ((curcalyr .eq. ibyr2) .and. (curitr .eq. 1)) then
           call IS_GETDATA !read ibyr2 MECS data
           call READ_IDMinput ! mining inputs -- move to workbook??
      endif

      CALL Setup_Mac_and_Price


!******
!  CALL THE INDUSTRIAL MODEL CALCULATIONS.
!******

      CALL ISEAM
      

!******
!  PASS THE RESULTS TO THE INTEGRATING SYSTEM.
!
!  WEXOG PASSES CONSUMPTION VALUES TO NEMS.
!  WEXOG ALSO SAVES ALL INPUT VALUES FROM NEMS TO A BINARY FILE.
!******

      CALL WEXOG

!******
!  FORMAT STATEMENTS USED IN SUBROUTINE.
!******

 902  FORMAT(1X,/)
 904  FORMAT(6X,11F8.1)
 905  FORMAT(6X,11F8.3)
 900  CONTINUE

      RETURN
      end subroutine ind
 ! The Contains statement causes the rest of the subroutines in this file to
 ! share the declarations in Subroutine IND and be callable only from within IND.

  !CONTAINS

    Subroutine Setup_Mac_and_Price
    use i_
    implicit none

      include 'ghgrep'

! Setups up and copies macro, prices, SEDS, and lagged quantity variables into
! arrays compatible with the industrial regional and sectoral structure.

       real ScalingFac(11)
       save ScalingFac
       integer iy
       integer iyy
       real ResidAdd(11)
       integer CoReg
       integer division(0:NDREG)/11,1,2,5,5,5,3,3,6,6,4,4,7,8,8,8,9/

       real emis(18)
       real C_CO2_FACTOR

       integer RTOVALUE,AB32SW
	   INTEGER ILOOP
       external RTOVALUE

!  Check runtime option to turn AB32SW switch for implementation of AB32 cap-and-trade in State of California.
!  The default setting is ON (1).
!
      AB32SW=RTOVALUE('AB32SW  ',1)

!  ASSIGN GROSS OUTPUT FOR EACH INDUSTRY.
!  If a variable is in physical units it is indicated in the comment

      chemship(:,:,curcalyr)=0.
      foodship(:,:,curcalyr)=0.    ! POT_07/31/2013
!     scgmisc(:,curiyr)=0.

      !EDS 4/9/2010
      !Calculate forest residues sold in renew module (trilBTU * $/mmBTU) by division (from coal regions)
      !Uses price in 87$ and then inflates to current macro $ (yr=2005 for AEO2011)
      ResidAdd(:)=0
      DO CoReg=0,NDREG
        ID=division(CoReg)
        ResidAdd(ID)=ResidAdd(ID)+QBMASCL(2,CoReg,curiyr)*PBMASCL(2,CoReg,curiyr)*MC_JPGDP(16)/1000
      ENDDO

      ! SUSAN
      ! MC_REVIND ADJUSTED BY MC_REVIND_ADJ TO CONVERT $2009 BACK TO $2005
      ! UNTIL A MORE PERMANENT FIX IS DONE ... UPDATING ITECH INPUT FILE
      !
	  !SUSAN
!	  WRITE(IUNITBENCH,*) "MC_REVIND_ADJ" , mc_revind_adj(1:48), "curiyr = ", curiyr
	!  WRITE(IUNITBENCH,*) "   "
	 ! write(IUNITBUG,*) 'debug outind,',SUM(MC_REVIND(1:2,10,curiyr)),',',SUM(MC_REVIND(3:4,10,curiyr)), &
	  !               ',',SUM(MC_REVIND(5:7,10,curiyr)),',',SUM(MC_REVIND(8:9,10,curiyr)),',',curiyr+1989
      DO 5 ID=1,11
        ir=region(id)

    OUTIND(1,ID)=MC_REVIND(ID,42,curiyr)  * MC_REVIND_ADJ(42)        ! CROPS
    !Add resid from above to non-crop production, EDS 4/9/2010
        OUTIND(2,ID)=MC_REVIND(ID,44,curiyr) * MC_REVIND_ADJ(44) + &    ! OTHER AG
                     MC_REVIND(ID,43,curiyr) * MC_REVIND_ADJ(43) + &    ! ANIMAL PRODUCTION
                     ResidAdd(ID)                             ! FOREST RESIDUE ABOVE DO NOT HAVE ADJUSTMENT FACTOR
        OUTIND(3,ID)=MC_REVIND(ID,45,curiyr) * MC_REVIND_ADJ(45)        ! COAL MINING
        OUTIND(4,ID)=MC_REVIND(ID,46,curiyr) * MC_REVIND_ADJ(46)        ! OIL & GAS MINING
        OUTIND(5,ID)=MC_REVIND(ID,47,curiyr) * MC_REVIND_ADJ(47)    ! METAL & OTHER MINING
        OUTIND(6,ID)=MC_REVIND(ID,48,curiyr) * MC_REVIND_ADJ(48)        ! CONSTRUCTION

        OUTIND(7,ID)=MC_REVIND(ID,1,curiyr) * MC_REVIND_ADJ(1) 			! FOOD
        OUTIND(8,ID)=MC_REVIND(ID,10,curiyr) * MC_REVIND_ADJ(10)        ! PAPER (TONS)!
        IF (curcalyr.eq.ibyr2) OUTINDIBYR(ID)=MC_REVIND(ID,10,curiyr) * MC_REVIND_ADJ(10)        ! PAPER (TONS) ibyr2
        OUTIND(9,ID)=MC_REVIND(ID,15,curiyr) * MC_REVIND_ADJ(15) + &    ! BASIC INORGANIC CHEM
                     MC_REVIND(ID,16,curiyr) * MC_REVIND_ADJ(16) + &    ! BASIC ORGANIC CHEM
                     MC_REVIND(ID,18,curiyr) * MC_REVIND_ADJ(18) + &    ! RESINS AND SYNTHETICS
                     MC_REVIND(ID,19,curiyr) * MC_REVIND_ADJ(19)        ! AGRICULTURE CHEMICALS

        if(ir.ne.0) then
          chemship(1,ir,curcalyr)=chemship(1,ir,curcalyr) + &
             MC_REVIND(ID,15,curiyr) * MC_REVIND_ADJ(15)  ! INORGANIC
          chemship(2,ir,curcalyr)=chemship(2,ir,curcalyr) + &
             MC_REVIND(ID,16,curiyr) * MC_REVIND_ADJ(16)  ! ORGANIC
          chemship(3,ir,curcalyr)=chemship(3,ir,curcalyr) + &
             MC_REVIND(ID,18,curiyr) * MC_REVIND_ADJ(18)  ! RESINS AND SYNTHETICS
          chemship(4,ir,curcalyr)=chemship(4,ir,curcalyr) + &
             MC_REVIND(ID,19,curiyr) * MC_REVIND_ADJ(19)  ! AG CHEM
          chemship(5,ir,curcalyr)=chemship(5,ir,curcalyr) + &
		      OUTIND(9,ID)
        endif

! Add the food subindustry shipments to obtain the total.  Then, sum food shipments for the regions.  POT_07/31/2013

        if(ir.ne.0) then
          foodship(1,ir,curcalyr)=foodship(1,ir,curcalyr) + &
		      MC_REVIND(ID,2,curiyr) * MC_REVIND_ADJ(2) ! Grain and Oil Seed Milling
          foodship(2,ir,curcalyr)=foodship(2,ir,curcalyr) + &
     		  MC_REVIND(ID,3,curiyr) * MC_REVIND_ADJ(3) ! Dairy Products
          foodship(3,ir,curcalyr)=foodship(3,ir,curcalyr) + &
		      MC_REVIND(ID,4,curiyr) * MC_REVIND_ADJ(4) ! Animal Slaughter and Seafood Products
          foodship(4,ir,curcalyr)=foodship(4,ir,curcalyr) + &
		      MC_REVIND(ID,5,curiyr) * MC_REVIND_ADJ(5) ! Other Food Products
          foodship(5,ir,curcalyr)=foodship(5,ir,curcalyr) + &
     		  OUTIND(7,ID)            ! Total for Food
        endif
! POT_07/31/2013 END! Add the food subindustry shipments to obtain the total.  Then, sum food shipments for the regions.  PTO

        OUTIND(10,ID)=MC_REVIND(ID,28,curiyr) * MC_REVIND_ADJ(28)      ! GLASS (TONS)
        OUTIND(12,ID)=MC_REVIND(ID,33,curiyr) * MC_REVIND_ADJ(33) + MC_REVIND(ID,26,curiyr) * MC_REVIND_ADJ(26)  * (1 - 0.8919)   ! IRON & STEEL & coke plants
        OUTIND(13,ID)=MC_REVIND(ID,34,curiyr) * MC_REVIND_ADJ(34)      ! PRIMARY ALUM

!  METALS-BASED DURABLES  (NAICS 332 to 336)

        OUTIND(14,ID)=MC_REVIND(ID,36,curiyr) * MC_REVIND_ADJ(36)      ! fabricated metal products
        OUTIND(15,ID)=MC_REVIND(ID,37,curiyr) * MC_REVIND_ADJ(37)      ! machinery
        OUTIND(16,ID)=MC_REVIND(ID,38,curiyr) * MC_REVIND_ADJ(38)      ! computer & electronics
        OUTIND(17,ID)=MC_REVIND(ID,39,curiyr) * MC_REVIND_ADJ(39)      ! transport equipment
        OUTIND(18,ID)=MC_REVIND(ID,40,curiyr) * MC_REVIND_ADJ(40)      ! electrical equipment

!  Balance of Manufacturing
!    19   BOM-wood products
!    20   BOM-plastics
!    21   BOM-other

        OUTIND(19,ID)=MC_REVIND(ID, 8,curiyr) * MC_REVIND_ADJ( 8)              ! lumber
        OUTIND(20,ID)=MC_REVIND(ID,27,curiyr) * MC_REVIND_ADJ(27)              ! plastics

        OUTIND(21,ID)=MC_REVIND(ID, 6,curiyr) * MC_REVIND_ADJ( 6)  + &         ! tobacco
                      MC_REVIND(ID, 7,curiyr) * MC_REVIND_ADJ( 7)  + &         ! textiles
                      MC_REVIND(ID, 9,curiyr) * MC_REVIND_ADJ( 9)  + &         ! furniture
                      MC_REVIND(ID,14,curiyr) * MC_REVIND_ADJ(14)  + &         ! printing
                      MC_REVIND(ID,20,curiyr) * MC_REVIND_ADJ(20)  + &         ! other chemicals - this might be the whole thing
                      MC_REVIND(ID,26,curiyr) * MC_REVIND_ADJ(26)  * 0.8919 + &        ! other pet, coal  - this portion of mcrevind 26 NOT coke plants, which go to steel
					  MC_REVIND(ID,32,curiyr) * MC_REVIND_ADJ(32)  + &  	   ! total other no more 0.982 because we have lime separate - kpe 10/13
                      MC_REVIND(ID,35,curiyr) * MC_REVIND_ADJ(35)  + &         ! other metals
                      MC_REVIND(ID,41,curiyr) * MC_REVIND_ADJ(41)              ! misc mfg

! POT_ibyr2 modified this code to execute for BASEYEAR using MC_REVIND
! New sub-industry breakouts (ESE 10/4/2011)
        OUTIND(22,ID)=MC_REVIND(ID,30,curiyr) * MC_REVIND_ADJ(30)       ! CEMENT
        OUTIND(23,ID)=MC_REVIND(ID,31,curiyr) * MC_REVIND_ADJ(31)       ! LIME
        OUTIND(11,ID)=OUTIND(22,ID) + OUTIND(23,ID)                     ! CEMENT & LIME (TONS) - kpe what is this tons business? arent these $$?
        IF(ID.EQ.11) LIMEOUTPUT(curiyr) = OUTIND(23,ID)
! For 2009 record Lime base year production for indexing
        IF (curcalyr.eq.ibyr2) THEN                   ! POT_ibyr2 From 2006 to ibyr2
            LIMEIBYR=MC_REVIND(ID,31,ICURIYR2) * MC_REVIND_ADJ(31)
        ENDIF
! For 2006 record Cement base year production for indexing
        IF (curcalyr.eq.ibyr2) THEN                   ! POT_ibyr2 From 2006 to ibyr2
             CEMENTIBYR=MC_REVIND(ID,30,ICURIYR2)* MC_REVIND_ADJ(30)                ! POT_ibyr2 From OUTIND to MC_REVIND POT_ibyr2
        ENDIF
! For 2006 record Aluminum base year production for indexing
        IF (curcalyr.eq.ibyr2) THEN                   ! kpe - updated to 2014 shipments value instead of 2006  10/13/17. POT_ibyr2 From 2006 to ibyr2
             ALUMIBYR=MC_REVIND(ID,34,ICURIYR2) * MC_REVIND_ADJ(34)           !td added for aluminum, POT_ibyr2 OUTIND to MC_REVIND
           ENDIF
! For 2006 record Glass base year production for indexing
        IF (curcalyr.eq.ibyr2) THEN                   ! POT_ibyr2 From 2006 to ibyr2
            GLASSIBYR(1)=MC_REVIND(ID,28,ICURIYR2) * MC_REVIND_ADJ(28)    ! td added for glass, POT_ibyr2 from OUTIND TO MC_REVIND
             call GL_shipping
            GLASSIBYR(2)=GL_ship(1)
            GLASSIBYR(3)=GL_ship(2)
            GLASSIBYR(4)=GL_ship(3)
            GLASSIBYR(5)=GL_ship(4)
        endif

! Old code for emissions now commented (ESE 10/4/2011)
!      if(ir.ne.0) then
!         SCGMisc(ir,curiyr)=SCGMisc(ir,curiyr) + MC_REVIND(ID,32,curiyr) ! Miscellaneous SCG
!      endif

!***************************************************************************AE
! Code added for chemical model
! Code added by Amelia Elson starting May 26, 2009
! Separate printing industry
!
!         xindpr(ID)=MC_REVIND(ID,14,curiyr) * MC_REVIND_ADJ(14) ! printing
!
!***************************************************************************end AE
   !SUSAN CHECK OUTPUT
    IF (ID .eq. 11) THEN
      DO ILOOP=1, 23
!      WRITE(IUNITBENCH,*) " INDUSTRY NUMBER = ", ILOOP," OUTIND = ",OUTIND(ILOOP,11)
!      WRITE(IUNITBENCH,*) " "
      ENDDO
    ENDIF


   5  CONTINUE

!******
!  ASSIGN EMPLOYMENT VALUES FOR EACH INDUSTRY.
!  Revise to use more detailed values from macro model
!  Order empind in the same order as the industrial subsectors POT_EMPLOYMENT CENSUS 2012 percent employment to glass,cement,Iron&steel,and Aluminum
!******
      DO 10 ID=1,11                       ! POT_MACRO convert MC_EMPNA to changed index.
        EMPIND(1,ID)=MC_EMPNA(ID,20,curiyr)     !Agricultural Crops, NAICS 111
        EMPIND(2,ID)=MC_EMPNA(ID,21,curiyr)     !Agricultural Other, NAICS 112-115
        EMPIND(3,ID)=MC_EMPNA(ID,22,curiyr)     !Coal Mining, NAICS 2121
        EMPIND(4,ID)=MC_EMPNA(ID,23,curiyr)     !Oil and Gas Mining, NAICS 211, 213
        EMPIND(5,ID)=MC_EMPNA(ID,24,curiyr)     !Metal and Other Mining, NAICS 2122, 2123
        EMPIND(6,ID)=sum(MC_EMPNA(ID,25:27,curiyr))     !Construction, NAICS 23
        EMPIND(7,ID)=MC_EMPNA(ID,1,curiyr)      !Food, NAICS 311
        EMPIND(8,ID)=MC_EMPNA(ID,6,curiyr)      !Paper, NAICS 322
        EMPIND(9,ID)=MC_EMPNA(ID,8,curiyr)      !Bulk Chemicals, NAICS 3251, 3252, 3253
        EMPIND(10,ID)=MC_EMPNA(ID,12,curiyr)*0.2753   !Nonmetallic minerals (was Glass), NAICS 327
        EMPIND(11,ID)=MC_EMPNA(ID,12,curiyr)*0.0482    !Nonmetallic minerals (was Cement and lime), NAICS 327
        EMPIND(12,ID)=MC_EMPNA(ID,13,curiyr)*0.3822   !Primary metals (was Iron and Steel), NAICS 331
        EMPIND(13,ID)=MC_EMPNA(ID,13,curiyr)*0.141    !Primary metals (was Aluminum), NAICS 331
        EMPIND(14,ID)=MC_EMPNA(ID,14,curiyr)    !Fabricated Metal, NAICS 332
        EMPIND(15,ID)=MC_EMPNA(ID,15,curiyr)    !Machinery, NAICS 333
        EMPIND(16,ID)=MC_EMPNA(ID,16,curiyr)    !Computer and Electronic, NAICS 334
        EMPIND(17,ID)=MC_EMPNA(ID,17,curiyr)    !Transportation Equipment, NAICS 336
        EMPIND(18,ID)=MC_EMPNA(ID,18,curiyr)    !Electrical Equipment, Appliances, Components, NAICS 335
        EMPIND(19,ID)=MC_EMPNA(ID,4,curiyr)     !Wood Products, NAICS 321
        EMPIND(20,ID)=MC_EMPNA(ID,11,curiyr)    !Plastic and Rubber Products, NAICS 326
        EMPIND(21,ID)=MC_EMPNA(ID,2,curiyr) + & !BOM Other, beverages and tobacco, NAICS 312
                     MC_EMPNA(ID,3,curiyr)  + & !BOM Other, textiles, apparel, leather, NAICS 313-316
                     MC_EMPNA(ID,5,curiyr)  + & !BOM Other, furniture, NAICS 337
                     MC_EMPNA(ID,7,curiyr)  + & !BOM Other, printing, NAICS 323
                     MC_EMPNA(ID,9,curiyr)  + & !BOM Other, other chemicals, NAICS 3254-3259
                     MC_EMPNA(ID,10,curiyr) + & !BOM Other, petroleum and coal, NAICS 324
                     MC_EMPNA(ID,19,curiyr)     !BOM Other, miscellaneous, NAICS 339
 10   CONTINUE

      C_CO2_FACTOR = 1.
!     IF (TRIM(CARBON_OR_2) .EQ. 'co2') C_CO2_FACTOR = 44. / 12.

!*****
!  Overrides for prices for Census Division 9 when running AB32 cap-and-trade.
!*****

!  ASSIGN NEMS PRICES TO IND VARIABLES  (from epmMPLBK--alternate to MPBLK with different variable names)
      DO ID=1,11
        ibif=1
        DPRCX(1,ID,ibif)=aELIN(ID,curiyr)
        DPRCX(2,ID,ibif)=aELIN(ID,curiyr)
        DPRCX(3,ID,ibif)=aGFIN(ID,curiyr)
        DPRCX(4,ID,ibif)=aGIIN(ID,curiyr)
        DPRCX(5,ID,ibif)=aGFIN(ID,curiyr)
        DPRCX(6,ID,ibif)=aLPIN(ID,curiyr)
        DPRCX(7,ID,ibif)=aCLIN(ID,curiyr)
        DPRCX(8,ID,ibif)=aMCIN(ID,curiyr)
        DPRCX(9,ID,ibif)=aMCIN(ID,curiyr)
        DPRCX(10,ID,ibif)=aRLIN(ID,curiyr)
        DPRCX(11,ID,ibif)=aDSIN(ID,curiyr)
        DPRCX(12,ID,ibif)=aLGIN(ID,curiyr)
        DPRCX(13,ID,ibif)=aLGINPF(ID,curiyr)  ! the adjusted lpg feed price
        DPRCX(14,ID,ibif)=aMGIN(ID,curiyr)
        DPRCX(15,ID,ibif)=aRSIN(ID,curiyr)
        DPRCX(16,ID,ibif)=aPCIN(ID,curiyr)
        DPRCX(17,ID,ibif)=aASIN(ID,curiyr)
        DPRCX(18,ID,ibif)=aRSIN(ID,curiyr)
        DPRCX(19,ID,ibif)=aPFIN(ID,curiyr)
        DPRCX(20,ID,ibif)=aKSIN(ID,curiyr)
        DPRCX(21,ID,ibif)=aRSIN(ID,curiyr)
        DPRCX(22,ID,ibif)=aOTIN(ID,curiyr)

        if(ID.eq.9.and.fcrl.eq.1) write(6,'(5x,a,22(f6.2,2x),2x,i4)') '==== NEMS adj price in $2012= ', DPRCX(1:22,ID,ibif)*MC_JPGDP(26), curcalyr

!  ASSIGN EMISSION COEFFICIENT TO EACH FUEL, as part of implementing AB32 cap-and-trade

! note that carbon emission factors only defined from 95 on, so use 95 for prior years

! emis(fuel) are in million tonnes carbon per quad. Since there are 10^9 MMBTUs in a Quad,
!    and 10^9 kg in one million metric tons, these cancel out so that the emis(fuel) factors above when
!    multiplied by variable ab_allow_p (California only) are equal to 87$/kg MMBTU
        IF(AB32SW.EQ.1.AND.CURCALYR.GE.ibyr2) then           ! POT_ibyr2
          iyy=max(curiyr,6)
!         emis(1)=em_elec(8,11,icy)/qelas(11,iy)       ! elec note: qelas in quads here
          emis(2)=engin(iyy)   * C_CO2_FACTOR          ! ngas
          emis(3)=eclin(iyy)   * C_CO2_FACTOR          ! steam coal
          emis(4)=emcin(iyy)   * C_CO2_FACTOR          ! met coal
          emis(5)=eclin(iyy)   * C_CO2_FACTOR          ! net coke import (steel only)
          emis(6)=erlin(iyy)   * C_CO2_FACTOR          ! resid (low sulphur)
          emis(7)=edsin(iyy)   * C_CO2_FACTOR          ! distillate
          emis(8)=elgin(iyy)   * C_CO2_FACTOR          ! liquid petrol gases
          emis(9)=emgin(iyy)   * C_CO2_FACTOR          ! motor gasoline
          emis(10)=esgin(iyy)  * C_CO2_FACTOR          ! still gas (refine only)
          emis(11)=epcin(iyy)  * C_CO2_FACTOR          ! petroleum coke
          emis(12)=0.0         * C_CO2_FACTOR          ! asphalt, all sequestered
          emis(13)=epfin(iyy)  * C_CO2_FACTOR          ! petroleum feedstock
          emis(14)=eksin(iyy)  * C_CO2_FACTOR          ! kerosene
          emis(15)=eotin(iyy)  * C_CO2_FACTOR          ! other ind
          emis(16)=enqngpf(iyy)  * C_CO2_FACTOR        ! nat gas feed stocks
          emis(17)=enqlgpf(iyy)  * C_CO2_FACTOR        ! lpg feedstock
          emis(18)=0.            * C_CO2_FACTOR        ! renewables, all sequestered

          if(ID.eq.11 .and.prtdbgi.gt.1) write(6,'(5x,a,f10.6,a,i4)') '==== AB32 Allowance price =',ab_allow_p(curiyr)*1.0E3,' in 87$/tCeq ', curcalyr

          emis(1)=sum(em_elec(8,8:9,(curiyr+baseyr-1)))/sum(qelas(8:9,max(curiyr,6)))
          DPRCX(1,9,ibif)=aELIN(9,curiyr)+0.*emis(1)*ab_allow_p(curiyr)   ! electricity. Marked-up for carbon in EMM.
          DPRCX(2,9,ibif)=aELIN(9,curiyr)+0.*emis(1)*ab_allow_p(curiyr)   ! not used. Marked-up for carbon in EMM.
          DPRCX(3,9,ibif)=aGFIN(9,curiyr)+emis(2)*ab_allow_p(curiyr)      ! NG core (PA and BLD)
          DPRCX(4,9,ibif)=aGIIN(9,curiyr)+emis(2)*ab_allow_p(curiyr)      ! NG non-core (BSC)
          DPRCX(5,9,ibif)=aGFIN(9,curiyr)+emis(16)*ab_allow_p(curiyr)     ! NG feedstock
          DPRCX(6,9,ibif)=aLPIN(9,curiyr)+emis(2)*ab_allow_p(curiyr)      ! NG L&P
          DPRCX(7,9,ibif)=aCLIN(9,curiyr)+emis(3)*ab_allow_p(curiyr)      ! steam coal
          DPRCX(8,9,ibif)=aMCIN(9,curiyr)+emis(4)*ab_allow_p(curiyr)      ! met coal = coking coal
          DPRCX(9,9,ibif)=aMCIN(9,curiyr)+emis(5)*ab_allow_p(curiyr)      ! for coke imports
          DPRCX(10,9,ibif)=aRLIN(9,curiyr)+emis(6)*ab_allow_p(curiyr)     ! residual fuel, low sulfur
          DPRCX(11,9,ibif)=aDSIN(9,curiyr)+0.*emis(7)*ab_allow_p(curiyr)     ! distillate. Marked-up for carbon in LFMM.
          DPRCX(12,9,ibif)=aLGIN(9,curiyr)+0.*emis(8)*ab_allow_p(curiyr)     ! LPG H&P. Marked-up for carbon in LFMM.
          DPRCX(13,9,ibif)=aLGINPF(9,curiyr)+0.0*emis(17)*ab_allow_p(curiyr) ! the adjusted lpg feed price. Marked-up for carbon in LFMM.
          DPRCX(14,9,ibif)=aMGIN(9,curiyr)+0.*emis(9)*ab_allow_p(curiyr)     ! mogas. Marked-up for carbon in LFMM.
          DPRCX(15,9,ibif)=aRSIN(9,curiyr)+emis(10)*ab_allow_p(curiyr)    ! still gas
          DPRCX(16,9,ibif)=aPCIN(9,curiyr)+emis(11)*ab_allow_p(curiyr)    ! pet coke
          DPRCX(17,9,ibif)=aASIN(9,curiyr)+0.*ab_allow_p(curiyr)          ! asphalt and road oil
          DPRCX(18,9,ibif)=aRSIN(9,curiyr)+emis(6)*ab_allow_p(curiyr)     ! Residual Fuel (average)
          DPRCX(19,9,ibif)=aPFIN(9,curiyr)+emis(13)*ab_allow_p(curiyr)    ! Petrochemical Feedstocks
          DPRCX(20,9,ibif)=aKSIN(9,curiyr)+0.*emis(14)*ab_allow_p(curiyr)    ! Kerosene. Marked-up for carbon in LFMM.
          DPRCX(21,9,ibif)=aRSIN(9,curiyr)+emis(13)*ab_allow_p(curiyr)    ! other feedstock
          DPRCX(22,9,ibif)=aOTIN(9,curiyr)+emis(15)*ab_allow_p(curiyr)    ! Other Petroleum

          if(ID.eq.11.and.fcrl.eq.1) write(6,'(5x,a,22(f6.2,2x),2x,i4)') '==== AB32 adj price in $2012= ', DPRCX(1:22,9,ibif)*MC_JPGDP(26), curcalyr
          if(ID.eq.11.and.prtdbgi.gt.1) write(6,'(5x,a,15(f10.6,2x),2(1x,i4))') '==== AB32 carbon price adder = ',emis(1:15)*ab_allow_p(curiyr), curcalyr, curiyr
          if(ID.eq.11.and.prtdbgi.gt.1) write(6,'(5x,a,15(f10.6,2x),2x,i4)') '==== AB32 emission factor from EMEBLK = ',emis(1:15), curcalyr
        ENDIF

! Unadjusted Prices:  for "Bifurcated" carbon allowance scheme where some covered; some not.
!  These are from the unadjusted price common block, MPBLK
        ibif=2
        DPRCX(1,ID,ibif)=PELIN(ID,curiyr)
        DPRCX(2,ID,ibif)=PELIN(ID,curiyr)
        DPRCX(3,ID,ibif)=PGFIN(ID,curiyr)
        DPRCX(4,ID,ibif)=PGIIN(ID,curiyr)
        DPRCX(5,ID,ibif)=PGFIN(ID,curiyr)
        DPRCX(6,ID,ibif)=PLPIN(ID,curiyr)
        DPRCX(7,ID,ibif)=PCLIN(ID,curiyr)
        DPRCX(8,ID,ibif)=PMCIN(ID,curiyr)
        DPRCX(9,ID,ibif)=PMCIN(ID,curiyr)
        DPRCX(10,ID,ibif)=PRLIN(ID,curiyr)
        DPRCX(11,ID,ibif)=PDSIN(ID,curiyr)
        DPRCX(12,ID,ibif)=PLGIN(ID,curiyr)
        DPRCX(13,ID,ibif)=PLGINPF(ID,curiyr)  ! use the lpg feed price from pmore
        DPRCX(14,ID,ibif)=PMGIN(ID,curiyr)
        DPRCX(15,ID,ibif)=PRSIN(ID,curiyr)
        DPRCX(16,ID,ibif)=PPCIN(ID,curiyr)
        DPRCX(17,ID,ibif)=PASIN(ID,curiyr)
        DPRCX(18,ID,ibif)=PRSIN(ID,curiyr)
        DPRCX(19,ID,ibif)=PPFIN(ID,curiyr)
        DPRCX(20,ID,ibif)=PKSIN(ID,curiyr)
        DPRCX(21,ID,ibif)=PRSIN(ID,curiyr)
        DPRCX(22,ID,ibif)=POTIN(ID,curiyr)

        if(ID.eq.9.and.fcrl.eq.1) write(6,'(5x,a,22(f6.2,2x),2x,i4)') '==== NEMS unadj price in $2012= ', DPRCX(1:22,ID,ibif)*MC_JPGDP(26), curcalyr

        IF(AB32SW.EQ.1.AND.CURCALYR.GE.ibyr2) then       ! POT_ibyr2
          iyy=max(curiyr,6)
!         emis(1)=em_elec(8,11,icy)/qelas(11,iy)       ! elec note: qelas in quads here
          emis(2)=engin(iyy)   * C_CO2_FACTOR          ! ngas
          emis(3)=eclin(iyy)   * C_CO2_FACTOR          ! steam coal
          emis(4)=emcin(iyy)   * C_CO2_FACTOR          ! met coal
          emis(5)=eclin(iyy)   * C_CO2_FACTOR          ! net coke import (steel only)
          emis(6)=erlin(iyy)   * C_CO2_FACTOR          ! resid (low sulphur)
          emis(7)=edsin(iyy)   * C_CO2_FACTOR          ! distillate
          emis(8)=elgin(iyy)   * C_CO2_FACTOR          ! liquid petrol gases
          emis(9)=emgin(iyy)   * C_CO2_FACTOR          ! motor gasoline
          emis(10)=esgin(iyy)  * C_CO2_FACTOR          ! still gas (refine only)
          emis(11)=epcin(iyy)  * C_CO2_FACTOR          ! petroleum coke
          emis(12)=0.0         * C_CO2_FACTOR          ! asphalt, all sequestered
          emis(13)=epfin(iyy)  * C_CO2_FACTOR          ! petroleum feedstock
          emis(14)=eksin(iyy)  * C_CO2_FACTOR          ! kerosene
          emis(15)=eotin(iyy)  * C_CO2_FACTOR          ! other ind
          emis(16)=enqngpf(iyy)  * C_CO2_FACTOR        ! nat gas feed stocks
          emis(17)=enqlgpf(iyy)  * C_CO2_FACTOR        ! lpg feedstock
          emis(18)=0.            * C_CO2_FACTOR        ! renewables, all sequestered

          emis(1)=sum(em_elec(8,8:9,(curiyr+baseyr-1)))/sum(qelas(8:9,max(curiyr,6)))
!          DPRCX(1,9,ibif)=PELIN(9,curiyr)-emis(1)*ab_allow_p(curiyr)         ! electricity. Remove marked-up for carbon in EMM.
!          DPRCX(2,9,ibif)=PELIN(9,curiyr)-emis(1)*ab_allow_p(curiyr)         ! not used. Remove marked-up for carbon in EMM.
          IF(CURCALYR.GE.ibyr2+1) DPRCX(3,9,ibif)=PGFIN(9,curiyr)+emis(2)*ab_allow_p(curiyr)      ! NG core (PA and BLD) POT_ibyr215 2015 to ibyr2+1 most next 17 rows
          IF(CURCALYR.GE.ibyr2+1) DPRCX(4,9,ibif)=PGIIN(9,curiyr)+emis(2)*ab_allow_p(curiyr)      ! NG non-core (BSC)    
          IF(CURCALYR.GE.ibyr2+1) DPRCX(5,9,ibif)=PGFIN(9,curiyr)+emis(16)*ab_allow_p(curiyr)     ! NG feedstock
          IF(CURCALYR.GE.ibyr2+1) DPRCX(6,9,ibif)=PLPIN(9,curiyr)+emis(2)*ab_allow_p(curiyr)      ! NG L&P
          DPRCX(7,9,ibif)=PCLIN(9,curiyr)+0.*emis(3)*ab_allow_p(curiyr)      ! steam coal
          DPRCX(8,9,ibif)=PMCIN(9,curiyr)+0.*emis(4)*ab_allow_p(curiyr)      ! met coal = coking coal
          DPRCX(9,9,ibif)=PMCIN(9,curiyr)+0.*emis(5)*ab_allow_p(curiyr)      ! for coke imports
          IF(CURCALYR.GE.ibyr2+1) DPRCX(10,9,ibif)=PRLIN(9,curiyr)+emis(6)*ab_allow_p(curiyr)     ! residual fuel, low sulfur
          IF(CURCALYR.LT.ibyr2+1) DPRCX(11,9,ibif)=PDSIN(9,curiyr)-emis(7)*ab_allow_p(curiyr)        ! distillate. Remove marked-up for carbon in LFMM.
          IF(CURCALYR.LT.ibyr2+1) DPRCX(12,9,ibif)=PLGIN(9,curiyr)-emis(8)*ab_allow_p(curiyr)        ! LPG H&P. Remove marked-up for carbon in LFMM.
          IF(CURCALYR.LT.ibyr2+1) DPRCX(13,9,ibif)=PLGINPF(9,curiyr)-emis(17)*ab_allow_p(curiyr)     ! the adjusted lpg feed price. Remove marked-up for carbon in LFMM.
          IF(CURCALYR.LT.ibyr2+1) DPRCX(14,9,ibif)=PMGIN(9,curiyr)-emis(9)*ab_allow_p(curiyr)        ! mogas. Remove marked-up for carbon in LFMM.
          DPRCX(15,9,ibif)=PRSIN(9,curiyr)+0.*emis(10)*ab_allow_p(curiyr)    ! still gas
          DPRCX(16,9,ibif)=PPCIN(9,curiyr)+0.*emis(11)*ab_allow_p(curiyr)    ! pet coke
          DPRCX(17,9,ibif)=PASIN(9,curiyr)+0.*ab_allow_p(curiyr)             ! asphalt and road oil. Note zero carbon coeffiecient.
          IF(CURCALYR.GE.ibyr2+1) DPRCX(18,9,ibif)=PRSIN(9,curiyr)+emis(6)*ab_allow_p(curiyr)     ! Residual Fuel (average)
          DPRCX(19,9,ibif)=PPFIN(9,curiyr)+0.*emis(13)*ab_allow_p(curiyr)    ! Petrochemical Feedstocks
          IF(CURCALYR.LT.ibyr2+1) DPRCX(20,9,ibif)=PKSIN(9,curiyr)-emis(14)*ab_allow_p(curiyr)       ! Kerosene. Remove marked-up for carbon in LFMM.
          DPRCX(21,9,ibif)=PRSIN(9,curiyr)+0.*emis(13)*ab_allow_p(curiyr)    ! other feedstock
          DPRCX(22,9,ibif)=POTIN(9,curiyr)+0.*emis(15)*ab_allow_p(curiyr)    ! Other Petroleum

          if(ID.eq.11.and.fcrl.eq.1) write(6,'(5x,a,22(f6.2,2x),2x,i4)') '==== AB32 unadj price in $2012= ', DPRCX(1:22,9,ibif)*MC_JPGDP(26), curcalyr
        ENDIF

! assign the "new" electricity prices according to which industry
!  groups: Primary=food,paper,chemicals,steel,aluminum;
!          Shift  =metal based durables;
!          Miscellaneous =all the rest.
! first make sure the prices are not zero!  ****
      if(curiyr.eq.1) then
            if(pelinp(id,curiyr).le.0) &
               pelinp(id,curiyr)=pelin(id,curiyr)
            if(pelins(id,curiyr).le.0) &
               pelins(id,curiyr)=pelin(id,curiyr)
            if(pelinm(id,curiyr).le.0) &
               pelinm(id,curiyr)=pelin(id,curiyr)
      else
            if(pelinp(id,curiyr).le.0) &
               pelinp(id,curiyr)=pelinp(id,curiyr-1)
            if(pelins(id,curiyr).le.0) &
               pelins(id,curiyr)=pelins(id,curiyr-1)
            if(pelinm(id,curiyr).le.0) &
               pelinm(id,curiyr)=pelinm(id,curiyr-1)
      endif
        DPRCX(23,ID,1:2)=PELINp(ID,curiyr)  ! for electricity, no difference between adj and unadjusted prices
        DPRCX(24,ID,1:2)=PELINs(ID,curiyr)
        DPRCX(25,ID,1:2)=PELINm(ID,curiyr)
      ENDDO

!************************************************************************AE
!! Do lag prices

      DO ID=1,11
        ibif=1
        iy=curiyr-1
        DPRCXLAG(1,ID,ibif)=aELIN(ID,iy)
        DPRCXLAG(2,ID,ibif)=aELIN(ID,iy)
        dprcxlag(3,ID,ibif)=aGFIN(ID,iy)
        dprcxlag(4,ID,ibif)=aGIIN(ID,iy)
        dprcxlag(5,ID,ibif)=aGFIN(ID,iy)
        dprcxlag(6,ID,ibif)=aLPIN(ID,iy)
        dprcxlag(7,ID,ibif)=aCLIN(ID,iy)
        dprcxlag(8,ID,ibif)=aMCIN(ID,iy)
        dprcxlag(9,ID,ibif)=aMCIN(ID,iy)
        dprcxlag(10,ID,ibif)=aRLIN(ID,iy)
        dprcxlag(11,ID,ibif)=aDSIN(ID,iy)
        dprcxlag(12,ID,ibif)=aLGIN(ID,iy)
        dprcxlag(13,ID,ibif)=aLGINPF(ID,iy)  ! the adjusted lpg feed price
        dprcxlag(14,ID,ibif)=aMGIN(ID,iy)
        dprcxlag(15,ID,ibif)=aRSIN(ID,iy)
        dprcxlag(16,ID,ibif)=aPCIN(ID,iy)
        dprcxlag(17,ID,ibif)=aASIN(ID,iy)
        dprcxlag(18,ID,ibif)=aRSIN(ID,iy)
        dprcxlag(19,ID,ibif)=aPFIN(ID,iy)
        dprcxlag(20,ID,ibif)=aKSIN(ID,iy)
        dprcxlag(21,ID,ibif)=aRSIN(ID,iy)
        dprcxlag(22,ID,ibif)=aOTIN(ID,iy)

!*****
!  Overrides for LAGGED prices when running AB32 cap-and-trade
!*****

! emis(fuel) are in million tonnes carbon per quad. Since there are 10^9 MMBTUs in a Quad,
!    and 10^9 kg in one million metric tons, these cancel out so that the emis(fuel) factors above when
!    multiplied by the California allowance cost, ab_allow_p, are equal to 87$/kg MMBTU
        IF(AB32SW.EQ.1.AND.CURCALYR.GE.ibyr2) then      ! POT_ibyr2
          iyy=max(curiyr-1,6)
!         emis(1)=em_elec(8,11,icy)/qelas(11,iy)       ! elec note: qelas in quads here
          emis(2)=engin(iyy)   * C_CO2_FACTOR          ! ngas
          emis(3)=eclin(iyy)   * C_CO2_FACTOR          ! steam coal
          emis(4)=emcin(iyy)   * C_CO2_FACTOR          ! met coal
          emis(5)=eclin(iyy)   * C_CO2_FACTOR          ! net coke import (steel only)
          emis(6)=erlin(iyy)   * C_CO2_FACTOR          ! resid (low sulphur)
          emis(7)=edsin(iyy)   * C_CO2_FACTOR          ! distillate
          emis(8)=elgin(iyy)   * C_CO2_FACTOR          ! liquid petrol gases
          emis(9)=emgin(iyy)   * C_CO2_FACTOR          ! motor gasoline
          emis(10)=esgin(iyy)  * C_CO2_FACTOR          ! still gas (refine only)
          emis(11)=epcin(iyy)  * C_CO2_FACTOR          ! petroleum coke
          emis(12)=0.0         * C_CO2_FACTOR          ! asphalt, all sequestered
          emis(13)=epfin(iyy)  * C_CO2_FACTOR          ! petroleum feedstock
          emis(14)=eksin(iyy)  * C_CO2_FACTOR          ! kerosene
          emis(15)=eotin(iyy)  * C_CO2_FACTOR          ! other ind
          emis(16)=enqngpf(iyy)  * C_CO2_FACTOR        ! nat gas feed stocks
          emis(17)=enqlgpf(iyy)  * C_CO2_FACTOR        ! lpg feedstock
          emis(18)=0.            * C_CO2_FACTOR        ! renewables, all sequestered

          emis(1)=sum(em_elec(8,8:9,iy+baseyr-1))/sum(qelas(8:9,max(iy,6)))
          DPRCXLAG(1,9,ibif)=aELIN(9,iy)+0.*emis(1)*ab_allow_p(iy)   ! electricity. Marked-up for carbon in EMM.
          DPRCXLAG(2,9,ibif)=aELIN(9,iy)+0.*emis(1)*ab_allow_p(iy)   ! not used. Marked-up for carbon in EMM.
          DPRCXLAG(3,9,ibif)=aGFIN(9,iy)+emis(2)*ab_allow_p(iy)      ! NG core (PA and BLD)
          DPRCXLAG(4,9,ibif)=aGIIN(9,iy)+emis(2)*ab_allow_p(iy)      ! NG non-core (BSC)
          DPRCXLAG(5,9,ibif)=aGFIN(9,iy)+emis(16)*ab_allow_p(iy)     ! NG feedstock
          DPRCXLAG(6,9,ibif)=aLPIN(9,iy)+emis(2)*ab_allow_p(iy)      ! NG L&P
          DPRCXLAG(7,9,ibif)=aCLIN(9,iy)+emis(3)*ab_allow_p(iy)      ! steam coal
          DPRCXLAG(8,9,ibif)=aMCIN(9,iy)+emis(4)*ab_allow_p(iy)      ! met coal = coking coal
          DPRCXLAG(9,9,ibif)=aMCIN(9,iy)+emis(5)*ab_allow_p(iy)      ! for coke imports
          DPRCXLAG(10,9,ibif)=aRLIN(9,iy)+emis(6)*ab_allow_p(iy)     ! residual fuel, low sulfur
          DPRCXLAG(11,9,ibif)=aDSIN(9,iy)+0.*emis(7)*ab_allow_p(iy)     ! distillate. Marked-up for carbon in LFMM.
          DPRCXLAG(12,9,ibif)=aLGIN(9,iy)+0.*emis(8)*ab_allow_p(iy)     ! LPG H&P. Marked-up for carbon in LFMM.
          DPRCXLAG(13,9,ibif)=aLGINPF(9,iy)+0.0*emis(17)*ab_allow_p(iy) ! the adjusted lpg feed price. Marked-up for carbon in LFMM.
          DPRCXLAG(14,9,ibif)=aMGIN(9,iy)+0.*emis(9)*ab_allow_p(iy)     ! mogas. Marked-up for carbon in LFMM.
          DPRCXLAG(15,9,ibif)=aRSIN(9,iy)+emis(10)*ab_allow_p(iy)    ! still gas
          DPRCXLAG(16,9,ibif)=aPCIN(9,iy)+emis(11)*ab_allow_p(iy)    ! pet coke
          DPRCXLAG(17,9,ibif)=aASIN(9,iy)+0.*ab_allow_p(iy)          ! asphalt and road oil
          DPRCXLAG(18,9,ibif)=aRSIN(9,iy)+emis(6)*ab_allow_p(iy)     ! Residual Fuel (average)
          DPRCXLAG(19,9,ibif)=aPFIN(9,iy)+emis(13)*ab_allow_p(iy)    ! Petrochemical Feedstocks
          DPRCXLAG(20,9,ibif)=aKSIN(9,iy)+0.*emis(14)*ab_allow_p(iy)    ! Kerosene. Marked-up for carbon in LFMM.
          DPRCXLAG(21,9,ibif)=aRSIN(9,iy)+emis(13)*ab_allow_p(iy)    ! other feedstock
          DPRCXLAG(22,9,ibif)=aOTIN(9,iy)+emis(15)*ab_allow_p(iy)    ! Other Petroleum

          if(ID.eq.11) write(6,'(5x,a,22(f6.2,2x),2x,i4)') '==== AB32 adj LAGGED price = ', DPRCXLAG(1:22,9,ibif), curcalyr

        ENDIF

! Unadjusted Prices:  for "Bifurcated" carbon allowance scheme where some covered; some not.
!  These are from the unadjusted price common block, MPBLK
        ibif=2
        dprcxlag(1,ID,ibif)=PELIN(ID,iy)
        dprcxlag(2,ID,ibif)=PELIN(ID,iy)
        dprcxlag(3,ID,ibif)=PGFIN(ID,iy)
        dprcxlag(4,ID,ibif)=PGIIN(ID,iy)
        dprcxlag(5,ID,ibif)=PGFIN(ID,iy)
        dprcxlag(6,ID,ibif)=PLPIN(ID,iy)
        dprcxlag(7,ID,ibif)=PCLIN(ID,iy)
        dprcxlag(8,ID,ibif)=PMCIN(ID,iy)
        dprcxlag(9,ID,ibif)=PMCIN(ID,iy)
        dprcxlag(10,ID,ibif)=PRLIN(ID,iy)
        dprcxlag(11,ID,ibif)=PDSIN(ID,iy)
        dprcxlag(12,ID,ibif)=PLGIN(ID,iy)
        dprcxlag(13,ID,ibif)=PLGINPF(ID,iy)  ! use the lpg feed price from pmore
        dprcxlag(14,ID,ibif)=PMGIN(ID,iy)
        dprcxlag(15,ID,ibif)=PRSIN(ID,iy)
        dprcxlag(16,ID,ibif)=PPCIN(ID,iy)
        dprcxlag(17,ID,ibif)=PASIN(ID,iy)
        dprcxlag(18,ID,ibif)=PRSIN(ID,iy)
        dprcxlag(19,ID,ibif)=PPFIN(ID,iy)
        dprcxlag(20,ID,ibif)=PKSIN(ID,iy)
        dprcxlag(21,ID,ibif)=PRSIN(ID,iy)
        dprcxlag(22,ID,ibif)=POTIN(ID,iy)
        IF(AB32SW.EQ.1.AND.CURCALYR.GE.ibyr2) then      ! POT_ibyr2
          iyy=max(curiyr,6)
!         emis(1)=em_elec(8,11,icy)/qelas(11,iy)       ! elec note: qelas in quads here
          emis(2)=engin(iyy)   * C_CO2_FACTOR          ! ngas
          emis(3)=eclin(iyy)   * C_CO2_FACTOR          ! steam coal
          emis(4)=emcin(iyy)   * C_CO2_FACTOR          ! met coal
          emis(5)=eclin(iyy)   * C_CO2_FACTOR          ! net coke import (steel only)
          emis(6)=erlin(iyy)   * C_CO2_FACTOR          ! resid (low sulphur)
          emis(7)=edsin(iyy)   * C_CO2_FACTOR          ! distillate
          emis(8)=elgin(iyy)   * C_CO2_FACTOR          ! liquid petrol gases
          emis(9)=emgin(iyy)   * C_CO2_FACTOR          ! motor gasoline
          emis(10)=esgin(iyy)  * C_CO2_FACTOR          ! still gas (refine only)
          emis(11)=epcin(iyy)  * C_CO2_FACTOR          ! petroleum coke
          emis(12)=0.0         * C_CO2_FACTOR          ! asphalt, all sequestered
          emis(13)=epfin(iyy)  * C_CO2_FACTOR          ! petroleum feedstock
          emis(14)=eksin(iyy)  * C_CO2_FACTOR          ! kerosene
          emis(15)=eotin(iyy)  * C_CO2_FACTOR          ! other ind
          emis(16)=enqngpf(iyy)  * C_CO2_FACTOR        ! nat gas feed stocks
          emis(17)=enqlgpf(iyy)  * C_CO2_FACTOR        ! lpg feedstock
          emis(18)=0.            * C_CO2_FACTOR        ! renewables, all sequestered

          emis(1)=sum(em_elec(8,8:9,iy+baseyr-1))/sum(qelas(8:9,max(iy,6)))
!          DPRCXLAG(1,9,ibif)=PELIN(9,iy)-emis(1)*ab_allow_p(iy)         ! electricity. Remove marked-up for carbon in EMM.
!          DPRCXLAG(2,9,ibif)=PELIN(9,iy)-emis(1)*ab_allow_p(iy)         ! not used. Remove marked-up for carbon in EMM.
          IF(CURCALYR.GT.ibyr2+1) DPRCXLAG(3,9,ibif)=PGFIN(9,iy)+emis(2)*ab_allow_p(iy)      ! NG core (PA and BLD) POT_ibyr215 2015 to ibyr2+1 most next 17 rows
          IF(CURCALYR.GT.ibyr2+1) DPRCXLAG(4,9,ibif)=PGIIN(9,iy)+emis(2)*ab_allow_p(iy)      ! NG non-core (BSC)
          IF(CURCALYR.GT.ibyr2+1) DPRCXLAG(5,9,ibif)=PGFIN(9,iy)+emis(16)*ab_allow_p(iy)     ! NG feedstock
          IF(CURCALYR.GT.ibyr2+1) DPRCXLAG(6,9,ibif)=PLPIN(9,iy)+emis(2)*ab_allow_p(iy)      ! NG L&P
          DPRCXLAG(7,9,ibif)=PCLIN(9,iy)+0.*emis(3)*ab_allow_p(iy)      ! steam coal
          DPRCXLAG(8,9,ibif)=PMCIN(9,iy)+0.*emis(4)*ab_allow_p(iy)      ! met coal = coking coal
          DPRCXLAG(9,9,ibif)=PMCIN(9,iy)+0.*emis(5)*ab_allow_p(iy)      ! for coke imports
          IF(CURCALYR.GT.ibyr2+1) DPRCXLAG(10,9,ibif)=PRLIN(9,iy)+emis(6)*ab_allow_p(iy)     ! residual fuel, low sulfur
          IF(CURCALYR.LE.ibyr2+1) DPRCXLAG(11,9,ibif)=PDSIN(9,iy)-emis(7)*ab_allow_p(iy)        ! distillate. Remove marked-up for carbon in LFMM.
          IF(CURCALYR.LE.ibyr2+1) DPRCXLAG(12,9,ibif)=PLGIN(9,iy)-emis(8)*ab_allow_p(iy)        ! LPG H&P. Remove marked-up for carbon in LFMM.
          IF(CURCALYR.LE.ibyr2+1) DPRCXLAG(13,9,ibif)=PLGINPF(9,iy)-emis(17)*ab_allow_p(iy)     ! the adjusted lpg feed price. Remove marked-up for carbon in LFMM.
          IF(CURCALYR.LE.ibyr2+1) DPRCXLAG(14,9,ibif)=PMGIN(9,iy)-emis(9)*ab_allow_p(iy)        ! mogas. Remove marked-up for carbon in LFMM.
          DPRCXLAG(15,9,ibif)=PRSIN(9,iy)+0.*emis(10)*ab_allow_p(iy)    ! still gas
          DPRCXLAG(16,9,ibif)=PPCIN(9,iy)+0.*emis(11)*ab_allow_p(iy)    ! pet coke
          DPRCXLAG(17,9,ibif)=PASIN(9,iy)+0.*ab_allow_p(iy)             ! asphalt and road oil. Note zero carbon coeffiecient.
          IF(CURCALYR.GT.ibyr2+1) DPRCXLAG(18,9,ibif)=PRSIN(9,iy)+emis(6)*ab_allow_p(iy)     ! Residual Fuel (average)
          DPRCXLAG(19,9,ibif)=PPFIN(9,iy)+0.*emis(13)*ab_allow_p(iy)    ! Petrochemical Feedstocks
          IF(CURCALYR.LE.ibyr2+1) DPRCXLAG(20,9,ibif)=PKSIN(9,iy)-emis(14)*ab_allow_p(iy)       ! Kerosene. Remove marked-up for carbon in LFMM.
          DPRCXLAG(21,9,ibif)=PRSIN(9,iy)+0.*emis(13)*ab_allow_p(iy)    ! other feedstock
          DPRCXLAG(22,9,ibif)=POTIN(9,iy)+0.*emis(15)*ab_allow_p(iy)    ! Other Petroleum

          if(ID.eq.11) write(6,'(5x,a,22(f6.2,2x),2x,i4)') '==== AB32 unadj LAGGED price = ', DPRCXLAG(1:22,9,ibif), curcalyr
        ENDIF


! assign the "new" electricity prices according to which industry
!  groups: Primary=food,paper,chemicals,steel,aluminum;
!          Shift  =metal based durables;
!          Miscellaneous =all the rest.
! first make sure the prices are not zero!  ****
      if(curiyr.eq.1) then
            if(pelinp(id,curiyr).le.0) &
               pelinp(id,curiyr)=pelin(id,curiyr)
            if(pelins(id,curiyr).le.0) &
               pelins(id,curiyr)=pelin(id,curiyr)
            if(pelinm(id,curiyr).le.0) &
               pelinm(id,curiyr)=pelin(id,curiyr)
      else
            if(pelinp(id,curiyr).le.0) &
               pelinp(id,curiyr)=pelinp(id,curiyr-1)
            if(pelins(id,curiyr).le.0) &
               pelins(id,curiyr)=pelins(id,curiyr-1)
            if(pelinm(id,curiyr).le.0) &
               pelinm(id,curiyr)=pelinm(id,curiyr-1)
      endif
        iy=curiyr-1
        dprcxlag(23,ID,1:2)=PELINp(ID,iy)  ! for electricity, no difference between adj and unadjusted prices
        dprcxlag(24,ID,1:2)=PELINs(ID,iy)
        dprcxlag(25,ID,1:2)=PELINm(ID,iy)
      ENDDO

!***********************************************************************end AE

!******
!  AGGREGATE CENSUS DIVISION PRICES TO CENSUS REGION PRICES.
!  IF in SEDS year range, USE SEDS CONSUMPTION TO WEIGHT PRICES.
!  IF PAST SEDS, USE LAG FORECAST CONSUMPTION.
!******
      IF(CURCALYR.LE.SEDSLastYr) THEN  ! Last year of SEDS data--2016 for aeo2019
        I = curiyr
        DO ID=1,11
          DCONX(1,ID)=QSELIN(ID,I)
          DCONX(2,ID)=QSELIN(ID,I)
          DCONX(3,ID)=QSNGIN(ID,I)
          DCONX(4,ID)=QSNGIN(ID,I)
          DCONX(5,ID)=QSNGIN(ID,I)
          DCONX(6,ID)=QSLPIN(ID,I)
          DCONX(7,ID)=QSCLIN(ID,I)
          DCONX(8,ID)=QSMCIN(ID,I)
          DCONX(9,ID)=QSMCIN(ID,I)
          DCONX(10,ID)=QSRSIN(ID,I)
          DCONX(11,ID)=QSDSIN(ID,I)
          DCONX(12,ID)=QSLGIN(ID,I)+QSPPIN(ID,I)
          DCONX(13,ID)=QSLGIN(ID,I)
          DCONX(14,ID)=QSMGIN(ID,I)
          DCONX(15,ID)=QSSGIN(ID,I)
          DCONX(16,ID)=QSPCIN(ID,I)
          DCONX(17,ID)=QSASIN(ID,I)
          DCONX(18,ID)=QSOTIN(ID,I)
          DCONX(19,ID)=QSPFIN(ID,I)
          DCONX(20,ID)=QSKSIN(ID,I)
          DCONX(21,ID)=QSOTIN(ID,I)
          DCONX(22,ID)=QSOTIN(ID,I)
          DconX(23,ID)=qELINp(ID,I)
          DconX(24,ID)=qELINs(ID,I)
          DconX(25,ID)=qELINm(ID,I)
        ENDDO
      ELSE
        DO ID=1,11
         DCONX(1,ID)=QELIN(ID,curiyr-1)
         DCONX(2,ID)=QELIN(ID,curiyr-1)
         DCONX(3,ID)=QGFIN(ID,curiyr-1)
         DCONX(4,ID)=QGIIN(ID,curiyr-1)
         DCONX(5,ID)=QGIIN(ID,curiyr-1)
         DCONX(6,ID)=QLPIN(ID,curiyr-1)+QNGLQ(ID,curiyr-1)
         DCONX(7,ID)=QCLIN(ID,curiyr-1)
         DCONX(8,ID)=QMCIN(ID,curiyr-1)
         DCONX(9,ID)=QMCIN(ID,curiyr-1)
         DCONX(10,ID)=QRLIN(ID,curiyr-1)
         DCONX(11,ID)=QDSIN(ID,curiyr-1)
         DCONX(12,ID)=QLGIN(ID,curiyr-1)
         DCONX(13,ID)=QLGIN(ID,curiyr-1)
         DCONX(14,ID)=QMGIN(ID,curiyr-1)
         DCONX(15,ID)=QSGIN(ID,curiyr-1)
         DCONX(16,ID)=QPCIN(ID,curiyr-1)
         DCONX(17,ID)=QASIN(ID,curiyr-1)
         DCONX(18,ID)=QOTIN(ID,curiyr-1)
         DCONX(19,ID)=QPFIN(ID,curiyr-1)
         DCONX(20,ID)=QKSIN(ID,curiyr-1)
         DCONX(21,ID)=QOTIN(ID,curiyr-1)
         DCONX(22,ID)=QOTIN(ID,curiyr-1)
         DconX(23,ID)=qELINp(ID,curiyr-1)
         DconX(24,ID)=qELINs(ID,curiyr-1)
         DconX(25,ID)=qELINm(ID,curiyr-1)
       ENDDO
      ENDIF
      DO ibif=1,2
       DO IF=1,25
        IF((DCONX(IF,1)+DCONX(IF,2)).GT.0.0) THEN
          PRCX(IF,1,ibif)=((DPRCX(IF,1,ibif)*DCONX(IF,1))+ &
                           (DPRCX(IF,2,ibif)*DCONX(IF,2)))/ &
                           (DCONX(IF,1)     +DCONX(IF,2))
        ELSE
          PRCX(IF,1,ibif)=(DPRCX(IF,1,ibif)+DPRCX(IF,2,ibif))/2.0
        ENDIF
        IF((DCONX(IF,3)+DCONX(IF,4)).GT.0.0) THEN
          PRCX(IF,2,ibif)=((DPRCX(IF,3,ibif)*DCONX(IF,3))+ &
                           (DPRCX(IF,4,ibif)*DCONX(IF,4)))/ &
                           (DCONX(IF,3)     +DCONX(IF,4))
        ELSE
          PRCX(IF,2,ibif)=(DPRCX(IF,3,ibif)+DPRCX(IF,4,ibif))/2.0
        ENDIF
        IF((DCONX(IF,5)+DCONX(IF,6)+DCONX(IF,7)).GT.0.0) THEN
          PRCX(IF,3,ibif)=((DPRCX(IF,5,ibif)*DCONX(IF,5))+ &
                           (DPRCX(IF,6,ibif)*DCONX(IF,6))+ &
                           (DPRCX(IF,7,ibif)*DCONX(IF,7)))/ &
                           (DCONX(IF,5)+DCONX(IF,6)+DCONX(IF,7))
        ELSE
          PRCX(IF,3,ibif)=(DPRCX(IF,5,ibif)+DPRCX(IF,6,ibif)+DPRCX(IF,7,ibif))/3.0
        ENDIF
        IF((DCONX(IF,8)+DCONX(IF,9)).GT.0.0) THEN
          PRCX(IF,4,ibif)=((DPRCX(IF,8,ibif)*DCONX(IF,8))+ &
                           (DPRCX(IF,9,ibif)*DCONX(IF,9)))/ &
                           (DCONX(IF,8)     +DCONX(IF,9))
        ELSE
          PRCX(IF,4,ibif)=(DPRCX(IF,8,ibif)+DPRCX(IF,9,ibif))/2.0
        ENDIF
       ENDDO
      ENDDO

!*****************************************************************AE
!! Do price lags by census region
      DO ibif=1,2
       DO IF=1,25
        IF((DCONX(IF,1)+DCONX(IF,2)).GT.0.0) THEN
          PRCXlag(IF,1,ibif)=((DPRCXlag(IF,1,ibif)*DCONX(IF,1))+ &
                           (DPRCXlag(IF,2,ibif)*DCONX(IF,2)))/ &
                           (DCONX(IF,1)     +DCONX(IF,2))
        ELSE
          PRCXlag(IF,1,ibif)=(DPRCXlag(IF,1,ibif)+DPRCXlag(IF,2,ibif))/2.0
        ENDIF
        IF((DCONX(IF,3)+DCONX(IF,4)).GT.0.0) THEN
          PRCXlag(IF,2,ibif)=((DPRCXlag(IF,3,ibif)*DCONX(IF,3))+ &
                           (DPRCXlag(IF,4,ibif)*DCONX(IF,4)))/ &
                           (DCONX(IF,3)     +DCONX(IF,4))
        ELSE
          PRCXlag(IF,2,ibif)=(DPRCXlag(IF,3,ibif)+DPRCXlag(IF,4,ibif))/2.0
        ENDIF
        IF((DCONX(IF,5)+DCONX(IF,6)+DCONX(IF,7)).GT.0.0) THEN
          PRCXlag(IF,3,ibif)=((DPRCXlag(IF,5,ibif)*DCONX(IF,5))+ &
                           (DPRCXlag(IF,6,ibif)*DCONX(IF,6))+ &
                           (DPRCXlag(IF,7,ibif)*DCONX(IF,7)))/ &
                           (DCONX(IF,5)+DCONX(IF,6)+DCONX(IF,7))
        ELSE
          PRCXlag(IF,3,ibif)=(DPRCXlag(IF,5,ibif)+DPRCXlag(IF,6,ibif)+DPRCXlag(IF,7,ibif))/3.0
        ENDIF
        IF((DCONX(IF,8)+DCONX(IF,9)).GT.0.0) THEN
          PRCXlag(IF,4,ibif)=((DPRCXlag(IF,8,ibif)*DCONX(IF,8))+ &
                           (DPRCXlag(IF,9,ibif)*DCONX(IF,9)))/ &
                           (DCONX(IF,8)     +DCONX(IF,9))
        ELSE
          PRCXlag(IF,4,ibif)=(DPRCXlag(IF,8,ibif)+DPRCXlag(IF,9,ibif))/2.0
        ENDIF
       ENDDO
      ENDDO

!*****************************************************************end AE

!******
!  ASSIGN NATIONAL PRICES.  (from epmMPLBK--alternate to MPBLK with different variable names)
!******
      ibif=1
        PRCX(1,5,ibif)=aELIN(11,curiyr)
        PRCX(2,5,ibif)=aELIN(11,curiyr)
        PRCX(3,5,ibif)=aGFIN(11,curiyr)
        PRCX(4,5,ibif)=aGIIN(11,curiyr)
        PRCX(5,5,ibif)=aGFIN(11,curiyr)
        PRCX(6,5,ibif)=aLPIN(11,curiyr)
        PRCX(7,5,ibif)=aCLIN(11,curiyr)
        PRCX(8,5,ibif)=aMCIN(11,curiyr)
        PRCX(9,5,ibif)=aMCIN(11,curiyr)
        PRCX(10,5,ibif)=aRLIN(11,curiyr)
        PRCX(11,5,ibif)=aDSIN(11,curiyr)
        PRCX(12,5,ibif)=aLGIN(11,curiyr)
        PRCX(13,5,ibif)=aLGIN(11,curiyr)
        PRCX(14,5,ibif)=aMGIN(11,curiyr)
        PRCX(15,5,ibif)=aRSIN(11,curiyr)
        PRCX(16,5,ibif)=aPCIN(11,curiyr)
        PRCX(17,5,ibif)=aASIN(11,curiyr)
        PRCX(18,5,ibif)=aRSIN(11,curiyr)
        PRCX(19,5,ibif)=aPFIN(11,curiyr)
        PRCX(20,5,ibif)=aKSIN(11,curiyr)
        PRCX(21,5,ibif)=aRSIN(11,curiyr)
        PRCX(22,5,ibif)=aOTIN(11,curiyr)
        PRCX(23,5,ibif)=pELINp(11,curiyr)
        PRCX(24,5,ibif)=pELINs(11,curiyr)
        PRCX(25,5,ibif)=pELINm(11,curiyr)
! Unadjusted Prices:  for "Bifurcated" carbon allowance scheme where some covered; some not.
!  These are from the unadjusted price common block, MPBLK
      ibif=2
        PRCX(1,5,ibif)=PELIN(11,curiyr)
        PRCX(2,5,ibif)=PELIN(11,curiyr)
        PRCX(3,5,ibif)=PGFIN(11,curiyr)
        PRCX(4,5,ibif)=PGIIN(11,curiyr)
        PRCX(5,5,ibif)=PGFIN(11,curiyr)
        PRCX(6,5,ibif)=PLPIN(11,curiyr)
        PRCX(7,5,ibif)=PCLIN(11,curiyr)
        PRCX(8,5,ibif)=PMCIN(11,curiyr)
        PRCX(9,5,ibif)=PMCIN(11,curiyr)
        PRCX(10,5,ibif)=PRLIN(11,curiyr)
        PRCX(11,5,ibif)=PDSIN(11,curiyr)
        PRCX(12,5,ibif)=PLGIN(11,curiyr)
        PRCX(13,5,ibif)=PLGINPF(11,curiyr)  ! the lpg feed price
        PRCX(14,5,ibif)=PMGIN(11,curiyr)
        PRCX(15,5,ibif)=PRSIN(11,curiyr)
        PRCX(16,5,ibif)=PPCIN(11,curiyr)
        PRCX(17,5,ibif)=PASIN(11,curiyr)
        PRCX(18,5,ibif)=PRSIN(11,curiyr)
        PRCX(19,5,ibif)=PPFIN(11,curiyr)
        PRCX(20,5,ibif)=PKSIN(11,curiyr)
        PRCX(21,5,ibif)=PRSIN(11,curiyr)
        PRCX(22,5,ibif)=POTIN(11,curiyr)
        PRCX(23,5,ibif)=PELINp(11,curiyr)
        PRCX(24,5,ibif)=PELINs(11,curiyr)
        PRCX(25,5,ibif)=PELINm(11,curiyr)

!******
!  Assign a price for biomass but it is irrelevant since renewables are not
!  a function of energy prices
!******

      DO IR=1,5
        PRCX(42,IR,1:2)=2.0
      ENDDO

!******
!  STEAM PRICE WILL ULTIMATELY BE A QUANTITY WEIGHTED AVERAGE.
!  AVERAGE OF NATURAL GAS, RESIDUAL OIL AND COAL PRICES.
!******

      DO IR=1,5
        PRCX(31,IR,1:2)=(PRCX(4,IR,1:2)+PRCX(7,IR,1:2)+PRCX(10,IR,1:2))/3.0
      ENDDO


!*****************************************************************AE
!! Do price lags
!******
!  ASSIGN NATIONAL PRICES.  (from epmMPLBK--alternate to MPBLK with different variable names)
!******
      ibif=1
        prcxlag(1,5,ibif)=aELIN(11,curiyr-1)
        prcxlag(2,5,ibif)=aELIN(11,curiyr-1)
        prcxlag(3,5,ibif)=aGFIN(11,curiyr-1)
        prcxlag(4,5,ibif)=aGIIN(11,curiyr-1)
        prcxlag(5,5,ibif)=aGFIN(11,curiyr-1)
        prcxlag(6,5,ibif)=aLPIN(11,curiyr-1)
        prcxlag(7,5,ibif)=aCLIN(11,curiyr-1)
        prcxlag(8,5,ibif)=aMCIN(11,curiyr-1)
        prcxlag(9,5,ibif)=aMCIN(11,curiyr-1)
        prcxlag(10,5,ibif)=aRLIN(11,curiyr-1)
        prcxlag(11,5,ibif)=aDSIN(11,curiyr-1)
        prcxlag(12,5,ibif)=aLGIN(11,curiyr-1)
        prcxlag(13,5,ibif)=aLGIN(11,curiyr-1)
        prcxlag(14,5,ibif)=aMGIN(11,curiyr-1)
        prcxlag(15,5,ibif)=aRSIN(11,curiyr-1)
        prcxlag(16,5,ibif)=aPCIN(11,curiyr-1)
        prcxlag(17,5,ibif)=aASIN(11,curiyr-1)
        prcxlag(18,5,ibif)=aRSIN(11,curiyr-1)
        prcxlag(19,5,ibif)=aPFIN(11,curiyr-1)
        prcxlag(20,5,ibif)=aKSIN(11,curiyr-1)
        prcxlag(21,5,ibif)=aRSIN(11,curiyr-1)
        prcxlag(22,5,ibif)=aOTIN(11,curiyr-1)
        prcxlag(23,5,ibif)=pELINp(11,curiyr-1)
        prcxlag(24,5,ibif)=pELINs(11,curiyr-1)
        prcxlag(25,5,ibif)=pELINm(11,curiyr-1)
! Unadjusted Prices:  for "Bifurcated" carbon allowance scheme where some covered; some not.
!  These are from the unadjusted price common block, MPBLK
      ibif=2
        prcxlag(1,5,ibif)=PELIN(11,curiyr-1)
        prcxlag(2,5,ibif)=PELIN(11,curiyr-1)
        prcxlag(3,5,ibif)=PGFIN(11,curiyr-1)
        prcxlag(4,5,ibif)=PGIIN(11,curiyr-1)
        prcxlag(5,5,ibif)=PGFIN(11,curiyr-1)
        prcxlag(6,5,ibif)=PLPIN(11,curiyr-1)
        prcxlag(7,5,ibif)=PCLIN(11,curiyr-1)
        prcxlag(8,5,ibif)=PMCIN(11,curiyr-1)
        prcxlag(9,5,ibif)=PMCIN(11,curiyr-1)
        prcxlag(10,5,ibif)=PRLIN(11,curiyr-1)
        prcxlag(11,5,ibif)=PDSIN(11,curiyr-1)
        prcxlag(12,5,ibif)=PLGIN(11,curiyr-1)
        prcxlag(13,5,ibif)=PLGINPF(11,curiyr-1)  ! the lpg feed price
        prcxlag(14,5,ibif)=PMGIN(11,curiyr-1)
        prcxlag(15,5,ibif)=PRSIN(11,curiyr-1)
        prcxlag(16,5,ibif)=PPCIN(11,curiyr-1)
        prcxlag(17,5,ibif)=PASIN(11,curiyr-1)
        prcxlag(18,5,ibif)=PRSIN(11,curiyr-1)
        prcxlag(19,5,ibif)=PPFIN(11,curiyr-1)
        prcxlag(20,5,ibif)=PKSIN(11,curiyr-1)
        prcxlag(21,5,ibif)=PRSIN(11,curiyr-1)
        prcxlag(22,5,ibif)=POTIN(11,curiyr-1)
        prcxlag(23,5,ibif)=PELINp(11,curiyr-1)
        prcxlag(24,5,ibif)=PELINs(11,curiyr-1)
        prcxlag(25,5,ibif)=PELINm(11,curiyr-1)

!******
!  Assign a price for biomass but it is irrelevant since renewables are not
!  a function of energy prices
!******

      DO IR=1,5
        prcxlag(42,IR,1:2)=2.0
      ENDDO

!******
!  STEAM PRICE WILL ULTIMATELY BE A QUANTITY WEIGHTED AVERAGE.
!  AVERAGE OF NATURAL GAS, RESIDUAL OIL AND COAL PRICES.
!******

      DO IR=1,5
        prcxlag(31,IR,1:2)=(prcxlag(4,IR,1:2)+prcxlag(7,IR,1:2)+PRCXlag(10,IR,1:2))/3.0
      ENDDO

!*****************************************************************end AE


!******
!  ASSIGN BASE YEAR PRICES FOR STORAGE
!******
      IF(IYR.EQ.ibyr2) THEN
         DO IR = 1,4
           PRCXIBYR(1,IR) = PRCX(4,IR,1)
           PRCXIBYR(2,IR) = PRCX(7,IR,1)
           PRCXIBYR(3,IR) = PRCX(10,IR,1)
		   PRCXIBYR(4,IR) = PRCX(1,IR,1)  ! electricity.  NEW for aeo2023 kpe
         ENDDO
      ENDIF
! Fill in yearly price array with current year prices. ":" is for adjusted/unadjusted dimension
      DO IF=1,50
        DO IR=1,4
          PRCXYR(IF,IR,curiyr,1:2)=PRCX(IF,IR,1:2)
        ENDDO
      ENDDO

! Get corn used for incremental ethanol production
!      DO ID=1,9
        BUSHEL(CURIYR,1) = CORNCD(1,1,CURIYR) + CORNCD(1,2,CURIYR)
        BUSHEL(CURIYR,2) = CORNCD(1,3,CURIYR) + CORNCD(1,4,CURIYR)
        BUSHEL(CURIYR,3) = CORNCD(1,5,CURIYR) + CORNCD(1,6,CURIYR) + CORNCD(1,7,CURIYR)
        BUSHEL(CURIYR,4) = CORNCD(1,8,CURIYR) + CORNCD(1,9,CURIYR)
        BUSHEL(CURIYR,5) = SUM(BUSHEL(CURIYR,1:4))
 !     ENDDO


    END Subroutine Setup_Mac_and_Price

!=============================================================================================
!  THIS SUBROUTINE CALLS MOST OF THE SUBROUTINES TO
!  SOLVE THE INDUSTRIAL MODEL.
!******
      SUBROUTINE ISEAM
      use i_

      IMPLICIT NONE

!******
!  DECLARE INTERNAL VARIABLES.
!******

      INTEGER IP,IPOLL,IREG,indx,ISPROCFLOW  ! kpe indx is industry
      integer is,ifl,ifx,inpreg,inpind,ieu,isub
      INTEGER IUNIT2R1,IUNIT2R2,IUNIT2R3,IUNIT2R4
      INTEGER IUNIT3R1,IUNIT3R2,IUNIT3R3,IUNIT3R4
      integer iunit/0/,ibeu
      save iunit
      logical lexist
      character*1 start,dumc*15, line*165
      
!******      
!   READ IN QCR COAL DATA AND 
!   ASM ELECTRICITY DATA
!******     
      Integer FEEDYEARS
      Integer MAX_YEARS
	  Integer QCR_YEARS
	  Integer ASM_YEARS

      ! will have a varying number of entries, depending on the start (START_YR_FEEDSTOCK) and end (SEDSLASTYR+FEEDYEARS)of the data period
      REAL,ALLOCATABLE::qcrcokeplnt(:)                  ! allocatable, because the number of entries can change every year
      REAL,ALLOCATABLE::qcrindchp(:)                 ! allocatable, because the number of entries can change every year
      REAL,ALLOCATABLE::qcrindnchp(:)                 ! allocatable, because the number of entries can change every year
      
      
    IF ((CURCALYR .eq. ibyr) .AND. (CURITR .eq. 1)) THEN 
            ALLOCATE(qcrcokeplnt(QCR_YEARS))                  ! allocatable, because the number of entries can change every year
            ALLOCATE(qcrindchp(QCR_YEARS))                 ! allocatable, because the number of entries can change every year
            ALLOCATE(qcrindnchp(QCR_YEARS))                 ! allocatable, because the number of entries can change every year
    ENDIF
!******
!  READ THE CONTROL VARIABLE FILE
!  ONLY ON THE FIRST ITERATION OF THE FIRST YEAR MODEL RUN.
!******
      IF(IYR.EQ.ibyr2.AND.FSTITER.EQ.1) THEN
        CALL RCNTL  !   Read indrun.txt and itlbshr.txt (boiler elasticities and latest MECS bsc fuel totals)
        CALL MecsLess860b ! calculate base year boiler fuel by subtracting 860b CHP fuel from Mecs indirect fuels
      ENDIF
     ! IF(IYR.EQ.ibyr2+1.AND.FSTITER.EQ.1.and.prtdbgi.ge.3) THEN
     !   write(6,'(1x,a)') ' ind reg  OT COGSTEAMibyr2 BIOSTEAMibyr2,noncogfosstm,CALIBibyr2_BIO,CALIBibyr2_FOS'
     !   do i=1,numind
        !  write(6,*)
      !    do j=1,4
         !   write(6,'(1x,2i3,4f11.2,2f11.4)') i,j,STEMCURIBYR(i,j),COGSTEAMIBYR(i,j), &
         !  BIOSTEAMIBYR(i,j),noncogfosstmIBYR(i,j),CALIBIBYR_BIO(i,j),CALIBIBYR_FOS(i,j)
       !   enddo
       ! enddo
      ! ENDIF

!******
!  OPEN A FILE FOR DEBUG WRITES.
!  ONLY IF INTERNAL DEBUG SWITCH IS ON, OR, IF SUBROUTINE
!  TRACE IS ON ,OR, IF WRITING SUMMARY RESULTS.
!  OPENING OF FILE IS DONE ON FIRST YEAR, FIRST ITERATION.
!  IF THE DEBUG FILE IS OPENED, A FLAG IS TURNED ON (IOPEN=1).
!******

      IF(IYR.EQ.ibyr2.AND.FSTITER.EQ.1) THEN
        FNAME='INDTST            '   ! named INDTST.txt
        NEW=.TRUE.
        IUNIT1=FILE_MGR('O',FNAME,NEW)
        IOPEN=1
      ENDIF

!******
!  WRITE SUBROUTINE TRACE INFORMATION, IF ON.
!******

      IF(ISUBTR.EQ.1.AND.IOPEN.EQ.1.AND.LSTITER.EQ.1) &
         WRITE(IUNIT1,991)

!******
!  WRITE A HEADING IN THE DEBUG REPORT FILE.
!******

      IF(IWDBG.EQ.1.AND.IOPEN.EQ.1.AND.LSTITER.EQ.1) &
           WRITE(IUNIT1,801) IYR


! update lag variables to initial data for current year.
           
   IF(IYR.GT.ibyr2.AND.FSTITER.EQ.1) THEN
        DO IREG=1,4
          indreg=IREG
          do indnum=1,indmax
             inddir=indnum
             call rdbin

             prodxlag=prodx
             prodvxlag=prodvx
             ENPINTLAG=enpint
             BYPINTLAG=bypint
             stemcurlag=stemcur
!             htrtlag=htrtcur
             bsshrlag=bsshr
             emplxlag=emplx
             prodlag=prodcur
             idlcaplag=idlcap

             call wrbin

          ENDDO
         ENDDO
      ENDIF


!        MAKE ADJUSTMENTS TO ENERGY PRICES
!**

       IF(IPRICE.EQ.1.AND.curcalyr.GT.techstrtyr) CALL PRICE ! to be consistent with when aeo2010 tech cases diverge

!******
!  DO CALCULATIONS FOR EACH INDUSTRY.
!******
	  ISPROCFLOW = 0


      DO 45 INDNUM=1,INDMAX
        inddir=indnum
        
        QCR_YEARS = END_YR_QCR-ibyr+1 ! Go from ibyr to END_YR_QCR (the +1 makes it include the first year)
	    ASM_YEARS = END_YR_ASM-ibyr+1 ! Go from ibyr to END_YR_ELEC (the +1 makes it include the first year)

        IF ((CURCALYR .eq. ibyr) .AND. (CURITR .eq. 1)) THEN

            FNAME='IND_COAL         '   ! Specify file to read in coal data/projections (from 2018 to SEDS year plus 3)
            NEW=.FALSE.
            IUNITCOAL=FILE_MGR('O',FNAME,NEW)
		
            Call Read_coal(QCR_YEARS, IUNITCOAL, qcrdata, MNUMYR, NUMIND, IBYR, qcrcokeplnt, qcrindchp, qcrindnchp)


	        FNAME='IND_ELECTRIC         '   ! Specify file to read in electricity data/projections (from 2018 to SEDS year plus 2)
            NEW=.FALSE.
            IUNITCOAL=FILE_MGR('O',FNAME,NEW)
		
            Call Read_electric(ASM_YEARS, IUNITCOAL, asmdata, MNUMYR, NUMIND, IBYR) 
            
            DO IREG=1,4
                indreg=IREG
                IF ((inddir.eq.8).or.(inddir.eq.10).or.(inddir.eq.11).or.(inddir.eq.12).or.(inddir.eq.13)) then     ! Use Quarterly Coal Report data for steam coal instead of MECS
                    IF (MECS_Data(inddir, 5, 7).ne.0.0) THEN    ! Keep value at 0 if MECS is at 0, even if QCR is nonzero
                        qcrdata(29,inddir,indreg) = qcrdata(29,inddir,5) * MECS_Data(inddir, indreg, 7)/MECS_Data(inddir, 5, 7) ! QCR total divided by region based on MECS
                        MECS_Data(inddir, indreg,7) = qcrdata(29,inddir,indreg)                                                 ! QCR value replaces MECS values
                        IF (indreg.eq.4) THEN
                            MECS_Data(inddir, 5,7) = qcrdata(29,inddir,5)
                        ENDIF
                    ENDIF
                ENDIF
            ENDDO
        
        ENDIF
        
        
	  if (inddir == 8 .or. (inddir >=10 .and. inddir <= 13) ) ISPROCFLOW = 1
	  
        DO IREG=1,4
          indreg=IREG

          call rexog ! get macro data

          IF(IYR.EQ.ibyr2)THEN  ! we read everything here

!           In first model year, read input files and do model calculations.

!  ON FIRST YEAR READ THE STEO FILE
            IF(INDNUM.EQ.1.AND.IR.EQ.1) THEN
              CALL IRSTEO
            ENDIF

            IF(INDNUM.EQ.1) THEN
              IF(INDREG.EQ.1) THEN
!******
!         READ What's left of the PRODUCTION AND ENERGY DATA file, ENPROD
!******
                FNAME='ENPROD'
                NEW=.FALSE.
                IUNIT4=FILE_MGR('O',FNAME,NEW)
! open industrial building energy use input ifile and position on first
! non-comment record
                fname='INDBEU'
                new=.false.
                ibeu=file_mgr('O',fname,new)
              ENDIF
            ENDIF

            CALL IEDATA    ! read enprod
! For simplicity, use common fuel indices for all boiler fuels whether used or not
            IFSLOC(1)=4
            ifsloc(2)=7
            ifsloc(3)=10
            ifsloc(4)=11
            ifsloc(5)=12
			if (inddir.ge.7) then	  ! manufacturing has electric boilers; this sets the electric boiler fuel and the ifsmax to 6
				ifsloc(6)=1
				ifsmax=6
			else  ! nonmanufacturing does not have electric boilers; keeps ifsmax at 5
			    ifsmax = 5
			endif
			if(inddir.eq.8.or.&   ! paper
               inddir.eq.9.or.&   ! bchem
               inddir.eq.12.or.&  ! steel
               inddir.eq.21) then ! BOMOther
              ifsloc(7)=16
              ifsloc(8)=22
              ifsmax=8
            endif
            ifsmax=ifsmax+1
            ifsloc(ifsmax)=41  ! hydro
            ifsmax=ifsmax+1
            ifsloc(ifsmax)=48   ! msw

! For Food sub-industry analysis, temporarily fill prodflow based on subindustry shipment share of
! total food shipments.  POT_07/31/2013
             if(inddir.eq.7) then
              DO IS=1,MPASTP
                  isub=((is-1)/4)+1                                                     ! subindustry 1 to 4 with 4 steps each.
                  prodflow(1,IS,1)=foodship(isub,indreg,ibyr2)/foodship(5,indreg,ibyr2) ! sub-industry share of base year food shipments; seems like it needs to use ibyr2, even though
                  prodflow(2,IS,1)=prodflow(1,IS,1)                                     ! this is an end-use industry; maybe it needs to run the first year the model runs?
              enddo
            endif
! POT_07/31/2013 END

            if(inddir.eq.9) then
! For Chemicals sub-industry analysis, temporarily fill prodflow based on subindustry shipment share of
! total chemical shipments.
              DO IS=1,MPASTP
                if(index(indstepname(is),'STEAM').eq.0) then   ! for all but the steam steps...
                  isub=((is-1)/6)+1                                ! subindustry 1 to 4
                  prodflow(1,IS,1)=chemship(isub,indreg,ibyr2)/chemship(5,indreg,ibyr2) ! sub-industry share of base year chemical shipments; seems like it needs to use ibyr2, even though
                  prodflow(2,IS,1)=prodflow(1,IS,1)                                     ! this is an end-use industry; maybe it needs to run the first year the model runs?
                endif
              enddo
            endif

            call ifinlcalc ! recalculate prodcur w/new prodflows

           if(inddir.eq.9) then
! For Chemicals sub-industry analysis, restore prodflow
              DO IS=1,MPASTP
                if(index(indstepname(is),'STEAM').eq.0) then   ! for all but the steam steps...
                  isub=((is-1)/6)+1                                ! subindustry 1 to 4
                  prodflow(1,IS,1)=1.                          ! sub-industry share of 2002 chemical shipments
                  prodflow(2,IS,1)=prodflow(1,IS,1)
                endif
              enddo
            endif


! Read a record from the industrial building energy use file.  Skip lines with "*" in column 1.
! Format of file is comma-separated values but with industry names enclosed in apostrophes.
!           position on next non-comment record
            start='*'
            do while(start.eq.'*')     !keep reading until there is no * in column 1
              read(ibeu,'(a)') start
            enddo
            backspace ibeu            !reposition file to prior record
! read building energy for 1)lighting, 2)hvac, 3)onsite transportation, and 4)facility support
! fuels indices are 1: elec, 2:ngas, 3:steam, 4:dist, 5:lpg
            enbint=0.
            read(ibeu,*) inpind,dumc,inpreg,enbint(1,1), &                  ! lighting
                                           (enbint(2,1:3)), &               ! hvac
                                           (enbint(3,1:2),enbint(3,4:5)), & ! transport
                                           (enbint(4,1:2),enbint(4,4:5))    ! fac.support
            if(inpind.ne.inddir) then
               backspace ibeu
               enbint=0.
            else
! convert building energy use from trillion btu to trillion btu per million employees.
              do ieu=1,4
                do ifx=1,5
                  if(emplx.gt.0.) then
                    enbint(ieu,ifx)=enbint(ieu,ifx)/emplx
                  endif
                enddo
              enddo
            endif
 

! Establish average industry prices based on share of market covered and non-covered
            call INDBIFURC

            call uectpc   ! read MECS updates for uecs, tpcs

!******
!         CALCULATE ENERGY CONSUMPTION IN THE PROCESS AND
!            AND ASSEMBLY COMPONENT.
!******
            ! kpe change --- call calpatot based on industry
			if (ISPROCFLOW == 1) then	
				CALL CALPATOT('tech')
			else
				CALL CALPATOT('original')
			endif
!******
!         CALCULATE BYPRODUCT ENERGY PRODUCED.
!******
            if (inddir.ne.8 .and. inddir.ne.12) then ! KPE conditional
				CALL CALBYPROD  
			else ! initialize variables	
				BYPQTY(:,:,:)=0.0
				DO ifx=1,23
					BYPBSCM(ifx)=0.0
				enddo
				DO ifx=1,7
					BYPBSCI(ifx)=0.0
				enddo
				DO ifx=1,9
				BYPBSCR(ifx)=0.0
				enddo

			endif
			

!******
!         CALCULATE ENERGY CONSUMPTION IN THE BUILDING COMPONENT.
!******
            CALL CALBTOT

!******
!         CALCULATE ELECTRICITY GENERATED BY THE INDUSTRY FOR OWN USE AND SALES.
!******

!****
!    CALCULATE ELECTRICITY GENERATION.
!****

      if (inddir.ne.8 .and. inddir.ne.12) CALL CALGEN  ! kpe adds conditional


      if(prtdbgi.eq.3) then
        call pcoggen
      endif

!****
!    CALCULATE THIS YEAR'S FUEL SHARES AND INTENSITIES.
!****
            if (inddir.ne.8 .and. inddir.ne.12) call calbsc
!******
!         CALCULATE ENERGY CONSUMPTION FOR THE BOILER/STEAM
!            /COGENERATION COMPONENT.
!******
            if (inddir.ne.8 .and. inddir.ne.12) CALL CALSTOT

!******
!         CALCULATE TOTAL ENERGY CONSUMPTION FOR THE
!            INDUSTRY.
!******


	!		if (inddir == 8) then
!			  IF ((curcalyr == ibyr2).and.(curitr == 1)) then
 !               call IS_GETDATA !read ibyr2 MECS data
 !               call READ_IDMinput ! mining inputs -- move to workbook??
 !             endif

!			endif

            CALL INDTOTAL(INDREG)
!******
!         CALCULATE NATIONAL TOTAL ENERGY CONSUMPTION FOR THE
!            INDUSTRY.
!******
            IF(IREG.EQ.4) THEN

              CALL NATTOTAL

            ENDIF
!******
!         FILL IN VALUES FOR NEMS REPORT WRITER VARIABLES.
!******

            CALL CONTAB(INDREG)
            IF(INDREG.EQ.4) CALL CONTAB(5)


            CALL WRBIN  ! write in 2014



          ELSE IF (ISPROCFLOW == 0 .and. (IYR.GT.ibyr2) )  then ! kpe change to nonprocess flow industries; run only
		                                                   ! for years 2015 and later; we skip a year

!******
!       Else, not the first year: just do MODEL CALCULATIONS without data file reading
!******

            INDREG=IREG
!
! read memory management buffers to initialize the current industry, region with
! the most recently available data.
!
            CALL RDBIN
            call rexog  ! get prodx and emplx from NEMS macro variables
! set electricity prices for the industry as baseload or medium load, or other
           if (inddir.eq.7.or.inddir.eq.8.or.inddir.eq.9.or.  & ! primary
               inddir.eq.12.or.inddir.eq.13) then
              prcx(1,indreg,1:2)=prcx(23,indreg,1:2)
              prcxyr(1,indreg,curiyr,1:2)=prcxyr(23,indreg,curiyr,1:2)
            elseif(inddir.ge.14.and.inddir.le.18) then ! 5 metal based durables industries
              prcx(1,indreg,1:2)=prcx(24,indreg,1:2)
              prcxyr(1,indreg,curiyr,1:2)=prcxyr(24,indreg,curiyr,1:2)
            else
              prcx(1,indreg,1:2)=prcx(25,indreg,1:2)
              prcxyr(1,indreg,curiyr,1:2)=prcxyr(25,indreg,curiyr,1:2)
            endif
            IF(IWDBG.EQ.1.AND.IOPEN.EQ.1.AND.LSTITER.EQ.1) &
                  WRITE(IUNIT1,8021) INDDIR
            IF(IWDBG.EQ.1.AND.IOPEN.EQ.1.AND.LSTITER.EQ.1) &
                  WRITE(IUNIT1,8022) INDREG

! Establish average industry prices based on share of market covered and non-covered
            call INDBIFURC

!  for high tech case, read a second set of UECs and TPCs that allow
!  a faster rate of technological improvement for some fuels/industries.
!  The new set is expected to be in the ITECH file, after the MECS set,
!  following a record with the string "hitech"


            if(curcalyr.gt.techstrtyr.and.hitech.eq.1) call uectpc


            ! if (ISPROCFLOW == 0) 
			CALL MODCAL('original')

          ! ENDIF ! OLD

!******
!  CALCULATE INDUSTRY TOTALS.
!******

          CALL WRQTY

!******
!  WRITE INFORMATION TO BE S AVED TO THE memory management buffer
!******
          INDREG=IREG
          ! if (ISPROCFLOW == 0) 
		  CALL WRBIN

        ENDIF ! END OF IF STARTING ON LINE 2305 AND THE ELSE IF FOR END USE INDUSTRIES
        ENDDO     ! KPE end of regional loop, still in industry loop

! Re-invoke regional sequence for tech-choice industries since they are dependent
! on regional shares of prodcur.mo
        IF ((ISPROCFLOW == 1).AND.(curcalyr.gt.ibyr2)) then ! new if statment, still in industry loop
		 ! if (ISPROCFLOW == 1) then
          ! if(inddir.eq.10  .or. inddir.eq.11  .or. inddir.eq. 13 .or. inddir.eq.12 .or. inddir.eq.8) then
            DO IREG=1,4
              indreg=IREG
              CALL RDBIN
              call rexog
			  if (inddir.eq.7.or.inddir.eq.8.or.inddir.eq.9.or.  & ! primary
               inddir.eq.12.or.inddir.eq.13) then
					prcx(1,indreg,1:2)=prcx(23,indreg,1:2)
						prcxyr(1,indreg,curiyr,1:2)=prcxyr(23,indreg,curiyr,1:2)
              else
                 prcx(1,indreg,1:2)=prcx(25,indreg,1:2)
                 prcxyr(1,indreg,curiyr,1:2)=prcxyr(25,indreg,curiyr,1:2)
              endif
              IF(IWDBG.EQ.1.AND.IOPEN.EQ.1.AND.LSTITER.EQ.1) &
                  WRITE(IUNIT1,8021) INDDIR
              IF(IWDBG.EQ.1.AND.IOPEN.EQ.1.AND.LSTITER.EQ.1) &
                  WRITE(IUNIT1,8022) INDREG
              call INDBIFURC
              call modcal('tech')
              call wrqty
              call wrbin
            enddo
          
        endif





   45 CONTINUE

!******
!  CALCULATE NECESSARY COGENERATION VARIABLES FOR NEMS.
!******

        call addupcogs ! add up cogen arrays
        CALL INDCGN


!******
!  CLOSE PRODUCTION AND ENERGY FILE, IF FIRST YEAR.
!******

      IF(IYR.EQ.ibyr2) THEN
        FNAME='ENPROD'
        NEW=.FALSE.
        IUNIT4=FILE_MGR('C',FNAME,NEW)
      ENDIF

  801 FORMAT(1X,'DEBUG TEST FILE, YEAR = ',I4)
  991 FORMAT(3X,'MAIN ROUTINE')
 8021 FORMAT(' INDUSTRY= ',I4)
 8022 FORMAT(' REGION  = ',I4)

      RETURN
      END SUBROUTINE ISEAM
!******
!  FOR THE MODEL DEVELOPER'S REPORT, THIS ROUTINE WILL ADJUST
!  PRICES FOR DISTILLATE, RESIDUAL OIL, COAL, NATURAL GAS
!  AND ELECTRICITY BY A FACTOR SPECIFIED IN THE RUNTIME FILE
!  THIS IS DONE FOR THE INDUSTRIAL SENSITIVITY RUNS.
!******
      SUBROUTINE PRICE
   use i_
      IMPLICIT NONE


      INTEGER ifuel

       DO IR=1,4
          PRCX(1,IR,1:2)=ELEC*PRCX(1,IR,1:2)
          PRCX(23,IR,1:2)=ELEC*PRCX(23,IR,1:2)
          PRCX(24,IR,1:2)=ELEC*PRCX(24,IR,1:2)
          PRCX(25,IR,1:2)=ELEC*PRCX(25,IR,1:2)
          PRCX(3,IR,1:2)=FGAS*PRCX(3,IR,1:2)
          PRCX(4,IR,1:2)=INTGAS*PRCX(4,IR,1:2)
          PRCX(5,IR,1:2)=FGAS*PRCX(3,IR,1:2)
          PRCX(7,IR,1:2)=COAL*PRCX(7,IR,1:2)
          PRCX(10,IR,1:2)=RESID*PRCX(10,IR,1:2)
          PRCX(11,IR,1:2)=DIST*PRCX(11,IR,1:2)
          PRCX(12,IR,1:2)=LPG*PRCX(12,IR,1:2)
          PRCX(13,IR,1:2)=LPG*PRCX(12,IR,1:2)
          do ifuel=1,25
            prcxyr(ifuel,ir,curiyr,1:2)=prcx(ifuel,ir,1:2)
          enddo
       ENDDO

!***********************************************************************AE
! Do lag prices
       DO IR=1,4
          prcxlag(1,IR,1:2)=ELEC*prcxlag(1,IR,1:2)
          prcxlag(23,IR,1:2)=ELEC*prcxlag(23,IR,1:2)
          prcxlag(24,IR,1:2)=ELEC*prcxlag(24,IR,1:2)
          prcxlag(25,IR,1:2)=ELEC*prcxlag(25,IR,1:2)
          prcxlag(3,IR,1:2)=FGAS*prcxlag(3,IR,1:2)
          prcxlag(4,IR,1:2)=INTGAS*prcxlag(4,IR,1:2)
          prcxlag(5,IR,1:2)=FGAS*prcxlag(3,IR,1:2)
          prcxlag(7,IR,1:2)=COAL*prcxlag(7,IR,1:2)
          prcxlag(10,IR,1:2)=RESID*prcxlag(10,IR,1:2)
          prcxlag(11,IR,1:2)=DIST*prcxlag(11,IR,1:2)
          prcxlag(12,IR,1:2)=LPG*prcxlag(12,IR,1:2)
          prcxlag(13,IR,1:2)=LPG*prcxlag(12,IR,1:2)
        ENDDO
!***********************************************************************end AE


      RETURN
      END SUBROUTINE PRICE
!******
!  FOR THE MCLAIN-LIEBERMAN BILL, this routine will
!  SET AVERAGE INDUSTRY ENERGY PRICES BASED ON SHARE OF THE INDUSTRY COVERED BY
!  THE BILL.
      SUBROUTINE indbifurc
   use i_
      IMPLICIT NONE

! Called within the industry/region loop, so ir and inddir are defined in calling program
      INTEGER ifuel,iyyr

      INTEGER RTOVALUE,AB32SW
      EXTERNAL RTOVALUE

!  Check runtime option to turn AB32SW switch for implementation of AB32 cap-and-trade in State of California.
!  The default setting is ON (1).
!
      AB32SW=RTOVALUE('AB32SW  ',1)

      ir=indreg
        DO IFUEL=1,50
          IF(AB32SW.EQ.1) then
            PRCX(IFUEL,IR,3)= (PRCX(IFUEL,IR,1) *     CARBSHR_AB(INDDIR,IR)) &
                          + (PRCX(IFUEL,IR,2) * (1.-CARBSHR_AB(INDDIR,IR)))
            prcxyr(ifuel,ir,CURIYR,1:3)=prcx(ifuel,ir,1:3)
            DO IYYR=9,CURIYR-1
              prcxyr(ifuel,ir,IYYR,3)=(prcxyr(ifuel,ir,IYYR,1) *     CARBSHR_AB(INDDIR,IR)) &
                                     + (prcxyr(ifuel,ir,IYYR,2) * (1.-CARBSHR_AB(INDDIR,IR)))
            ENDDO
          ELSE
          PRCX(IFUEL,IR,3)= (PRCX(IFUEL,IR,1) *     CARBSHR(INDDIR)) &
                          + (PRCX(IFUEL,IR,2) * (1.-CARBSHR(INDDIR)))
          prcxyr(ifuel,ir,CURIYR,1:3)=prcx(ifuel,ir,1:3)
          DO IYYR=9,CURIYR-1
            prcxyr(ifuel,ir,IYYR,3)=(prcxyr(ifuel,ir,IYYR,1) *     CARBSHR(INDDIR)) &
                                   + (prcxyr(ifuel,ir,IYYR,2) * (1.-CARBSHR(INDDIR)))

          ENDDO
          ENDIF
ENDDO

!***********************************************************************AE
! Do lag prices

       DO IFUEL=1,50
         IF(AB32SW.EQ.1) then
           PRCXlag(IFUEL,IR,3)= (PRCXlag(IFUEL,IR,1) *     CARBSHR_AB(INDDIR,IR)) &
                              + (PRCXlag(IFUEL,IR,2) * (1.-CARBSHR_AB(INDDIR,IR)))
         ELSE
          PRCXlag(IFUEL,IR,3)= (PRCXlag(IFUEL,IR,1) *     CARBSHR(INDDIR)) &
                          + (PRCXlag(IFUEL,IR,2) * (1.-CARBSHR(INDDIR)))
         ENDIF
       ENDDO


!***********************************************************************end AE

      RETURN
      END SUBROUTINE indbifurc

!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!  THIS SUBROUTINE READS THE CONTROL FILE INDRUN.
!******
      SUBROUTINE RCNTL
   use i_
      IMPLICIT NONE
      character*80 onerec
      integer first
      INTEGER K,ifuel
      CHARACTER*80 COMMENTi

!******

      INTEGER IUNIT9,IUNIT10,INDINT,INDRG
      REAL COEFF(4), temp(9)
      CHARACTER*15 INDN
      Real sizeshrtemp(6,5,2)
      Integer indsize, isize, jfuel

!******
!  OPEN THE CONTROL FILE INDRUN.
!******

      FNAME='INDRUN'  ! indrun.txt
      NEW=.FALSE.
      IUNIT5=FILE_MGR('O',FNAME,NEW)
      READ(IUNIT5,801)
      READ(IUNIT5,803) ISUBTR   ! SUBROUTINE TRACE OPTION
      READ(IUNIT5,803) INDMAX   ! MAX NUMBER OF INDUSTRIES
      READ(IUNIT5,803) IWDBG    ! DEBUG SWITCH
      READ(IUNIT5,803) ISEDS    ! OPTION FOR SEDS BENCHMARKING
	  READ(IUNIT5,803) ICALIBRATE ! OPTION TO CALIBRATE BACK TO TABLE 6  !SUSAN_UPDATE
      READ(IUNIT5,803) IPRICE   ! OPTION FOR PRICE SENSITIVITIES
      READ(IUNIT5,807) ELEC    !   ELEC PRICE sensitivity factor
      READ(IUNIT5,807) FGAS    !   firm gas price sensitivity factor
      READ(IUNIT5,807) INTGAS  !   interruptible gas price sensitivity
      READ(IUNIT5,807) COAL    !   coal
      READ(IUNIT5,807) RESID   !   resid
      READ(IUNIT5,807) DIST    !   distillate
      READ(IUNIT5,807) LPG     !   liquid petro gas

      READ(IUNIT5,803) ITPC      ! OPTION FOR TPC SENSTIVITIES
      READ(IUNIT5,807) TPC1
      READ(IUNIT5,807) TPC2

      READ(IUNIT5,803)FRZTECH  ! OPTION FOR FROZEN TECH CASE
      READ(IUNIT5,803)HITECH   ! OPTION FOR RAPID TECH CASE
      READ(IUNIT5,803)EETECH   ! OPTION FOR ENERGY EFFICIENT TECH CASE POT_EE

      READ(IUNIT5,803)IRETIRE  ! OPTION FOR RETIREMENT RATE SENSITIVITIES
      READ(IUNIT5,807)RETRATE  ! RETIREMENT RATE MULTIPLIER


      READ(IUNIT5,'(a)',END=99) COMMENTi
      READ(IUNIT5,*,end=99,err=99) LOOKAHEAD !Number of lookahead years for CHP and Motors

! Read Carbshr(i) --Share of each industry's fossil consumption subject to carbon allowance costs.
      read(iunit5,'()')  ! skip a line
      carbshr(:)=1.0  ! default values in case using old control file without this assumption
      do j=1,numind
        read(iunit5,*,end=25) carbshr(j)
      enddo
25    continue
!******
!  CLOSE CONTROL FILE.
!******
99    IUNIT5=FILE_MGR('C',FNAME,NEW)


!******
!  READ
!  BOILER SHARE ELASTICITIES
!******
      FNAME='ITLBSHR'
      IUNIT10=FILE_MGR('O',FNAME,NEW)
      READ(IUNIT10,900)
      READ(IUNIT10,900)
      DO I = 1,1000
        read(iunit10,'(a)') onerec
        first=ichar(onerec(1:1))
        if(first.le.47.or.first.ge.58) then
           exit! exit do loop
        else
          READ(onerec,*,end=399)INDINT,INDRG,COEFF(1)
          TLBSHR(INDINT,INDRG,1)=COEFF(1)  ! fuel shares, k=2,3,4, overridden using data below & Form 860b
        endif
      ENDDO
      read(iunit10,'(a)') onerec ! skip a line

! read MECS boiler/steam/cogen fuel (aka, indirect fuels) in trill. btu
      BSCIBYR=0.
      do indint=7,numind
        do indrg=1,4
          read(iunit10,*,end=499) j,j,(temp(k),k=1,9) ! order on record is Resid,Dist,Ngas,LPG,Coal,Oth pet, pet coke, ELECTRICITY
! copy to fuel order consistent with cogen data arrays, which is 1:coal,2:tot oil,3:ngas,4:wood,5:oth,6:msw
! since we don't have breakout of wood/other/msw, and we want to keep track of oil by fuel, then save
! oil detail into positions 7:8:9
          BSCIBYR(indint,indrg,1)= temp(5) ! coal
          BSCIBYR(indint,indrg,2)= temp(1)+temp(2)+temp(4)+temp(7)+temp(8) ! oil
          BSCIBYR(indint,indrg,3)= temp(3) ! ngas
          BSCIBYR(indint,indrg,4)= temp(6) ! wood/biomass
          BSCIBYR(indint,indrg,5)= 0.      ! other cogen
          BSCIBYR(indint,indrg,6)= 0.      ! msw   cogen
          BSCIBYR(indint,indrg,7)= temp(1) ! residual
          BSCIBYR(indint,indrg,8)= temp(2) ! distillate
          BSCIBYR(indint,indrg,9)= temp(4) ! lpg
          BSCIBYR(indint,indrg,10)= temp(7) ! oth pet
          BSCIBYR(indint,indrg,11)= temp(8) ! pet coke
          BSCIBYR(indint,indrg,12)= temp(9) ! electricity, new for AEO2023

        enddo
      enddo
399   continue

      read(iunit10,'()') ! skip a line
! Read in size share array by industry, fuel, and size group
      Do indsize=1,6 ! non-man, food, paper, chem, metals, other man
         Do ifuel=1,5 ! NG, Coal, Oil products, biomass, electricity (kpe add 10/21/22
            read(iunit10,*,end=499) sizeshrtemp(indsize,ifuel,1),sizeshrtemp(indsize,ifuel,2)
         Enddo
      Enddo
! do sum somes
  do indreg=1,4
    do ifuel=1,12
      BSCIBYR(numind+1,indreg,ifuel)=sum(BSCIBYR(1:numind,indreg,ifuel))
    enddo
  enddo
  do inddir=1,numind+1
    do ifuel=1,12 ! double check the 13 index
      BSCIBYR(inddir,5,ifuel)=sum(BSCIBYR(inddir,1:4,ifuel))
    enddo
  enddo

! Move size shares to proper var
  do inddir=1,numind+1
     do jfuel=1,10
        do isize=1,2
           If (jfuel.EQ.1.OR.jfuel.EQ.2) Then       ! NG=1, coal=2
              ifuel=jfuel
           ElseIf (jfuel.GE.3.AND.jfuel.LE.5) Then   ! oil products
              ifuel=3
           ElseIf (jfuel.EQ.6) Then   ! electricity
              ifuel=5
		   else
		  ! now fuels categorides diverge--see ~2400 for ifsmax 
			   if(inddir.eq.8.or.&   ! paper
				   inddir.eq.9.or.&   ! bchem
				   inddir.eq.12.or.&  ! steel
				   inddir.eq.21) then ! BOMOther
					  if ((jfuel.GE.7).AND.(jfuel.LE.8)) Then   ! Other & biomass
						 ifuel=3
					  else 
						 ifuel=4
					  endif
				elseif ((inddir.ge.7).AND.(jfuel.ge.7)) then
						 ifuel=4
				Endif
			endif

           If (inddir.GE.1.AND.inddir.LE.6) Then     ! Non-manufacturing
              sizeshr(inddir,jfuel,isize)=sizeshrtemp(1,ifuel,isize)
           ElseIf (inddir.EQ.7) Then            ! Food
              sizeshr(inddir,jfuel,isize)=sizeshrtemp(2,ifuel,isize)
           ElseIf (inddir.EQ.8) Then            ! Paper
              sizeshr(inddir,jfuel,isize)=sizeshrtemp(3,ifuel,isize)
           ElseIf (inddir.EQ.9) Then            ! Chemicals
              sizeshr(inddir,jfuel,isize)=sizeshrtemp(4,ifuel,isize)
           ElseIf (inddir.EQ.10.OR.inddir.EQ.11.OR.inddir.GE.14) Then ! .AND.inddir.LE.21) Then  ! Oth. man.
              sizeshr(inddir,jfuel,isize)=sizeshrtemp(6,ifuel,isize)
           ElseIf (inddir.EQ.12.OR.inddir.EQ.13) Then        ! Metals
              sizeshr(inddir,jfuel,isize)=sizeshrtemp(5,ifuel,isize)
           Endif
        Enddo
     Enddo
  Enddo

      IUNIT10=FILE_MGR('C',FNAME,NEW)
  if(prtdbgi.eq.3) then
! write out in approximately the same layout as input file itlbshr.txt'
    write(6,'(a)') 'Initial base year BSC fuel use as read in -- before Form 860b adjustment'
    write(6,'(a)') 'IND REG    Resid     Dist     ngas      LPG     coal    other    oth pet    pet coke   oil-tot   electric total'
    do inddir=1,numind+1
      write(6,*)
      do indreg=1,5
        write(6,'(2i3,10f9.2)') inddir,indreg, &
         BSCIBYR(inddir,indreg,7),  &  ! resid
         BSCIBYR(inddir,indreg,8),  &  ! disti
         BSCIBYR(inddir,indreg,3),  &  ! ngas
         BSCIBYR(inddir,indreg,9),  &  ! LPG
         BSCIBYR(inddir,indreg,1),  &  ! coal
         BSCIBYR(inddir,indreg,4),  &  ! other (renewable)
         BSCIBYR(inddir,indreg,10), &  ! oth pet
         BSCIBYR(inddir,indreg,11), &  ! pet coke
         BSCIBYR(inddir,indreg,2),  &  ! oil-tot
         BSCIBYR(inddir,indreg,12),  &  ! electricity--new for aeo2023
         sum(BSCIBYR(inddir,indreg,1:4))
      enddo
    enddo
  endif

      return
499   write(6,*) ' early end of file on itlbshr.txt reading boiler fuel'
      IUNIT10=FILE_MGR('C',FNAME,NEW)

  801 FORMAT(1X)
  803 FORMAT(/,I4)
  805 FORMAT(/,A18)
  807 FORMAT(/,3X,F4.2)
  900 FORMAT(1X)
      RETURN
      END SUBROUTINE RCNTL

!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!  THIS SUBROUTINE FILLS IN THE VALUE OF THE MODEL VARIABLES.
!  VARIABLES INCLUDE EMPLOYMENT AND VALUE OF OUTPUT.
!******
      SUBROUTINE REXOG
   use i_
      IMPLICIT NONE
      INTEGER ISECT,IS,IX,IY

      ir=indreg
      isect=inddir
      IF(IR.EQ.1) THEN
        IX=1
        IY=2
      elseif(IR.EQ.2) THEN
        IX=3
        IY=4
      elseif(IR.EQ.3) THEN
        IX=5
        IY=7
      elseif(IR.EQ.4) THEN
        IX=8
        IY=9
      ENDIF
!******
!  FOR EACH INDUSTRY, FILL IN VALUE OF OUTPUT.
!******
! revised employment variable empind is now ordered the same as outind

      prodvx=0.
      emplx=0.

      DO ID=IX,IY
        IF (ISECT.EQ.11) THEN
           PRODVX=PRODVX+OUTIND(22,ID)
        ELSE
           PRODVX=PRODVX+OUTIND(ISECT,ID)
        ENDIF
        EMPLX=EMPLX+EMPIND(ISECT,ID)
      ENDDO

!******
!  ADJUST UNITS FROM NEMS (MILLION) TO WHAT WE NEED (THOUSAND)
!******

      EMPLX=EMPLX*1000.0

      if(iyr.eq.ibyr2) then
         prodvxlag=prodvx
      endif

!******
!  FORMAT STATEMENTS
!******

  991 FORMAT(3X,'REXOG')

      RETURN
      END SUBROUTINE REXOG

	! SUSAN CUT OLD WEXOG ......

! SUSAN NEW WEXOG CODE FROM FILE WEXOG_WIRE2.F

!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!  WEXOG IMPLEMENTS BENCHMARKING AND ASSIGNS THE VARIABLES
!   THAT GO BACK TO THE NEMS SYSTEM.
!  THIS INCLUDES ANY SHARING TO CENSUS DIVISIONS AS NECESSARY.
!******  This is the start of old WEXOG up to creating SEDS9 ***************
      SUBROUTINE WEXOG
   use i_
      IMPLICIT NONE
!******

      real divshr
      external divshr, rtovalue
      INTEGER STEOBM,RTOVALUE
	  INTEGER INDBMOVR
      INTEGER INDBMOVR2         ! Benchmark Switch (3/4/09-EDS)
	  INTEGER FADEYRS		    ! number of years to fade ---kpe
      PARAMETER(INDBMOVR=0)  ! 0 for reference, 2 for sidecases
!******
!  DECLARE INTERNAL VARIABLES.
!******

    INTEGER ICD,ICR,IY,IYEAR,NYR,FUEL_INDEX,IYLAG,ITT,IFF,IFUEL, ILOOP,CHEM_INDEX,IMAC
    INTEGER DOONCE(MNUMYR)/MNUMYR*0/   ! variable to make sure some things are just done once

    SAVE DOONCE

    INTEGER NCENSREG, NCENSDIV, MDivPerReg, ICOUNT, MAINFL, RENEWFL
    INTEGER CREG(9)/1,1,2,2,3,3,3,4,4/
    PARAMETER(NCENSREG=4,NCENSDIV=9,MDivPerReg=3,MAINFL=22,RENEWFL=8)
    REAL SEDS9(11,MAINFL),SEDS4(5,MAINFL)
    REAL RSEDS9(11,RENEWFL),RSEDS4(5,RENEWFL)
    REAL CHECK(MAINFL), RCHECK(RENEWFL)
    REAL BF_SEDS(MAINFL,NCENSREG)
    REAL RBF_SEDS(RENEWFL,NCENSREG)
    REAL BFCHECK(MAINFL)
    REAL RBFCHECK(RENEWFL)
    REAL STEO(MAINFL)
    REAL RSTEO(RENEWFL)
    REAL BMAIN(MAINFL,5)             ! UNBENCHMARKED MODEL RESULTS FOR MAIN FUELS
    REAL BRENEW(RENEWFL,5)           ! UNBENCHMARKED MODEL RESULTS FOR RENEWABLES
    REAL FADE
    REAL fade_factor ! (1,1)            ! refers to new function
    REAL BMAIN_SEDS_ADJUSTED(MAINFL)
    REAL BRENEW_SEDS_ADJUSTED(RENEWFL)
    REAL BF_STEO(MAINFL)
    REAL RBF_STEO(RENEWFL)
    REAL BMAIN_ADJUSTED(MAINFL,5)
    REAL BRENEW_ADJUSTED(RENEWFL,5)
    REAL FIRMSHR(5),SUMCDIV,DSHARE,ADJUSTED,RADJUSTED, REF(22)

    real sELeth(9),sNGeth(9),sCLeth(9)  ! backup regional shares for missing regional ethanol quantities

! 911 new LFMM-tied chemical model
    real nonpropanefeed
    real totalfeedtemp

!      real propyleneratio ! propane & naphtha feedstock : propylene price ratio; NSK commented out 9/24/2019
    real feedstockratio ! propane : naphtha price ratio
    real bulkchemratio ! indexed growth of bulk chemicals
!      real propylenebase  ! baseline year propylene consumption; NSK commented out 9/24/2019
    real ethaneproduction ! national ethane production in trillion BTU
!      real propyleneincrement ! incremental propylene demand which can substitute for LPG feedstock; NSK commented out 9/24/2019
      
         
      real pcfbase ! baseline national PCF/naphtha feedstock consumption
      real lpgbase ! baseline national LPG feedstock consumption
      real feedstocktotal ! total current feedstock in trills
      real feedstockdiff ! difference between current feedstock total and baseyear feedstock total
      real pcfincrement ! adjusted incremental PCF demand
      real lpgincrement ! adjusted incremental LPG demand
      real pcfnew ! new PFC feedsotck final demand
      real lpgnew ! new LPG feedstock final demand
      real lpgold
      real pcfold
      real pcftemp
      real heattemp(MNUMYR)
      real heattemp2(MNUMYR)
      real ethanefrac ! fraction of LPG that is ethane; used for PCF/LPG price discriminant
      real Naphtha_to_ethane    ! Convert tBtu of naphtha cracking consumption to tBtu of ethane consumption
      
      ! New chemical model variables (NSK 2021)
      real, parameter:: H2_heat = 134.195           ! MMBtu/tonne
      real, parameter:: Methane_heat = 52.618       ! MMBtu/tonne
      real, parameter:: ULSD_heat = 41.9540         ! MMBtu/tonne 
      real, parameter:: Ethane_heat = 0.0000489808  ! trillion Btu/tonne
      real, parameter:: Naphtha_heat = 0.0000431386 ! trillion Btu/tonne   
      

      ! The new chemical model considers 11 chemical products from cracking ethane and naphtha  NSK
      ! Cracking products and indices (variable CHEM_INDEX):
      !   1     ethylene
      !   2     H2
      !   3     methane
      !   4     propylene
      !   5     butadiene
      !   6     butanes/butylenes   (we assume it is just all butanes)
      !   7     benzene
      !   8     xylene
      !   9     toluene
      !   10    fuel oil
      !   11    other aromatics

      ! Mass yields from cracking ethane or naphtha (in tonnes product per tonne feedstock cracked)
      real X_ethane(11)/0.8091, 0.0591, 0.0704, 0.0194, 0.0178, 0.0081, 0.0081, 0.0, 0.0008, 0.0, 0.0073/           ! Yields from ethane cracking
      real X_naphtha(11)/0.3867, 0.0097, 0.1694, 0.1547, 0.0476, 0.0507, 0.0437, 0.0224, 0.0166, 0.0251, 0.0735/    ! Yields from naphtha cracking
      
      ! Slopes and intercepts for chemical products price regressions (only for cracking products 4 through 8)
      real Chem_price_slope(11)/0.0, 0.0, 0.0, 13.7740, 19.9012, 6.65763, 5.60443, 8.00159, 9.19759, 0.0, 0.0/                  ! (1987$/tonne product)/(1987$/b WTI)
      real Chem_price_intercept(11)/0.0, 0.0, 0.0, -60.5256, 18.8091, -7.81998, 245.34893, 160.36134, 116.15598, 0.0, 0.0/      ! 1987$/tonne product

      ! Ethylene demand regression variables
      real Ethylene_x(5)    ! X variables for regression (macro shipments); filled in below
      real Ethylene_y(5)/26.185, 26.130, 27.220, 29.975, 31.350/    ! Y variables for regression (ethylene produced in 2015–19, in million tonnes; American Chemistry Council data)
      ! real Ethylene_y(28)/18.564, 18.709, 20.201, 21.3, 22.275, 23.17, 23.615, 25.385, 25.115, 22.51, 23.645, &
      !          22.977, 25.685, 23.975, 25.02, 25.415, 22.555, 22.61, 23.975, 24.41, 24.025, 25.035, 24.66, 26.185, 26.13, 27.22, 29.975, 31.35/

      real Ethylene_slope               ! Slope of ethylene regression (million tonnes ethylene/billion dollars of shipments)
      real Ethylene_intercept           ! Intercept of ethylene regression (million tonnes ethylene)
      real Ethylene_demand(MNUMYR)      ! Ethylene demand (tonnes ethylene)
      real Base_ethane_demand(MNUMYR)   ! Ethane demand if all flex capacity consumed ethane (tBtu ethane)
      real Ethylene_benchmark           ! Benchmark ethylene demand regression to last year of read-in feedstock numbers (tonnes/tonne)
      
      ! Cracking capacity variables
      real, parameter:: Naphtha_nonflex_consumption = 550.  ! Base naphtha cracking consumption in tBtu; assumed constant over model period
      real Naphtha_flex_consumption(5, MNUMYR)              ! Naphtha consumption from flexible cracking capacity, in tBtu
      real Slow_flex_capacity(5, MNUMYR)                    ! Ethane cracking capacity (in tonnes ethylene produced) that could switch to 
                                                            !   flexible cracking capacity given sustained favorable naphtha economics
      real Quick_flex_capacity(5, MNUMYR)                   ! Cracking capacity (in tonnes ethylene produced) that can switch quickly between 
                                                            !   cracking naphtha or cracking ethane, based on economic favoribility
      
      ! Other chemical model variables
      real Naphtha_price_mass(5,MNUMYR)         ! Naphtha price in 1987$/tonne
      real Ethane_price_mass(5,MNUMYR)          ! Ethane price in 1987$/tonne
      real Cost_ethylene_from_ethane(5,MNUMYR)  ! Cost of ethylene cracked from ethane, in 1987$/tonne ethylene produced
      real Cost_ethylene_from_naphtha(5,MNUMYR) ! Cost of ethylene cracked from naphtha, in 1987$/tonne ethylene produced
      real Chem_product_price(11, curiyr)       ! Price of 11 cracking products, in 1987$/tonne
      real Naphtha_to_HGL(5,MNUMYR)             ! Naphtha demand coming out of the end-use model that is now being allocated to total HGL feedstock (in tBtu of ethane that is replacing the naphtha cracking)
      
      !   FEEDSTOCK TARGETS

    ! FEEDSTOCK PERCENTAGES BY REGION PROVIDED BY PETER
        REAL FEEDNGPERCENT(4)/0.01,0.13,0.83,0.03/
        REAL FEEDLPGPERCENT(4) /0.01,0.03,0.96,0.0/     ! NSK updated 10/16/2019
        REAL COKECOALIMPORTPERCENT(11)/0.0,0.18,0.55,0.01,0.0,0.01,0.25,0.0,0.0,0.0,1.0/    ! Approximate 2014–18 average share of net coke coal exports from 1/2020 Quarterly Coal Report (complicated
                                                                                            ! because two Census Divisions have net imports, but the total is a net export). Last two entries are for the
                                                                                            ! unused Division and the U.S. total, respectively. NSK 2/24/2020

      integer propyleneflag ! allows for continued artificial scaling of future propylene demand once it is needed      
      Integer, parameter:: START_YR_FEEDSTOCK=2006    ! Beginning of feedstock data
      Integer, parameter:: END_YR_FEEDSTOCK=2023      ! Last year of feedstock data in feedstock.csv; 2022 as of AEO2021
      Integer, parameter:: MAX_FRAC_YEARS=37          ! Last index year of feedstock data in EthaneReg.csv and PropaneReg.csv; 37 (corresponding to 2026) as of AEO2023
      Integer :: FEEDYEARS
      Integer:: MAX_YEARS
      Integer Hist_Yr
      Integer L, M
    
! feedlpgtotal, feedngtotal, and feedethtotal will have a varying number of entries, depending on the start (START_YR_FEEDSTOCK) and end (SEDSLASTYR+FEEDYEARS)of the data period
      REAL,ALLOCATABLE::feedngtotal(:)                  ! feedngtotal is allocatable, because the number of entries can change every year
      REAL,ALLOCATABLE::feedlpgtotal(:)                 ! feedlpgtotal is allocatable, because the number of entries can change every year
      REAL,ALLOCATABLE::feedethtotal(:)                 ! feedethtotal is allocatable, because the number of entries can change every year; need to connect this to other ethane variables (new and current, e.g. ethold)
      REAL,ALLOCATABLE::feedpropanetotal(:)             ! feedpropanetotal is allocatable, because the number of entries can change every year
      REAL,ALLOCATABLE::feednormbutanetotal(:)          ! feednormbutanetotal is allocatable, because the number of entries can change every year
      REAL,ALLOCATABLE::feedisobutanetotal(:)           ! feedisobutanetotal is allocatable, because the number of entries can change every year
      REAL,ALLOCATABLE::feedpropylenetotal(:)           ! feedpropylenetotal is allocatable, because the number of entries can change every year
      REAL,ALLOCATABLE::feednatgasolinetotal(:)         ! feednatgasolinetotal is allocatable, because the number of entries can change every year
      REAL,ALLOCATABLE::feednaphtotal(:)                ! feednaphtotal is allocatable, because the number of entries can change every year
	  
   
! NSK 10/3/2019      
      
      REAL,ALLOCATABLE::EthaneDivFrac(:, :)        ! EthaneDivFrac and PropaneDivFrac are the fraction of total ethane or propane feedstock (respectively) in a given Census Division (second
      REAL,ALLOCATABLE::PropaneDivFrac(:, :)       ! argument, always 1 to 9) in a given year (first argument and the reason the variable is allocatable; goes from 1990 to STEOLastYr+4, where 1990=1)
      REAL PropyleneDivFrac(9)/0.0,0.053,0.012,0.0,0.015,0.009,0.895,0.0,0.016/ ! propylene regional fractions of total consumption, based on Warren's calculations; kept constant over all years; NSK 9/26/2019
      REAL NaphthaDivFrac(4)/0.0,0.0,1.0,0.0/

 !!!!!!!!!!!!!!
      
      REAL::aerngfeedhistory(16)                        ! aerngfeedhistory will always have 16 entries (1990 through 2005, inclusive)
      REAL::aerlpgfeedhistory(16)                       ! aerlpgfeedhistory will always have 16 entries (1990 through 2005, inclusive)
      REAL::aerethfeedhistory(16)                       ! aerethfeedhistory will always have 16 entries (1990 through 2005, inclusive); need to connect this to other ethane variables (new and current, e.g. ethold)
      REAL::aerpropanefeedhistory(16)                   ! aerpropanefeedhistory will always have 16 entries (1990 through 2005, inclusive)
      REAL::aernormbutanefeedhistory(16)                ! aernormbutanefeedhistory will always have 16 entries (1990 through 2005, inclusive)
      REAL::aerisobutanefeedhistory(16)                 ! aerisobutanefeedhistory will always have 16 entries (1990 through 2005, inclusive)
      REAL::aerpropylenefeedhistory(16)                 ! aerpropylenefeedhistory will always have 16 entries (1990 through 2005, inclusive)
      REAL::aernatgasolinefeedhistory(16)               ! aernatgasolinefeedhistory will always have 16 entries (1990 through 2005, inclusive)      
      REAL::aernaphfeedhistory(16)                      ! aernaphfeedhistory will always have 16 entries (1990 through 2005, inclusive)

      
      !*************************************
      
    character*20 FUELNAME(22)

      DATA  FUELNAME/&
      '1 Electricity     ', & !   1,
      '2 NA              ', & !   2,
      '3 NG CORE         ', & !   3,
      '4 NG NONCORE      ', & !   4,
      '5 NG FEEDSTOCK    ', & !   5,
      '6 LEASE AND PLANT ', & !   6, should come from NGMM
      '7 STEAM COAL      ', & !   7,
      '8 MET COAL        ', & !   8,
      '9 NET COKE IMPORT ', & !   9,
      '10 RESID           ', & !  10,
      '11 DISTILLATE      ', & !  11,
      '12 LPG HP          ', & !  12,
      '13 LPG FEEDSTOCK   ', & !  13,
      '14 MOGAS           ', & !  14,
      '15 STILL GAS       ', & !  15,
      '16 PET COKE        ', & !  16,
      '17 ASPHALT         ', & !  17,
       '18 LUBES & WAXES   ', & !  18,
    '19 PET CHEM FEED   ', & !  19,
    '20 KEROSENE        ', & !  20,
    '21 OTHER PETRO FEED', & !  21,
    '22 OTHER PETRO     '/    ! 22,

       CHARACTER*20 RFUELNAME(8)
       DATA RFUELNAME/&
       '1 HYDROPOWER     ', & ! 1
       '2 BIOMASS-WOOD   ', & ! 2
       '3 BIOMASS-PULPING', & ! 3
       '4 GEOTHERMAL     ', & ! 4
       '5 SOLAR          ', & ! 5
       '6 PHOTOVOLTAIC   ', & ! 6
     '7 WIND           ', & ! 7
     '8 MSW            '/   ! 8



! Index Constants for Industrial Tables 35 to 44 not sure why this is here ?????
    integer ixEL/1/,ixNG/2/,ixCL/3/,ixMC/4/, &
            ixCI/5/,ixRF/6/,ixDS/7/,ixLG/8/,ixMG/9/, &
            ixSG/10/,ixPC/11/,ixAS/12/,ixPF/13/,ixKS/14/, &
            ixOP/15/,ixNF/16/,ixLF/17/,ixRN/18/

    INTEGER SF,ISEDYR,IOWN,IGRD,IYY

    INTEGER ING3/3/,ICL1/1/,IRL2/2/

    real asphalttarget(5)
    real asphaltpercent(5)

    integer indus
      
    
!******
!  INITIALIZE VARIOUS INTERNAL VARIABLES.
!******

      IY=IYR-1989
      IYLAG=IY-1
      ITT=0
      IFF=0

      IF(ISUBTR.EQ.1.AND.IOPEN.EQ.1.AND.LSTITER.EQ.1) &
        WRITE(IUNIT1,991)
900   FORMAT(1X)

      sELeth(1:9)=(/0.,0.,0.31,0.69,0.,0.,0.,0.,0./)  !  backup regional shares
      sNGeth(1:9)=(/0.,0.,0.30,0.70,0.,0.,0.,0.,0./)
      sCLeth(1:9)=(/0.,0.,0.28,0.72,0.,0.,0.,0.,0./)

      if(sum(qNGeth(curiyr,1:9)).eq.0.0) qNGeth(curiyr,1:9)=qNGeth(curiyr,11)*sNGeth(1:9)
      if(sum(qELeth(curiyr,1:9)).eq.0.0) qELeth(curiyr,1:9)=qELeth(curiyr,11)*sELeth(1:9)
      if(sum(qCLeth(curiyr,1:9)).eq.0.0) qCLeth(curiyr,1:9)=qCLeth(curiyr,11)*sCLeth(1:9)



! Fill SEDS vars--Done every year--the min(CURIYR,MSEDYR) returns the year index or the last
! SEDS year, whichever is smaller.
!

! START OF MY NEW CODING

! 						TQMAIN          BMAIN       Q OUTPUT VAR
!------------------     --------       ---------    ---------------------
! ELECTRICITY          	TQMAIN(1,ICR)    BMAIN(1,1:5)    QELIN
! NA                   	TQMAIN(2,ICR)    BMAIN(2,1:5)    N/A
! NG H&P CORE          	TQMAIN(3,ICR)    BMAIN(3,1:5)    QGFIN
! NG H&P NONCORE       	TQMAIN(4,ICR)    BMAIN(4,1:5)    QGIIN
! NG FEEDSTOCK         	TQMAIN(5,ICR)    BMAIN(5,1:5)    INQNGPF
! NG LEASE AND PLANT   	TQMAIN(6,ICR)    BMAIN(6,1:5)    NOT FILLED BY WEXOG; comes from NGMM
! STEAM COAL      		TQMAIN(7,ICR)    BMAIN(7,1:5)    QCLIN
! MET COAL        		TQMAIN(8,ICR)    BMAIN(8,1:5)    QMCIN
! NET COKE IMPORTS    	TQMAIN(9,ICR)    BMAIN(9,1:5)    QCIIN
! RESIDUAL FUEL      	TQMAIN(10,ICR)   BMAIN(10,1:5)    QRSIN
! DISTILLATE      		TQMAIN(11,ICR)   BMAIN(11,1:5)    QDSIN
! LPG H&P        		TQMAIN(12,ICR)   BMAIN(12,1:5)    QLGIN
! LPG FEEDSTOCK      	TQMAIN(13,ICR)   BMAIN(13,1:5)    INQLGPF
! MOGAS          		TQMAIN(14,ICR)   BMAIN(14,1:5)    QMGIN
! STILL GAS        		TQMAIN(15,ICR)   BMAIN(15,1:5)    QSGIN
! PET COKE        		TQMAIN(16,ICR)   BMAIN(16,1:5)    QPCIN
! ASPHALT AND ROAD OIL 	TQMAIN(17,ICR)   BMAIN(17,1:5)    QASIN
! LUBES & WAXES      	TQMAIN(18,ICR)   BMAIN(18,1:5)    QLUIN
! PETROCHEM FEEDSTOCK  	TQMAIN(19,ICR)   BMAIN(19,1:5)    QPFIN
! KEROSENE        		TQMAIN(20,ICR)   BMAIN(20,1:5)    QKSIN = 0 after last STEO year
! OTHER PETRO FEEDSTOCK TQMAIN(21,ICR)   BMAIN(21,1:5)    QOTIN
! OTHER PETRO      		TQMAIN(22,ICR)   BMAIN(22,1:5)    QOTIN

! TQRENEW
! HYDRO          		TQRENW(1,ICR)   BRENEW(1,1:5)    QHOIN
! BIOMASS - WOOD    	TQRENW(2,ICR)   BRENEW(2,1:5)    QBMIN
! BIOMASS - PULP    	TQRENW(3,ICR)   BRENEW(3,1:5)    QBMIN
! GEOTHERMAL       		TQRENW(4,ICR)   BRENEW(4,1:5)    QGEIN
! SOLAR          		TQRENW(5,ICR)   BRENEW(5,1:5)    QSTIN
! PHOTOVOLTAIC      	TQRENW(6,ICR)   BRENEW(6,1:5)    QPVIN
! WIND          		TQRENW(7,ICR)   BRENEW(7,1:5)    QWIIN
! MUNI WASTE      		TQRENW(8,ICR)   BRENEW(8,1:5)    QMSIN

! BIOMASS WOOD AND PULPING LIQUOR ARE COMBINED IN THE BENCHMARKING.  THEY
! WILL HAVE THE SAME BENCHMARK FACTORS
! OTHER INDUSTRIAL Q VARIALBES WHICH WILL BE WRITTEN OUT:
! INQNGHP -- NATURAL GAS TOTAL HEAT AND POWER -- NEW VARIABLE TO BE CREATED
! QNGIN = QGFIN + QGIIN + INQNGPF
! QRLIN = QRSIN
! QLGIN = INQLGPF + INQLGHP
! INQLGHP -- LPG HEAT AND POWER -- NEW VARIABLE TO BE CREATED

!*******************************
! New code to read in feedstock value, NAL and NSK 06/19/19
    
    FEEDYEARS = END_YR_FEEDSTOCK - SEDSLASTYR
    MAX_YEARS = END_YR_FEEDSTOCK-START_YR_FEEDSTOCK+1 ! Go from START_YR_FEEDSTOCK to END_YR_FEEDSTOCK (the +1 makes it include the first year)
    
IF (CURCALYR .eq. ibyr2 .AND. CURITR .eq. 1) THEN
	
      ALLOCATE(feedngtotal(MAX_YEARS))
      ALLOCATE(feedlpgtotal(MAX_YEARS))
      ALLOCATE(feedethtotal(MAX_YEARS))
      ALLOCATE(feedpropanetotal(MAX_YEARS))
      ALLOCATE(feednormbutanetotal(MAX_YEARS))
      ALLOCATE(feedisobutanetotal(MAX_YEARS))
      ALLOCATE(feedpropylenetotal(MAX_YEARS))
      ALLOCATE(feednatgasolinetotal(MAX_YEARS))
      ALLOCATE(feednaphtotal(MAX_YEARS))
 
! New code to read in ethane and propane Census Region fractions NSK 10/3/2019
      ALLOCATE(EthaneDivFrac(9, MAX_FRAC_YEARS))
      ALLOCATE(PropaneDivFrac(9, MAX_FRAC_YEARS)) 	  	  	  

    FNAME='FEEDSTOCK         '      ! Specify file to read in LPG and natural gas feedstock data/projections (from 2006 to SEDS year plus 4)
    NEW=.FALSE.
    IUNITFEED=FILE_MGR('O',FNAME,NEW)
		
    Call Read_feedstock(SEDSLASTYR, MAX_YEARS, FEEDYEARS, START_YR_FEEDSTOCK, IUNITFEED, feedngtotal, feedlpgtotal, feedethtotal, &
                          feedpropanetotal, feedpropylenetotal, feednormbutanetotal, feedisobutanetotal, feednatgasolinetotal, feednaphtotal)
    
	
    FNAME='FEEDSTKAER        '      ! Specify file to read in LPG and natural gas feedstock HISTORY (from 1990 to 2005)
    NEW=.FALSE.
    IUNITFAER=FILE_MGR('O',FNAME,NEW)
    
    Call Read_feedstock_AER(IUNITFAER, aerngfeedhistory, aerlpgfeedhistory, aerethfeedhistory, aerpropanefeedhistory, &
                              aerpropylenefeedhistory, aernormbutanefeedhistory, aerisobutanefeedhistory, aernatgasolinefeedhistory, aernaphfeedhistory)
  
                              
    FNAME='ETHANEREG         '      ! Specify file to read in ethane feedstock fractions (from 1990 to STEO last year plus 4)
    NEW=.FALSE.
    IUNITFRACETH=FILE_MGR('O',FNAME,NEW)
   
    Call Read_eth_frac(MAX_FRAC_YEARS, IUNITFRACETH, EthaneDivFrac)
    
    
    FNAME='PROPANEREG         '      ! Specify file to read in ethane feedstock fractions (from 1990 to STEO last year plus 4)
    NEW=.FALSE.
    IUNITFRACPROP=FILE_MGR('O',FNAME,NEW)
   
    Call Read_prop_frac(MAX_FRAC_YEARS, IUNITFRACPROP, PropaneDivFrac)
      
END IF

!*******************************

! FOR ALL YEARS

! CREATE BMAIN(20,5) AND FIRMSHR(5)

!  CREATE FADE FACTORS.  FADE IS USED TO CREATE A COMPOSITE BENCHMARK FACTOR
!  PREVIOUSLY THIS WAS IN A LOOP ... WE ONLY NEED TO DO IT ONCE PER YEAR

       INDBMOVR2 = RTOVALUE('INDBMOVR',0)
! for now, comment out the FADEYRS variable until after modelling season
!	   FADEYRS   = RTOVALUE('INDSTEOFADE',10)
	   
	   FADEYRS = 12
	   FADE = 0.0
	   
	   FADE = fade_factor(FADEYRS,INDBMOVR2)  ! KPE function--# of years to fade, indbmovr

 
 ! replacing the following with above function
  !     FADE=0.0           ! PRE STEO YEARS
  !     IF(CURCALYR .GT. SedsLastYr) THEN
  !      IF (CURCALYR .LE. (STEOLastYr - INDBMOVR)) THEN
  !        FADE=1.0         ! STEO Years 2010-2013
  !        ELSE IF (CURCALYR .EQ. (STEOLastYr - INDBMOVR +1)) THEN
  !        FADE=0.8       ! fade gone after 5 years
  !        ELSE IF (CURCALYR .EQ. (STEOLastYr - INDBMOVR +2)) THEN
  !        FADE=0.6
  !        ELSE IF (CURCALYR .EQ. (STEOLastYr - INDBMOVR +3)) THEN
  !        FADE=0.5
  !        ELSE IF (CURCALYR .EQ. (STEOLastYr - INDBMOVR +4)) THEN
  !        FADE=0.4
  !        ELSE IF (CURCALYR .EQ. (STEOLastYr - INDBMOVR +5)) THEN
  !        FADE=0.3
  !        ELSE IF (CURCALYR .EQ. (STEOLastYr - INDBMOVR +6)) THEN
  !        FADE=0.2
  !        ELSE IF (CURCALYR .EQ. (STEOLastYr - INDBMOVR +7)) THEN
  !        FADE=0.15
  !        ELSE IF (CURCALYR .EQ. (STEOLastYr - INDBMOVR +8)) THEN
  !        FADE=0.1
  !        ELSE IF (CURCALYR .EQ. (STEOLastYr - INDBMOVR +9)) THEN
  !        FADE=0.05
  !        ELSE
  !        FADE=0.0
  !        END IF
  !      END IF

    ! CREATE NATIONAL REFINERY DATA FOR OUTPUT LATER

    REF(1) = QELRF(11,CURIYR) + QELETH(CURIYR,11) + OGELSHALE(CURIYR)
    REF(2) = 0
    REF(3) = QNGRF(11,CURIYR) + QNGETH(CURIYR,11) + QGTLRF(11,CURIYR) + CGOGSQ(11,CURIYR,ING3)
    REF(4) = 0
    REF(5) = 0
    REF(6) = 0
    REF(7) = QCLRF(11,CURIYR) + QCLETH(CURIYR,11)  + CGOGSQ(11,CURIYR,ICL1)
    REF(8) = 0
    REF(9) = 0
    REF(10) = QRLRF(11,CURIYR) + CGOGSQ(11,CURIYR,IRL2)
    REF(11) = QDSRF(11,CURIYR)
    REF(12) = QLGRF(11,CURIYR)
    REF(13) = 0
    REF(14) = 0
    REF(15) = QSGRF(11,CURIYR)
    REF(16) = QPCRF(11,CURIYR) + QCCRF(11,CURIYR)
    REF(17) = 0
    REF(18) = 0
    REF(19) = 0
    REF(20) = 0
    REF(21) = QOTRF(11,CURIYR)
    REF(22) = QOTRF(11,CURIYR)

    IF ((FCRL .EQ. 1) .AND. (CURCALYR .EQ. ibyr2)) THEN
	  WRITE(IUNITBENCH,*) "INDBMOVR = ", INDBMOVR, "INDBMOVR2 = ", INDBMOVR2
	  WRITE(IUNITBENCH,*) "******************************************************"
      WRITE(IUNITBENCH,*) " LPG FEEDSTOCK ANALYSIS"
    DO ILOOP = 21,23
       WRITE(IUNITBENCH,*) "CURIYR = ", ILOOP
       WRITE(IUNITBENCH,*) "LPG:  ", "QSLGIN = ", QSLGIN(11,ILOOP), "QSKSIN = KEROSENE = ",&
          QSKSIN(11,CURIYR), "QSPPIN = ", QSPPIN(11,CURIYR), &
       "QLGRF = ", QLGRF(11,CURIYR), &
              "FEEDLPGTOTAL = ", FEEDLPGTOTAL(ILOOP-START_YR_FEEDSTOCK+BASEYR)
    END DO
      END IF
	IF (FCRL .EQ. 1) THEN
    WRITE(IUNITBENCH,*) "***************************************"
    WRITE(IUNITBENCH,*) " "

    WRITE(IUNITBENCH,*) "  "
    WRITE(IUNITBENCH,*) "***************************************************************"
    WRITE(IUNITBENCH,360) " ***   CURIYR =  ", CURIYR, "  *****  CURCALYR =  ", CURCALYR, " *****"
    WRITE(IUNITBENCH,*) "***************************************************************"
    WRITE(IUNITBENCH,*) "  "
	END IF
360   FORMAT(A,I4,A,I6,A)
      DO ICR=1,4
        DO FUEL_INDEX=1,19
          BMAIN(FUEL_INDEX,ICR) = TQMAIN(FUEL_INDEX,ICR)
          END DO

 !       BMAIN(12,ICR) = BMAIN(12,ICR) + TQMAIN(20,ICR)  ! KEROSENE should be in its own variable
 !   BMAIN(20,ICR) = 0
        
        BMAIN(21,ICR) = TQMAIN(21,ICR) + TQMAIN(22,ICR)
		BMAIN(22,ICR) = BMAIN(21,ICR)
		IF ((BMAIN(3,ICR) + BMAIN(4,ICR)) .GT. 0) THEN
			FIRMSHR(ICR) = BMAIN(3,ICR) / (BMAIN(3,ICR) + BMAIN(4,ICR))
		ELSE
			FIRMSHR(ICR) = 0
		END IF
      END DO

    DO FUEL_INDEX=1,22
       BMAIN(FUEL_INDEX,5) = SUM(BMAIN(FUEL_INDEX,1:4))
    END DO
      FIRMSHR(5) = BMAIN(3,5) / (BMAIN(3,5) + BMAIN(4,5))

        WRITE(IUNITBENCH,'(a,5F8.4)') "FIRM SHARE = ", FIRMSHR(1:5)


! CREATE BRENEW

    DO ICR=1,4
        BRENEW(1,ICR) = TQRENW(1,ICR)
        BRENEW(2,ICR) = TQRENW(2,ICR) + TQRENW(3,ICR)
        BRENEW(3,ICR) = TQRENW(2,ICR) + TQRENW(3,ICR)
        BRENEW(4,ICR) = TQRENW(4,ICR)
        BRENEW(5,ICR) = TQRENW(5,ICR)
        BRENEW(6,ICR) = TQRENW(6,ICR)
        BRENEW(7,ICR) = TQRENW(7,ICR)
        BRENEW(8,ICR) = TQRENW(8,ICR)
    END DO
      DO IFUEL=1,8
        BRENEW(IFUEL,5) = SUM(BRENEW(IFUEL,1:4))
      END DO



!CASE 1:  CURIYR .LE. MSEDYR

    IF (CURIYR .LE. MSEDYR)  THEN


    ! WANTED TO CODE THIS WITHOUT SEDS9 BUT IT IS NEEDED LATER FOR EASY COMPUTATION OF BFCHECK.
	IF (FCRL .EQ. 1) THEN

         WRITE(IUNITBENCH,*) "SEDS INPUTS FOR ", CURCALYR
     WRITE(IUNITBENCH,*) "ELECTRICITY: ","QSELIN = ",QSELIN(11,CURIYR),"QELRF = ", &
             QELRF(11,CURIYR),"QELETH = ",QELETH(CURIYR,11),&
         "OGELSHALE = ",OGELSHALE(CURIYR)
         WRITE(IUNITBENCH,*) "NATURAL GAS: ","QSNGIN = ", QSNGIN(11,CURIYR), &
            "QNGRF = ", QNGRF(11,CURIYR), "QNGETH = ", QNGETH(CURIYR,11), &
             "QGTLRF = ", QGTLRF(11,CURIYR), "CGOGSQ = ",CGOGSQ(11,CURIYR,ING3), &
              "FEEDNGTOTAL = ", FEEDNGTOTAL(CURIYR-START_YR_FEEDSTOCK+BASEYR)
     WRITE(IUNITBENCH,*) "COAL ", "QSCLIN = ", QSCLIN(11,CURIYR), "QCLRF = ", &
            QCLRF(11,CURIYR), "QCLETH = ",QCLETH(CURIYR,11), &
             "CGOGSQ = ", CGOGSQ(11,CURIYR,ICL1)

     WRITE(IUNITBENCH,*) "MET COAL AND NET COKE", "QSMCIN = ", QSMCIN(11,CURIYR), &
                   "QSCIIN = ", QSCIIN(11,CURIYR)
     WRITE(IUNITBENCH,*) "RESID ", "QSRSIN = ", QSRSIN(11,CURIYR),&
          "QRLRF = ", QRLRF(11,CURIYR),&
          "CGOGSQ = ", CGOGSQ(11,CURIYR,IRL2)
       WRITE(IUNITBENCH,*) "DISTILLATE ", "QSDSIN = ", QSDSIN(11,CURIYR),&
         "QDSRF = ", QDSRF(11,CURIYR)
       WRITE(IUNITBENCH,*) "LPG ", "QSLGIN = ", QSLGIN(11,CURIYR), "QSKSIN = KEROSENE = ",&
          QSKSIN(11,CURIYR), "QLGRF = ", QLGRF(11,CURIYR), &
              "FEEDLPGTOTAL = ", FEEDLPGTOTAL(CURIYR-START_YR_FEEDSTOCK+BASEYR)
     WRITE(IUNITBENCH,*) "MOGAS ", "QSMGIN = ", QSMGIN(11,CURIYR)
         WRITE(IUNITBENCH,*) "STILL GAS ", "QSSGIN = ", QSSGIN(11,CURIYR), &
         "QSGRF = ", QSGRF(11,CURIYR)
      WRITE(IUNITBENCH,*) "PET COKE ", "QSPCIN = ", QSPCIN(11,CURIYR), "QPCRF = ", QPCRF(11,CURIYR), &
          "QCCRF = ", QCCRF(11,CURIYR)
          WRITE(IUNITBENCH,*) "ASPHALT ","QSASIN = ", QSASIN(11,CURIYR)
      WRITE(IUNITBENCH,*) "LUBES ", "BMAIN(18) SHARED OUT WITH QSOTIN FOR CURIYR", "BMAIN = ", &
          BMAIN(18,1:4), "QSOTIN = ", QSOTIN(11,CURIYR)
          WRITE(IUNITBENCH,*) "PETRO FEEDSTOCK ", "QSPFIN = ", QSPFIN(11,CURIYR)
      WRITE(IUNITBENCH,*) "OTHER PETRO FEEDSTOCK ", "QSOTIN = ", QSOTIN(11,CURIYR), &
          "QOTRF = ", QOTRF(11,CURIYR)

	END IF

        DO ICD=1,9
      ICR = CReg(ICD)

    ! INDUSTRIAL ELECTRICITY
      IF (ICD .EQ. 8) THEN
            SEDS9(ICD,1) = QSELIN(ICD,CURIYR) - QELRF(ICD,CURIYR) - &
           QELETH(CURIYR,ICD) - OGELSHALE(CURIYR)
      ELSE
        SEDS9(ICD,1) = QSELIN(ICD,CURIYR) - QELRF(ICD,CURIYR) - &
           QELETH(CURIYR,ICD)
      END IF
        ! NOT USED IN INDUSTRIAL MODULE
          SEDS9(ICD,2) = 0

    ! NG FEEDSTOCK ... NEEDS WORK
      SEDS9(ICD,5) = FEEDNGTOTAL(CURIYR-START_YR_FEEDSTOCK+BASEYR) * FEEDNGPERCENT(ICR) * &
            DIVSHR(QSNGIN(1,CURIYR),ICD,ICR)
!      SEDS9(ICD,5) = FEEDNGTOTAL(CURIYR-START_YR_FEEDSTOCK+BASEYR) * QSNGIN(ICD,CURIYR) / QSNGIN(11,CURIYR)

    ! NG H&P CORE
    !  QNGETH HAS DIFFERENT ARRAY DIMENSIONS ...
      SEDS9(ICD,3) = (QSNGIN(ICD,CURIYR) - QNGRF(ICD,CURIYR) - &
         QNGETH(CURIYR,ICD) - SEDS9(ICD,5) - QGTLRF(ICD,CURIYR) - &
       CGOGSQ(ICD,CURIYR,ING3)) * FIRMSHR(ICR)

      !NG H&P NONCORE ... NEED FEEDNG BY DIVISION CHECK WITH PETER
      SEDS9(ICD,4) = SEDS9(ICD,3) * (1. - FIRMSHR(ICR)) / FIRMSHR(ICR)
    
      !SEDS9(ICD,6) IS LEASE AND PLANT FUEL WHICH WE DO NOT BENCH ... ASK ABOUT THIS

      ! STEAM COAL
      SEDS9(ICD,7) = QSCLIN(ICD,CURIYR) - QCLRF(ICD,CURIYR) - &
                     QCLETH(CURIYR,ICD) - CGOGSQ(ICD,CURIYR,ICL1)

      !MET COAL
	  ! use met coal distribution to allocate net coke imports to divisions

!      DSHARE = QSMCIN(ICD,CURIYR) / QSMCIN(11,CURIYR)
      SEDS9(ICD,8) = QSMCIN(ICD,CURIYR)
      
      ! NET COKE IMPORTS
      SEDS9(ICD,9) = QSCIIN(11,CURIYR) * COKECOALIMPORTPERCENT(ICD)

      ! RESIDUAL FUEL TOTAL AND RESIDUAL FUEL LOW
      ! THERE WAS ADDITIONAL CODE IN WEXOG FOR THE SITUATION QRLRF > QSRSIN.  NOT INCLUDED HERE
      SEDS9(ICD,10) = QSRSIN(ICD,CURIYR) - QRLRF(ICD,CURIYR) - &
                      CGOGSQ(ICD,CURIYR,IRL2)
      ! DISTILLATE
      SEDS9(ICD,11) = QSDSIN(ICD,CURIYR) - QDSRF(ICD,CURIYR)

      ! TQMAIN(12) IS LPG HEAT AND POWER.  IT APPEARS THAT THE CURRENT WEXOG CREATED A CATEGORY
      ! BMAIN(8) AS A SUM OF TQMAIN(12) AND TQMAIN(13) WHICH WOULD BE LPG TOTAL. THIS IS NOT WHAT WE
      ! WANT TO DO.
      ! LPG ASSUME TOTAL. WE DON'T BENCHMARK LPG TOTAL

      ! LPG FEEDSTOCK
      SEDS9(ICD,13) = FEEDLPGTOTAL(CURIYR-START_YR_FEEDSTOCK+BASEYR) * FEEDLPGPERCENT(ICR) * DIVSHR(QSLGIN(1,CURIYR),ICD,ICR)
!      SEDS9(ICD,13) = FEEDLPGTOTAL(CURIYR-START_YR_FEEDSTOCK+BASEYR) * QSLGIN(ICD,CURIYR) / QSLGIN(11,CURIYR)

      ! LPG HEAT AND POWER
      SEDS9(ICD,12) = QSLGIN(ICD,CURIYR) - QLGRF(ICD,CURIYR) &
             - SEDS9(ICD,13)
      ! MOGAS
      SEDS9(ICD,14) = QSMGIN(ICD,CURIYR)

      ! STILL GAS ... SET TO ZERO BECAUSE INDUSTRIAL DOES NOT USE STILL GAS 4/13/2015 SUSAN
      SEDS9(ICD,15) = 0.0
        
      ! PET COKE
      SEDS9(ICD,16) = QSPCIN(ICD,CURIYR) - QPCRF(ICD,CURIYR) - QCCRF(ICD,CURIYR)
      
      ! ASPHALT AND ROAD OIL
      SEDS9(ICD,17) = QSASIN(ICD,CURIYR)
      
      ! LUBES
      SEDS9(ICD,18) = QSLUIN(ICD,CURIYR)
      
      ! PETRO FEEDSTOCK
      SEDS9(ICD,19) = QSPFIN(ICD,CURIYR)
      
      ! KEROSENE
      SEDS9(ICD,20) = QSKSIN(ICD,CURIYR)
      
      ! OTHER PETRO FEEDSTOCK
      SEDS9(ICD,21) = QSOTIN(ICD,CURIYR) - QOTRF(ICD,CURIYR)
      
      ! OTHER PETRO  ... THIS IS A DUPLICATE OF FUEL 21 BECAUSE THEY ARE COMBINED
      ! BMAIN 21 AND BMAIN 22 ARE DUPLICATES AS WELL
      SEDS9(ICD,22) = SEDS9(ICD,21)

      !********************* RENEWABLES **************************
      ! HYDRO
      RSEDS9(ICD,1) = QSHOIN(ICD,IY)

      ! BIOMASS WOOD
      RSEDS9(ICD,2) = QSBMIN(ICD,CURIYR) - QBMRF(ICD,CURIYR)

      ! BIOMASS PULPING LIQUOR
      RSEDS9(ICD,3) = QSBMIN(ICD,CURIYR) - QBMRF(ICD,CURIYR)


      ! GEOTHERMAL
      RSEDS9(ICD,4)= BRENEW(4,ICR) * DIVSHR(QSGEIN(1,CURIYR),ICD,ICR)

      ! SOLAR
      RSEDS9(ICD,5)= BRENEW(5,ICR) * DIVSHR(QSSTIN(1,CURIYR),ICD,ICR)

          ! PHOTOVOLTAIC
      RSEDS9(ICD,6)= BRENEW(6,ICR) * DIVSHR(QSPVIN(1,CURIYR),ICD,ICR)

      ! WIND
      RSEDS9(ICD,7)= BRENEW(7,ICR) * DIVSHR(QSWIIN(1,CURIYR),ICD,ICR)

      ! MUNICIPAL SOLID WASTE
      RSEDS9(ICD,8)= QSMSIN(ICD,CURIYR)

      !***********************************************************

    END DO  ! END CREATE SEDS9

    DO FUEL_INDEX=1,22
      DO ICD=1,9
        IF (FUEL_INDEX .NE. 9) THEN
          SEDS9(ICD,FUEL_INDEX) = MAX(0.0,SEDS9(ICD,FUEL_INDEX))
        END IF
      END DO
    END DO

	IF (FCRL .EQ. 1) THEN

    WRITE(IUNITBENCH,*) "SEDS ESTIMATES ... NATIONAL"
    DO FUEL_INDEX=1,22
       SEDS9(11,FUEL_INDEX) = SUM(SEDS9(1:9,FUEL_INDEX))
       WRITE(IUNITBENCH,300) FUELNAME(FUEL_INDEX),"SEDS = ", SEDS9(11,FUEL_INDEX)
300     FORMAT(A,A,F11.3)
    END DO
       WRITE(IUNITBENCH,*) "*************************************"
    DO FUEL_INDEX=1,8
       RSEDS9(11,FUEL_INDEX) = SUM(RSEDS9(1:9,FUEL_INDEX))
       WRITE(IUNITBENCH,300) RFUELNAME(FUEL_INDEX),"RENEWABLES SEDS = ",RSEDS9(11,FUEL_INDEX)
       END DO
      WRITE(IUNITBENCH,*) "*************************************"

	END IF

! NOW CREATE BF_SEDS.  FOR FIELD 6 BF_SEDS SHOULD JUST BE 1.
    DO ICR = 1,4

!**** SEDS BENCHMARK FOR MAIN FUELS  ***************************
      DO IFUEL=1,22


        SEDS4(ICR,IFUEL) = SUMCDIV(SEDS9(1,IFUEL), ICR)

        IF (ABS(BMAIN(IFUEL,ICR)) .GT. 0.0) THEN
         BF_SEDS(IFUEL,ICR) = SEDS4(ICR,IFUEL) / BMAIN(IFUEL,ICR)
        ELSE
         BF_SEDS(IFUEL,ICR) = 1.0  ! KPE change to 1.0
        END IF

      END DO
      BF_SEDS(6,ICR) = 1.0
! 	  BF_SEDS(9,ICR) = 1.0  ! NEW CODE FOR NET COKE IMPORTS BF WILL ALWAYS BE 1.0; NSK removed 2/25/20


!**** SEDS BENCHMARKS FOR THE RENEWABLES **********************
      DO IFUEL=1,8

        RSEDS4(ICR,IFUEL) = SUMCDIV(RSEDS9(1,IFUEL), ICR)
        IF (ABS(BRENEW(IFUEL,ICR)) .GT. 0.0) THEN
        RBF_SEDS(IFUEL,ICR) = RSEDS4(ICR,IFUEL) / BRENEW(IFUEL,ICR)
      ELSE
        RBF_SEDS(IFUEL,ICR) = 1.0  ! KPE change to 1 from 0
      END IF
      END DO
!**************************************************************
        END DO

	IF (FCRL .EQ. 1) THEN

         WRITE(IUNITBENCH,*) "SEDS BENCHMARK FACTORS"
         WRITE(IUNITBENCH,'(a,5F8.4)') "FIRM SHARE = ", FIRMSHR(1:5)

     DO ICR=1,4
        WRITE(IUNITBENCH,*) "REGION = ", ICR
        WRITE(IUNITBENCH,*) "FUELNAME            ", "     BMAIN     ", " SEDS4 ", "  BF_SEDS"
        DO IFUEL=1,22
           WRITE(IUNITBENCH,310) FUELNAME(IFUEL), BMAIN(IFUEL,ICR), SEDS4(ICR,IFUEL), BF_SEDS(IFUEL,ICR)
        END DO

     WRITE(IUNITBENCH,*) "**********************************************************"
     END DO

         WRITE(IUNITBENCH,*) "SEDS RENEWABLE BENCHMARK FACTORS"
     DO ICR=1,4
        WRITE(IUNITBENCH,*) "REGION = ", ICR
        WRITE(IUNITBENCH,*) "RFUELNAME           ", "    BRENEW    ", " RSEDS4 " , " RBF_SEDS"
        DO IFUEL=1,8
           WRITE(IUNITBENCH,310) RFUELNAME(IFUEL), BRENEW(IFUEL,ICR), RSEDS4(ICR,IFUEL), RBF_SEDS(IFUEL,ICR)
        END DO

     WRITE(IUNITBENCH,*) "**********************************************************"
     END DO

	END IF

310     FORMAT(A,2F11.2,F10.4)

    ! END ICR LOOP TO CREATE BF_SEDS

! BFCHECK IS A NATIONAL CHECK TO MAKE SURE THAT BF_SEDS * BMAIN EQUALS THE NATIONAL SEDS ESTIMATE
! IN MOST SITUATIONS IT IS 1, BUT IF FOR SOME REASON BMAIN IS ZERO FOR SOME REGION BUT SEDS IS
! POSITIVE THIS ADDITIONAL CHECK WILL ASSURE THAT THE NATIONAL BMAIN = NATIONAL SEDS
   IF (FCRL .EQ. 1) WRITE(IUNITBENCH,*) "BF CHECK "
    DO IFUEL=1,22
      CHECK(IFUEL) = 0
      DO ICR=1,4
        CHECK(IFUEL) = CHECK(IFUEL) + BMAIN(IFUEL,ICR) * BF_SEDS(IFUEL,ICR)
      END DO
      IF (ABS(CHECK(IFUEL)) .GT. 0) THEN
          BFCHECK(IFUEL) = SUM(SEDS9(1:9,IFUEL)) / CHECK(IFUEL)
      ELSE
          BFCHECK(IFUEL) = 0.0
      END IF
    IF (FCRL .EQ. 1) WRITE(IUNITBENCH,*) FUELNAME(IFUEL),"BFCHECK = ",BFCHECK(IFUEL)

!*******************************************************************************
! THIS IS ADDED IN BECAUSE SEDS YEARS DO NOT GET A STEO BENCHMARK.
! WILL BE USED LATER WHEN COMPUTING THE COMPOSITE BF
      BF_STEO(IFUEL) = 0.0
!*******************************************************************************

      DO ICR=1,4
        BF_SEDS(IFUEL,ICR) = BF_SEDS(IFUEL,ICR) * BFCHECK(IFUEL)
      END DO
    END DO  ! END IFUEL LOOP TO DO CHECK ON MAIN FUELS
    IF (FCRL .EQ. 1)  WRITE(IUNITBENCH,*) "********************************************************"

! RENEWABLE NATIONAL CHECK
    DO IFUEL=1,8
      RCHECK(IFUEL) = 0.0
      DO ICR=1,4
        RCHECK(IFUEL) = RCHECK(IFUEL) + BRENEW(IFUEL,ICR) * RBF_SEDS(IFUEL,ICR)
      END DO
      IF (ABS(RCHECK(IFUEL)) .GT. 0) THEN
        RBFCHECK(IFUEL) = SUM(RSEDS9(1:9,IFUEL)) / RCHECK(IFUEL)
      ELSE
        RBFCHECK(IFUEL) = 0.0
      END IF
!*******************************************************************************
! THIS IS ADDED IN BECAUSE SEDS YEARS DO NOT GET A STEO BENCHMARK.
! WILL BE USED LATER WHEN COMPUTING THE COMPOSITE BF
      RBF_STEO(IFUEL) = 0.0
!*******************************************************************************
    IF (FCRL .EQ. 1) WRITE(IUNITBENCH,*) RFUELNAME(IFUEL),"RENEWABLE BFCHECK = ",RBFCHECK(IFUEL)

      DO ICR=1,4
        RBF_SEDS(IFUEL,ICR) = RBF_SEDS(IFUEL,ICR) * RBFCHECK(IFUEL)
      END DO
    END DO  ! END IFUEL LOOP TO CREATE CHECK ON RENEWABLE FUELS BF

    IF (FCRL .EQ. 1) WRITE(IUNITBENCH,*) "********************************************************"


   ! END IF  ! END OF CASE 1:

!**************  END CASE 1  **************************************************

! CREATE STEO(20) AND STEOWASTE FOR THE STEO YEARS.  THIS IS READ IN FROM A FILE AND SHOULD BE DONE ONCE
! THUS THE USE OF CURITR

! IS IT RIGHT TO USE CURITR?  THE Q VARIABLES COULD CHANGE BETWEEN ITERATIONS RIGHT?????

! CASE 2.

    ELSE IF (( CURIYR .GT. MSEDYR) .AND. &
      (CURCALYR .LE. (STEOLASTYR - INDBMOVR2)) )  THEN

! CASE 2: CURIYR > MSEDYR BUT CURCALYR <= (STEOLASTYR - INDBMOVR2)
! OLD CODE USED IYEAR = CURCALYR THEN USED IYEAR IN SUBSCRIPT FOR ARRAY
! NOT SURE WHY THIS WOULD BE NECESSARY

!        IF (CURITR .EQ. 1 .AND. CURCALYR .GT. SEDSLASTYR &
!            .AND. CURCALYR .LE. (STEOLASTYR - INDBMOVR2)) THEN

        ! ELECTRICITY WHY IS OGELSHALE SUBTRACTED FROM STEO BUT NOT SEDS ????????????????
        ! IT IS ... BUT ONLY IN ONE DISTRICT 1/15/2016
		STEO(1) = MAX(0.0,STEOQ(CURCALYR,18) - QELRF(11,CURIYR) - &
           QELETH(CURIYR,11) - OGELSHALE(CURIYR))


        ! NOT USED
        STEO(2) = 0

        ! NG H&P FIRM  ... CODE IN WEXOG NOW IS CONDITIONAL FOR SOME STRANGE REASON ... ASK PETER FOR CLARIFICATION
        STEO(3) = MAX(0.0,(STEOQ(CURCALYR,13) - QNGRF(11,CURIYR) - &
               QNGETH(CURIYR,11) - QGTLRF(11,CURIYR) - &
           FEEDNGTOTAL(CURIYR-START_YR_FEEDSTOCK+BASEYR) - SUM(CGOGSQ(1:9,CURIYR,ING3)) ) * FIRMSHR(5))

        ! NG H&P NONFIRM
        STEO(4) = STEO(3) * ((1. - FIRMSHR(5)) / FIRMSHR(5))

        ! NG FEEDSTOCK ... THIS IS READ INTO PROGRAM AND WILL CREATE A BENCHFACTOR OF 1
        STEO(5) = FEEDNGTOTAL(CURIYR-START_YR_FEEDSTOCK+BASEYR)

        ! LEASE AND PLANT FUEL
!        STEO(6) = STEOQ(CURCALYR,14)

        ! STEAM COAL ... SAME COMMENT ABOUT OGEL ... IT SUBTRACTED FROM STEO BUT NOT SEDS ?????
      ! I THINK PETER SAID OGELSHALE IS ZERO OR INSIGNIFICANT FOR SED YEARS
        STEO(7) = MAX(0.0,STEOQ(CURCALYR,15) - QCLRF(11,CURIYR) - &
            QCLETH(CURIYR,11) - SUM(CGOGSQ(1:9,CURIYR,ICL1)))


        ! MET COAL
        STEO(8) = STEOQ(CURCALYR,16)

        ! NET COAL COKE IMPORTS
        STEO(9) = STEOQ(CURCALYR,17)

        ! RESIDUAL FUEL
        STEO(10) = MAX(0.0,STEOQ(CURCALYR,2) - QRLRF(11,CURIYR) - &
                 SUM(CGOGSQ(1:9,CURIYR,IRL2)))

        ! DISTILLATE
        STEO(11) = MAX(0.0,STEOQ(CURCALYR,1)  - QDSRF(11,CURIYR))
        
        ! LPG HEAT AND POWER
        STEO(12) = MAX(0.0,STEOQ(CURCALYR,3) - &
         QLGRF(11,CURIYR) - FEEDLPGTOTAL(CURIYR-START_YR_FEEDSTOCK+BASEYR))

        ! LPG FEEDSTOCK
         STEO(13) = FEEDLPGTOTAL(CURIYR-START_YR_FEEDSTOCK+BASEYR)

        ! MOGAS
        STEO(14) = STEOQ(CURCALYR,4)

        ! STILL GAS CURRENT CODE HAS A CHECK FOR REFINERY > STEO ... ASK PETER IF NEEDED
        STEO(15) = 0.0  ! SET TO ZERO BECAUSE INDUSTRIAL DOES NOT USE STILL GAS 4/13/2015 SUSAN
!        STEO(15) = STEOQ(CURCALYR,10) - QSGRF(11,CURIYR)

        ! PET COKE
        STEO(16) = MAX(0.0,STEOQ(CURCALYR,9) - QPCRF(11,CURIYR) - QCCRF(11,CURIYR))

        ! ASPHALT
        STEO(17) = STEOQ(CURCALYR,6)

        ! LUBES AND WAXES
        STEO(18) = STEOQ(CURCALYR,8)

        ! PETRO CHEM FEEDSTOCK
        STEO(19) = STEOQ(CURCALYR,5)

        ! KEROSENE
        STEO(20) = STEOQ(CURCALYR,7)

        
        ! OTHER PETRO FEEDSTOCK
        STEO(21) = MAX(0.0, STEOQ(CURCALYR,12) - QOTRF(11,CURIYR))
        

        ! OTHER PETRO ... DUPLICATE WITH FUEL 21
        STEO(22) = STEO(21)

      !********************* RENEWABLES **************************
      ! HYDRO
      RSTEO(1) = STEOQ(CURCALYR,19)

      ! BIOMASS WOOD AND PULPING LIQUOR
      RSTEO(2) = STEOQ(CURCALYR,20) - QBMRF(11,CURIYR)

      ! BIOMASS PULPING LIQUOR AND WOOD
      RSTEO(3) = STEOQ(CURCALYR,20) - QBMRF(11,CURIYR)
		! ADDED -QBMRF(11,CURIYR) (SUBTRACTION OF REFINERY BIOMASS CONSUMPTION 8/26/16 BY MS

      ! GEOTHERMAL
      RSTEO(4)= BRENEW(4,5)

      ! SOLAR
      RSTEO(5)= BRENEW(5,5)

      ! PHOTOVOLTAIC
      RSTEO(6)= BRENEW(6,5)

      ! WIND
      RSTEO(7)= BRENEW(7,5)

      ! MUNICIPAL SOLID WASTE
      RSTEO(8)= STEOQ(CURCALYR,21)
      !***********************************************************

! MAIN FUELS BENCHMARK FACTOR CALCULATION
    IF (FCRL .EQ. 1) WRITE(IUNITBENCH,*) " *************** STEO *************"

         DO IFUEL=1,22
           BMAIN_SEDS_ADJUSTED(IFUEL) = 0.0  ! KPE start from 0 

         DO ICR=1,4
              BMAIN_SEDS_ADJUSTED(IFUEL) = BMAIN_SEDS_ADJUSTED(IFUEL) + &
             BMAIN(IFUEL,ICR) * BF_SEDS(IFUEL,ICR)
          END DO

! denominator could be negative
           IF (ABS(BMAIN_SEDS_ADJUSTED(IFUEL)) .GT. 0.0) THEN
            BF_STEO(IFUEL) = STEO(IFUEL) / BMAIN_SEDS_ADJUSTED(IFUEL)
           ELSE
            BF_STEO(IFUEL) = 1.0  ! KPE change from 0 to  1
           END IF

        END DO
!		BF_STEO(9) = 1.0

! RENEWABLE FUELS BENCHMARK FACTOR CALCULATIONS
      DO IFUEL=1,8
        BRENEW_SEDS_ADJUSTED(IFUEL) = 0.0
          DO ICR=1,4
            BRENEW_SEDS_ADJUSTED(IFUEL) = BRENEW_SEDS_ADJUSTED(IFUEL) + &
             BRENEW(IFUEL,ICR) * RBF_SEDS(IFUEL,ICR)
          END DO

              IF (ABS(BRENEW_SEDS_ADJUSTED(IFUEL)) .GT. 0.0) THEN
          RBF_STEO(IFUEL) = RSTEO(IFUEL) / BRENEW_SEDS_ADJUSTED(IFUEL)
          ELSE
          RBF_STEO(IFUEL) = 1.0  ! KPE change to 1 from 0
          END IF
          END DO

! STEO OUTPUT FOR VERIFICATION

         IF (FCRL .EQ. 1) WRITE(IUNITBENCH,*) "STEO BENCHMARK FACTORS"
         IF (FCRL .EQ. 1) WRITE(IUNITBENCH,'(a,5F8.4)') "FIRM SHARE = ", FIRMSHR(1:5)

        IF (FCRL .EQ. 1) WRITE(IUNITBENCH,*) "FUELNAME           ", "  BMAIN   ", "SEDS_ADJ","   STEO ", " BF_STEO ", "ADJ"
        DO IFUEL=1,22
         ADJUSTED = BMAIN_SEDS_ADJUSTED(IFUEL) * BF_STEO(IFUEL)
        IF (FCRL .EQ. 1) WRITE(IUNITBENCH,320) FUELNAME(IFUEL), BMAIN(IFUEL,5), BMAIN_SEDS_ADJUSTED(IFUEL), STEO(IFUEL), BF_STEO(IFUEL), ADJUSTED
        END DO

        IF (FCRL .EQ. 1) WRITE(IUNITBENCH,*) "**********************************************************"


        IF (FCRL .EQ. 1) WRITE(IUNITBENCH,*) "SEDS RENEWABLE BENCHMARK FACTORS"
        IF (FCRL .EQ. 1) WRITE(IUNITBENCH,*) "FUELNAME          ", "  BRENEW   ", "SEDS_ADJ "," RSTEO  ", " RBF_STEO ", "RADJ"
        DO IFUEL=1,8
         RADJUSTED = BRENEW_SEDS_ADJUSTED(IFUEL) * RBF_STEO(IFUEL)
        IF (FCRL .EQ. 1) WRITE(IUNITBENCH,320) RFUELNAME(IFUEL), BRENEW(IFUEL,5), BRENEW_SEDS_ADJUSTED(IFUEL), RSTEO(IFUEL), RBF_STEO(IFUEL), RADJUSTED
        END DO

        IF (FCRL .EQ. 1) WRITE(IUNITBENCH,*) "**********************************************************"

320      FORMAT(A,3F9.2,F7.4,F9.2)

!  END OF CALCULATION OF BF_STEO. FOR YEARS FOLLOWING THE VALUES STORED IN BF_STEO APPLY FOR ALL SUBSEQUENT YEARS,
  END IF ! END OF IF LOOPS ... NOW COMPUTE BF AND RBF FOR ALL YEARS

!******************************************************************************
! NOW FOR ALL YEARS WE NEED TO COMPUTE THE COMPOSITE BENCHMARK FACTOR BF
! NOT THAT FOR SEDS YEARS BF WILL BE BF_SEDS.  FOR STEO YEARS BF WILL BE
! BF_STEO * BF_SEDS.  AND FOR YEARS AFTER STEOLASTYR BF WILL BE A COMPOSITE OF
! BF_SEDS AND BF_SEDS * BF_STEO.  EVENTUALLY THIS COMPOSITE WILL FADE OUT AND
! WE WILL USE BF_SEDS AS THE COMPOSITE FACTOR UNTIL 2050.
! ALSO NOTE THAT THE FINAL BF_SEDS COMPUTATION IS CHANGED PER CONSULTATION WITH
! PETER.  PREVIOUSLY BF_SEDS WAS AN AVERAGE.  WE SWITCHED TO USING THE LAST SEDS
! YEARS AS THE FINAL BF_SEDS FACTOR.  THE REASON IS THE EARLY YEARS HAVE TOO MUCH
! NOISE IN THE INDUSTRIAL MODEL ESTIMATES.  THE FINAL SEDS YEAR SHOULD HAVE THE
! LEAST AMOUNT OF MODEL NOISE.
!*******************************************************************************
!
      if (curitr.eq.1 .and. curiyr+1989.gt.sedslastyr+1) then
        write (IFEEDOUT,*) 'curiyr = ',curiyr
        write (IFEEDOUT,*) 'mc_gslgisnhwyr = ',mc_gslgisnhwyr(curiyr)
        write (IFEEDOUT,*) 'asphalt check  '
      end if
      if (curiyr+1989.eq.sedslastyr+5) then    ! set up initial seed for projecting asphalt target
	     asphalttarget(5) = qasin(11,IY)       ! and set up regional breakout percentages
		 asphaltpercent(1) = (qasin(1,IY) + qasin(2,IY)) / qasin(11,IY)
 		 asphaltpercent(2) = (qasin(3,IY) + qasin(4,IY)) / qasin(11,IY)
		 asphaltpercent(3) = (qasin(5,IY) + qasin(6,IY) + qasin(7,IY)) / qasin(11,IY)
		 asphaltpercent(4) = (qasin(8,IY) + qasin(9,IY)) / qasin(11,IY)
      end if
      if (curitr.eq.1 .and. curiyr+1989.gt.sedslastyr+5) then  ! KPE change .ge. to .gt. so not to nullify previous if block
	     asphalttarget(5) = qasin(11,iy-1) * mc_gslgisnhwyr(curiyr) / mc_gslgisnhwyr(curiyr-1)
      end if
	  ASPHALTTARGET(1:4) = ASPHALTTARGET(5) * ASPHALTPERCENT(1:4) ! get regional asphalt consumption
      
! Model flexible cracking capacity; only exists in division 7/region 3 NSKchem
    IF (curcalyr.eq.sedslastyr+FEEDYEARS) THEN
        ! Baseline consumption  and capacity in the year before the feedstock model starts running
        Naphtha_flex_consumption(3,curiyr)=MAX(0.0, feednaphtotal(CURIYR-16)-Naphtha_nonflex_consumption)  ! Naphtha consumption from flexible cracking capacity, in tBtu
        Slow_flex_capacity(3,curiyr) = 5510000.     ! Ethane cracking capacity (in tonnes ethylene produced) that could switch to flexible cracking capacity given sustained favorable naphtha economics
        Quick_flex_capacity(3,curiyr) = 2610000.    ! Cracking capacity (in tonnes ethylene produced) that can switch quickly between cracking naphtha or cracking ethane, based on economic favoribility
        
        DO IMAC=1,5
            ! Populate ethylene regression x variables for years 2015–19 (macro shipments of resins, synthetic rubber, and fibers—index 18) 
            !Ethylene_x(IMAC)=MC_REVIND(11,16,25+IMAC) + MC_REVIND(11,18,25+IMAC) ! Macro shipments, in billion 2012$ as of AEO2021
            Ethylene_x(IMAC)=MC_REVIND(11,18,25+IMAC) ! Macro shipments, in billion 2012$ as of AEO2021
            ! Calculate ethylene regression slope and intercept

        ENDDO
            !Ethylene_slope=(28.0*dot_product(Ethylene_x,Ethylene_y)-SUM(Ethylene_x(1:28))*SUM(Ethylene_y(1:28)))/&     ! million tonnes ethylene/billion dollars of shipments
            !                (28.0*SUM(Ethylene_x(1:28)**2)-SUM(Ethylene_x(1:28))**2)
            !Ethylene_intercept=(SUM(Ethylene_y(1:28))-Ethylene_slope*SUM(Ethylene_x(1:28)))/28.0                       ! million tonnes ethylene
            
            Ethylene_slope=(5.0*dot_product(Ethylene_x,Ethylene_y)-SUM(Ethylene_x(1:5))*SUM(Ethylene_y(1:5)))/&     ! million tonnes ethylene/billion dollars of shipments
                            (5.0*SUM(Ethylene_x(1:5)**2)-SUM(Ethylene_x(1:5))**2)
            Ethylene_intercept=(SUM(Ethylene_y(1:5))-Ethylene_slope*SUM(Ethylene_x(1:5)))/5.0                       ! million tonnes ethylene
        
    ENDIF
      
    IF (curcalyr.gt.sedslastyr+FEEDYEARS) THEN
        Ethane_price_mass(3,curiyr)=PETIN(7,curiyr)*Ethane_heat*1000000.0               ! Ethane price in 1987$/tonne  
        Naphtha_price_mass(3,curiyr)=PPFIN(7,curiyr)*Naphtha_heat*1000000.0             ! Naphtha price in 1987$/tonne
        
        Cost_ethylene_from_ethane(3,curiyr)=Ethane_price_mass(3,curiyr)/X_ethane(1)     ! Cost of ethylene cracked from ethane, in 1987$/tonne ethylene produced
        Cost_ethylene_from_naphtha(3,curiyr)=Naphtha_price_mass(3,curiyr)/X_naphtha(1)  ! Cost of ethylene cracked from naphtha, in 1987$/tonne ethylene produced
        
        ! Cracking product prices (1987$/tonne product)
        DO CHEM_INDEX=2,11                  ! Comparison is ultimately being done on a per-tonne-ethylene basis, so ethylene price (CHEM_INDEX=1) doesn't matter
            
            IF (CHEM_INDEX .eq. 2) THEN         ! Hydrogen
                Chem_product_price(CHEM_INDEX, curiyr)=PNGIN(7,curiyr)*H2_heat  ! For now treat all hydrogen as still gas, burned to offset the purchase of natural
                                                                                ! gas; when and if NEMS starts calculating a hydrogen price, we will use that here 
            ELSE IF (CHEM_INDEX .eq. 3) THEN    ! Methane
                Chem_product_price(CHEM_INDEX, curiyr)=PNGIN(7,curiyr)*Methane_heat ! Assume methane burned to offset purchases of natural gas
            ELSE                                ! Everything else, though indices 10 and 11 are 0, and redefined below
                Chem_product_price(CHEM_INDEX, curiyr)=Chem_price_slope(CHEM_INDEX)*WTI_PRICE(curiyr)+Chem_price_intercept(CHEM_INDEX)  
            ENDIF
            
            
            IF (CHEM_INDEX .eq. 10) THEN   ! Fuel oil
                Chem_product_price(CHEM_INDEX, curiyr)=PDSAS(7,curiyr)*ULSD_heat        ! Use distillate price, ULSD heat content
            ELSE IF (CHEM_INDEX .eq. 11) THEN   ! Other aromatics
                Chem_product_price(CHEM_INDEX, curiyr)=(Chem_product_price(7, curiyr)+Chem_product_price(8, curiyr)+Chem_product_price(9, curiyr))/3.0
                ! Average of benzene, xylene, and toluene
            ENDIF
            
            ! Subtract value of side products from costs of feedstock (done on a per-tonne-of-ethylene-produced basis)
            Cost_ethylene_from_ethane(3,curiyr)=Cost_ethylene_from_ethane(3,curiyr)-Chem_product_price(CHEM_INDEX, curiyr)*X_ethane(CHEM_INDEX)/X_ethane(1)
            Cost_ethylene_from_naphtha(3,curiyr)=Cost_ethylene_from_naphtha(3,curiyr)-Chem_product_price(CHEM_INDEX, curiyr)*X_naphtha(CHEM_INDEX)/X_naphtha(1)

        ENDDO
     
        ! Initialize capacities and naphtha flex consumption for a given year
        Slow_flex_capacity(3,curiyr)=Slow_flex_capacity(3,curiyr-1)
        Quick_flex_capacity(3,curiyr)=Quick_flex_capacity(3,curiyr-1)
        Naphtha_flex_consumption(3,curiyr)=Naphtha_flex_consumption(3,curiyr-1)
    
        If ((Cost_ethylene_from_ethane(3,curiyr-5) .gt. Cost_ethylene_from_naphtha(3,curiyr-5)) .and. &
         (Cost_ethylene_from_ethane(3,curiyr-4) .gt. Cost_ethylene_from_naphtha(3,curiyr-4)) .and. &
         (Cost_ethylene_from_ethane(3,curiyr-3) .gt. Cost_ethylene_from_naphtha(3,curiyr-3)) .and. (Slow_flex_capacity(3,curiyr-1) .gt. 0.0)) then
            Slow_flex_capacity(3,curiyr)=MAX(0.0, Slow_flex_capacity(3,curiyr-1)-Slow_flex_capacity(3,sedslastyr+FEEDYEARS-1989)*0.2) 
	        Quick_flex_capacity(3,curiyr)=Quick_flex_capacity(3,curiyr-1)+(Slow_flex_capacity(3,curiyr-1)-Slow_flex_capacity(3,curiyr))
        EndIf

        If (Cost_ethylene_from_ethane(3,curiyr) .gt. Cost_ethylene_from_naphtha(3,curiyr)) then
	        Naphtha_flex_consumption(3,curiyr)=MIN(Quick_flex_capacity(3,curiyr)*Naphtha_heat/X_naphtha(1), &
             Naphtha_flex_consumption(3,curiyr-1)+0.5*Quick_flex_capacity(3,curiyr)*Naphtha_heat/X_naphtha(1))
        EndIf

        If (Cost_ethylene_from_ethane(3,curiyr) .lt. Cost_ethylene_from_naphtha(3,curiyr)) then
            Naphtha_flex_consumption(3,curiyr)=MAX(0.0, Naphtha_flex_consumption(3,curiyr-1) &
             -0.5*Quick_flex_capacity(3,curiyr)*Naphtha_heat/X_naphtha(1))
        EndIf
        
        Ethylene_demand(curiyr)=1000000.0*(Ethylene_slope*(MC_REVIND(11,18,curiyr)) + Ethylene_intercept)   ! Tonnes ethylene (U.S. total demand)
        Ethylene_benchmark=(QETINPF(11,MSEDYR+FEEDYEARS)*X_ethane(1)/Ethane_heat+QPFIN(11,MSEDYR+FEEDYEARS)*X_naphtha(1)/Naphtha_heat)/&
            (1000000.0*(Ethylene_slope*(MC_REVIND(11,18,MSEDYR+FEEDYEARS)) + Ethylene_intercept)) ! Benchmark ethylene regression to laste year of read-in data
        Ethylene_demand(curiyr)=Ethylene_demand(curiyr)*Ethylene_benchmark
        Base_ethane_demand(curiyr)=(Ethylene_demand(curiyr)-Naphtha_nonflex_consumption*X_naphtha(1)/Naphtha_heat)*Ethane_heat/X_ethane(1)  ! tBtu ethane demand if all flexible capacity uses ethane
        
        
        Do ICD=1,9           
            ! tBtu ethane demand by census region; use census division ethane split from last feed year (2022 for AEO2021)
            ! Assume census divisions other than 7 are not building new facilities, and remain at constant production levels (use last feed year read-in data)
            QETINPF(ICD,curiyr)=QETINPF(ICD,MSEDYR+FEEDYEARS)
            IF (ICD .eq. 7) THEN    ! Assuming flex capacity and regular capacity growth is only ever in census division 7
                QETINPF(ICD,curiyr)=Base_ethane_demand(curiyr)-(Naphtha_flex_consumption(3,curiyr)*X_naphtha(1)/Naphtha_heat)*Ethane_heat/X_ethane(1) &
                    -(QETINPF(11,MSEDYR+FEEDYEARS)-QETINPF(7,MSEDYR+FEEDYEARS))
            ENDIF
        EndDo
        
        QETINPF(11,curiyr)=SUM(QETINPF(1:9,curiyr))       
    ENDIF

    DO IFUEL=1,22
       DO ICR=1,4

       BF(CURIYR,IFUEL,ICR) = (1 - FADE) * BF_SEDS(IFUEL,ICR) + &
          FADE * BF_STEO(IFUEL) * BF_SEDS(IFUEL,ICR)
          

        ! Custom benchmark factor targets for HGL feedstock, petchem feedstock, and natural gas feedstock
                IF (CURCALYR .GT. (SEDSLASTYR + FEEDYEARS)) THEN  
                    PCFFEEDTARGET(ICR,curiyr)=0.0   ! tBtu; assume naphtha cracking only occurs in census region 3/division 7
                    PCFFEEDTARGET(3,curiyr) = Naphtha_flex_consumption(3,curiyr) + Naphtha_nonflex_consumption 
                    PCFFEEDTARGET(5,curiyr) = SUM(PCFFEEDTARGET(1:4,curiyr))
                    NGFEEDTARGET(5) = BMAIN(5,5) * NGFEEDCALIBFACT
                    NGFEEDTARGET(1:4) = NGFEEDTARGET(5) * FEEDNGPERCENT(1:4)
                    ! Naphtha from the "old" method of calculation (i.e., just taking what the end-use model puts out and benchmarking it to SEDS/STEO) minus naphtha from the feedstock switcing method
                    ! This is the amount of feedstock demand from the end-use model that we are neglecting by flattening the naphtha consumption, so it needs to be added to HGL feedstock total
                    ! Yes, it shouldn't really be a one-to-one Btu trade off (since ethane cracking is more efficient), but it is an ok approximation for now; can be negative (NSK 7/2021)
                    IF (IFUEL .EQ. 13) THEN ! Index 13 = HGL feedstock
                        BF(CURIYR,19,3)=(1 - FADE) * BF_SEDS(19,3) + FADE * BF_STEO(19) * BF_SEDS(19,3) ! Define initial naphtha benchmark factor for division 3 early, to use to calculate HGL feedstock benchmark factor
                        
                        Naphtha_to_HGL(3,curiyr)=(BMAIN(19,3)*BF(CURIYR,19,3)-(Naphtha_flex_consumption(3,curiyr) + Naphtha_nonflex_consumption))*(X_naphtha(1)/Naphtha_heat)*(Ethane_heat/X_ethane(1))
                        Naphtha_to_HGL(5,curiyr)=Naphtha_to_HGL(3,curiyr)
                        
                        LPGFEEDTARGET(5) = BMAIN(13,5) * LPGFEEDCALIBFACT                                                       ! Baseline adjustment based on last read in year
                        LPGFEEDTARGET(1:4) = MAX(LPGFEEDTARGET(5) * FEEDLPGPERCENT(1:4) + Naphtha_to_HGL(1:4,curiyr), 0.0)      ! Add excess (or deficit) end-use model naphtha demand; should only be in region 3
                        LPGFEEDTARGET(5) = SUM(LPGFEEDTARGET(1:4))                                                              ! Re-sum regional values
                    END IF
                ELSE
                    NGFEEDTARGET(5) = FEEDNGTOTAL(CURIYR-START_YR_FEEDSTOCK+BASEYR)
                    NGFEEDTARGET(1:4) = NGFEEDTARGET(5) * FEEDNGPERCENT(1:4)
	                LPGFEEDTARGET(5) = FEEDLPGTOTAL(CURIYR-START_YR_FEEDSTOCK+BASEYR)
                    LPGFEEDTARGET(1:4) = LPGFEEDTARGET(5) * FEEDLPGPERCENT(1:4)
                    ! PCFFEEDTARGET only is used in years after SEDSLASTYR + FEEDYEARS, so no need for "alternate" value
                END IF

                
                
        write (IFEEDOUT,*)
        write (IFEEDOUT,'(A,I4)') 'Feedstock targets for ',curcalyr
        write (IFEEDOUT,'(A,5F10.3)') 'NG      ',NGFEEDTARGET(1:5)
        write (IFEEDOUT,'(A,5F10.3)') 'LPG     ',LPGFEEDTARGET(1:5)
        write (IFEEDOUT,'(A,5F10.3)') 'PCF     ',PCFFEEDTARGET(1:5, curiyr)
        write (IFEEDOUT,'(A,5F10.3)') 'ASPHALT ',ASPHALTTARGET(1:5)
        write (IFEEDOUT,*)
        
! breakout feedstocks regionally (based on historical consumption patterns) from national target

! THESE ARE LIMITS PUT ON THE FINAL BF ... SOMEWHAT CONSISTENT WITH THE OLD WEXOG
! OPEN TO DISCUSSION
          
    IF (CURCALYR .GT. (STEOLASTYR - INDBMOVR2)) THEN
        IF ((IFUEL .EQ. 9) .OR. (IFUEL .EQ. 12)) THEN
            BF(CURIYR,IFUEL,ICR) = 1.0

        ELSE IF (IFUEL .EQ. 5) THEN ! adjust natural gas feedstock benchmark factor
            IF (BMAIN(5,ICR) .GT. 0.0) THEN
                BF(CURIYR,5,ICR) = NGFEEDTARGET(ICR) / BMAIN(5,ICR)
            ELSE
                BF(CURIYR,5,ICR) = 0.0
            END IF
            
        ELSE IF (IFUEL .EQ. 13) THEN ! adjust LPG benchmark factor
            IF (BMAIN(13,ICR) .GT. 0.0) THEN
                BF(CURIYR,13,ICR) = LPGFEEDTARGET(ICR) / BMAIN(13,ICR)
            ELSE
                BF(CURIYR,13,ICR) = 0.0
            END IF
            
        ELSE IF (IFUEL .EQ. 19) THEN
            IF (curcalyr.eq.sedslastyr+FEEDYEARS) THEN ! Use naphtha read-in value for sedslastyr+FEEDYEARS
                IF (BMAIN(19,ICR) .GT. 0.0) THEN
                write (IFEEDOUT,*) 'curcalyr region PCFFEEDTARGET = ',curcalyr,ICR,feednaphtotal(CURIYR-16)*NaphthaDivFrac(ICR)
                    BF(CURIYR,19,ICR) = feednaphtotal(CURIYR-16)*NaphthaDivFrac(ICR) / BMAIN(19,ICR)
                ELSE
                    BF(CURIYR,19,ICR) = 0.0
                END IF
            ELSE IF (curcalyr.gt.sedslastyr+FEEDYEARS) THEN
                IF (BMAIN(19,ICR) .GT. 0.0) THEN ! only adjust PCF target after hardcoded LPG feedstocks are in
                    write (IFEEDOUT,*) 'curcalyr region PCFFEEDTARGET = ',curcalyr,ICR,PCFFEEDTARGET(ICR, curiyr)
                    BF(CURIYR,19,ICR) = PCFFEEDTARGET(ICR, curiyr) / BMAIN(19,ICR)
                ELSE
                    BF(CURIYR,19,ICR) = 0.0
                END IF 
            END IF

        ELSE IF (IFUEL .EQ. 17 .and. curcalyr.ge.sedslastyr+5) THEN ! adjust asphalt benchmark factor
            IF (BMAIN(17,ICR) .GT. 0.0) THEN ! only adjust asphalt target if regional value non-zero
			  write (IFEEDOUT,*) 'curcalyr region ASPHALTTARGET = ',curcalyr,ICR,ASPHALTTARGET(ICR)
			  BF(CURIYR,17,ICR) = ASPHALTTARGET(ICR) / BMAIN(17,ICR)
            ELSE
			  BF(CURIYR,17,ICR) = 0.0
			END IF
  !      ELSE IF (IFUEL .EQ. 19) THEN
  !        BF(CURIYR,IFUEL,ICR) = MAX(1.05,BF(CURIYR,IFUEL,ICR))
!        ELSE IF ((IFUEL .EQ. 21) .OR. (IFUEL .EQ. 22)) THEN
!          BF(CURIYR,IFUEL,ICR) = MAX(1.25,BF(CURIYR,IFUEL,ICR))
        END IF
    END IF

       !IF ((INDBMOVR2 .eq. 0) .AND. (CURCALYR .GT. 2020) .AND. ((IFUEL .EQ. 8) .OR. (IFUEL .EQ. 9))) THEN
       ! BF(CURIYR,IFUEL,ICR) = HISTBF(CURIYR,IFUEL,ICR)     ! Make met coal and coke coal imports use side case benchmarks. Remove for AEO2022. NSK 11/19/20
       !END IF

       
	   ! IF INDBMOVR2=2 THEN THIS IS A SIDE CASE ... OVERWRITE BENCHMARK FACTOR WITH HISTORICAL BF
		! KPE --- why are we doing this --- allows hinky readings
 !      IF ((INDBMOVR2 .NE. 0) .AND. (CURCALYR .GT. (SEDSLASTYR + 2))) THEN
 !        BF(CURIYR,IFUEL,ICR) = HISTBF(CURIYR,IFUEL,ICR)
 !      END IF

       BMAIN_ADJUSTED(IFUEL,ICR) = BMAIN(IFUEL,ICR) * BF(CURIYR,IFUEL,ICR)
! END LIMITS *********************************************************************
       END DO

       BMAIN_ADJUSTED(IFUEL,5) = SUM(BMAIN_ADJUSTED(IFUEL,1:4))
       IF (ABS(BMAIN(IFUEL,5)) .GT. 0.0) THEN
         BF(CURIYR,IFUEL,5) = BMAIN_ADJUSTED(IFUEL,5) / BMAIN(IFUEL,5)
       ELSE
         BF(CURIYR,IFUEL,5) = 0.0
       END IF
    END DO


       DO IFUEL=1, 8
       DO ICR=1,4

       RBF(CURIYR,IFUEL,ICR) = (1 - FADE) * RBF_SEDS(IFUEL,ICR) + &
                                    FADE  * RBF_SEDS(IFUEL,ICR) * RBF_STEO(IFUEL)

	! DITTO FOR RENEWABLES ... OVERWRITE FOR SIDE CASES
    ! KPE try no historical
    !  IF ((INDBMOVR2 .NE. 0) .AND. (CURCALYR .GT. (SEDSLASTYR + 2))) THEN
    ! 	  RBF(CURIYR,IFUEL,ICR) = RHISTBF(CURIYR,IFUEL,ICR)
    !  END IF

       BRENEW_ADJUSTED(IFUEL,ICR) = BRENEW(IFUEL,ICR) * RBF(CURIYR,IFUEL,ICR)

       END DO
       IF (SUM(BRENEW(IFUEL,1:4)) .NE. 0.0) THEN
          RBF(CURIYR,IFUEL,5) = SUM(BRENEW_ADJUSTED(IFUEL,1:4)) / SUM(BRENEW(IFUEL,1:4))
       ELSE
          RBF(CURIYR,IFUEL,5) = 0.0
       ENDIF
    END DO


    
!***********************************************************************************
! OUTPUT
    IF (FCRL .EQ. 1) THEN !CHECK FOR FCRL

    WRITE(IUNITBENCH,*) "FINAL BENCHMARK ADJUSTMENT ", "CALENDAR YEAR = ", CURCALYR
	IF (INDBMOVR2 .NE. 0) THEN
	   WRITE(IUNITBENCH,*) "*************************************************************************************************"
	   WRITE(IUNITBENCH,*) "THIS IS A SIDE CASE.  BENCHMARK FACTORS WERE OVERWRITTEN WITH REFERENCE CASE BENCHMARK FACTORS"
	   WRITE(IUNITBENCH,*) "*************************************************************************************************"
	END IF
    WRITE(IUNITBENCH,*) "FADE = ", FADE

    IF (CURIYR .LE. MSEDYR)  THEN
    WRITE(IUNITBENCH,*) "FUELNAME             ", "  BMAIN   ","   SEDS   ","    BF  ", "   FINAL"

    DO IFUEL=1,22
      WRITE(IUNITBENCH,330) FUELNAME(IFUEL),BMAIN(IFUEL,5),SEDS9(11,IFUEL),BF(CURIYR,IFUEL,5),BMAIN_ADJUSTED(IFUEL,5)
    END DO
    WRITE(IUNITBENCH,*) "*****************************************"
    WRITE(IUNITBENCH,*) "RFUELNAME            ", "  BRENEW   ","   RSEDS   ","  RBF   ", "   FINAL"
    DO IFUEL=1,8
      WRITE(IUNITBENCH,330) RFUELNAME(IFUEL),BRENEW(IFUEL,5),RSEDS9(11,IFUEL),RBF(CURIYR,IFUEL,5),BRENEW_ADJUSTED(IFUEL,5)
    END DO

    ELSE IF ( (CURIYR .GT. MSEDYR) .AND. (CURCALYR .LE. (STEOLASTYR - INDBMOVR2)) )  THEN

    WRITE(IUNITBENCH,*) "FUELNAME             ", "   BMAIN   ","   STEO   ","   BF   ", "   FINAL"
    DO IFUEL=1,22
      WRITE(IUNITBENCH,330) FUELNAME(IFUEL),BMAIN(IFUEL,5),STEO(IFUEL),BF(CURIYR,IFUEL,5),BMAIN_ADJUSTED(IFUEL,5)
    END DO
    WRITE(IUNITBENCH,*) "*****************************************"
    WRITE(IUNITBENCH,*) "RFUELNAME            ", "   BRENEW   ","   RSTEO   ","   RBF   ", "  FINAL"
    DO IFUEL=1,8
      WRITE(IUNITBENCH,330) RFUELNAME(IFUEL),BRENEW(IFUEL,5),RSTEO(IFUEL),RBF(CURIYR,IFUEL,5),BRENEW_ADJUSTED(IFUEL,5)
    END DO

    ELSE

    WRITE(IUNITBENCH,*) "FUELNAME             ", "  BMAIN","  BF_SEDS  ","  BF_STEO","  BF  ", "FINAL EST"
    DO ICR=1,4

    WRITE(IUNITBENCH,*) "REGION = ", ICR
    DO IFUEL=1,22
      WRITE(IUNITBENCH,340) FUELNAME(IFUEL),BMAIN(IFUEL,ICR),BF_SEDS(IFUEL,ICR),BF_STEO(IFUEL),BF(CURIYR,IFUEL,ICR),BMAIN_ADJUSTED(IFUEL,ICR)
    END DO
    WRITE(IUNITBENCH,*) "*****************************************"
    WRITE(IUNITBENCH,*) "RFUELNAME        ", "   BRENEW","  RBF_SEDS ","  RBF_STEO ","  RBF  ", "FINAL EST"
    DO IFUEL=1,8
      WRITE(IUNITBENCH,340) RFUELNAME(IFUEL),BRENEW(IFUEL,ICR),RBF_SEDS(IFUEL,ICR),RBF_STEO(IFUEL),RBF(CURIYR,IFUEL,ICR),BRENEW_ADJUSTED(IFUEL,ICR)
    END DO

    END DO

    END IF

  END IF !CHECK FOR FCRL

330  FORMAT(A,2F13.4,F8.4,F13.4)         ! POT_WEXOGWRITE F11.2 to F13.4
340  FORMAT(A,F11.4,3F8.4,F11.4)         ! POT_WEXOGWRITE F9.2 to F11.4

!****************************************************************************
!  Verification of LOGIC FOR COMPOSITE BENCHMARK FACTORS:
!
! BF_SEDS IS "FROZEN" AT MSEDYR
!
! BF_SEDS(J,ICR) = SEDS(J,ICR,MSEDYR) / BMAIN(J,ICR,MSEDYR)
!
! BF_STE0 IS "FROZEN" AT STEOLASTYR
!
! BF_STEO(J) = STEO(J,STEOLASTYR) / SUM(BMAIN(J,ICR,STEOLASTYR) * BF_SEDS(J,ICR))
!            = STEO(J,STEOLASTYR) / SUM(BMAIN(J,ICR,STEOLASTYR) * SEDS(J,ICR,MSEDYR) / BMAIN(J,ICR,MSEDYR))
!
! SO ... IGNORING THE COMPOSITING FACTOR THIS IS WHAT THE FINAL BENCHMARK
! ESTIMATE WOULD BE FOR 2017 USING 100 PERCENT BF_STEO
! ASSUME SEDS LAST YR = 2012 AND STEO LAST YEAR = 2016
!
! BMAIN_ADJUSTED(J,ICR,CURCALYR=2017) =
!       BMAIN(J,ICR,2017) * SEDS(J,ICR,2012) / BMAIN(J,ICR,2012) * STEO(J,2016) / SUM(BMAIN(J,ICR,2016) * SEDS(J,ICR,2012) / BMAIN(J,ICR,2012))
!
! HERE IS WHAT BMAIN_ADJUSTED WOULD BE IF BENCHMARKING WAS PURELY SEDS
!
! BENCH_FINAL_SEDS(J,ICR,2017) =
!    BMAIN(J,ICR,2017) * SEDS(J,ICR,2012) / BMAIN(J,ICR,2012)
!
! SO WHAT WE ARE DOING IS FORMING A COMPOSITE OF THE TWO BENCHMARKS FACTORS,
! BF_SEDS AND (BF_SEDS * BF_STEO)
!*****************************************************************************

! WRITE OUT RESULTS TO Q VARIABLES

DO ICD=1,9
      ICR = CReg(ICD)

    ! INDUSTRIAL ELECTRICITY
      QELIN(ICD,IY) = BMAIN_ADJUSTED(1,ICR) * DIVSHR(QSELIN(1,MSEDYR),ICD,ICR)&
      + QELRF(ICD,IY) + QELETH(IY,ICD)
      IF (ICD .EQ. 8) THEN
         QELIN(ICD,IY) = BMAIN_ADJUSTED(1,ICR) * DIVSHR(QSELIN(1,MSEDYR),ICD,ICR)&
                + QELRF(ICD,IY) + QELETH(IY,ICD) + OGELSHALE(IY)  ! ADD IN OILSHALE ELECTRICITY IN DIVISION 8
      END IF
 
      
    !*******************************************************************************************
    ! NG CORE
      QGFIN(ICD,IY) = (BMAIN_ADJUSTED(3,ICR) + BMAIN_ADJUSTED(5,ICR)) * DIVSHR(QSNGIN(1,MSEDYR),ICD,ICR)  ! Includes feedstock

    ! NG NONCORE ...
      QGIIN(ICD,IY) = BMAIN_ADJUSTED(4,ICR) * DIVSHR(QSNGIN(1,MSEDYR),ICD,ICR) &
           + QNGRF(ICD,IY) + QNGETH(IY,ICD) + QGTLRF(ICD,IY) + CGOGSQ(ICD,IY,ING3)

    ! NG FEEDSTOOCK
      INQNGPF(ICD,IY) = BMAIN_ADJUSTED(5,ICR) * DIVSHR(QSNGIN(1,MSEDYR),ICD,ICR)

    ! NG H&P TOTAL .... NEW Q VARIABLE ... SOMEDAY
    !  INQNGHP(ICD,IY) = QGFIN(ICD,IY) + QGIIN(ICD,IY)

    ! NG TOTAL SANS LEASE AND PLANT FUEL
      QNGIN(ICD,IY) = QGFIN(ICD,IY) + QGIIN(ICD,IY)
      
    !********************************************************************************************

    ! STEAM COAL
      QCLIN(ICD,IY) = BMAIN_ADJUSTED(7,ICR) * DIVSHR(QSCLIN(1,MSEDYR),ICD,ICR) &
        + QCLRF(ICD,IY) + QCLETH(IY,ICD) + CGOGSQ(ICD,IY,ICL1)


    ! MET COAL
      QMCIN(ICD,IY) = BMAIN_ADJUSTED(8,ICR) * DIVSHR(QSMCIN(1,MSEDYR),ICD,ICR)

    !  DSHARE = QSMCIN(I,CURIYR) / QSMCIN(11,CURIYR)  ! use met coal distribution to allocate net coke imports to divisions

    ! NET COKE COAL IMPORTS
         
      QCIIN(ICD,IY) = BMAIN_ADJUSTED(9,ICR) * DIVSHR(QCIIN(1,MSEDYR),ICD,ICR)     

    ! RESIDUAL FUEL TOTAL AND RESIDUAL FUEL LOW
      QRSIN(ICD,IY) = BMAIN_ADJUSTED(10,ICR) * DIVSHR(QSRSIN(1,MSEDYR),ICD,ICR) &
        + QRLRF(ICD,IY) + CGOGSQ(ICD,IY,IRL2)                   ! QRSXX=QRLXX+QRHXX where QRLXX is use of low-sulfur resid and QRHXX is use of high-sulfur resid; currently (as of 1/16/2020)
      QRLIN(ICD,IY) = QRSIN(ICD,IY)                             ! QRHRF=QRHRL=0, but if industrial consumption of high-sulfur resid was ever non-0, these equations probably wouldn't work correctly

    ! DISTILLATE
      QDSIN(ICD,IY) = BMAIN_ADJUSTED(11,ICR) * DIVSHR(QSDSIN(1,MSEDYR),ICD,ICR) &
              + QDSRF(ICD,IY)
      
    !************************************************************************************************
    ! NOTES FROM PREVIOUS SECTION ...
      ! TQMAIN(12) IS LPG HEAT AND POWER.  IT APPEARS THAT THE CURRENT WEXOG CREATED A CATEGORY
      ! BMAIN(8) AS A SUM OF TQMAIN(12) AND TQMAIN(13) WHICH WOULD BE LPG TOTAL. THIS IS NOT WHAT WE
      ! WANT TO DO.
      ! LPG ASSUME TOTAL
    !************************************************************************************************

    ! LPG FEEDSTOCK
    ! Subtract naphtha flex consumption from HGL feedstock (convert to ethane-equivalent tBtu — that is, the tBtus of ethane needed to produce the same amount of ethylene
      INQLGPF(ICD,IY) = BMAIN_ADJUSTED(13,ICR) * DIVSHR(QSLGIN(1,MSEDYR),ICD,ICR)! - &

    ! LPG HEAT AND POWER
      INQLGHP(ICD,IY) = BMAIN_ADJUSTED(12,ICR) * DIVSHR(QSLGIN(1,MSEDYR),ICD,ICR) &
        + QLGRF(ICD,IY)  ! + QSPPIN(ICD,IY)
    


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        
    ! SEDS.f90 SUBTRACTS QSPPIN BUT I DON'T SEE THIS ADDED BACK IN CURRENT WEXOG ... CHECK WITH PETER
    ! CORRECTED 05/04/2015.  QSPPIN IS PENTANES PLUS AND IS INCLUDED IN THE FEEDSTOCK NUMBER PETER
    ! HARDCODED INTO THE PROGRAM.  EARLIER VERSIONS OF WEXOG INCLUDED IT SEPARATELY WHICH WE NOW
    ! BELIEVE WAS IN ERROR.

      QLGIN(ICD,IY) = INQLGPF(ICD,IY) + INQLGHP(ICD,IY)
    
    !*********************************************************************************************************
    ! MOGAS
      QMGIN(ICD,IY) = BMAIN_ADJUSTED(14,ICR) * DIVSHR(QSMGIN(1,MSEDYR),ICD,ICR)

    ! STILL GAS
      QSGIN(ICD,IY) = QSGRF(ICD,CURIYR)

    ! PET COKE
      QPCIN(ICD,IY) = BMAIN_ADJUSTED(16,ICR) * DIVSHR(QSPCIN(1,MSEDYR),ICD,ICR) &
          + QPCRF(ICD,IY) + QCCRF(ICD,IY)

    ! ASPHALT AND ROAD OIL
      QASIN(ICD,IY) = BMAIN_ADJUSTED(17,ICR) * DIVSHR(QSASIN(1,MSEDYR),ICD,ICR)

    ! LUBES
      QLUIN(ICD,IY) = BMAIN_ADJUSTED(18,ICR) * DIVSHR(QSLUIN(1,MSEDYR),ICD,ICR)
      
    ! PETRO FEEDSTOCK
      QPFIN(ICD,IY) = BMAIN_ADJUSTED(19,ICR) * DIVSHR(QSPFIN(1,MSEDYR),ICD,ICR)

    ! KEROSENE IS NOT MODELED IN THE INDUSTRIAL MODULE
     IF (CURCALYR .gt. MSEDYR) Then
        QKSIN(ICD,IY) = QSKSIN(ICD,MSEDYR)      ! Becuase residential sets their kerosene consumption to 0 but really rolls it into distillate, 
     END IF                                     ! it didn't make sense to make industrial kerosene the STEO total minus comercial and residential consumption    

    ! OTHER PETRO
      QOTIN(ICD,IY) = BMAIN_ADJUSTED(21,ICR) * DIVSHR(QSOTIN(1,MSEDYR),ICD,ICR) &
         + QOTRF(ICD,IY)

 ! RENEWABLE FUELS *****************************************************************************

    ! HYDRO
      QHOIN(ICD,IY) = BRENEW_ADJUSTED(1,ICR) * DIVSHR(QSHOIN(1,MSEDYR),ICD,ICR)

    ! BIOMASS
      QBMIN(ICD,IY) = BRENEW_ADJUSTED(2,ICR) * DIVSHR(QSBMIN(1,MSEDYR),ICD,ICR) + QBMRF(ICD,IY)
		! ADDED &+QBMRF(ICD,IY) (ADDITION OF REFINERY CONSUMPTION OF BIOMASS) 8/26/16 BY MS

    ! GEOTHERMAL
      QGEIN(ICD,IY) = BRENEW_ADJUSTED(4,ICR) * DIVSHR(QSGEIN(1,MSEDYR),ICD,ICR)

    ! SOLAR
      QSTIN(ICD,IY) = BRENEW_ADJUSTED(5,ICR) * DIVSHR(QSSTIN(1,MSEDYR),ICD,ICR)

    ! PHOTOVOLTAIC
      QPVIN(ICD,IY) = BRENEW_ADJUSTED(6,ICR) * DIVSHR(QSPVIN(1,MSEDYR),ICD,ICR)

    ! WIND
      QWIIN(ICD,IY) = BRENEW_ADJUSTED(7,ICR) * DIVSHR(QSWIIN(1,MSEDYR),ICD,ICR)

    ! MUNICIPAL SOLID WASTE
      QMSIN(ICD,IY) = BRENEW_ADJUSTED(8,ICR) * DIVSHR(QSMSIN(1,MSEDYR),ICD,ICR)

    ! TOTAL RENEWABLES
      QTRIN(ICD,IY) = QHOIN(ICD,IY) + QGEIN(ICD,IY) + QBMIN(ICD,IY) + &
                      QMSIN(ICD,IY) + QSTIN(ICD,IY) + QPVIN(ICD,IY) + &
                      QWIIN(ICD,IY)
! END RENEWABLE FUELS

       
         IF (CURCALYR .lt. SEDSLASTYR+1) Then             ! Fixed regional (and, slightly, total) read-ins froms SEDS numbers
          Do ID=1,11                                      ! (BMAIN_ADJUSTED isn't properly matching regional totals); NSK 1/15/2020        
         
              QELIN(ID,IY) = QSELIN(ID,IY)                ! Electricity              
              QDSIN(ID,IY) = QSDSIN(ID,IY)                ! Distillate
              QRSIN(ID,IY) = QSRSIN(ID,IY)                ! Resid
              QRLIN(ID,IY) = QRSIN(ID,IY)                 ! Low-sulfur resid
              QLGIN(ID,IY) = QSLGIN(ID,IY) + QSPPIN(ID,IY)! HGL
              QMGIN(ID,IY) = QSMGIN(ID,IY)                ! Mogas
              QPFIN(ID,IY) = QSPFIN(ID,IY)                ! Petrochemical feedstock; none currently outside Census Division 7, but if this changes someday, this code would fix BMAIN(19) during SEDS years
              QASIN(ID,IY) = QSASIN(ID,IY)                ! Asphalt and road oil
              QKSIN(ID,IY) = QSKSIN(ID,IY)                ! Kerosene
              QLUIN(ID,IY) = QSLUIN(ID,IY)                ! Lubes
              QPCIN(ID,IY) = QSPCIN(ID,IY)                ! Petroleum coke (includes refinery consumption)
              QOTIN(ID,IY) = QSOTIN(ID,IY)                ! Other petroleum: aviation gasoline blending components, unfinished oils, waxes, lubes, special naphthas, and miscellaneous petroleum products
                                                          ! (series for non-refinery crude oil, motor gasoline blending components, and unfractionated streams before 1984 are included, but equal 0)
              QGFIN(ID,IY) = QSGFIN(ID,IY)                ! Natural gas heat and power core (based on firm/interruptible  shares from last AEO's restart file—we should probably figure out a better method)
              QGIIN(ID,IY) = QSGIIN(ID,IY)                ! Natural gas heat and power non-core (based on firm/interruptible  shares from last AEO's restart file—we should probably figure out a better method)
              QNGIN(ID,IY) = QSNGIN(ID,IY)                ! Natural gas heat and power total
              QCLIN(ID,IY) = QSCLIN(ID,IY)                ! Steam coal
              QMCIN(ID,IY) = QSMCIN(ID,IY)                ! Met coal
              QCIIN(ID,IY) = QSCIIN(11,IY)*COKECOALIMPORTPERCENT(ID)                ! Net coke coal imports based on approximate Census Division breakdown in January 2020 Quarterly Coal Report
              QPRIN(ID,IY) = QSPRIN(ID,IY)                ! Propane (0 before 2010)
!              INQLGHP(ICD,IY) = BMAIN_ADJUSTED(12,ICR) * DIVSHR(QSLGIN(1,MSEDYR),ICD,ICR) &
!                + QLGRF(ICD,IY)  ! + QSPPIN(ICD,IY)
              
     ! Renewables              
              
              QBMIN(ID,IY) = QSBMIN(ID,IY)                ! Wood
              QHOIN(ID,IY) = QSHOIN(ID,IY)                ! Hydroelectricity (includes commercial consumption)
              QMSIN(ID,IY) = QSMSIN(ID,IY)                ! Municipal solid waste
     
              
          End Do
         End If
      
 END DO      


!*************************************************************************
!  CREATE NATIONAL LEVEL Q ESTIMATES
    QELIN(11,IY) = sum(QELIN(1:9,IY))
    QGFIN(11,IY) = sum(QGFIN(1:9,IY))
    QGIIN(11,IY) = sum(QGIIN(1:9,IY))
    INQNGPF(11,IY) = sum(INQNGPF(1:9,IY))
!    INQNGHP(11,IY) = sum(INQNGHP(1:9,IY))  does not exist yet
    QNGIN(11,IY) = sum(QNGIN(1:9,IY))
    QCLIN(11,IY) = sum(QCLIN(1:9,IY))
    QMCIN(11,IY) = sum(QMCIN(1:9,IY))
    QCIIN(11,IY) = sum(QCIIN(1:9,IY))
    QRSIN(11,IY) = sum(QRSIN(1:9,IY))
    QDSIN(11,IY) = SUM(QDSIN(1:9,IY))   
    QLGIN(11,IY) = sum(QLGIN(1:9,IY))
    INQLGPF(11,IY) = sum(INQLGPF(1:9,IY))
    INQLGHP(11,IY) = sum(INQLGHP(1:9,IY))    
    QMGIN(11,IY) = sum(QMGIN(1:9,IY))
    QSGIN(11,IY) = sum(QSGIN(1:9,IY))
    QPCIN(11,IY) = sum(QPCIN(1:9,IY))
    QASIN(11,IY) = sum(QASIN(1:9,IY))
    QLUIN(11,IY) = sum(QLUIN(1:9,IY))
    QPFIN(11,IY) = sum(QPFIN(1:9,IY))
    QKSIN(11,IY) = sum(QKSIN(1:9,IY))
    QOTIN(11,IY) = sum(QOTIN(1:9,IY))
    QHOIN(11,IY) = sum(QHOIN(1:9,IY))
    QBMIN(11,IY) = sum(QBMIN(1:9,IY))
    QGEIN(11,IY) = sum(QGEIN(1:9,IY))
    QSTIN(11,IY) = sum(QSTIN(1:9,IY))
    QPVIN(11,IY) = sum(QPVIN(1:9,IY))
    QWIIN(11,IY) = sum(QWIIN(1:9,IY))
    QMSIN(11,IY) = sum(QMSIN(1:9,IY))
    QTRIN(11,IY) = sum(QTRIN(1:9,IY))
! print out here
write(IUNITBUG,'(" Met coal Q variable ",I6,10F12.3)') curcalyr,QMCIN(1:9,IY),QMCIN(11,IY)

! put another set of WRITE statements here ....
    IF (FCRL .EQ. 1) THEN
      WRITE(IUNITBENCH,*) "FINAL Q VARIABLES AND COMPONENTS"
      IF (CURIYR .LE. MSEDYR)  THEN
        WRITE(IUNITBENCH,*) "CURCALYR = ", CURCALYR
        WRITE(IUNITBENCH,*) "QELIN = ", QELIN(11,CURIYR), "QSELIN = ", QSELIN(11,CURIYR), "REF = ", REF(1)
        WRITE(IUNITBENCH,*) "QNGIN = ", QNGIN(11,CURIYR), "QSNGIN = ", QSNGIN(11,CURIYR), "REF = ", REF(3)
        WRITE(IUNITBENCH,*) "INQNGPF = ", INQNGPF(11,CURIYR)
        WRITE(IUNITBENCH,*) "QGFIN = ", QGFIN(11,CURIYR), "QGIIN = ", QGIIN(11,CURIYR)
        WRITE(IUNITBENCH,*) "QRLIN = ", QRLIN(11,CURIYR), "QSRLIN = ",QSRLIN(11,CURIYR), "REF = ", REF(10)
        WRITE(IUNITBENCH,*) "QDSIN = ", QDSIN(11,CURIYR), "QSDSIN = ", QSDSIN(11,CURIYR), "REF = ", REF(11)
        WRITE(IUNITBENCH,*) "QLGIN = ", QLGIN(11,CURIYR), "QSLGIN = " , QSLGIN(11,CURIYR), "REF = ", REF(12)
        WRITE(IUNITBENCH,*) "INQLGPF = ", INQLGPF(11,CURIYR)
        WRITE(IUNITBENCH,*) "QSGIN = ", QSGIN(11,CURIYR), "QSSGIN = ", QSSGIN(11,CURIYR), "REF = ", REF(15)
        WRITE(IUNITBENCH,*) "QLUIN = ", QLUIN(11,CURIYR), "BMAIN = ", BMAIN(18,5)
        WRITE(IUNITBENCH,*) "QOTIN = ", QOTIN(11,CURIYR), "QSOTIN = ", QSOTIN(11,CURIYR), "REF = ", REF(21)
        WRITE(IUNITBENCH,*) "QKSIN = ", QKSIN(11,CURIYR), "QSKSIN = ", QSKSIN(11,CURIYR), "REF = ", REF(20)
       

      ELSE IF (( CURIYR .GT. MSEDYR) .AND. &
        (CURCALYR .LE. (STEOLASTYR - INDBMOVR2)) )  THEN
        WRITE(IUNITBENCH,*) "CURCALYR = ", CURCALYR
      DO IFUEL=1,22
         WRITE(IUNITBENCH,'(a,2x,a,F12.4,2x,a,2F12.4,F10.4)') FUELNAME(IFUEL), "STEO = ", STEO(IFUEL),  &
           "BMAIN = ", BMAIN(IFUEL,5), REF(IFUEL), BF(CURIYR,IFUEL,5)
      END DO
     ELSE
      DO IFUEL=1,22
         WRITE(IUNITBENCH,'(a,2x,a,F12.4,2x,a,F12.4,2x,a,F10.4,2x,a,F12.4)') FUELNAME(IFUEL),  &
           "BMAIN = ",BMAIN(IFUEL,5), &
           "BMAIN_ADJUSTED = ", BMAIN_ADJUSTED(IFUEL,5), &
           "BF = ", BF(CURIYR,IFUEL,5), "REF = ", REF(IFUEL)
      END DO
     END IF

     IF (CURCALYR .EQ. IEYR) THEN            ! POT_2050 2040 to IEYR calculated from LASTYR to last year 2040
      WRITE(IUNITBENCH,*) "US BENCHMARK FACTORS,2010,2011"
      DO IFUEL=1,22
        WRITE(IUNITBENCH,350) FUELNAME(IFUEL), BF(ICURIYR2:LASTYR,IFUEL,5)       ! POT_2050 51 to LASTYR
      END DO
      DO ICR=1,4
        WRITE(IUNITBENCH,*) " "
        WRITE(IUNITBENCH,*) "BENCHMARK FACTORS REGION ", ICR,",2010,2011"
        DO IFUEL=1,22
          WRITE(IUNITBENCH,350) FUELNAME(IFUEL), BF(ICURIYR2:LASTYR,IFUEL,ICR)      ! POT_2050 51 to LASTYR
        END DO
      END DO

	 ! WRITE TO IBFACTRO .... THE OFFICIAL OUTPUT FILE FOR THE BENCHMARK FACTORS

	DO IFUEL=1,22
	    DO ICR=1,4
          WRITE(IFACTOUT,351) FUELNAME(IFUEL),IFUEL,ICR, BF(ICURIYR2:LASTYR,IFUEL,ICR)	      ! POT_2050 51 to LASTYR - kpe lower bound 21 to ICURIYR2
	    END DO
	END DO

    DO IFUEL=1,8
	   DO ICR=1,4
	      WRITE(IFACTOUT,351) RFUELNAME(IFUEL),IFUEL,ICR, RBF(ICURIYR2:LASTYR,IFUEL,ICR)        ! POT_2050 51 to LASTYR - kpe lower bound 21 to ICURIYR2
	   END DO
    END DO


    END IF

	END IF ! END OF CHECK FOR FCRL=1

350     FORMAT(A,<LASTYR-21+1>(",",F8.4))                         ! POT_WEXOGWRITE F6.2 to F8.4
351     FORMAT(A,2(",",I3),<LASTYR-ICURIYR2+1>(",",F12.6))


! THIS IS THE LAST SECTION OF CODE THAT BEGINS WITH THE LPG COMPONENTS
! BREAKDOWN CODE THAT PETER WROTE.  REVIEW CODE TO MAKE SURE PREVIOUSLY
! DEFINED VARIABLES ARE NOT OVERWRITTEN.  THERE IS ALSO CODE AT END THAT
! NEEDS TO BE REVIEWED.
! BEGIN CODE:


! sulfur demand
! based on linear regression between macro ag chemical shipments and
! USGS data for sulfur consumption in the United States
! using the USGS 2009 and 2007 Minerals Yearbook (Sulfur)
      qsulfurin(11,iy) = &
            341.7 *mc_revind(11,19,curiyr)* MC_REVIND_ADJ(19) + 4751.8

      do icd = 1,9
         qsulfurin(icd,iy) = qsulfurin(11,iy)* &
     mc_revind(icd,19,curiyr)/mc_revind(11,19,curiyr)
!         write(IFEEDOUT,*) 'icd and qsulfurin(icd,iy) = ',icd,qsulfurin(icd,iy)
      end do
!      write (IFEEDOUT,*) 'iy  qsulfurin(11,iy)',iy,qsulfurin(11,iy)

      if (curcalyr.gt.sedslastyr+feedyears) then                
	          qlgin(11,curiyr) = inqlgpf(11,curiyr) + inqlghp(11,curiyr)
			  qlgin(1:9,curiyr) = inqlgpf(1:9,curiyr) + inqlghp(1:9,curiyr)
      end if

        write (IFEEDOUT,*)'plginpf(11,23) sum(inqlgpf(1:9,23)) pprolenerf(11,23) sum(tqmain(19,1:4)) sum(qpfin(1:9,23)) ppfin(11,curiyr)'
        write (IFEEDOUT,*) plginpf(11,23),sum(inqlgpf(1:9,23)),pprolenerf(11,23),sum(tqmain(19,1:4)),sum(qpfin(1:9,23)),ppfin(11,curiyr)
        write (IFEEDOUT,*) 'idiot check'
        write (IFEEDOUT,*) 'national LPG feedstock = ',sum(inqlgpf(1:9,iy))
        write (IFEEDOUT,*) 'total feedstock = ',sum(qpfin(1:9,iy)) + sum(inqlgpf(1:9,iy))


! NOTE THAT (CONSISTENT WITH THE REST OF IDM) THAT ALL FEEDSTOCK DEMANDS ARE IN TRILLS
! ethane demand (national) - is technically part of the "LPG" in the MER
! assume that all ethane is used for petrochemical feedstock

! NGPL feedstock ///////////////////////////////////////////////////////////// NSK 9/27/2019

      ethaneproduction =  RFQNGPL(10,curiyr,1)*CFEEQ*365.0*10.0**3/10.0**6              ! LFMM (really OGSM) national ethane production, thousand barrels/d to trillion BTU/yr
                                                                                        ! CFEEQ = 2.783 MMBtu/b ethane
      
    If (CURCALYR .eq. ibyr2) Then                            
        Do Hist_Yr = 1, 16              ! Put in historical numbers from 1990–2005 from feedstkaer.csv; NSK 4/1/2020         
            qetinpf(11,Hist_Yr) = aerethfeedhistory(Hist_Yr)                          ! Ethane
            qprinpf(11,Hist_Yr) = aerpropanefeedhistory(Hist_Yr)                      ! Propane
            qprolenerf(11,Hist_Yr) = aerpropylenefeedhistory(Hist_Yr)                 ! Propylene
            qbuinpf(11,Hist_Yr) = aernormbutanefeedhistory(Hist_Yr)                   ! Normal butane
            qisinpf(11,Hist_Yr) = aerisobutanefeedhistory(Hist_Yr)                    ! Isobutane
            qppinpf(11,Hist_Yr) = aernatgasolinefeedhistory(Hist_Yr)                  ! Natural gasoline
  
            Do ID =1,9
                qetinpf(ID,Hist_Yr) = EthaneDivFrac(ID,Hist_Yr) * qetinpf(11,Hist_Yr)           ! Read in ethane fractions to calculate regional ethane
                qprinpf(ID,Hist_Yr) = PropaneDivFrac(ID,Hist_Yr) * qprinpf(11,Hist_Yr)          ! Read in propane fractions to calculate regional propane
                qprolenerf(ID,Hist_Yr) = propylenedivfrac(ID)*qprolenerf(11,Hist_Yr)            ! Regional propylene breakdown; fractions of total based on Warren's regional numbers; NSK 9/26/19
                
                If (ID .eq. 7) then                                 ! Butane and natural gasoline feedstock is all consumed in Division 7; NSK 9/26/2019
                    qisinpf(ID,Hist_Yr) = qisinpf(11,Hist_Yr)
                    qbuinpf(ID,Hist_Yr) = qbuinpf(11,Hist_Yr)
                    qppinpf(ID,Hist_Yr) = qppinpf(11,Hist_Yr)
                Else
                    qisinpf(ID,Hist_Yr) = 0   
                    qbuinpf(ID,Hist_Yr) = 0
                    qppinpf(ID,Hist_Yr) = 0
                Endif

            End Do
            
        End Do
        
        Do Hist_Yr = 17,ibyr2-1990+1   ! Put in historical data from 2006 to base year (2014 as of AEO2021) from feedstock.csv; NSK 4/1/2020 
            qetinpf(11,Hist_Yr) = feedethtotal(Hist_Yr-16)                          ! Ethane
            qprinpf(11,Hist_Yr) = feedpropanetotal(Hist_Yr-16)                      ! Propane
            qprolenerf(11,Hist_Yr) = feedpropylenetotal(Hist_Yr-16)                 ! Propylene
            qbuinpf(11,Hist_Yr) = feednormbutanetotal(Hist_Yr-16)                   ! Normal butane
            qisinpf(11,Hist_Yr) = feedisobutanetotal(Hist_Yr-16)                    ! Isobutane
            qppinpf(11,Hist_Yr) = feednatgasolinetotal(Hist_Yr-16)                  ! Natural gasoline


            Do ID =1,9
                qetinpf(ID,Hist_Yr) = EthaneDivFrac(ID,Hist_Yr) * qetinpf(11,Hist_Yr)               ! Read in ethane fractions to calculate regional ethane
                qprinpf(ID,Hist_Yr) = PropaneDivFrac(ID,Hist_Yr) * qprinpf(11,Hist_Yr)              ! Read in propane fractions to calculate regional propane
                qprolenerf(ID,Hist_Yr) = propylenedivfrac(ID)*qprolenerf(11,Hist_Yr)                ! Regional propylene breakdown; fractions of total based on Warren's regional numbers; NSK 9/26/19
            
                If (ID .eq. 7) then                                 ! Butane and natural gasoline feedstock is all consumed in Division 7; NSK 9/26/2019
                    qisinpf(ID,Hist_Yr) = qisinpf(11,Hist_Yr)
                    qbuinpf(ID,Hist_Yr) = qbuinpf(11,Hist_Yr)
                    qppinpf(ID,Hist_Yr) = qppinpf(11,Hist_Yr)
                Else
                    qisinpf(ID,Hist_Yr) = 0   
                    qbuinpf(ID,Hist_Yr) = 0
                    qppinpf(ID,Hist_Yr) = 0
                Endif
                
            End Do
            
        End Do

    Else If (CURIYR .gt. 16 .and. CURIYR .lt. MSEDYR+FEEDYEARS+1) Then  ! Put in historical and projected numbers from 2014 to MSEDYR+FEEDYEARS (2021 for AEO 2020) from feedstock.csv;
                                                                        ! since model doesn't run before 2014, these will start populating at 2014 instead of 2007 (when CURIYR=17); NSK 9/25/2019
          qetinpf(11,curiyr) = feedethtotal(CURIYR-16)                            ! Ethane
          qprinpf(11,curiyr) = feedpropanetotal(CURIYR-16)                        ! Propane
          qprolenerf(11,curiyr) = feedpropylenetotal(CURIYR-16)                   ! Propylene          
          qbuinpf(11,curiyr) = feednormbutanetotal(CURIYR-16)                     ! Normal butane
          qisinpf(11,curiyr) = feedisobutanetotal(CURIYR-16)                      ! Isobutane
          qppinpf(11,curiyr) = feednatgasolinetotal(CURIYR-16)                    ! Natural gasoline
     
!          Do ID =1,9
!                qetinpf(ID,curiyr) = EthaneDivFrac(ID,curiyr) * qetinpf(11,curiyr)           ! Read in ethane fractions to calculate regional ethane
!                qprinpf(ID,curiyr) = PropaneDivFrac(ID,curiyr) * qprinpf(11,curiyr)          ! Read in propane fractions to calculate regional propane
!                
!                If (ID .eq. 7) then                                 ! Butane and natural gasoline feedstock is all consumed in Division 7; NSK 9/26/2019
!                    qisinpf(ID,curiyr) = qisinpf(11,curiyr)
!                    qbuinpf(ID,curiyr) = qbuinpf(11,curiyr)
!                    qppinpf(ID,curiyr) = qppinpf(11,curiyr)
!                Else
!                    qisinpf(ID,curiyr) = 0   
!                    qbuinpf(ID,curiyr) = 0
!                    qppinpf(ID,curiyr) = 0
!                Endif

!          End Do

          
    Else If (CURIYR .gt. MSEDYR+FEEDYEARS) Then                             ! Put in projected numbers after MSEDYR+FEEDYEARS (2021 for AEO 2020); NSK 4/1/2020 
        qprolenerf(11,curiyr) = 302000*365*3.835/1000000.0                                                                    ! Set total propylene at 302,000 b/d after MSEDYR+FEEDYEARS; NSK 9/24/2019
          
        IF (qetinpf(11,curiyr) .gt. ethaneproduction) THEN
            heattemp2(curiyr) = qetinpf(11,curiyr) - ethaneproduction
            qetinpf(7,curiyr) = qetinpf(7,curiyr) - heattemp2(curiyr)    ! Reduce consumption only in division 7
            qetinpf(11,curiyr) = qetinpf(11,curiyr) - heattemp2(curiyr)
        ELSE
            heattemp2(curiyr)=0.0
        END IF
          
        qprinpf(11,curiyr) = MAX((inqlgpf(11,curiyr)-qetinpf(11,curiyr)-qprolenerf(11,curiyr)-heattemp2(curiyr))*qprinpf(11,MSEDYR+FEEDYEARS)/ &                 ! Propane after the last read-in year (MSEDYR+FEEDYEARS, or 2022 for AEO 2021) is set to be
            (inqlgpf(11,MSEDYR+FEEDYEARS)-qetinpf(11,MSEDYR+FEEDYEARS)-qprolenerf(11,MSEDYR+FEEDYEARS)-heattemp2(MSEDYR+FEEDYEARS)) + 0.83*heattemp2(curiyr),0.0) ! the same fraction of total feedstock HGL minus propylene and ethane as the last read-in year; also add 83% of ethane demand that OGSM can't meet (NSK 7/2021)
        qbuinpf(11,curiyr) = MAX((inqlgpf(11,curiyr)-qetinpf(11,curiyr)-qprolenerf(11,curiyr)-heattemp2(curiyr))*qbuinpf(11,MSEDYR+FEEDYEARS)/ &                 ! n-butane isobutane after the last read-in year (MSEDYR+FEEDYEARS, or 2022 for AEO 2021) is set to be
            (inqlgpf(11,MSEDYR+FEEDYEARS)-qetinpf(11,MSEDYR+FEEDYEARS)-qprolenerf(11,MSEDYR+FEEDYEARS)-heattemp2(MSEDYR+FEEDYEARS)) + 0.17*heattemp2(curiyr),0.0) ! the same fraction of total feedstock HGL minus propylene and ethane as the last read-in year; also add 17% of ethane demand that OGSM can't meet (NSK 7/2021)
        qisinpf(11,curiyr) = MAX((inqlgpf(11,curiyr)-qetinpf(11,curiyr)-qprolenerf(11,curiyr)-heattemp2(curiyr))*qisinpf(11,MSEDYR+FEEDYEARS)/ &                 ! Isobutane after the last read-in year (MSEDYR+FEEDYEARS, or 2022 for AEO 2021) is set to be 
            (inqlgpf(11,MSEDYR+FEEDYEARS)-qetinpf(11,MSEDYR+FEEDYEARS)-qprolenerf(11,MSEDYR+FEEDYEARS)-heattemp2(MSEDYR+FEEDYEARS)),0.0)                         ! the same fraction of total feedstock HGL minus propylene and ethane as the last read-in year (NSK 7/2021)
        qppinpf(11,curiyr) = MAX((inqlgpf(11,curiyr)-qetinpf(11,curiyr)-qprolenerf(11,curiyr)-heattemp2(curiyr))*qppinpf(11,MSEDYR+FEEDYEARS)/ &                 ! Natural gasoline after the last read-in year (MSEDYR+FEEDYEARS, or 2022 for AEO 2021) is set to be
            (inqlgpf(11,MSEDYR+FEEDYEARS)-qetinpf(11,MSEDYR+FEEDYEARS)-qprolenerf(11,MSEDYR+FEEDYEARS)-heattemp2(MSEDYR+FEEDYEARS)),0.0)                         ! the same fraction of total feedstock HGL minus propylene and ethane as the last read-in year (NSK 7/2021)

		  continue
!          Do ID =1,9
!              qetinpf(ID,CURIYR) = EthaneDivFrac(ID, MSEDYR+FEEDYEARS) * qetinpf(11,CURIYR)   ! Use STEOLASTYR+4 ethane fractions for years after STEOLASTYR+4 
!              qprinpf(ID,CURIYR) = PropaneDivFrac(ID, MSEDYR+FEEDYEARS) * qprinpf(11,CURIYR)
!                If (ID .eq. 7) then                                 ! Butane and natural gasoline feedstock is all consumed in Division 7; NSK 9/26/2019
!                    qisinpf(ID,curiyr) = qisinpf(11,curiyr)
!                    qbuinpf(ID,curiyr) = qbuinpf(11,curiyr)
!                    qppinpf(ID,curiyr) = qppinpf(11,curiyr)
!                Else
!                    qisinpf(ID,curiyr) = 0   
!                    qbuinpf(ID,curiyr) = 0
!                    qppinpf(ID,curiyr) = 0
!                Endif
              
 !         End Do
          
    End If                                                   
      
      write (IFEEDOUT,*) 'total ethane from OGSM in Mb/d RFQNGPL(10,curiyr,1)) = ', RFQNGPL(10,curiyr,1)
      write (IFEEDOUT,*) 'actual ethane consumed and ethane produced'
      write (IFEEDOUT,*) qetinpf(11,iy),ethaneproduction
      write (IFEEDOUT,*) 'check propylene at year ',iy+1989
      write (IFEEDOUT,*) 'total propylene demand ',qprolenerf(11,curiyr)
      write (IFEEDOUT,*) 'national feedstock values before adjustment  '
      write (IFEEDOUT,*) 'ethane','  pentanes+','  isobutane'
      write (IFEEDOUT,*) qetinpf(11,curiyr),qppinpf(11,curiyr),qisinpf(11,curiyr)
      write (IFEEDOUT,*) 'normal butane','  propane','  propylene'
      write (IFEEDOUT,*) qbuinpf(11,curiyr),qprinpf(11,curiyr),qprolenerf(11,curiyr)
      write (IFEEDOUT,*) 'check of total feedstocks = ',qetinpf(11,curiyr)+qppinpf(11,curiyr)+qisinpf(11,curiyr)+ &
                          qbuinpf(11,curiyr)+qprinpf(11,curiyr)+qprolenerf(11,curiyr)

! share out national totals of ethane & n-butane & isobutane & pentanes+ & propane feedstock demand amongst the 9 Census Divisions
      do icd = 1,9
          
          qprolenerf(ICD,CURIYR) = propylenedivfrac(ICD)*qprolenerf(11,CURIYR)              ! Regional propylene breakdown; fractions of total based on Warren's regional numbers; NSK 9/26/19

          IF (CURIYR .gt. MAX_FRAC_YEARS) THEN                                              ! Regional propane fractions read in from CSV file
              qprinpf(ICD,CURIYR) = PropaneDivFrac(ICD, MAX_FRAC_YEARS) * qprinpf(11,CURIYR)
          ELSE
              qprinpf(ICD,CURIYR) = PropaneDivFrac(ICD, CURIYR) * qprinpf(11,CURIYR)   
          ENDIF
          
          IF (curcalyr.le.sedslastyr+feedyears) THEN                                        ! Regional ethane fractions read in from CSV file
              qetinpf(ICD,CURIYR) = EthaneDivFrac(ICD, CURIYR) * qetinpf(11,CURIYR)         ! up to SEDSLASTYR+5 (2023 in AEO2021)
          ENDIF                                                                             ! Defined (far) above for years after this
        
          If (ICD .eq. 7) then                                 ! Butane and natural gasoline feedstock is all consumed in Division 7; NSK 9/26/2019
              qisinpf(icd,curiyr) = qisinpf(11,curiyr)
              qbuinpf(icd,curiyr) = qbuinpf(11,curiyr)
              qppinpf(icd,curiyr) = qppinpf(11,curiyr)
          Else
              qisinpf(icd,curiyr) = 0   
              qbuinpf(icd,curiyr) = 0
              qppinpf(icd,curiyr) = 0
          Endif
          
      end do

     if (curcalyr.le.sedslastyr+feedyears) then  ! ensure feedstock total = inqlgpf during benchmarking years
	  	do icd = 1,9
			inqlgpf(icd,curiyr) = qetinpf(icd,curiyr) + qprinpf(icd,curiyr) + qprolenerf(icd,curiyr) + & 
			qbuinpf(icd,curiyr) + qisinpf(icd,curiyr) + qppinpf(icd,curiyr)
		end do	
	  	do icd = 11,11
			inqlgpf(icd,curiyr) = qetinpf(icd,curiyr) + qprinpf(icd,curiyr) + qprolenerf(icd,curiyr) + & 
			qbuinpf(icd,curiyr) + qisinpf(icd,curiyr) + qppinpf(icd,curiyr)
		end do	
	  end if


! Adjust for negative regional heat and power
      
! compute (for LFMM) industrial heat and power demand for LPG

!      do icd = 11,11
!         inqlghp(icd,iy) = qlgin(icd,iy) - inqlgpf(icd,iy)
!      end do
      do icd = 1,9
         inqlghp(icd,iy) = qlgin(icd,iy) - inqlgpf(icd,iy)
      end do

	  heattemp(curiyr) = 0.0

 
!	if (curcalyr.gt.sedslastyr+2 .and. curcalyr.lt.sedslastyr+5) then
!      do icd = 1,9
!		 if (inqlghp(icd,iy).lt.0.8*inqlghp(icd,iy-1)) then
!		    qlgin(icd,iy) = qlgin(icd,iy) + (0.85*inqlghp(icd,iy-1) - inqlghp(icd,iy))
!			inqlghp(icd,iy) = 0.85*inqlghp(icd,iy-1)
!		end if
 !        write (IFEEDOUT,*) 'first regional check on inqlghp  =  ',inqlghp(icd,iy)
   !   end do


 !     do icd = 1,9
!		 if (inqlghp(icd,iy).gt.1.2*inqlghp(icd,iy-1)) then
!		    qlgin(icd,iy) = qlgin(icd,iy) - (inqlghp(icd,iy) - 1.15*inqlghp(icd,iy-1))
!			inqlghp(icd,iy) = 1.15*inqlghp(icd,iy-1)
!         end if
!        write (IFEEDOUT,*) 'first regional check on inqlghp  =  ',inqlghp(icd,iy)
!      end do
!    end if
  


       do icd = 1,9 ! correct for regional negative heat & power LPG fuel
         if (inqlghp(icd,iy).lt.0.0) then
            do icr = 1,9
               if (icd.ne.icr) then
                  heattemp(curiyr) = inqlghp(11,iy) - inqlghp(icd,iy)
                  inqlghp(icr,iy) = inqlghp(icr,iy) + inqlghp(icd,iy) * inqlghp(icr,iy) / heattemp(curiyr)
               end if
            end do
            inqlghp(icd,iy) = 0.0
         end if
      end do


      do icd = 1,9
        qlgin(icd,iy) = inqlghp(icd,iy) + inqlgpf(icd,iy)   ! implement corrected INQLGHP into QLGIN (10-18-2013 PGR)
        write (IFEEDOUT,*) 'second regional check on inqlghp  =  ',inqlghp(icd,iy)
      end do
        
      
	  inqlghp(11,iy) = sum(inqlghp(1:9,iy))
      QLGIN(11,iy) = sum(qlgin(1:9,iy))

      write (IFEEDOUT,*) 'sum regions of inqlghp  =',sum(inqlghp(1:9,iy))
      write (IFEEDOUT,*) 'ethane from LFMM in MMbbl/d = ',icd,rfqngpl(10,curiyr,1)
      write (IFEEDOUT,*) 'LPG summary for year  ',curiyr
      write (IFEEDOUT,*) 'ethane','  pentanes+','  isobutane'
      write (IFEEDOUT,*) qetinpf(11,curiyr),qppinpf(11,curiyr),qisinpf(11,curiyr)
      write (IFEEDOUT,*) 'normal butane','  propane','  propylene'
      write (IFEEDOUT,*) qbuinpf(11,curiyr),qprinpf(11,curiyr),qprolenerf(11,curiyr)

      write (IFEEDOUT,*) 'check national feedstock total  = ',qetinpf(11,curiyr)+qppinpf(11,curiyr)+qisinpf(11,curiyr)+ &
         qbuinpf(11,curiyr)+qprinpf(11,curiyr)+qprolenerf(11,curiyr)
      write (IFEEDOUT,*) 'inferred heat and power for LPG','  LPG feedstock','  LPG total industrial'
      write (IFEEDOUT,*) inqlghp(11,iy),inqlgpf(11,iy),qlgin(11,iy)
      write (IFEEDOUT,*)
      write (IFEEDOUT,*)

! set total NGL variables
      do icd = 1,9
         qetin(icd,iy) = qetinpf(icd,iy) !+ qetrf(icd,iy)     ! Refinery LPG variables aren't being used, and always equal 0; NSK 9/26/2019
         qbuin(icd,iy) = qbuinpf(icd,iy) !+ qburf(icd,iy)
         qisin(icd,iy) = qisinpf(icd,iy) !+ qisrf(icd,iy)
         qppin(icd,iy) = qppinpf(icd,iy) !+ qpprf(icd,iy)
         
         IF (iy .gt. MSEDYR) Then
             qprin(icd,iy) = qprinpf(icd,iy) + inqlghp(icd,iy) !+ qprrf(icd,iy)
         END IF
      
     end do

     write (IFEEDOUT,*) 'FINAL HGL: for year ',iy+1989
     write (IFEEDOUT,*) 'FINAL HGL: ethane       = ',sum(qetin(1:9,iy))
     write (IFEEDOUT,*) 'FINAL HGL: ethane feed  = ',sum(qetinpf(1:9,iy))
     write (IFEEDOUT,*) 'FINAL HGL: propane H&P	 = ',sum(inqlghp(1:9,iy))
     write (IFEEDOUT,*) 'FINAL HGL: propane feed = ',sum(qprinpf(1:9,iy))
     write (IFEEDOUT,*) 'FINAL HGL: nbutane      = ',sum(qbuinpf(1:9,iy))
     write (IFEEDOUT,*) 'FINAL HGL: ibutane      = ',sum(qisinpf(1:9,iy))
     write (IFEEDOUT,*) 'FINAL HGL: pentanes+    = ',sum(qppinpf(1:9,iy))
     write (IFEEDOUT,*) 'FINAL HGL: propylene    = ',sum(qprolenerf(1:9,iy))
     write (IFEEDOUT,*) 'FINAL HGL: all HGL feed = ',qetinpf(11,iy)+qppinpf(11,iy)+qisinpf(11,iy)+ &
                                                     qbuinpf(11,iy)+qprinpf(11,iy)+qprolenerf(11,iy)
     write (IFEEDOUT,*) '-----------------------------------------------------------'
     write (IFEEDOUT,*)
	
!HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
! *** PGR - fill in hydrogen variable to send to LFMM ***
! this is the total merchant hydrogen amount sold to refiners in the U.S.
! it is based on the differnece of refiners' total hydrogen receipts (from
! PSA's Supply & Disposition). Units of hydrogen are in million barrels of (residual) fuel
! oil equivalent. This amount will grow with U.S. refinery diesel production

! historical values for merchant H2 in
! L:/mid/Industrial/AEO2014/hydrogen/H2 capacity input feedstock - gross addendum.xls
      hydrogen2ref(19) = 21.780
      hydrogen2ref(20) = 30.374
      hydrogen2ref(21) = 37.385
      hydrogen2ref(22) = 41.655
      hydrogen2ref(23) = 43.254 ! year 2012

! forecasted values for merchant hydrogen
! based on growth of refinery diesel production
! from last historical year (2012)
! should later replace "23" with last historical year index
      if (curiyr.gt.23) then
         hydrogen2ref(curiyr) = hydrogen2ref(23) * (rfprddiesel(11,curiyr) / rfprddiesel(11,23))
      end if
      write (IFEEDOUT,*) 'year and hydrogen production ',curiyr,hydrogen2ref(curiyr)
!HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH



! now that benchmarking and fixes have been accomplished,
! compute the resulting benchmark factors as derived.  Reassign
! the BENCH array.
! REVISE AND KEEP FOR NOW ... BENCHFAC IS USED IN AN OUTPUT FILE
! NOT YET REVISED
 ! BENCHFAC NO LONGER EXISTS.  CODE ELSEWHERE WHICH REFERENCES BENCHFAC WILL NEED TO BE REVISED
 !     do icr=1,NCENSREG
 !       BENCH( 1,ICR)=SumCDIV(QELIN(1,IY),icr)
 !       BENCH( 2,ICR)=SumCDIV(QNGIN(1,iy),icr)
 !       BENCH( 3,ICR)=SumCDIV(QCLIN(1,iy),icr)
 !       BENCH( 4,ICR)=SumCDIV(QMCIN(1,iy),icr)
 !       BENCH( 5,ICR)=SumCDIV(QCIIN(1,iy),icr)
 !       BENCH( 6,ICR)=SumCDIV(QRLIN(1,iy),icr)
 !       BENCH( 6,ICR)=SumCDIV(QRSIN(1,iy),icr)
 !       BENCH( 7,ICR)=SumCDIV(QDSIN(1,iy),icr)
 !       BENCH( 8,ICR)=SumCDIV(QLGIN(1,iy),icr)
 !       BENCH( 9,ICR)=SumCDIV(QMGIN(1,iy),icr)
 !       BENCH(10,ICR)=SumCDIV(QSGIN(1,iy),icr)
 !       BENCH(11,ICR)=SumCDIV(QPCIN(1,iy),icr)
 !       BENCH(12,ICR)=SumCDIV(QASIN(1,iy),icr)
 !       BENCH(13,ICR)=SumCDIV(QPFIN(1,iy),icr)
 !       BENCH(14,ICR)=SumCDIV(QKSIN(1,iy),icr)
 !       BENCH(15,ICR)=SumCDIV(QOTIN(1,iy),icr)
 !       BENCH(16,icr)=SumCDIV(QBMIN(1,iy),icr)
 !       BENCH(17,icr)=SumCDIV(QMSIN(1,iy),icr)
 !       do F17=1,NSEDSFL
 !         if(bmain(f17,icr).gt.0.) then
 !           benchfac(f17,icr)=bench(f17,icr)/bmain(f17,icr)
 !         endif
 !       enddo
 !     enddo
!  Summarize Benchmarking at US level
!  for indt.csv and console output (store in benchfac)
  !    do f17=1,nsedsfl
  !      benchfac(f17,5)=1.
  !      if(sum(bmain(f17,1:4)).ne.0.) then
  !        BENCHFAC(F17,5)=sum(BENCH(F17,1:4))/sum(BMAIN(F17,1:4))
  !      endif
  !    enddo
  !    if(prtdbgi.gt.1) then
  !      write(6,150) 'BM',curcalyr,'==========================================================='
  !      write(6,150) 'BM',curcalyr,'(Excludes Refineries)  Before     After    Factor     SEDS4'
  !      do F17=1,NSEDSFL
  !         write(6,151) curcalyr,sedsflname(f17), &
  !           sum(bmain(f17,1:4)),                 &
  !           sum(bench(f17,1:4)),                 &
  !           BENCHFAC(F17,5), &
  !           sum(seds4(f17,1:4))
  !      enddo
!150     format(a,i4,a)
!151     format('BM',i4,' ',a,2F10.1,F10.4,F10.1)
  !    endif

! separate the total electric into the three categories ***
! primary,shift,miscellaneous                           ***
! the shares are at the census region level             ***
! SUSAN ... NOT SURE WHAT THIS WHERE THIS ENDDO BELONGS ... COMMENTING OUT
!
!      enddo

! SUSAN ADD ... RECREATE BENCHFAC FOR THE OUTPUT FILE.  THIS SHOULD BE REVISED IN THE FUTURE
! BUT THE ALGORITHM FOR PRINTING OUT INDT.CSV IS CRYPTIC.

		DO ICR=1,5
			BENCHFAC(1,ICR) = BF(CURIYR,1,ICR)  ! ELECTRICITY
            BENCHFAC(2,ICR) = 0.0				! NATURAL GAS NEEDS WORK ... SET ZERO FOR NOW
			BENCHFAC(3,ICR) = BF(CURIYR,7,ICR)	! STEAM COAL
			BENCHFAC(4,ICR) = BF(CURIYR,8,ICR)	! MET COAL
			BENCHFAC(5,ICR) = BF(CURIYR,9,ICR)	! NET COKE IMPORTS
			BENCHFAC(6,ICR) = BF(CURIYR,10,ICR)	! RESID
			BENCHFAC(7,ICR) = BF(CURIYR,11,ICR)	! DISTILLATE
			BENCHFAC(8,ICR) = BF(CURIYR,13,ICR)	! LPG NEEDS WORK ... SET ZERO FOR NOW
			BENCHFAC(9,ICR) = BF(CURIYR,14,ICR)	! MOGAS
			BENCHFAC(10,ICR) = BF(CURIYR,15,ICR)	! STILL GAS
			BENCHFAC(11,ICR) = BF(CURIYR,16,ICR)	! PET COKE
			BENCHFAC(12,ICR) = BF(CURIYR,17,ICR)	! ASPHALT AND ROAD OIL
			BENCHFAC(13,ICR) = BF(CURIYR,19,ICR)	! PETRO CHEM FEEDSTOCK
			BENCHFAC(14,ICR) = BF(CURIYR,20,ICR)	! KEROSENE
			BENCHFAC(15,ICR) = BF(CURIYR,21,ICR)	! OTHER PETRO
			BENCHFAC(16,ICR) = RBF(CURIYR,2,ICR)	! BIOMASS
			BENCHFAC(17,ICR) = RBF(CURIYR,8,ICR)	! WASTE
		END DO



! BIFURCATION: split fuel into two categories:
! 1) fuel to be included in calculations of co2 emissions as covered in a CO2 limit (S,139, M-L Bill)
! 2) fuel outside a covered sector and to be excluded from CO2 emissions calculation
!
! By default, everything goes into category 1.


! initialization.  prevents unsightly accumulation on each nems iteration
     QE2NGIN(:,iy,:)=0.
     QE2CLIN(:,iy,:)=0.
     QE2MCIN(:,iy,:)=0.
     QE2MGIN(:,iy,:)=0.
     QE2DSIN(:,iy,:)=0.
     QE2KSIN(:,iy,:)=0.
     QE2LGIN(:,iy,:)=0.
     QE2RSIN(:,iy,:)=0.
     QE2PFIN(:,iy,:)=0.
     QE2SGIN(:,iy,:)=0.
     QE2PCIN(:,iy,:)=0.
     QE2ASIN(:,iy,:)=0.
     QE2OTIN(:,iy,:)=0.
     QE2CIIN(:,iy,:)=0.

     QE2NGIN(11,iy,1) = SUM(QNGIN(1:9,iy))    ! Natural Gas.  Industrial
     QE2CLIN(11,iy,1) = SUM(QCLIN(1:9,iy))    ! Steam Coal.  Industrial
     QE2MCIN(11,iy,1) = SUM(QMCIN(1:9,iy))    ! Metallurgical Coal.  Industrial
     QE2MGIN(11,iy,1) = SUM(QMGIN(1:9,iy))    ! Motor Gasoline.  Industrial
     QE2DSIN(11,iy,1) = SUM(QDSIN(1:9,iy))    ! Distillate.  Industrial
     QE2KSIN(11,iy,1) = SUM(QKSIN(1:9,iy))    ! Kerosene.  Industrial
     QE2LGIN(11,iy,1) = SUM(QLGIN(1:9,iy))    ! Liquid Petroleum Gases.  Industrial
     QE2RSIN(11,iy,1) = SUM(QRSIN(1:9,iy))    ! Residual Fuel.  Industrial
     QE2PFIN(11,iy,1) = SUM(QPFIN(1:9,iy))    ! Petrochemical Feedstocks.  Industrial
     QE2SGIN(11,iy,1) = SUM(QSGIN(1:9,iy))    ! Still Gas.  Industrial
     QE2PCIN(11,iy,1) = SUM(QPCIN(1:9,iy))    ! Petroleum Coke.  Industrial
     QE2ASIN(11,iy,1) = SUM(QASIN(1:9,iy))    ! Asphalt and Road Oil.  Industrial
     QE2OTIN(11,iy,1) = SUM(QOTIN(1:9,iy))    ! Other Petroleum.  Industrial
     QE2CIIN(11,iy,1) = SUM(QCIIN(1:9,iy))    ! Net Coal Coke Imports.  Industrial

! Sum the non-covered share of energy for each fossil fuel over the numind industries
     do indus=1,numind
       QE2NGIN(11,iy,2) = QE2NGIN(11,iy,2) + (1.-carbshr(indus)) * QtyByInd( 2,indus)
       QE2CLIN(11,iy,2) = QE2CLIN(11,iy,2) + (1.-carbshr(indus)) * QtyByInd( 3,indus)
       QE2MCIN(11,iy,2) = QE2MCIN(11,iy,2) + (1.-carbshr(indus)) * QtyByInd( 4,indus)
       QE2MGIN(11,iy,2) = QE2MGIN(11,iy,2) + (1.-carbshr(indus)) * QtyByInd( 9,indus)
       QE2DSIN(11,iy,2) = QE2DSIN(11,iy,2) + (1.-carbshr(indus)) * QtyByInd( 7,indus)
       QE2KSIN(11,iy,2) = QE2KSIN(11,iy,2) + (1.-carbshr(indus)) * QtyByInd(14,indus)
       QE2LGIN(11,iy,2) = QE2LGIN(11,iy,2) + (1.-carbshr(indus)) * QtyByInd( 8,indus)
       QE2RSIN(11,iy,2) = QE2RSIN(11,iy,2) + (1.-carbshr(indus)) * QtyByInd( 6,indus)
       QE2PFIN(11,iy,2) = QE2PFIN(11,iy,2) + (1.-carbshr(indus)) * QtyByInd(13,indus)
       QE2SGIN(11,iy,2) = QE2SGIN(11,iy,2) + (1.-carbshr(indus)) * QtyByInd(10,indus)
       QE2PCIN(11,iy,2) = QE2PCIN(11,iy,2) + (1.-carbshr(indus)) * QtyByInd(11,indus)
       QE2ASIN(11,iy,2) = QE2ASIN(11,iy,2) + (1.-carbshr(indus)) * QtyByInd(12,indus)
       QE2OTIN(11,iy,2) = QE2OTIN(11,iy,2) + (1.-carbshr(indus)) * QtyByInd(15,indus)
       QE2CIIN(11,iy,2) = QE2CIIN(11,iy,2) + (1.-carbshr(indus)) * QtyByInd( 5,indus)
     enddo

! Next, subtract the fuel not covered (category 2) from the total now in 1st category.
! afterwards, the total of the two should match and the fuels should be bifurcated along
! the policy's coverage assumptions.

     QE2NGIN(11,iy,1) = max(0.,QE2NGIN(11,iy,1) - QE2NGIN(11,iy,2))
     QE2CLIN(11,iy,1) = max(0.,QE2CLIN(11,iy,1) - QE2CLIN(11,iy,2))
     QE2MCIN(11,iy,1) = max(0.,QE2MCIN(11,iy,1) - QE2MCIN(11,iy,2))
     QE2MGIN(11,iy,1) = max(0.,QE2MGIN(11,iy,1) - QE2MGIN(11,iy,2))
     QE2DSIN(11,iy,1) = max(0.,QE2DSIN(11,iy,1) - QE2DSIN(11,iy,2))
     QE2KSIN(11,iy,1) = max(0.,QE2KSIN(11,iy,1) - QE2KSIN(11,iy,2))
     QE2LGIN(11,iy,1) = max(0.,QE2LGIN(11,iy,1) - QE2LGIN(11,iy,2))
     QE2RSIN(11,iy,1) = max(0.,QE2RSIN(11,iy,1) - QE2RSIN(11,iy,2))
     QE2PFIN(11,iy,1) = max(0.,QE2PFIN(11,iy,1) - QE2PFIN(11,iy,2))
     QE2SGIN(11,iy,1) = max(0.,QE2SGIN(11,iy,1) - QE2SGIN(11,iy,2))
     QE2PCIN(11,iy,1) = max(0.,QE2PCIN(11,iy,1) - QE2PCIN(11,iy,2))
     QE2ASIN(11,iy,1) = max(0.,QE2ASIN(11,iy,1) - QE2ASIN(11,iy,2))
     QE2OTIN(11,iy,1) = max(0.,QE2OTIN(11,iy,1) - QE2OTIN(11,iy,2))
     QE2CIIN(11,iy,1) = max(0.,QE2CIIN(11,iy,1) - QE2CIIN(11,iy,2))

      qelinp(1,iy)=qelin(1,iy)*xelinshr(1,1)
      qelinp(2,iy)=qelin(2,iy)*xelinshr(1,1)
      qelinp(3,iy)=qelin(3,iy)*xelinshr(1,2)
      qelinp(4,iy)=qelin(4,iy)*xelinshr(1,2)
      qelinp(5,iy)=qelin(5,iy)*xelinshr(1,2)
      qelinp(6,iy)=qelin(6,iy)*xelinshr(1,3)
      qelinp(7,iy)=qelin(7,iy)*xelinshr(1,3)
      qelinp(8,iy)=qelin(8,iy)*xelinshr(1,4)
      qelinp(9,iy)=qelin(9,iy)*xelinshr(1,4)
      qelins(1,iy)=qelin(1,iy)*xelinshr(2,1)
      qelins(2,iy)=qelin(2,iy)*xelinshr(2,1)
      qelins(3,iy)=qelin(3,iy)*xelinshr(2,2)
      qelins(4,iy)=qelin(4,iy)*xelinshr(2,2)
      qelins(5,iy)=qelin(5,iy)*xelinshr(2,2)
      qelins(6,iy)=qelin(6,iy)*xelinshr(2,3)
      qelins(7,iy)=qelin(7,iy)*xelinshr(2,3)
      qelins(8,iy)=qelin(8,iy)*xelinshr(2,4)
      qelins(9,iy)=qelin(9,iy)*xelinshr(2,4)
      qelinm(1,iy)=qelin(1,iy)*xelinshr(3,1)
      qelinm(2,iy)=qelin(2,iy)*xelinshr(3,1)
      qelinm(3,iy)=qelin(3,iy)*xelinshr(3,2)
      qelinm(4,iy)=qelin(4,iy)*xelinshr(3,2)
      qelinm(5,iy)=qelin(5,iy)*xelinshr(3,2)
      qelinm(6,iy)=qelin(6,iy)*xelinshr(3,3)
      qelinm(7,iy)=qelin(7,iy)*xelinshr(3,3)
      qelinm(8,iy)=qelin(8,iy)*xelinshr(3,4)
      qelinm(9,iy)=qelin(9,iy)*xelinshr(3,4)


! REVIEW .... OK ... THIS JUST FILLS IN HISTORY
! set AER history for LPG feedstock
      if (curcalyr.eq.sedslastyr) then
      do nyr = 1,16
         INQLGPF(11,nyr) = aerlpgfeedhistory(nyr)
         do icd = 1,9
! SUSAN CHANGED SEDS9 TO REFLECT NEW DEFINITION OF ARRAY

            INQLGPF(icd,nyr) = INQLGPF(11,nyr) * seds9(icd,13)/sum(seds9(1:9,13))
         end do
!         write (IFEEDOUT,*) iy,curcalyr,nyr,inqlgpf(11,nyr),sum(inqlgpf(1:9,nyr))
      end do
      end if

! REVIEW  AHHH THIS IS FOR FILLING IN HISTORY ... KEEP
! set AER history for NG feedstock
      if (curcalyr.eq.sedslastyr) then
      do nyr = 1,16
         INQNGPF(11,nyr) = aerngfeedhistory(nyr)
         do icd = 1,9
            INQNGPF(icd,nyr) = INQNGPF(11,nyr) * seds9(5,icd)/sum(seds9(5,1:9))  ! SUSAN CHANGED TO REFLECT NEW SEDS9 STRUCTURE
         end do
         write (IFEEDOUT,*) iy,curcalyr,nyr,"INQLGPF = ",inqlgpf(11,nyr),sum(inqlgpf(1:9,nyr))
      end do
      end if

! ***
!   get a us total for the 3 electricity groups
! ***
      qelinp(11,IY)=0.
      qelins(11,IY)=0.
      qelinm(11,IY)=0.
      DO ICD = 1,9
         qelinp(11,IY)= qelinp(11,iy) + qelinp(icd,iy)
         qelins(11,IY)= qelins(11,iy) + qelins(icd,iy)
         qelinm(11,IY)= qelinm(11,iy) + qelinm(icd,iy)
      ENDDO

!  adjust mining to add cogen fuel consumption
! KEEP FOR NOW BUT CODE SHOULD BE MOVED TO CONTAB WHEN CONTAB IS MOVED

      do icr=1,4
        MINECON(ixNG,icr,CURIYR)=MINECON(ixNG,icr,CURIYR)+SumCDIV(CGOGSQ(1,CURIYR,3),icr)
        MINECON(ixCL,icr,CURIYR)=MINECON(ixCL,icr,CURIYR)+SumCDIV(CGOGSQ(1,CURIYR,1),icr)
        MINECON(ixRF,icr,CURIYR)=MINECON(ixRF,icr,CURIYR)+SumCDIV(CGOGSQ(1,CURIYR,2),icr)
      enddo
      MINECON(ixNG,5,CURIYR)=MINECON(ixNG,5,CURIYR)+CGOGSQ(11,CURIYR,3)
      MINECON(ixCL,5,CURIYR)=MINECON(ixCL,5,CURIYR)+CGOGSQ(11,CURIYR,1)
      MINECON(ixRF,5,CURIYR)=MINECON(ixRF,5,CURIYR)+CGOGSQ(11,CURIYR,2)

! Drop mill waste into var for RFM ... KEEP
      DO ICR=1,4
         MWIN(ICR,IY)=TQRENW(2,ICR)
      ENDDO
 
! CREATE NATIONAL BENCHMARK FACTORS FOR FEEDSTOCKS FOR LAST BENCHMARKED YEAR.
		 IF (CURCALYR .LE. SEDSLASTYR + FEEDYEARS) THEN
		    INQNGPF(11,IY) = SUM(INQNGPF(1:9,IY))
			INQLGPF(11,IY) = SUM(INQLGPF(1:9,IY))         
            ngfeedcalibfact = inqngpf(11,IY) / BMAIN(5,5)
		    LPGFEEDCALIBFACT = INQLGPF(11,IY) / BMAIN(13,5)
		 END IF
! END CODE:
!******
991 FORMAT(3X,'WEXOG')

      RETURN
      END SUBROUTINE WEXOG

! SUSAN END PASTE NEW WEXOG



! *****************************************************************************
       SUBROUTINE IRSTEO
   use i_
      IMPLICIT NONE
      
      INTEGER IUNIT13,IYEAR,IC,SF,iyy,icd,ierr,icr,ifuel,idum1,idum2
      Real HGL_tot_SEDSlast, HGL_tot_STEO1, HGL_tot_STEO2, HGL_tot_STEO3
      
      CHARACTER*70 FUEL, label*11
      character*20 FUELNAME(22)
      character*20 RFUELNAME(22)
      
! OPEN AND READ FILE CONTAINING STEO History and Projections

      
!      FNAME='INDSTEO'
!      IUNIT13=FILE_MGR('O',FNAME,NEW)
!      NEW=.FALSE.
!      READ(IUNIT13,992)  ! SKIP THE FILE HEADER
!      DO SF=1,21
!        READ(IUNIT13,*,end=99,err=99) (STEOQ(IYEAR,SF),IYEAR=STEOLastYr-6,STEOLastYr)
!      ENDDO

      SF=0    ! Reinitialize counting integers
      IYEAR=0
      IC=0

!-------------------New STEO read-in (to replace indsteo.txt includes file)--------------

! Distillate (1)  

      STEOQ(STEOLastYr-2,1)=QSDSIN(11,MSEDYR)*(1+(INDDFTCBUS((STEOLastYr-2)-1990+1)-INDDFTCBUS((STEOLastYr-3)-1990+1)) &
          /INDDFTCBUS((STEOLastYr-3)-1990+1))                           ! Distillate (use STEO growth rate on last historical SEDS number)
      STEOQ(STEOLastYr-1,1)=STEOQ(STEOLastYr-2,1)*(1+(INDDFTCBUS((STEOLastYr-1)-1990+1)-INDDFTCBUS((STEOLastYr-2)-1990+1)) &
          /INDDFTCBUS((STEOLastYr-2)-1990+1))                           ! Distillate (use STEO growth rate on first STEO year's number)
      STEOQ(STEOLastYr,1)=STEOQ(STEOLastYr-1,1)*(1+(INDDFTCBUS((STEOLastYr)-1990+1)-INDDFTCBUS((STEOLastYr-1)-1990+1)) &
          /INDDFTCBUS((STEOLastYr-1)-1990+1))                           ! Distillate (use STEO growth rate on second STEO year's number)

          
 ! Residual fuel (2)    
      
      STEOQ(STEOLastYr-2,2)=QSRSIN(11,MSEDYR)*(1+(INDRFTCBUS((STEOLastYr-2)-1990+1)-INDRFTCBUS((STEOLastYr-3)-1990+1)) &
          /INDRFTCBUS((STEOLastYr-3)-1990+1))                                     ! Resid (use STEO growth rate on last historical SEDS number)
      STEOQ(STEOLastYr-1,2)=STEOQ(STEOLastYr-2,2)*(1+(INDRFTCBUS((STEOLastYr-1)-1990+1)-INDRFTCBUS((STEOLastYr-2)-1990+1)) &
          /INDRFTCBUS((STEOLastYr-2)-1990+1))                                     ! Resid (use STEO growth rate on first STEO year's number)
      STEOQ(STEOLastYr,2)=STEOQ(STEOLastYr-1,2)*(1+(INDRFTCBUS((STEOLastYr)-1990+1)-INDRFTCBUS((STEOLastYr-1)-1990+1)) &
          /INDRFTCBUS((STEOLastYr-1)-1990+1))                                     ! Resid (use STEO growth rate on second STEO year's number)
      
! HGL (3)         
! 100% of ethane/ethylene, propylene, butane/butylene, and natural gasoline are industrial according to the current NEMS set up (2/4/2020). Subtract
! commercial, residential, and transportation propane to get industrial total NSK 2/4/2020

      STEOQ(STEOLastYr-2,3)=INDETTCBUS(MSEDYR+1) + INDPRTCBUS(MSEDYR+1) + INDC4TCBUS(MSEDYR+1) + INDPPTCBUS(MSEDYR+1) &
                            - QPRCM(11,MSEDYR+1) - QPRRS(11,MSEDYR+1) - QPRTR(11,MSEDYR+1)                              ! First STEO year
      STEOQ(STEOLastYr-1,3)=INDETTCBUS(MSEDYR+2) + INDPRTCBUS(MSEDYR+2) + INDC4TCBUS(MSEDYR+2) + INDPPTCBUS(MSEDYR+2) &
                            - QPRCM(11,MSEDYR+2) - QPRRS(11,MSEDYR+2) - QPRTR(11,MSEDYR+2)                              ! Second STEO year
      STEOQ(STEOLastYr,3)=INDETTCBUS(MSEDYR+3) + INDPRTCBUS(MSEDYR+3) + INDC4TCBUS(MSEDYR+3) + INDPPTCBUS(MSEDYR+3) &
                            - QPRCM(11,MSEDYR+3) - QPRRS(11,MSEDYR+3) - QPRTR(11,MSEDYR+3)                              ! Third STEO year
          
          
! Mogas (4)      

      STEOQ(STEOLastYr-2,4)=QSMGIN(11,MSEDYR)*(1+(INDMGTCBUS((STEOLastYr-2)-1990+1)-INDMGTCBUS((STEOLastYr-3)-1990+1)) &
          /INDMGTCBUS((STEOLastYr-3)-1990+1))                                     ! Mogas (use STEO growth rate on last historical SEDS number)
      STEOQ(STEOLastYr-1,4)=STEOQ(STEOLastYr-2,4)*(1+(INDMGTCBUS((STEOLastYr-1)-1990+1)-INDMGTCBUS((STEOLastYr-2)-1990+1)) &
          /INDMGTCBUS((STEOLastYr-2)-1990+1))                                     ! Mogas (use STEO growth rate on first STEO year's number)
      STEOQ(STEOLastYr,4)=STEOQ(STEOLastYr-1,4)*(1+(INDMGTCBUS((STEOLastYr)-1990+1)-INDMGTCBUS((STEOLastYr-1)-1990+1)) &
          /INDMGTCBUS((STEOLastYr-1)-1990+1))                                     ! Mogas (use STEO growth rate on second STEO year's number)
      
          
! Lubes (8)
          
          STEOQ(STEOLastYr-2,8)=INDLUTCBUS(MSEDYR+1) - QLUTR(11,MSEDYR+1)       ! First STEO year; subtract out transportation lubes (QLUTR)
          STEOQ(STEOLastYr-1,8)=INDLUTCBUS(MSEDYR+2) - QLUTR(11,MSEDYR+2)       ! Second STEO year; subtract out transportation lubes (QLUTR)
          STEOQ(STEOLastYr,8)=INDLUTCBUS(MSEDYR+3) - QLUTR(11,MSEDYR+3)         ! Third STEO year; subtract out transportation lubes (QLUTR)
   
  
! Other Petroleum (12)
     
     STEOQ(STEOLastYr-2,12)=INDABTCBUS(MSEDYR+1) + INDUOTCBUS(MSEDYR+1) + INDMSTCBUS(MSEDYR+1) + INDSNTCBUS(MSEDYR+1) + &
                            INDWXTCBUS(MSEDYR+1) + (INDLUTCBUS(MSEDYR+1) - QLUTR(11,MSEDYR+1))      ! First STEO year; subtract out transportation lubes (QLUTR)
     STEOQ(STEOLastYr-1,12)=INDABTCBUS(MSEDYR+2) + INDUOTCBUS(MSEDYR+2) + INDMSTCBUS(MSEDYR+2) + INDSNTCBUS(MSEDYR+2) + &
                            INDWXTCBUS(MSEDYR+2) + (INDLUTCBUS(MSEDYR+2) - QLUTR(11,MSEDYR+2))      ! Second STEO year; subtract out transportation lubes (QLUTR)
     STEOQ(STEOLastYr,12)=INDABTCBUS(MSEDYR+3) + INDUOTCBUS(MSEDYR+3) + INDMSTCBUS(MSEDYR+3) + INDSNTCBUS(MSEDYR+3) + &
                            INDWXTCBUS(MSEDYR+3) + (INDLUTCBUS(MSEDYR+3) - QLUTR(11,MSEDYR+3))      ! Third STEO year; subtract out transportation lubes (QLUTR)
          
          
      
      DO IYEAR=STEOLastYr-6, STEOLastYr

          STEOQ(IYEAR,5) = INDFETCBUS(IYEAR-1990+1)                             ! Petrochemical feedstocks (not including HGL)
          STEOQ(IYEAR,6) = INDARTCBUS(IYEAR-1990+1)                             ! Asphalt and road oil
          STEOQ(IYEAR,7) = QSKSIN(11,MSEDYR)                                    ! Kerosene
          STEOQ(IYEAR,9) = INDPCTCBUS(IYEAR-1990+1)-INDPCEPCONB(IYEAR-1990+1)                             ! Petroleum coke (marketed and catalytic coke) is equal to total STEO coke minus
                                                                                ! the STEO series for power-sector petcoke consumption (though the NEMS electricity model ignores petcoke)
          STEOQ(IYEAR,13) = INDNGINX(IYEAR-1990+1)*INDNGNUKUS(IYEAR-1990+1)     ! Natural gas
          STEOQ(IYEAR,15) = INDCLYCBUS(IYEAR-1990+1)                            ! Steam coal
          STEOQ(IYEAR,16) = INDCLKCBUS(IYEAR-1990+1)                            ! Met coal
          STEOQ(IYEAR,17) = INDCCNIBUS(IYEAR-1990+1)                            ! Net coke coal imports
          STEOQ(IYEAR,18) = INDEXICPUS(IYEAR-1990+1)                            ! Electricity         
          STEOQ(IYEAR,19) = INDHVICBUS(IYEAR-1990+1) + INDHVCCBUS(IYEAR-1990+1) ! Hydro (includes commercial)         
          STEOQ(IYEAR,20) = INDWWICBUS(IYEAR-1990+1)                            ! Wood
          STEOQ(IYEAR,21) = INDOWICBUS(IYEAR-1990+1)                            ! Municipal solid waste
      ENDDO
      
!-----------------------------------------------------------------------------------------      

! Read Benchmark Factors (BMFs) to override if INDBMOVR=2
!     DO IC=1,3            ! Skip header/title for BMFs
!       READ(IUNIT13,992)
!     END DO

!     DO SF=1,17
!      READ(IUNIT13,*,IOSTAT=ierr) (BMFOVR(SF,IYEAR), IYEAR=2008,2009)
!      IF (ierr.ne.0 .and. SF.lt.17) WRITE(6,*) 'Error reading BMFOVR'
!     END DO

!      IUNIT13=FILE_MGR('C',FNAME,NEW)

	 DO IFUEL=1,22
	    DO ICR=1,4
         READ(IFACTIN,993) FUELNAME(IFUEL),IDUM1,IDUM2, HISTBF(ICURIYR:LASTYR,IFUEL,ICR)
	    END DO
	 END DO
     DO IFUEL=1,8
	   DO ICR=1,4
        READ(IFACTIN,993) RFUELNAME(IFUEL),IDUM1,IDUM2, RHISTBF(ICURIYR:LASTYR,IFUEL,ICR)
	   END DO
    END DO	
      

  992 FORMAT(A)
  993 FORMAT(A,2(1X,I3),<LASTYR-ICURIYR+1>(1X,F12.6))

      RETURN
! 99   write(6,*) 'Attn:  Error reading STEO'
!      return
      END SUBROUTINE IRSTEO

	  !XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!   IEDATA READS THE PRODUCTION AND MAIN ENERGY DATA FILE FOR
!     FOR EACH REGION OF EACH INDUSTRY IN THE INITIAL YEAR
!     DATA FILE: ENPROD
!     (REPLACES EXISTING PDATA AND EDATA)
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!
      SUBROUTINE IEDATA
   use i_
      IMPLICIT NONE

!****
!  DECLARE INTERNAL VARIABLES.
!****

      INTEGER IFLAG,NUMFMT,NLASTREG,IERR,ICOUNT,NUMREG, &
          LINDDIR,INDEX,NUMEIIND,IHEADER,ISTEPDEF,ICOGEN,INEIELAS, &
          IEISTEP,EIFLAG, NSTEP,IFUEL,IFL,IVINT,NFUELS,IFPX,IEQ, &
          ISTP,ICA,ICB,ILOOP
      REAL TOTSHR,BTEMP
      REAL TEMPVAR
!
      CHARACTER *200 ISTR
!
!   DEFINE NUMBER OF INDUSTRIES, FORMATS, ENERGY INTENSIVE INDUSTRIES
!      AND REGIONS
!
      PARAMETER (NUMFMT=9, NUMEIIND=7, NUMREG=4)
      CHARACTER*8 IFORMT(NUMFMT),EIIND(NUMEIIND), &
       ITAG,LTAGNAME

      INTEGER IREGCK(NUMREG)
!
!   USE DATA STATEMENTS TO DEFINE FILE FORMATS, INDUSTRIES, AND
!     ENERGY INTENSIVE INDUSTRIES.
!
      DATA IFORMT /'.HEADER ', &
                   '.STEPDEF', &
                   'BEU     ', &
                   'BSCBYP  ', &
                   'BSFUEL  ', &
                   'COGEN   ', &
                   'NEIELAS ', &
                   'STEPBYP ', &
                   'EISTEP'/
!
!

      DATA IREGCK/NUMREG*0/
!
      DATA EIIND /'07FOOD  ', '08PAPER ', '09B_CHEM', '10GLASS ', &
        '11CEMENT', '12STEEL ', '13ALUMNM'/
!
      integer only1/0/

       integer irecd/0/
!
!***
!  WRITE SUBROUTINE TRACE, IF ON.
!****

      IF(ISUBTR.EQ.1.AND.IOPEN.EQ.1.AND.LSTITER.EQ.1) &
        WRITE(IUNIT1,991)
      if(only1.eq.0) then
         only1=1
         INAMECK(:)='XYZ'
         INAME(:)= (/'01AGCROP', '02AGOTHR', '03COALMN', '04OILGAS', &
         '05METLMN', '06CONSTR', '07FOOD  ', '08PAPER ', '09B_CHEM', &
         '10GLASS ', '11CEMENT', '12STEEL ', '13ALUMNM', '14FABMET', &
         '15MACHIN', '16COMPUT', '17TRANEQ', '18ELECEQ', '19WOODPR', &
         '20PLASTI', '21BOMOTH'/)

         lindname=iname(1)
         nlastreg=1
      endif
      CALL IZEROOUT(ITAG,NLASTREG,ISTP,NSTEP,IEQ,IFPX,NFUELS, &
           IFUEL,IHEADER,ISTEPDEF,ICOGEN,INEIELAS,IEISTEP)

      call mecsbase ! read mecsbase updates for prodflows

!
      ICOUNT=1
!
      DO 10 ILOOP=1,5000
!
!   READ IN ONE DATA RECORD
!
      READ(IUNIT4,1,ERR=100,END=105,IOSTAT=IOS) INDNAME,INDREG,ITAG &
       ,ISTR
      irecd=irecd+1
!      write(iunit1,1111)irecd, indname,indreg,itag,istr
!1111   FORMAT(i5,1x,A8,1X,I8,1X,A8,1X,A200)
1     FORMAT(A8,1X,I8,1X,A8,1X,A200)
!
!   CHECK FOR CORRECT INDUSTRY NAME.  IF NOT, WRITE A MESSAGE AND
!      SKIP TO NEXT RECORD
!
      CALL ICHECK(IFLAG,NUMIND,INAME,INDNAME,INDEX)
      IF (IFLAG.EQ.0) THEN
        IF(PRTDBGI.GE.2) WRITE(6,2) INDNAME
2       FORMAT(1X,'SUB_IEDATA:  INDUSTRY NAME=',A8, &
                  ' NOT RECOGNIZED, SKIP RECORD')
        GO TO 10
      ENDIF
!
!   CHECK FOR ENERGY INTENSIVE INDUSTRY.  IF SO, SET EIFLAG=1
!
      IF(ICOUNT.EQ.1) THEN
        CALL ICHECK(EIFLAG,NUMEIIND,EIIND,INDNAME,INDEX)
      ENDIF
!
!   FILE SUBSECTIONS MUST BEGIN WITH A .HEADER RECORD.  ONLY ONE
!     WILL BE READ PER SUBSECTION
!
      if(icount.eq.1.and.itag.ne.'.HEADER ') then
        WRITE(6,4) INDNAME,INDREG,ITAG,'HAS INVALID FIRST RECORD; MUST BE .HEADER.  SKIP RECORD.'
4       FORMAT(1X,'SUB_IEDATA:  ',A8,' REGION',I3,', ',A8,1X,A)
        GO TO 10
       ENDIF
!
!   CHECK FOR VALID FILE FORMAT NAME.  IF NOT, WRITE A MESSAGE
!     AND SKIP TO NEXT RECORD
!
      CALL ICHECK(IFLAG,NUMFMT,IFORMT,ITAG,INDEX)
      IF(IFLAG.EQ.0) THEN
        WRITE(6,4) INDNAME,INDREG,ITAG, 'HAS INVALID FILE FORMAT.  SKIP RECORD.'
        GO TO 10
      ENDIF
!
!   IF REGION NUMBER OUT OF RANGE, WRITE A MESSAGE
!      AND SKIP TO NEXT RECORD
!
      IF(INDREG.LT.1.OR.INDREG.GT.NUMREG) THEN
        WRITE(6,4) INDNAME,INDREG,ITAG,'HAS INVALID REGION NUMBER.  SKIP RECORD.'
        GO TO 10
      ENDIF
!
!   WRITE FILE SUBSECTION DESCRIPTION TO PRINTER
!
      IF(ICOUNT.EQ.1) THEN
        IF(PRTDBGI.GE.2)WRITE(6,7) INDNAME, INDREG
7       FORMAT(1X,'SUB_IEDATA:  READING ENPROD INDUSTRY ' &
              ,A8,', REGION',I3)
      ENDIF
!

!
!   IF THIS IS A NEW INDUSTRY, CHECK IF ALL REGIONS WERE REPRESENTED
!     IN THE LAST INDUSTRY
!
       if (icount.gt.1) then
        IF(INDNAME.NE.LINDNAME) THEN
          DO J=1,NUMREG
            IF(IREGCK(J).NE.J)THEN
              WRITE(6,11) trim(LINDNAME),J
11            FORMAT(1X,'SUB_IEDATA WARNING: ',A,' REGION' &
                    ,I3,' IS MISSING')
            ENDIF
            IREGCK(J)=0          ! AFTER CHECKING, ZERO OUT
          ENDDO
        ENDIF
       endif
!
!    IF THIS IS A NEW REGION OR INDUSTRY, BACKSPACE THE FILE,
!       MAKE SURE THE FILE SUBSECTION HAD THE CORRECT COMPONENTS,
!       MODIFY THE PRODUCTIONS FLOWS TO REFLECT IMPORTS
!       AND EXPORTS, CALCULATE PRODUCTION THROUGHPUT FOR EACH STEP,
!       AND RETURN TO CALLING ROUTINE.
!

        IF((INDREG.NE.NLASTREG.OR.INDNAME.NE.LINDNAME).and.icount.gt.1) THEN
          BACKSPACE(IUNIT4)
          irecd=irecd-1
          INDREG = NLASTREG
          INDNAME = LINDNAME
!
          CALL IFINLCHECK(IFLAG,NLASTREG,IHEADER,ISTEPDEF,ICOGEN,EIFLAG,INEIELAS,IEISTEP)

          IF(IFLAG.GT.0)RETURN
!
          CALL IFINLCALC
          RETURN
        ENDIF


!
!   IF NO CHANGE IN INDUSTRY OR REGION, CALL THE APPROPRIATE READ
!     SUBROUTINE BASED ON THE VALUE OF THE FORMAT NAME
!
      IF(ITAG.EQ.'.HEADER ') THEN
        CALL IRHEADER(ISTR,TEMPVAR,IERR,IOS)
        IF(IERR.NE.1) IHEADER=IHEADER+1
        IF(IWDBG.EQ.1.AND.IOPEN.EQ.1) THEN
          IF(LSTITER.EQ.1) THEN
            WRITE(IUNIT1,8021) INDDIR
            WRITE(IUNIT1,8022) INDREG
          ENDIF
          WRITE(IUNIT1,992) IDVAL,PHDRAT
        ENDIF
        if(EIFLAG.eq.0) then
          !MPASTP=1                     ! 1 STEP FOR NEI INDUSTRY
          INDSTEPNAME(1)='N/A'         ! STEP NAME IS N/A
        endif
!
      ELSEIF(ITAG.EQ. 'BSCBYP  ') THEN
        CALL IRBSCBYP(ISTR,IOS,IERR)

      ELSEIF(ITAG.EQ.'STEPBYP ') THEN
        CALL IRSTEPBYP(ISTR,IOS,IERR,IFLAG)
        IF(IFLAG.EQ.0) GO TO 10      ! INVALID STEP NAME
!
      ENDIF
!
      IF(IERR.GT.0) GO TO 100          ! INDICATES A READ ERROR
!
!   STORE THE CURRENT REGION NUMBER, INCREMENT THE COUNT
!   OF VALID RECORDS IN THIS REGION AND STORE THE
!     INDUSTRY NAME, REGION NUMBER, AND TAG NAME
!
      IF(ICOUNT.EQ.1) THEN
        IREGCK(INDREG)=INDREG
      ENDIF
      ICOUNT=ICOUNT+1
      LINDNAME=INDNAME
      LINDDIR=INDDIR
      NLASTREG=INDREG
      LTAGNAME=ITAG
!
!
10    CONTINUE
!
      WRITE(6,99)
99    FORMAT(1X,'SUB_IEDATA ERROR:  LOOP INCREMENT EXCEEDED BEFORE ' &
            ,'EOF ENCOUNTERED.')
      RETURN
!
100   WRITE(6,101) IOS
      write(6,'(a,i5)') 'on record number :',irecd
101   FORMAT(1X,'SUB_IEDATA READ ERROR NUMBER ',I5)
      IF(IERR.GT.0) THEN
        WRITE(6,102) IFORMT(IERR)
102     FORMAT(1X,'SUB_IEDATA ERROR:  READING ENPROD FORMAT TYPE ' &
                ,A8)
      ENDIF
      RETURN
!
!   MODIFY PRODUCTION FLOWS FOR LAST REGION OF LAST INDUSTRY
!
105   CONTINUE
!

      CALL IFINLCHECK(IFLAG,NLASTREG,IHEADER,ISTEPDEF,ICOGEN,EIFLAG,INEIELAS,IEISTEP)

      IF(IFLAG.GT.0)RETURN
      CALL IFINLCALC
      
!
!   CHECK IF ALL REGIONS WERE REPRESENTED IN THE LAST INDUSTRY
!
      DO J=1,NUMREG
        IF(IREGCK(J).NE.J)THEN
          WRITE(6,11) LINDNAME,J
        ENDIF
      ENDDO
!
!   CHECK IF ALL INDUSTRIES ARE REPRESENTED IN THIS RUN
!
      DO I=1,NUMIND
        IF(INAMECK(I).NE.INAME(I)) THEN
          WRITE(6,106) INAME(I),INAMECK(I)
106       FORMAT(1X,'SUB_IEDATA INDUSTRY ',A,' NOT REPRESENTED. (' &
                ,A,')')
        ENDIF
      ENDDO
!
      IF(PRTDBGI.GE.2)WRITE(6,110)IOS
110   FORMAT(1X,'SUB_IEDATA:  ENPROD EOF ENCOUNTERED ',I5)
!
991   FORMAT(3X,'IEDATA')
8021  FORMAT(' INDUSTRY= ',I4)
8022  FORMAT(' REGION = ',I4)
992   FORMAT(3X,I2,F25.5)
      RETURN
      END SUBROUTINE IEDATA
!
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!
!   SUBROUTINE ICHECK CHECKS IF THE NAME ICHAR IS AN ELEMENT OF THE
!     ARRAY ICHARAR WITH HAS NUMVAR ELEMENTS.
!     IF FOUND, CHECK RETURNS A VALUE IFLAG=1 AND THE INDEX NUMBER.
!     OTHERWISE CHECK RETURNS A VALUE IFLAG=0.
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!
      SUBROUTINE ICHECK(IFLAG,NUMVAR,ICHARAR,ICHAR,INDEX)
   use i_
      IMPLICIT NONE
      INTEGER IFLAG,NUMVAR,ILOOP,INDEX
      CHARACTER*(*) ICHARAR(numvar)
      CHARACTER*(*) ICHAR
      IFLAG = 0
      ILOOP = 1
      DO WHILE(ILOOP.LE.NUMVAR.AND.IFLAG.EQ.0)
         IF(ICHAR.EQ.ICHARAR(ILOOP)) THEN
           IFLAG=1
           INDEX=ILOOP
         ENDIF
         ILOOP=ILOOP+1
      END DO
      RETURN
      END SUBROUTINE ICHECK
!
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!   SUBROUTINE IRHEADER READS THE .HEADER RECORD, THE FIRST
!    RECORD ON FILE FOR EACH REGION OF EACH INDUSTRY.
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!
      SUBROUTINE IRHEADER(ISTR,TEMPVAR,IERR,IOSi)
   use i_
      IMPLICIT NONE
      INTEGER IERR
      INTEGER*4 IOSi
      REAL TEMPVAR,dum


      CHARACTER *200 ISTR
      IERR=0
      READ(ISTR,*,ERR=100,IOSTAT=IOSi)INDDIR,IDVAL,PHDRAT,dum, &
           STEMCUR

	  if (INDDIR.eq.12) PRODX_Base(inddir,INDREG)=PHDRAT !store PHDRAT for iron and steel calculations - I think this is wrong - better to have direct output

!****
!  CALCULATE THE PHYSICAL UNITS BASED ON THE VALUE OF IDVAL
!****

      IF(IDVAL.EQ.1) THEN
        PHDRAT=PHDRAT/PRODVX        !RATIO OF PHY TO DOLLAR VALUE
        PRODX=PHDRAT*PRODVX

      ENDIF
      IF(IDVAL.EQ.2) THEN
        PRODX=PRODVX
      ENDIF
      PRODXLAG=PRODX

      RETURN
100   IERR=1
      RETURN
      END SUBROUTINE IRHEADER
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!    SUBROUTINE IRBSCBYP READS BYPRODUCT FUEL INFORMATION FOR
!      INDUSTRIES HAVING A BOILER/STEAM COMPONENT WHICH USE
!      BYPRODUCT FUELS (GENERALLY PRODUCED IN THAT INDUSTRY'S
!      PROCESS/ASSEMBLY COMPONENT).
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!
      SUBROUTINE IRBSCBYP(ISTR,IOSi,IERR)
   use i_
      IMPLICIT NONE
!
      CHARACTER *200 ISTR
      INTEGER*4 IOSi
      INTEGER IERR,IDUM,IFX
      REAL TEMP(2)
!
      IERR=0
!
!   IDUM IS THE FUEL SEQUENCE NUMBER--NOT ACTUALLY USED
!
      READ(ISTR,*,ERR=100,IOSTAT=IOSi) IDUM,IFX, &
       (TEMP(J),J=1,2)
!
!   COUNT BYPRODUCT FUELS, AND STORE FUEL NUMBER AND OTHER VALUES
!     IN THE APPROPRIATE POSITION IN THE ARRAYS
!
      IFSBYP=IFSBYP+1
      IFSLOCBY(IFSBYP)=IFX
      BYSINT(IFSBYP)  =TEMP(1)
      BYBSCSC(IFSBYP) =TEMP(2)
!
      RETURN
!
100   IERR=4
      RETURN
      END SUBROUTINE IRBSCBYP
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!   SUBROUTINE IRCOGEN READS COGENERATION DATA
!
      SUBROUTINE IRCOGEN
   use i_
      IMPLICIT NONE


      INTEGER IUNIT9,IUNIT11
      INTEGER IYEAR,IND,IFUEL
      real*8 tmpcap,tmpgen,tmpelf,tmpthr,tmpfac,tmpihr,tmpgrd

      integer doonce/0/
      save doonce
      character*25 adum
      real elecfuel(3)       ! temp to store fuel for elec portion of cogen


! READ history COGEN data on Capacity, generation, fuel consumption etc,
! Input file created by l:main/dsa/cogdat/cogcsv.f90
! read all industries and years first time through (rather than mess with trying
! to read on year/industry at a time

      if(doonce.eq.1) return
      doonce=1



      maxcogyr=0
      cogcap=0.
      coggen=0.
      cogelf=0.
      cogthr=0.

      FNAME='EXSTCAP'
      IUNIT9=FILE_MGR('O',FNAME,NEW)
      READ(IUNIT9,'()') ! skip first line
10    continue ! return here until end of file is reached
      read(iunit9,*,end=99) iyear,adum,ind,ir,adum,ifuel, &
        tmpcap,tmpgen,tmpelf,tmpthr,tmpfac,tmpihr,tmpgrd
!3 format(i4,',"',a15,'",',i3,',',i3,',"',a6,'",',i5,5(',',f14.0),',',f7.5,',',f9.0,f6.4)
      if(ind.le.numind) then
        iyear=iyear-baseyr+1
        cogcap(ir,iyear,ind,ifuel)=tmpcap/1000.
        coggen(ir,iyear,ind,ifuel)=tmpgen/1000000.
        cogelf(ir,iyear,ind,ifuel)=tmpelf/1000000.
        cogthr(ir,iyear,ind,ifuel)=tmpthr/1000000.
        coggrd(ir,iyear,ind,ifuel)=tmpgrd
        maxcogyr=max(maxcogyr,iyear)
      endif

      goto 10
99    continue

      iunit9=file_mgr('C',fname,new)

! OPEN FILE CONTAINING PLANNED CAPACITY VALUES

      FNAME='PLANCAP'
      IUNIT11=FILE_MGR('O',FNAME,NEW)
      READ(IUNIT11,'()') ! skip first line which is a header
   nadds=0
20 continue
      read(iunit11,*,end=98) iyear,adum,ind,ir,adum,ifuel, &
        tmpcap,tmpgen,tmpelf,tmpthr,tmpfac,tmpihr,tmpgrd
      nadds=nadds+1
      iadd=nadds
      cogadd(iadd).year=iyear-baseyr+1
      cogadd(iadd).industry=ind
      cogadd(iadd).censusdiv=ir
      cogadd(iadd).fuelind=ifuel
      cogadd(iadd).cap=tmpcap/1000. ! capacity
      cogadd(iadd).gen=tmpgen/1000000. ! generation
      cogadd(iadd).thr=tmpthr/1000000. ! useful thermal output (steam)
      cogadd(iadd).elc=tmpelf/1000000. ! fuel consumption for electricity only
      cogadd(iadd).grd=tmpgrd  ! grid share vary with AEO2012, prior to AEO2011 all have same grid share so no averaging needed
   goto 20
98 continue
!
      iunit11=file_mgr('C',fname,new)

      RETURN
      END SUBROUTINE IRCOGEN
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!    CALCULATE COGEN Grid and Own-use SHARES for current INDREG, INDDIR.
!    That is fill  GRDSHR_REG(indreg,inddir)
      SUBROUTINE CALCGSH
   use i_
      IMPLICIT NONE

      real curshare,newshare,goalshare
      real sumshr, sumgen

      INTEGER K,L,M,ifuel

!     Calculate total grid share for each region based on division values

! Establish the range of census divisions for the current region using an innovative approach
      L=indreg*2+indreg/4-1  ! obviously, L will be 1,3,5, and 8 for indreg=1..4
      M=indreg*2+indreg/3    !            M will be 2,4,7, and 9 for indreg=1..4


! determine GRDSHR_REG(INDREG,INDDIR), the average grid share across the fuels and census divisions
! for this industry in this census region
      sumshr=0.
      sumgen=0.
      do ir=l,m
        do ifuel=1,numflchp
          sumshr=sumshr + coggen(ir,curiyr,inddir,ifuel)*coggrd(ir,curiyr,inddir,ifuel)
          sumgen=sumgen + coggen(ir,curiyr,inddir,ifuel)
        enddo
      enddo

!      GRDSHR_REG(indreg,INDDIR) = 0.0

!      if(sumgen.gt.0.) then
!        grdshr_reg(indreg,inddir)=sumshr/sumgen
!      endif

!
! this won't work in current structure.  would have to be done using coggrd() detail
! because coggrd is used directly to sum up capacity and generation in indcgn.
!
!  have grdshr increase over time so that it attains a 20% value by 2020
!      if(iyr.gt.2001) then
!       if(inddir.eq.8) then
!        GoalShare=.35
!       else
!        GoalShare=.20
!       endif
!        CurShare=grdshr_reg(indreg,inddir)
!        NewShare=CurShare+(GoalShare-CurShare)* &
!         (float(iyr-2001)/float(2020-2001))
!        grdshr_reg(indreg,inddir)=NewShare
!      endif

      RETURN
      END SUBROUTINE CALCGSH

!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!    Initialize cogen arrays for the current year by
!   adding affects of planned additions to last years stock.
!    routine is called every year
!  KPE change:  coginit now has a parameter representing the region. When called
!    by most industries, will pass the regional parameter currently in force
!   when called by paper and steel (industries 8 & 12, respectively), will loop through  4  regions in ppis_bsc 
!   
!
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
      SUBROUTINE COGINIT(INDREGX)
   use i_
      IMPLICIT NONE

!  DECLARE INTERNAL VARIABLES

      INTEGER K,iyear,indi,ifuel
      INTEGER L,M
	  INTEGER INDREGX

      IF(INDREGX.EQ.1) THEN
        L = 1
        M = 2
      ELSE IF(INDREGX.EQ.2) THEN
        L = 3
        M = 4
      ELSE IF(INDREGX.EQ.3) THEN
        L = 5
        M = 7
      ELSE IF(INDREGX.EQ.4) THEN
        L = 8
        M = 9
      ENDIF

      YR = IYR - 1989

!   add in the planned units coming on line this year

      if(curiyr.gt.maxcogyr) then
        coggen(l:m,curiyr,inddir,:)=0.
        cogcap(l:m,curiyr,inddir,:)=0.
        cogthr(l:m,curiyr,inddir,:)=0.
        cogelf(l:m,curiyr,inddir,:)=0.

        do iadd=1,nadds
          iyear=cogadd(iadd).year
          indi=cogadd(iadd).industry
          i=cogadd(iadd).censusdiv
          if(iyear.eq.yr.and.indi.eq.inddir.and.I.GE.L.and.i.LE.M) then
            ifuel=cogadd(iadd).fuelind
            coggen(i,iyear,inddir,ifuel)=coggen(i,iyear,inddir,ifuel)+cogadd(iadd).gen ! generation
            cogcap(i,iyear,inddir,ifuel)=cogcap(i,iyear,inddir,ifuel)+cogadd(iadd).cap ! capacity
            cogthr(i,iyear,inddir,ifuel)=cogthr(i,iyear,inddir,ifuel)+cogadd(iadd).thr ! useful thermal output (steam)
            cogelf(i,iyear,inddir,ifuel)=cogelf(i,iyear,inddir,ifuel)+cogadd(iadd).elc ! fuel consumption for electricity only
!           coggrd(i,iyear,inddir,ifuel)=cogadd(iadd).grd  ! grid share--all will have same grid share so no averaging needed
          endif
        enddo

!     Add planned units to last year's stock to initialize
!     current year capacity/generation/fuel use etc.
!     In calgen, unplanned model builds
!     from Gas Turbine and biomass steam turbines will be added
        do i=l,m
			coggen(i,curiyr,inddir,1:numflchp)=coggen(i,curiyr-1,inddir,1:numflchp)+coggen(i,curiyr,inddir,1:numflchp)
			cogcap(i,curiyr,inddir,1:numflchp)=cogcap(i,curiyr-1,inddir,1:numflchp)+cogcap(i,curiyr,inddir,1:numflchp)
			cogthr(i,curiyr,inddir,1:numflchp)=cogthr(i,curiyr-1,inddir,1:numflchp)+cogthr(i,curiyr,inddir,1:numflchp)
			cogelf(i,curiyr,inddir,1:numflchp)=cogelf(i,curiyr-1,inddir,1:numflchp)+cogelf(i,curiyr,inddir,1:numflchp)
			coggrd(i,curiyr,inddir,1:numflchp)=coggrd(i,curiyr-1,inddir,1:numflchp)
		enddo
      endif

      RETURN
      END SUBROUTINE COGINIT
!========================================================================================
  subroutine addupcogs
     use i_
  implicit none
  integer incap  !switch to use ibyr2+1 weighted average or ibyr2+2 weighted average
  integer ifuel,jfuel,ncap
  integer imatch(numflchp+1)/1,2,3,5,5,6,5,5,5,5,7/  ! no electricity
  ! ! 1:coal,2:oil,3:ngas,4:hydro,5:geoth,6:msw,7:biomass,8:solar,9:othergas,10:electricity, 11:other (total?) !kpe change
  real totcogen !Paper Cogen Electricity Total
  real coggenshr(MNUMCR-2,numflchp+1) !gen paper census region shares
  real cogcapshr(MNUMCR-2,numflchp+1)  !cap paper census region shares
  real cogthrshr(MNUMCR-2,numflchp+1) !thr paper census region shares
  integer jx ! counting integer for testing purposes only --KPE



! sum cogen arrays around the array edges
! total fuel
  ! if ((inddir.ne.8).or.(inddir.ne.12)) then    ! these are already done in ppis_bsc for industries and year
	do ir=1,9
		do i=1,numind
		coggen(ir,curiyr,i,numflchp+1)=sum(coggen(ir,curiyr,i,1:numflchp))
		cogcap(ir,curiyr,i,numflchp+1)=sum(cogcap(ir,curiyr,i,1:numflchp))
		cogthr(ir,curiyr,i,numflchp+1)=sum(cogthr(ir,curiyr,i,1:numflchp))
		cogelf(ir,curiyr,i,numflchp+1)=sum(cogelf(ir,curiyr,i,1:numflchp))
		enddo
	enddo
! total regions
	do i=1,numind  
		do ifuel=1,numflchp+1
			coggen(11,curiyr,i,ifuel)=sum(coggen(1:9,curiyr,i,ifuel))
			cogcap(11,curiyr,i,ifuel)=sum(cogcap(1:9,curiyr,i,ifuel))
			cogelf(11,curiyr,i,ifuel)=sum(cogelf(1:9,curiyr,i,ifuel))
		enddo
	enddo
  ! endif  ! no steel or paper
! total industries
  do ifuel=1,numflchp+1
    do ir=1,11
      coggen(ir,curiyr,numind+1,ifuel)=sum(coggen(ir,curiyr,1:numind,ifuel))
      cogcap(ir,curiyr,numind+1,ifuel)=sum(cogcap(ir,curiyr,1:numind,ifuel))
      cogthr(ir,curiyr,numind+1,ifuel)=sum(cogthr(ir,curiyr,1:numind,ifuel))
      cogelf(ir,curiyr,numind+1,ifuel)=sum(cogelf(ir,curiyr,1:numind,ifuel))
    enddo
  enddo
! assign ftab global reporting variables (national).  collapse fuels from 11 to 7 using imatch
  do i=1,numind

    CHPINDCAP(1:7,i,curiyr)=0.
    CHPINDGEN(1:7,i,curiyr)=0.
    CHPINDSTM(1:7,i,curiyr)=0.
    CHPINDCON(1:7,i,curiyr)=0.

    do ifuel=1,numflchp+1
      jfuel=imatch(ifuel) ! imatch(numfl+1)/1,2,3,5,5,6,5,5,5,5,7/  ! KPE change; 8 is electric
		  CHPINDCAP(jfuel,i,curiyr)=CHPINDCAP(jfuel,i,curiyr)+cogcap(11,curiyr,i,ifuel)*.001 ! to GW
		  CHPINDGEN(jfuel,i,curiyr)=CHPINDGEN(jfuel,i,curiyr)+coggen(11,curiyr,i,ifuel)*.001 ! to bkwh
		  CHPINDSTM(jfuel,i,curiyr)=CHPINDSTM(jfuel,i,curiyr)+cogthr(11,curiyr,i,ifuel)
		  CHPINDCON(jfuel,i,curiyr)=CHPINDCON(jfuel,i,curiyr)+cogelf(11,curiyr,i,ifuel)+(cogthr(11,curiyr,i,ifuel)/.8)

    enddo
  enddo



! average the grid share across regions and fuels for each industry
  do i=1,numind
    chpgrdshr(i,curiyr)=0
    do ifuel=1,numflchp
      do ir=1,9
 ! was      if ((i.ne.8).or.(curcalyr.le.ibyr2)) chpgrdshr(i,curiyr)=chpgrdshr(i,curiyr) + coggen(ir,curiyr,i,ifuel)*coggrd(ir,curiyr,i,ifuel)
! no conditionals		if (curcalyr.le.ibyr2) chpgrdshr(i,curiyr)=chpgrdshr(i,curiyr) + coggen(ir,curiyr,i,ifuel)*coggrd(ir,curiyr,i,ifuel)
		chpgrdshr(i,curiyr)=chpgrdshr(i,curiyr) + coggen(ir,curiyr,i,ifuel)*coggrd(ir,curiyr,i,ifuel)
	  enddo
    enddo
    if(coggen(11,curiyr,i,numflchp+1).gt.0) then
     ! was if ((i.ne.8).or.(curcalyr.le.ibyr2))  chpgrdshr(i,curiyr)=chpgrdshr(i,curiyr)/coggen(11,curiyr,i,numflchp+1)
	 ! new now conditionals
	 chpgrdshr(i,curiyr)=chpgrdshr(i,curiyr)/coggen(11,curiyr,i,numflchp+1)
    endif
  enddo

  return
end subroutine addupcogs
!=================================================================================
subroutine mecsless860b
use i_
implicit none
! determine the balance of fuels for conventional boilers by subtracting the CHP fuel, as
! indicated by EIA Form 860b, from the MECS indirect fuels (or BSC boiler-steam-cogen fuel).
! This balance of fuels will be used as the starting fuel basis for applying boiler fuel elasticities

  integer if1,if2,ifuel, L, M
  real fuel860b, fuelmecs, diff, oilsum, sumfos, sumoil
  character*4 cfuel(4)/'coal','oil','ngas','othr'/
  fuel860b = 0.0
  fuelmecs = 0.0
  diff = 0.0
  do inddir=1,numind
    do indreg=1,4
! Establish the range of census divisions for the current region using an innovative approach
      L=indreg*2+indreg/4-1  ! obviously, L will be 1,3,5, and 8 for indreg=1..4
      M=indreg*2+indreg/3    !            M will be 2,4,7, and 9 for indreg=1..4

      do ifuel=1,4 ! coal, oil, ngas, other
        if1=ifuel
        if2=ifuel
        if(ifuel.eq.4) if2=6   ! to do sum of 860b's wood, other, msw

        fuel860b=sum(cogelf(L:M,curiyr,inddir,if1:if2))+ &
                 sum(cogthr(L:M,curiyr,inddir,if1:if2))/.8  ! .8 is form 860 assumed boiler efficiency
        CHPIBYR(inddir,indreg,ifuel)=fuel860b

        fuelmecs=BSCIBYR(inddir,indreg,ifuel)
        diff=fuelmecs-fuel860b

        if(diff.lt.0.0 .and. prtdbgi.ge.3 .and.inddir.ge.7) then
          write(6,'(a,2i3,1x,a,2f12.0)') &
          '860b CHP fuel exceeds MECS indirect fuel (inddir,indreg,ifuel,mecs,860b):', &
          inddir,indreg,cfuel(ifuel),fuelmecs,fuel860b
        endif

        diff=max(0.,diff)
        BOILIBYR(inddir,indreg,ifuel)=diff
        fuelmecs=fuel860b+diff ! reset "mecs" in case fuel is missing or 860b is greater
        BSCIBYR(inddir,indreg,ifuel)=fuelmecs
      enddo
! reshare BSCIBYR petroleum detail to revised oil total
      oilsum=sum(BSCIBYR(inddir,indreg,7:11)) ! sum of oil products
      if(oilsum.gt.0.) then
         BSCIBYR(inddir,indreg,7)=BSCIBYR(inddir,indreg,2)*(BSCIBYR(inddir,indreg,7)/oilsum) ! resid
         BSCIBYR(inddir,indreg,8)=BSCIBYR(inddir,indreg,2)*(BSCIBYR(inddir,indreg,8)/oilsum) ! dist
         BSCIBYR(inddir,indreg,9)=BSCIBYR(inddir,indreg,2)*(BSCIBYR(inddir,indreg,9)/oilsum) ! lpg
         BSCIBYR(inddir,indreg,10)=BSCIBYR(inddir,indreg,2)*(BSCIBYR(inddir,indreg,10)/oilsum) ! oth oil
         BSCIBYR(inddir,indreg,11)=BSCIBYR(inddir,indreg,2)*(BSCIBYR(inddir,indreg,11)/oilsum) ! petrol coke

         oilsum=sum(BSCIBYR(inddir,indreg,7:11)) ! sum of oil products

         BOILIBYR(inddir,indreg,7)=BOILIBYR(inddir,indreg,2)*(BSCIBYR(inddir,indreg,7)/oilsum)
         BOILIBYR(inddir,indreg,8)=BOILIBYR(inddir,indreg,2)*(BSCIBYR(inddir,indreg,8)/oilsum)
         BOILIBYR(inddir,indreg,9)=BOILIBYR(inddir,indreg,2)*(BSCIBYR(inddir,indreg,9)/oilsum)
         BOILIBYR(inddir,indreg,10)=BOILIBYR(inddir,indreg,2)*(BSCIBYR(inddir,indreg,10)/oilsum)
         BOILIBYR(inddir,indreg,11)=BOILIBYR(inddir,indreg,2)*(BSCIBYR(inddir,indreg,11)/oilsum)

         CHPIBYR(inddir,indreg,7)=CHPIBYR(inddir,indreg,2)*(BSCIBYR(inddir,indreg,7)/oilsum)
         CHPIBYR(inddir,indreg,8)=CHPIBYR(inddir,indreg,2)*(BSCIBYR(inddir,indreg,8)/oilsum)
         CHPIBYR(inddir,indreg,9)=CHPIBYR(inddir,indreg,2)*(BSCIBYR(inddir,indreg,9)/oilsum)
         CHPIBYR(inddir,indreg,10)=CHPIBYR(inddir,indreg,2)*(BSCIBYR(inddir,indreg,10)/oilsum)
         CHPIBYR(inddir,indreg,11)=CHPIBYR(inddir,indreg,2)*(BSCIBYR(inddir,indreg,11)/oilsum)

      else ! oil distribution missing because it was aggregated in 860b data
         BSCIBYR(inddir,indreg,7)=BSCIBYR(inddir,indreg,2)  !  put it all in resid
         BSCIBYR(inddir,indreg,8:11)=0.


         BOILIBYR(inddir,indreg,7)=BOILIBYR(inddir,indreg,2)  !  put it all in resid
         BOILIBYR(inddir,indreg,8:11)=0.

         CHPIBYR(inddir,indreg,7)=CHPIBYR(inddir,indreg,2)  !  put it all in resid
         CHPIBYR(inddir,indreg,8:11)=0.

      endif  ! double check index on below
      ! electricity has no chp, so boilibyr is a simple assignment
	  if (inddir.ge.7) BOILIBYR(inddir,indreg,12)=BSCIBYR(inddir,indreg,12)  ! electric boilers
	  ! if (ifuel.eq.12) 
    !  write(777,*) 'BOILBYR for electricity, industry, and region', inddir, indreg, BOILIBYR(inddir,indreg,12) 
	enddo
  enddo
! do sum somes
  do indreg=1,4
    do ifuel=1,12
      BSCIBYR(numind+1,indreg,ifuel)=sum(BSCIBYR(1:numind,indreg,ifuel))
    enddo
  enddo
  do inddir=1,numind+1
    do ifuel=1,12
      BSCIBYR(inddir,5,ifuel)=sum(BSCIBYR(inddir,1:4,ifuel))
    enddo
  enddo
  do indreg=1,4
    do ifuel=1,11
      CHPIBYR(numind+1,indreg,ifuel)=sum(CHPIBYR(1:numind,indreg,ifuel))
    enddo
  enddo
  do inddir=1,numind+1
    do ifuel=1,11
      CHPIBYR(inddir,5,ifuel)=sum(CHPIBYR(inddir,1:4,ifuel))
    enddo
  enddo
  do indreg=1,4
    do ifuel=1,12
      BOILIBYR(numind+1,indreg,ifuel)=sum(BOILIBYR(1:numind,indreg,ifuel))
    enddo
  enddo
  do inddir=1,numind+1
    do ifuel=1,12
      BOILIBYR(inddir,5,ifuel)=sum(BOILIBYR(inddir,1:4,ifuel))
    enddo
  enddo
! Reset Fossil boiler shares using nonCHP boiler fuel .  Warning: Fuel order inconsistent among
! these arrays.  See itlbshr.txt
!
  do inddir=1,numind
    do indreg=1,4
      sumfos=sum(BOILIBYR(inddir,indreg,1:3)) + BOILIBYR(inddir,indreg,12) ! last term is electric
      if(sumfos.gt.0) then
        tlbshr(inddir,indreg,5)=BOILIBYR(inddir,indreg,12)/sumfos ! electric inprogress
        tlbshr(inddir,indreg,2)=BOILIBYR(inddir,indreg,3)/sumfos !ngas
        tlbshr(inddir,indreg,3)=BOILIBYR(inddir,indreg,1)/sumfos !coal
        tlbshr(inddir,indreg,4)=BOILIBYR(inddir,indreg,2)/sumfos !oil
      else
        sumfos=sum(BSCIBYR(inddir,indreg,1:3)) + BSCIBYR(inddir,indreg,12)
        if(sumfos.gt.0) then
		  tlbshr(inddir,indreg,5)=BSCIBYR(inddir,indreg,12)/sumfos !electric
          tlbshr(inddir,indreg,2)=BSCIBYR(inddir,indreg,3)/sumfos !ngas
          tlbshr(inddir,indreg,3)=BSCIBYR(inddir,indreg,1)/sumfos !coal
          tlbshr(inddir,indreg,4)=BSCIBYR(inddir,indreg,2)/sumfos !oil
        endif
      endif
    enddo
  enddo
  if(prtdbgi.eq.3) then
! write out in approximate same layout as input file itlbshr.txt'
    write(6,'(a)') 'Revised base year BSC fuel use after Form 860b adjustment'
    write(6,'(a)') 'IND REG    Resid     Dist     ngas      LPG     coal    other    oth pet    pet coke   electric    oil-tot    total'
    do inddir=1,numind+1
      write(6,*)
      do indreg=1,5
        write(6,'(2i3,11f9.2)') inddir,indreg, &
         BSCIBYR(inddir,indreg,7), &  ! resid
         BSCIBYR(inddir,indreg,8), &  ! disti
         BSCIBYR(inddir,indreg,3), &  ! ngas
         BSCIBYR(inddir,indreg,9), &  ! LPG
         BSCIBYR(inddir,indreg,1), &  ! coal
         BSCIBYR(inddir,indreg,4), &  ! other
         BSCIBYR(inddir,indreg,10), &  ! oil oth
         BSCIBYR(inddir,indreg,11), &  ! petrol coke
         BSCIBYR(inddir,indreg,12), &  ! electricity--new for AEO2023--this prints out OK here
         BSCIBYR(inddir,indreg,2), &  ! oil-tot
         sum(BSCIBYR(inddir,indreg,1:4))
      enddo
    enddo

! write summary of 860 and nonCHP boiler fuel
    write(6,'(a)') 'CHP fuel use after MECS-based oil product sharing'
    write(6,'(a)') 'IND REG    Resid     Dist     ngas      LPG     coal    other    oth pet    pet coke   oil-tot   total'
    do inddir=1,numind+1
      write(6,*)
      do indreg=1,5
        write(6,'(2i3,10f9.2)') inddir,indreg, &
         CHPIBYR(inddir,indreg,7), &  ! resid
         CHPIBYR(inddir,indreg,8), &  ! disti
         CHPIBYR(inddir,indreg,3), &  ! ngas
         CHPIBYR(inddir,indreg,9), &  ! LPG
         CHPIBYR(inddir,indreg,1), &  ! coal
         CHPIBYR(inddir,indreg,4), &  ! other
         CHPIBYR(inddir,indreg,10), &  ! oil oth
         CHPIBYR(inddir,indreg,11), &  ! petrol coke
         CHPIBYR(inddir,indreg,2), &  ! oil-tot
         sum(CHPIBYR(inddir,indreg,1:4)) ! total
      enddo
    enddo
    write(6,'(a)') 'nonCHP fuel use after MECS-860b adjustment'
    write(6,'(a)') 'IND REG    Resid     Dist     ngas      LPG     coal    other    oth pet    pet coke   oil-tot  electric  total',&
  '  %ngas  %coal   %oil'  
    do inddir=1,numind+1
      write(6,*)
      do indreg=1,5
        write(6,'(2i3,10f9.2\)') inddir,indreg, &
         BOILIBYR(inddir,indreg,7), &  ! resid
         BOILIBYR(inddir,indreg,8), &  ! disti
         BOILIBYR(inddir,indreg,3), &  ! ngas
         BOILIBYR(inddir,indreg,9), &  ! LPG
         BOILIBYR(inddir,indreg,1), &  ! coal
         BOILIBYR(inddir,indreg,4), &  ! other
         BOILIBYR(inddir,indreg,10), &  ! oil oth
         BOILIBYR(inddir,indreg,11), &  ! petrol coke
         BOILIBYR(inddir,indreg,2), &  ! oil-tot
		 BOILIBYR(inddir,indreg,12), &  ! electric--this is OK & nonzero
         sum(BOILIBYR(inddir,indreg,1:4))   ! total
         if(inddir.le.numind.and.indreg.le.4) then
           write(6,'(3f7.4)') (tlbshr(inddir,indreg,ifuel),ifuel=2,4)  ! boiler fuel shares
         else
           write(6,*)
         endif
      enddo
    enddo

  endif

  return
end subroutine mecsless860b
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!   SUBROUTINE IRSTEPBYP READS BYPRODUCT DATA PER PROCESS/ASSEMBLY
!     STEP IF THE INDUSTRY PRODUCES BYPRODUCTS IN THAT COMPONENT.
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!
      SUBROUTINE IRSTEPBYP(ISTR,IOSi,IERR,IFLAG)
   use i_
      IMPLICIT NONE
!
      CHARACTER*200 ISTR,ISTR2
      CHARACTER*8 TNAME, ISTPN(30)
      INTEGER*4 IOSi
      INTEGER IFL,IERR,IDUM,IFX,ISTP,IFLAG
      REAL TEMP(4)
!
      IERR=0
!
!   FIRST READ IS FORMATTED TO READ CHARACTER DATA
!
      READ(ISTR,1,ERR=100,IOSTAT=IOSi) TNAME,ISTR2
1     FORMAT(A8,1X,A191)
!
!   SECOND READ IS UNFORMATTED; IDUM IS THE SEQUENCE NUMBER--NOT USED
!
      READ(ISTR2,*,ERR=100,IOSTAT=IOSi) IDUM,IFX, &
       (TEMP(J),J=1,4)
!
!   ASSIGN THE VALUES IN INDSTEPNAME TO AN 8 CHARACTER ARRAY,
!     CHECK FOR A VALID STEP NAME, AND FIND THE STEP NUMBER
!
      DO J=1,MPASTP
      ISTPN(J)=INDSTEPNAME(J)
      ENDDO
!
      CALL ICHECK(IFLAG,MPASTP,ISTPN,TNAME,ISTP)
      IF(IFLAG.EQ.0) THEN                   ! INVALID STEP NAME
        WRITE(6,5) INDNAME, TNAME
5       FORMAT(1X,'SUB_IRSTEPBYP WARNING:  ',A8,' HAS NO STEP ' &
               ,A8,' SKIP RECORD')
        RETURN
      ENDIF
!
!   COUNT FUELS FOR STEP ISTP, STORE FUEL NUMBER AND OTHER VALUES
!     IN THE APPROPRIATE POSITION OF THE ARRAYS.
!
      IFBYP(ISTP)=IFBYP(ISTP)+1
      IFL=IFBYP(ISTP)
      IFLOCBY(IFL,ISTP)=IFX
!
      BYPINT(1,IFL,ISTP)=TEMP(1)
      BYPCSC(1,IFL,ISTP)=TEMP(2)
!
!  SET VINTAGE 2 VALUES EQUAL TO VINTAGE 3 VALUES
!
      DO J=2,3
        BYPINT(J,IFL,ISTP)=TEMP(3)
        BYPCSC(J,IFL,ISTP)=TEMP(4)
      ENDDO
!
      DO J=1,3
        BYPINTLAG(J,IFL,ISTP)=BYPINT(J,IFL,ISTP)
      ENDDO
      RETURN
!
100   IERR=8
!
      RETURN
      END SUBROUTINE IRSTEPBYP
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!   SUBROUTINE IFINLCHECK CHECKS FOR 1 .HEADER RECORD AND THE CORRECT
!     NUMBER OF COGEN RECORDS FOR
!     EACH REGION OF EACH INDUSTRY AND STORES THE INDUSTRY NAME.
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!
      SUBROUTINE IFINLCHECK(IFLAG,NREG,IHEADER,ISTEPDEF,ICOGEN,EIFLAG,INEIELAS,IEISTEP)
   use i_

      IMPLICIT NONE
      INTEGER IFLAG,NREG,IHEADER,ISTEPDEF, &
        ICOGEN,INEIELAS,IEISTEP, &
        ITMP,EIFLAG

!
      IFLAG=0
!
!   MUST BE ONE AND ONLY ONE .HEADER RECORD PER FILE SUBSECTION
!
      IF(IHEADER.NE.1)THEN
        IFLAG=IFLAG+1
        WRITE(6,1) INDNAME,NREG,IHEADER
      ENDIF
!
!   NO MORE THAN ONE COGEN RECORD PER FILE SUBSECTION
!
      IF(ICOGEN.GT.1) THEN
        IFLAG=IFLAG+1
        WRITE(6,3) INDNAME,NREG,ICOGEN
      ENDIF
      IF(IFLAG.NE.0) WRITE(6,6)INDNAME,NREG,IFLAG
      IF(IFLAG.EQ.0) INAMECK(INDDIR)=INDNAME
!
1     FORMAT(1X,'SUB_IFINLCHECK ERROR:  ',A,' REGION ' &
             ,I3,' HAS ',I3,' .HEADER')
3     FORMAT(1X,'SUB_IFINLCHECK ERROR:  ',A,' REGION ' &
             ,I3,' HAS ',I3,' COGEN,', &
             ' SHOULD HAVE 0 OR 1')
6     FORMAT(1X,'SUB_IFINLCHECK NOTE:  ',A,' REGION ' &
             ,I3,' HAS',I3,' ERROR(S) AS ', &
             'INDICATED ABOVE.  CORRECT AND RE-EXECUTE')
!
      RETURN
      END SUBROUTINE IFINLCHECK
!
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!   SUBROUTINE IFINLCALC CALCULATES SELECTED VALUES AT THE END OF
!     REGIONAL DATA FOR EACH INDUSTRY.
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!
      SUBROUTINE IFINLCALC
   use i_
      IMPLICIT NONE
!
!   DECLARE INTERNAL VARIABLES
!
      INTEGER IS,IX,IZ,IC
      REAL PRODSUM(30,maxlinks),BTEMP
!
!
!****
!  THE PRODUCTION THROUGHPUT FOR EACH STEP IS CALCULATED.
!****
!
 


      
      DO 100 IS=1,MPASTP
        PRODCUR(4,IS)=0.0
        DO 85 IC=1,NTMAX(IS)
          IF(IPASTP(IS,IC).EQ.0) THEN
            PRODSUM(IS,IC)=PRODFLOW(1,IS,IC)*PRODX
          ELSE
            PRODSUM(IS,IC)=PRODFLOW(1,IS,IC)* &
                            PRODCUR(4,IPASTP(IS,IC))
          ENDIF
          PRODCUR(4,IS)=PRODCUR(4,IS)+PRODSUM(IS,IC)
 85   CONTINUE
      PRODCUR(1,IS)=PRODCUR(4,IS)
  100 CONTINUE
  
!
!   COMPUTE THE SHARE OF TOTAL FUEL CONSUMPTION FOR EACH FUEL
!
      BTEMP=0.0
      DO IS=1,IFSMAX
        BTEMP=BTEMP+BSSHR(IS)
      ENDDO
      if(bsshr(is).gt.0.) then
        DO IS=1,IFSMAX
          BSSHR(IS)=BSSHR(IS)/BTEMP
        ENDDO
      endif
      RETURN
      END SUBROUTINE IFINLCALC
!
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!   SUBROUTINE IZEROOUT INITIALIZES VARIABLES FOR EACH REGION
!     OF EACH INDUSTRY.  VARIABLES ARE INITIALIZED TO BLANK,
!     ZERO, OR ONE.
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!
      SUBROUTINE IZEROOUT(ITAG,NLASTREG,ISTP,NSTEP,IEQ,IFPX,NFUELS, &
          IFUEL,IHEADER,ISTEPDEF,ICOGEN,INEIELAS,IEISTEP)
   use i_
      IMPLICIT NONE
!
!   DECLARE LOCAL VARIABLES
!
      INTEGER NLASTREG,ISTP,NSTEP,IEQ,IFPX,NFUELS,IFUEL,K,L, &
         IHEADER,ISTEPDEF,ICOGEN,INEIELAS,IEISTEP
      CHARACTER *8 ITAG
!
!   INITIALIZE VARIABLES TO ZERO, BLANK, OR ONE AS APPROPRIATE
!
      INDNAME= ' '
      ITAG=    ' '
      IDVAL=   0
      PHDRAT=  0.0
      STEMCUR= 0.0
      MPASTP = 0
      ISTP=    0
      NSTEP   =0
      IEQ     =0
      IFPX    =0
      NFUELS  =0
      IFUEL   =0
      IHEADER =0
      ISTEPDEF=0
      ICOGEN  =0
      INEIELAS=0
      IEISTEP =0
      IFSMAX  =0
      IFSBYP  =0
!
      NTMAX(:)=0
      PRODRETR(:)=0.0
      INDSTEPNAME(:)='        '
      IFMAX(:)=0
      IFBYP(:)=0
      IPASTP(:,:)=0
      PRODFLOW(:,:,:)=0.0
      ENPINT(:,:,:)=0.0
      EINTER(:,:,:)=0.0
      BCSC(:,:,:)=0.0
      BYPINT(:,:,:)=0.0
      BYPCSC(:,:,:)=0.0
      IFSLOC(:)=0
      BSSHR(:)=0.0
      IFSLOCBY(:)=0
      BYSINT(:)=0.0
      BYBSCSC(:)=0.0
      IFLOC(:,:)=0
	  PAPER_BLIQ = 0.0
	  PAPER_BLIQQ = 0.0
	  sumprodcur(:,:) = 0.0
	  PAPER_STEAM_GRS(:,:) = 0.0 
	  PP_STEAM_Cogen(:) = 1.0
	  PP_Steam_Boiler(:) = 1.0
	  PP_ElecGen(:) = 1.0
      !IS_tot_energy_use(:,:) = 0.0

      RETURN
      END SUBROUTINE IZEROOUT
!
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!  THIS SUBROUTINE STORES THE data for one industry and region
      SUBROUTINE WRBIN
   use i_
      IMPLICIT NONE
! Copy the data to the industry/region buffer

      COPYBUF(INDREG,INDDIR).INDMAX     = INDMAX
      COPYBUF(INDREG,INDDIR).ENPMQTY    = ENPMQTY
      COPYBUF(INDREG,INDDIR).ENPIQTY    = ENPIQTY
      COPYBUF(INDREG,INDDIR).ENPRQTY    = ENPRQTY
      COPYBUF(INDREG,INDDIR).PRODX      = PRODX
      COPYBUF(INDREG,INDDIR).PRODXLAG   = PRODXLAG
      COPYBUF(INDREG,INDDIR).PRODVX     = PRODVX
      COPYBUF(INDREG,INDDIR).PRODVXLAG  = PRODVXLAG
      COPYBUF(INDREG,INDDIR).EMPLX      = EMPLX
      COPYBUF(INDREG,INDDIR).EMPLXLAG   = EMPLXLAG
      COPYBUF(INDREG,INDDIR).ENBINT     = ENBINT
      COPYBUF(INDREG,INDDIR).ENBQTY     = ENBQTY
      COPYBUF(INDREG,INDDIR).ENSQTY     = ENSQTY
      COPYBUF(INDREG,INDDIR).BSSHR      = BSSHR
      COPYBUF(INDREG,INDDIR).BSSHRLAG   = BSSHRLAG
      COPYBUF(INDREG,INDDIR).STEMCUR    = STEMCUR
      COPYBUF(INDREG,INDDIR).STEMCURLAG = STEMCURLAG
      COPYBUF(INDREG,INDDIR).COGSTEAM   = COGSTEAM
      COPYBUF(INDREG,INDDIR).NONCOGSTEAM=NONCOGSTEAM
      COPYBUF(INDREG,INDDIR).BIOSTEAM   = BIOSTEAM
      COPYBUF(INDREG,INDDIR).NONCOGFOSSTEAM=NONCOGFOSSTEAM
      COPYBUF(INDREG,INDDIR).FUELFOSSTEAM=FUELFOSSTEAM
      COPYBUF(INDREG,INDDIR).COGBOILFUEL= COGBOILFUEL
      COPYBUF(INDREG,INDDIR).ELOWN      = ELOWN
      COPYBUF(INDREG,INDDIR).ELSALE     = ELSALE
      COPYBUF(INDREG,INDDIR).GENFUEL    = GENFUEL
      COPYBUF(INDREG,INDDIR).RPTGEN     = RPTGEN
      COPYBUF(INDREG,INDDIR).RPTCAP     = RPTCAP
      COPYBUF(INDREG,INDDIR).QTYMAIN    = QTYMAIN(:,INDREG)
      COPYBUF(INDREG,INDDIR).QTYINTR    = QTYINTR(:,INDREG)
      COPYBUF(INDREG,INDDIR).QTYRENW    = QTYRENW(:,INDREG)
      COPYBUF(INDREG,INDDIR).BYPBSCM    = BYPBSCM
      COPYBUF(INDREG,INDDIR).BYPBSCI    = BYPBSCI
      COPYBUF(INDREG,INDDIR).BYPBSCR    = BYPBSCR
      COPYBUF(INDREG,INDDIR).PRODRETR   = PRODRETR
      COPYBUF(INDREG,INDDIR).PRODCUR    = PRODCUR
      COPYBUF(INDREG,INDDIR).PRODLAG    = PRODLAG
      COPYBUF(INDREG,INDDIR).PRODFLOW   = PRODFLOW
      COPYBUF(INDREG,INDDIR).ENPINT     = ENPINT
      COPYBUF(INDREG,INDDIR).ENPINTLAG  = ENPINTLAG
      COPYBUF(INDREG,INDDIR).ENPQTY     = ENPQTY
      COPYBUF(INDREG,INDDIR).BYPINT     = BYPINT
      COPYBUF(INDREG,INDDIR).BYPINTLAG  = BYPINTLAG
      COPYBUF(INDREG,INDDIR).BYPQTY     = BYPQTY
      COPYBUF(INDREG,INDDIR).IDLCAP     = IDLCAP
      COPYBUF(INDREG,INDDIR).IDLCAPLAG  = IDLCAPLAG
      COPYBUF(INDREG,INDDIR).INDMAX     = INDMAX
      COPYBUF(INDREG,INDDIR).MPASTP     = MPASTP
      COPYBUF(INDREG,INDDIR).PHDRAT     = PHDRAT
      COPYBUF(INDREG,INDDIR).INDDIR     = INDDIR
      COPYBUF(INDREG,INDDIR).IDVAL      = IDVAL
      COPYBUF(INDREG,INDDIR).IFSMAX     = IFSMAX
      COPYBUF(INDREG,INDDIR).IFSLOC     = IFSLOC
      COPYBUF(INDREG,INDDIR).IFSBYP     = IFSBYP
      COPYBUF(INDREG,INDDIR).IFSLOCBY   = IFSLOCBY
      COPYBUF(INDREG,INDDIR).NTMAX      = NTMAX
      COPYBUF(INDREG,INDDIR).IFMAX      = IFMAX
      COPYBUF(INDREG,INDDIR).IPASTP     = IPASTP
      COPYBUF(INDREG,INDDIR).IFLOC      = IFLOC
      COPYBUF(INDREG,INDDIR).ITYPE      = ITYPE
      COPYBUF(INDREG,INDDIR).BCSC       = BCSC
      COPYBUF(INDREG,INDDIR).IFBYP      = IFBYP
      COPYBUF(INDREG,INDDIR).IFLOCBY    = IFLOCBY
      COPYBUF(INDREG,INDDIR).BYPCSC     = BYPCSC
      COPYBUF(INDREG,INDDIR).EINTER     = EINTER
      COPYBUF(INDREG,INDDIR).NumRptGrps     = NumRptGrps
      COPYBUF(INDREG,INDDIR).NumRptGrpSteps = NumRptGrpSteps
      COPYBUF(INDREG,INDDIR).RptGrpSteps    = RptGrpSteps
      COPYBUF(INDREG,INDDIR).RptGrpNames    = RptGrpNames
      COPYBUF(INDREG,INDDIR).RptGrpSName    = RptGrpSName
      COPYBUF(INDREG,INDDIR).INDNAME    = INDNAME
      COPYBUF(INDREG,INDDIR).INDSTEPNAME= INDSTEPNAME

      RETURN
      END SUBROUTINE WRBIN
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
! refresh the data for a given region and industry
!
      SUBROUTINE RDBIN
   use i_
      IMPLICIT NONE
      if(indreg.eq.0.or.inddir.eq.0) then
        write(6,*) ' indreg,inddir=',indreg,inddir
      endif
 ! Copy the data from the industry/region buffer to "local" variables

      INDMAX           = COPYBUF(INDREG,INDDIR).INDMAX
      ENPMQTY          = COPYBUF(INDREG,INDDIR).ENPMQTY
      ENPIQTY          = COPYBUF(INDREG,INDDIR).ENPIQTY
      ENPRQTY          = COPYBUF(INDREG,INDDIR).ENPRQTY
      PRODX            = COPYBUF(INDREG,INDDIR).PRODX
      PRODXLAG         = COPYBUF(INDREG,INDDIR).PRODXLAG
      PRODVX           = COPYBUF(INDREG,INDDIR).PRODVX
      PRODVXLAG        = COPYBUF(INDREG,INDDIR).PRODVXLAG
      EMPLX            = COPYBUF(INDREG,INDDIR).EMPLX
      EMPLXLAG         = COPYBUF(INDREG,INDDIR).EMPLXLAG
      ENBINT           = COPYBUF(INDREG,INDDIR).ENBINT
      ENBQTY           = COPYBUF(INDREG,INDDIR).ENBQTY
      ENSQTY           = COPYBUF(INDREG,INDDIR).ENSQTY
      BSSHR            = COPYBUF(INDREG,INDDIR).BSSHR
      BSSHRLAG         = COPYBUF(INDREG,INDDIR).BSSHRLAG
      STEMCUR          = COPYBUF(INDREG,INDDIR).STEMCUR
      STEMCURLAG       = COPYBUF(INDREG,INDDIR).STEMCURLAG
      COGSTEAM         = COPYBUF(INDREG,INDDIR).COGSTEAM
      NONCOGSTEAM      = COPYBUF(INDREG,INDDIR).NONCOGSTEAM
      BIOSTEAM         = COPYBUF(INDREG,INDDIR).BIOSTEAM
      NONCOGFOSSTEAM   = COPYBUF(INDREG,INDDIR).NONCOGFOSSTEAM
      FUELFOSSTEAM     = COPYBUF(INDREG,INDDIR).FUELFOSSTEAM
      COGBOILFUEL      = COPYBUF(INDREG,INDDIR).COGBOILFUEL
      ELOWN            = COPYBUF(INDREG,INDDIR).ELOWN
      ELSALE           = COPYBUF(INDREG,INDDIR).ELSALE
      GENFUEL          = COPYBUF(INDREG,INDDIR).GENFUEL
      RPTGEN           = COPYBUF(INDREG,INDDIR).RPTGEN
      RPTCAP           = COPYBUF(INDREG,INDDIR).RPTCAP
      QTYMAIN(:,INDREG)= COPYBUF(INDREG,INDDIR).QTYMAIN
      QTYINTR(:,INDREG)= COPYBUF(INDREG,INDDIR).QTYINTR
      QTYRENW(:,INDREG)= COPYBUF(INDREG,INDDIR).QTYRENW
      BYPBSCM          = COPYBUF(INDREG,INDDIR).BYPBSCM
      BYPBSCI          = COPYBUF(INDREG,INDDIR).BYPBSCI
      BYPBSCR          = COPYBUF(INDREG,INDDIR).BYPBSCR
      PRODRETR         = COPYBUF(INDREG,INDDIR).PRODRETR
      PRODCUR          = COPYBUF(INDREG,INDDIR).PRODCUR
      PRODLAG          = COPYBUF(INDREG,INDDIR).PRODLAG
      PRODFLOW         = COPYBUF(INDREG,INDDIR).PRODFLOW
      ENPINT           = COPYBUF(INDREG,INDDIR).ENPINT
      ENPINTLAG        = COPYBUF(INDREG,INDDIR).ENPINTLAG
      ENPQTY           = COPYBUF(INDREG,INDDIR).ENPQTY
      BYPINT           = COPYBUF(INDREG,INDDIR).BYPINT
      BYPINTLAG        = COPYBUF(INDREG,INDDIR).BYPINTLAG
      BYPQTY           = COPYBUF(INDREG,INDDIR).BYPQTY
      IDLCAP           = COPYBUF(INDREG,INDDIR).IDLCAP
      IDLCAPLAG        = COPYBUF(INDREG,INDDIR).IDLCAPLAG
      INDMAX           = COPYBUF(INDREG,INDDIR).INDMAX
      MPASTP           = COPYBUF(INDREG,INDDIR).MPASTP
      PHDRAT           = COPYBUF(INDREG,INDDIR).PHDRAT
      INDDIR           = COPYBUF(INDREG,INDDIR).INDDIR
      IDVAL            = COPYBUF(INDREG,INDDIR).IDVAL
      IFSMAX           = COPYBUF(INDREG,INDDIR).IFSMAX
      IFSLOC           = COPYBUF(INDREG,INDDIR).IFSLOC
      IFSBYP           = COPYBUF(INDREG,INDDIR).IFSBYP
      IFSLOCBY         = COPYBUF(INDREG,INDDIR).IFSLOCBY
      NTMAX            = COPYBUF(INDREG,INDDIR).NTMAX
      IFMAX            = COPYBUF(INDREG,INDDIR).IFMAX
      IPASTP           = COPYBUF(INDREG,INDDIR).IPASTP
      IFLOC            = COPYBUF(INDREG,INDDIR).IFLOC
      ITYPE            = COPYBUF(INDREG,INDDIR).ITYPE
      BCSC             = COPYBUF(INDREG,INDDIR).BCSC
      IFBYP            = COPYBUF(INDREG,INDDIR).IFBYP
      IFLOCBY          = COPYBUF(INDREG,INDDIR).IFLOCBY
      BYPCSC           = COPYBUF(INDREG,INDDIR).BYPCSC
      EINTER           = COPYBUF(INDREG,INDDIR).EINTER
      NumRptGrps       = COPYBUF(INDREG,INDDIR).NumRptGrps
      NumRptGrpSteps   = COPYBUF(INDREG,INDDIR).NumRptGrpSteps
      RptGrpSteps      = COPYBUF(INDREG,INDDIR).RptGrpSteps
      RptGrpNames      = COPYBUF(INDREG,INDDIR).RptGrpNames
      RptGrpSName      = COPYBUF(INDREG,INDDIR).RptGrpSName
      INDNAME          = COPYBUF(INDREG,INDDIR).INDNAME
      INDSTEPNAME      = COPYBUF(INDREG,INDDIR).INDSTEPNAME
      return
      end SUBROUTINE RDBIN
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!  IF NOT THE FIRST YEAR, THE
!  MODEL CALCULATIONS ARE DIRECTED FROM THIS SUBROUTINE.
!****

      SUBROUTINE MODCAL(version)
   use i_
      IMPLICIT NONE
      character*(*) version ! argument passed as 'original' or 'tech' to trigger tech choice industries
      INTEGER TLOGFLG,COUNT
      INTEGER INTSVE(7)
      INTEGER NONMFG(8)
      INTEGER IS,IFUEL,IFX
      INTEGER ISTEP
      REAL INDCARBREG4,ab_indcarbCA
      REAL ab_covd_em_AG,ab_covd_em_MINE,ab_covd_em_CONST
      REAL ab_covd_em_FOOD,ab_covd_em_PAPER,ab_covd_em_CHEM
      REAL ab_covd_em_GLASS,ab_covd_em_CEMENT,ab_covd_em_STEEL
      REAL ab_covd_em_ALUM,ab_covd_em_FAB,ab_covd_em_MACH
      REAL ab_covd_em_COMP,ab_covd_em_TRANEQ,ab_covd_em_ELECEQ
      REAL ab_covd_em_WOODPRD,ab_covd_em_PLASTIC,ab_covd_em_BOM
      REAL TEMP_VALUE

      INTEGER RTOVALUE,AB32SW
      EXTERNAL RTOVALUE

      DATA INTSVE/7,8,9,10,11,12,13/
      DATA NONMFG/0,0,1,2,3,4,5,6/

!  Check runtime option to turn AB32SW switch for implementation of AB32 cap-and-trade in State of California.
!  The default setting is ON (1).
!
      AB32SW=RTOVALUE('AB32SW  ',1)

!****
!  WRITE SUBROUTINE TRACE, IF ON.
!****

      IF(ISUBTR.EQ.1.AND.IOPEN.EQ.1.AND.LSTITER.EQ.1) &
        WRITE(IUNIT1,991)

!****
!  CALCULATE ENERGY CONSUMPTION IN THE PA COMPONENT.
!****

!****
!  ASSIGN AB32 CARBON SHARE FOR STATE OF CALIFORNIA.
!****
      IF(AB32SW.EQ.1) THEN
        IF(INDREG.EQ.4.AND.CURCALYR.GE.IBYR2) THEN        !  Program starts 2013. POT_ibyr2
          CARBSHR_AB(INDDIR,INDREG)=CARBSHRCA(INDDIR)    !  2010 CA share of covered facilities in western census region.
        ELSE
          CARBSHR_AB(INDDIR,INDREG)=0.     !  Zero value denotes no covered facilities in CA.
        ENDIF
      ENDIF

!****
!    DETERMINE PRODUCTION FLOWS FOR EACH PROCESS/ASSEMBLY STEP.
!****
          if ((inddir.eq.8).and.(curcalyr.ge.ibyr2+1))  then
		     call prodflow_paper                      ! this replaces CALPROD for paper
          else if ((inddir.eq.12).and.(curcalyr.ge.ibyr2+1))  then
		     call prodflow_steel                      ! this replaces CALPROD for iron and steel
          else if (curcalyr.ge.ibyr2+1) then ! KPE added conditional
             CALL CALPROD
          endif

! CALCULATE THIS YEAR'S UECS (ENPINT) BASED ON TPC/CSC PARAMETERS
      if (version == 'original') then
		DO ISTEP=1,MPASTP
			DO IFUEL=1,IFMAX(ISTEP)

			CALL CALCSC(IFUEL,ISTEP)

			ENDDO
		ENDDO
	  endif 

!****
!    ADD UP ENERGY CONSUMPTION OVER THE PROCESS/ASSEMBLY STEPS.
!****
      if(version.eq.'tech') then
        if(inddir.eq.11.and.curcalyr.ge.ibyr2+1) then  ! POT_ibyr2OTHER 2007 to ibyr2+1
          call cement_industry
        endif
        if(inddir.eq.13.and.curcalyr.ge.ibyr2+1) then  ! POT_ibyr2OTHER 2007 to ibyr2+1
          call aluminum_industry
        endif
        if(inddir.eq.10.and.curcalyr.ge.ibyr2+1) then  ! POT_ibyr2OTHER 2007 to ibyr2+1
          call glass_industry
        endif
		 if(inddir.eq.12.and.curcalyr.ge.ibyr2+1) then
		  call ironsteel_industry
        endif
		 if(inddir.eq.8.and.curcalyr.ge.ibyr2+1) then
		   call paperpulp_industry
        endif
      endif
  
    
      CALL CALPATOT(version)

!****
!  DETERMINE BYPRODUCT FUEL PRODUCED IN THE PA STEPS.
!****

            if (inddir.ne.8 .and. inddir.ne.12) then ! KPE conditional
				CALL CALBYPROD  
			else ! initialize variables	
				BYPQTY(:,:,:)=0.0
				DO ifx=1,23
					BYPBSCM(ifx)=0.0
				enddo
				DO ifx=1,7
					BYPBSCI(ifx)=0.0
				enddo
				DO ifx=1,9
				BYPBSCR(ifx)=0.0
				enddo

			endif


!****
!    ADD UP TOTAL BUILDING ENERGY CONSUMPTION.
!****

     CALL CALBTOT


!****
!  CALCULATE ENERGY CONSUMPTION IN BOILER/STEAM/COGEN.
!****
!bsc is included in P&A for steel and paper  
if ((inddir.eq.12).or.(inddir.eq.8)) then   ! made the contingency on industry only; then call ppis_bsc only for certain years
   if (CURCALYR.GT.maxcogyr) call ppis_bsc   !  KPE call for all regions--but only after maxcogyr--was ge.ibyr2+1  

else

!****
!    CALCULATE ELECTRICITY GENERATION.
!****
!


      CALL CALGEN


      if(prtdbgi.eq.3) then
        call pcoggen
      endif

!****
!    CALCULATE THIS YEAR'S FUEL SHARES AND INTENSITIES.
!****
      CALL CALBSC

!****
!    ADD UP TOTAL ENERGY CONSUMPTION IN THE BSC COMPONENT.
!****

      CALL CALSTOT

endif

     !  kpe calling for all because prtgbi == 3 writes quarter gig files
     !	if ((prtdbgi.eq.1).and.(curitr == 1)) call pcoggen


! The remaining code in this modcal subroutine accumulates totals across industry.  These
! sums may only be accumulated once for each region and industry.  So skip the remainder
! if this is invoocation is not the "tech" option and the industry is a tech-choice industry.
! "tech" version means process flow industries, not "tech" side cases KPE
! not quite --- the first modcal invocation is for year ibyr2 (at least as it stands in the code now); this invocation
! is for the remaining years

! old version
!  IF( (inddir.eq.10 .or. inddir.eq.11  .or. inddir.eq.13 .or. inddir.eq.12 .or. inddir.eq.8).and. version.ne.'tech') then
!     return
!  endif

! kpe version --- invokes the process flow industry subroutines
!  this is where the mecsbench procedure used to be --- now at bottom of calpatot
  IF (inddir.eq.10 .or. inddir.eq.11  .or. inddir.eq.13 .or. inddir.eq.12 .or. inddir.eq.8) then
  !   return
  !endif


!****
!  Benchmark and CALCULATE OVERALL INDUSTRY TOTALS.
!****
!if (curiyr.eq.1) then  ! only uncomment if testing without benchmarks
 if (CURCALYR.ge.(ibyr2+2)) then 
      SELECT CASE (INDDIR)
		Case (12)
	      call benchmecs(steelcon(1,1,curiyr-1),is_mecsbench(indreg,1:9))
        Case (8)
          call benchmecs(papercon(1,1,curiyr-1),pp_mecsbench(indreg,1:9))
        Case (13)
          call benchmecs(alumcon(1,1,curiyr-1),al_mecsbench(indreg,1:9))
        Case (11)
          call benchmecs(cementcon(1,1,curiyr-1),cm_mecsbench(indreg,1:9))
        Case (10)
          call benchmecs(glasscon(1,1,curiyr-1),gl_mecsbench(indreg,1:9))
      end select
  endif
endif ! process flow industry total----


      IF(INDREG.EQ.4.AND.CURCALYR.EQ.ibyr2+1) THEN                ! POT_ibyr215

        CARBSHRCA(1:2)= (72845.4+ 78776.2)*(12./44.)*1.0E-6/INDCARBREG4(AGCON(1,1,curiyr+1),curiyr+1)   ! update 2010 CA reports in tCO2e and NEMS reports million tonnes.
!        write(6,'(5x,a,3f10.4,2x,2(i2,2x),2x,i4)') '==== AB32 AGCON ', AGCON(1,4,curiyr+1), AGCON(3,4,curiyr+1), AGCON(8,4,curiyr+1), INDDIR, INDREG, curcalyr-1
        CARBSHRCA(3:5)= (15489799.3+1900216.8)*(12./44.)*1.0E-6/INDCARBREG4(MINECON(1,1,curiyr+1),curiyr+1)  ! update  Now covered emissions for mining
        CARBSHRCA(6)= 0.0*(12./44.)*1.0E-6/INDCARBREG4(CONSTCON(1,1,curiyr+1),curiyr+1) ! OK
        CARBSHRCA(7)= 1871037.7*(12./44.)*1.0E-6/INDCARBREG4(FOODCON(1,1,curiyr+1),curiyr+1) !OK
        CARBSHRCA(8)= 885255.6*(12./44.)*1.0E-6/INDCARBREG4(PAPERCON(1,1,curiyr+1),curiyr+1) ! OK
        CARBSHRCA(9)= 3529177.1*(12./44.)*1.0E-6/INDCARBREG4(CHEMCON(1,1,curiyr+1),curiyr+1)
        CARBSHRCA(10)= 646293.1*(12./44.)*1.0E-6/INDCARBREG4(GLASSCON(1,1,curiyr+1),curiyr+1)
        CARBSHRCA(11)= 7729408.5*(12./44.)*1.0E-6/((INDCARBREG4(CEMENTCON(1,1,curiyr+1),curiyr+1))+ co2_clink(curiyr+1,4)/1.0E6)   !  co2_clink is in C units.
        CARBSHRCA(12)= 330405.8*(12./44.)*1.0E-6/INDCARBREG4(STEELCON(1,1,curiyr+1),curiyr+1)
        CARBSHRCA(13)= 32119.5*(12./44.)*1.0E-6/INDCARBREG4(ALUMCON(1,1,curiyr+1),curiyr+1)
        CARBSHRCA(14)= 58211.0*(12./44.)*1.0E-6/INDCARBREG4(FABMETALCON(1,1,curiyr+1),curiyr+1) ! OK to here
        CARBSHRCA(15)= 32655.0*(12./44.)*1.0E-6/INDCARBREG4(MACHINECON(1,1,curiyr+1),curiyr+1)
        CARBSHRCA(16)= 0.0*(12./44.)*1.0E-6/INDCARBREG4(COMPUTECON(1,1,curiyr+1),curiyr+1)
        CARBSHRCA(17)= 93550.7*(12./44.)*1.0E-6/INDCARBREG4(TRANEQUIPCON(1,1,curiyr+1),curiyr+1)  ! OK to here
        CARBSHRCA(18)= 0.0/INDCARBREG4(ELECEQUIPON(1,1,curiyr+1),curiyr+1)
        CARBSHRCA(19)= 0.0*(12./44.)*1.0E-6/INDCARBREG4(WOODPRODCON(1,1,curiyr+1),curiyr+1)
        CARBSHRCA(20)= 0.0*(12./44.)*1.0E-6/INDCARBREG4(PLASTICCON(1,1,curiyr+1),curiyr+1)
        CARBSHRCA(21)= 538758.5*(12./44.)*1.0E-6/INDCARBREG4(BOMOTHCON(1,1,curiyr+1),curiyr+1)

        IF(CARBSHRCA(INDDIR).GT.1.0) CARBSHRCA(INDDIR)=1.0
        CARBSHRCA(11)=0.52        ! Hardcode a carbon share for cement based on 2010 clinker production in CA

        write(6,'(5x,a,i2,a,f10.4,a,i4)') '==== AB32 CARBSHRCA(',INDDIR,') = ', CARBSHRCA(INDDIR), ' in ', curcalyr
      ENDIF

      !  Fill each of the Industry carbon emission values for reporting.
      IF(AB32SW.EQ.1.AND.INDREG.EQ.4.AND.CURCALYR.GE.ibyr2+1) then                   ! POT_ibyr215
      SELECT CASE (INDDIR)
        Case (1:2)
         ab_covd_em_AG = 0.
         ab_covd_em_AG = ab_indcarbCA(AGCON(1,1,CURIYR),CURIYR,CARBSHR_AB(INDDIR,INDREG))
         write(6,'(5x,a,2(2x,f10.4),2x,i4)') '==== AB32 ', ab_indcarbCA(AGCON(1,1,CURIYR),CURIYR,CARBSHR_AB(INDDIR,INDREG)),CARBSHR_AB(INDDIR,INDREG),curcalyr
        Case (3:5)
         ab_covd_em_MINE=0.
         ab_covd_em_MINE = ab_indcarbCA(MINECON(1,1,CURIYR),CURIYR,CARBSHR_AB(INDDIR,INDREG))
        Case (6)
         ab_covd_em_CONST = 0.
         ab_covd_em_CONST = ab_indcarbCA(CONSTCON(1,1,CURIYR),CURIYR,CARBSHR_AB(INDDIR,INDREG))
        Case (7)
         ab_covd_em_FOOD = 0.
         ab_covd_em_FOOD = ab_indcarbCA(FOODCON(1,1,CURIYR),CURIYR,CARBSHR_AB(INDDIR,INDREG))
        Case (8)
         ab_covd_em_PAPER = 0.
         ab_covd_em_PAPER = ab_indcarbCA(PAPERCON(1,1,CURIYR),CURIYR,CARBSHR_AB(INDDIR,INDREG))
        Case (9)
         ab_covd_em_CHEM = 0.
         ab_covd_em_CHEM = ab_indcarbCA(CHEMCON(1,1,CURIYR),CURIYR,CARBSHR_AB(INDDIR,INDREG))
!         write(6,'(5x,a,3(2x,f10.4),2x,i4)') '==== AB32 ', ab_indcarbCA(CHEMCON(1,1,CURIYR),CURIYR,CARBSHR_AB(INDDIR,INDREG)),INDCARBREG4(CHEMCON(1,1,curiyr),curiyr),CARBSHR_AB(INDDIR,INDREG),curcalyr
        Case (10)
         ab_covd_em_GLASS = 0.
         ab_covd_em_GLASS = ab_indcarbCA(GLASSCON(1,1,CURIYR),CURIYR,CARBSHR_AB(INDDIR,INDREG))
        Case (11)
         ab_covd_em_CEMENT = 0.
         ab_covd_em_CEMENT = ab_indcarbCA(CEMENTCON(1,1,CURIYR),CURIYR,CARBSHR_AB(INDDIR,INDREG))
        Case (12)
         ab_covd_em_STEEL = 0.
         ab_covd_em_STEEL = ab_indcarbCA(STEELCON(1,1,CURIYR),CURIYR,CARBSHR_AB(INDDIR,INDREG))
        Case (13)
         ab_covd_em_ALUM = 0.
         ab_covd_em_ALUM = ab_indcarbCA(ALUMCON(1,1,CURIYR),CURIYR,CARBSHR_AB(INDDIR,INDREG))
        Case (14)
         ab_covd_em_FAB = 0.
         ab_covd_em_FAB = ab_indcarbCA(FABMETALCON(1,1,CURIYR),CURIYR,CARBSHR_AB(INDDIR,INDREG))
        Case (15)
         ab_covd_em_MACH = 0.
         ab_covd_em_MACH = ab_indcarbCA(MACHINECON(1,1,CURIYR),CURIYR,CARBSHR_AB(INDDIR,INDREG))
        Case (16)
         ab_covd_em_COMP = 0.
         ab_covd_em_COMP = ab_indcarbCA(COMPUTECON(1,1,CURIYR),CURIYR,CARBSHR_AB(INDDIR,INDREG))
        Case (17)
         ab_covd_em_TRANEQ = 0.
         ab_covd_em_TRANEQ = ab_indcarbCA(TRANEQUIPCON(1,1,CURIYR),CURIYR,CARBSHR_AB(INDDIR,INDREG))
        Case (18)
         ab_covd_em_ELECEQ = 0.
         ab_covd_em_ELECEQ = ab_indcarbCA(ELECEQUIPON(1,1,CURIYR),CURIYR,CARBSHR_AB(INDDIR,INDREG))
        Case (19)
         ab_covd_em_WOODPRD = 0.
         ab_covd_em_WOODPRD = ab_indcarbCA(WOODPRODCON(1,1,CURIYR),CURIYR,CARBSHR_AB(INDDIR,INDREG))
        Case (20)
         ab_covd_em_PLASTIC = 0.
         ab_covd_em_PLASTIC = ab_indcarbCA(PLASTICCON(1,1,CURIYR),CURIYR,CARBSHR_AB(INDDIR,INDREG))
        Case (21)
         ab_covd_em_BOM = 0.
         ab_covd_em_BOM = ab_indcarbCA(BOMOTHCON(1,1,CURIYR),CURIYR,CARBSHR_AB(INDDIR,INDREG))
        end select

     
        
!***** CA carbon emissions of covered industies, units Million metic tCeq

        TEMP_VALUE = ab_covd_em_ind(CURIYR)

        ab_covd_em_ind(CURIYR)=ab_covd_em_AG+ab_covd_em_MINE+ab_covd_em_CONST+      &
                               ab_covd_em_FOOD+ab_covd_em_PAPER+ab_covd_em_CHEM+     &
                               ab_covd_em_GLASS+ab_covd_em_CEMENT+ab_covd_em_STEEL+  &
                               ab_covd_em_ALUM+ab_covd_em_FAB+ab_covd_em_MACH+       &
                               ab_covd_em_COMP+ab_covd_em_TRANEQ+ab_covd_em_ELECEQ+  &
                               ab_covd_em_WOODPRD+ab_covd_em_PLASTIC+ab_covd_em_BOM

        IF (isnan(ab_covd_em_ind(CURIYR))) THEN
           WRITE(6,2037) CURIRUN, CURIYR+1989, CURITR, ab_covd_em_ind(CURIYR),          &
                               ab_covd_em_AG, ab_covd_em_MINE, ab_covd_em_CONST,        &
                               ab_covd_em_FOOD, ab_covd_em_PAPER, ab_covd_em_CHEM,      &
                               ab_covd_em_GLASS, ab_covd_em_CEMENT, ab_covd_em_STEEL,   &
                               ab_covd_em_ALUM, ab_covd_em_FAB, ab_covd_em_MACH,        &
                               ab_covd_em_COMP, ab_covd_em_TRANEQ, ab_covd_em_ELECEQ,   &
                               ab_covd_em_WOODPRD, ab_covd_em_PLASTIC, ab_covd_em_BOM
 2037      FORMAT(1X,"ab_covd_em_ind_is_NAN",3(":",I4),19(":",F12.6))

           ab_covd_em_ind(CURIYR) = TEMP_VALUE

        END IF

 !  ***** CA process industrial process emissions or also called non-CO2 emissions per NEMS parlance, convert to units of Million metric tCeq  -- process emissions already covered
          ab_covd_em_oth(CURIYR)=1.0E-6*((CARBSHR_AB(11,4)*co2_clink(curiyr,4))+       &
                                 0.0 + &      ! Sum of California covered process emissions: Adipic Acid Production (in tCeq units).
                                 0.0 + &      ! Sum of California covered process emissions: Aluminum Production (in tCeq units).
                                 0.0 + &      ! Sum of California covered process emissions: Ammonia Manufacturing (in tCeq units).
                                 17052.1 + &      ! Sum of California covered process emissions: Lime Production (in tCeq units).
                                 0.0 + &      ! Sum of California covered process emissions: Ferroalloy Production (in tCeq units).
                                 86007.7 + &      ! Sum of California covered process emissions: Glass Production (in tCeq units).
                                 0.0 + &      ! Sum of California covered process emissions: HCFC?2 Production from HFC?3 Destruction (in tCeq units).
                                 0.0 + &      ! Sum of California covered process emissions: Hydrogen Production (in tCeq units). Pre! Sume captured as feedstock.
                                 3363.3 + &      ! Sum of California covered process emissions: Iron and Steel Production (in tCeq units).
                                 4557.7 + &      ! Sum of California covered process emissions: Lead Production (in tCeq units).
                                 2837.45454545455 + &      ! Sum of California covered process emissions: Miscellaneous Use of Carbonates (in tCeq units).
                                 4454.86909090909 + &      ! Sum of California covered process emissions: Nitric Acid Production (in tCeq units).
                                 0.0 + &      ! Sum of California covered process emissions: Petrochemical Production (in tCeq units).
                                 36578.0 +  &              ! Sum of California covered process emissions: Petroleum Refining. Only CH4 and N2O emissions.
                                 0.0 + &      ! Sum of California covered process emissions: Phosphoric Acid Production (in tCeq units).
                                 0.0 + &      ! Sum of California covered process emissions: Pulp and Paper Manufacturing (in tCeq units).
                                 0.0 + &      ! Sum of California covered process emissions: Silicon Carbide Production (in tCeq units).
                                 0.0 + &      ! Sum of California covered process emissions: Soda Ash Manufacturing (in tCeq units).
                                 0.0 + &      ! Sum of California covered process emissions: Titanium Dioxide Production (in tCeq units).
                                 0.0 + &      ! Sum of California covered process emissions: Zinc Production (in tCeq units).
                                 0.0)         ! Sum of California covered process emissions: Landfills (in tCeq units). Pre! Sume all biogenic emissions.

          IF(INDDIR.EQ.NUMIND) THEN
            write(6,'(5x,a,1x,f15.4,a,i4)') '==== AB32 Total CO2 Industrial Covered Million tCeq Emissions = ', &
                                                  ab_covd_em_ind(CURIYR), ' for ', CURCALYR
            write(6,'(5x,a,1x,f15.4,a,i4)') '==== AB32 Total non-CO2 Industrial Covered Million tCeq Emissions = ', &
                                                  ab_covd_em_oth(CURIYR), ' for ', CURCALYR
            write(6,'(5x,a,1x,f15.4,a,i4)') '==== AB32 Total Clinker Million tCeq Emissions = ', &
                                                  1.0E-6*CARBSHR_AB(11,4)*co2_clink(curiyr,4), ' for ', CURCALYR
          ENDIF

        ELSE
          ab_covd_em_ind(CURIYR)=0.0
          ab_covd_em_oth(CURIYR)=0.0
        ENDIF

! now calling ind total for everybody
	  CALL INDTOTAL(INDREG)

!****
!  CALCULATE OVERALL INDUSTRY NATIONAL TOTALS.
!****

      IF(indreg.EQ.4) THEN
        CALL NATTOTAL
      ENDIF

!****
!  FILL IN VALUES FOR NEMS REPORT WRITER VARIABLES.
!****

     
      CALL CONTAB(indreg)
      IF(indreg.EQ.4) CALL CONTAB(5)




  991 FORMAT(3X,'MODCAL')


   RETURN
      END SUBROUTINE MODCAL

!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
      function indcarbreg4(x_con,iy)
      implicit none
!   designed for use by ind:
!   calculates carbon emissions for an industrial sector for a given year
!   "con" is one of the arrays in indrep holding fuel
!          consumption for the sector
!   iy is the nems year index
!   indcarbreg4 returns the result in million tonnes of carbon
! emis(fuel) are in million metric tons carbon per quad.

      include 'parametr'
      include 'ncntrl'
      include 'qblk'
      include 'emmparm'
      include 'emission'
      include 'emeblk'
      include 'ghgrep'
      real x_con(18,5)
      real emis(18)
      real divs(4,2)
      integer i,iy,icy
      integer iyy
      real indcarbreg4
      real fsum
      external fsum   ! function fsum sums the first dimension of an array

      REAL C_CO2_FACTOR

      C_CO2_FACTOR = 1.
!     IF (TRIM(CARBON_OR_2) .EQ. 'co2') C_CO2_FACTOR = 44. / 12.

! emel calculated in epm.
!
! emission factors only defined from 95 on, so use 95 for prior years
      iyy=max(iy,6)
      icy=iy+baseyr-1
      emis(1)=em_elec(8,11,icy)/qelas(11,iy)       ! elec note: qelas in quads here
      emis(2)=engin(iyy)   * C_CO2_FACTOR          ! ngas
      emis(3)=eclin(iyy)   * C_CO2_FACTOR          ! steam coal
      emis(4)=emcin(iyy)   * C_CO2_FACTOR          ! met coal
      emis(5)=eclin(iyy)   * C_CO2_FACTOR          ! net coke import (steel only)
      emis(6)=erlin(iyy)   * C_CO2_FACTOR          ! resid (low sulphur)
      emis(7)=edsin(iyy)   * C_CO2_FACTOR          ! distillate
      emis(8)=elgin(iyy)   * C_CO2_FACTOR          ! liquid petrol gases
      emis(9)=emgin(iyy)   * C_CO2_FACTOR          ! motor gasoline
      emis(10)=esgin(iyy)  * C_CO2_FACTOR          ! still gas (refine only)
      emis(11)=epcin(iyy)  * C_CO2_FACTOR          ! petroleum coke
      emis(12)=0.0         * C_CO2_FACTOR          ! asphalt, all sequestered
      emis(13)=epfin(iyy)  * C_CO2_FACTOR          ! petroleum feedstock
      emis(14)=eksin(iyy)  * C_CO2_FACTOR          ! kerosene
      emis(15)=eotin(iyy)  * C_CO2_FACTOR          ! other ind
      emis(16)=enqngpf(iyy)  * C_CO2_FACTOR        ! nat gas feed stocks
      emis(17)=enqlgpf(iyy)  * C_CO2_FACTOR        ! lpg feedstock
      emis(18)=0.          * C_CO2_FACTOR          ! renewables, all sequestered
! multiply fuel use in trill btu times emission factor.
! and divide by 1000
      Indcarbreg4=0.
      do i =2,18
        indcarbreg4=indcarbreg4+x_con(i,4)*emis(i)/1000.
      enddo
      i=1
!!! indirect CO2 from electricity generation is excluded:
!!!      emis(1)=sum(em_elec(8,8:9,icy))/sum(qelas(8:9,iy))       ! elec note: qelas in quads here (Western region)
!!!      indcarbreg4=indcarbreg4+x_con(i,4)*emis(i)/1000.
      return
      END

!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
      function ab_indcarbCA(y_con,iy,ab_carbshr)
      implicit none
!   designed for use by ind:
!   calculates carbon emissions for an industrial sector in CA for a given year
!   "con" is one of the arrays in indrep holding fuel
!          consumption for the sector
!   iy is the nems year index
!   ab_indcarbCA returns the result in million tonnes of carbon
! emis(fuel) are in million tonnes carbon per quad.

      include 'parametr'
      include 'ncntrl'
      include 'qblk'
      include 'emmparm'
      include 'emission'
      include 'emeblk'
      include 'ghgrep'
      real y_con(18,5)
      real emis(18)
      real divs(4,2)
      integer i,iy,icy
      integer iyy
      real ab_indcarbCA,ab_carbshr
      real temp_carb
      real fsum
      external fsum   ! function fsum sums the first dimension of an array

      REAL C_CO2_FACTOR

      C_CO2_FACTOR = 1.
!     IF (TRIM(CARBON_OR_2) .EQ. 'co2') C_CO2_FACTOR = 44. / 12.

! emel calculated in epm.
!
! emission factors only defined from 95 on, so use 95 for prior years
      iyy=max(iy,6)
      icy=iy+baseyr-1
      emis(1)=em_elec(8,11,icy)/qelas(11,iy)       ! elec note: qelas in quads here
      emis(2)=engin(iyy)   * C_CO2_FACTOR          ! ngas
      emis(3)=eclin(iyy)   * C_CO2_FACTOR          ! steam coal
      emis(4)=emcin(iyy)   * C_CO2_FACTOR          ! met coal
      emis(5)=eclin(iyy)   * C_CO2_FACTOR          ! net coke import (steel only)
      emis(6)=erlin(iyy)   * C_CO2_FACTOR          ! resid (low sulphur)
      emis(7)=edsin(iyy)   * C_CO2_FACTOR          ! distillate
      emis(8)=elgin(iyy)   * C_CO2_FACTOR          ! liquid petrol gases
      emis(9)=emgin(iyy)   * C_CO2_FACTOR          ! motor gasoline
      emis(10)=esgin(iyy)  * C_CO2_FACTOR          ! still gas (refine only)
      emis(11)=epcin(iyy)  * C_CO2_FACTOR          ! petroleum coke
      emis(12)=0.0         * C_CO2_FACTOR          ! asphalt, all sequestered
      emis(13)=epfin(iyy)  * C_CO2_FACTOR          ! petroleum feedstock
      emis(14)=eksin(iyy)  * C_CO2_FACTOR          ! kerosene
      emis(15)=eotin(iyy)  * C_CO2_FACTOR          ! other ind
      emis(16)=enqngpf(iyy)  * C_CO2_FACTOR        ! nat gas feed stocks
      emis(17)=enqlgpf(iyy)  * C_CO2_FACTOR        ! lpg feedstock
      emis(18)=0.          * C_CO2_FACTOR          ! renewables, all sequestered
! multiply fuel use in trill btu times emission factor.
! and divide by 1000
      ab_indcarbCA=0.
      do i =2,18
        temp_carb = ab_indcarbCA

        ab_indcarbCA= ab_indcarbCA+(ab_carbshr*y_con(i,4)*emis(i)/1000.)

        IF (isnan(ab_indcarbCA)) THEN

           WRITE(6,2371) CURIRUN, CURIYR+1989, CURITR, i, ab_indcarbCA, ab_carbshr, y_con(i,4), emis(i)
 2371      FORMAT(1X,"AB_INDCARBCA_IS_NAN",4(":",I4),4(":",F18.6))

        END IF
      enddo


      return
      END

!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!  THIS SUBROUTINE DETERMINES THE PRODUCTION FLOWS FOR THE
!  PROCESS AND ASSEMBLY COMPONENT.
!
!     Retirement of capacity is implemented.
!     Production of base year, Post-base year, and New Capacity is tracked.
!     New Capacity requirements are calculated that meet final demand
!     changes and retirements.  New Capacity is determined
!     such that downstep requirements are met
!     by a mix of surviving capacity and new capacity.  This is
!     formulated as an input-output problem and solved as a set
!     of simultaneous equations
!
      SUBROUTINE CALPROD
   use i_
      IMPLICIT NONE
      real AveSPrc,MinVert
      external AveSPrc,MinVert
      REAL X
      INTEGER IS,IV,IT,IP,IC
      integer nz
	  INTEGER INDBMOVR2
	  INTEGER INDBMOVR
      parameter(nz=numind*4)
      REAL PRODXIBYR(numind,4)/nz*0./    ! Holds base year version of PRODX (Ind. Production) by industry and region
      REAL PRODXMID/0./              ! Holds Change in PRODX since the base year
      REAL PRODXNEW/0./              ! Holds Change in PRODX from prior year
      INTEGER MAXSTPS
      PARAMETER (MAXSTPS=maxstep+1)
      REAL PRODSAV(4,MAXSTPS)
      REAL ALPHA(7)
      REAL MCPRICE(4)
      REAL DELTA
      INTEGER IY,CASE,isub
      real old_ship(5),new_ship(5),surv_ship
! Retirement Rate price sensitivity function
      REAL RetireBeta/2./    ! Logit coefficient for use in choice between default and maximum retirement rate
      REAL RetireMaxRate     ! Maximum Retirement rate
      REAL RetirePrat(maxstps) ! Ratio of current Prices to base year Prices
      REAL RetirePriceFactor ! Multiplier on retirement rate due to energy price response
      REAL RetireRate(0:maxstps)     ! retirement rate after application of price sensitivity parameter(by step)

!      REAL AveSPrc           !function to return price change since a specified year
      REAL ImportFac          ! factor for import penetration of cement in high price scenarios
      REAL KeepPF(2,maxstep,maxlinks) !keep the original prodflow so it can be restored at the end of the routine
      REAL ImpScalar/0.80/
      REAL WetFac/0.80/   ! Wet Kilns are reduced more than dry kilns

      real alprodtotal(4) ! regional primary + secondary total from prodflow matrix;
                          ! assume this total maintained even though relative amounts of primary and secondary
                          ! flows can vary over time
      real alslope(4)     ! electric price regression slopes
      real alslopelag(4)  ! electric price lag regression slopes
      real alintercept(4) ! regression intercepts
      real albaseratio(4) ! 2006 base year primary / (primary + secondary)
      real alpricelag(4)  ! lag price
      real alefficiency(4)  !factors in changes for electricity efficiency; 1.0 assumes 14500 kWh/ton
      real alprodflowtotal(4) ! total primary + secondary PRODFLOW elements (same for both old and new PRODFLOWS)
      real alhistratio(4,4) ! regional historical values
      real alratio(4)     ! actual (current/projected) ratio
      real bauxite(4)     ! for bauxite compuation
      INTEGER IFUEL
      integer rtovalue,behave

      REAL D(MAXSTPS+1)      ! vector of final demands (output). usually, only D(1) is nonzero.
      REAL Dsurv(MAXSTPS+1)  ! demands by step that can be met by surviving capacity.
      real Dold(MAXSTPS+1)
      REAL Dnew(MAXSTPS+1)   ! demands by step that must be met by new capacity.
      REAL Xnew(maxstps+1)   ! Cumulative New productive capacity by step since base year
      real xold(maxstps+1)
      Real Xsurv(maxstps+1)  ! Base year productive capacity surviving to current year, net of retirements
      REAL IAold(MAXSTPS+1,MAXSTPS+1)      ! I-A Matrix of I/O Coefficients, Old capacity
      REAL IAnew(MAXSTPS+1,MAXSTPS+1)      ! I-A Matrix of I/O Coefficients, New Capacity
      REAL IAnew_inv(MAXSTPS+1,MAXSTPS+1)  ! Inverse of I-A matrix of I/O Coefficients, New Capacity
      REAL IAold_inv(MAXSTPS+1,MAXSTPS+1)  ! Inverse of I-A matrix of I/O Coefficients, New Capacity
      REAL*8 Real8A1(MAXSTPS+1,MAXSTPS+1)
      REAL*8 Real8A2(MAXSTPS+1,MAXSTPS+1)
      real*4 Det
! Product Flow Input-Output Coefficients. Used to determine
! new capacity additions that will balance downstep requirements against
! existing capacity, such that new capacity is added in proportion to
! rates specified in the PRODFLOW(NEW, , )  array


      REAL IDLED_OLD,IDLED_MID
      INTEGER OLD,MID,NEU,TOT ,DOWN_STEP,  & ! Constants Used to Refer to Subscripts by Name
       OLD_RATE,NEW_RATE                    ! Constants Used to Refer to Subscripts by Name
      PARAMETER(OLD=1,MID=2,NEU=3,TOT=4)    ! Constants Used to Refer to Subscripts by Name
      PARAMETER(OLD_RATE=1,NEW_RATE=2)      ! Constants Used to Refer to Subscripts by Name
      REAL ClinkPrat(maxstps)               ! Price increase to change clinker flows, use 2008 as base year


    REAL IND_FLOW(maxstps,5)

	INTEGER irx,isx



      IF(ISUBTR.EQ.1.AND.IOPEN.EQ.1.AND.LSTITER.EQ.1) &
        WRITE(IUNIT1,991)

! set up regression parameters for primary production ratio for Aluminum
      data alslope/-0.000199,-0.000856,0.000324,-0.00227/
      data alslopelag/-0.0001928,0.001498,-0.00142,-0.0003944/
      data alintercept/0.5645,0.10153,0.993048,2.1385/
      data albaseratio/0.23,0.29,0.41,0.36/	! from 2006 USGS data; 2006 [primary / (primary + secondary)] ratio
      data alefficiency/1.0,1.0,1.0,1.0/    ! factors in changes for electricity; 1.0 assumes 14500 kWh/ton
      data alhistratio/0.25,0.29,0.26,0.21,0.36,0.42,0.42,0.46,0.41,0.44,0.35,0.34,0.49,0.51,0.50,0.50/
      DATA ALPHA/1.0,2.5,3.0,3.5,4.0,4.5,5.0/
!     DATA ALPHA/1.0,4.0,4.5,5.5,6.5,7.5,8.5/

!     CASE=1
!     DELTA = 0.0
      IY = IYR - baseyr + 1
      IR = INDREG
! *** assign the behave runtime variable            ***
! *** the values are 1=lazy, 2=normal, 3=aggressive ***
! *** normal is normally the default                ***
      behave=rtovalue('BEHAVE  ',2)

      do is = 0,maxstps
         RetireRate(is)=0.0
      enddo
! function AveSPrc returns change in regional prices used for this step since history .
! use as price variable on retirement function
      do is=1,MPASTP
        RetirePrat(is)=AveSPrc(ir,ibyr2-1989,curiyr,is)  ! last historical price year is IND base year
        ClinkPrat(is) =AveSPrc(ir,19,curiyr,is)  ! for clinker flow rate change use 2008 as clinker base year
     !   if(RetirePrat(is).lt.1.1) RetirePrat(is)=1.0   ! only price changes >10 % influence retires
      enddo


!
!   If this is a RETIREMENT SENSITIVITY CASE,
!   Adjust Retirement Rates by sensitivity multiplier
      IF(IRETIRE.EQ.1.AND.curcalyr.EQ.IBYR+2) THEN  ! POT_IBYROTHER 2008 to IBYR+2
         DO IS = 1,MPASTP
          PRODRETR(IS)=MIN(0.9,RETRATE*PRODRETR(IS))
         ENDDO
       endif

! set the default retirement rate; can be changed below for specified scenarios
      do is=1,MPASTP
        RetireRate(is)=PRODRETR(is)             ! retirement rate from prodflow.txt
      enddo

! modify retirement rate as a function of price increases.  No change
! if average energy prices have not increase.


      DO IS = 1,MPASTP

        X=RetirePrat(is)**RetireBeta
        RetirePriceFactor=X/(1.0+X)

        if(curcalyr.gt.techstrtyr) then
          if(frztech.eq.1)then !if frozen technology, change Retirements
            RetireRate(is)=PRODRETR(IS)*RetirePriceFactor  ! if no price change, rate is 0.5 of default rate
          elseif(hitech.eq.1)then !if high technology, change Retirements
            RetireRate(is)=3.0*PRODRETR(IS)*RetirePriceFactor
          else
            RetireRate(is)=2.0*PRODRETR(IS)*RetirePriceFactor
          endif
         endif
      enddo

      prodcur=prodlag  ! initialize from prior year, every iteration
      idlcap=idlcaplag ! initialize from prior year, every iteration

!    Restore any capacity that was idled last year.
!    retire the OLD and MIDDLE Production Capacity

      DO IS=1,MPASTP
        PRODCUR(MID,IS)=PRODCUR(MID,IS)+PRODCUR(NEU,IS)   ! Put last year's NEW into this year's MID
        PRODCUR(OLD,IS)=PRODCUR(OLD,IS)+IDLCAP(IS)        ! Add back any Idled Capacity from Last Year
        IDLCAP(IS)=0.                                     ! Initialize Idle Capacity
        PRODCUR(NEU,IS)=0.0                               ! Initialize New  Capacity

        PRODCUR(OLD,IS)=PRODCUR(OLD,IS)*(1.0-RetireRate(IS))
        PRODCUR(MID,IS)=PRODCUR(MID,IS)                 ! mid not retired *(1.0-RetireRate(IS))

        PRODCUR(TOT,IS)=PRODCUR(OLD,IS)+PRODCUR(MID,IS)
      ENDDO

!  Assign the eXogenous PRODuction requirements (PRODX), possibly
!  adjusting the units (dollars or tons) based in industry option IDVAL.
!  For PHYSICAL UNITS (tons) (IDVAL=1), Convert units using
!  the fixed relationship between dollar value and physical value (PHDRAT).
!  NOTE: The proper pronunciation of PHDRAT is FUD'-RAT.


      IF(IDVAL.EQ.1) THEN
        PRODX=PHDRAT*PRODVX
      ELSEIF(IDVAL.EQ.2) THEN
        PRODX=PRODVX
      ENDIF
!
!    Break exogenous production out into a base year component, Post-base year component,
!    and a new component.  This is for compatibility with the process step
!    vintaging.
!
! NSK ibyr2 update 7/2020  
  IF ((inddir .eq. 8) .or. (inddir .eq. 10) .or. (inddir .eq. 11) .or. (inddir .eq. 12) .or. (inddir .eq. 13)) then ! Process-flow industries     
      IF(IYR.EQ.ibyr2+1) PRODXIBYR(INDDIR,INDREG)=PRODXLAG !MECS reset to ibyr2 (process-flow industries)
  ELSE                                                                                                              ! End-use industries
      IF(IYR.EQ.ibyr2+1) PRODXIBYR(INDDIR,INDREG)=PRODXLAG !MECS reset to ibyr2 (end-use industries)
  ENDIF
      
      PRODXMID=PRODXLAG-PRODXIBYR(INDDIR,INDREG)
      PRODXNEW=PRODX-PRODXLAG

!      IF(IYR.EQ.IBYR+1) PRODXIBYR(INDDIR,INDREG)=PRODXLAG !MECS reset to IBYR
!      PRODXMID=PRODXLAG-PRODXIBYR(INDDIR,INDREG)
!      PRODXNEW=PRODX-PRODXLAG

      IF(PRTDBGI.gt.1) THEN
        write(6,*) 'PRODXLAG)=',PRODXLAG
        write(6,*) 'PRODX=',PRODX
        write(6,*) 'PRODXNEW=',prodxnew
        write(6,*) 'PRODXMID=',prodxmid
        write(6,*) 'PRODXIBYR =',PRODXIBYR(inddir,indreg)
      endif

      IF(PRTDBGI.gt.1) THEN
        write(6,*) ' PRODCUR, After retirement calcs'
        call prodout
      ENDIF

! For Food sub-industry analysis, fill prodflow based on subindustry shipment share of
! total food shipments for years after the baseyear.  POT_07/31/2013
    if(inddir.eq.7) then
       DO IS=1,MPASTP
          isub=((is-1)/4)+1                                                 ! subindustry 1 to 4 with 4 steps each
          prodflow(1,IS,1)=foodship(isub,indreg,iyr)/foodship(5,indreg,iyr) ! sub-industry share of food shipments
          prodflow(2,IS,1)=prodflow(1,IS,1)
       enddo
    endif
! POT_07/31/2013 END

!   Revise prodflow for the cement clinker steps to reflect a combination of increased imports
!   and increased production of blended cements.  The revision is a function of price change
!   for the step
!   At the end of the routine restore prodflows to original values so the change is not cumulative
     ImportFac=1.0     ! initialize import factor to 1.0, i.e., no change
!SUSAN: CHANGED CODE TO CHECK ON STEOLASTYR - INDBMOVR2. INDBMOVR2 IS READ IN FROM SCEDES. =0 FOR REFERENCE CASE AND 2 FOR SIDE CASES.
!END SUSAN:
      if (inddir.eq.11.and.curcalyr.gt.(STEOLastYr - INDBMOVR2)) then  ! clinker flows change only after steo benchmarking
       keepPF=prodflow
       do is=1,MPASTP
        if (ClinkPrat(is).gt.1.0) then
           ImportFac = ImpScalar+(1 / (5.0*ClinkPrat(is)))  ! if price is unchanged, ImportFac=1.0;
                                                      ! if price doubles, ImportFac=0.9
        endif
        DO IT=1,NTMAX(IS)    ! for each downstep
         if (is.eq.2) then
           prodflow(1,is,it) = ImportFac*prodflow(1,is,it)
           prodflow(2,is,it) = ImportFac*prodflow(2,is,it)
         endif
         if (is.eq.3) then
           prodflow(1,is,it) = WetFac*ImportFac*prodflow(1,is,it) ! plus factor for wet kilns
         endif
        enddo
       enddo
      endif

!Construct I/O coefficient matrix (eg. matrix A) for old, new capacity using
!     the production flow rates (prodflow).  That is,
!     Aij gives flowrate of input i to produce a unit of output j.  Then
!     Formulate the corresponding "I/O technology matrix" (eg. I-A), such that
!     (I-A) X = D   , where X is the solution vector, D is the final demand vector.
!     Invert matrix (I-A) to solve for X:
!               -1
!      X = (I-A)    D
!
!     Let IAnew_inv = inverse of (I-A) for new capacity

      Xnew(1:maxstps+1)   = 0.
      Xold(1:maxstps+1)   = 0.
      Xsurv(1:maxstps+1)  = 0.
      IAold(1:MAXSTPS+1,1:MAXSTPS+1)      = 0.
      IAnew(1:MAXSTPS+1,1:MAXSTPS+1)      = 0.
      IAnew_inv(1:MAXSTPS+1,1:MAXSTPS+1)  = 0.
      IAold_inv(1:MAXSTPS+1,1:MAXSTPS+1)  = 0.

      D(1:MAXSTPS+1)      = 0.
      if(inddir.ne.9) then ! for other than chemicals, put final demand in first element
        D(1) = PRODX
      else                 ! for chemicals, put subindustry final demands in associated steps
        DO IS=1,MPASTP
          if(index(indstepname(is),'STEAM').eq.0) then   ! for all but the steam steps...
            isub=((is-1)/6)+1                                ! subindustry 1 to 4
            D(IS+1)=chemship(ISUB,indreg,curcalyr)
          endif
        enddo
      endif

      if (inddir.eq.13 ) then                                                        ! Aluminum Industry prodflow adjustment
         alprodflowtotal(indreg) = prodflow(old_rate,3,1) + prodflow(old_rate,4,1)  ! Add primary and secondary production
         if (curiyr.ge.17 .and. curiyr.le.21 ) then                                  ! Between 2006 and 2010
            alratio(indreg) = alhistratio(curiyr-17,indreg)                         ! Peg historical ratios with USGS data
         else
            alratio(indreg) = prcx(2,indreg,2) * 0.003412 * 14500 * alslope(indreg) + &
                           prcxlag(2,indreg,2) * 0.003412 * 14500 * alslopelag(indreg) + &
                           alintercept(indreg)
         end if

         prodflow(old_rate,4,1) = alratio(indreg) * alprodflowtotal(indreg)         ! Reallocate prodflow between primary and secondary
         prodflow(old_rate,4,2) = prodflow(old_rate,4,1)                            !   Set downstep = upstep
         prodflow(old_rate,3,1) = alprodflowtotal(indreg) - prodflow(old_rate,4,1)  !
         prodflow(old_rate,3,2) = prodflow(old_rate,3,1)                            !
         write (IFEEDOUT,*) 'prodflow elements revisited'
         write (IFEEDOUT,*) prodflow(old_rate,4,1),prodflow(old_rate,4,2),prodflow(old_rate,3,1),prodflow(old_rate,3,2),prodflow(old_rate,5,1)
         write (IFEEDOUT,*) 'year = ',curcalyr
         write (IFEEDOUT,*) 'indreg = ',indreg
         write (IFEEDOUT,*) 'ratio = ',alratio(indreg)

      end if

! fill Input-Output Matrices
      IAold(1,1)=1.
      IAnew(1,1)=1.
      DO IS=1,MPASTP                                      ! for each process step

        IAold(is+1,is+1)=1.  ! 1s along dominant diagonal represent the Identity matrix
        IAnew(is+1,is+1)=1.  ! 1s along dominant diagonal represent the Identity matrix

        DO IT=1,NTMAX(IS)    ! for each downstep.. (note, IT<>IS)

          DOWN_STEP = IPASTP(IS,IT)

          IAold(IS+1,down_step+1)=0.-prodflow(old_rate,is,it)
          IAnew(IS+1,down_step+1)=0.-prodflow(new_rate,is,it)
        enddo

      enddo


! Invert the input-output matrices.
!   Initialize inverted matrices as the identity matrix
      DO IS=1,mpastp+1
        IAnew_inv(is,is)=1.
        IAold_inv(is,is)=1.
      enddo
      det = MINVERT(IAnew,IAnew_inv,mpastp+1,mpastp+1,Real8A1,Real8A2,maxstps+1)

666 FORMAT(I2,1X,8F7.3)

      if(det.eq.0. .and. prtdbgi.gt.1) then
         write(6,*) ' singular matrix found in CALPROD, inddir,indreg=',inddir,indreg
      endif
      det = MINVERT(IAold,IAold_inv,mpastp+1,mpastp+1,Real8A1,Real8A2,maxstps+1)
      if(det.eq.0. .and. prtdbgi.gt.1) then
         write(6,*) ' singular matrix found in CALPROD, inddir,indreg=',inddir,indreg
      endif

!********************************************


      Xsurv(1) = PRODCUR(OLD,1)/prodflow(OLD_RATE,1,1) ! first step always a final demand step.
      Xsurv(1) = D(1) ! this does not make any difference from Xsurv(1) = PRODCUR(OLD,1)/prodflow(OLD_RATE,1,1)
!      Xsurv(1) = PRODXIBYR(INDDIR,INDREG) * (1.0 - PRODRETR(1))**(iyr-IBYR) ! "retire" final demand that can no longer be met by surviving capacity

      Xsurv(2:MPASTP+1)=PRODCUR(OLD,1:MPASTP)

! final demand that can be met by the surviving capacity is given by:
! Dsurv=IAold * Xsurv.  (matrix multiplication).  Some of Dsurv(2:maxstps+1) may be nonzero
! due to differential retirement rates by steps

      Dsurv = MATMUL(IAold,Xsurv)
      Dnew = D - Dsurv

!     if(inddir.eq.12.and.dnew(8).gt.0.) dnew(8)=0. ! don't attempt to add coking capacity
      if(inddir.eq.12.and.dnew(4).gt.0.) dnew(4)=0. ! don't attempt to add ingot capacity
!w      Xnewk = matmul(IAnew_inv , Dnew)  ! cumulative new capacity add since beginning
      Xnew = matmul(IAnew_inv , Dnew)  ! cumulative new capacity add since beginning but
      Xold = matmul(IAold_inv , Dnew)


! determine this year's additions from total less mid vintage stuff already added.
      PRODCUR(NEU,1:MPASTP) = Xnew(2:MPASTP+1) - prodcur(MID,1:MPASTP)
!t3      if (inddir.eq.13 .and. curiyr.le.21) then
      if (inddir.eq.13) then
          PRODCUR(NEU,1:MPASTP) = 0.0*Xnew(2:MPASTP+1) + 1.0*Xold(2:MPASTP+1) - prodcur(MID,1:MPASTP)
!t2      else if (inddir.eq.13 .and. curiyr.gt.21) then
!t2          PRODCUR(NEU,1:MPASTP) = 0.5*Xnew(2:MPASTP+1) + 0.5*Xold(2:MPASTP+1) - prodcur(MID,1:MPASTP)
      end if
!   Treat a negative result for new capacity as a temporary
!   idling of capacity.

      DO IS=1,MPASTP
        IF(PRODCUR(NEU,IS).LT.0.) THEN
          IDLCAP(IS)=-1.*PRODCUR(NEU,IS)
          PRODCUR(NEU,IS)=0.
        ENDIF
        IDLED_OLD = MIN(PRODCUR(OLD,IS) , IDLCAP(IS))              ! Idle as much OLD capacity as possible
        IDLED_MID = MIN(PRODCUR(MID,IS) , IDLCAP(IS) - IDLED_OLD)  ! Idle as much of the rest from MID capacity as possible
        IDLCAP(IS) = IDLED_OLD + IDLED_MID                         ! recalculate idled based on limits


        PRODCUR(OLD,IS) = PRODCUR(OLD,IS) - IDLED_OLD         ! Amount of Production from Old Capacity
        PRODCUR(MID,IS) = PRODCUR(MID,IS) - IDLED_MID         ! Amount of Production from MID Capacit
        PRODCUR(TOT,IS) = PRODCUR(OLD,IS)+PRODCUR(MID,IS)+PRODCUR(NEU,IS)
        if (inddir.eq.13) then
          bauxite(indreg) = prodcur(tot,4)                    ! Bauxite requirement is linked to primary AL production
        end if
        if (inddir.eq.13 .and. indreg.eq.3) then
          write (IFEEDOUT,*) 'is & curiyr = ',is,curiyr
          write (IFEEDOUT,*) 'idled_old ','idled_mid ','prodcur(old) ','prodcur(mid) ','prodcur(tot)  '
          write (IFEEDOUT,*) idled_old,idled_mid,prodcur(old,is),prodcur(mid,is),prodcur(tot,is)
          write (IFEEDOUT,*) 'xold ','xnew'
          write (IFEEDOUT,*) xold(is+1),xnew(is+1)
          write (IFEEDOUT,*) 'prodcur(neu,is) = ',prodcur(neu,is)
          if (is.eq.5) then
            prodcur(tot,5) = (bauxite(1) + bauxite(2) + bauxite(3) + bauxite(4)) * 1.6      ! All bauxite refining is in region 3
          end if
          write (IFEEDOUT,*) 'RRRRR idled_old ','idled_mid ','prodcur(old) ','prodcur(mid) ','prodcur(tot)  '
          write (IFEEDOUT,*) idled_old,idled_mid,prodcur(old,is),prodcur(mid,is),prodcur(tot,is)
        end if

      ENDDO
!  calculate co2 emissions (in carbon units) for clinker production
!  since lime mfg emissions can be calculated anywhere, do that here as well
       if (inddir.eq.11) then
         if(ir.eq.1) then
            co2_clink(iy,1:5)=0.
            co2_lime(iy,1:5)=0.
         endif

         co2_clink(iy,ir)=clinkFac*(prodcur(TOT,2)+prodcur(TOT,3)+prodcur(TOT,5)) ! dry+wet+dry-bal
! problem with this next line is that the lime industry model may not have been called yet so the value is from the prior year or region
         co2_lime(iy,ir) =CO2_process   !Use lime process emissions from new sub-model
                                        !1000*LimeFac*SCGMisc(ir,iy) previous method
         if(ir.eq.4) then
           co2_clink(iy,5) =sum(co2_clink(iy,1:4))
           co2_lime(iy,5)  =sum(co2_lime(iy,1:4))
         endif
      endif

! Restore cement prodflow for dry kilns to original value
!SUSAN: CHANGED CODE TO CHECK ON STEOLASTYR - INDBMOVR2. INDBMOVR2 IS READ IN FROM SCEDES. =0 FOR REFERENCE CASE AND 2 FOR SIDE CASES.
!END SUSAN:
      if (inddir.eq.11.and.curcalyr.gt. (STEOLastYr - INDBMOVR2)) then  ! clinker flows change only after steo benchmarking
       prodflow=keepPF
      endif

!***************************************************************
!	Determine regional allocation of flows for revised Aluminum model using PRODCUR values
! the following needs to be done for all four regions before aluminum industry model can be called. So this should
! be done when version.eq.'original' to set the stage.
        IF (inddir.eq.13.or.inddir.eq.11.or.inddir.eq.10) THEN                                   ! We can add a dimension to make it industry-specific if desired
          if(ir.eq.1) then
            ind_flow(:,:)=0.
          endif
          DO IS=1,MPASTP
            IND_FLOW(is,ir) = PRODCUR(TOT,IS)                                 ! Keep track of total material flows out of each process step, by region
          ENDDO
          IF (ir.eq.4) THEN
            DO IS=1,MPASTP
              IND_FLOW(is,5) = SUM(IND_FLOW(is,1:4))                       ! Add across regions after all the cycling is done
            ENDDO
            IF(inddir.eq.11) THEN                                                ! Cement-specific step
              DO irx = 1,5
                IND_FLOW(2,irx) = IND_FLOW(2,irx) + IND_FLOW(5,irx)     ! Adjust dry-process output for cement
              ENDDO
            ENDIF
         
            IF(inddir.eq.13) THEN
			    primprod_percent(iy)=ind_flow(4,5)/(ind_flow(4,5)+ind_flow(3,5))  !set primary production percent for AL--																			  ! note: legacy prodcur step index used because prodcur is calculated by legacy code
				if (curcalyr.le.ibyr2+1) primprod_percent(iy) = min(0.32,primprod_percent(iy))              ! POT_ibyr215
			    if (curcalyr.eq.2016) primprod_percent(iy) = min(0.20,primprod_percent(iy)) ! primary production 19% in 2016
				if (curcalyr.gt.2016) primprod_percent(iy) = min(0.25,primprod_percent(iy))                            ! in subsequent years, primary production is constrained at 25%

			ENDIF

            DO IS=1,MPASTP
              DO irx = 1,4
                IND_FLOW_SHARE(inddir,is,irx) = IND_FLOW(is,irx) / IND_FLOW(is,5)    ! Calculate regional shares of output by process step
              ENDDO
            ENDDO
          ENDIF
        ENDIF

!	Note: for Cement, IND_FLOW_SHARE ratios are used to regionalize energy demand as follows:

!                       is = 1    Finish Grinding demand
!                       is = 2    Dry Process demand
!	                  is = 3    Wet Process demand
!                       is = 4,5  Ignored

!	For Aluminum, IND_FLOW_SHARE ratios are used to regionalize energy demand as follows:

!	                  is = 1,2  Ignored
!	                  is = 3    Secondary Production
!                       is = 4    Smelting & Anode Production
!                       is = 5    Alumina Refining & Boilers

!     For Glass, IND_FLOW_SHARE across process steps will be the same.
!           This is because, unlike Aluminum or Cement, there is no change in mass
!           betweens process steps

!***************************************************************






  991 FORMAT(3X,'CALPROD')
      IF(PRTDBGI.gt.1) THEN
        write(6,*) ' PRODCUR, After All calcs'
        call prodout
      ENDIF
      END SUBROUTINE CALPROD
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!   Debug Printing Routine called from CALPROD
!
      SUBROUTINE PRODOUT
   use i_
      implicit none

      integer is,iv
      character*10 vintage(5)/ &
       '     Idle', &
       '      Old', &
       '      Mid', &
       '      New', &
       '      Tot'/
      write(6,'(/18x,5a10)') (vintage(iv),iv=1,5)
      do is=1,MPASTP
         write(6,'(1x,a,5f10.1)') indstepname(is)(:18), &
        idlcap(is),(prodcur(iv,is),iv=1,4)
      enddo
      write(6,*) ' '
      RETURN
      END SUBROUTINE PRODOUT
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!  THIS SUBROUTINE CALCULATES THIS YEAR'S UECS BASED ON
!  CONSERVATION/TECHNOLOGICAL SAVINGS CURVES.
!  THE OLD,MID AND NEW UECS ARE RECALCULATED.
!****
        SUBROUTINE CALCSC(IFUEL,ISTEP)
! Updated to implement dynamic TPC for the end-use models

   use i_
      IMPLICIT NONE
      real AveFPrc
      external AveFPrc
      INTEGER INDBMOVR2
      INTEGER INDBMOVR

      INTEGER IFUEL,ISTEP,IV,IFX
    !  REAL TCAL! ,UEC(20)
     ! REAL MINREI
    !  REAL INDPRICE(4)
    !  REAL DELTA
     ! REAL TEMPTPC
     ! INTEGER CASE,IY


! Variables for price sensitive TPC
      REAL TPCBeta        ! Logit coefficient for use in choice between default and maximum TPC rate
      REAL TPCMaxRate     ! Maximum TPC rate
      REAL TPCPrat        ! Ratio of current Prices to base year Prices
    !  REAL TPCPriceFactor ! Multiplier on TPC rate due to energy price response
      REAL TPCRate(3)     ! TPC rate after application of price sensitivity parameter(by step)
      Real X

    !  real minpint(3)     ! minimum ENPINT (uec) associated with enr year REI

! variables for the aggressive consumer response scenario
    
    !  real penfac/3.0/!factor changes market penetration in aggressive consumer scenario
     ! real minpintfac(3)     ! factor to reduce minpint for old and new vintage
      
        ! Define some new variables, some of which may be read in from an input file.  
       
	Integer T_Mid(15,maxstep)            ! Year of inflection point in logistic curve
	Integer T_Shift(15,maxstep)          ! Calibration of curve shape (time shift) 
	REAL alpha_1(maxstep)                ! Time dependence coefficient
	REAL alpha_2(maxstep)                ! Price dependence coefficient
	REAL beta_1(maxstep)                 ! Logit Exponent 
    
    REAL REI(3,15,maxstep)       ! REI 
	REAL REI_Adj(3,15,maxstep)       ! REI adjustment to UEC
	REAL REI_Adj_Lag(3,15,maxstep)   ! Lagged value of REI adjustment
	

    ! set the values for testing
    beta_1(istep)=2.0
    alpha_1(istep)=1.0
    T_Shift(ifuel,istep)=4
    T_Mid(ifuel,istep)=15
    alpha_2(istep)=1.0
      
      ! Set the alpha coeffiients to zero for frozen tech case; JRM 11/10/19
      IF(curcalyr.GT.techstrtyr.AND.FRZTECH.EQ.1) THEN
        alpha_1(istep) = 0.0
        alpha_2(istep) = 0.0
      ENDIF
          
     ! IY = IYR - 1989
      IR = INDREG
	REI(1,ifuel,istep) = ((1.+bcsc(1,ifuel,istep))**float(ijumpcalyr-ibyr2+1))          ! REI Old
	REI(3,ifuel,istep) = ((1.+bcsc(3,ifuel,istep))**float(ijumpcalyr-ibyr2+1))          ! REI New
	REI(2,ifuel,istep) = REI(3,ifuel,istep)                                          ! REI Existing  (superfluous?)

! Note: TPCPrat is the result of a function that returns the ratio of fuel prices relative to the base year	
    ifx=ifloc(ifuel,istep)
    TPCPrat=AveFprc(ir,ibyr2-1989,curiyr,ifx) ! AveFPrc returns price change since history ended (ie the base year)
    IF (curcalyr.eq.ibyr2+1) REI_Adj(1:3,ifuel,istep) = 1.0          ! Initialize REI in base year
	REI_Adj_Lag(1:3,ifuel,istep) = REI_Adj(1:3,ifuel,istep)        ! Hold lagged value for subsequent TPC calculation
	Do iv=1,3,2                         ! Do for old and new vintages; existing vintage will be set to 'new' value
	  REI_Adj(iv,ifuel,istep) = 1.0 + (REI(iv,ifuel,istep)-1.0) * (1.0 - (1.0 / &
	                            (1.0 + (alpha_1(istep) * (Max((curcalyr-ibyr2-T_Shift(ifuel,istep)),0)     &
		                        / (T_Mid(ifuel,istep)-ibyr2-T_Shift(ifuel,istep)))    & 
								+  alpha_2(istep) * (Max(TPCPrat - 1.0,0.0)))**beta_1(istep))))
	  TPCRate(iv) = min(REI_Adj(iv,ifuel,istep) / REI_Adj_Lag(iv,ifuel,istep) , 1.0)       ! Dynamic TPC for this time period
    enddo
    TPCRate(2)=TPCRate(3)                               ! Current-vintage plants improve at the same rate as new plants
 
    IF(INDDIR.EQ.1.OR.INDDIR.EQ.2) CALL AGTPC(IFUEL,ISTEP)                  ! Calculate TPCs for Agriculture Sectors (Crop & Other)
    IF(INDDIR.EQ.3)  CALL COALTPC(IFUEL,ISTEP)                ! Calculate TPCs for Coal Mining sector
    IF(INDDIR.EQ.4) CALL OGSMTPC(IFUEL,ISTEP)                ! Calculate TPCs for Oil & Gas sector; OGSM values not set on first iteration so don't call
    IF(INDDIR.EQ.5)  CALL OTH_MINTPC(IFUEL,ISTEP)                ! Calculate TPCs for Other Mining sector
!   IF(INDDIR.EQ.6) CALL CONTPC(IFUEL,ISTEP)                 	! Calculate TPCs for the Construction sector
	
	! 9/6/2016 Call to CON Subroutine commented out by MSN. This call erroneously assumes that CON is split into the 3 categories
    ! of building construction, civil engineering, and trade. This is no longer true (in the program). Commenting out this call to CON Subroutine until
	! long-term fix can be made to properly split CON into it's three subcategories again.

!***
!    CHECK TPC SENSITIVITY FLAG "ITPC" SET TO ONE. IF SO
!    APPLY TPC MULTIPLIER "TPC" IN Beginning with first year after STEO
!***
!SUSAN: CHANGED CODE TO CHECK ON STEOLASTYR - INDBMOVR2. INDBMOVR2 IS READ IN FROM SCEDES. =0 FOR REFERENCE CASE AND 2 FOR SIDE CASES.
!END SUSAN:
      IF(curcalyr.GT.(STEOLastYr - INDBMOVR2).AND.ITPC.EQ.1) THEN      ! ITPC: Sensitivity Flag (currrently set to 0 in indrun.txt)
        BCSC(1,IFUEL,ISTEP)=TPC1*BCSC(1,IFUEL,ISTEP)     ! TPC1: Sensitivity factor for old plants (=1.0 in indrun.txt)
        BCSC(3,IFUEL,ISTEP)=TPC2*BCSC(3,IFUEL,ISTEP)     ! TPC2: Sensitivity factor for new plants (=1.0 in indrun.txt)
      ENDIF
      !  I'm not sure how to accommodate this (code above), but maybe we can use the sensitivity factor to adjust the exponent, like: JRM 11/10/19
!	beta_1(istep) = TPC1 * beta_1(istep)    ! Doing this would require having a vintage index for the coefficients, I suppose.

         
      ! Set the alpha coeffiients to zero for frozen tech case; JRM 11/10/19
      IF(curcalyr.GT.techstrtyr.AND.FRZTECH.EQ.1) THEN
        alpha_1(istep) = 0.0
        alpha_2(istep) = 0.0
      ENDIF	
      
     ! 
     ! TPCBeta=4.0
     ! if (BCSC(1,ifuel,istep).gt.0.0) TPCBeta=(1.0/TPCBeta) !Prevent counterintuitive effect on positive TPC's
      ifx=ifloc(ifuel,istep)
  !    if (ifx.lt.1) then
        !write(*,*) 'debug fuel not found in CALCSC',ifuel,istep,inddir,curiyr+1989
    !  else
   !     TPCPrat=AveFprc(ir,ibyr2-1989,curiyr,ifx) ! AveFPrc returns price change since history ended (ie the base year)
   !   endif
	  !x=TPCPrat**TPCBeta              ! logistical function to get s-shape response
     ! TPCPriceFactor=X/(1.0+X)        !
     

! Instead of using EINTER (the base year UEC), use
! last year's UEC and implement one year's worth of
! technological progress.  This will allow any improvements
! due to price factors to be incorporated as well.
! Do not Apply tech progress
! to the mid-vintage productive capacity

      DO IV=1,3,2
        ENPINT(IV,IFUEL,ISTEP)=ENPINTLAG(IV,IFUEL,ISTEP)* TPCRate(iv)
      ENDDO
     IF (prodlag(2,istep)+prodlag(3,istep).gt.0.0) THEN

! compute average UEC (enpint) for mid-vintage
        iv=2
        ENPINT(2,IFUEL,ISTEP)= &
         (prodlag(2,ISTEP)*ENPINTLAG(2,IFUEL,ISTEP)+ &
           prodlag(3,ISTEP)*ENPINTLAG(3,IFUEL,ISTEP))/ &
          (prodlag(2,istep)+prodlag(3,istep))              !  mid not tpc'd
      

      ENDIF

! *** for frozen tech case assume all new adds are at the average *** c
! *** base case assumes that new adds will be at the average of   *** c
! *** of installed avg plus state-of-the-art                      *** c
! *** cannot use minpints for frozen run at this time             *** c

      if (curcalyr.gt.techstrtyr.and.frztech.eq.1) then
          enpint(1,ifuel,istep) = ENPINTLAG(1,IFUEL,ISTEP)
          enpint(3,ifuel,istep) = ENPINTLAG(3,IFUEL,ISTEP)
      ENDIF
      
      
      if(curcalyr.gt.techstrtyr.and.frztech.eq.1)return


  991 FORMAT(3X,'CALCSC')
      RETURN
      END SUBROUTINE CALCSC
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!  THIS SUBROUTINE CALCULATES THE BYPRODUCT ENERGY CONSUMPTION
!  IN THE PROCESS AND ASSEMBLY COMPONENT.  IT IS ASSUMED AT THIS
!  POINT (2/12/93) THAT ALL BYPRODUCT ENERGY IS CONSUMED IN
!  IN THE BOILER/STEAM COGEN COMPONENT.
!****
      SUBROUTINE CALBYPROD
   use i_
      IMPLICIT NONE
      real AveFPrc
      external AveFPrc

      INTEGER IS,IFuel,IV,IFX,IFY,iy
      REAL DELPROD,TPROD
      REAL TPCPrat        ! Ratio of current Prices to base year Prices
      Real X,TPCBeta/4./  ! Logit coefficient to choose maximum TPC rate
      REAL TPCRate(3) ! TPC rate after application of price sensitivity parameter(by step)
      REAL TPCPriceFactor ! Multiplier on TPC rate due to energy price response
      real TPC1Pap    ! internal TPC(old) for non-mfg
      real TPC3Pap    ! internal TPC(new) for non-mfg
      integer rtovalue,behave,hirenew,lorenew

      IY = IYR - 1989
      IR = INDREG

      behave=rtovalue('BEHAVE  ',2) ! read value of behave, default to 2 if not found
      hirenew=rtovalue('HIRENEW ',0) ! read value of hirenew, default to 0 if not found
      lorenew=rtovalue('LORENEW ',0) ! read value of lorenew, default to 0 if not found

!****
!  CALCULATE FOR EACH PROCESS STEP AND FOR EACH BYPRODUCT,
!  IF THE LAGGED TOTAL THROUGHPUT FOR A PROCESS STEP IS NOT ZERO,
!  THEN CALCULATE THE 'EFFICIENCY' OF WASTE MATERIALS PRODUCED
!  BASED ON SOME TECHNICAL EFFICIENCY.
!  Note that the enprod default is for the bypcsc (aka tpc) to be zero ***
!  Allow the TPC to increase for the paper industry is industrial prices increase
!  sufficiently. The idea is that higher prices will lead to greater biomass recovery.
!****

! **** for the high renewable scenario, set hitech = 1 at the start of this loop ****
! **** at the end of the loop, set hitech = 0                                    ****
! **** for the low renewable scenario, set frztech = 1 at the start of this loop ****
! **** at the end of the loop, set frztech = 0                                   ****

      if (hirenew.eq.1.and.curcalyr.gt.techstrtyr) hitech=1
      if (lorenew.eq.1.and.curcalyr.gt.techstrtyr) frztech=1


! biomass UEC will go up slightly *** c
      do is=1,mpastp
        do ifuel=1,ifbyp(is)
           bypcsc(1,ifuel,is)=0.003
           bypcsc(3,ifuel,is)=0.003
        enddo
      enddo

!****
!  CALCULATE THIS YEAR'S RATE OF BYPRODUCT ENERGY PRODUCED including price
!  sensitive tpc effect, if any.  Here, its more byproduct with higher prices
!****

      DO 60 IS=1,MPASTP
        DO 60 IFuel=1,IFBYP(IS)
          ifx=iflocby(ifuel,is)
          
! NSK ibyr2 update 7/2020
    IF ((inddir .eq. 8) .or. (inddir .eq. 10) .or. (inddir .eq. 11) .or. (inddir .eq. 12) .or. (inddir .eq. 13)) then   ! Process-flow industries
              TPCPrat=AveFprc(ir,ibyr2-1989,curiyr,ifx)  ! AveFPrc returns price change since last history year (ie the base year)
    ELSE                                                                                                                ! End-use industries
              TPCPrat=AveFprc(ir,ibyr2-1989,curiyr,ifx)  ! AveFPrc returns price change since last history year (ie the base year)
    END IF     
      
          TPCPrat=AveFprc(ir,ibyr2-1989,curiyr,ifx)  ! AveFPrc returns price change since last history year (ie the base year)
!      if(TPCPrat.lt.1.1) TPCPrat=1.0  ! Don't change TPC unless price change > 1.1
! if prices have not increased the base case is used
! *** do this only for fuel 42 (biomass) and fuel 43 (pulping liquor)
        if    ((ifx.eq.42.or.ifx.eq.43).and.(TPCPRat.ge.1.1) &
              .and.(frztech.ne.1) &
              .and.(hitech.ne.1) &
              .and.(behave.eq.2)) then                  ! prices go up, no tech scenarios
                bypcsc(1,ifuel,is)=0.004
                bypcsc(3,ifuel,is)=0.004
        elseif ((ifx.eq.42.or.ifx.eq.43) &    !.and.(TPCPRat.ge.1.10)
               .and.(hitech.eq.1.and.hirenew.ne.1.and.curcalyr.gt.techstrtyr) &
               .and.(behave.eq.2)) then                 ! prices do not matter, high tech scenario
                bypcsc(1,ifuel,is)=0.007
                bypcsc(3,ifuel,is)=0.007
        elseif ((ifx.eq.42.or.ifx.eq.43) &    !.and.(TPCPRat.ge.1.10)
               .and.(hitech.eq.1.and.hirenew.eq.1.and.curcalyr.gt.techstrtyr) &
               .and.(behave.eq.2)) then                 ! prices do not matter, high renewables scenario
                bypcsc(1,ifuel,is)=0.013
                bypcsc(3,ifuel,is)=0.013
        elseif ((ifx.eq.42.or.ifx.eq.43) &    !.and.(TPCPRat.ge.1.10)
               .and.(frztech.eq.1.and.curcalyr.gt.techstrtyr) &
               .and.(behave.eq.2)) then                 ! prices do not matter, frozen tech scenario
                bypcsc(1,ifuel,is)=0.0
                bypcsc(3,ifuel,is)=0.0
        endif
        TPC1Pap=bypcsc(1,ifuel,is)
        TPC3Pap=bypcsc(3,ifuel,is)

        x=TPCPrat**TPCBeta          ! logistical function to get s-shape response
        TPCPriceFactor=X/(1.0+X)    !
        if(isnan(TPCPriceFactor)) TPCPRICEFACTOR=.5
        TPCRate(1)=2.0*TPC1Pap * TPCPriceFactor
        TPCRate(3)=2.0*TPC3Pap * TPCPriceFactor
        DO IV=1,3,2
          BYPINT(IV,IFuel,IS)=BYPINTLAG(IV,IFuel,IS) &
                           * exp(TPCRate(IV))
!        enddo
!60    CONTINUE

      if(prodlag(2,is)+prodlag(3,is).gt.0.0) THEN

        BYPINT(2,IFUEL,IS)= &
          ((prodlag(2,IS)*BYPINTLAG(2,IFUEL,IS)+ &
           prodlag(3,IS)*BYPINTLAG(3,IFUEL,IS))/ &
           (prodlag(2,is)+prodlag(3,is))) &
           *exp(TPCRate(1))
      ENDIF

        enddo
60    CONTINUE

! **** if this is high renewables run, at the end of the loop, reset hitech = 0                                    ****

        if(hirenew.eq.1) hitech=0
        if(lorenew.eq.1) frztech=0


!****
!  CALCULATE THE ENERGY BYPRODUCT PRODUCTION IN EACH PROCESS STEP.
!****

      BYPQTY(:,:,:)=0.0

      DO 70 IS=1,MPASTP
      DO 70 IFuel=1,IFBYP(IS)
        BYPQTY(1,IFuel,IS)=PRODCUR(1,IS)*BYPINT(1,IFuel,IS)
        BYPQTY(2,IFuel,IS)=PRODCUR(2,IS)*BYPINT(2,IFuel,IS)
        BYPQTY(3,IFuel,IS)=PRODCUR(3,IS)*BYPINT(3,IFuel,IS)
        BYPQTY(4,IFuel,IS)=BYPQTY(1,IFuel,IS)+BYPQTY(2,IFuel,IS)+ &
                                        BYPQTY(3,IFuel,IS)
   70 CONTINUE

!****
!  CONVERT MMBTU TO TRILLION BTU IF IDVAL=1.
!  DO NOT CONVERT IF IDVAL=2.
!****

      IF(IDVAL.EQ.1) THEN
        DO 80 IS=1,MPASTP
        DO 80 IFuel=1,IFBYP(IS)
        DO 80 IV=1,4
          BYPQTY(IV,IFuel,IS)=BYPQTY(IV,IFuel,IS)/1000000.0

 80     CONTINUE
      ENDIF

!****
!  SUM UP THE CONSUMPTION OVER THE FUEL TYPES.
!****

      DO 90 IS=1,MPASTP
      DO 90 IV=1,4
        BYPQTY(IV,6,IS)=0.0
        DO 90 IFuel=1,IFBYP(IS)
          BYPQTY(IV,6,IS)=BYPQTY(IV,6,IS)+BYPQTY(IV,IFuel,IS)
 90   CONTINUE

!****
!  SUM OVER STEPS AND PUT PRODUCTION INTO THE
!  APPROPRIATE ARRAY FOR THE SPECIFIC ENERGY SOURCE.  THE FUEL
!  ORDER IS GIVEN AT THE START OF THIS PROGRAM.
!  DETERMINE THE AMOUNT OF BYPRODUCT THAT GOES TO BSC AND PA.
!  FOR NOW ASSUME EVERYTHING GOES TO BSC.
!****

        DO IFuel=1,23
          BYPBSCM(IFuel)=0.0
        enddo
        DO IFuel=1,7
          BYPBSCI(IFuel)=0.0
        enddo
        DO IFuel=1,9
          BYPBSCR(IFuel)=0.0
        enddo
      DO 100 IS=1,MPASTP
      DO 100 IFuel=1,IFBYP(IS)
        IFX=IFLOCBY(IFuel,IS)
        IF(IFX.LE.30) THEN
          BYPBSCM(IFX)=BYPBSCM(IFX)+BYPQTY(4,IFuel,IS)
        ELSE
          IF(IFX.LE.40) THEN
            IFY=IFX-30
            BYPBSCI(IFY)=BYPBSCI(IFY)+BYPQTY(4,IFuel,IS)
          ELSE

! *** the idea here is that bypqty is  "produced" via UECs            ***
! *** in the pa component.  this code assigns all this byproduct to   ***
! *** the bsc, except in minor cases where none is produced in the pa ***
            IFY=IFX-40
            BYPBSCR(IFY)=BYPBSCR(IFY)+BYPQTY(4,IFuel,IS)
          ENDIF
        ENDIF
  100 CONTINUE

!****
!  FORMAT STATEMENTS.
!****

  512 FORMAT(1X,'PROCESS/ASSEMBLY BYPRODUCT PRODUCTION BY FUEL:')
  513 FORMAT(5X,'FUEL ',I4,F12.2)
  991 FORMAT(3X,'CALBYPROD')

      RETURN
      END SUBROUTINE CALBYPROD

!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!  THIS STEP CALCULATES THE TOTAL ENERGY CONSUMPTION IN THE PROCESS
!  ASSEMBLY COMPONENT.
!****
      SUBROUTINE CALPATOT(version)
   use i_
      IMPLICIT NONE
     character*(*) version ! argument passed as 'original' or 'tech' to trigger tech choice industries

!****
!  DECLARE INTERNAL VARIABLES.
!****

      INTEGER IS,IV,IFX,IFY,IFUEL
      INTEGER CASE,IY,kk
      REAL TEMP, machdrv
       real domprod_rpt(15:mnumyr)
       real prim_prod_rpt(15:mnumyr)
       real survcap_rpt(15:mnumyr)
       real index2006_rpt(15:mnumyr)
	   real coalpapsumx(3,mnumyr)     ! kpe papersum variable so we don't add up all 26 steps at the same time 
       real kraft_shr    ! KPE kraft share of total kraft/mechanical pulp for assigning steps 24-26
	   real steam_share(7)  ! kpe variables to allocate steam to different is steps, based on paper_steam_grs
      

      common /alrpt/domprod_rpt,prim_prod_rpt,survcap_rpt,index2006_rpt


! Methanol Adjustment
! Due to assumed non-modeled near-elimination of domestic methanol production,
! adjust feedstock and process heat natural gas required in the organic chemical
! industry.  step 7 is organic/heat, natural gas heat is ifx=3
!            step 12 is organic/feed, natural gas feed is ifx=5
!                             2005 2006 2007 2008 2009 2010
    REAL MethAdj(2005:2010,2)/  30,  33,  37,  41,  44,  48,  & ! h&p
                                64,  73,  83,  93, 102, 112/    ! feedstock
      IY = IYR - baseyr + 1

     coalpapsumx(:,:) = 0.   ! initialize intermediate paper sum variable
	 kraft_shr = 0.
	 steam_share(:) = 0.
	 
	! do kx=0,4
	 !   coalpapsumx(kx+1) = CoalSCons(kx*5+10:kx*5+15), 
		coalpapsumx(1,curiyr) = sum(CoalSCons(10:15,curiyr))
		coalpapsumx(2,curiyr) = sum(CoalSCons(16:20,curiyr))
        coalpapsumx(3,curiyr) = sum(CoalSCons(21:26,curiyr))

!****
!  WRITE SUBROUTINE TRACE, IF ON.
!****
 
      IF(ISUBTR.EQ.1.AND.IOPEN.EQ.1.AND.LSTITER.EQ.1) &
        WRITE(IUNIT1,991)

!****
!  CALCULATE THE ENERGY CONSUMPTION BY VINTAGE IN EACH PROCESS STEP.
!****
     DO 60 IS=1,MPASTP
     DO 60 IFUEL=1,IFMAX(IS)
          ENPQTY(1,IFUEL,IS)=PRODCUR(1,IS)*ENPINT(1,IFUEL,IS)
          ENPQTY(2,IFUEL,IS)=PRODCUR(2,IS)*ENPINT(2,IFUEL,IS)
          ENPQTY(3,IFUEL,IS)=PRODCUR(3,IS)*ENPINT(3,IFUEL,IS)
          ENPQTY(4,IFUEL,IS)=sum(ENPQTY(1:3,IFUEL,IS)) 
          
! Debug for CON
! If (inddir.eq.6) write(6,*) curcalyr,'fuel',ifuel,indreg,is,ENPINT(1,IFUEL,IS)
! if (inddir.eq.11.and.curcalyr.ge.2008.and.fcrl.eq.1) write(6,'(5x,a,(f15.2,2x),6(1x,i4))') '==== Cement industry PA = ',ENPQTY(4,IFUEL,IS), ifuel, ifmax(is), is, mpastp, curcalyr, curiyr

  60 CONTINUE

    if(version.eq.'tech') then

! NEW CEMENT & LIME MODEL
! Overwrite the cement industry results above with both cement and lime
! IDVAL for ind 11 is 1 so units are MMBTU and get converted later

    IF(inddir.eq.11.and.curcalyr.ge.IBYR2+1) then    ! POT_IBYROTHER 2008 to IBYR+2

       ! Only fill total, not by vintage (4) since Cement isn't currently set up for it
       ! Steps, third index, are 1=finish grind, 2=kilns, 3=raw grind, 4=lime, 5=imports (not done here)
         ENPQTY(:,:,1:4)=0.0

          ! fuel 1 Elect
            ENPQTY(4,1,1)=IND_FLOW_SHARE(inddir,1,indreg)*ElecCons(1,curiyr)
            ENPQTY(4,1,2)=IND_FLOW_SHARE(inddir,2,indreg)*ElecCons(2,curiyr)
            ENPQTY(4,1,3)=IND_FLOW_SHARE(inddir,3,indreg)*ElecCons(4,curiyr)
            ENPQTY(4,1,4)=IND_FLOW_SHARE(inddir,2,indreg)*ElecCons(5,curiyr)
!            if(fcrl.eq.1) write(6,'(5x,a,3(f15.2,2x),2(1x,i4))') '==== Lime industry PA = ', lime_totenergy, coal_process, ng_process, curcalyr, curiyr

          ! fuel 2 NG
            ENPQTY(4,2,2)=IND_FLOW_SHARE(inddir,2,indreg)*NgCons(3,curiyr)  *1000.0
            ENPQTY(4,2,3)=IND_FLOW_SHARE(inddir,3,indreg)*NGCons(4,curiyr)  
            ENPQTY(4,2,4)=IND_FLOW_SHARE(inddir,2,indreg)*NGCons(5,curiyr)  
            
          ! fuel 3 Stm Coal
            !ENPQTY(4,6,2)=IND_FLOW_SHARE(inddir,2,indreg)*CoalSCons(3,curiyr)*1000.0
            !ENPQTY(4,6,4)=IND_FLOW_SHARE(inddir,2,indreg)*CoalSCons(5,curiyr)  !1000.*coal_process !lime
            ENPQTY(4,3,2)=IND_FLOW_SHARE(inddir,2,indreg)*CoalSCons(3,curiyr)*1000.0
            ENPQTY(4,3,4)=IND_FLOW_SHARE(inddir,2,indreg)*CoalSCons(5,curiyr)  !1000.*coal_process !lime
            
          ! fuel 4 Coking Coal
            !ENPQTY(4,7,2)=IND_FLOW_SHARE(inddir,2,indreg)*0.000001*CoalSCons(3,curiyr)  *1000.0
            !ENPQTY(4,7,4)=IND_FLOW_SHARE(inddir,2,indreg)*0.000001*CoalSCons(5,curiyr) *1000.0
            ENPQTY(4,4,2)=IND_FLOW_SHARE(inddir,2,indreg)*0.000001*CoalSCons(3,curiyr)  *1000.0
            ENPQTY(4,4,4)=IND_FLOW_SHARE(inddir,2,indreg)*0.000001*CoalSCons(5,curiyr) *1000.0  

          ! fuel 5 Resid
            !ENPQTY(4,3,2)=0.0 !IND_FLOW_SHARE(inddir,2,indreg)*(HFOCons(3,curiyr))*cm_hfoshr(1)*1000.0
	        !ENPQTY(4,3,4)=0.0 !IND_FLOW_SHARE(inddir,2,indreg)*(HFOCons(5,curiyr))*lm_hfoshr(1)                 
            ENPQTY(4,5,2)=0.0 !IND_FLOW_SHARE(inddir,2,indreg)*(HFOCons(3,curiyr))*cm_hfoshr(1)*1000.0
	        ENPQTY(4,5,4)=0.0 !IND_FLOW_SHARE(inddir,2,indreg)*(HFOCons(5,curiyr))*lm_hfoshr(1) 

          ! fuel 6 Distl
            !ENPQTY(4,4,2)=IND_FLOW_SHARE(inddir,2,indreg)*(HFOCons(3,curiyr))*1000. !*cm_hfoshr(2) !cement 
	        !ENPQTY(4,4,4)=IND_FLOW_SHARE(inddir,2,indreg)*(HFOCons(5,curiyr))!*lm_hfoshr(2)       !lime 
            ENPQTY(4,6,2)=IND_FLOW_SHARE(inddir,2,indreg)*(HFOCons(3,curiyr))*1000. !*cm_hfoshr(2) !cement 
	        ENPQTY(4,6,4)=IND_FLOW_SHARE(inddir,2,indreg)*(HFOCons(5,curiyr))!*lm_hfoshr(2)       !lime 

          ! fuel 7 Pet Coke
            !ENPQTY(4,5,2)=IND_FLOW_SHARE(inddir,2,indreg)*PetCons(3,curiyr)*1000.0
            !ENPQTY(4,5,4)=0.0 !lime
            ENPQTY(4,7,2)=IND_FLOW_SHARE(inddir,2,indreg)*PetCons(3,curiyr)*1000.0
            ENPQTY(4,7,4)=0.0 !lime
          
            ! fuel 8 Oth Pet
            ENPQTY(4,8,2)=0.0 !IND_FLOW_SHARE(inddir,2,indreg)*cm_hfoshr(3)*(HFOCons(3,curiyr))*1000.0
            ENPQTY(4,8,4)=0.0 !IND_FLOW_SHARE(inddir,2,indreg)*lm_hfoshr(3)*(HFOCons(3,curiyr))*1000.0
          
            ! fuel 9 Municipal Solid Waste redefined to Alternative Solid Fuels
            ENPQTY(4,9,2)=IND_FLOW_SHARE(inddir,2,indreg)*(tot_burner_fuel(5))*1000.0
       Endif
! END CEMENT & LIME

! NEW Aluminum Model
! IDVAL for ind 13 is 1 so units are MMBTU and get converted later
       IF(inddir.eq.13.and.curcalyr.ge.ibyr2+1) then   ! POT_ibyr2OTHER 2007 to ibyr2+1
       ! Only fill total, not by vintage (4) since Alum isn't currently set up for it???
       ! Steps, third index, are 1=semi-sheet, 2=semi-other, 3=secondary, 4=primary, 5=bauxite
          ENPQTY(:,:,1:5)=0.0
! fuel 1 Elect
          ENPQTY(4,1,1)= ElecCons(6,curiyr) * IND_FLOW_SHARE(inddir,1,indreg) !is_production(inddir,1)*&
                        !3000.0*IND_FLOW_SHARE(inddir,1,indreg)

          ENPQTY(4,1,4)=(ElecCons(1,curiyr)+ElecCons(2,curiyr)+ElecCons(3,curiyr))*&
                           IND_FLOW_SHARE(inddir,4,indreg)

! fuel 2 NG

          ENPQTY(4,2,1)= NGCons(6,curiyr)* IND_FLOW_SHARE(inddir,1,indreg)
          ENPQTY(4,2,3)=(NGCons(4,curiyr)+NGCons(5,curiyr))*IND_FLOW_SHARE(inddir,3,indreg)
          ENPQTY(4,2,4)=(NGCons(3,curiyr)+NGCons(2,curiyr))*IND_FLOW_SHARE(inddir,4,indreg)

 ! fuel 5 Pet Coke
           ENPQTY(4,5,4)=PetCons(2,curiyr)*IND_FLOW_SHARE(inddir,4,indreg)
 ! fuel 8 Other Pet
          ENPQTY(4,8,4)=OPetCons(2,curiyr)*IND_FLOW_SHARE(inddir,4,indreg)
!

!************************************************
        endif
! End Aluminum

! NEW Glass Model
 !ENPQTY(4,1,1)= ElecCons(6,curiyr) * IND_FLOW_SHARE(inddir,1,indreg)
        IF(inddir.eq.10.and.curcalyr.ge.ibyr2+1) then   ! POT_ibyr2OTHER 2007 to ibyr2+1
       ! Only fill total ??
       ! Steps, third index, are 1=flat, 2=container, 3=blown, 4=fiber
       ! ElecCons and NGCons first index reference the 14 glass processes
          ENPQTY(:,:,1:4)=0.0
! fuel 1 Elect
          ENPQTY(4,1,1)=SUM(ElecCons(1:4,curiyr))*IND_FLOW_SHARE(inddir,1,indreg)*gl_mecs(2)
          ENPQTY(4,1,2)=SUM(ElecCons(5:7,curiyr))*IND_FLOW_SHARE(inddir,2,indreg)*gl_mecs(2)
          ENPQTY(4,1,3)=SUM(ElecCons(8:11,curiyr))*IND_FLOW_SHARE(inddir,3,indreg) *gl_mecs(2)
          ENPQTY(4,1,4)=SUM(ElecCons(12:14,curiyr))*IND_FLOW_SHARE(inddir,4,indreg) *gl_mecs(2)

! fuel 2 NG
          ENPQTY(4,2,1)=SUM(NGCons(1:4,curiyr))*IND_FLOW_SHARE(inddir,1,indreg)*1000000.0 *gl_mecs(1)
          ENPQTY(4,2,2)=SUM(NGCons(5:7,curiyr))*IND_FLOW_SHARE(inddir,2,indreg)*1000000.0*gl_mecs(1)
          ENPQTY(4,2,3)=SUM(NGCons(8:11,curiyr))*IND_FLOW_SHARE(inddir,3,indreg) *1000000.0 *gl_mecs(1)
          ENPQTY(4,2,4)=SUM(NGCons(12:14,curiyr))*IND_FLOW_SHARE(inddir,4,indreg)*1000000.0*gl_mecs(1)
        endif  ! End Glass

! New Iron and Steel Model
! IDVAL for ind 12 is 1 so units are MMBTU and get converted later

      IF(inddir.eq.12.and.curcalyr.ge.ibyr2+1) then
	     ENPQTY(:,:,1:8)=0.0
		 do is=1,IS_MAXSTPS-3
		    ENPQTY(4,1,is)=ElecCons(is,curiyr)*IND_FLOW_SHARE(inddir,is,indreg)*1000000.0
            ENPQTY(4,2,is)=NgCons(is,curiyr)*IND_FLOW_SHARE(inddir,is,indreg)*1000000.0
            ENPQTY(4,6,is)=CoalSCons(is,curiyr)*IND_FLOW_SHARE(inddir,is,indreg)*1000000.0
            ENPQTY(4,7,is)=CoalMCons(is,curiyr)*IND_FLOW_SHARE(inddir,is,indreg)*1000000.0
		    ENPQTY(4,3,is)=HFOCons(is,curiyr)*IND_FLOW_SHARE(inddir,is,indreg)*1000000.0 ! 10% of HFO is residual
		    ENPQTY(4,8,is)=0.0 !0.90*HFOCons(is,curiyr)*IND_FLOW_SHARE(inddir,is,indreg)*1000000.0 ! 90% of HFO is other petroleum

		 enddo
		 ! combine steps 6 and 7 into step 6 since DRI is split into 2 steps in process calcs
		 ENPQTY(4,1,6)=(ElecCons(6,curiyr)+ElecCons(7,curiyr))*IND_FLOW_SHARE(inddir,6,indreg)*1000000.0
         ENPQTY(4,2,6)=(NgCons(6,curiyr)+NgCons(7,curiyr))*IND_FLOW_SHARE(inddir,6,indreg)*1000000.0
         ENPQTY(4,6,6)=(CoalSCons(6,curiyr)+CoalSCons(7,curiyr))*IND_FLOW_SHARE(inddir,6,indreg)*1000000.0
         ENPQTY(4,7,6)=(CoalMCons(6,curiyr)+CoalMCons(7,curiyr))*IND_FLOW_SHARE(inddir,6,indreg)*1000000.0
		 ENPQTY(4,3,6)=(HFOCons(6,curiyr)+HFOCons(7,curiyr))*IND_FLOW_SHARE(inddir,6,indreg) *1000000.0! 10% of HFO is residual
		 ENPQTY(4,8,6)=0.0 !0.90*(HFOCons(6,curiyr)+HFOCons(7,curiyr))*IND_FLOW_SHARE(inddir,6,indreg) *1000000.0! 90% of HFO is other petroleum

		 is=8 !coke is step 8 in process calcs
		 ENPQTY(4,1,is-1)=ElecCons(is,curiyr)*IND_FLOW_SHARE(inddir,is-1,indreg)*1000000.0
         ENPQTY(4,2,is-1)=NgCons(is,curiyr)*IND_FLOW_SHARE(inddir,is-1,indreg)*1000000.0
         ENPQTY(4,6,is-1)=CoalSCons(is,curiyr)*IND_FLOW_SHARE(inddir,is-1,indreg) *1000000.0
         ENPQTY(4,7,is-1)=CoalMCons(is,curiyr)*IND_FLOW_SHARE(inddir,is-1,indreg)*1000000.0
		 ENPQTY(4,3,is-1)=HFOCons(is,curiyr)*IND_FLOW_SHARE(inddir,is-1,indreg)*1000000.0 ! 10% of HFO is residual
		 ENPQTY(4,8,is-1)=0.0 !0.90*HFOCons(is,curiyr)*IND_FLOW_SHARE(inddir,is-1,indreg)*1000000.0 ! 90% of HFO is other petroleum
		
      endif !end iron and steel

! New Pulp and Paper Model
! IDVAL for ind 8 is 1 so units are MMBTU and get converted later


      IF(inddir.eq.8 .and. curcalyr .ge. ibyr2+1) then
	  
	     ENPQTY(:,:,1:7)=0.0
		 
		 kraft_shr = sumprodcur(inddir,6)/sum(sumprodcur(inddir,5:6)) ! sharing out production to kraft pulp

		 ! now allocate steam shares for fossil fuel consumption. only paper and steps 24-26 have fossil, so 
		 ! the steam shares are meaningful only for steps 1, 5 & 6.  Nevertheless, matching steam shares to 
		 ! is steps
		 steam_share(1) = sum(paper_steam_grs(10:23,curiyr))/sum(paper_steam_grs(10:26,curiyr))  ! KPE paper
	     steam_share(2) = 1.0 !paper_steam_grs(9,curiyr)/sum(paper_steam_grs(1:26,curiyr))		! KPE bleach
         steam_share(3) = 1.0 !sum(paper_steam_grs(6:8,curiyr))/sum(paper_steam_grs(10:26,curiyr))	! kpe waste paper	 
		 steam_share(4) = 1.0 ! sum(paper_steam_grs(4:5,curiyr))/sum(paper_steam_grs(10:26,curiyr))	! kpe mech pulp	 
         steam_share(5) = (sum(paper_steam_grs(24:26,curiyr))*(1. - kraft_shr))/sum(paper_steam_grs(10:26,curiyr)) ! kpe chem pulp
         steam_share(6) = sum(paper_steam_grs(24:26,curiyr))*kraft_shr/sum(paper_steam_grs(10:26,curiyr)) ! kpe Kraft pulp
		
		 steam_share(7) = 1.0 ! paper_steam_grs(1,curiyr)/sum(paper_steam_grs(1:26,curiyr)) ! kpe wood
	   
		    is=1 !paper KPE--now steps 10-23; 24-26 have been reassigned to kraft and semi-chem pulp
		    ENPQTY(4,1,is)=SUM(ElecCons(10:23,curiyr))*IND_FLOW_SHARE(inddir,is,indreg)*1000000.0
            ENPQTY(4,2,is)=(SUM(NgCons(10:23,curiyr))+steam_share(is)*(PP_Steam_Boiler(2)+PP_STEAM_Cogen(2))) & 
			        *IND_FLOW_SHARE(inddir,is,indreg)*1000000.0

		
!		    ENPQTY(4,5,is)=SUM(PAPER_STEAM(10:26,curiyr))*IND_FLOW_SHARE(inddir,is,indreg)*1000000.0 /1.054615
            is=2!bleach
			ENPQTY(4,1,is)=ElecCons(9,curiyr)*IND_FLOW_SHARE(inddir,is,indreg)*1000000.0

!            ENPQTY(4,2,is)=PAPER_STEAM(9,curiyr)*IND_FLOW_SHARE(inddir,is,indreg)*1000000.0/1.054615
			is=3 !waste_p
			ENPQTY(4,1,is)=(ElecCons(6,curiyr)+SUM(ElecCons(7:8,curiyr))*pulpshare(1,5)) &
                               *IND_FLOW_SHARE(inddir,is,indreg)*1000000.0
!            ENPQTY(4,2,is)=(Paper_Steam(6,curiyr)+SUM(Paper_Steam(7:8,curiyr))*pulpshare(2,5)) &
!                               *IND_FLOW_SHARE(inddir,is,indreg)*1000000.0/1.054615
			is=4 !mech_p
            ENPQTY(4,1,is)=(SUM(ElecCons(4:5,curiyr))+SUM(ElecCons(7:8,curiyr))*pulpshare(1,4)) &
                               *IND_FLOW_SHARE(inddir,is,indreg)*1000000.0
!            ENPQTY(4,2,is)=(SUM(Paper_Steam(4:5,curiyr))+SUM(Paper_Steam(7:8,curiyr))*pulpshare(2,4)) &
!                               *IND_FLOW_SHARE(inddir,is,indreg)*1000000.0/1.054615

           ! note:  steps 24-26, which were once part of is 1, are moved to kraft & semi-chem pulp.  
		   ! they are shared out according to the prodcur.
		   ! steps 24-26 are the only steps with nonelectric conventional fuels

			 is=5 !chem_p
            ENPQTY(4,1,is)=(ElecCons(3,curiyr)+SUM(ElecCons(7:8,curiyr))*pulpshare(1,3)) &
                               *IND_FLOW_SHARE(inddir,is,indreg)*1000000.0		   
			! now add electricity in steps 24-26			
			ENPQTY(4,1,is)=  ENPQTY(4,1,is) + SUM(ElecCons(24:26,curiyr))*(1. - kraft_shr) &
                               *IND_FLOW_SHARE(inddir,is,indreg)*1000000.0
				   
!            ENPQTY(4,2,is)=(Paper_Steam(3,curiyr)+SUM(Paper_Steam(7:8,curiyr))*pulpshare(2,3)) &
!                               *IND_FLOW_SHARE(inddir,is,indreg)*1000000.0/1.054615
            ENPQTY(4,2,is)=((1. - kraft_shr)*SUM(NgCons(24:26,curiyr)) + steam_share(is)*(PP_Steam_Boiler(2)+PP_STEAM_Cogen(2)))* & 
			                IND_FLOW_SHARE(inddir,is,indreg)*1000000.0
            ENPQTY(4,3,is)=(pp_hfoshr(1)*((1. - kraft_shr)*SUM(HFOCons(24:26,curiyr)) + &
			          steam_share(is)*(PP_Steam_Boiler(3)+PP_Steam_Cogen(3))))*IND_FLOW_SHARE(inddir,is,indreg)*1000000.0 !resid
            ENPQTY(4,8,is)=(pp_hfoshr(4)*((1. - kraft_shr)*SUM(HFOCons(24:26,curiyr)) + &
			          steam_share(is)*(PP_Steam_Boiler(3)+PP_Steam_Cogen(3))))*IND_FLOW_SHARE(inddir,is,indreg)*1000000.0 !resid
            ENPQTY(4,5,is)=(pp_hfoshr(2)*((1. - kraft_shr)*SUM(HFOCons(24:26,curiyr)) + &
			          steam_share(is)*(PP_Steam_Boiler(3)+PP_Steam_Cogen(3))))*IND_FLOW_SHARE(inddir,is,indreg)*1000000.0 !resid
            ENPQTY(4,4,is)=(pp_hfoshr(3)*((1. - kraft_shr)*SUM(HFOCons(24:26,curiyr)) + &
			          steam_share(is)*(PP_Steam_Boiler(3)+PP_Steam_Cogen(3))))*IND_FLOW_SHARE(inddir,is,indreg)*1000000.0 !resid
	        ENPQTY(4,6,is)=((1. - kraft_shr)*SUM(CoalSCons(24:26,curiyr)) + &
			          steam_share(is)*(PP_Steam_Boiler(4)+PP_STEAM_Cogen(4)))*IND_FLOW_SHARE(inddir,is,indreg)*1000000.0 !resid
				  
	!				  
	!		ENPQTY(4,8,is)=(1. - kraft_shr)*pp_hfoshr(4)*SUM(HFOCons(24:26,curiyr))*IND_FLOW_SHARE(inddir,is,indreg)*1000000.0 !other pet
    !        ENPQTY(4,5,is)=(1. - kraft_shr)*pp_hfoshr(2)*SUM(HFOCons(24:26,curiyr))*IND_FLOW_SHARE(inddir,is,indreg)*1000000.0 !pet coke
	!		ENPQTY(4,4,is)=(1. - kraft_shr)*pp_hfoshr(3)*SUM(HFOCons(24:26,curiyr))*IND_FLOW_SHARE(inddir,is,indreg)*1000000.0 !distillate
	!		ENPQTY(4,6,is)= (1. - kraft_shr)*SUM(CoalSCons(24:26,curiyr))*IND_FLOW_SHARE(inddir,is,indreg)*1000000.0

			is=6 !kraft_p
			ENPQTY(4,1,is)=(ElecCons(2,curiyr)+SUM(ElecCons(7:8,curiyr))*pulpshare(1,2)) &
                               *IND_FLOW_SHARE(inddir,is,indreg)*1000000.0

			ENPQTY(4,1,is)=  ENPQTY(4,1,is) + SUM(ElecCons(24:26,curiyr))*kraft_shr &
                               *IND_FLOW_SHARE(inddir,is,indreg)*1000000.0

            ENPQTY(4,2,is)=(kraft_shr*SUM(NgCons(24:26,curiyr)) + steam_share(is)*(PP_Steam_Boiler(2)+PP_STEAM_Cogen(2)))* & 
			                IND_FLOW_SHARE(inddir,is,indreg)*1000000.0
			! resid				
            ENPQTY(4,3,is)=(pp_hfoshr(1)*(kraft_shr*SUM(HFOCons(24:26,curiyr)) + &
			          steam_share(is)*(PP_Steam_Boiler(3)+PP_Steam_Cogen(3))))*IND_FLOW_SHARE(inddir,is,indreg)*1000000.0 !resid
            ! other petroluem
			ENPQTY(4,8,is)=(pp_hfoshr(4)*(kraft_shr*SUM(HFOCons(24:26,curiyr)) + &
			          steam_share(is)*(PP_Steam_Boiler(3)+PP_Steam_Cogen(3))))*IND_FLOW_SHARE(inddir,is,indreg)*1000000.0 !resid
            ! pet coke
			ENPQTY(4,5,is)=(pp_hfoshr(2)*(kraft_shr*SUM(HFOCons(24:26,curiyr)) + &
			          steam_share(is)*(PP_Steam_Boiler(3)+PP_Steam_Cogen(3))))*IND_FLOW_SHARE(inddir,is,indreg)*1000000.0 !resid
            ! distillate
			ENPQTY(4,4,is)=(pp_hfoshr(3)*(kraft_shr*SUM(HFOCons(24:26,curiyr)) + &
			          steam_share(is)*(PP_Steam_Boiler(3)+PP_Steam_Cogen(3))))*IND_FLOW_SHARE(inddir,is,indreg)*1000000.0 !resid
	        !coal
			ENPQTY(4,6,is)=(kraft_shr*SUM(CoalSCons(24:26,curiyr)) + &
			          steam_share(is)*(PP_Steam_Boiler(4)+PP_STEAM_Cogen(4)))*IND_FLOW_SHARE(inddir,is,indreg)*1000000.0 !resid



!            ENPQTY(4,2,is)=(Paper_Steam(2,curiyr)+SUM(Paper_Steam(7:8,curiyr))*pulpshare(2,2)) &
!                               *IND_FLOW_SHARE(inddir,is,indreg)*1000000.0/1.054615   ! GJ to Btu  keep an eye on these
!            ENPQTY(4,2,is)=kraft_shr*SUM(NgCons(24:26,curiyr))*IND_FLOW_SHARE(inddir,is,indreg)*1000000.0
!            ENPQTY(4,3,is)=kraft_shr*pp_hfoshr(1)*SUM(HFOCons(24:26,curiyr))*IND_FLOW_SHARE(inddir,is,indreg)*1000000.0 !resid
!			ENPQTY(4,8,is)=kraft_shr*pp_hfoshr(4)*SUM(HFOCons(24:26,curiyr))*IND_FLOW_SHARE(inddir,is,indreg)*1000000.0 !other pet
!            ENPQTY(4,5,is)=kraft_shr*pp_hfoshr(2)*SUM(HFOCons(24:26,curiyr))*IND_FLOW_SHARE(inddir,is,indreg)*1000000.0 !pet coke
!			ENPQTY(4,4,is)=kraft_shr*pp_hfoshr(3)*SUM(HFOCons(24:26,curiyr))*IND_FLOW_SHARE(inddir,is,indreg)*1000000.0 !distillate
!			ENPQTY(4,6,is)= kraft_shr*SUM(CoalSCons(24:26,curiyr))*IND_FLOW_SHARE(inddir,is,indreg)*1000000.0
            is=7 !wood
			ENPQTY(4,1,is)=ElecCons(1,curiyr)*IND_FLOW_SHARE(inddir,is,indreg)*1000000.0
			
			
! KPE   completed moving steps 24-26 to kraft and semi-chem pulp
!   may be ready for test run
            !biomass
            write(IUNITBUG,'(" PAPER_HOG    : ",I6,<26-10+1>F12.3)') curcalyr,PAPER_HOG(10:26,curiyr)
            write(IUNITBUG,'(" PAPER_BLIQUOR: ",I6,<26-10+1>F12.3)') curcalyr,PAPER_BLIQUOR(1:26,curiyr)
			! NOTE:  ENPRQTY should be in trills-- the conversion is not done on the renewable variable
            ! KPE note:  let's try calculating enprqty on line 84xx and see what happens . . .
            ! leaving the 84xx calculation for now . . .			
            ! ENPRQTY(2)=(SUM(PAPER_HOG(1:26,curiyr))/1.054615)*1.0E-6 ! in trills . . . this is now mmBTU *1000000.0/1.054615
            ! ENPRQTY(3)=(abs(SUM(PAPER_BLIQUOR(1:26,curiyr)))/1.054615)*1.0E-6 ! in trills  this is now mmBTU   *1000000.0  /1.054615



      endif
    endif ! ' of   if (version .eq. 'tech')



      DO IS=1,MPASTP
      DO IFUEL=1,IFMAX(IS)
         IFX=IFLOC(IFUEL,IS)
        if (inddir.eq.1 .and. is.eq.1) then
        call corncalc(is,ifuel,ifx)

       endif

       if(inddir.eq.9 .and. is.eq.24 .and. ifx.eq.5) then
        call corncalc(is,ifuel,ifx)
       endif
      ENDDO
      ENDDO
! methanol adjustment goes here
      DO IS=1,MPASTP
      DO IFUEL=1,IFMAX(IS)
         IFX=IFLOC(IFUEL,IS)
       if(curcalyr.ge.2005.and.inddir.eq.9.and.indreg.eq.3) then
          if(is.eq.7.and.ifx.eq.3) then
            enpqty(1,ifuel,is) = enpqty(1,ifuel,is) -  MethAdj(min(curcalyr,2010),1)
            enpqty(4,ifuel,is) = enpqty(4,ifuel,is) -  MethAdj(min(curcalyr,2010),1)
          endif
          if(is.eq.12.and.ifx.eq.5) then
             enpqty(1,ifuel,is) = enpqty(1,ifuel,is) - MethAdj(min(curcalyr,2010),2)
             enpqty(4,ifuel,is) = enpqty(4,ifuel,is) - MethAdj(min(curcalyr,2010),2)
          endif
       endif
     ENDDO
     ENDDO


!****
!  CONVERT MMBTU TO TRILLION BTU IF IDVAL=1.
!  DO NOT CONVERT IF IDVAL=2.
!****
      IF(IDVAL.EQ.1.OR.IDVAL.EQ.3) THEN
        DO 70 IS=1,MPASTP
        DO 70 IFUEL=1,10 !IFMAX(IS)
	!	if (ifmax(is).gt.10) write(5555,*) 'DEBUG THIS',ifmax(is),is
             DO 86 IV=1,4
               ENPQTY(IV,IFUEL,IS)=ENPQTY(IV,IFUEL,IS)/1000000.

 86          CONTINUE
 70     CONTINUE

      ENDIF

  !****
!  SUM UP THE CONSUMPTION OVER THE FUEL TYPES.
!****

      DO 80 IS=1,MPASTP
      DO 80 IV=1,4
        ENPQTY(IV,16,IS)=0.0
        DO 80 IFUEL=1,IFMAX(IS)
          ENPQTY(IV,16,IS)=ENPQTY(IV,16,IS)+ENPQTY(IV,IFUEL,IS)
 80   CONTINUE


      if(inddir.eq.7 .or. inddir.eq.9 .or.inddir.ge.14) then
        call motors

! sum electricity for all machine drive steps.
        machdrv=0.
        DO  IS=1,MPASTP
          DO  IFUEL=1,IFMAX(IS)
            IFX=IFLOC(IFUEL,IS)
            IF((IFX.eq.1 .or. ifx.eq.23 .or. ifx.eq.24 .or. ifx.eq.25).and.index(indstepname(is),'MACHDRV').gt.0)THEN
              machdrv=machdrv+ enpqty(4,IFUEL,IS)
            ENDIF
          enddo
        enddo
! replace electricity from machine drive steps with output from motor model,
! since there can be more than one machine drive step (in chemicals, eg), share
! the motor model electricity proportionately to each of the machine drive steps.
        DO  IS=1,MPASTP
          DO  IFUEL=1,IFMAX(IS)
            IFX=IFLOC(IFUEL,IS)
            IF((IFX.eq.1 .or. ifx.eq.23 .or. ifx.eq.24 .or. ifx.eq.25).and.index(indstepname(is),'MACHDRV').gt.0)THEN
              if (isinf(TotAdjMotorEnergy(mind,motorsizes+1,indreg,curiyr))) then
                write(6,*) 'Infinity Found in TotAdjMotorEnergy(mind,motorsizes+1,indreg,curiyr)'
                write(6,*) 'inddir,indreg=',inddir,indreg
                write(6,*) 'check motor efficiency inputs--must be nonzero to avoid infinity'
              endif
              ENPQTY(1:3,IFUEL,IS)=0.
              temp=enpqty(4,ifuel,is)
              ENPQTY(4,IFUEL,IS)=temp*           &
              (TotAdjMotorEnergy(mind,motorsizes+1,indreg,curiyr)/machdrv)! Total adjusted energy consumption: 4 industries, 7 motor sizes + total, # of model years
              if(prtdbgi.ge.2) then
                write(8,'(i4,3i3,2f12.2)') curcalyr,curitr,inddir,indreg,temp,enpqty(4,ifuel,is)
              endif
            ENDIF
          enddo
        enddo
      endif

!****
!  SUM OVER VINTAGES AND STEPS AND PUT CONSUMPTION INTO THE
!  APPROPRIATE ARRAY FOR THE SPECIFIC ENERGY SOURCE.  THE FUEL
!  ORDER IS GIVEN AT THE START OF THIS PROGRAM, AND THE ARRAYS ARE
!  ENPMQTY FOR THE MAIN FUEL SOURCES, ENPIQTY FOR THE INTERMEDIATE
!  FUEL SOURCES AND ENPRQTY FOR THE RENEWABLE ENERGY SOURCES.
!****

      DO 90 IFUEL=1,23
        ENPMQTY(IFUEL)=0.0
   90 CONTINUE
      DO 92 IFUEL=1,7
        ENPIQTY(IFUEL)=0.0
   92 CONTINUE
      DO 94 IFUEL=1,9
        ENPRQTY(IFUEL)=0.0
   94 CONTINUE

   ! "b" version gets rid of the year thing; a version should keep the years intact
   if (((inddir.ne.8).and.(inddir.ne.12))) then !.or.(CURCALYR.LE.IBYR2)) then
      DO 100 IS=1,MPASTP
      DO 100 IFUEL=1,IFMAX(IS)
        IFX=IFLOC(IFUEL,IS)
        
        IF(IFX.LE.30) THEN
          ENPMQTY(IFX)=ENPMQTY(IFX)+ENPQTY(4,IFUEL,IS)
	    ELSE
          IF(IFX.LE.40) THEN
            IFY=IFX-30
            ENPIQTY(IFY)=ENPIQTY(IFY)+ENPQTY(4,IFUEL,IS)
          ELSE
            IFY=IFX-40
            ENPRQTY(IFY)=ENPRQTY(IFY)+ENPQTY(4,IFUEL,IS)
          ENDIF
        ENDIF
  100 CONTINUE
	
!paper industry -- primary fuel, steam, and biomass
	else if ((inddir.eq.8)) then ! .and.(CURCALYR.gt.ibyr2)) then

	DO IS=1,7 !MPASTP

		 ENPMQTY(1)=ENPMQTY(1)+ENPQTY(4,1,IS) !electric
		 ENPMQTY(3)=ENPMQTY(3)+ENPQTY(4,2,IS)  !ngas
		 ENPMQTY(7)=ENPMQTY(7)+ENPQTY(4,6,IS)  !sub bit coal
		 ENPMQTY(8)=ENPMQTY(8)+ENPQTY(4,7,IS)  !met coal
		 ENPMQTY(10)=ENPMQTY(10)+ENPQTY(4,3,IS) !residual
		 ENPMQTY(11)=ENPMQTY(11)+ENPQTY(4,4,IS) ! distillate
		 ENPMQTY(16)=ENPMQTY(16)+ENPQTY(4,5,IS) ! petcoke 
		 ENPMQTY(22)=ENPMQTY(22)+ENPQTY(4,8,IS) !other petroleum
		 
	enddo
		
            ENPRQTY(2:3)=0.0; ENPIQTY(1) =0.0 ! reinitialize for the new enprqty variables and enpiqty
		  ! let's calculate enprqty in this place only.   Have changed to PP_HOGFuel, which is all hogfuel used, both step 25 & steam 
		  !  NOTE:  reverting to the nonsteam hogfuel for now. Do we use ENPIQTY for paper?  However, do we need intermediate? we do this because renewable steam is not accounted for in ppis_bsc 
		   ! ENPRQTY(2)=(IND_FLOW_SHARE(inddir,1,indreg)*PP_HOGFuel/1.054615)*1.0E-6 
		   ENPRQTY(2)= IND_FLOW_SHARE(inddir,1,indreg)*((SUM(PAPER_HOG(1:26,curiyr))/1.054615)*1.0E-6 +PP_STEAM_Cogen(6)) ! trills; adding renewable steam; no boiler  
           ENPRQTY(3)= (IND_FLOW_SHARE(inddir,1,indreg)*ABS(SUM(PAPER_BLIQUOR(1:26,curiyr)))/1.054615)*1.0E-6 ! trills NOTE: setting to lower values causes runaway values   *1000000.0  /1.054615
           ! KPE --- old equation ENPIQTY(1)=SUM(PAPER_STEAM(1:26,curiyr))/1.054615*SteamRgShr(inddir,indreg)
		   ! now setting to the gross number because steam being generated uses energy too and we don't account in the ensqty variable for renewables
		   ! use this for paper?  This is meaningless; steam is included in the various fuel equations
            ENPIQTY(1)=((SUM(PAPER_STEAM_GRS(1:26,curiyr))/1.054615)*SteamRgShr(inddir,indreg))*1.0E-6  ! trills
			
        
      else if (inddir.eq.12) then


	  ENPMQTY(9)=NI_COKE(curiyr)*IND_FLOW_SHARE(inddir,7,indreg)*27.34/1000.0 !net coke imports (27.34 million btus/tonne)
	  DO IS=1,7 !MPASTP
         ENPMQTY(1)=ENPMQTY(1)+ENPQTY(4,1,IS) !electric
		 ENPMQTY(3)=ENPMQTY(3)+ENPQTY(4,2,IS)  !ngas
		 ENPMQTY(7)=ENPMQTY(7)+ENPQTY(4,6,IS)  !sub bit coal
		 ENPMQTY(8)=ENPMQTY(8)+ENPQTY(4,7,IS)  !met coal
		 ENPMQTY(10)=ENPMQTY(10)+ENPQTY(4,3,IS) !residual
		 ENPMQTY(22)=ENPMQTY(22)+ENPQTY(4,8,IS) !other petroleum
		 ENPIQTY(1)=STEAM_Total/1000000.0*SteamRgShr(inddir,indreg)

		 ENPMQTY(4)=0.0  !non core gas only used for steam production in steel
	  enddo


	endif


!****
!  ENERGY CONSUMPTION IS WRITTEN TO DEBUG FILE IF IWDBG=1.
!****
      IF(IWDBG.EQ.1) THEN
        IF(IOPEN.EQ.1.AND.LSTITER.EQ.1) WRITE(IUNIT1,512)
        DO 150 IFUEL=1,22
          IF(IOPEN.EQ.1.AND.LSTITER.EQ.1) &
            WRITE(IUNIT1,513) IFUEL,ENPMQTY(IFUEL)
  150   CONTINUE
        DO 160 IFUEL=1,6
          IF(IOPEN.EQ.1.AND.LSTITER.EQ.1) &
            WRITE(IUNIT1,513) IFUEL,ENPIQTY(IFuel)
  160   CONTINUE
        DO 170 IFUEL=1,8
          IF(IOPEN.EQ.1.AND.LSTITER.EQ.1) &
            WRITE(IUNIT1,513) IFUEL,ENPRQTY(IFUEL)
  170   CONTINUE
      ENDIF

!****
!  FORMAT STATEMENTS.
!****

  512 FORMAT(1X,'PROCESS/ASSEMBLY CONSUMPTION BY FUEL:')
  513 FORMAT(5X,'FUEL ',I4,F12.2)
  900 FORMAT(1X,'PSTEP,FUEL',I2,I2)
  901 FORMAT(1X,'TPUT,INTENSITY,CONSPTN')
  902 FORMAT(1X,F25.5,2X,F15.6,2X,F25.6)
  903 FORMAT(1X,F25.5,2X,F15.6,2X,F25.6)
  904 FORMAT(1X,'PROD',1X,F15.5)
  991 FORMAT(3X,'CALPATOT')

  
      RETURN
      END SUBROUTINE CALPATOT

      subroutine corncalc(is,ifuel,ifx)
   use i_
      implicit none
       integer ifuel,ifx,is
       integer idxEL/1/,idxNG/2/,idxDS/3/,idxLP/4/,idxMG/5/
       real cornfuel(5),nitrofuel
       real cornfac(5)/1.10,3.05,6.65,3.32,1.64/,nitrofac/23.4/
!                      EL,  NG,  DS,  LP,  MG,            ag chem ng feedstock (thousand Btu/bushel)
!  incremental corn production is assumed to be half the increase from 2007 for now
       integer bushel_base/18/ ! 2007
       if(inddir.eq.1) then
        cornfuel(1:5) = max(cornfac(1:5) * 0.5*(bushel(curiyr,indreg) - bushel(bushel_base,indreg)),0.)

           IF(IFX.eq.1)THEN
              enpqty(3,IFUEL,IS) = enpqty(3,IFUEL,IS) + cornfuel(idxEL)/1000.
              enpqty(4,IFUEL,IS) = enpqty(4,IFUEL,IS) + cornfuel(idxEL)/1000.
            ENDIF
            IF(IFX.eq.3)THEN
              enpqty(3,IFUEL,IS) = enpqty(3,IFUEL,IS) + cornfuel(idxNG)/1000.
              enpqty(4,IFUEL,IS) = enpqty(4,IFUEL,IS) + cornfuel(idxNG)/1000.
            ENDIF
            IF(IFX.eq.11)THEN
              enpqty(3,IFUEL,IS) = enpqty(3,IFUEL,IS) + cornfuel(idxDS)/1000.
              enpqty(4,IFUEL,IS) = enpqty(4,IFUEL,IS) + cornfuel(idxDS)/1000.
            ENDIF
            IF(IFX.eq.12)THEN
              enpqty(3,IFUEL,IS) = enpqty(3,IFUEL,IS) + cornfuel(idxLP)/1000.
              enpqty(4,IFUEL,IS) = enpqty(4,IFUEL,IS) + cornfuel(idxLP)/1000.
            ENDIF
            IF(IFX.eq.14)THEN
              enpqty(3,IFUEL,IS) = enpqty(3,IFUEL,IS) + cornfuel(idxMG)/1000.
              enpqty(4,IFUEL,IS) = enpqty(4,IFUEL,IS) + cornfuel(idxMG)/1000.
            ENDIF
       elseif (inddir.eq.9) then

            nitrofuel = 0.0
            nitrofuel = max(nitrofac * 0.5*(bushel(curiyr,indreg) - bushel(bushel_base,indreg)),0.)
            IF(IFX.eq.5)THEN
              enpqty(4,IFUEL,IS) = enpqty(4,IFUEL,IS) + nitrofuel/1000.
            ENDIF

       endif

      END SUBROUTINE CORNCALC

!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
! THIS SUBROUTINE CALCULATES TOTAL ENERGY CONSUMPTION FOR
!  THE BUILDINGS COMPONENT.
!****
      SUBROUTINE CALBTOT
   use i_
      IMPLICIT NONE
      real AveFprc
      external AveFprc

      INTEGER IS,IFUEL
      real emplxIBYR(numind,4),prodvxIBYR(numind,4)

      real BldPFac,BldPrat,BldElas/-0.5/
      integer iy,ifx
      real uec(4,5)
      real eweight/0.7/,pweight

      integer ibldloc(5)/1,3,30,11,12/ ! elec, core ng, steam , dist, lpg


      pweight=1.-eweight

      ir=indreg
      iy=curiyr

!****
!  CALCULATE ENERGY CONSUMPTION FOR LIGHTING AND HVAC.
!****

! NSK ibyr2 update 7/2020     
    IF ((inddir .eq. 8) .or. (inddir .eq. 10) .or. (inddir .eq. 11) .or. (inddir .eq. 12) .or. (inddir .eq. 13)) then   ! Process-flow industries           
      if(curiyr.eq.ibyr2-baseyr+1) then
        prodvxIBYR(inddir,indreg)=PRODVX
        emplxIBYR(inddir,indreg)=emplx
      endif
    ELSE                                                                                                                ! End-use industries      
      if(curiyr.eq.IBYR2-baseyr+1) then
        prodvxIBYR(inddir,indreg)=PRODVX
        emplxIBYR(inddir,indreg)=emplx
      endif
    END IF      
      
      do is=1,4
        do ifuel=1,5
           uec(is,ifuel)=0.
           if(prodvxIBYR(inddir,indreg).gt.0.0.and. &
              emplxIBYR(inddir,indreg).gt.0.0) &
           uec(is,ifuel)=enbint(is,ifuel)* &
           emplxIBYR(inddir,indreg)/prodvxIBYR(inddir,indreg)
        enddo
      enddo
      DO 70 IS=1,4
      DO 70 IFUEL=1,5

        ifx=ibldloc(ifuel)

!  Define a price-related factor to reduce energy consumption if price changes
! NSK ibyr2 update 7/2020
    IF ((inddir .eq. 8) .or. (inddir .eq. 10) .or. (inddir .eq. 11) .or. (inddir .eq. 12) .or. (inddir .eq. 13)) then   ! Process-flow industries
        BldPrat=AveFprc(ir,ibyr2-1989,curiyr,ifx) ! price change since history ended (base year)
    ELSE                                                                                                                ! End-use industries
        BldPrat=AveFprc(ir,ibyr2-1989,curiyr,ifx) ! price change since history ended (base year)
    END IF       

        BldPFac=BldPRat**BldElas

        ENBQTY(IS,IFUEL)= BldPFac * &
           (eweight*EMPLX*ENBINT(IS,IFUEL) &
          +pweight*prodvx*UEC(IS,IFUEL))

   70 CONTINUE
      DO 80 IFUEL=1,5
        ENBQTY(5,IFUEL)=sum(ENBQTY(1:4,IFUEL))  ! 5 is for total across 4 usage classes
   80 CONTINUE

!****
!  WRITE CONSUMPTION TO DEBUG FILE, IF ON.
!****

      IF(IWDBG.EQ.1) THEN
        IF(IOPEN.EQ.1.AND.LSTITER.EQ.1) WRITE(IUNIT1,974)
        DO 150 IFUEL=1,5
          IF(IOPEN.EQ.1.AND.LSTITER.EQ.1) &
            WRITE(IUNIT1,973) IFUEL,(ENBQTY(IS,IFUEL),IS=1,5)
  150   CONTINUE
      ENDIF

!****
!  FORMAT STATEMENTS.
!****

  973 FORMAT(5X,'FUEL ',I4,5F12.2)
  974 FORMAT(1X,'BUILDINGS CONSUMPTION BY FUEL:')
  991 FORMAT(3X,'CALBTOT')

      RETURN
      END SUBROUTINE CALBTOT
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!  pick which of 5 steam segment variables to use
!  return the fraction of steam by cogen load segment
      FUNCTION STEAMSEG(indus,iload)
   use i_
      implicit none
      real steamseg
      integer indus,iload

      if(indus.eq.7) then
        steamseg=SteamSeg_Food(iload)
      elseif(indus.eq.8) then
        steamseg=SteamSeg_Paper(iload)
      elseif(indus.eq.9) then
        steamseg=SteamSeg_Chem(iload)
      elseif(indus.eq.12) then
        steamseg=SteamSeg_Steel(iload)
      else
        steamseg=SteamSeg_Other(iload)
      endif
      return
      end FUNCTION SteamSeg
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
! THIS SUBROUTINE CALCULATES ELECTRICITY GENERATION FOR OWN
! USE AND SALES TO THE GRID.  IT ALSO CALCULATES STEAM USED
!  FOR COGENERATION.
!****
      SUBROUTINE CALGEN
   use i_
      IMPLICIT NONE
      real SteamSeg
      External SteamSeg
      real AggSteamLoad,AveHourlyLoad,TechPotMW(nload+1), &
       EconPotMw(nload+1),CapAddMW, &
       CapAddGWH,NonCogStm,escalng,escalel,totq1,totq2
      real capaddsum,techpotsum,econpotsum,dshr,suminvest,capcost
      real StmAddTril,BioAddElf,BioAddStm
      integer il,isys
      real jfrac
      real bio
      INTEGER IT
      INTEGER MY,K,L,M,n

      integer fuel,div
      real BioAvail(4,MNUMYR)   ! save amount of byproduct biofuels available, paper only
      real BioAddGwh, BioAddMW,gen,stm,avehtrt,BioAddHtRt, BioDeclineRate
! added for byproduct steam calculation
      real bysqty(10)
      real avgint,tdem
      integer ifx,ify,ifuel
! end of additions for byproduct steam calculation

! added so boiler efficiency-related calculations would parallel CALSTOT
      real bypbeff(6)/0.69,0.69,0.69,0.69,0.69,0.69/   ! 69 percent match boiler eff, prior value was 65 percent based on oit steam and cibo reports
! end of boiler efficiency-related additions

      integer rtovalue,behave,AB32SW
      external rtovalue

      real cf(4),penetrate
      real biofactor/0.90/   ! incremental bio available for cogen (ei867/MECS)
      real biocapfac/.666/   ! assumed capacity factor to convert new bio-gen to capacity
      integer pyr,pyear      ! lookahead removed
      real W_Util(5)         ! POT_08/01/2013 Historical utilizations for the past five years
      integer util_yr        ! POT_08/01/2013 Year of history used in Do loop

      real newgen, oldgrd, newgrd, coggrdnew(numind)

! coggrdnew:  Assumed grid share for new capacity additions
!    Initialized from exstcap.txt, average of 2004-2010/US(11)/"all fl"(11)
      data coggrdnew/ &
      0.1674, & ! agcrop
      0.1429, & ! agother
      0.0000, & ! coal min
      0.0000, & ! O&G min
      0.7063, & ! met min
      0.0000, & ! cons
      0.0326, & ! Food.
      0.0949, & ! Paper
      0.2653, & ! B-chem
      0.0000, & ! Glass
      0.0117, & ! cement
      0.2686, & ! steel
      0.2729, & ! allum
      0.0000, & ! fab metals
      0.0000, & ! machinery
      0.0039, & ! computers
      0.0809, & ! transportation
      0.9352, & ! electrical equip
      0.5653, & ! wood products
      0.0181, & ! plastics
      0.1516/   ! BOM

! coggrdnew:  Assumed grid share for new capacity additions
!    Initialized from exstcap.txt, 2008/US(11)/"all fl"
!      data coggrdnew/ &
!      0.2827, & ! agcrop
!      0.0399, & ! agother
!      0.0000, & ! coal min
!      0.0000, & ! O&G min
!      0.8216, & ! met min
!      0.0000, & ! cons
!      0.2633, & ! Food.
!      0.1926, & ! Paper
!      0.2937, & ! B-chem
!      0.0000, & ! Glass
!      0.2434, & ! cement
!      0.1139, & ! steel
!      0.1561, & ! allum
!      0.1965, & ! fab metals
!      0.3902, & ! machinery
!      0.0099, & ! computers
!      0.1455, & ! transportation
!      0.0953, & ! electrical equip
!      0.6482, & ! wood products
!      0.0000, & ! plastics
!      0.1805/   ! BOM

      Real  RegCHPScore(4)/0.335,0.175,0.235,0.255/     ! Remove scaling; only scaling should be done to the penetration variable in indcogenx.xlsx
                                                        ! Regional penetration adjustment based on
                                                        ! 2017 CHP capacity and 2016 ACEEE Scorecard - calculated in
												        ! ..\Industrial_Team\US\AEO\AEO2019\projects\chp_update/state chp (updated to 2017 data and with revised factors).xlsx
      if(inddir.eq.1.and.indreg.eq.1) Then
        suminvest=0.
      endif
      YR = IYR - 1989
      IF(INDREG.EQ.1) THEN
        L = 1
        M = 2
      ELSE IF(INDREG.EQ.2) THEN
        L = 3
        M = 4
      ELSE IF(INDREG.EQ.3) THEN
        L = 5
        M = 7
      ELSE IF(INDREG.EQ.4) THEN
        L = 8
        M = 9
      ENDIF

!  Check runtime option to turn AB32SW switch for implementation of AB32 cap-and-trade in State of California.
!  The default setting is ON (1).
!
      AB32SW=RTOVALUE('AB32SW  ',1)

! Estimate economic attractiveness of typical cogen systems for various steam loads.
!   1) Assign Projection of next few year's price in 2018 dollars for cogen evaluation
        cogFuelPrice=0.
        cogElecPrice=0.
        jfrac=0.

        pyear=curcalyr
        pyr=curiyr

!       lookahead=0                     ! assume myopic--zero future years considered
        jfrac=1./(1.+float(lookahead))  ! used for price averaging over the current and "lookahead" years
        do j=0,lookahead                ! loop over current year and once for each lookahead year
          escalng=0.
          escalel=0.
          totq1=0.
          totq2=0.
          do i=L,M  ! get average escalation across divisions in this region
            totq1=totq1+QGFIN(i,pyr)
            totq2=totq2+QELIN(i,pyr)
          enddo
          do i=L,M
            IF(AB32SW.EQ.1) THEN
              escalng=escalng+ &
                 ((aGFIN(i,MIN(ijumpyr,pyr+j))*CARBSHR_AB(inddir,indreg) + pGFIN(i,MIN(ijumpyr,pyr+j))*(1.-CARBSHR_AB(inddir,indreg))) / &
                  (aGFIN(i,pyr)              *CARBSHR_AB(inddir,indreg) + pGFIN(i,pyr)              *(1.-CARBSHR_AB(inddir,indreg)))) &
                 * qgfin(i,pyr)/totq1
              escalel=escalel+ &
                 (aELIN(i,MIN(ijumpyr,pyr+j))/aELIN(i,pyr)) &
                 * qelin(i,pyr)/totq2
            ELSE
            escalng=escalng+ &
               ((aGFIN(i,MIN(ijumpyr,pyr+j))*carbshr(inddir) + pGFIN(i,MIN(ijumpyr,pyr+j))*(1.-carbshr(inddir))) / &
                (aGFIN(i,pyr)              *carbshr(inddir) + pGFIN(i,pyr)              *(1.-carbshr(inddir)))) &
               * qgfin(i,pyr)/totq1
            escalel=escalel+ &
               (aELIN(i,MIN(ijumpyr,pyr+j))/aELIN(i,pyr)) &
               * qelin(i,pyr)/totq2
            ENDIF
          enddo
          CogFuelPrice=CogFuelPrice+PRCX(3,indreg,1)*escalng

          CogElecPrice=CogElecPrice+PRCX(1,indreg,1)*escalel

        enddo
        call cogent     ! reads cogen assumptions spreadsheet (done once)
        CogFuelPrice=CogFuelPrice*jfrac * MC_JPGDP(DollarYearCHP-BASEYR+1)  ! average prices and convert to year dollars used in indcogenx (2018$ as of AEO2022) to match cap costs
        CogElecPrice=CogElecPrice*jfrac * MC_JPGDP(DollarYearCHP-BASEYR+1)
                     
        CogElecPrice=CogElecPrice*(1.-StandByFrac)


        
! POT_08/01/2013 Start - utilizaton code

!***** compute utilization fractions for economic assessment.
          RegCHPutil(:,:)=0.
          maxRegCHPutil(:,:)=0.
         W_Util(:)=0.

         do util_yr=1,5
           if(sum(cogcap(l:m,maxcogyr-util_yr,inddir,11)).gt.0.0) W_Util(util_yr)= (sum(coggen(l:m,maxcogyr-util_yr,inddir,11))/  &
                                                                                    sum(cogcap(l:m,maxcogyr-util_yr,inddir,11)))/8.760 ! Historical util
           if(W_Util(util_yr).lt.0.0.or.W_Util(util_yr).gt.1.0) W_Util(util_yr)=0.0   ! Check for valid data.
         enddo

         if(sum(cogcap(l:m,maxcogyr,inddir,11)).gt.0) RegCHPutil(indreg,inddir)=(sum(coggen(l:m,maxcogyr,inddir,11))/  &
                                                                                 sum(cogcap(l:m,maxcogyr,inddir,11)))/8.760

         maxRegCHPutil(indreg,inddir)=max(0.05,RegCHPutil(indreg,inddir),W_Util(1),W_Util(2),W_Util(3),W_Util(4),W_Util(5))

         if(maxRegCHPutil(indreg,inddir).gt.1.0) write(6,'(5x,a,f10.6,2x,2(i4,2x))') '==== ERROR Utilization of CHP too HIGH ',  &
                                                 maxRegCHPutil(indreg,inddir), inddir, indreg

         if(inddir.eq.18.and.indreg.eq.1) write(6,'(5x,a,f10.6,2x,5(f10.6,2x))') 'inddir=18 indreg=1 ',RegCHPutil(indreg,inddir),W_Util(1:5)

!*****  Quality Check on CHP data from OES (exst.cap)
         if(maxRegCHPutil(indreg,inddir).gt.0.90) maxRegCHPutil(indreg,inddir)=0.90
         if(maxRegCHPutil(indreg,inddir).lt.0.05) maxRegCHPutil(indreg,inddir)=0.05
         if(RegCHPutil(indreg,inddir).gt.0.90) RegCHPutil(indreg,inddir)=0.90
         if(RegCHPutil(indreg,inddir).lt.0.05) RegCHPutil(indreg,inddir)=0.05

         if(RegCHPutil(indreg,inddir).gt.maxRegCHPutil(indreg,inddir)) write(6,'(5x,a,2(f10.6,2x),2(i4,2x))') '==== ERROR Utilization of CHP ',  &
                                                                       maxRegCHPutil(indreg,inddir), RegCHPutil(indreg,inddir), inddir, indreg

        ! write(6,'(5x,a,2(f10.6,2x),2(i4,2x))') '==== CHP utilization (current, max) = ',  &
        !                                     RegCHPutil(indreg,inddir),maxRegCHPutil(indreg,inddir),inddir,indreg
! POT_08/01/2013 END

        call evalcogen(0,CURIYR+BASEYR-1)    ! evaluate a set of cogen systems at current prices

! ***********************************************
! *** note that the fuel order for coggen is: ***
! *** coal, oil, gas, wood, other, msw        ***
! ***********************************************

      if(inddir.eq.8) then
        bioavail(indreg,yr)=bypbscr(2)+bypbscr(3)
      endif

!****
!  TOTAL STEAM DEMAND FROM THE BLD AND PA COMPONENTS.
!****
! NSK ibyr2 update 7/2020
      STEMCUR=ENBQTY(2,3)+ENPIQTY(1)

    IF ((inddir .eq. 8) .or. (inddir .eq. 10) .or. (inddir .eq. 11) .or. (inddir .eq. 12) .or. (inddir .eq. 13)) then   ! Process-flow industries
      if(curcalyr.eq.ibyr2) stemcurlag=stemcur
    ELSE                                                                                                                ! End-use industries
      if(curcalyr.eq.ibyr2) stemcurlag=stemcur    
    END IF
    
      if(stemcur.lt.0.) stemcur=0.
      
!****
!  CALCULATE THE AMOUNT OF STEAM GENERATED BY THE BYPRODUCT FUELS.
!****

      BYPSTMM=0.0
      BYPSTMI=0.0
      BYPSTMR=0.0
      DO IFuel=1,IFSBYP
        IFX=IFSLOCBY(IFuel)
        IF(IFX.LE.30) THEN
          BYSQTY(IFuel)=BYPBSCM(IFX)
          BYPSTMM=BYPSTMM+(BYSQTY(IFuel)*bypbeff(IFuel))
        ELSEIF(IFX.LE.40) THEN
          IFY=IFX-30
          BYSQTY(IFuel)=BYPBSCI(IFY)
          BYPSTMI=BYPSTMI+(BYSQTY(IFuel)*bypbeff(IFuel))
        ELSE
          IFY=IFX-40
          BYSQTY(IFuel)=BYPBSCR(IFY)
          BYPSTMR=BYPSTMR+(BYSQTY(IFuel)*bypbeff(IFuel))
        ENDIF
      ENDDO
      BYPSTM=BYPSTMM+BYPSTMI+BYPSTMR  ! why is this never used?


!   call COGINIT to initialize the cogeneration data arrays with
!   generation, capacity, fuel use based on form 860b data/or prior year data and planned builds,

      CALL COGINIT(INDREG)

      if(inddir.eq.1.and.indreg.eq.1)then
        capaddsum=0.
        techpotsum=0.
        econpotsum=0.
      endif

! Next line controls start year for Cogen model builds (unplanned additions)
      if(curiyr.gt.maxcogyr) then ! this ends at label 100
!        beginning with year beyond the last history year, which was 2008 in aeo2010,
!  Assess cogen potential, ignoring any prior year 'model' additions.
!  All new systems are assumed to be gas turbines, except for Byproduct-fueled cogen which is
!  handled separately.
!  This potential will vary as steam loads change and expected fuel prices change.  Given this
!  total potential, assume a fraction of it is added for the current year.  Thus, the
!  amount of cogeneration capacity added in any year is proportional to the total
!  economic potential over the projected period as determined from current year conditions.
!
!    See Subr EvalCogen for economic assessment of candidate systems

         NonCogStm=STEMCUR-cogsteamhist(inddir,indreg) !  Steam not generated by existing cogen or biofuels
         
         if(NonCogStm .lt. 0.0) nonCogStm=0.0
         CapAddGWH=0.
         CapAddMW=0.
         techpotmw(nload+1)=0.
         econpotmw(nload+1)=0.
         gen=0.
         avehtrt=0.
         StmAddTril=0.
         stm=0.
         DO il=1,nload                                         ! load segments. see icogen.wk1 for example
           isys=CogSys(il)                                     ! system as sized for the given segment
           AggSteamLoad  = NonCogStm*SteamSeg(inddir,il)       ! Fraction of Agg. Steam within the load segment
           AveHourlyLoad = AggSteamLoad /.008760               ! Average hourly steam load in segment (tot., not per-site)
           TechPotMW(il) = AveHourlyLoad*PowerSteam(isys)/3.412 ! Assume all candidate systems sized to meet average load in segment
           EconPotMW(il) = TechPotMW(il)*EconFrac(il)           ! Total Economic Potential based on Payback Acceptance Assumptions
           penetrate=penetration(il)*RegCHPScore(indreg)
           
           
! increase yearly penetration fraction of the economic potential during periods with ITCs
           if(IYR.GE.CapCostMultStart.AND.IYR.LE.CapCostMultEnd.and.CapCostMult(isys).lt.0.97) then
             penetrate=penetrate*1.25  ! normally about 1/20 of the potential added each year.  this speeds it up to 1/16 during ITC period
           endif
           CapAddMW      = CapAddMW +                           & ! Accumulate over iload
                          EconPotMW(il)*Penetrate               ! yearly penetration , mw, for this iload
           gen=          (EconPotMW(il)*Penetrate) * 8.670 *   & ! yearly penetration, mw POT_08/01/2013
                           (RegCHPutil(indreg,inddir) + ((maxRegCHPutil(indreg,inddir) - RegCHPutil(indreg,inddir)) / & ! used to achieve max historical utilization
                           (IEYR - 2011)) * (curcalyr - 2011)) ! to a historical high  POT_2050 2040 to IEYR
           CapAddGWH     = CapAddGWH + gen                      ! Accumulate over iload

           stm=           (gen*3412./10.**6)/PowerSteam(isys)  ! keep track of annual steam provided
           StmAddTril    = StmAddTril+stm
           techpotmw(nload+1)=techpotmw(nload+1)+techpotmw(il)
           econpotmw(nload+1)=econpotmw(nload+1)+econpotmw(il)
           capaddsum=capaddsum+EconPotMW(il)*Penetrate
           techpotsum=techpotsum+techpotmw(il)
           econpotsum=econpotsum+econpotmw(il)
           avehtrt=avehtrt+gen*CHeatRate(isys)
           CapCost=CogCapCostKW(isys)
           if(IYR.GE.CapCostMultStart.AND.IYR.LE.CapCostMultEnd) Then
             CapCost=CogCapCostKW(isys)*CapCostMult(isys)
           endif
           suminvest=suminvest+EconPotMW(il)*Penetrate*CapCost
         ENDDO
         if(capaddGWH.gt.0) then
            avehtrt=avehtrt/capaddGWH
         endif

         if(prtdbgi.eq.3)then
           do il=1,nload+1
             if(il.le.nload)then
             write(6,'(a,i4,i3,a,i1,i2,4f10.3)') 'cogen',iyr, &
              inddir,' R',indreg,il, &
              techpotmw(il),econpotmw(il),econfrac(il),Cpayback(il)
             else
             write(6,'(a,i4,i3,a,i1,i2,2f10.3,20x,2f10.3)') 'cogen', &
              iyr,inddir,' R',indreg,il, &
              techpotmw(il),econpotmw(il),CapAddMW,CapAddGWH
             endif
           enddo
         endif
         if(inddir.eq.numind.and.indreg.eq.4.and.prtdbgi.eq.3) then
           write(6,'(a,i4,f12.1)') &
          'cogen , total technical potential ',iyr,techpotsum
           write(6,'(a,i4,f12.1)') &
          'cogen , total economic potential ',iyr,econpotsum
           write(6,'(a,i4,f12.1)') &
          'cogen , total capacity additions ',iyr,capaddsum
           write(6,'(a,i4,f12.1)') &
          'cogen , total investment, bill 2018$ ',iyr,suminvest*.001
          
         endif

!  Loop over census divisions in current region, and add in unplanned
!  capacity additions for biomass and other cogen builds determined from economic
!  assessment above

         do i=L,M  ! divisions in current region
           dshr= 1./float(M-L+1)      ! this division's share of the census region


!        Byproduct adds in the paper industry, steam turbine (pm=3)
!        Use for cogen = ratio of ei867 biomass to MECS biomass
           if(inddir.eq.8) then
             fuel=7
             bio= biofactor * (bioavail(indreg,curiyr)-bioavail(indreg,curiyr-1))
!        Add paper-biofuel-steam cogen based on increment of biofuels available
!        but don't let a decline in availability affect anything.
!        convert Btus x10^12 to gwh (kwh x 10^6)
             BioAddHtRt=25000.
             if(CurCalYr.gt.techstrtyr.and.hitech.eq.1) then
                BioDeclineRate=(25000.-17000.)/(2020.-2002.)  !
                BioAddHtRt=25000. - BioDeclineRate*(CurCalYr-2003)
                if(BioAddHtRt.lt.17000.) BioAddHtRt=17000.
             endif
             BioAddGwh=max(0.,(bio/BioAddHtRt))*10.**6
             BioAddMW=(BioAddGwh/8.766)/BioCapFac
! steam from bio assumed to be based on 80 percent thermal efficiency and a
! electricity incremental heatrate of 12700. (12700 is based on the average fuel allocated
! to electricity for biomass cogen units in 2000 in the CNEAF 860b data.)
! Eg., for a 25000 total electric heatrate, 12700 input btus used for electric, and 12300 used for steam.  Useful
! Steam assumed to be 80% of 12300, or 9840.  Assumed Power steam ratio is about .35, and overall
! efficiency about 51%. (9840+3412)/25000.  At a total heatrate of 17000, if the electric efficiency re
! mains at 12700, the useful thermal drops to 3440 (17000-12700)/.8, so the power steam ratio
! rises to about .99 (3412/3440) and the overall efficiency drops to about .40 (=(3412+3440)/17000)

             BioAddElf=BioAddGwh*12700./10.**6
             BioAddStm=(bio - BioAddElf)/.8

             newgen=BioAddGWH*dshr
             oldgrd=coggen(i,curiyr,inddir,fuel)*coggrd(i,curiyr,inddir,fuel)
             newgrd=newgen*coggrdnew(inddir)
             coggrd(i,curiyr,inddir,fuel)=(oldgrd+newgrd)/ &
                            (coggen(i,curiyr,inddir,fuel)+newgen)

             coggen(i,curiyr,inddir,fuel)= BioAddGWH*dshr + &
             coggen(i,curiyr,inddir,fuel)

             cogcap(i,curiyr,inddir,fuel)= BioAddMW *dshr + &
             cogcap(i,curiyr,inddir,fuel)

             cogthr(i,curiyr,inddir,fuel)= BioAddStm*dshr + &
             cogthr(i,curiyr,inddir,fuel)

             cogelf(i,curiyr,inddir,fuel)= BioAddElf*dshr + &
             cogelf(i,curiyr,inddir,fuel)


           endif

!        Gas Turbine/CC Adds -- based on the investment/penetration method above
           fuel=3  ! natural gas

           newgen=CapAddGWH*dshr
           oldgrd=coggen(i,curiyr,inddir,fuel)*coggrd(i,curiyr,inddir,fuel)
           newgrd=newgen*coggrdnew(inddir)
           if(newgen+coggen(i,curiyr,inddir,fuel).gt.0) then
             coggrd(i,curiyr,inddir,fuel)=(oldgrd+newgrd)/ &
                            (coggen(i,curiyr,inddir,fuel)+newgen)
           endif
           coggen(i,curiyr,inddir,fuel)=CapAddGWH*dshr  +    &
           coggen(i,curiyr,inddir,fuel)

           cogcap(i,curiyr,inddir,fuel)=CapAddMW*dshr   +    &
           cogcap(i,curiyr,inddir,fuel)

           cogthr(i,curiyr,inddir,fuel)=StmAddTril*dshr +    &
           cogthr(i,curiyr,inddir,fuel)

           cogelf(i,curiyr,inddir,fuel)=((CapAddGWH*avehtrt/10.**6)-(StmAddTril/.8))*dshr  + &
           cogelf(i,curiyr,inddir,fuel)

         enddo ! i .. divisions

100   endif     ! of IF(iyr.gt.(maxcogyr))

!****
      CALL CALCGSH ! calculate average grid share for each region (average over census div and fuel)

!********
!     Total generation by grid, own-use across fuels and census divisions for this industry
!********
      elsale=sum(coggen(l:m,curiyr,inddir,1:numflchp)*coggrd(l:m,curiyr,inddir,1:numflchp))
      elown =sum(coggen(l:m,curiyr,inddir,1:numflchp)*(1.-coggrd(l:m,curiyr,inddir,1:numflchp)))

      RETURN
      END SUBROUTINE CALGEN
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
! 6 CALCULATES THIS YEAR'S BOILER FUEL SHARES.
! THE FUELS INCLUDED HERE ARE THE PURCHASED FUELS ONLY, THAT
! IS, NO BYPRODUCT FUELS.
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

      SUBROUTINE CALBSC
   use i_
      IMPLICIT NONE
      real AveFPrc
      external AveFPrc
      REAL ALPHA,W(4)
      REAL OILSHARE,TSHR,SUMOIL
      REAL LSUM
      INTEGER IFF
      integer IFuel     ! index for fuel looping
! make fuel switching parameter a function of price if really big prices
      REAL SwitchBeta/2./    ! controls swing from default to maximum switch parameter
      REAL SwitchPrat        ! Ratio of current Prices to base year Prices
      REAL SwitchPriceFactor ! Multiplier on switch rate due to energy price response
      Real X
      Integer IY
      integer rtovalue,behave


      real maxcoal,renorm
      real coalPfac/1.33/    ! Factor to account for non-price cost associated with coal use
      real ngasPfac/1.00/    ! Factor to reflect NGAS as "premium" fuel
      real oilPfac/1.17/     ! Factor to reflect oil as "discount" fuel
      real elecPfac/1.00/    ! CHP Factor to reflect electricity as equivalent to natural gas in "premiumness"
      integer icoal
! Average boiler efficiencies   NG, coal, resid, distl, LPG, electricity petcoke, oth, ?ydro? biomass, electric #6, total
      real avebeff(11)/0.78,0.83,0.84,0.8,0.76,0.98,0.8,0.8,0.8,0.69,0.8/         ! Multiple sources


!****
!  WRITE SUBROUTINE TRACE IF ON.
!****

      IF(ISUBTR.EQ.1.AND.IOPEN.EQ.1.AND.LSTITER.EQ.1) &
        WRITE(IUNIT1,991)

! *** assign the behave runtime variable            ***
! *** the values are 1=lazy, 2=normal, 3=aggressive ***
! *** normal is normally the default                ***
      behave=rtovalue('BEHAVE  ',2)

      ir=indreg
      iy = iyr - 1989

      sumoil=BSCIBYR(inddir,indreg,2)
      DO IFuel=1,IFSMAX              ! Loop over all fuels-kpe see lines 2446 for assignments--don't quite understand
      ! First share out petroleum-based fuels
        IF(IFSLOC(IFuel).EQ.10.OR.IFSLOC(IFuel).EQ.11.OR. &
          IFSLOC(IFuel).EQ.12.OR.IFSLOC(IFuel).EQ.14.OR.IFSLOC(IFuel).EQ.15 &
         .OR.IFSLOC(IFuel).EQ.16.OR.IFSLOC(IFuel).EQ.20.OR. &
          IFSLOC(IFuel).EQ.22) THEN

          BSFUELSHR(INDDIR,INDREG,Ifuel)=0.
          if(sumoil.gt.0.) then
            if(IFSLOC(IFUEL).eq.10) then                           ! Residual Oil
              BSFUELSHR(INDDIR,INDREG,IFuel)=(BSCIBYR(inddir,indreg,7)/sumoil)*avebeff(ifuel)
            elseif(ifsloc(ifuel).eq.11) then                       ! Distillate Oil
              BSFUELSHR(INDDIR,INDREG,IFuel)=(BSCIBYR(inddir,indreg,8)/sumoil)*avebeff(ifuel)
            elseif(ifsloc(ifuel).eq.12)then                        ! LPG H&P
              BSFUELSHR(INDDIR,INDREG,IFuel)=(BSCIBYR(inddir,indreg,9)/sumoil)*avebeff(ifuel)
            elseif(ifsloc(ifuel).eq.16)then                        ! Pet Coke
              BSFUELSHR(INDDIR,INDREG,IFuel)=(BSCIBYR(inddir,indreg,11)/sumoil)*avebeff(ifuel)
            elseif(ifsloc(ifuel).eq.22)then                        ! Other Petro
              BSFUELSHR(INDDIR,INDREG,IFuel)=(BSCIBYR(inddir,indreg,10)/sumoil)*avebeff(ifuel)
            else
              BSFUELSHR(INDDIR,INDREG,IFuel)=0.
            endif
          else  ! if oil currently zero, set share for resid to 1 for future use
            if(ifsloc(ifuel).eq.10) then
               bsfuelshr(inddir,indreg,ifuel)=1.0
            endif
          endif
      ! Now handle all non-petroleum-based fuels
        elseif(ifsloc(ifuel).eq.4) then                           ! NG
           bsfuelshr(inddir,indreg,ifuel)=tlbshr(inddir,indreg,2)*avebeff(ifuel)
        elseif(ifsloc(ifuel).eq.7) then                           ! Coal
           bsfuelshr(inddir,indreg,ifuel)=tlbshr(inddir,indreg,3)*avebeff(ifuel)
        elseif(ifsloc(ifuel).eq.1) then                           ! electricity
           bsfuelshr(inddir,indreg,ifuel)=tlbshr(inddir,indreg,7)*avebeff(ifuel)
        endif
      enddo

!   ASSIGN PRICES AND COEFFICIENTS TO DUMMY VARIABLES
!   W1=>GAS,W2=>COAL,W3=>OIL

!   First set the "default" alpha
       Alpha=TLBSHR(INDDIR,INDREG,1) ! this is the default value

! NSK ibyr2 update 7/2020
    IF ((inddir .eq. 8) .or. (inddir .eq. 10) .or. (inddir .eq. 11) .or. (inddir .eq. 12) .or. (inddir .eq. 13)) then   ! Process-flow industries
        SwitchPrat=AveFPrc(ir,ibyr2-1989,curiyr,31) ! AveFPrc returns price change since history ended (base year)
    ELSE                                                                                                                ! End-use industries
        SwitchPrat=AveFPrc(ir,ibyr2-1989,curiyr,31) ! AveFPrc returns price change since history ended (base year)    
    END IF
       
       x=SwitchPrat**SwitchBeta
       SwitchPriceFactor=X/(1.0+X)

! ***** no switching differnce for either high or low tech *****
!      if(SwitchPrat.gt.1.05) then
!         Alpha=4.*TLBSHR(INDDIR,INDREG,1) * SwitchPriceFactor
!      endif

!      if(SwitchPrat.gt.1.05) then
!        if(behave.eq.2.and.curcalyr.le.2005) then  ! regular behavior and not high technology
!         Alpha=4.*TLBSHR(INDDIR,INDREG,1) * SwitchPriceFactor
!        elseif(hitech.eq.1.and.curcalyr.gt.(2005)) then ! high technology scenario, starts 2005 (aeo2004)
!         Alpha=4.5*TLBSHR(INDDIR,INDREG,1) * SwitchPriceFactor
!        elseif(frztech.eq.1.and.curcalyr.gt.2005) then
!         Alpha= TLBSHR(INDDIR,INDREG,1)
!        endif
!      endif


       W(1) = ngasPfac*PRCX(4,INDREG,3)/PRCXIBYR(1,INDREG) ! indexed price of gas (base year not = 1)
       W(2) = coalPfac*PRCX(7,INDREG,3)/PRCXIBYR(2,INDREG) ! indexed price of coal
       W(3) = oilPfac*PRCX(10,INDREG,3)/PRCXIBYR(3,INDREG) ! indexed price of residual fuel
       W(4) = elecPfac*PRCX(1,INDREG,3)/PRCXIBYR(4,INDREG)  ! indexed price for electric--ntoe index at end

       LSUM = 0.0
       DO I = 1,4
          if(w(i).le.0.05) w(i)=.05  ! prevent zero raised to negative exp (alpha) when coal or other prices set to zero
	!	  if (i.lt.4) then
          LSUM = LSUM +  (W(I)**ALPHA)*TLBSHR(INDDIR,INDREG,I+1)*avebeff(ifuel)
!		  else
       !     LSUM = LSUM +  (W(I)**ALPHA)*TLBSHR(INDDIR,INDREG,7)*avebeff(10)
 !         endif			
       ENDDO

      renorm=1.0
      icoal=0
      DO IFuel=1,IFSMAX
     ! Petroleum based products
       IF(IFSLOC(IFuel).EQ.10.OR.IFSLOC(IFuel).EQ.11.OR. &
          IFSLOC(IFuel).EQ.12.OR.IFSLOC(IFuel).EQ.14.OR.IFSLOC(IFuel).EQ.15 &
          .OR.IFSLOC(IFuel).EQ.16.OR.IFSLOC(IFuel).EQ.20.OR. &
          IFSLOC(IFuel).EQ.22) THEN
         IF(LSUM.GT.0.0) &
          BSSHR(IFuel) = ((W(3)**ALPHA)*TLBSHR(INDDIR,INDREG,4)*avebeff(ifuel)/LSUM)* &
                            BSFUELSHR(INDDIR,INDREG,IFuel)
         ENDIF

       ! Natural Gas
         IF(IFSLOC(IFuel).EQ.4) THEN
           IF(LSUM.GT.0.0) &
             BSSHR(IFuel) = (W(1)**ALPHA)*TLBSHR(INDDIR,INDREG,2)*avebeff(ifuel)/LSUM
           ENDIF

       ! Coal
         IF(IFSLOC(IFuel).EQ.7) THEN
         IF(LSUM.GT.0.0) then
           if(TLBSHR(INDDIR,INDREG,3).gt. 0.0) icoal=ifuel
           BSSHR(IFuel) = (W(2)**ALPHA)*TLBSHR(INDDIR,INDREG,3)*avebeff(ifuel)/LSUM
           ENDIF
	     ENDIF ! coal
		 ! electricity BSSHR index is 6, 
	     IF(IFSLOC(IFuel).EQ.1)  THEN 
			BSSHR(IFuel) = (W(4)**ALPHA)*TLBSHR(INDDIR,INDREG,5)*avebeff(IFuel)/LSUM
		 ENDIF	! electric

      ENDDO
! normalize boiler shares
      LSUM=0.
      do IFUEL=1,IFSMAX
        lsum=lsum+bsshr(ifuel)
      enddo
      if((lsum.ne.0).and.(abs(lsum-1.).gt.0.001)) then
        do ifuel=1,ifsmax
           bsshr(ifuel)=bsshr(ifuel)/lsum
        enddo
      endif



! NSK ibyr2 update 7/2020    
    IF ((inddir .eq. 8) .or. (inddir .eq. 10) .or. (inddir .eq. 11) .or. (inddir .eq. 12) .or. (inddir .eq. 13)) then   ! Process-flow industries
        if(curcalyr.eq.ibyr2) then
            bsshrlag=bsshr
        endif
    ELSE                                                                                                                ! End-use industries
        if(curcalyr.eq.ibyr2) then
            bsshrlag=bsshr
        endif    
    END IF
      
! assume coal boiler capacity will have limited growth overtime and that the coal share
! cannot increase over current share. icode to make sure that will keep
! coal-steam from growing is:  (stemcurlag/stemcur)*bssshrlag(coal).
! will reverse some of this but should keep coal steam from growing as fast as stemcur

       if(icoal.ne.0) then ! indicates coal is used and has nonzero bsshr
          if(stemcur.ne.0.) maxcoal=(stemcurlag/stemcur)*bsshrlag(icoal)
          if(bsshr(icoal).gt.maxcoal.and.bsshr(icoal).ne.1.) then
            renorm=(1.-maxcoal)/(1.-bsshr(icoal))  ! prepare to renormalize other boiler shares
            bsshr(icoal)=maxcoal ! don't let coal steam increase
            do ifuel=1,ifsmax
              if(ifuel.ne.icoal) then
                bsshr(ifuel)= bsshr(ifuel)*renorm
              endif
            enddo
          endif
       endif

       if(prtdbgi.gt.1) then
         if(indreg.eq.1) write(6,'(a,15I6)')'               Ind Reg ',(ifsloc(ifuel),ifuel=1,ifsmax)
         write(6,'(a,2I4,15F6.3)') 'Boiler Shares:',inddir,indreg,bsshr(1:ifsmax),sum(bsshr(1:ifsmax))
       endif

!  FORMAT STATEMENTS.
  991 FORMAT(3X,'CALBSC')
      RETURN
      END SUBROUTINE CALBSC

!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!  THIS SUBROUTINE CALCULATES TOTAL FUEL CONSUMPTION IN THE
!  BOILER/STEAM COGENERATION COMPONENT.
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
      SUBROUTINE CALSTOT
   use i_
      IMPLICIT NONE

      real fuelsys(numflchp)      ! Cogen System Fuel by fuel type
      real fuelelec(numflchp)     ! Elec portion of cogen system fuel by fuel type
      real fuelcogsteam(numflchp) ! process steam portion of cogen system fuel
!      real cogsteam          ! total steam from fuelcogsteam
!      real noncogsteam       ! stemcur-cogsteam, or the non cogenerated steam
!      real biosteam          ! steam from availbiomass (this is non cogen biomass steam)
!      real noncogfossteam    ! Non-cogen steam from fossill (=noncogsteam-biosteam)
!      real fuelfossteam(11)  ! fuel used to generate noncogfossteam, by type
!      real CogBoilFuel(10)   ! Cogen Boiler Fuel Use (fossil only)
      real availbiomass      ! bioproduct fuel used in non cogen boilers (bioproduct less fuelsys(3,4)
! boiler efficiencies   NG, coal, resid, distl, LPG, petcoke, oth, ?ydro? biomass, dummy, electric

      real beff(11)/0.78,0.83,0.84,0.8,0.76,0.8,0.8,0.8,0.69,0.98,0.80/           ! same as CALBSC
!     real beff(6)/0.806,0.82,0.80,0.65,0.65,0.65/  ! use 65 percent based on oit steam and cibo reports
!     real beff(6)/0.806,0.82,0.80,0.74,0.74,0.74/
      real noncogfosfuel     ! Non-cogen fossil fuel to make noncogfossteam
      real TotCogBoilFuel    ! total fossil boiler fuel
      real fuel(3)           ! temp to store fuel for cogen (grid, own-use, tot)
      real elecfuel(3)       ! temp to store fuel for elec portion of cogen
      real incrheatrate      ! amount of input heat allocated to elec portion of cogen
      real avebeff           ! average boiler efficiency across fossil fuels
      real TotFuel,NormSum,NewShr,OldShr,Shift,SumShr,CurSum ,Factor
      integer ntries,maxtries
      real bsshrFossil(11)   ! recomputation of bsshr, boiler fuel shares
      real resetsum,estimated,implied
      integer reset(11) ,repeat, ifuel_last_fossil
      logical assigned_once(6) ! used when mapping the 3 cogen fuel indexing to the indexing with ifsloc

      INTEGER IP,IT,IFJ,K,L,M,N,ifx

      integer IFuel,JFuel,bsize     ! index for fuel and size loops

      real check_cogboilfuel,check_fuelsys,check3,check4,check5,check6,check7,check8 ! debugging sums

      GENFUEL=0.  ! sum of cogen fuel for this industry and region ; stored in buffers; for indy rep writer
      RPTCAP=0.
      RPTGEN=0.
	  bsshrFossil(:) = 0.
	  reset(:) = 0.

      YR = IYR - 1989

! pick range of census divisions that are in the current census region
      IF(INDREG.EQ.1) THEN
        L = 1
        M = 2
      ELSE IF(INDREG.EQ.2) THEN
        L = 3
        M = 4
      ELSE IF(INDREG.EQ.3) THEN
        L = 5
        M = 7
      ELSE IF(INDREG.EQ.4) THEN
        L = 8
        M = 9
      ENDIF

!** initialize these 2 variables outside the i=l,m loop to get the region total **
      fuelsys(1:numflchp)=0.
      fuelelec(1:numflchp)=0.
      fuelcogsteam(1:numflchp)=0.
!
!  Calculate fuel consumption from cogeneration:
!          GENFUEL        used in the report writer and stored by region/year in the buffers
!          RTPGEN, RPTCAP used in the report writer and stored by region/year in the buffers
! since we are compiling sums across industries here, we have to apply
! grid/own-use shares at the industry level
      do I=L,M ! census divisions in current indreg
        do ifuel=1,numflchp
          jfuel=min(4,ifuel) ! 1:col, 2:oil, 3:gas, 4:other/renew

          fuelcogsteam(ifuel)=fuelcogsteam(ifuel)+cogthr(I,YR,INDDIR,IFUEL)/.8 ! CHP beff 80%

          elecfuel(3)=cogelf(I,YR,INDDIR,IFUEL)
          elecfuel(1)=cogelf(I,YR,INDDIR,IFUEL)*    coggrd(I,YR,INDDIR,IFUEL)
          elecfuel(2)=cogelf(I,YR,INDDIR,IFUEL)*(1.-coggrd(I,YR,INDDIR,IFUEL))

          fuel(3)=cogelf(I,YR,INDDIR,IFUEL)+cogthr(I,YR,INDDIR,IFUEL)/.8
          fuel(1)=fuel(3)*    coggrd(I,YR,INDDIR,IFUEL)
          fuel(2)=fuel(3)*(1.-coggrd(I,YR,INDDIR,IFUEL))

          fuelelec(ifuel)=fuelelec(ifuel) + elecfuel(3)
          fuelsys(ifuel)= fuelsys(ifuel) + fuel(3)      ! numflchp fuels

          genfuel(Jfuel)= genfuel(Jfuel) + fuel(3)
          RPTCAP(Jfuel)= RPTCAP(Jfuel) + cogcap(I,YR,INDDIR,IFUEL)
          RPTGEN(Jfuel)= RPTGEN(Jfuel) + coggen(I,YR,INDDIR,IFUEL)

        enddo ! ifuel

      enddo ! census divisions in current indreg

!  The steam generated from cogen won't
!  need to be generated by non-cogeneration boilers

      cogsteam=sum(fuelcogsteam(1:numflchp))*.8  ! CHP beff 80%

!  Subtract biomass used in cogen boilers.  This fuel
!  has already been accounted for as byproduct fuel and should reduce
!  the need for fossil-fuels in non-cogen boilers.
!
      availbiomass=(ByPBSCR(2)+ ByPBSCR(3))- fuelsys(7) ! subtract cogen wood from wood byproducts
      availbiomass=max(0.,availbiomass)

      biosteam=availbiomass*beff(10)  ! wood boiler efficiency

!  Determine steam that must be produced from non-cogen boilers.
!  It's possible that Cogen steam (cogsteam) will be greater than
!  internal estimate of steam demand (stemcur) because cogen steam
!  is derived initially from exogenous Form 860b cogeneration estimates.

      noncogsteam = max(0.,stemcur-cogsteam)
      noncogfossteam = max(0.,noncogsteam-biosteam)     
      if(prtdbgi.eq.3)write(6,'(a,i4,i3,a,i1,4f10.2)') 'steam ',iyr,inddir,'r', &
       indreg,stemcur,cogsteam,biosteam,noncogfossteam

! for printing debug info on calibrating nonCHP boiler fuel use, save steam info
! NSK ibyr2 update 7/2020
IF ((inddir .eq. 8) .or. (inddir .eq. 10) .or. (inddir .eq. 11) .or. (inddir .eq. 12) .or. (inddir .eq. 13)) then   ! Process-flow industries
    if(yr.eq.(ibyr2-baseyr+1)) then

        STEMCURIBYR(inddir,indreg)=stemcur
        COGSTEAMIBYR(inddir,indreg)=cogsteam
        BIOSTEAMIBYR(inddir,indreg)=biosteam
        noncogfosstmIBYR(inddir,indreg)=noncogfossteam

! Calculate calibration factors such that the CHP and nonCHP fuel use will match MECS.
! this is in part due to regional discrepancies in steam-to-fuel ratios and/or
! bad steam estimates from 860b or the mecs-based estimate.
        CALIBIBYR_BIO(inddir,indreg)=1.
        CALIBIBYR_FOS(inddir,indreg)=1.
        if(BOILIBYR(inddir,indreg,4).gt.0.) then
          estimated=biosteam/beff(4)
          implied=BOILIBYR(inddir,indreg,4)
          if(estimated.gt.0.0) CALIBIBYR_BIO(inddir,indreg)=implied/estimated
        endif
! Correct for regional situation where CHP fuel exceeds MECS, yet steam demand
! for nonCHP boilers still must be met.  Set a very low calibration factor
! such that MECS fuel use is not exceeded by more than .1 trill btu.
        if(sum(BOILIBYR(inddir,indreg,1:3)).eq. 0.0 .and. noncogfossteam.gt.0.0) then
           BOILIBYR(inddir,indreg,1:3)=.0333
        endif
        if(sum(BOILIBYR(inddir,indreg,1:3)).gt.0.) then
          estimated=noncogfossteam/.8
          implied=sum(BOILIBYR(inddir,indreg,1:3))
          if(estimated.gt.0.0) CALIBIBYR_FOS(inddir,indreg)=implied/estimated
        endif
    endif

ELSE    ! End-use industries
    if(yr.eq.(ibyr2-baseyr+1)) then

        STEMCURIBYR(inddir,indreg)=stemcur
        COGSTEAMIBYR(inddir,indreg)=cogsteam
        BIOSTEAMIBYR(inddir,indreg)=biosteam
        noncogfosstmIBYR(inddir,indreg)=noncogfossteam

! Calculate calibration factors such that the CHP and nonCHP fuel use will match MECS.
! this is in part due to regional discrepancies in steam-to-fuel ratios and/or
! bad steam estimates from 860b or the mecs-based estimate.
        CALIBIBYR_BIO(inddir,indreg)=1.
        CALIBIBYR_FOS(inddir,indreg)=1.
        if(BOILIBYR(inddir,indreg,4).gt.0.) then
          estimated=biosteam/beff(4)
          implied=BOILIBYR(inddir,indreg,4)
          if(estimated.gt.0.0) CALIBIBYR_BIO(inddir,indreg)=implied/estimated
        endif
! Correct for regional situation where CHP fuel exceeds MECS, yet steam demand
! for nonCHP boilers still must be met.  Set a very low calibration factor
! such that MECS fuel use is not exceeded by more than .1 trill btu.
        if(sum(BOILIBYR(inddir,indreg,1:3)).eq. 0.0 .and. noncogfossteam.gt.0.0) then
           BOILIBYR(inddir,indreg,1:3)=.0333
        endif
        if(sum(BOILIBYR(inddir,indreg,1:3)).gt.0.) then
          estimated=noncogfossteam/.8
          implied=sum(BOILIBYR(inddir,indreg,1:3))
          if(estimated.gt.0.0) CALIBIBYR_FOS(inddir,indreg)=implied/estimated
        endif
    endif
END IF

! assign cogen fossil fuel to IND fuel locations and share out oil fuel use to oil products
! based on MECS

      CogBoilFuel(:)=0.
      ifuel_last_fossil=0 ! highest fuel index matching a fossil fuel, assuming indices in ifsloc(1:ifsmax) are in ascending order
      Do IFUEL=1,IFSMAX
        I=IFSLOC(IFUEL)
        jfuel=0
        if(i.eq.7) then
          jfuel=1 ! coal
          CogBoilFuel(ifuel)=Fuelsys(jfuel)
          ifuel_last_fossil=max(ifuel,ifuel_last_fossil)
        elseif(i.ge.10.and.i.le.22) then
          jfuel=2  ! oil
          CogBoilFuel(ifuel)=Fuelsys(jfuel)*BSFUELSHR(INDDIR,INDREG,IFUEL) ! this requires that bsfuelshr be based on BSCibyr2, not BOILibyr2
          ifuel_last_fossil=max(ifuel,ifuel_last_fossil)
! the rest of these are to transfer non-biomass renewables (msw& hydro are non zero) to
! the ensqty array to be reflected in qtyrenw
        elseif(i.eq.4) then
          jfuel=3  ! ngas
          CogBoilFuel(ifuel)=Fuelsys(jfuel)
          ifuel_last_fossil=max(ifuel,ifuel_last_fossil)
        elseif(i.eq.41) then
          jfuel=4
          CogBoilFuel(ifuel)=Fuelsys(jfuel)
        elseif(i.eq.44) then
          jfuel=5
          CogBoilFuel(ifuel)=Fuelsys(jfuel)
        elseif(i.eq.48) then
          jfuel=6
          CogBoilFuel(ifuel)=Fuelsys(jfuel)
        elseif(i.eq.46) then
          jfuel=8
          CogBoilFuel(ifuel)=Fuelsys(jfuel)
        elseif(i.eq.1) then
          jfuel=9  ! electricity
          CogBoilFuel(ifuel)= 0. 
        !  ifuel_last_fossil=max(ifuel,ifuel_last_fossil)
        endif
        if(jfuel.eq.0) then
          Write(6,'(a,i2,a,i2,a,i2)') 'unassigned cogboilfuel index for i, where i=ifsloc(ifuel):',i, &
          ' in industry # ',inddir,' Region ',indreg
        endif
      enddo



! Assign nonCHP fossil fuel (noncogfosfuel) to IND fuel locations and share out based on update fuel shares

! ifuel = 1=NG, 2=Coal, 3=Resid, 4=Distl, 5=LPG H&P, 6=Pet Coke, 7=Other, 8=Hydro, 9=Biomass 10=electricity
! Not all fuels are used for all industries
      FuelFosSteam(:)=0.
      sumshr=sum(bsshr(:))
      DO IFUEL=1,10
        DO bsize=1,2            ! 1=10 MMBtu/yr or less, 2=greater than 10 MMBtu/yr
           NonCogFosFuel=noncogfossteam*BSSHR(ifuel)  ! BSSHR from CALBSC
           FuelFosSteam(ifuel)=(NonCogFosFuel/beff(ifuel))*CALIBIBYR_FOS(inddir,indreg)     
           if (IFUEL.eq.6) then
		     FosFuelSteamSize(inddir,ifuel,bsize,indreg)= FuelFosSteam(ifuel)*sizeshr(inddir,5,bsize)
		   else
		     FosFuelSteamSize(inddir,ifuel,bsize,indreg)= FuelFosSteam(ifuel)*sizeshr(inddir,ifuel,bsize)
		   endif											 
		      FOSFUELSTEAMSIZE(inddir,ifuel,bsize,5)=FOSFUELSTEAMSIZE(inddir,ifuel,bsize,5)+&
                                                         FOSFUELSTEAMSIZE(inddir,ifuel,bsize,indreg)
        ENDDO
      ENDDO

      check_cogboilfuel=sum(cogboilfuel(1:ifuel_last_fossil))  ! fossil fuels
      check_fuelsys=sum(fuelsys(1:3))                          ! fossil fuel for )
      check3=check_cogboilfuel-check_fuelsys
      if(abs(check3).gt. 0.001.and.prtdbgi.gt.1) then
        write(6,'(a,2i3,3f10.3)')' Cogboilfuel and fuelsys fossil don''t agree, in Inddir,indreg,cogboilfuel,fuelsys,check3:', &
        inddir,indreg,check_cogboilfuel,check_fuelsys,check3
      endif


      do ifuel=1,ifsmax
        ifx=ifsloc(ifuel)
		ensqty(ifuel)=FuelFosSteam(ifuel)+CogBoilFuel(ifuel)      
      enddo

      check5=sum(ensqty)
      check4=sum(fuelfossteam)


      if(yr.eq.(maxcogyr)) then
! for cogen technical potential, determine amount of steam not already met by cogen and not
! met already by biofueled steam
         cogsteamhist(inddir,indreg)=max(0.,stemcur-noncogfossteam) ! = cogsteam+biosteam
      endif
      RETURN
      END SUBROUTINE CALSTOT
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!  CONSUMPTION FOR THE INDUSTRY COMPONENTS ARE CONSOLIDATED INTO
!  ONE TOTAL, AND INDUSTRIES ARE ADDED INTO AN OVERALL INDUSTRIAL
!  TOTAL. ALSO CALCULATE TOTALS FOR METAL BASED DURABLES AND
!  OTHER MANUFACTURING
!****
      SUBROUTINE INDTOTAL
   use i_
      IMPLICIT NONE

      INTEGER IFUEL,IFF

      REAL sv_val
      REAL ELECTEMP
      REAL SUM
      REAL OwnAdj ! adjust own use and grid sales if needed


      IF(ISUBTR.EQ.1.AND.IOPEN.EQ.1.AND.LSTITER.EQ.1) &
        WRITE(IUNIT1,991)


!****
!  INITIALIZE THE QTY ARRAYS.
!****


          DO IFUEL=1,23
            QTYMAIN(IFUEL,INDREG)=0.0
          ENDDO
          DO IFUEL=1,7
            QTYINTR(IFUEL,INDREG)=0.0
          ENDDO
          DO IFUEL=1,9
            QTYRENW(IFUEL,INDREG)=0.0
          ENDDO
          if (indnum.eq.1) then
          do ifUEL=1,3
             xelin(ifUEL,indreg)=0.0
             xelinshr(ifUEL,indreg)=0.0
          enddo
          endif

!****
!  THE PA QUANTITIES ARE PUT IN THE TOTAL ARRAYS.
!****

      DO IFUEL=1,22
        sv_val = QTYMAIN(IFUEL,INDREG)

        QTYMAIN(IFUEL,INDREG)=ENPMQTY(IFUEL)
        !IF (IFUEL.eq.
		
	!	if ((curitr == 1).and.((inddir == 8).or.(inddir == 12)).and.(IFUEL == 1)) write (! ,'(A,3I6,2F12.0)')  & 
	!      "ELECTRICITY industry,region,year, qtymain ENPMQTY", inddir,indreg,curcalyr, QTYMAIN(IFUEL,INDREG), ENPMQTY(iFUEL) 

        IF (ISNAN(ENPMQTY(IFUEL))) THEN
           WRITE(6,2331) CURIRUN, CURIYR+1989, CURITR, INDREG, IFUEL, sv_val, ENPMQTY(IFUEL)
 2331      FORMAT(1X,"ENPMQTY_IS_NAN",5(":",I4),2(":",F21.6))
           QTYMAIN(IFUEL,INDREG) = sv_val
        END IF

      ENDDO
      DO IFUEL=1,6
        QTYINTR(IFUEL,INDREG)=ENPIQTY(IFUEL)
      ENDDO
      DO IFUEL=1,8
        QTYRENW(IFUEL,INDREG)=ENPRQTY(IFUEL)
      ENDDO


!****
!  ADD building energy by fuel
!****
      sv_val = QTYMAIN(1,INDREG)

      QTYMAIN(1,INDREG)=QTYMAIN(1,INDREG)+ENBQTY(5,1)  ! electricity

      IF (ISNAN(ENBQTY(5,1))) THEN
         WRITE(6,2332) CURIRUN, CURIYR+1989, CURITR, INDREG, 1, sv_val, ENBQTY(5,1)
 2332    FORMAT(1X,"ENBQTY_5_1_IS_NAN",5(":",I4),2(":",F21.6))
         QTYMAIN(1,INDREG) = sv_val
      END IF

      sv_val = QTYMAIN(3,INDREG)

      QTYMAIN(3,INDREG)=QTYMAIN(3,INDREG)+ENBQTY(5,2)  ! nat.gas

      IF (ISNAN(ENBQTY(5,2))) THEN
         WRITE(6,2333) CURIRUN, CURIYR+1989, CURITR, INDREG, 2, sv_val, ENBQTY(5,2)
 2333    FORMAT(1X,"ENBQTY_5_2_IS_NAN",5(":",I4),2(":",F21.6))
         QTYMAIN(3,INDREG) = sv_val
      END IF

      QTYINTR(1,INDREG)=QTYINTR(1,INDREG)+ENBQTY(5,3)  ! steam

      sv_val = QTYMAIN(11,INDREG)

      QTYMAIN(11,INDREG)=QTYMAIN(11,INDREG)+ENBQTY(5,4)  ! distillate

      IF (ISNAN(ENBQTY(5,4))) THEN
         WRITE(6,2334) CURIRUN, CURIYR+1989, CURITR, INDREG, 11, sv_val, ENBQTY(5,4)
 2334    FORMAT(1X,"ENBQTY_5_4_IS_NAN",5(":",I4),2(":",F21.6))
         QTYMAIN(11,INDREG) = sv_val
      END IF

      sv_val = QTYMAIN(12,INDREG)

      QTYMAIN(12,INDREG)=QTYMAIN(12,INDREG)+ENBQTY(5,5)  ! lpg

      IF (ISNAN(ENBQTY(5,5))) THEN
         WRITE(6,2335) CURIRUN, CURIYR+1989, CURITR, INDREG, 12, sv_val, ENBQTY(5,5)
 2335    FORMAT(1X,"ENBQTY_5_5_IS_NAN",5(":",I4),2(":",F21.6))
         QTYMAIN(12,INDREG) = sv_val
      END IF

!****
!  BSC ENERGY SOURCES HAVE TO BE TRANSLATED.  run for steel and paper.  
!****
 !    if ((inddir .ne. 8).and.(inddir .ne. 12)) then

		  DO 80 IFUEL=1,IFSMAX
			IF(IFSLOC(IFUEL).LT.30) THEN
			  IFF=IFSLOC(IFUEL)

			  sv_val = QTYMAIN(IFF,INDREG)

			  QTYMAIN(IFF,INDREG)=QTYMAIN(IFF,INDREG)+ENSQTY(IFUEL)


			  IF (ISNAN(ENSQTY(IFUEL))) THEN
				 WRITE(6,2336) CURIRUN, CURIYR+1989, CURITR, INDREG, IFF, IFUEL, sv_val, ENSQTY(IFUEL)
	 2336        FORMAT(1X,"ENSQTY_IS_NAN",6(":",I4),2(":",F21.6))
				 QTYMAIN(IFF,INDREG) = sv_val
			  END IF

			ELSE
			  IF(IFSLOC(IFUEL).LT.40) THEN
				IFF=IFSLOC(IFUEL)-30
				QTYINTR(IFF,INDREG)=QTYINTR(IFF,INDREG)+ENSQTY(IFUEL)
			  ELSE
				IFF=IFSLOC(IFUEL)-40
				QTYRENW(IFF,INDREG)=QTYRENW(IFF,INDREG)+ENSQTY(IFUEL)
			  ENDIF
			ENDIF
	   80 CONTINUE
!	endif

!****
!  ADD BYPRODUCT FUEL USED.  KPE:  not run for steel or paper 
!****
     
 !     if ((inddir .ne. 8).and.(inddir .ne. 12)) then
		  DO IFUEL=1,22

			sv_val = QTYMAIN(IFUEL,INDREG)

			QTYMAIN(IFUEL,INDREG)=QTYMAIN(IFUEL,INDREG)+BYPBSCM(IFUEL)

			IF (ISNAN(BYPBSCM(IFUEL))) THEN
			   WRITE(6,2337) CURIRUN, CURIYR+1989, CURITR, INDREG, IFUEL, sv_val, BYPBSCM(IFUEL)
	 2337      FORMAT(1X,"BYPBSCM_IS_NAN",5(":",I4),2(":",F21.6))
			   QTYMAIN(IFUEL,INDREG) = sv_val
			END IF

		  ENDDO
		  DO IFUEL=1,6
			QTYINTR(IFUEL,INDREG)=QTYINTR(IFUEL,INDREG)+BYPBSCI(IFUEL)
		  ENDDO
		  DO IFUEL=1,8
			QTYRENW(IFUEL,INDREG)=QTYRENW(IFUEL,INDREG)+BYPBSCR(IFUEL)
		  ENDDO
!	  endif
!****
!  QTYMAIN(1,IR) IS DEFINED AS PURCHASED ELECTRICITY ONLY.
!****
! GET TOTAL OWN USE GENERATION
! elown is in gwh
! doesn't apply to steel and paper?
! use separate equation for steel and paper --now there's an else statement! 
      
      
		  ELECTEMP=QTYMAIN(1,INDREG) - ELOWN*(3412./10.**6)  ! check to see if this applies to steel and paper
	  if ((inddir.ne.8).and.(inddir.ne.12)) then
     	IF(ELECTEMP.GE.0.0) THEN
			QTYMAIN(1,INDREG)=ELECTEMP
		ELSE
			ELOWN  = ELOWN +  ELECTEMP * (10.**6/3412.) ! if we are here, electemp is negative
			ELSALE = ELSALE - ELECTEMP * (10.**6/3412.) ! to keep things balanced, increase sales to grid
			QTYMAIN(1,INDREG)=0.0                       ! reduce ownuse by same amount
		   if(prtdbgi.gt.1) then
			 write(6,'(A,3I4)') ' self generation exceeds electricity use, curiyr,indreg,inddir=', &
			  curiyr,indreg,inddir
		   endif
      	ENDIF
	  else  ! we use the values calculated in ppis_bsc
		ELOWN  = elownx(inddir,indreg)
		ELSALE = elsalex(inddir,indreg)
      endif

!****
!  DO TOTALS.
!****

      DO IFUEL=1,22
        QTYMAIN(23,INDREG)=QTYMAIN(23,INDREG)+QTYMAIN(IFUEL,INDREG)
      ENDDO
      DO IFUEL=1,6
        QTYINTR(7,INDREG)=QTYINTR(7,INDREG)+QTYINTR(IFUEL,INDREG)
      ENDDO
      DO IFUEL=1,8
        QTYRENW(9,INDREG)=QTYRENW(9,INDREG)+QTYRENW(IFUEL,INDREG)
      ENDDO

!  also calculate electricity shares for the three
!  groups: Primary=food,paper,chemicals,steel,aluminum;
!          Shift  =metal based durables;
!          Miscellaneous =all the rest.
      if (inddir.eq.7.or.inddir.eq.8.or.inddir.eq.9.or. &
          inddir.eq.12.or.inddir.eq.13) then
          xelin(1,indreg)=xelin(1,indreg) + &
                           qtymain(1,indreg)
        else if (inddir.ge.14.and.inddir.le.18) then
          xelin(2,indreg)=xelin(2,indreg) + &
                           qtymain(1,indreg)
        else
          xelin(3,indreg)=xelin(3,indreg) + &
                           qtymain(1,indreg)
      endif
      xelinshr(1,indreg)=xelin(1,indreg)/ &
       (xelin(1,indreg)+ &
        xelin(2,indreg)+ &
        xelin(3,indreg))

       xelinshr(2,indreg)=xelin(2,indreg)/ &
       (xelin(1,indreg)+ &
        xelin(2,indreg)+ &
        xelin(3,indreg))

      xelinshr(3,indreg)=xelin(3,indreg)/ &
       (xelin(1,indreg)+ &
        xelin(2,indreg)+ &
        xelin(3,indreg))
      
!****
!  FORMAT STATEMENTS.
!****

  991 FORMAT(3X,'INDTOTAL')

      RETURN
      END  SUBROUTINE INDTOTAL
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!  CONSUMPTION FOR THE INDUSTRY COMPONENTS ARE CONSOLIDATED INTO
!  ONE TOTAL, AND INDUSTRIES ARE ADDED INTO AN OVERALL INDUSTRIAL
!  TOTAL.
!****
      SUBROUTINE NATTOTAL
   use i_
      IMPLICIT NONE

      INTEGER IFUEL,IFF
      REAL LUBEIDX          ! Production index of food, steel, elec mach, and inorganic; where 2002 = 100

      IF(ISUBTR.EQ.1.AND.IOPEN.EQ.1.AND.LSTITER.EQ.1) &
        WRITE(IUNIT1,991)

!***
!  INITIALIZE TO 0.0 THE NATIONAL VARIABLES.
!****

      DO IFUEL=1,23
        QTYMAIN(IFUEL,5)=0.0
      ENDDO

      DO IFUEL=1,7
        QTYINTR(IFUEL,5)=0.0
      ENDDO

      DO IFUEL=1,9
        QTYRENW(IFUEL,5)=0.0
      ENDDO

!****
!  CALCULATE NATIONAL TOTALS.
!****

      DO IFUEL=1,22
        DO IR=1,4
          QTYMAIN(IFUEL,5)=QTYMAIN(IFUEL,5)+QTYMAIN(IFUEL,IR)
        ENDDO
      ENDDO

      DO IFUEL=1,6
        DO IR=1,4
          QTYINTR(IFUEL,5)=QTYINTR(IFUEL,5)+QTYINTR(IFUEL,IR)
        ENDDO
      ENDDO

      DO IFUEL=1,8
        DO IR=1,4
          QTYRENW(IFUEL,5)=QTYRENW(IFUEL,5)+QTYRENW(IFUEL,IR)
        ENDDO
      ENDDO


!****
!  SUM UP TOTALS OVER FUELS.
!****

      DO 100 IR=1,5
        QTYMAIN(23,IR)=0.0
        DO 100 IFUEL=1,22
          QTYMAIN(23,IR)=QTYMAIN(23,IR)+QTYMAIN(IFUEL,IR)
  100 CONTINUE

      DO 102 IR=1,5
        QTYINTR(7,IR)=QTYINTR(1,IR)+QTYINTR(2,IR)+QTYINTR(3,IR) &
              +QTYINTR(4,IR)+QTYINTR(5,IR)+QTYINTR(6,IR)
  102 CONTINUE

      DO 105 IR=1,5
        QTYRENW(9,IR)=0.0
        DO 105 IFUEL=1,8
          QTYRENW(9,IR)=QTYRENW(9,IR)+QTYRENW(IFUEL,IR)
  105 CONTINUE

!****
!  THE ARRAYS ARE ADDED UP OVER THE VARIOUS INDUSTRIES.
!****
      DO 150 IR=1,5
        DO IFUEL=1,23
          IF(INDNUM.EQ.1) THEN
            TQMAIN(IFUEL,IR)=0.0
          ENDIF
          TQMAIN(IFUEL,IR)=TQMAIN(IFUEL,IR)+QTYMAIN(IFUEL,IR)
      ! THIS SET OF EQUATIONS UPDATED WITH MC_REVIND_ADJ  -- SUSAN
          IF (IFUEL.EQ.18 .AND. IR.EQ.5) THEN                              ! Overwrites value for IFUEL = 18 (Lubes & Waxes) at national level
            LUBEIDX = 100.* ( MC_REVIND(11, 1,curiyr)*MC_REVIND_ADJ( 1) &
                            + MC_REVIND(11,15,curiyr)*MC_REVIND_ADJ(15) &
                            + MC_REVIND(11,33,curiyr)*MC_REVIND_ADJ(33) &
                            + MC_REVIND(11,40,curiyr)*MC_REVIND_ADJ(40) ) &
                          / ( MC_REVIND(11, 1,13)*MC_REVIND_ADJ( 1) &
                            + MC_REVIND(11,15,13)*MC_REVIND_ADJ(15) &
                            + MC_REVIND(11,33,13)*MC_REVIND_ADJ(33) &
                            + MC_REVIND(11,40,13)*MC_REVIND_ADJ(40) )             ! Production index for lube exposed industries, where 2002=100
            TQMAIN(IFUEL,IR) = (-5.5183 + 4.1380*LOG(LUBEIDX))**2.         ! National regression estimate for Lubes & Waxes
            tqmain(ifuel,ir) = tqmain(ifuel,ir) * 0.70                     ! scale lube & wax regression based on 2011 - 2012 actual industrial lube use
          ENDIF
        ENDDO
        DO IFUEL=1,7
          IF(INDNUM.EQ.1) THEN
            TQINTR(IFUEL,IR)=0.0
          ENDIF
          TQINTR(IFUEL,IR)=TQINTR(IFUEL,IR)+QTYINTR(IFUEL,IR)
        ENDDO
        DO IFUEL=1,9
          IF(INDNUM.EQ.1) THEN
            TQRENW(IFUEL,IR)=0.0
          ENDIF
          TQRENW(IFUEL,IR)=TQRENW(IFUEL,IR)+QTYRENW(IFUEL,IR)
        ENDDO
  150 CONTINUE

! regionalize lubes from national using SEDS values from last SEDS year
! NSK 2/11/2020

      tqmain(18,1) = tqmain(18,5) * (QSLUIN(1,MSEDYR) + QSLUIN(2,MSEDYR))/QSLUIN(11,MSEDYR)
      tqmain(18,2) = tqmain(18,5) * (QSLUIN(3,MSEDYR) + QSLUIN(4,MSEDYR))/QSLUIN(11,MSEDYR)
      tqmain(18,3) = tqmain(18,5) * (QSLUIN(5,MSEDYR) + QSLUIN(6,MSEDYR) + QSLUIN(7,MSEDYR))/QSLUIN(11,MSEDYR)
      tqmain(18,4) = tqmain(18,5) * (QSLUIN(8,MSEDYR) + QSLUIN(9,MSEDYR))/QSLUIN(11,MSEDYR)

      
!****
!  FORMAT STATEMENTS.
!****

  991 FORMAT(3X,'NATTOTAL')

      RETURN
      END SUBROUTINE NATTOTAL
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!  TOTAL ENERGY CONSUMPTION FOR THE INDUSTRY IS WRITTEN TO THE
!  DEBUG FILE.
!****
      SUBROUTINE WRQTY
   use i_
      IMPLICIT NONE



      IF(ISUBTR.EQ.1.AND.IOPEN.EQ.1.AND.LSTITER.EQ.1) &
        WRITE(IUNIT1,991)

!****
!  WRITE OVERALL CONSUMPTION TO DEBUG FILE.
!****

      IF(IOPEN.EQ.1.AND.LSTITER.EQ.1.and.IWDBG.eq.1) &
       WRITE(IUNIT1,900) IYR,QTYMAIN(23,INDREG), &
                         QTYINTR(7,INDREG),QTYRENW(9,INDREG)

      IF(INDREG.EQ.4) THEN
        IF(IWDBG.EQ.1) THEN
          IF(IOPEN.EQ.1.AND.LSTITER.EQ.1)WRITE(IUNIT1,875)
          DO IF=1,23
            IF(IOPEN.EQ.1.AND.LSTITER.EQ.1) &
                 WRITE(IUNIT1,877) IF,(QTYMAIN(IF,IR),IR=1,5)
          ENDDO
          DO IF=1,7
            IF(IOPEN.EQ.1.AND.LSTITER.EQ.1) &
                 WRITE(IUNIT1,877) IF,(QTYINTR(IF,IR),IR=1,5)
          ENDDO
          DO IF=1,9
            IF(IOPEN.EQ.1.AND.LSTITER.EQ.1) &
                 WRITE(IUNIT1,877) IF,(QTYRENW(IF,IR),IR=1,5)
          ENDDO
        ENDIF
      ENDIF

!****
!  FORMAT STATEMENTS.
!****

  875 FORMAT(1X,'OVERALL CONSUMPTION BY FUEL')
  877 FORMAT(5X,'FUEL ',I4,5F10.1)
  900 FORMAT(' RESULTS FOR ',I4,':  MAIN=',F8.1,'  INTR=',F8.1, &
        '  RENW=',F8.1)
  991 FORMAT(3X,'WRQTY')

      RETURN
      END SUBROUTINE WRQTY
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
! THIS SUBROUTINE CALCULATES THE NECESSARY COGENERATION
!  VARIABLES TO BE PASSED TO THE NEMS SYSTEM.
!****
      SUBROUTINE INDCGN
   use i_
      IMPLICIT NONE
! real totgen
      integer k,it,ifuel,iy

! sum capacity and generation across the numind industries for the current year

      IY = curiyr
      CAPGW=0.
      GENGWH=0.
      DIVFUEL=0.
      DO I = 1,9 ! divisions
        do j=1,numflchp ! coal,oil,nat gas, hydro, geoth, msw, biomass, solar, other gas, other.
          DO K = 1,numind ! industry

            capgw(i,j,1)=capgw(i,j,1)+cogcap(i,iy,k,j)*coggrd(i,iy,k,j)
            capgw(i,j,2)=capgw(i,j,2)+cogcap(i,iy,k,j)*(1.-coggrd(i,iy,k,j))

            gengwh(i,j,1)=gengwh(i,j,1)+coggen(i,iy,k,j)*coggrd(i,iy,k,j)
            gengwh(i,j,2)=gengwh(i,j,2)+coggen(i,iy,k,j)*(1.-coggrd(i,iy,k,j))

            divfuel(i,j,1)=divfuel(i,j,1) + cogelf(I,iy,k,j)*    coggrd(I,iy,k,j)
            divfuel(i,j,2)=divfuel(i,j,2) + cogelf(I,iy,k,j)*(1.-coggrd(I,iy,k,j))

          enddo ! end of the industry loop
        ENDDO ! fuel
       ENDDO  ! divisions

! do US (11) totals of the 9 census divisions
      do k=1,2
        do j=1,numflchp
           capgw(11,j,k)=sum(capgw(1:9,j,k))
           gengwh(11,j,k)=sum(gengwh(1:9,j,k))
           divfuel(11,j,k)=sum(divfuel(1:9,j,k))
        enddo
      enddo

!******
!  COGENERATION VARIABLES ARE PASSED TO NEMS.
!******

        DO ID=1,11  ! divisions
          DO IF=1,numflchp
            CGINDLCAP(ID,IY,IF)=0.0          !CAPACITY
            CGINDLQ(ID,IY,IF)=0.0            !FUEL CONS
            DO IT=1,2
              CGINDLGEN(ID,IY,IF,IT)=0.0            !GENERATION
            ENDDO
          ENDDO
        ENDDO
! Fill NEMS Global variables specified with 10 fuel classes--fuel detail now agrees with ind module
        DO ID=1,11
          DO IFuel=1,numflchp
            CGINDLCAP(ID,IY,IFuel)=CAPGW(ID,IFuel,1)+CAPGW(ID,IFuel,2)
            CGINDLQ(ID,IY,IFuel)=DIVFUEL(ID,IFuel,1)+DIVFUEL(ID,IFuel,2)
            DO IT=1,2    ! grid=1, own use=2 sales
              CGINDLGEN(ID,IY,IFuel,IT)=GENGWH(ID,IFuel,IT)
            ENDDO
          enddo
        enddo


      RETURN
      END  SUBROUTINE INDCGN
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!  CONSUMPTION TABLES FOR INDIVIDUAL INDUSTRIES
!  MANUFACTURING-H&P,NONMANUFACTURING-H&P,MISC FEEDSTOCK,
!  ELECTRICITY GENERATED,FOOD,PAPER,CHEMICAL,GLASS,CEMENT,
!  STEEL, AND ALUMINUM,METAL BASED DURABLES, OTHER MANUFACTURING
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

      SUBROUTINE CONTAB(ICR)
   use i_
      IMPLICIT NONE
      INTEGER ICR ! region index(1:4) or 5 for National

      INTEGER IY
      INTEGER DIVS(5,2)/1,3,5,8,11, &  ! Census Division start for each Region and US
                        2,4,7,9,11/    ! Census Division end   for each Region and US



      IY = IYR - 1989
!  Initialize if this is the first time through (INDNUM will be 1)
      IF (INDNUM.EQ.1) THEN
         qtybyind(:,:)=0.

         MANHP(1:18,icr,IY)       =0.0
         NONHP(1:18,icr,IY)       =0.0
         REFCON(1:18,icr,IY)      =0.0
         FOODCON(1:18,icr,IY)     =0.0
         PAPERCON(1:18,icr,IY)    =0.0
         CHEMCON(1:18,icr,IY)     =0.0
         GLASSCON(1:18,icr,IY)    =0.0
         STEELCON(1:18,icr,IY)    =0.0
         CEMENTCON(1:18,icr,IY)   =0.0
         ALUMCON(1:18,icr,IY)     =0.0
         AGCON(1:18,icr,IY)       =0.0
         MINECON(1:18,icr,IY)     =0.0
         CONSTCON(1:18,icr,IY)    =0.0
         FABMETALCON(1:18,icr,IY) =0.0
         MACHINECON(1:18,icr,IY)  =0.0
         COMPUTECON(1:18,icr,IY)  =0.0
         TRANEQUIPCON(1:18,icr,IY)=0.0
         ELECEQUIPON(1:18,icr,IY) =0.0
         WOODPRODCON(1:18,icr,IY) =0.0
         PLASTICCON(1:18,icr,IY)  =0.0
         BOMOTHCON(1:18,icr,IY)   =0.0



!   store consumption for refineries
!   REFCON used for Table 35 in Ftab.  reassigned in main.f after PMM runs

         REFCON(1,icr,iy)= SUM(QELRF(DIVS(icr,1):DIVS(icr,2),IY))+ &
		 SUM(QELeth(IY,DIVS(icr,1):DIVS(icr,2))) ! electricity
         REFCON(2,icr,iy)= SUM(QNGRF(DIVS(icr,1):DIVS(icr,2),IY))+ &
		 SUM(QNGeth(IY,DIVS(icr,1):DIVS(icr,2)))+SUM(QGTLRF(DIVS(icr,1):DIVS(icr,2),IY)) ! nat gas h&p
         REFCON(3,icr,iy)= SUM(QCLRF(DIVS(icr,1):DIVS(icr,2),IY))+ &
		 SUM(QCLeth(IY,DIVS(icr,1):DIVS(icr,2)))  ! steam coal
         REFCON(6,icr,iy)= SUM(QRLRF(DIVS(icr,1):DIVS(icr,2),IY))      ! residual
         REFCON(7,icr,iy)= SUM(QDSRF(DIVS(icr,1):DIVS(icr,2),IY))      ! distillate
         REFCON(8,icr,iy)= SUM(QLGRF(DIVS(icr,1):DIVS(icr,2),IY))      ! lpg h&p
         REFCON(10,icr,iy)=SUM(QSGRF(DIVS(icr,1):DIVS(icr,2),IY))      ! still gas
         REFCON(11,icr,iy)=SUM(QPCRF(DIVS(icr,1):DIVS(icr,2),IY)) + &  !        petroleum coke, Marketable
                          SUM(QCCRF(DIVS(icr,1):DIVS(icr,2),IY))      !    petroleum coke, cat coke
         REFCON(15,icr,iy)=SUM(QOTRF(DIVS(icr,1):DIVS(icr,2),IY))      ! other petroleum
         REFCON(18,icr,iy)=SUM(QBMRF(DIVS(icr,1):DIVS(icr,2),IY))      ! biomass

!******
!     Add refinery consumption to MANUFACTURING Heat and Power
!******
         DO IF=1,18
           MANHP(IF,icr,IY)=REFCON(IF,icr,IY)
         ENDDO
!******
!     Add oil and gas cogen to NONMANUFACTURING HEAT AND POWER
!******

         NONHP(2,icr,IY)=SUM(CGOGSQ(DIVS(icr,1):DIVS(icr,2),IY,3))   ! natural gas
         NONHP(3,icr,IY)=SUM(CGOGSQ(DIVS(icr,1):DIVS(icr,2),IY,1))   ! steam coal
         NONHP(6,icr,IY)=SUM(CGOGSQ(DIVS(icr,1):DIVS(icr,2),IY,2))   ! residual
      ENDIF

!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!     FILL TABLE FOR MANUFACTURING, NON MANUFACTURING AGGREGATIONS
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

      IF (INDDIR.GE.7.AND.INDDIR.LE.numind) THEN
        call indfillcon(MANHP(1,icr,IY),QTYMAIN(1,icr),QTYRENW(1,icr))
      ELSEIF(INDDIR.LT.7) THEN
        call indfillcon(NONHP(1,icr,IY),QTYMAIN(1,icr),QTYRENW(1,icr))
      ENDIF
!  Fill each of the other Industry consumption tables.
      SELECT CASE (INDDIR)      ! Added BENCHHIST to benchmark purchased electricity and steam coal values NSK 3/3/22
        Case (1:2)
          call indfillcon(AGCON(1,icr,IY),QTYMAIN(1,icr),QTYRENW(1,icr))
        Case (3:5)
          call indfillcon(MINECON(1,icr,IY),QTYMAIN(1,icr),QTYRENW(1,icr))
        Case (6)
          call indfillcon(CONSTCON(1,icr,IY),QTYMAIN(1,icr),QTYRENW(1,icr))
        Case (7)
          call indfillcon(FOODCON(1,icr,IY),QTYMAIN(1,icr),QTYRENW(1,icr))
          IF (icr.eq.5) call BENCHHIST(FOODCON(1,1,IY),icr)
        Case (8)
          call indfillcon(PAPERCON(1,icr,IY),QTYMAIN(1,icr),QTYRENW(1,icr))
          IF (icr.eq.5) call BENCHHIST(PAPERCON(1,1,IY),icr)
        Case (9)
          call indfillcon(CHEMCON(1,icr,IY),QTYMAIN(1,icr),QTYRENW(1,icr))
          IF (icr.eq.5) call BENCHHIST(CHEMCON(1,1,IY),icr)
        Case (10)
          call indfillcon(GLASSCON(1,icr,IY),QTYMAIN(1,icr),QTYRENW(1,icr))
          IF (icr.eq.5) call BENCHHIST(GLASSCON(1,1,IY),icr)
        Case (11)
          call indfillcon(CEMENTCON(1,icr,IY),QTYMAIN(1,icr),QTYRENW(1,icr))
          IF (icr.eq.5) call BENCHHIST(CEMENTCON(1,1,IY),icr)
        Case (12)
          call indfillcon(STEELCON(1,icr,IY),QTYMAIN(1,icr),QTYRENW(1,icr))
          IF (icr.eq.5) call BENCHHIST(STEELCON(1,1,IY),icr)
        Case (13)
          call indfillcon(ALUMCON(1,icr,IY),QTYMAIN(1,icr),QTYRENW(1,icr))
          IF (icr.eq.5) call BENCHHIST(ALUMCON(1,1,IY),icr)
        Case (14)
          call indfillcon(FABMETALCON(1,icr,IY) ,QTYMAIN(1,icr),QTYRENW(1,icr))
          IF (icr.eq.5) call BENCHHIST(FABMETALCON(1,1,IY),icr)
        Case (15)
          call indfillcon(MACHINECON(1,icr,IY)  ,QTYMAIN(1,icr),QTYRENW(1,icr))
          IF (icr.eq.5) call BENCHHIST(MACHINECON(1,1,IY),icr)
        Case (16)
          call indfillcon(COMPUTECON(1,icr,IY)  ,QTYMAIN(1,icr),QTYRENW(1,icr))
          IF (icr.eq.5) call BENCHHIST(COMPUTECON(1,1,IY),icr)
        Case (17)
          call indfillcon(TRANEQUIPCON(1,icr,IY),QTYMAIN(1,icr),QTYRENW(1,icr))
          IF (icr.eq.5) call BENCHHIST(TRANEQUIPCON(1,1,IY),icr)
        Case (18)
          call indfillcon(ELECEQUIPON(1,icr,IY) ,QTYMAIN(1,icr),QTYRENW(1,icr))
          IF (icr.eq.5) call BENCHHIST(ELECEQUIPON(1,1,IY),icr)
        Case (19)
          call indfillcon(WOODPRODCON(1,icr,IY) ,QTYMAIN(1,icr),QTYRENW(1,icr))
          IF (icr.eq.5) call BENCHHIST(WOODPRODCON(1,1,IY),icr)          
        Case (20)
          call indfillcon(PLASTICCON(1,icr,IY)  ,QTYMAIN(1,icr),QTYRENW(1,icr))
          IF (icr.eq.5) call BENCHHIST(PLASTICCON(1,1,IY),icr)             
        Case (21)
          call indfillcon(BOMOTHCON(1,icr,IY)   ,QTYMAIN(1,icr),QTYRENW(1,icr))
          IF (icr.eq.5) call BENCHHIST(BOMOTHCON(1,1,IY),icr)          
      end select


      IF(icr.EQ.5) call indfillcon(QtyByInd(1,INDDIR),QTYMAIN(1,icr),QTYRENW(1,icr))
      
      RETURN
      END  SUBROUTINE CONTAB

      SUBROUTINE INDFILLCON(CON,QTYMAIN1,QTYRENW1)
   use i_
      implicit none

      real con(18)
      real qtymain1(23)
      real qtyrenw1(9)

! Corresponding Indices in Con and QTYMAIN array
!
!             con   qtymain
! elec          1    1,2
! ngas          2    3,4,6
! steam coal    3    7
! met coal      4    8
! net coke imp  5    9
! resid         6   10
! dist          7   11
! lpg           8   12
! mogas         9   14
! still gas    10   15
! petrol coke  11   16
! asphalt      12   17
! petrol feed  13   18,19,21 ! lubes,petrochemfeedstock, oth pet feedstoc
! kero         14   20
! oth ind      15   22
! ng feed      16   5
! lpg feed     17   13
! renew        18

! icon returns the subscript index for CON for each subscript in qtymain
!
!                      1  2  3  4  5  6  7  8  9 10 11 12
!                     13 14 15 16 17 18 19 20 21 22
      integer icon(22)/1, 1, 2, 2,16, 2, 3, 4, 5, 6, 7, 8, &
                      17, 9,10,11,12,13,13,14,13,15/
      do i=1,22
        con(icon(i))=con(icon(i))+qtymain1(i)
		! if ((curitr == 1)) &  ! .and.((inddir == 8)).or.(inddir == 12)) &
		!   write(6,'(A,5I6,2F12.1)') "inddir, region, year, i, icon, con, qtymain", & ! don't uncomment this  unless you're really stuck
		 !       inddir, indreg, curcalyr, i, icon, con(icon(i)), qtymain1(i) 
      enddo
      do j=1,8
        con(18)=con(18)+qtyrenw1(j)
      enddo
      return
      end  SUBROUTINE INDFILLCON
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!
! Finalize industrial variables that combine refinery and cogeneration
! related data.
! Write year's worth of data to industrial output files indusa.csv, indreg.csv, indt.csv

      SUBROUTINE INDUSREPORT
   use i_
      IMPLICIT NONE

      integer ifuel,it,iy
      integer cgif(6)/1,2,3,7,10,6/
      iy=curiyr

! Call routines to write to the Industrial Model's Internal Report writers using unbenchmarked results
!
      call indsic('US')  ! creates indsic.csv  US summary for each industry
      call indsic('1 ')  ! creates indreg1.csv   Industry summaries by census region
      call indsic('2 ')  ! creates indreg2.csv   Industry summaries by census region
      call indsic('3 ')  ! creates indreg3.csv   Industry summaries by census region
      call indsic('4 ')  ! creates indreg4.csv   Industry summaries by census region
      call indgrp(0)     ! creates indt.csv     Summary of all Manufacturing and Nonmanufacturing industries (0).
      call indgrp(1)     ! creates indm.csv     Summary of all Manufacturing industries (1).
      call indgrp(2)     ! creates indn.csv     Summary of all NonManufacturing industries (2).


! Retally the individual reporting arrays to produce Table 44 results (to include latest PMM version of REFCON)
      MANHP(:,:,IY)= REFCON(:,:,IY) +     FOODCON(:,:,IY) +   PAPERCON(:,:,IY) +        CHEMCON(:,:,IY) + &
                   GLASSCON(:,:,IY) +    STEELCON(:,:,IY) +  CEMENTCON(:,:,IY) +        ALUMCON(:,:,IY) + &
                FABMETALCON(:,:,iy) +  MACHINECON(:,:,iy) + COMPUTECON(:,:,iy) +   TRANEQUIPCON(:,:,iy) + &
                ELECEQUIPON(:,:,iy) + WOODPRODCON(:,:,iy) + PLASTICCON(:,:,iy) +      BOMOTHCON(:,:,iy)

      NONHP(:,:,IY) = AGCON(:,:,IY) +     MINECON(:,:,IY) +   CONSTCON(:,:,IY)

      RETURN
      END  SUBROUTINE INDUSREPORT
! **************************************************************

      FUNCTION AveSPrc(IRi,JYi,IYi,istep)
! returns ratio of average energy price in year iy to price in base year jy
! for a given process-assembly step in a given census region, The
! price average is weighted based on the mix of fuels used in the step (prior year).

   use i_
      implicit none
      integer IRi ! number of census region from 1 to 4
      integer JYi ! base year index, 1990=1
      integer IYi ! future year index
      integer istep ! p/a step
      real AveSPrc, AveJY,AveIY, qty

      INTEGER IFX,IFUEL
      real SumRevIY
      real SumRevJY
      real SumQty

      AveSPrc=1.  ! default value
      if(IYi.le.JYi) then
        return
      endif

      SumRevIY=0.
      SumRevJY=0.
      SumQty=0.

! Loop over fuels used for the step and aggregate
! "revenue" and quantity.

      do ifuel=1,ifmax(istep)

        Qty = enpintlag(1,ifuel,istep)*prodlag(1,istep) + &
              enpintlag(2,ifuel,istep)*prodlag(2,istep) + &
              enpintlag(3,ifuel,istep)*prodlag(3,istep)

        SumQty = SumQty + Qty

        ifx=ifloc(ifuel,istep)


        SumRevIY=SumRevIY+ qty*prcxyr(ifx,iri,iyi,3)
        SumRevJY=SumRevJY+ qty*prcxyr(ifx,iri,jyi,3)

      enddo
      if(SumQty .LE. 0.) then
        AveSPrc=1.
        return
      endif
      AveIY=SumRevIY/SumQty
      AveJY=SumRevJY/SumQty

      if(AveJY.eq.0.0) return
      AveSPrc= AveIY/AveJY

      return
      end FUNCTION AveSPrc
! **************************************************************
      FUNCTION AveFPrc(IRi,JYi,IYi,ifx)
         use i_

! returns ratio of a fuel price in year iy to price in base year jy
! for a given fuel (IFX) in a given census region,
      implicit none
      integer IRi ! number of census region from 1 to 4
      integer JYi ! base year index, 1990=1
      integer IYi ! future year index
      INTEGER IFX ! industrial fuel index

      real AveFPrc, PrcJY,PrcIY


      AveFprc=1.  ! default value
      if(IYi.le.JYi) then
        return
      endif


      PrcIY=prcxyr(ifx,iri,iyi,3)
      PrcJY=prcxyr(ifx,iri,jyi,3)


      if(PrcJY.eq.0.0) return
      AveFPrc= PrcIY/PrcJY

      return
      end FUNCTION AveFPrc

! =======================================================
      subroutine mecsbase
   use i_
      implicit none
! this routine reads in prodflow data file, containing
! data on production flow rates by process assembly
! steps.
!
      character*128 line,dumc*20, duma*20
      integer inpind,inpreg,inpstp,idown,is,nsteps,ivint,g,inpg,igs,ngrps
      integer iunit/0/
      save iunit

      if(iunit.eq.0) then
        fname='PRODFLOW'
        NEW=.FALSE.
        IUNIT=FILE_MGR('O',FNAME,NEW)
      endif
!
      if(iunit.le.0) return
!     if(curitr.ne.1) return
      inpind=0
      inpreg=0
      NumRptGrps=0
      NumRptGrpSteps(1:12)=0
      RptGrpSteps(1:12,1:maxstep)=0
      RptGrpNames(1:12)=' '
      RptGrpSName(1:12,1:maxstep)=' '


! read lines until the end of file is reached or all records
! for a given industry and region have been read in
      do while (inpreg.le.indreg.and. &
           inpind.le.inddir)

        read(iunit,'(a)',end=99) line
        if(line(1:1).ne.'*') then
! file has three sections for each industry: step definitions, retirement rates, and prodflow rates
! for each step.
          if(index(line,'Number of Steps').ne.0) then
! read step definitions
            read(line,*) inpind,inpreg,dumc,nsteps,ngrps

            if(inpind.eq.inddir.and.inpreg.eq.indreg) then
              ipastp=0
              ntmax=0
              prodflow=0.
              if(prtdbgi.gt.1) then
                write(6,'(a,i2,a,i1)') 'reading prodflow file, inddir=',inddir, &
                                                             ' indreg=',indreg
                write(6,*) ' number of steps, Rpt. Groups=',nsteps,ngrps
              endif
              MPASTP=nsteps
              NumRptGrps=ngrps
              do is=1,mpastp
10              read(iunit,'(a)') line
                if(line(1:1).eq.'*') goto 10
                read(line,*) inpind,inpreg,inpstp,duma,dumc, &
                  ntmax(inpstp), &
                  (IPASTP(inpstp,IDOWN),IDOWN=1,ntmax(inpstp))
                  if(prtdbgi.gt.1) &
                   write(6,'(1x,3i3,2a,7i3)') inpind,inpreg,inpstp,duma,dumc, &
                  ntmax(inpstp), &
                  (IPASTP(inpstp,IDOWN),IDOWN=1,ntmax(inpstp))
                if(inpstp.ne.is) then
                   write(6,*) 'PRODFLOW file missing step definitions'
                   return
                endif
              enddo
! Read definitions for reporting energy by process step subset groupings.
! This option currently applies to the Chemicals industry Only so summary reports for
! each subindustry and each end-uses are created.

              if(NumRptGrps.gt.0) then

!      INTEGER NumRptGrps                  ! Number of Reporting SubGroups for Process Assembly Energy reporting (used in Chemicals for Subindustry rpt), max:12, min:0
!      INTEGER NumRptGrpSteps(12)          ! Number of steps in each reporting SubGroup for P/A
!      INTEGER RptGrpSteps(12,maxstep)     ! Identification of step numbers included in each reporting subgroup in P/A
!      Character*24 RptGrpNames(12)        ! Reporting group names
!      Character*24 RptGrpSName(12,maxstep+1)! Reporting labels for step names
                if(prtdbgi.gt.1) then
                   write(6,*) 'Process Assembly Reporting Sub-Groups'
                   write(6,*) '  Ind Reg Grp  Group Name Steps Step#    Step Name'
                endif
                do g=1,NumRptGrps
12                read(iunit,'(a)') line
                  if(line(1:1).eq.'*') goto 12
                  read(line,*) inpind,inpreg,inpg,RptGrpNames(inpg),NumRptGrpSteps(inpg), &
                    (RptGrpSteps(inpg,igs),igs=1,NumRptGrpSteps(inpg)),                    &
                    (RptGrpSName(inpg,igs),igs=1,NumRptGrpSteps(inpg))
                  RptGrpSName(inpg,NumRptGrpSteps(inpg)+1)='  Total'
                  if(prtdbgi.gt.1) then
                    write(6,'(1x,3i4,1x,a,i5)') inpind,inpreg,inpg,RptGrpNames(inpg),NumRptGrpSteps(inpg)
                    do igs=1,NumRptGrpSteps(inpg)
                      write(6,'(32x,i5,6x,a)') RptGrpSteps(inpg,igs),RptGrpSName(inpg,igs)
                    enddo
                  endif
                enddo
! for p/a totaling
                RptGrpNames(NumRptGrps+1)='Total Process/Assembly'
                NumRptGrpSteps(NumRptGrps+1)=mpastp
                do is=1,mpastp
                   RptGrpSteps(NumRptGrps+1,is)=is
                   RptGrpSName(NumRptGrps+1,is)=indstepname(is)
                enddo
              endif
! read retirement rates
              do is=1,mpastp
13              read(iunit,'(a)') line
                if(line(1:1).eq.'*') goto 13
                read(line,*) inpind,inpreg,inpstp,indstepname(inpstp),dumc,prodretr(inpstp)
                  if(prtdbgi.gt.1) &
                   write(6,'(1x,3i3,a,f10.4)') inpind,inpreg,inpstp,duma,prodretr(inpstp)
                if(inpstp.ne.is) then
                   write(6,*) 'PRODFLOW file missing retirement rates'
                   return
                endif
              enddo
              indstepname(mpastp+1)='Total Process/Assembly'

            elseif(inpind.gt.inddir.or.(inpind.eq.inddir.and.inpreg.gt.indreg)) then
               backspace(iunit)
               return
            endif
          else
! read prodflow rates
            read(line,*) inpind,inpreg
            if(inpind.eq.inddir.and.inpreg.eq.indreg) then
              read(line,*) inpind,inpreg,ivint,inpstp, &
              dumc, &
             (prodflow(min(ivint,2),inpstp,idown),idown=1,ntmax(inpstp))
              if(prtdbgi.gt.1) &
!       this is here for experimental purposes only !!!
!             if(ivint.eq.3) then
!               do idown=1,ntmax(inpstp)
!                 prodflow(2,inpstp,idown)=
!    1            prodflow(1,inpstp,idown)           !  keep same flows
!               enddo
!             end if
              write(6,'(4i3,a,6f10.3)') inpind,inpreg,ivint,inpstp, &
              dumc, &
             (prodflow(min(ivint,2),inpstp,idown),idown=1,ntmax(inpstp))
            else
              backspace(iunit)
              return
            endif
          endif

        endif
      enddo

! close the file when the last energy-intensive industry is read
      if (inddir.eq.numind.and.indreg.eq.4) goto 99
      return
! end of file branch.  close file
99    fname='PRODFLOW'
      iunit=file_mgr('C',fname,new)
      iunit=0
      return
      end subroutine mecsbase
! =======================================================
      subroutine uectpc
   use i_
      implicit none
      real futuec
      external futuec

      integer is,i_ind,i_ifx,ifx,ifl,i_ir,i_stp
      character*20 duma,line*100
      real minpint
      integer iuectpc/0/  ! unit number.  if zero, open file
      CHARACTER*20 FUELNAME(50)
      fuelname=' '  ! array initialization
      FUELNAME(1)='ELECTRICITY '
      FUELNAME(2)='GENERATION'
      FUELNAME(3)='NAT GAS CORE '
      FUELNAME(4)='NAT GAS NONCORE'
      FUELNAME(5)='NAT GAS FEEDSTOCK'
      FUELNAME(6)='NAT GAS LEASE & PLANT'
      FUELNAME(7)='STEAM COAL'
      FUELNAME(8)='COKING COAL'
      FUELNAME(9)='NET COKE IMPORTS'
      FUELNAME(10)='RESIDUAL OIL'
      FUELNAME(11)='DISTILLATE OIL'
      FUELNAME(12)='LPGS HEAT AND POWER'
      FUELNAME(13)='LPGS FEEDSTOCKS'
      FUELNAME(14)='MOTOR GASOLINE'
      FUELNAME(15)='STILL GAS'
      FUELNAME(16)='PETROLEUM COKE'
      FUELNAME(17)='ASPHALT & ROAD OIL'
      FUELNAME(18)='LUBES & WAXES'
      FUELNAME(19)='PETROCHEM FEEDSTOCKS'
      FUELNAME(20)='KEROSENE'
      FUELNAME(21)='OTHER OIL FEEDSTOCKS'
      FUELNAME(22)='OTHER PETROLEUM'

      iyr=curiyr+baseyr-1
      ir=indreg

        if(prtdbgi.ge.1.and.curitr.eq.1.and.curcalyr.eq.ibyr2) then

! write out what could be used as the ITECH file to INDTST.txt
!  (would be used if steps/industries changed or for debugging
        do is=1,mpastp
          write(iunit1,3002) indnum,ir,indstepname(is),ifmax(is), &
            (ifloc(ifl,is),ifl=1,ifmax(is))

3002   format(1x,i2,',',i1,',','''',a,'''',',',i2,',', &
       15(i2,','))
        enddo
        DO IS = 1,MPASTP
          DO IFL = 1,IFMAX(IS)
            IFX = IFLOC(IFL,IS)
            write(iunit1,3001) indnum,ir, &
            indstepname(is),ifx,fuelname(ifx), &
            einter(1,ifl,is), &
            futuec(einter(1,ifl,is),bcsc(1,ifl,is),29), &
            bcsc(1,ifl,is), &
            einter(3,ifl,is), &
            futuec(einter(3,ifl,is),bcsc(3,ifl,is),29), &
            bcsc(3,ifl,is)

          enddo
        enddo
3001     format(1x,i2,',',i1,',', '''',a,'''',',',i2,',', &
          '''',a,'''',',',2(f8.4,',',f8.4,',',f8.4,','))
       endif

!
!   read in the ITECH file used as the
!   spreadsheet input (in comma-separate-value format)
!   to obtain UECs and TPCs

! open file first time through
      if(iuectpc.eq.0) then
        fname='ITECH'
        new=.false.
        iuectpc=file_mgr('O',fname,new)
        READ(iuectpc,*)         ! Six line comment/header must be read-over
        READ(iuectpc,*)
        READ(iuectpc,*)
        READ(iuectpc,*)
        READ(iuectpc,*)
        READ(iuectpc,*)
      endif

      if(iuectpc.gt.0) then

!  For hitech case, read second set of UEC/TPCs for use after 'techstrtyr'.
!  To do this, position file in the middle after the "hitech" record
!
        if(hitech.eq.1.and.curcalyr.gt.techstrtyr.and. &
           ir.eq.1.and.inddir.eq.1 ) then
           rewind iuectpc
 25        continue
           read(iuectpc,'(a)',end=199) line      ! read lines until the end or
           if(index(line,'hitech').eq.0) goto 25  ! until a record with "hitech" is found
           write(6,*) ' Hitech records found in ITECH file'
        endif
        if(prtdbgi.gt.1) then
          write(6,*) ' Reading ITECH File, inddir,ir=',inddir,ir,iyr
        endif
        DO IS = 1,MPASTP
! count fuels used in each step.  Allows fuel detail to override enprod
          ifmax(is)=0
          ifl=0
! test each fuelrecord to see if it belongs in this industry, region, and step
 26       continue
          i_ind=0
          i_ir=0
          i_stp=0
          duma=' '
          i_ifx=0
          read(iuectpc,*,end=199,err=299,iostat=ios) i_ind,i_ir,i_stp,duma,i_ifx

          if(i_ind.eq.indnum.and.i_ir.eq.ir.and.i_stp.eq.IS) then
             ifl=ifl+1
             ifmax(is)=ifmax(is)+1
             ifloc(ifl,is)=i_ifx
             IFX = IFLOC(IFL,IS)
             indstepname(is)=duma
             backspace iuectpc
             read(iuectpc,*,end=199,err=299) i_ind,i_ir,i_stp,duma,i_ifx, &
                    duma,einter(1,ifl,is),minpint,bcsc(1,ifl,is), &
                         einter(3,ifl,is),minpint,bcsc(3,ifl,is)
! NSK ibyr2 update 7/2020; although this is for end-use industries, the values are read in only on the first year the model runs
             if(iyr.eq.ibyr2) then          
                enpint(1,ifl,is)=einter(1,ifl,is)
                enpint(3,ifl,is)=einter(3,ifl,is)
                enpint(2,ifl,is)=einter(3,ifl,is)
             endif
             goto 26
          else
             backspace iuectpc
          endif
        enddo
      endif
199   continue
     if (inddir.ge.numind.and.indreg.ge.4) then
         fname='ITECH'
         iuectpc=file_mgr('C',fname,new)
         iuectpc=0
      endif
      return

299   continue
!      write(6,*) 'possible error reading iuectpc, iostat=',ios
!      write(6,*) 'erroneous line follows (except if end-of-file or "hitech")=>'
!      line=' '
!      backspace iuectpc
!      read(iuectpc,'(a)',end=298,err=298) line
!      write(6,'(a)') line

 298  continue
      if (inddir.ge.numind.and.indreg.ge.4) then
         fname='ITECH'
         iuectpc=file_mgr('C',fname,new)
         iuectpc=0
      endif

      end  subroutine uectpc
! =======================================================
      function futuec(base,tpc,nyears)
   use i_
      implicit none

!     Calculates UEC in some future year from the base
!     year value (base), a rate of decline (tpc: negative),
!     and the number of years.
      real base, tpc, futuec
      integer nyears


      futuec=base
      if(base.ne.0..and.tpc.ne.0.) then
        futuec=base*(1.+tpc)**nyears
      endif
      return
      end function futuec
! ============================================================
!  read Cogeneration Penetration Assumption Spreadsheet
      SUBROUTINE cogent
   use i_
      implicit none
      integer do_once/0/
      integer idebug
      save do_once


      CHARACTER*16 RNAME
      INTEGER WKUNIT



      if(do_once.eq.0) then
         do_once=1
         NEW=.FALSE.
         FNAME='INDCOGENX'   !indcogenx.xlsx


!  OPEN WORKSHEET FILE USING FILE MANAGER
         WKUNIT = FILE_MGR('O',FNAME,NEW)


!  CALL SUBROUTINE TO READ ALL DEFINED RANGES FROM WORKSHEET
!  This stores the ranges in a temporary data area that can
!  get overwritten by the next model if they use it.  So all
!  ranges have to be extracted from the temporary area immediately.

         CALL ReadRngXLSX(WKUNIT,'icogen')  ! read range names and corresponding data from indcogenx.xlsx, worksheet "icogen"

!  CLOSE WORKSHEET FILE
         WKUNIT = FILE_MGR('C',FNAME,NEW)

!  Copy each range from worksheet data area to variables
!  GETRNGR:  Copies a REAL variable from the worksheet
!            data area into the variable.
!
! System characteristics--8 (nsys) system sizes considered

         CALL GETRNGR('eleccap         ',CogSizeKW       ,1,nsys,1)
         CALL GETRNGR('capcostyearly   ',CapCostYearly   ,endyr-2003+1,nsys,1)
         CALL GETRNGR('capfac          ',CapFac          ,1,nsys,1)
         CALL GETRNGR('heatrateyearly  ',CHeatRateYearly ,endyr-2003+1,nsys,1)
         CALL GETRNGR('overalleffyear  ',OverAllEffYearly,endyr-2003+1,nsys,1)
         CALL GETRNGR('rapidcapcostyr  ',RapidCapCostYr  ,endyr-2003+1,nsys,1)
         CALL GETRNGR('rapidheatrateyr ',CRapidHeatRateYr,endyr-2003+1,nsys,1)
         CALL GETRNGR('rapidoralleffyr ',RapidOrAllEffYr,endyr-2003+1,nsys,1)
! Steam Load Segmentation for 8 boiler size class:
!
         CALL GETRNGR('steamseg_food   ',SteamSeg_Food  ,1,nload,1)
         CALL GETRNGR('steamseg_paper  ',SteamSeg_Paper ,1,nload,1)
         CALL GETRNGR('steamseg_chem   ',SteamSeg_Chem  ,1,nload,1)
         CALL GETRNGR('steamseg_steel  ',SteamSeg_Steel ,1,nload,1)
         CALL GETRNGR('steamseg_other  ',SteamSeg_Other ,1,nload,1)
         CALL GETRNGR('steamseg_refin  ',SteamSeg_Refin ,1,nload,1)
!         CALL GETRNGR('thermalcap      ',thermalcap    ,1,nload,1)
         
         CALL GETRNGR('penetration     ',Penetration    ,1,nload,1)
         CALL GETRNGR('acceptfrac      ',AcceptFrac     ,13,1,1)
         CALL GETRNGR('acceptfrac2     ',AcceptFrac2    ,13,1,1)
         CALL GETRNGR('CapCostMult     ',CapCostMult     ,1,nsys,1)
         write(6,'(a,8F10.3)') 'CapCostMult=',capcostmult

         CALL GETRNGI('CapCostMultStar ',CapCostMultStart,1,1,1)
         CALL GETRNGI('CapCostMultEnd  ',CapCostMultEnd  ,1,1,1)
         write(6,'(a,i4)') 'CapCostMultStart=',CapCostMultstart
         write(6,'(a,i4)') 'CapCostMultEnd  =',CapCostMultEnd
         CALL GETRNGR('StandbyFrac     ',StandByFrac     ,1,1,1)
         CALL GETRNGR('DollarYear      ',DollarYearCHP   ,1,1,1)

! execute economic evaluation for a trial run and print results

         idebug=prtdbgi
         CogElecPrice=CogElecPrice*(1.-StandByFrac)
         call EvalCogen(idebug,CURIYR+BASEYR-1)
!
      ENDIF  ! doonce=1
      Return
      End SUBROUTINE cogent
! ==============================================================================
      Subroutine EvalCogen(idebug,Year)
   use i_
      implicit none
      real acceptance
      external acceptance
      integer idebug, il, isys,Year,year2, t, RTOVALUE, LEGIRA
      real CapCost, PVSav, disrate, CHPyr
      external RTOVALUE
      LEGIRA=RTOVALUE('LEGIRA  ',1)
! Assign the current year cost and performance characteristics.
      year2=year
      if(year2.lt.2009) year2=2009    ! Base year for CHP data is 2009
!      if(hitech.eq.1.and.curcalyr.gt.2008) year2=ijumpcalyr  ! use ijumpcalyr cost/perform assumptions for hitech case
      if(frztech.eq.1.and.curcalyr.gt.techstrtyr) year2=techstrtyr ! use side case start yr cost/perform assumptions for frozen case

      do i=1,nsys
        CogCapCostKW(i)=CapCostYearly(year2,i)
        Cheatrate(i)   =CheatRateYearly(year2,i)
        OverAllEff(i)  =OverAllEffYearly(year2,i)
      enddo

      if(hitech.eq.1) then
        do i=1,nsys
          CogCapCostKW(i)=RapidCapCostYr(year2,i)
          Cheatrate(i)   =CRapidHeatRateYr(year2,i)
          OverAllEff(i)  =RapidOrAllEffYr(year2,i)
        enddo
      endif

!  Establish the technical characteristics derived from the input characteristics
         do i=1,nsys
           ElecGenEff(i)=3412./CHeatRate(i)
           ElecSizeMWH(i)=CogSizeKW(i) * 8.760 * &
             MIN(CapFac(i),maxRegCHPutil(indreg,inddir) * &
             (QELAS(11,curiyr)/QELAS(11,22))) ! maxRegCHPutil(indreg,inddir) is our POT_08/01/2013
                                              ! initial guess for assumed utilization
           FuelUse(i)=ElecSizeMWH(i) * CHeatRate(i)/10.**6  ! to bill btu/yr
           PowerSteam(i)=ElecGenEff(i)/(OverAllEff(i)-ElecGenEff(i))
           SteamOutput(i)=CogSizeKW(i)*.003412 /PowerSteam(i)
         enddo

!  For each load segment l..
      do il=1,nload

         EboilEff(il)=.8
         !SteamLoad(il)=ThermalCap(il) ! new
      enddo
      do il=1,nload
!        Use preassigned cogeneration system for each load segment
!        (as opposed to some sort of thermal matching done previously).


         CogSys(il)=il
         isys=CogSys(il)

         FuelCost(il)     = FuelUse(isys)*CogFuelPrice      ! to 1000s of $
         ExistFuelUse(il) = SteamOutput(isys) * 8.76 * &
                              MIN(CapFac(isys),maxRegCHPutil(indreg,inddir) * &    ! POT_08/01/2013 UTIL1 CHANGE
                              (QELAS(11,curiyr)/QELAS(11,22))) / & ! maxRegCHPutil(indreg,inddir) is our
                              EBoilEff(il)                    ! initial guess for assumed utilization

         ExistFuelCost(il)= ExistFuelUse(il) * CogFuelPrice

         ElecValue(il)    = ElecSizeMWH(isys) * CogElecPrice*.003412
         IncrFuelCost(il) = FuelCost(il) - ExistFuelCost(il)
         OperProfit(il)   = ElecValue(il) - IncrFuelCost(il)


         CapCost=CogCapCostKW(isys)

! Multiply capital cost by a factor if in the specified interval. Implements
! CCTI if alternate icogen.wk1 input file used

         if(Year.GE.CapCostMultStart.AND.Year.LE.CapCostMultEnd) Then
           CapCost=CogCapCostKW(isys)*CapCostMult(isys)
           IF (LEGIRA.eq.3) then    ! High IRA case (delete after AEO2023)
               IF((Year.eq.2023).or.(Year.eq.2024)) THEN    ! Use investment tax credit of 42% instead of 10% (so CapCostMult=0.58 instead of 0.90)
                  CapCost=CogCapCostKW(isys)*CapCostMult(isys)*58.0/90.0
               ENDIF
           ENDIF
         endif

         Investment(il)   = CogSizeKW(isys) * CapCost *.001

!   check for very small or negative zero operating profit, assign desired results for those instances4zero

        if (OperProfit(il) .le. 0.5) then
            OperProfit(il)=-0.5
            CPayBack(il)=99
            EconFrac(il)=0.
        else

         ! Use new economic choice model, ROI breakeven period rather than payback
         ! variables have been kept as "payback" to keep it simple and because the acceptance curve still holds
           CPayBack(il)=99.
           PVSav=0
           t=0
           disrate=(MC_RMTCM10Y(curiyr) &                 ! Nominal discount rate is 10 yr treasury rate
                    -((MC_CPI(11,curiyr)/MC_CPI(11,curiyr-1))-1)*100 &  ! convert to real rate
                    +2.)/100.                             ! plus a 2% ref risk premium
           DO t=1,99
              CHPyr=real(t)
              PVSav=(OperProfit(il)/((1+disrate)**CHPyr))+PVSav
              IF (PVSav .ge. Investment(il)) THEN
                 CPayBack(il)=CHPyr-(PVSav-Investment(il))/(OperProfit(il)/((1+disrate)**CHPyr))
                 EXIT
              ENDIF
           ENDDO
         ! IF (t .gt. 13) THEN
         ! CPayBack(il)=14.
         ! ENDIF

         ! CPayBack(il)     = Investment(il) / OperProfit(il)    **Old econ equation**

!  Get Economic Fraction based on the Payback Acceptance Curve.  Two versions
!  of the curve are used: one version for small plants, represents industrial ownership.
!  the second, used for the largest plants, represents independent ownership.

         if(il.le.6) then
           EconFrac(il)     = Acceptance(AcceptFrac(1),13,CPayback(il))
         else
           EconFrac(il)     = Acceptance(AcceptFrac2(1),13,CPayback(il))
         endif
        endif
!
         if(idebug.gt.1) then
           call WritCogen(6,isys,il)
         endif
      enddo
      return
      end  Subroutine EvalCogen
! ==============================================================================
      FUNCTION Acceptance(AcceptFrac,n,Payback)
      implicit none

!   Do a lookup and interpolation to find the acceptance fraction
!   for a given payback
      integer n,i
      real acceptance,payback,AcceptFrac(n),frac,top,bot

      acceptance=0.
      if(isnan(payback)) return
      TOP=0.
      BOT=0.0
      if(payback.lt.0.) return
      i=floor(payback)+1

      if(i.le.n) then
        top=AcceptFrac(i)
        if(i.le.n-1) bot=acceptfrac(i+1)

! establish interpolation fraction
        frac=payback-floor(payback)

! interpolate between the two steps on the payback acceptance
! vector.
        acceptance=top-frac*(top-bot)
      end if
      return
      end FUNCTION Acceptance

! ==============================================================================
      Subroutine WritCogen(O,ISYS,l)
   use i_
      implicit none

      integer O
      integer isys ! system number (1 to 5)
      integer l    ! load segment  (1 to 4)

1000  format(10x,a,t60,f11.2)
1003  format(10x,a,t60,f11.3)
      write(O,*) ' '
      write(O,*) ' '
      write(O,1000) 'Cogeneration System Evaluation (2018$)'
      write(O,1000) ' '
      write(O,1000) 'Prices ($/mmbtu) '
      write(O,1000) '  Elec  ',CogElecPrice
      write(O,1000) '  Nat Gas ',CogFuelPrice
      write(O,1000) ' '
      write(O,1000) 'Cogen System Assumptions '
      write(O,1000) '  Cogen Capacity (KW) ',CogSizeKW(isys)
      write(O,1000) '  Cogen Elec Output(MWH) ', ElecSizeMWH(isys)
      write(O,1003) '  Power-to-Steam Ratio (BTU-Elec/BTU-Heat)', &
        PowerSteam(isys)
      write(O,1000) '  Steam output (mmBtu/hr) ', SteamOutput(isys)
      write(O,1000) '  Heat rate(btu/kwhe) ', CHeatRate(isys)
      write(O,1000) '  Fuel Use (Bill Btu/year) ',FuelUse(isys)
      write(O,1003) '  Overall Efficiency ',OverAllEff(isys)
      write(O,1000) ' '
      write(O,1000) 'Existing System (or conventional system) '
      write(O,1000) '  Steam output (mmBtu/hr) ',SteamOutput(isys)
      write(O,1000) '  Boiler Efficiency ',EBoilEff (l)
      write(O,1000) '  Fuel use per (bill btu/year) ',ExistFuelUse(l)
      write(O,1000) ' '
      write(O,1000) 'Electricity Value '
      write(O,1000) '  Elec price ($/mwh) ',CogElecPrice*3.412
      write(O,1000) '  Value of Electricity (Thous $/year) ', &
       ElecValue(l)
      write(O,1000) ' '
      write(O,1000) 'Operating Cost (thous $/year) '
      write(O,1000) '   Cogen System ',FuelCost(l)
      write(O,1000) '   Existing System ',ExistFuelCost(l)
      write(O,1000) '      Incremental fuel cost ', &
       IncrFuelCost(l)
      write(O,1000) ' '
      write(O,1000) 'Incremental Investment for Cogen (Thous $) ', &
       Investment(l)
      write(O,1000) 'Gross Operating Profit (Elect Savings-Fuel Cost),', &
       OperProfit(l)
      write(O,1000) 'ROI Breakeven Period ',CPayBack(l)
      write(O,1000) 'Econ Fraction  ',EconFrac(l)
      return
      end Subroutine WritCogen
! ====================================================================
      subroutine pcoggen
   use i_
      implicit none


      real sumit(numflchp+1),SCogCap(numflchp+1)
      integer ifuel,indsic,ic
      character*3 fuels(numflchp+1)/'col','oil','gas','hyd','geo','msw','wod','sol','oga','oth','tot'/

      INTEGER K,L,M

      integer fuel,div
      yr=iyr-1989
      sumit=0.
      IF(INDREG.EQ.1) THEN
        L = 1
        M = 2
      ELSE IF(INDREG.EQ.2) THEN
        L = 3
        M = 4
      ELSE IF(INDREG.EQ.3) THEN
        L = 5
        M = 7
      ELSE IF(INDREG.EQ.4) THEN
        L = 8
        M = 9
      ENDIF
      if(indreg.eq.1.and.inddir.eq.1) then
        scogcap=0.
      endif
      do i=l,m
        do fuel=1,numflchp ! fuel
           scogcap(fuel)=scogcap(fuel)+ cogcap(i,curiyr,inddir,fuel)
        enddo
      enddo
      if(indreg.eq.4.and.inddir.eq.numind) then

        do ifuel=1,numflchp
          do indsic=1,numind
            do ic=1,9
              sumit(ifuel)=sumit(ifuel) + coggen(ic,yr,indsic,ifuel)
            enddo
          enddo
        enddo


        sumit(numflchp+1)=sum(sumit(1:numflchp))

        do ifuel=1,numflchp+1
          write(6,'(a6,i4,1x,a3,5f10.1)') 'sumit ',iyr,fuels(ifuel), &
          sumit(ifuel)
        enddo
      endif
201   format(1x,a,i4,i3,' D',i1,1x,a3,4f12.5)
202   format(1x,a,i4,i3,' D',i1,1x,2x,4f12.5)
302   format(1x,a,i4,i3,' R',i1,1x,2x,4f12.5)

      do i=L,M
        do fuel=1,numflchp+1
          write(6,201) 'coggen ',1989+curiyr,inddir,i, &
          fuels(fuel),coggen(i,curiyr,inddir,fuel)

          write(6,201) 'cogcap ',1989+curiyr,inddir,i,  &
          fuels(fuel),cogcap(i,curiyr,inddir,fuel)
        enddo
      enddo
      if(indreg.eq.4.and.inddir.eq.numind) then
        scogcap(numflchp+1)=sum(scogcap(1:numflchp))
        write(6,'(a,i4,11f10.2)') ' Scogcap=', &
         curiyr+1989,(scogcap(fuel),fuel=1,numflchp+1)
      endif
      return
      end subroutine pcoggen
!===============================================================================
      FUNCTION MINVERT(AI,BI,III,JJJ,A,B,ID)
      integer id,iii,jjj,kk,nv,kkm,l,ipo,k,kmo,n
      real minvert
! Matrix Inversion and Determinant
! This function inverts the input matrix AI. BI is identity matrix on input
! (1s on diagonal; 0 elsewhere). BI becomes the inverse matrix on output.
! AMATQ2 returns the determinant of the matrix.
! If the determinant is 0, then the matrix was singular (having no inverse
! because rows are linearly dependent).
! Source: copied out of some old math library listing many years ago.
!
!  input matrices AI is real*4
!  output matrices A is real*8
!  BI and B contain the inverted matrix,
!  BI is real*4; and B is REAL*8.
!  III (and JJJ) = the size of the matrix
!  ID is the passed length dimension of the arrays.
!  III is normally less than the maximum ID

        REAL*8 R,S,D
        real*4 AI(ID,ID),BI(ID,1)
        real*8 A(ID,ID),B(ID,1)
        KK=III
        NV=JJJ
        KKM=KK-1
        D=1.D0
        IF(NV) 10,20,20
   10   NV=-NV
        D=0.D0
   20   DO 50 I=1,III
          DO 30 J=1,III
   30       A(I,J)=DBLE(AI(I,J))
          DO 40 J=1,NV
   40       B(I,J)=DBLE(BI(I,J))
   50   CONTINUE
        DO 200 I=1,KKM
        S=0.D0
        DO 70 J=I,KK
        R=DABS(A(J,I))
        IF(R-S)70,60,60
   60   S=R
        L=J
   70   CONTINUE
        IF(L-I)80,130,80
   80   DO 90 J=I,KK
        S=A(I,J)
        A(I,J)=A(L,J)
   90   A(L,J)=S
        IF(NV)120,120,100
  100   DO 110 J=1,NV
        S=B(I,J)
        B(I,J)=B(L,J)
  110   B(L,J)=S
  120   D=-D
  130   IF(A(I,I)) 140,200,140
  140   IPO=I+1
        DO 190 J=IPO,KK
        IF(A(J,I)) 150,190,150
  150   S=A(J,I)/A(I,I)
        A(J,I)=0.D0
        DO 160 K=IPO,KK
  160   A(J,K)=A(J,K)-A(I,K)*S
        IF(NV)190,190,170
  170    DO 180 K=1,NV
  180   B(J,K)=  B(J,K)-  B(I,K)*S
  190   CONTINUE
  200   CONTINUE
        DO 210 I=1,KK
  210   D=D*A(I,I)
        IF(NV)250,250,220
  220   KMO=KK-1
        DO 240 K=1,NV
        IF(A(KK,KK).NE.0.D0)B(KK,K)=B(KK,K)/A(KK,KK)
        DO 240 I=1,KMO
        N=KK-I
        DO 230 J=N,KMO
  230   B(N,K)=B(N,K)-A(N,J+1)*B(J+1,K)
  240   IF(A(N,N).NE.0.D0)B(N,K)=B(N,K)/A(N,N)
  250   MINVERT=SNGL(D)
        DO 260 I=1,III
        DO 260 J=1,NV
  260   BI(I,J)=SNGL(B(I,J))
        RETURN
        END FUNCTION MINVERT

!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!  THIS IS A REPORT-WRITER PROGRAM FOR THE INDUSTRIAL MODULE.
      subroutine INDSIC(argc)
   use i_
      IMPLICIT NONE

	  INTEGER STfuelmap(6)
	  DATA STfuelmap /1,2,3,8,6,7/ !Iron and Steel industry fuels from array ENPQTY (elec,ng,resid,other pet,steam coal, coke coal)
      INTEGER IY,ISTEP,IS,IFUEL(50)
      INTEGER ifuelpa(maxstep+1,16),IROW/0/
      INTEGER IU,IY1,IY2
      INTEGER IREG,IFF,IREC,IGROUP
      INTEGER IUNIT(5)
      real*8 rval
      CHARACTER*166 LINE ! length must match the 166 character length declaration in ckstr (in fwk1io.f)
      CHARACTER*3  INTG
      REAL OUTPUT(maxstep,0:5)  ! PHYSICAL OUTPUT
      REAL EMPLOY(0:5)     ! EMPLOYMENT
      REAL OUTPUTQTY(0:5)  ! QUANTITY OF OUTPUT
      REAL OUTPUTVAL(0:5)  ! VALUE OF OUTPUT
      REAL OUTPUTACT(0:5)  ! Value of output, Actual (without subsector re-weighting, if applicable)
      CHARACTER*33 fullname(21) / &                ! industry name variable changed
           'Crop Agriculture                 ', &  ! to allow better table headings (ESE 6/8/09)
           'Other Agriculture                ', &
           'Coal Mining                      ', &
           'Oil & Gas Mining                 ', &
           'Metallic & Non-metallic Mining   ', &
           'Construction                     ', &
           'Food                             ', &
           'Paper                            ', &
           'Bulk Chemicals                   ', &
           'Glass                            ', &
           'Cement                           ', &
           'Iron & Steel                     ', &
           'Aluminum                         ', &
           'Fabricated Metals                ', &
           'Machinery                        ', &
           'Computers & Electronics          ', &
           'Transportation Equipment         ', &
           'Electrical Equipment & Appliances', &
           'Wood                             ', &
           'Plastics & Rubbers               ', &
           'Balance of Manufacturing         '/

!
!  IN THE FOLLOWING ARRAYS, THE THIRD SUBSCRIPT IS as follows:
!      0 = NATIONAL TOTALS
!      1-4 = REGIONAL TOTALS
!      5 = TOTALS FOR THE CURRENT INDUSTRY
      REAL ENPMQTYT(23,0:8)     ! ENERGY CONSUMPTION BY FUEL
      REAL ENPIQTYT(7,0:8)      ! INTERMEDIATE PRODUCT CONSUMPTION BY FUEL
      REAL ENPRQTYT(9,0:8)      ! RENEWABLES CONSUMPTION BY FUEL
      REAL BLDENCONS(12,0:8)    ! ENERGY CONSUMPTION IN BUILDINGS
      REAL ENPQTYT(16,maxstep+1,5)! ENERGY CONSUMPTION FOR PROCESS & ASSEMBLY
      REAL ENPQTYsub(16,12,maxstep+1,5) !energy summed by fuel for up to 12 step subset groups (for chemical subindustries and end-use totals).
      REAL ENSQTYT(50,0:8)      ! ENERGY CONSUMPTION FOR BOIL/STEAM/COGEN
      REAL BYPQTYTR(8,0:8)      ! BYPRD-REN CONSUMPTION FOR BOIL/STEAM/COGEN
      REAL BYPQTYTI(6,0:8)      ! BYPRD-INTR CONSUMPTION FOR BOIL/STEAM/COGEN
      REAL STEMCURT(0:8)        ! STEAM GENERATION
      REAL COGSTEAMT(0:8)       ! Cogen STEAM GENERATION
      REAL NONCOGSTEAMT(0:8)    ! non cogen STEAM GENERATION
      REAL BIOSTEAMT(0:8)       ! non cogen STEAM GENERATION from biomass
      REAL NONCOGFOSSTEAMT(0:8) ! non cogen STEAM GENERATION from fossil fuels

      REAL ELOWNT(0:8)   ! ELECTRICITY GENERATION FOR OWN USE
      REAL ELSALET(0:8)   ! ELECTRICITY GENERATION FOR SALE TO GRID
      REAL GENFUELT(4,0:8)! FUEL CONSUMPTION FOR ELECTRIC GENERATION
      REAL RPTGENT(4,0:8) ! CHP generation by fuel GWH
      REAL RPTCAPT(4,0:8) ! CHP capacity by fuel MW
      REAL TOTAL    ! WORKING STORAGE FOR SUMS
      REAL WORK      ! WORKING STORAGE FOR RATIOS
      REAL REFIN(14,11)   ! REFINERY DATA by CENSUS 9-region
      REAL REFINE(14,5)   ! Refinery data by census 4-region+US
      REAL CLINKCO2(5)    ! Clinker Process emissions, 4-region+US
      REAL LIMECO2(5)     ! Lime process emissions,4-region+US

      INTEGER IBYPTMPR(8,0:5)
      INTEGER IBYPTMPI(6,0:5),IP

      CHARACTER*40  FUELNAME(50)
      CHARACTER*168 FLINE
      integer ifl,m,icd
!**********************************************************
!  INITIALIZE FUELNAME DATA.
!**********************************************************

      DATA FUELNAME / &
           'Electricity', &
           'Electricity Generated', &
           'Natural Gas Firm', &
           'Natural Gas Inter.', &
           'Natural Gas Feedstock', &
           'Natural Gas Lease & Plant', &
           'Steam Coal', &
           'Coking Coal', &
           'Net Coal Coke Imports', &
           'Residual Oil', &
           'Distillate Oil', &
           'LPGs for Heat And Power', &
           'LPGs for Feedstocks', &
           'Motor Gasoline', &
           'Still Gas', &
           'Petroleum Coke', &
           'Asphalt & Road Oil', &
           'Lubes & Waxes', &
           'Petrochemical Feedstocks', &
           'Kerosene', &
           'Other Petroleum Feedstocks', &
           'Other Petroleum', &
           ' ', &
           ' ', &
           ' ', &
           ' ', &
           ' ', &
           ' ', &
           ' ', &
           ' ', &
           'Steam', &
           'Coke Oven Gas', &
           'Blast Furnace Gas', &
           'Other Byproduct Gas', &
           'Waste Heat', &
           'Coke', &
           ' ', &
           ' ', &
           ' ', &
           ' ', &
           'Hydropower', &
           'Biomass-Wood', &
           'Biomass-Pulping Liquor', &
           'Geothermal', &
           'Solar', &
           'Photovoltaic', &
           'Wind', &
           'Municipal Solid Waste', &
           ' ', &
           ' '/

      CHARACTER*40  REFUELNAME(14) / &
           'Purch Elec, Peak', &
           'Purch Elec, Nonpeak', &
           'Purch Elec', &
           'Natural Gas, Core', &
           'Natural Gas, Noncore', &
           'Natural Gas', &
           'Coal', &
           'Residual Fuel, Low Sulfur', &
           'Distillate', &
           'Liquid Petroleum Gases', &
           'Still Gas', &
           'Petroleum Coke', &
           'Other Petroleum', &
           'Lease & Plant Fuel'/

      CHARACTER*40  BFUELNAME(10) / & 
	       'Natural Gas', &
           'Coal', &
           'Residual Fuel', &
           'Distillate', &
           'Liquid Petroleum Gases', &
           'Electricity', &
		   'Petroleum Coke', &
           'Other', &
           'Other Renewables',&
           'Biomass'/

      CHARACTER*24 BENCHVARS(17) / &
            'Electricity', &
            'Natural Gas', &
            'Steam Coal', &
            'Metallurgical Coal', &
            'Net Coal Coke Imports', &
            'Residual Oil', &
            'Distillate Oil', &
            'Liquid Petroleum Gas', &
            'Motor Gasoline', &
            'Still Gas', &
            'Petroleum Coke', &
            'Asphalt and Road Oil', &
            'Petrochemical Feedstocks', &
            'Kerosene', &
            'Other Petroleum', &
            'Biomass', &
            'Waste'/

      CHARACTER*52 GROUPNAME(6:8) / &
           'Sum of Energy-Intensive Industries', &
           'Sum of Non-Manufacturing Industries', &
           'Sum of Non-Energy-Intensive Manufacturing Industries'/
      character*25 bldname(12)/'Lighting--Electricity',  &
         'HVAC--Electricity     ','HVAC--Natural Gas     ','          HVAC--Steam', &
         'Support--Electricity  ','Support--Natural Gas  ','Support--Distillate  ','Support--LPG  ', &
         'Transport--Electricity','Transport--Natural Gas','Transport--Distillate','Transport--LPG' /
!    revised to aid indyDB tch Oct4,2006
!     character*25 genname(4)/'      Natural Gas',  '      Coal' ,'      Oil', '      Other'/
      character*25 genname1(4)/'  Natural Gas(MW)',  '  Coal(MW)' ,'  Oil(MW)', '  Other(MW)'/
      character*25 genname2(4)/' Natural Gas(gWh)',  ' Coal(gWh)' ,' Oil(gWh)', ' Other(gWh)'/
      character*25 genname3(4)/'Natural Gas(tBtu)',  'Coal(tBtu)' ,'Oil(tBtu)', 'Other(tBtu)'/
      integer      genorder(4)/ 3,1,2,4/
      integer      cfuel(8)
      integer      rfuel(9)
      
      CHARACTER*10  REGNAME(5)/ &
            'Northeast', &
            'Midwest', &
            'South', &
            'West', &
            'US Total'/
      DATA cfuel/1,4,7,10,11,12,16,22/      !  list of fuel indices always listed in bsc section; NSK 12/22
      DATA rfuel/3,6,7,8,9,10,11,12,13/     !  list of fuel indices always listed in refinery consumption section; NSK 12/22

      character*50 blnkfile
      character*166 rundoc(2)
      integer l
      integer I15,vers,icol,numstep
      logical once(5)/.true.,.true.,.true.,.true.,.true./
 ! for wk1 output routine.  holds unit number
      integer cwk1unit

     ! For each industry, identify the fuel rows that will be printed by their
     ! fuel index numbers.  PRINTEM(1,INDDIR) (first column below) is the number of
     ! fuels that have nonzero fuel consumption in at least one region.  PRINTEM(2...,INDDIR) are the
     ! applicable fuel indices.  These are used to assign a "1" (true) to the corresponding locations
     ! in PRINTFUEL(INDDIR,1..50).
	 ! KPE -- come back to this before default to see if there are any fuels we need to add
	 ! this will prevent unsightly nonalignment in indxxx files

      integer printem(14,numind)/ &
       11,  1,  3,  4, 10, 11, 12, 14, 22, 41, 42, 48,  0,  0,  &    ! ind # 1
       11,  1,  3,  4,  7, 10, 11, 12, 14, 22, 42, 41,  0,  0,  &    ! ind # 2
        6,  1,  3,  7, 10, 11, 14,  0,  0,  0,  0,  0,  0,  0,  &    ! ind # 3
        9,  1,  3,  4,  7, 10, 11, 14, 22, 42,  0,  0,  0,  0,  &    ! ind # 4
        7,  1,  3,  4,  7, 10, 11, 14,  0,  0,  0,  0,  0,  0,  &    ! ind # 5
        6,  1,  3, 11, 14, 17, 12,  0,  0,  0,  0,  0,  0,  0,  &    ! ind # 6
       10,  1,  3,  4,  7, 10, 11, 12, 41, 42, 48,  0,  0,  0,  &    ! ind # 7
       13,  1,  3,  4,  7, 10, 11, 12, 16, 22, 41, 42, 43, 48,  &    ! ind # 8
       13,  1,  3,  4,  5,  7, 10, 11, 12, 13, 16, 19, 22, 48,  &    ! ind # 9
        7,  1,  3,  4,  7, 10, 11, 12,  0,  0,  0,  0,  0,  0,  &    ! ind # 10
       11,  1,  3,  4,  7, 10, 11, 16, 22, 48, 12,  8,  0,  0,  &    ! ind # 11
       12,  1,  3,  4,  7,  8,  9, 10, 11, 22, 31, 41, 12,  0,  &    ! ind # 12
        9,  1,  3,  4,  7, 10, 11, 16, 41, 12,  0,  0,  0,  0,  &    ! ind # 13
       10,  1,  3,  4,  7,  8, 10, 11, 12, 41, 42,  0,  0,  0,  &    ! ind # 14
        9,  1,  3,  4,  7, 10, 11, 12, 41, 42,  0,  0,  0,  0,  &    ! ind # 15
        9,  1,  3,  4,  7, 10, 11, 12, 41, 42,  0,  0,  0,  0,  &    ! ind # 16
        9,  1,  3,  4,  7, 10, 11, 12, 41, 42,  0,  0,  0,  0,  &    ! ind # 17
       10,  1,  3,  4,  7, 10, 11, 12, 41, 42, 16,  0,  0,  0,  &    ! ind # 18
        9,  1,  3,  4,  7, 10, 11, 12, 41, 42,  0,  0,  0,  0,  &    ! ind # 19
        9,  1,  3,  4,  7, 10, 11, 12, 41, 42,  0,  0,  0,  0,  &    ! ind # 20
       10,  1,  3,  4,  7, 10, 11, 12, 16, 41, 42,  0,  0,  0/       ! ind # 21
      integer printfuel(numind,50),ifn, nfuel,igstot,igf2,istot,if2
      integer gfmax(12,maxstep+1),gfloc(16,12,maxstep+1),indcnt,bsize
!       9,  1,  3,  4,  7, 10, 11, 12, 41, 42,  0,  0,  0,  0,  &    ! ind # 18

!**********************************************************
! check argument to create regional spreadsheet.
! if "r ", only the USA total
! spreadsheet is created.
!**********************************************************

      INTEGER*4 regstart  ! 5 for usa total, 4 for 4 regions
      INTEGER*4 regstop   ! 5 for usa total, 4 for 4 regions
      INTEGER*4 iro(5),ius,g,igf,igs
      save iro,ius
      character*2 argc
      logical lexist,notopen/.false./
      real SumCDiv
      external SumCDiv
      integer irecl
      character*1 nul
      parameter (irecl=400)
      character*irecl longline
!******

      if(notopen) return
      fname='INDREG' ! for file_mgr
      if (argc(1:1).eq.'r')  then
         regstart=1
         regstop=4
         vers=1
         blnkfile='indreg.csv'
         fname='INDREG1' ! for file_mgr
      elseif (argc(1:1).eq.'1') then
         regstart=1
         regstop=1
         vers=1
         blnkfile='indreg1.csv'
         fname='INDREG1' ! for file_mgr
      elseif (argc(1:1).eq.'2') then
         regstart=2
         regstop=2
         vers=2
         blnkfile='indreg2.csv'
         fname='INDREG2' ! for file_mgr
      elseif (argc(1:1).eq.'3') then
         regstart=3
         regstop=3
         vers=3
         blnkfile='indreg3.csv'
         fname='INDREG3' ! for file_mgr
      elseif (argc(1:1).eq.'4') then
         regstart=4
         regstop=4
         vers=4
         blnkfile='indreg4.csv'
         fname='INDREG4' ! for file_mgr
      else
         regstart=5
         regstop=5
         vers=5
         blnkfile='indusa.csv'
         fname='INDUSA' ! for file_mgr
      endif

      if(once(vers)) then
        printfuel=0
        do inddir=1,numind
          nfuel=printem(1,inddir)
          do ifn=1,nfuel
            printfuel(inddir,PRINTEM(ifn+1,inddir))=1
          enddo
        enddo
      endif

! set which file is being written:  regional or us spreadsheet
! open output spreadsheets if this is the first time through
      if(vers.le.4) then
        if(once(vers)) then
   !       iro= 951
          iro(vers)=file_mgr('O',fname,.true.) ! get a free unit number from file_mgr
          if(iro(vers).le.0) iro(vers)=950+vers
          cwk1unit=iro(vers)
          inquire(unit=cwk1unit,opened=lexist)
          if(lexist) close(unit=cwk1unit,status='delete') ! close and delete wk1 file opened by file_mgr.  open csv file instead
          inquire(file=blnkfile,exist=lexist)
          if(lexist) then
             OPEN(UNIT=cwk1unit,FILE=blnkfile,FORM='FORMATTED', &
             ACCESS='DIRECT',recl=irecl,err=1000)
             close(cwk1unit,status='delete',err=1000)
1000         continue
          endif
          OPEN(UNIT=cwk1unit,FILE=blnkfile,FORM='FORMATTED', &
             ACCESS='DIRECT',status='new',recl=irecl,err=1001)

        endif
        i15=iro(vers)
      else
        if(once(vers)) then
!         ius=955
          iro(vers)=file_mgr('O',fname,.true.) ! get a free unit number from file_mgr
          inquire(unit=iro(vers),opened=lexist)
          if(lexist) close(unit=iro(vers),status='delete')

          if(iro(vers).le.0) iro(vers)=950+vers

          cwk1unit=iro(vers)
          inquire(file=blnkfile,exist=lexist)
          if(lexist) then
             OPEN(UNIT=cwk1unit,FILE=blnkfile,FORM='FORMATTED', &
             ACCESS='DIRECT',recl=irecl,err=2000)
             close(cwk1unit,status='delete',err=2000)
2000         continue
          endif
          OPEN(UNIT=cwk1unit,FILE=blnkfile,FORM='FORMATTED', &
           ACCESS='DIRECT',RECL=irecl,status='new',err=1001)

        endif
        i15=iro(vers)
      endif
      cwk1unit=i15
! get scenario/datecode identification of run
      rundoc(1)=' Scenario '//scen
      rundoc(2)=' DateCode '//date

      ICOL=curcalyr-ibyr2+3-1  !!TDTDTD
      irow=2
!**********************************************************
!  INITIALIZE THE SPREADSHEET FILE:
!**********************************************************
      if(once(vers)) then
        CALL ckstr(I15,1,1,rundoc(1),1,0,1)
        CALL ckstr(I15,2,1,rundoc(2),1,0,1)
      endif

      IY = curiyr
      i=iy
      iyr= curcalyr
!**********************************************************
!  CALCULATE NECESSARY VARIABLES FOR REPORT TABLES, FOR
!  EACH INDUSTRY.
!**********************************************************

      DO INDNUM=1,INDMAX
        inddir=indnum
        OUTPUT   =0.
        EMPLOY   =0.
        OUTPUTQTY=0.
        OUTPUTVAL=0.
        OUTPUTACT=0.
        ENPMQTYT =0.
        ENPIQTYT =0.
        ENPRQTYT =0.
        BLDENCONS=0.
        ENPQTYT  =0.
        ENPQTYsub=0.
        ENSQTYT  =0.
        BYPQTYTR =0.
        BYPQTYTI =0.
        STEMCURT =0.
        COGSTEAMT=0.
        NONCOGSTEAMT=0.
        BIOSTEAMT=0.
        NONCOGFOSSTEAMT=0.
        ELOWNT   =0.
        ELSALET  =0.
        GENFUELT =0.
        RPTGENT   =0.
        RPTCAPT   =0.
        IBYPTMPR =0.
        IBYPTMPI =0.
        IFUELpa = 0
        refine=0.
        clinkco2=0.
        limeco2=0.
        FOSFUELSTEAMSIZE(:,:,:,5)=0.


        DO INDREG=1,4

!**********************************************************
!  copy region-industry data
!**********************************************************

          CALL RDBIN

!  ESTABLISH PRODUCT THROUGHPUT FOR EACH PROCESS STEP.

          DO ISTEP=1,MPASTP
            IF(IDVAL.EQ.1) THEN			! PRODCUR is in physical units
              if (((inddir.eq.12).or.(inddir.eq.8)).and.(curcalyr.gt.ibyr2)) then
			  OUTPUT(ISTEP,5)=SUM(PRODCUR(1:4,ISTEP))/1000. !TD: prodcur is in thousand tons for iron and steel; is this ok?
              OUTPUT(ISTEP,indreg)=PRODCUR(indreg,ISTEP)/1000.
			  else
			  OUTPUT(ISTEP,5)=OUTPUT(ISTEP,5)+ (PRODCUR(4,ISTEP)/1000000.)
              OUTPUT(ISTEP,indreg)=PRODCUR(4,ISTEP)/1000000.
			  endif
            ELSE                                                              ! PRODCUR is in dollar units
              OUTPUT(ISTEP,5)=OUTPUT(ISTEP,5)+PRODCUR(4,ISTEP)
              OUTPUT(ISTEP,indreg)=PRODCUR(4,ISTEP)
            ENDIF
          ENDDO

!  ESTABLISH EMPLOYMENT NUMBER.

          EMPLOY(5) = EMPLOY(5)+EMPLX
          EMPLOY(INDREG) = EMPLOY(INDREG)+EMPLX

!  ESTABLISH PHYSICAL VALUE OF OUTPUT.
          if ((inddir.eq.12) .and. (curcalyr.ge.ibyr2)) prodx=prodx_steel(indreg)*1000.0  !steel has it's own dynamic prodflow subroutine: prodflow_steel -- changing "gt" to "ge" to allow ibyr2 base values of steel to be applied POT_ibyr2
          if ((inddir.eq.8) .and. (curcalyr.gt.ibyr2)) prodx=prodx_paper(indreg)*1000.0  !paper has it's own dynamic prodflow subroutine: prodflow_paper

          IF(IDVAL.EQ.2) THEN
            OUTPUTQTY(5) = 0.0
            OUTPUTQTY(INDREG) = 0.
          ELSE
           OUTPUTQTY(5) = OUTPUTQTY(5)+(PRODX/1000000.)
           OUTPUTQTY(INDREG) = PRODX/1000000.
          ENDIF

!  ESTABLISH DOLLAR VALUE OF OUTPUT.
          OUTPUTVAL(5) = OUTPUTVAL(5)+PRODVX
          OUTPUTVAL(INDREG) =PRODVX

!  ESTABLISH TOTAL ENERGY CONSUMPTION BY MAIN FUEL.

! SUSAN  changed Aug 6, 2013 ... corrected addition of cogen fuel for national
          DO IFn=1,23
             ENPMQTYT(IFn,5)=ENPMQTYT(IFn,5)+QTYMAIN(IFn,INDREG)
             ENPMQTYT(IFn,INDREG)=QTYMAIN(IFn,INDREG)
             IF (INDNUM .eq. 4) THEN          ! For O&G mine need to add cogen calc from OGS
                IF (IFn .eq. 3) THEN           ! Natural gas
                   ENPMQTYT(IFn,5)=ENPMQTYT(IFn,5)+SumCDIV(CGOGSQ(1,CURIYR,IFn),INDREG)
                   ENPMQTYT(IFn,INDREG)=ENPMQTYT(IFn,INDREG)+SumCDIV(CGOGSQ(1,CURIYR,IFn),INDREG)
                ELSE IF (IFn .eq. 7) THEN      ! Coal
                   ENPMQTYT(IFn,5)=ENPMQTYT(IFn,5)+SumCDIV(CGOGSQ(1,CURIYR,1),INDREG)
                   ENPMQTYT(IFn,INDREG)=ENPMQTYT(IFn,INDREG)+SumCDIV(CGOGSQ(1,CURIYR,1),INDREG)
                ELSE IF (IFn .eq. 10) THEN     ! Residual Fuel
                   ENPMQTYT(IFn,5)=ENPMQTYT(IFn,5)+SumCDIV(CGOGSQ(1,CURIYR,2),INDREG)
                   ENPMQTYT(IFn,INDREG)=ENPMQTYT(IFn,INDREG)+SumCDIV(CGOGSQ(1,CURIYR,2),INDREG)
                ENDIF
             ENDIF
          ENDDO
! END SUSAN

!  ESTABLISH TOTAL ENERGY CONSUMPTION BY INTERMEDIATE FUEL.

          DO IFn=1,7
             ENPIQTYT(IFn,5)=ENPIQTYT(IFn,5)+QTYINTR(IFn,INDREG)
             ENPIQTYT(IFn,INDREG)=QTYINTR(IFn,INDREG)
          ENDDO

!  ESTABLISH TOTAL ENERGY CONSUMPTION BY RENEWABLE FUEL.

          DO IFn=1,9
             ENPRQTYT(IFn,5) = ENPRQTYT(IFn,5)+QTYRENW(IFn,INDREG)
             ENPRQTYT(IFn,INDREG) = QTYRENW(IFn,INDREG)
          ENDDO

!  ESTABLISH BUILDING COMPONENT CONSUMPTION BY FUEL.

          BLDENCONS( 1,5) = BLDENCONS( 1,5)+ENBQTY(1,1)  ! lighting
          BLDENCONS( 2,5) = BLDENCONS( 2,5)+ENBQTY(2,1)  ! hvac el
          BLDENCONS( 3,5) = BLDENCONS( 3,5)+ENBQTY(2,2)  ! hvac ng
          BLDENCONS( 4,5) = BLDENCONS( 4,5)+ENBQTY(2,3)  ! hvac stm
          BLDENCONS( 5,5) = BLDENCONS( 5,5)+ENBQTY(3,1)  ! fac support, el
          BLDENCONS( 6,5) = BLDENCONS( 6,5)+ENBQTY(3,2)  ! fac support, ng
          BLDENCONS( 7,5) = BLDENCONS( 7,5)+ENBQTY(3,4)  ! fac support, df
          BLDENCONS( 8,5) = BLDENCONS( 8,5)+ENBQTY(3,5)  ! fac support, lpg
          BLDENCONS( 9,5) = BLDENCONS( 9,5)+ENBQTY(4,1)  ! onsite tran, el
          BLDENCONS(10,5) = BLDENCONS(10,5)+ENBQTY(4,2)  ! onsite tran, ng
          BLDENCONS(11,5) = BLDENCONS(11,5)+ENBQTY(4,4)  ! onsite tran, ng
          BLDENCONS(12,5) = BLDENCONS(12,5)+ENBQTY(4,5)  ! onsite tran, ng

          BLDENCONS( 1,INDREG) = ENBQTY(1,1)
          BLDENCONS( 2,INDREG) = ENBQTY(2,1)
          BLDENCONS( 3,INDREG) = ENBQTY(2,2)
          BLDENCONS( 4,INDREG) = ENBQTY(2,3)
          BLDENCONS( 5,INDREG) = ENBQTY(3,1)  ! fac support, el
          BLDENCONS( 6,INDREG) = ENBQTY(3,2)  ! fac support, ng
          BLDENCONS( 7,INDREG) = ENBQTY(3,4)  ! fac support, df
          BLDENCONS( 8,INDREG) = ENBQTY(3,5)  ! fac support, lpg
          BLDENCONS( 9,INDREG) = ENBQTY(4,1)  ! onsite tran, el
          BLDENCONS(10,INDREG) = ENBQTY(4,2)  ! onsite tran, ng
          BLDENCONS(11,INDREG) = ENBQTY(4,4)  ! onsite tran, df
          BLDENCONS(12,INDREG) = ENBQTY(4,5)  ! onsite tran, lpg

!  ESTABLISH PROCESS AND ASSEMBLY (p/a) COMPONENT CONSUMPTION BY FUEL.

          gfmax=0  ! count for number of fuels used in each sub group of steps
          gfloc=0  ! fuel id numbers for each sub group of steps
          istot=MPASTP+1
          ifmax(istot)=0
          DO IS=1,MPASTP
            DO IFn=1,IFMAX(IS)
              IFF = IFLOC(IFn,IS)
! build list of fuels used to total p/a energy across steps by fuel
              if2=0
              do i=1,ifmax(istot)
                if(ifloc(i,istot).eq.iff) then
                  if2=i
                  exit
                endif
              enddo
              if(if2.eq.0) then
                if2=ifmax(istot)+1
                ifmax(istot)=if2
                ifloc(if2,istot)=iff
              endif



              if(iff.ne.36)then  ! do not add in coke consumption
			    if ((inddir.eq.12).and.(curcalyr.gt.ibyr2)) then
			      if (IFn.le.6) then
                    ENPQTYT(STfuelmap(IFn),IS,5)     =ENPQTYT(STfuelmap(IFn),IS,5)+ENPQTY(4,STfuelmap(IFn),IS)
                    ENPQTYT(STfuelmap(IFn),IS,indreg)=ENPQTY(4,STfuelmap(IFn),IS)
				    ENPQTYT(STfuelmap(IFn),IStot,5)     =ENPQTYT(STfuelmap(IFn),IStot,5)+ENPQTY(4,STfuelmap(IFn),IS)
                    ENPQTYT(STfuelmap(IFn),IStot,indreg)=ENPQTYT(STfuelmap(IFn),IStot,indreg)+ENPQTY(4,STfuelmap(IFn),IS)
			      endif
			    else
			      ENPQTYT(IFn,IS,5)     =ENPQTYT(IFn,IS,5)+ENPQTY(4,IFn,IS)
                  ENPQTYT(IFn,IS,indreg)=ENPQTY(4,IFn,IS)
                  ENPQTYT(IF2,IStot,5)     =ENPQTYT(IF2,IStot,5)+ENPQTY(4,IFn,IS)
                  ENPQTYT(IF2,IStot,indreg)=ENPQTYT(IF2,IStot,indreg)+ENPQTY(4,IFn,IS)
			    endif
              endif
! compile fuel use by reporting group
! for industries like chemical having several reporting steps,
              if(NumRptGrps.gt.0) then
                 do g=1,NumRptGrps
                   igstot=NumRptGrpSteps(g)+1 ! used for totaling of fuel across steps in a group
                   do igs=1,NumRptGrpSteps(g)
                     if (RptGrpSteps(g,igs).eq.is) then
! build list of fuels used with each group
                       igf=0
                       do i=1,gfmax(g,igs)
                         if(gfloc(i,g,igs).eq.iff) then
                           igf=i
                           exit
                         endif
                       enddo
                       if(igf.eq.0) then
                          igf=gfmax(g,igs)+1
                          gfmax(g,igs)=igf
                          gfloc(igf,g,igs)=iff
                       endif
 ! build list of fuels used for the total of each group
                      igf2=0
                       do i=1,gfmax(g,igstot)
                         if(gfloc(i,g,igstot).eq.iff) then
                           igf2=i
                           exit
                         endif
                       enddo
                       if(igf2.eq.0) then
                          igf2=gfmax(g,igstot)+1
                          gfmax(g,igstot)=igf2
                          gfloc(igf2,g,igstot)=iff
                       endif
! assign fuel by group, fuel, step.  sum across regions; create group fuel total (igf2)
                       ENPQTYsub(g,IGF,    IGS,5)     =ENPQTYsub(g, IGF,   IGS,5)     +ENPQTY(4,IFn,IS)
                       ENPQTYsub(g,IGF,    IGS,indreg)=ENPQTYsub(g, IGF,   IGS,indreg)+ENPQTY(4,IFn,IS)
                       ENPQTYsub(g,IGF2,igstot,5)     =ENPQTYsub(g,IGF2,igstot,5)     +ENPQTY(4,IFn,IS)
                       ENPQTYsub(g,IGF2,igstot,indreg)=ENPQTYsub(g,IGF2,igstot,indreg)+ENPQTY(4,IFn,IS)
                     endif
                   enddo
                 enddo
              endif
            ENDDO
          ENDDO

          DO IS=1,MPASTP+1
            DO IFn=1,IFMAX(IS)+1
              IF(ENPQTYT(IFn,IS,indreg).ne.0.0) THEN
                IFUELpa(is,IFn) = 1
              ENDIF
            ENDDO
          ENDDO


!  ESTABLISH BOILER/STEAM/COGENERATION CONSUMPTION BY FUEL.

!  PURCHASED FUELS:

! SUSAN  changed Aug 6, 2013 ... corrected addition of cogen fuel for national
! SUSAN  changed Aug 8, 2013 ... corrected logic. IFn is NOT the fuel as was coded.  IFF is the fuel code.
! Logic here is kind of hard to follow.  IFSLOC is a holder array for fuel codes.  ENSQTY is defined from 1 to IFSMAX.
! but this index is not the fuel codes.  We need to use IFSLOC to locate the fuel code. Changed code to reflect the correct fuel code.

          DO IFn=1,IFSMAX   
		                    
             IFF=IFSLOC(IFn)
             ENSQTYT(IFF,5) = ENSQTYT(IFF,5)+ENSQTY(IFn)
		     if ((inddir.eq.8).or. (inddir.eq.12)) then
               if (curcalyr.gt.ibyr2) ENSQTYT(IFF,INDREG) = ENSQTY(IFn)*SteamRgShr(inddir,indreg)
			 endif
             IF (INDNUM .eq. 4) THEN          ! For O&G mine need to add cogen calc from OGS
                IF (IFF .eq. 4) THEN           ! Natural gas

                   ENSQTYT(IFF,5)=ENSQTYT(IFF,5)+SumCDIV(CGOGSQ(1,CURIYR,3),INDREG)
                   ENSQTYT(IFF,INDREG)=ENSQTYT(IFF,INDREG)+SumCDIV(CGOGSQ(1,CURIYR,3),INDREG)
                ELSE IF (IFF .eq. 7) THEN      ! Coal

                   ENSQTYT(IFF,5)=ENSQTYT(IFF,5)+SumCDIV(CGOGSQ(1,CURIYR,1),INDREG)
                   ENSQTYT(IFF,INDREG)=ENSQTYT(IFF,INDREG)+SumCDIV(CGOGSQ(1,CURIYR,1),INDREG)
                ELSE IF (IFF .eq. 10) THEN     ! Residual Fuel

                   ENSQTYT(IFF,5)=ENSQTYT(IFF,5)+SumCDIV(CGOGSQ(1,CURIYR,2),INDREG)
                   ENSQTYT(IFF,INDREG)=ENSQTYT(IFF,INDREG)+SumCDIV(CGOGSQ(1,CURIYR,2),INDREG)
                ENDIF
             ENDIF
          ENDDO
! END SUSAN FIX

!  BYPRODUCT FUELS:
          DO IFn=1,8
            BYPQTYTR(IFn,5)=BYPQTYTR(IFn,5)+BYPBSCR(IFn)
            BYPQTYTR(IFn,INDREG)=BYPBSCR(IFn)
          ENDDO

          DO IFn=1,6
            BYPQTYTI(IFn,5)=BYPQTYTI(IFn,5)+BYPBSCI(IFn)
            BYPQTYTI(IFn,INDREG)=BYPBSCI(IFn)
          ENDDO

!** ESTABLISH TOTAL STEAM DEMAND.

          STEMCURT(5) = STEMCURT(5)+STEMCUR
          STEMCURT(INDREG) = STEMCUR

          COGSTEAMT(5)=COGSTEAMT(5)+COGSTEAM
          COGSTEAMT(INDREG)=COGSTEAM

          NONCOGSTEAMT(5)=NONCOGSTEAMT(5)+NONCOGSTEAM
          NONCOGSTEAMT(INDREG)=NONCOGSTEAM

          BIOSTEAMT(5)=BIOSTEAMT(5)+BIOSTEAM
          BIOSTEAMT(INDREG)=BIOSTEAM

          NONCOGFOSSTEAMT(5)=NONCOGFOSSTEAMT(5)+NONCOGFOSSTEAM
          NONCOGFOSSTEAMT(INDREG)=NONCOGFOSSTEAM

!  ESTABLISH ELECTRICITY GENERATED FOR OWN USE.

          ELOWNT(5) = ELOWNT(5)+ELOWN
          ELOWNT(INDREG) = ELOWNT(INDREG)+ELOWN

!  ESTABLISH ELECTRICITY GENERATED FOR SALES TO THE GRID.

          ELSALET(5) = ELSALET(5)+ELSALE
          ELSALET(INDREG) = ELSALET(INDREG)+ELSALE

!  ESTABLISH FUEL CONSUMPTION FOR COGENERATION, generation, and capacity

! SUSAN  changed Aug 6, 2013 ... corrected addition of cogen fuel for national

          DO IFn=1,4
            GENFUELT(IFn,5)=GENFUELT(IFn,5)+ GENFUEL(IFn)
            GENFUELT(IFn,INDREG)=GENFUEL(IFn)
            IF (INDNUM .eq. 4 .AND. IFn .eq. 3) THEN          ! For O&G mine need to replace cogen calc from OGS
               GENFUELT(IFn,5)=SumCDIV(CGOGSQ(1,CURIYR,IFn),INDREG)
               GENFUELT(IFn,INDREG)=SumCDIV(CGOGSQ(1,CURIYR,IFn),INDREG)
            ENDIF

            RPTGENT(IFn,5)=RPTGENT(IFn,5)+ RPTGEN(IFn)
            RPTGENT(IFn,INDREG)=RPTGEN(IFn)
            IF (INDNUM .eq. 4 .AND. IFn .eq. 3) THEN          ! For O&G mine need to replace cogen calc from OGS
               RPTGENT(IFn,5)=SumCDIV(CGOGSQ(1,CURIYR,IFn),INDREG)/3.412
               RPTGENT(IFn,INDREG)=SumCDIV(CGOGSQ(1,CURIYR,IFn),INDREG)/3.412
            ENDIF
            RPTCAPT(IFn,5)=RPTCAPT(IFn,5)+ RPTCAP(IFn)
            RPTCAPT(IFn,INDREG)=RPTCAP(IFn)
		
            
          ENDDO

! END SUSAN

!  Fill in the values for CO2 process emissions for clinker and lime
          DO IFn=1,5
             CLINKCO2(IFn) = co2_clink(curiyr,IFn)/10.0**6  ! convert to million metric tons
             LIMECO2(IFn)  = co2_lime(curiyr,IFn)/10.0**6   ! convert to million metric tons
          ENDDO

! ESTABLISH TOTAL BOILER FUEL BY SIZE
          DO indcnt=1,indmax
             DO ifn=1,10
                DO bsize=1,2
                   FOSFUELSTEAMSIZE(indcnt,ifn,bsize,5)=FOSFUELSTEAMSIZE(indcnt,ifn,bsize,5)+&
                                                          FOSFUELSTEAMSIZE(indcnt,ifn,bsize,indreg)
		!		if (ifn.eq.6) write(777,*) 'Fossil fuel steam size electricity & bsize', &
		!		  indcnt, indreg,  FOSFUELSTEAMSIZE(indcnt,ifn,bsize,indreg)
                ENDDO
             ENDDO
          ENDDO

        ENDDO      !  END OF INPUT LOOP OVER REGIONS

!**********************************************************
!  THIS IS A SPECIAL SECTION FOR REFINERY DATA.
!**********************************************************

        IF(INDNUM.EQ.INDMAX) THEN
 !  REFINING CONSUMPTION
!         refin(1,1:11)=QEPRF(1:11,curiyr)
!         refin(2,1:11)=QENRF(1:11,curiyr)
          refin(3,1:11)=QELRF(1:11,curiyr)+qELeth(curiyr,1:11)
		  refin(4,1:11)=QGFRF(1:11,curiyr)
          refin(5,1:11)=QGIRF(1:11,curiyr)+qNGeth(curiyr,1:11)+qGTLrf(1:11,curiyr)
          refin(6,1:11)=QNGRF(1:11,curiyr)
          refin(7,1:11)=QCLRF(1:11,curiyr)+qCLeth(curiyr,1:11)
          refin(8,1:11)=QRLRF(1:11,curiyr)
          refin(9,1:11)=QDSRF(1:11,curiyr)
          refin(10,1:11)=QLGRF(1:11,curiyr)
          refin(11,1:11)=QSGRF(1:11,curiyr)
          refin(12,1:11)=QPCRF(1:11,curiyr)+qCCRF(1:11,curiyr)
          refin(13,1:11)=QOTRF(1:11,curiyr)
!  NATURAL GAS LEASE AND PLANT CONSUMPTION and liquefaction for exporting
!         refin(14,1:11)=QLPIN(1:11,curiyr)+QNGLQ(1:11,curiyr)

          do ifl=1,13
            do indreg=1,4
! Establish the range of census divisions for the current region using an innovative approach
              L=indreg*2+indreg/4-1  ! obviously, L will be 1,3,5, and 8 for indreg=1..4
              M=indreg*2+indreg/3    !            M will be 2,4,7, and 9 for indreg=1..4
              do icd=L,M
                refine(ifl,indreg)=refine(ifl,indreg)+refin(ifl,icd)
                refine(ifl,5)=refine(ifl,5)+refin(ifl,icd)
              enddo
            enddo
          enddo
        endif

       do indreg=regstart,regstop
         if (indnum.ge.1.and.indnum.le.6) then
           write(line,'(a,i2,a,a)') 'Table ',indnum, &
                '.  Energy and Macroeconomic Profile for Non-Manufacturing Industry - ', &
                  fullname(indnum)
         else
            write(line,'(a,i2,a,a)') 'Table ',indnum, &
                '.  Energy and Macroeconomic Profile for Manufacturing Industry - ', &
                  fullname(indnum)
         endif
         IROW = irow+2
         if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
         IROW = IROW + 1
         LINE = ' Census Region: '//regname(indreg)
         if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
         IROW = IROW + 1

         CALL ckint(I15,IROW,icol,curcalyr,0)  !!!!!TDTDTD


!**********************************************************
!  WRITE MACROECONOMIC SECTION.
!**********************************************************

         IROW = IROW + 2
         LINE = 'Macroeconomic Indicators'
         if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)

         Line =  '  Value of Output (billion 2005$)'
         if(OUTPUTACT(indreg).gt.0.) then
            Line =  '  Value of Output (billion 2005$)'
            IROW = IROW + 1
            if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
            CALL cknum(I15,IROW,icol,dble(OUTPUTACT(indreg)),2,4)
            Line = '  Output, w/Subsector Energy Weighting (billion 2005$)'
         endif
         IROW = IROW + 1
         if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
         CALL cknum(I15,IROW,icol,dble(outputval(indreg)),2,4)

         if(outputqty(indreg).gt.0.) then
           Line = '  Physical Output (million tonnes)'
           IROW = IROW + 1
           if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
           CALL cknum(I15,IROW,icol,dble(OUTPUTQTY(indreg)),2,4)
         endif

         if(employ(indreg).gt.0.) then
           Line =  '  Employment (thousand)'
           IROW = IROW + 1
           if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
           CALL cknum(I15,IROW,icol,dble(employ(indreg)),2,4)
         endif

!**********************************************************
!  WRITE TOTAL ENERGY CONSUMPTION BY FUEL SECTION.
!**********************************************************

         if (inddir.eq.12) then
		   LINE =  'Total Energy Consumption (Trillion BTU) (benchmarked to MECS)'
		 else
		   LINE =  'Total Energy Consumption (Trillion BTU)'
		 endif
         IROW = IROW + 2
         if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)

         TOTAL = 0.


         DO IF=1,22
       
            IF (ENPMQTYT(IF,indreg).gt.0.0001 .or.printfuel(inddir,if).eq.1 ) THEN
               LINE =  '  ' // FUELNAME(IF)
               IROW = IROW + 1
               if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
               CALL cknum(I15,IROW,Icol,dble(ENPMQTYT(IF,indreg)),2,16)
               TOTAL = TOTAL + ENPMQTYT(IF,indreg)
            ENDIF
            IF (IF.EQ.6)THEN
               LINE = '    Natural Gas Total'
               IROW = IROW + 1
               if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
               WORK = ENPMQTYT(3,indreg)+ENPMQTYT(4,indreg) &
                     +ENPMQTYT(5,indreg)+ENPMQTYT(6,indreg)
               CALL cknum(I15,IROW,icol,DBLE(WORK),2,16)
            ENDIF
         ENDDO

         DO IF=1,8
            IF (ENPRQTYT(IF,indreg).gt.0.0001.or.printfuel(inddir,if+40).eq.1) THEN
               LINE =  '  ' // FUELNAME(IF+40)
               IROW = IROW + 1
               if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
               CALL cknum(I15,IROW,ICOL,dble(ENPRQTYT(IF,indreg)),2,8)
               TOTAL = TOTAL + ENPRQTYT(IF,indreg)
            ENDIF
         ENDDO

		 if (inddir.ne.12) then !don't report for steel
         DO IF=2,3         ! only do coke oven gas and bf gas
            IF (ENPIQTYT(IF,indreg).gt.0.0001.or.printfuel(inddir,if+30).eq.1) THEN
               LINE =  '  ' // FUELNAME(IF+30)
               IROW = IROW + 1
               if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
               CALL cknum(I15,IROW,ICOL,dble(ENPIQTYT(IF,indreg)),2,8)
               TOTAL = TOTAL + ENPIQTYT(IF,indreg)
              ENDIF
         ENDDO
		 endif

         Line =  '          Total'
         IROW = IROW + 1
         if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
         CALL cknum(I15,IROW,icol,dble(total),2,8)

!**********************************************************
!  WRITE UNIT ENERGY CONSUMPTION BY FUEL.
!**********************************************************

         IROW = IROW + 2
         IF(IDVAL.EQ.1) THEN
           LINE =  'Unit Energy Consumption (MMBTU/TON)'
         ELSE
           LINE =  'Unit Energy Consumption (Thousand BTU/2005$)'
         ENDIF
         if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)

         DO IF=1,22
            IF (ENPMQTYT(IF,indreg).gt.0.0001.or.printfuel(inddir,if).eq.1  ) THEN
               LINE =  '  ' // FUELNAME(IF)
               work=0.
               IF(IDVAL.EQ.1) THEN
                 IF (OUTPUTQTY(indreg) .ne. 0.) WORK = ENPMQTYT(IF,indreg)/OUTPUTQTY(indreg)
               else
                 IF (OUTPUTVAL(indreg) .ne. 0.) WORK = ENPMQTYT(IF,indreg)/OUTPUTVAL(indreg)
                 IF (OUTPUTACT(indreg) .ne. 0.) WORK = ENPMQTYT(IF,indreg)/OUTPUTACT(indreg)
               endif
               IROW = IROW + 1
               if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
               CALL cknum(I15,IROW,ICOL,dble(work),2,4)
            ENDIF
         ENDDO

         DO IF=1,8
           IF(ENPRQTYT(IF,indreg).gt.0.0001.or.printfuel(inddir,if+40).eq.1) THEN
             work=0.
             LINE =  '  ' // FUELNAME(IF+40)
             IF(IDVAL.EQ.1) THEN
               IF (OUTPUTQTY(indreg) .ne. 0.) work=ENPRQTYT(IF,indreg)/OUTPUTQTY(indreg)
             else
               IF (OUTPUTVAL(indreg) .ne. 0.) WORK = ENPRQTYT(IF,indreg)/OUTPUTVAL(indreg)
               IF (OUTPUTACT(indreg) .ne. 0.) WORK = ENPRQTYT(IF,indreg)/OUTPUTACT(indreg)
             endif
             IROW = IROW + 1
             if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
             CALL cknum(I15,IROW,icol,dble(work),2,4)
           ENDIF
         ENDDO
         if (inddir.ne.12) then !don't report for steel
         DO IF=2,3         ! only do coke oven gas and bf gas
           IF (ENPIQTYT(IF,indreg).gt.0.0001.or.printfuel(inddir,if+30).eq.1) THEN
             LINE =  '  ' // FUELNAME(IF+30)
             work=0.
             IF(IDVAL.EQ.1) THEN
               if(OUTPUTQTY(indreg).gt.0.001) WORK = ENPIQTYT(IF,indreg)/OUTPUTQTY(indreg)
             else
               IF(OUTPUTVAL(indreg).gt.0.001) WORK = ENPIQTYT(IF,indreg)/OUTPUTVAL(indreg)
               IF(OUTPUTACT(indreg).gt.0.001) WORK = ENPIQTYT(IF,indreg)/OUTPUTACT(indreg)
             ENDIF
             IROW = IROW + 1
             if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
             CALL cknum(I15,IROW,ICOL,dble(work),2,4)
           ENDIF
         ENDDO
		 endif
         total=0.
!**********************************************************
!  WRITE ENERGY CONSUMPTION IN THE BUILDINGS COMPONENT.
!**********************************************************
         if(indnum.gt.6) then ! non-mfg has no buildings component

           LINE = 'BUILDINGS COMPONENT'
           IROW = IROW + 2
           if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
           total=0.

           TOTAL=sum(BLDENCONS(1:12,INDREG))

           LINE = 'Energy Consumption for Buildings (Trillion BTU)'
           IROW = IROW + 2
           if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)

           do i=1,12
             LINE=BLDNAME(I)
             IROW = IROW + 1
             if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
             CALL cknum(I15,IROW,ICOL,dble(BLDENCONS(I,indreg)),2,4)
           enddo
           Line =  '          Total Building Energy Use'

           IROW = IROW + 1
           if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)

           CALL cknum(I15,IROW,ICOL,DBLE(total),2,4)
           IF (BLDENCONS(4,indreg) .NE. 0.)  THEN
             Line =  '          Total less Steam'
             IROW = IROW + 1
             if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
             TOTAL = TOTAL - BLDENCONS(4,indreg)
             CALL cknum(I15,IROW,ICOL,DBLE(total),2,4)
           ENDIF
         endif  ! end of the non-mfg exclude

!**********************************************************
!  WRITE VARIOUS VARIABLES IN THE PA COMPONENT.
!**********************************************************
         total=0.
         LINE = 'PROCESS AND ASSEMBLY COMPONENT'
         IROW = IROW + 2
         if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)

!**********************************************************
!      WRITE PRODUCT THROUGHPUT IN THE PA COMPONENT.
!      APPLICABLE ONLY TO ENERGY INTENSIVE INDUSTRIES.
!**********************************************************

         IF (inddir.gt.6) THEN ! DO ENERGY INTENSIVE
           IF(IDVAL.EQ.1) THEN
             LINE = 'Product Throughput (million tonnes)'
           ELSE
             LINE = 'Product Throughput (Billion 2005$)'
           ENDIF
           IROW = IROW + 2
           if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
           DO ISTEP=1,MPASTP
             LINE = '  ' // INDSTEPNAME(ISTEP)
             IROW = IROW + 1
             if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
             CALL cknum(I15,IROW,icol,dble(OUTPUT(ISTEP,indreg)),2,4)
           ENDDO
         ENDIF                !  END OF SKIP FOR NON-ENERGY INTENSIVE

!**********************************************************
!  WRITE ENERGY CONSUMPTION FOR EACH PROCESS STEP.
!**********************************************************

         LINE='Energy Consumption for Process and Assembly (Trillion BTU)'

         IROW = IROW + 2
         if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)

         if(NumRptGrps.eq.0) then ! standard report
           numstep=mpastp
           if(inddir.le.2.OR.inddir.ge.6) numstep=numstep+1  ! do not provide total p/a for mining or construction
           DO ISTEP=1,numstep
             total=0.
             IF(inddir.le.2.OR.INDDIR.ge.6) THEN
               LINE = '  ' // INDSTEPNAME(ISTEP)
               IROW = IROW + 1
               if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
             ENDIF

			 ! hardwire for steel
            if (inddir.eq.12) then
		          IFUELpa=0
			      IFUELpa(1:3,1:4)=1 !HOT, Cold and Continuous
				  IFUELpa(4,1:5)=1 !BOF
				  IFUELpa(5,1:2)=1 !EAF
				  IFUELpa(6,1:6)=1 !DRI
				  IFUELpa(7,1:6)=1 !Coke
				  IFUELpa(8,1:6)=1 !Total
		     endif

                 
            if (inddir.eq.18) then ! Hardcode for Electrical Equipment & Appliances
                  DO IS=1,MPASTP+1
                    DO IFn=1,IFMAX(IS)+1
                        IFUELpa(is,IFn) = 1
                    ENDDO
                  ENDDO
            endif   

            
            if (inddir.eq.21) then ! Hardcode for Balance of Manufacturing
                  DO IS=1,MPASTP+1
                    DO IFn=1,IFMAX(IS)+1
                        IFUELpa(is,IFn) = 1
                    ENDDO
                  ENDDO
            endif                              

            
            DO IF=1,IFMAX(ISTEP)

               IF (IFUELpa(istep,IF) .EQ. 1.OR.inddir.le.2.OR. &
            inddir.eq.6.OR.inddir.eq.11.or.inddir.eq.13.or.inddir.eq.10) THEN
			     LINE = '    ' // FUELNAME(IFLOC(IF,ISTEP))
                 IROW = IROW + 1
                 if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
				 if (CURCALYR.eq.ibyr2) then
				   CALL cknum(I15,IROW,icol,dble(ENPQTYT(IF,ISTEP,indreg)),2,4)
				   TOTAL = TOTAL + ENPQTYT(IF,ISTEP,indreg)
				 else
				 if ((inddir.eq.12).and.(if.gt.3)) then
				    CALL cknum(I15,IROW,icol,dble(ENPQTYT(STfuelmap(if),ISTEP,indreg)),2,4)
					TOTAL = TOTAL + ENPQTYT(STfuelmap(if),ISTEP,indreg)
				else
                   CALL cknum(I15,IROW,icol,dble(ENPQTYT(IF,ISTEP,indreg)),2,4)
				   TOTAL = TOTAL + ENPQTYT(IF,ISTEP,indreg)
				 endif
                 endif
               endif
              ENDDO
           ENDDO

           Line =  '          Total'
           IROW = IROW + 1
           if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)

           CALL cknum(I15,IROW,Icol,dble(total),2,4)

         else    ! Print P/A by Reporting Group (chemicals)
!      INTEGER NumRptGrps                  ! Number of Reporting SubGroups for Process Assembly Energy reporting (used in Chemicals for Subindustry rpt), max:12, min:0
!      INTEGER NumRptGrpSteps(12)          ! Number of steps in each reporting SubGroup for P/A
!      INTEGER RptGrpSteps(12,maxstep)     ! Identification of step numbers included in each reporting subgroup in P/A
!      Character*12 RptGrpNames(12)        ! Reporting group names
!      Character*12 RptGrpSName(12,maxstep)! Reporting labels for step names


           do g=1,NumRptGrps
             irow=irow+2
             line='Process/Assembly Subset:  '//RptGrpNames(g)
             if(once(vers)) call ckstr(i15,irow,1,line,1,0,1)
             RptGrpSName(g,NumRptGrpSteps(g)+1)='Total '//RptGrpNames(g)

             Do igs=1,NumRptGrpSteps(g)+1
               IROW = IROW + 1
               line='  '//RptGrpSName(g,igs)
               if(once(vers))CALL ckstr(I15,IROW,1,line,1,0,1)
               total=0.
               DO i=1,GFMAX(g,igs)
                 iff=gfloc(i,g,igs)
                 LINE = '    ' // FUELNAME(iff)
                 IROW = IROW + 1
                 if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
                 CALL cknum(I15,IROW,icol,dble(ENPQTYsub(g,i,igs,indreg)),2,4)
                 TOTAL = TOTAL + ENPQTYsub(g,i,igs,indreg)
               ENDDO
               if(gfmax(g,igs).gt.1) then
                 Line =  '          Total'
                 IROW = IROW + 1
                 if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
                 CALL cknum(I15,IROW,Icol,dble(total),2,4)
               endif
             enddo
          enddo
! write out total of process/assembly
          istep=mpastp+1
          LINE = RptGrpNames(NumRptGrps+1)
          IROW = IROW + 2
          if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
          total=0.
           DO IF=1,IFMAX(ISTEP)
             IF (IFUELpa(istep,IF) .EQ. 1) THEN
               LINE = '  ' // FUELNAME(IFLOC(IF,ISTEP))
               IROW = IROW + 1
               if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
               CALL cknum(I15,IROW,icol,dble(ENPQTYT(IF,ISTEP,indreg)),2,4)
               TOTAL = TOTAL + ENPQTYT(IF,ISTEP,indreg)
             endif
            ENDDO
           Line =  '      Total'
           IROW = IROW + 1
           if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)

           CALL cknum(I15,IROW,Icol,dble(total),2,4)

        endif
!**********************************************************
!  WRITE ENERGY CONSUMPTION FOR BSC COMPONENT.
!**********************************************************
 !if (inddir.ne.12) then   !no BSC for steel; included in PA
         LINE = 'BOILER/STEAM/COGENERATION COMPONENT'
         IROW = IROW + 2
         if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)

         LINE = 'Energy Consumption for Boiler'// &
               '/Steam/Cogeneration (Trillion BTU)'
         IROW = IROW + 2
         if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
         total=0.
         DO IF=1,22
           IF((ENSQTYT(IF,indreg).gt.0.001).or.ANY(cfuel.eq.if)) then   ! currently (12/22) for indices 1,4,7,10,11,12,16,22
             LINE = '  ' // FUELNAME(IF)
             IROW = IROW + 1
             if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
             CALL cknum(I15,IROW,icol,dble(ENSQTYT(IF,indreg)),0,4)    ! POT_2050NDIGIT  2 to 0
			 TOTAL = TOTAL + ENSQTYT(IF,indreg)
           ENDIF
         ENDDO
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!this needs to go somewhere else BYPBSCR(2) feeds this variable
!if (inddir.eq.8) then
!BYPQTYTR(2,1:4)=PP_STEAM_Cogen(6)*.25
!BYPQTYTR(2,5)=PP_STEAM_Cogen(6)
!endif


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         DO IF=1,8
           IF(BYPQTYTR(IF,indreg).gt.0.001) THEN
             LINE = '  ' // FUELNAME(IF+40)
             IROW = IROW + 1
             if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
             CALL cknum(I15,IROW,ICOL,dble(BYPQTYTR(IF,indreg)),0,4)                 ! POT_2050NDIGIT  2 to 0
             TOTAL = TOTAL+ BYPQTYTR(IF,indreg)
           ENDIF
         ENDDO
 	     if (inddir.ne.12) then !don't report for steel
         DO IF=2,5    ! omit steam and coke
            IF(BYPQTYTI(IF,indreg).gt.0.001) THEN
              LINE = '  ' // FUELNAME(IF+30)
              IROW = IROW + 1
              if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
              CALL cknum(I15,IROW,icol,dble(BYPQTYTI(IF,indreg)),0,4)                ! POT_2050NDIGIT  2 to 0
              TOTAL= TOTAL + BYPQTYTI(IF,indreg)
            ENDIF
         ENDDO
		 endif

         Line =  '          Total'
         IROW = IROW + 1
         if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
         CALL cknum(I15,IROW,ICOL,dble(total),0,4)                                    ! POT_2050NDIGIT  2 to 0

         LINE = 'Unbenchmarked Energy Consumption for Boilers'// &
               'by size (Trillion BTU)'
         IROW = IROW + 2
         LINE = 'Boilers 10MMBTU/HR and Under'
         IROW = IROW + 1
         if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
         total=0.
         DO IFn=1,10
           LINE = '  ' // BFUELNAME(IFn)
           IROW = IROW + 1
           if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
           CALL cknum(I15,IROW,icol,dble(FosFuelSteamSize(inddir,IFn,1,indreg)),0,4)  ! POT_2050NDIGIT  2 to 0
           TOTAL = TOTAL + FosFuelSteamSize(inddir,IFn,1,indreg)
         ENDDO

         LINE = 'Boilers Over 10MMBTU/HR'
         IROW = IROW + 1
         if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
         total=0.
         DO IFn=1,10
           LINE = '  ' // BFUELNAME(IFn)
           IROW = IROW + 1
           if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
           CALL cknum(I15,IROW,icol,dble(FosFuelSteamSize(inddir,IFn,2,indreg)),0,4)   ! POT_2050NDIGIT  2 to 0
           TOTAL = TOTAL + FosFuelSteamSize(inddir,IFn,2,indreg)
         ENDDO

!**********************************************************
!  WRITE STEAM GENERATION.
!**********************************************************

         LINE = 'Total Steam Generation (Tr. BTU)'
         IROW = IROW + 2
         if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
         CALL cknum(I15,IROW,icol,dble(STEMCURT(indreg)),0,4)         ! POT_2050NDIGIT  2 to 0

         LINE = '  CHP Steam Generation'
         IROW = IROW + 1
         if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
         CALL cknum(I15,IROW,icol,dble(COGSTEAMT(indreg)),0,4)        ! POT_2050NDIGIT  2 to 0

         LINE = '  Total Non-CHP Steam Generation'
         IROW = IROW + 1
         if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
         CALL cknum(I15,IROW,icol,dble(NONCOGSTEAMT(indreg)),0,4)     ! POT_2050NDIGIT  2 to 0

         LINE = '      Non-CHP Fossil Steam Generation'
         IROW = IROW + 1
         if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
         CALL cknum(I15,IROW,icol,dble(NONCOGFOSSTEAMT(indreg)),0,4)  ! POT_2050NDIGIT  2 to 0

         LINE = '      Non-CHP Biomass Steam Generation'
         IROW = IROW + 1
         if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
         CALL cknum(I15,IROW,icol,dble(BIOSTEAMT(indreg)),0,4)        ! POT_2050NDIGIT  2 to 0

!**********************************************************
!  WRITE ELECTRICITY/CHP  VARIABLES.
!**********************************************************

         LINE = 'ELECTRICITY CAPACITY, GENERATION, AND FUEL USE'
         IROW = IROW + 2
         if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)

         Line = '  Generating Capacity (MW)'
         total=0.
         IROW = IROW + 1
         if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
          do if=1,4
           i=genorder(if)
           IROW = IROW + 1
           Line = genname1(if)
           if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
           CALL cknum(I15,IROW,icol,dble(RPTCAPT(i,indreg)),0,4)   ! POT_2050NDIGIT  2 to 0
           TOTAL = TOTAL + RPTCAPT(i,indreg)
         enddo
         Line =  '          Total'
         IROW = IROW + 1
         if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
         CALL cknum(I15,IROW,ICOL,dble(total),0,4)                  ! POT_2050NDIGIT  2 to 0

         Line = '  Generation (GWH)'
         Total=0.
         IROW = IROW + 1
         if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
          do if=1,4
           i=genorder(if)
           IROW = IROW + 1
           Line = genname2(if)
           if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
           CALL cknum(I15,IROW,icol,dble(RPTGENT(i,indreg)),0,4)    ! POT_2050NDIGIT  2 to 0
           TOTAL = TOTAL + RPTGENT(i,indreg)
         enddo
         Line =  '          Total'
         IROW = IROW + 1
         if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
         CALL cknum(I15,IROW,ICOL,dble(total),0,4)                  ! POT_2050NDIGIT  2 to 0

         Line = '    Own Use'
         IROW = IROW + 2
         if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
         CALL cknum(I15,IROW,icol,dble(ELOWNT(indreg)),0,4)          ! POT_2050NDIGIT  2 to 0

         Line = '    Grid Sales'
         IROW = IROW + 1
         if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
         CALL cknum(I15,IROW,icol,dble(ELSALET(indreg)),0,4)         ! POT_2050NDIGIT  2 to 0

         Line = '    Fuel Consumption (Trillion Btu)'
         TOTAL = 0.
         IROW = IROW + 2
         if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
         do if=1,4
           i=genorder(if)
           IROW = IROW + 1
           Line = genname3(if)
           if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
           CALL cknum(I15,IROW,icol,dble(GENFUELT(i,indreg)),0,4)     ! POT_2050NDIGIT  2 to 0
           TOTAL = TOTAL + GENFUELT(i,indreg)
         enddo
         Line =  '          Total'
         IROW = IROW + 1
         if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
         CALL cknum(I15,IROW,ICOL,dble(total),0,4)                    ! POT_2050NDIGIT  2 to 0
!endif  !endif for non steel
!*************************************************
!  WRITE Process Emissions for Clinker and Lime Production.
!**********************************************************
       if(inddir.eq.11) then

         LINE = 'Process Emissions for Clinker and Lime Production'
         IROW = IROW + 2
         if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)

         Line = '  Clinker Process Emissions (million metric tons)'

         IROW = IROW + 1
         if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)

           CALL cknum(I15,IROW,icol,dble(CLINKCO2(indreg)),2,4)

        Line = '  Lime Process Emissions (million metric tons)'

        IROW = IROW + 1
        if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)

        CALL cknum(I15,IROW,icol,dble(LIMECO2(indreg)),2,4)
       endif ! end of process emissions loop

       enddo ! end of indreg loop for table output

     ENDDO ! end of industry loop

!**********************************************************
!  THIS IS A SPECIAL SECTION FOR REFINERY DATA.
!**********************************************************
     do indreg=regstart,regstop

        LINE = 'Energy Profile for Refining'
        IROW = (IROW/20)*20 +21
        if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
        IROW = IROW + 1
        LINE = ' Census Region: '//regname(indreg)
        if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
        IROW = IROW + 1
        LINE =  'TOTAL ENERGY CONSUMPTION'
        if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
        CALL ckint(I15,IROW,ICOL,curcalyr,0)

        IROW = IROW + 2

        total=0.

        DO if=1,13
           IF (ANY(rfuel.eq.if)) THEN   ! print if IF=3,6,7,8,9,10,11,12,13
             LINE =  '  ' // REFUELNAME(if)
             IROW = IROW + 1
             if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
             CALL cknum(I15,IROW,ICOL,DBLE(REFINE(if,indreg)),2,4)
             TOTAL = TOTAL + REFINE(if,indreg)
           ENDIF
        ENDDO
        Line =  '          Total'
        IROW = IROW + 1
        if(once(vers))CALL ckstr(I15,IROW,1,LINE,1,0,1)
        CALL cknum(I15,IROW,icol,dble(total),2,4)

     enddo
!**********************************************************
!  CLOSE THE SPREADSHEET FILE:
!**********************************************************
      once(vers)=.false.

      if(curiyr.eq.lastyr) then
         irow=1
         read(i15,'(a)',rec=irow) longline
         nul=char(0)
         do while (.not. eof(i15))
            read(i15,'(a)',rec=irow,err=999) longline
            do i=1,irecl-2
              if(longline(i:i).eq.nul) longline(i:i)=' '
            enddo
            do i=irecl-2,1,-1
              if(longline(i:i).ne.','.and.longline(i:i).ne.' ') then
!                if(i.lt.irecl-2) longline(i+1:i+1)=','
                exit
              else
                if(longline(i:i).eq.',') then
                  longline(i:i)=' '
                endif
              endif
            enddo
            longline(irecl-1:irecl)=char(13)//char(10)
!            if(len_trim(longline(:irecl-2)).eq.0) then
!              longline(1:4)='" ",'
!            endif
            write(i15,'(a)',rec=irow) longline
999         continue
            irow=irow+1
         enddo
       CLOSE(I15)
      endif

      RETURN
1001  continue
      write(6,*) ' error opening ', trim(blnkfile)
      notopen=.true.
      return
      END SUBROUTINE INDSIC
!===================================================================================
      SUBROUTINE INDGRP(groupsel)
   use i_
      IMPLICIT NONE
      INTEGER IY,ISTEP,IS,IFUEL(50),IROW/0/,IU,IY1,IY2
      INTEGER IREG,IFF,IREC,IGROUP,ifl,L,M,icr,icd,ncol
      INTEGER IUNIT(5)
      REAL*8 BENCHMARK,PRODUCT,EMPLY,ENCON,TOTCON,ENMAIN
      REAL*8 ENITM,ENRENW,BLDG
      REAL*8 PACON
      REAL*8 BSCON,BYPRENW
      REAL*8 BYPINTI
      REAL*8 STEAM,OWN
      REAL*8 SALE,OUTGEN
      REAL*8 TOTWK,UEC
      REAL*8 MACROVAL
      REAL*8 MACORPHY
      CHARACTER*166 LINE,IRNAME*2
      CHARACTER*166 RUNDOC(2)
      CHARACTER*3  INTG
      REAL OUTPUT(50)  ! PHYSICAL OUTPUT
      REAL EMPLOY(0:5)     ! EMPLOYMENT
      REAL OUTPUTQTY(0:5)  ! QUANTITY OF OUTPUT
      REAL OUTPUTVAL(0:5)  ! VALUE OF OUTPUT
!
!  IN THE FOLLOWING ARRAYS, THE THIRD SUBSCRIPT IS VERY COMPLEX:
!      0 = NATIONAL TOTALS
!      1-4 = REGIONAL TOTALS
!      5 = TOTALS FOR THE CURRENT INDUSTRY
!      6 = TOTAL OF ALL ENERGY-INTENSIVE INDUSTRIES
!      7 = TOTAL OF ALL NON-MANUFACTURING INDUSTRIES
!      8 = TOTAL OF ALL NON-INTENSIVE MANUFACTURING INDUSTRIES
!
      REAL ENPMQTYT(23,0:8)! ENERGY CONSUMPTION BY FUEL
      REAL ENPIQTYT(07,0:8)! INTERMEDIATE PRODUCT CONSUMPTION BY FUEL
      REAL ENPRQTYT(09,0:8)! RENEWABLES CONSUMPTION BY FUEL
!
      REAL BLDENCONS(12,0:8)! ENERGY CONSUMPTION IN BUILDINGS
      REAL ENPQTYT(16,30)!ENERGY CONSUMPTION FOR PROCESS & ASSEMBL
      REAL ENPQTYTR(50,0:8)!ENERGY CONSUMPTION FOR PROCESS & ASSEMBL
      REAL ENSQTYT(50,0:8)!ENERGY CONSUMPTION FOR BOIL/STEAM/COGEN
      REAL BYPQTYTR(8,0:8)!BYPRD-REN CONSUMPTION FOR BOIL/STEAM/COGEN
      REAL BYPQTYTI(6,0:8)!BYPRD-INTR CONSUMPTION FOR BOIL/STEAM/COGEN
      REAL STEMCURT(0:8)       ! STEAM GENERATION
      REAL COGSTEAMT(0:8)      ! Cogen STEAM GENERATION
      REAL NONCOGSTEAMT(0:8)   ! non cogen STEAM GENERATION
      REAL BIOSTEAMT(0:8)      ! non cogen STEAM GENERATION from biomass
      REAL NONCOGFOSSTEAMT(0:8)!  non cogen STEAM GENERATION from fossil fuels

      REAL ELOWNT(0:8)   ! ELECTRICITY GENERATION FOR OWN USE
      REAL ELSALET(0:8)   ! ELECTRICITY GENERATION FOR SALE TO GRID
      REAL GENFUELT(4,0:8)! FUEL CONSUMPTION FOR ELECTRIC GENERATION
      REAL RPTGENT(4,0:8) ! CHP generation by fuel GWH
      REAL RPTCAPT(4,0:8) ! CHP capacity by fuel MW

      REAL TOTAL        ! WORKING STORAGE FOR SUMS
      REAL WORK   ! WORKING STORAGE FOR RATIOS
      REAL REFIN(13,11)   ! STORAGE FOR REFINERY DATA EXTRACT FR TEMPO
      real refine(13,5)
      INTEGER IBYPTMPR(8,0:8)
      INTEGER IBYPTMPI(6,0:8),IP
      CHARACTER*40  FUELNAME(50)
      CHARACTER*168 FLINE
      logical OncePerGroup(0:2)/.true.,.true.,.true./,once
 ! for wk1 output routine.  holds unit number
      integer cwk1unit
      common/ciowk1/cwk1unit
      logical notopen/.false./

      CHARACTER*10  REGNAME(5)/ &
            'Northeast', &
            'Midwest', &
            'South', &
            'West', &
            'US Total'/

      DATA FUELNAME / &
           'Electricity', &
           'Electricity Generated', &
           'Natural Gas Firm', &
           'Natural Gas Inter.', &
           'Natural Gas Feedstock', &
           'Natural Gas Lease & Plant', &
           'Steam Coal', &
           'Coking Coal', &
           'Net Coal Coke Imports', &
           'Residual Oil', &
           'Distillate Oil', &
           'LPGs for Heat And Power', &
           'LPGs for Feedstocks', &
           'Motor Gasoline', &
           'Still Gas', &
           'Petroleum Coke', &
           'Asphalt & Road Oil', &
           'Lubes & Waxes', &
           'Petrochemical Feedstocks', &
           'Kerosene', &
           'Other Petroleum Feedstocks', &
           'Other Petroleum', &
           ' ', &
           ' ', &
           ' ', &
           ' ', &
           ' ', &
           ' ', &
           ' ', &
           ' ', &
           'Steam', &
           'Coke Oven Gas', &
           'Blast Furnace Gas', &
           'Other Byproduct Gas', &
           'Waste Heat', &
           'Coke', &
           ' ', &
           ' ', &
           ' ', &
           ' ', &
           'Hydropower', &
           'Biomass-Wood', &
           'Biomass-Pulping Liquor', &
           'Geothermal', &
           'Solar', &
           'Photovoltaic', &
           'Wind', &
           'Municipal Solid Waste', &
           ' ', &
           ' '/

      CHARACTER*40  REFUELNAME(14) / &
           'Purch Elec, Peak', &
           'Purch Elec, Nonpeak', &
           '   Purch Elec', &
           'Natural Gas, Core', &
           'Natural Gas, Noncore', &
           '   Natural Gas', &
           'Coal', &
           'Residual Fuel, Low Sulfur', &
           'Distillate', &
           'Liquid Petroleum Gases', &
           'Still Gas', &
           'Petroleum Coke', &
           'Other Petroleum', &
           'Lease & Plant Fuel'/

      CHARACTER*24 BENCHVARS(17) / &
            'Electricity', &
            'Natural Gas', &
            'Steam Coal', &
            'Metallurgical Coal', &
            'Net Coal Coke Imports', &
            'Residual Oil', &
            'Distillate Oil', &
            'Liquid Petroleum Gas', &
            'Motor Gasoline', &
            'Still Gas', &
            'Petroleum Coke', &
            'Asphalt and Road Oil', &
            'Petrochemical Feedstocks', &
            'Kerosene', &
            'Other Petroleum', &
            'Biomass',&
            'Waste'/
      CHARACTER*52 GROUPNAME(6:8) / &
           'Sum of Energy-Intensive Industries', &
           'Sum of Non-Manufacturing Industries', &
           'Sum of Non-Energy-Intensive Manufacturing Industries'/

      character*25 bldname(12)/'Lighting--Electricity',  &
         'HVAC--Electricity     ','HVAC--Natural Gas     ','          HVAC--Steam', &
         'Support--Electricity  ','Support--Natural Gas  ','Support--Distillate  ','Support--LPG  ', &
         'Transport--Electricity','Transport--Natural Gas','Transport--Distillate','Transport--LPG' /

      character*25 genname(4)/'      Natural Gas',  '      Coal' ,'      Oil', '      Other'/
      integer    genorder(4)/ 3,1,2,4/

       character*60 blnkfile        !length extended to allow longer sub-dir fully qualified name (ESE 4/7/11)

       integer I16Group(0:2),ICOL,I16
       logical lexist

      INTEGER*4 GroupOpt  ! 1 to include only a single group of industries in census totals
      INTEGER*4 GroupSel  ! Group Selected for GroupOpt: 1: man, 2:nonman
      integer*4 benchrow(0:2)/3*0/
      real SumCDiv
      external SumCDiv
      integer irecl
      character*1 nul
      parameter (irecl=400)
      character*irecl longline


      if(notopen) return
      OUTPUT =0.
      EMPLOY =0.
      OUTPUTQTY=0.
      OUTPUTVAL=0.
      ENPMQTYT =0.
      ENPIQTYT =0.
      ENPRQTYT =0.
      BLDENCONS=0.
      ENPQTYT  =0.
      ENPQTYTR =0.
      ENSQTYT  =0.
      BYPQTYTR =0.
      BYPQTYTI =0.
      STEMCURT =0.
      COGSTEAMT=0.
      NONCOGSTEAMT=0.
      BIOSTEAMT=0.
      NONCOGFOSSTEAMT=0.
      ELOWNT   =0.
      ELSALET  =0.
      GENFUELT =0.
      RPTGENT   =0.
      RPTCAPT   =0.
      IBYPTMPR =0.
      IBYPTMPI =0.

!**********************************************************
! argument GroupSel is for non-default option to create
! regional report for just manufacturing or just nonmanu
! industries.
! Normally (argument=0), the regional sections
! of this report are for total industrial.
! An argument of "1" results in a regional output of only manufacturing
! summaries at the census region level; a "2" is for nonmanufacturing
! only.
!**********************************************************
      GroupOpt=0
!     GroupSel=1   ! use this to print indm.csv with only mfg (excluding refining)
      if(GroupSel.eq.1.or.GroupSel.eq.2) GroupOpt=1


! get scenario/datecode identification of run
      rundoc(1)='Scenario: '//scen
      rundoc(2)='Datecode: '//date


      if(OncePerGroup(GroupSel)) then
        fname='INDT'
        if(GroupOpt.eq.1) then
          if(GroupSel.eq.1) fname='INDM'
          if(GroupSel.eq.2) fname='INDN'
        endif
        i16Group(GroupSel)=file_mgr('O',fname,.true.) ! get a free unit number from file_mgr
        i16=i16Group(GroupSel)
        inquire(unit=i16,name=blnkfile)
        close(i16,status='delete')
        OPEN(UNIT=i16,FILE=blnkfile,FORM='FORMATTED', &
           ACCESS='DIRECT',status='new',recl=irecl,err=1001)

      endif
      i16=i16Group(GroupSel)
      cwk1unit=i16  ! must be restored because two wk1 files open at once
      once=OncePerGroup(GroupSel)

      ICOL=curcalyr-ibyr2+3
      irow=0
!**********************************************************
!  INITIALIZE THE SPREADSHEET FILE:
!**********************************************************
      if(once) then
        CALL ckstr(I16,1,1,rundoc(1),1,0,1)
        CALL ckstr(I16,2,1,rundoc(2),1,0,1)
      endif

      IY = curiyr
      i=iy
      iyr= curcalyr


!**********************************************************
!  CALCULATE NECESSARY VARIABLES FOR REPORT TABLES, FOR
!  EACH INDUSTRY.
!**********************************************************

      DO INDNUM=1,INDMAX
        inddir=indnum

        DO INDREG=1,4
          CALL RDBIN
          if(GroupOpt.eq.1.and.GroupSel.eq.1.and.INDNUM.LE.6) cycle !cycle means skip this loop of the current do loop)
          if(GroupOpt.eq.1.and.GroupSel.eq.2.and.INDNUM.GE.7) cycle
          IF(INDDIR.GE.7.and.INDDIR.LE.13) THEN
            IGROUP = 6
          ELSE IF (INDDIR .LT. 7) THEN
            IGROUP = 7
          ELSE
             IGROUP = 8
          ENDIF

            DO ISTEP=1,MPASTP
              IF(INDREG.EQ.1) OUTPUT(ISTEP)=0.0
              IF(IDVAL.EQ.1) THEN
                OUTPUT(ISTEP)=OUTPUT(ISTEP)+(PRODCUR(4,ISTEP)/1000000.)
              ELSE
                OUTPUT(ISTEP)=OUTPUT(ISTEP)+PRODCUR(4,ISTEP)
              ENDIF
            ENDDO

            EMPLOY(5) = EMPLOY(5)+EMPLX
            EMPLOY(0) = EMPLOY(0)+EMPLX
            EMPLOY(INDREG) = EMPLOY(INDREG)+EMPLX

            IF(IDVAL.EQ.2) THEN
              outputqty(0)=0.
              outputqty(indreg)=0.
            ELSE
              OUTPUTQTY(0) = OUTPUTQTY(0)+(PRODX/1000000.)
              OUTPUTQTY(INDREG) = OUTPUTQTY(INDREG)+ (PRODX/1000000.)
            ENDIF

!  ESTABLISH DOLLAR VALUE OF OUTPUT.

            OUTPUTVAL(0) = OUTPUTVAL(0)+PRODVX
            OUTPUTVAL(INDREG) = OUTPUTVAL(INDREG)+PRODVX

!**********************************************************
!  ESTABLISH TOTAL ENERGY CONSUMPTION BY MAIN FUEL.
!**********************************************************

            DO IF=1,23
              ENPMQTYT(IF,0)=ENPMQTYT(IF,0)+QTYMAIN(IF,INDREG)
              ENPMQTYT(IF,INDREG)=ENPMQTYT(IF,INDREG) &
                                     +QTYMAIN(IF,INDREG)
              ENPMQTYT(IF,IGROUP)=ENPMQTYT(IF,IGROUP) &
                                     +QTYMAIN(IF,INDREG)
            ENDDO

!  ESTABLISH TOTAL ENERGY CONSUMPTION BY INTERMEDIATE FUEL.

            DO IF=1,7
              ENPIQTYT(IF,0)=ENPIQTYT(IF,0)          +QTYINTR(IF,INDREG)
              ENPIQTYT(IF,INDREG)=ENPIQTYT(IF,INDREG)+QTYINTR(IF,INDREG)
              ENPIQTYT(IF,IGROUP)=ENPIQTYT(IF,IGROUP)+QTYINTR(IF,INDREG)
            ENDDO

!  ESTABLISH TOTAL ENERGY CONSUMPTION BY RENEWABLE FUEL.

            DO IF=1,9
              ENPRQTYT(IF,0) = ENPRQTYT(IF,0)        +QTYRENW(IF,INDREG)
              ENPRQTYT(IF,INDREG)=ENPRQTYT(IF,INDREG)+QTYRENW(IF,INDREG)
              ENPRQTYT(IF,IGROUP)=ENPRQTYT(IF,IGROUP)+QTYRENW(IF,INDREG)
            ENDDO

!  ESTABLISH BUILDING COMPONENT CONSUMPTION BY FUEL.

            if(inddir.gt.6) then

              BLDENCONS( 1,0) = BLDENCONS( 1,0)+ENBQTY(1,1)  ! lighting
              BLDENCONS( 2,0) = BLDENCONS( 2,0)+ENBQTY(2,1)  ! hvac el
              BLDENCONS( 3,0) = BLDENCONS( 3,0)+ENBQTY(2,2)  ! hvac ng
              BLDENCONS( 4,0) = BLDENCONS( 4,0)+ENBQTY(2,3)  ! hvac stm
              BLDENCONS( 5,0) = BLDENCONS( 5,0)+ENBQTY(3,1)  ! fac support, el
              BLDENCONS( 6,0) = BLDENCONS( 6,0)+ENBQTY(3,2)  ! fac support, ng
              BLDENCONS( 7,0) = BLDENCONS( 7,0)+ENBQTY(3,4)  ! fac support, df
              BLDENCONS( 8,0) = BLDENCONS( 8,0)+ENBQTY(3,5)  ! fac support, lpg
              BLDENCONS( 9,0) = BLDENCONS( 9,0)+ENBQTY(4,1)  ! onsite tran, el
              BLDENCONS(10,0) = BLDENCONS(10,0)+ENBQTY(4,2)  ! onsite tran, ng
              BLDENCONS(11,0) = BLDENCONS(11,0)+ENBQTY(4,4)  ! onsite tran, ng
              BLDENCONS(12,0) = BLDENCONS(12,0)+ENBQTY(4,5)  ! onsite tran, ng

              if(indreg.eq.0 .or. igroup.eq.0) then
                 write(6,*) 'help: indreg=0 or igroup=0,',indreg,igroup,iy,inddir
              endif

              BLDENCONS( 1,INDREG) = BLDENCONS( 1,INDREG)+ ENBQTY(1,1)
              BLDENCONS( 2,INDREG) = BLDENCONS( 2,INDREG)+ ENBQTY(2,1)
              BLDENCONS( 3,INDREG) = BLDENCONS( 3,INDREG)+ ENBQTY(2,2)
              BLDENCONS( 4,INDREG) = BLDENCONS( 4,INDREG)+ ENBQTY(2,3)
              BLDENCONS( 5,INDREG) = BLDENCONS( 5,INDREG)+ ENBQTY(3,1)  ! fac support, el
              BLDENCONS( 6,INDREG) = BLDENCONS( 6,INDREG)+ ENBQTY(3,2)  ! fac support, ng
              BLDENCONS( 7,INDREG) = BLDENCONS( 7,INDREG)+ ENBQTY(3,4)  ! fac support, df
              BLDENCONS( 8,INDREG) = BLDENCONS( 8,INDREG)+ ENBQTY(3,5)  ! fac support, lpg
              BLDENCONS( 9,INDREG) = BLDENCONS( 9,INDREG)+ ENBQTY(4,1)  ! onsite tran, el
              BLDENCONS(10,INDREG) = BLDENCONS(10,INDREG)+ ENBQTY(4,2)  ! onsite tran, ng
              BLDENCONS(11,INDREG) = BLDENCONS(11,INDREG)+ ENBQTY(4,4)  ! onsite tran, ng
              BLDENCONS(12,INDREG) = BLDENCONS(12,INDREG)+ ENBQTY(4,5)  ! onsite tran, ng

              BLDENCONS( 1,IGROUP) = BLDENCONS( 1,IGROUP)+ ENBQTY(1,1)
              BLDENCONS( 2,IGROUP) = BLDENCONS( 2,IGROUP)+ ENBQTY(2,1)
              BLDENCONS( 3,IGROUP) = BLDENCONS( 3,IGROUP)+ ENBQTY(2,2)
              BLDENCONS( 4,IGROUP) = BLDENCONS( 4,IGROUP)+ ENBQTY(2,3)
              BLDENCONS( 5,IGROUP) = BLDENCONS( 5,IGROUP)+ ENBQTY(3,1)  ! fac support, el
              BLDENCONS( 6,IGROUP) = BLDENCONS( 6,IGROUP)+ ENBQTY(3,2)  ! fac support, ng
              BLDENCONS( 7,IGROUP) = BLDENCONS( 7,IGROUP)+ ENBQTY(3,4)  ! fac support, df
              BLDENCONS( 8,IGROUP) = BLDENCONS( 8,IGROUP)+ ENBQTY(3,5)  ! fac support, lpg
              BLDENCONS( 9,IGROUP) = BLDENCONS( 9,IGROUP)+ ENBQTY(4,1)  ! onsite tran, el
              BLDENCONS(10,IGROUP) = BLDENCONS(10,IGROUP)+ ENBQTY(4,2)  ! onsite tran, ng
              BLDENCONS(11,IGROUP) = BLDENCONS(11,IGROUP)+ ENBQTY(4,4)  ! onsite tran, ng
              BLDENCONS(12,IGROUP) = BLDENCONS(12,IGROUP)+ ENBQTY(4,5)  ! onsite tran, ng
            endif

!  ESTABLISH PROCESS AND ASSEMBLY COMPONENT CONSUMPTION BY FUEL.

            DO IS=1,MPASTP
               DO IF=1,IFMAX(IS)
                  ENPQTYT(IF,IS)=ENPQTYT(IF,IS)            +ENPQTY(4,IF,IS)
                  IFF = IFLOC(IF,IS)
                  if (IFF.LT.1) then

                  else
                     ENPQTYTR(IFF,0)=     ENPQTYTR(IFF,0)     +ENPQTY(4,IF,IS)
                     ENPQTYTR(IFF,INDREG)=ENPQTYTR(IFF,INDREG)+ENPQTY(4,IF,IS)
                     ENPQTYTR(IFF,IGROUP)=ENPQTYTR(IFF,IGROUP)+ENPQTY(4,IF,IS)
                  endif
               ENDDO
            ENDDO

!  ESTABLISH BOILER/STEAM/COGENERATION CONSUMPTION BY FUEL.

!  PURCHASED FUELS:

            DO IF=1,IFSMAX
              IFF=IFSLOC(IF)
              ENSQTYT(IFF,0) =      ENSQTYT(IFF,0)      +ENSQTY(IF)
              ENSQTYT(IFF,INDREG) = ENSQTYT(IFF,INDREG) +ENSQTY(IF)
              ENSQTYT(IFF,IGROUP) = ENSQTYT(IFF,IGROUP) +ENSQTY(IF)

              			  
		!	  if (IF.eq.6)write(777,*) 'Electric boiler values', indreg, igroup, &
		!	   ENSQTY(IF), ENSQTYT(IFF,0), ENSQTYT(IFF,INDREG), ENSQTYT(IFF,IGROUP)    

            ENDDO

			  
!  BYPRODUCT FUELS:

              DO IF=1,8
                BYPQTYTR(IF,0)=     BYPQTYTR(IF,0)     +BYPBSCR(IF)
                BYPQTYTR(IF,INDREG)=BYPQTYTR(IF,INDREG)+BYPBSCR(IF)
                BYPQTYTR(IF,IGROUP)=BYPQTYTR(IF,IGROUP)+BYPBSCR(IF)
              ENDDO

              DO IF=1,6
                BYPQTYTI(IF,0)=     BYPQTYTI(IF,0)     +BYPBSCI(IF)
                BYPQTYTI(IF,INDREG)=BYPQTYTI(IF,INDREG)+BYPBSCI(IF)
                BYPQTYTI(IF,IGROUP)=BYPQTYTI(IF,IGROUP)+BYPBSCI(IF)
              ENDDO

!  ESTABLISH TOTAL STEAM DEMAND.

              STEMCURT(0) =      STEMCURT(0)     +STEMCUR
              STEMCURT(INDREG) = STEMCURT(INDREG)+STEMCUR
              STEMCURT(IGROUP) = STEMCURT(IGROUP)+STEMCUR

              COGSTEAMT(0)     = COGSTEAMT(0)     +COGSTEAM
              COGSTEAMT(INDREG)= COGSTEAMT(INDREG)+COGSTEAM
              COGSTEAMT(IGROUP)= COGSTEAMT(IGROUP)+COGSTEAM

              NONCOGSTEAMT(0)     = NONCOGSTEAMT(0)     +NONCOGSTEAM
              NONCOGSTEAMT(INDREG)= NONCOGSTEAMT(INDREG)+NONCOGSTEAM
              NONCOGSTEAMT(IGROUP)= NONCOGSTEAMT(IGROUP)+NONCOGSTEAM

              BIOSTEAMT(0)        = BIOSTEAMT(0)     +BIOSTEAM
              BIOSTEAMT(INDREG)   = BIOSTEAMT(INDREG)+BIOSTEAM
              BIOSTEAMT(IGROUP)   = BIOSTEAMT(IGROUP)+BIOSTEAM

              NONCOGFOSSTEAMT(0)     = NONCOGFOSSTEAMT(0)     +NONCOGFOSSTEAM
              NONCOGFOSSTEAMT(INDREG)= NONCOGFOSSTEAMT(INDREG)+NONCOGFOSSTEAM
              NONCOGFOSSTEAMT(IGROUP)= NONCOGFOSSTEAMT(IGROUP)+NONCOGFOSSTEAM

!  ESTABLISH ELECTRICITY GENERATED FOR OWN USE.

              ELOWNT(0)      = ELOWNT(0)     +ELOWN
              ELOWNT(INDREG) = ELOWNT(INDREG)+ELOWN
              ELOWNT(IGROUP) = ELOWNT(IGROUP)+ELOWN

!  ESTABLISH ELECTRICITY GENERATED FOR SALES TO THE GRID.

              ELSALET(0)      = ELSALET(0)     +ELSALE
              ELSALET(INDREG) = ELSALET(INDREG)+ELSALE
              ELSALET(IGROUP) = ELSALET(IGROUP)+ELSALE

!**********************************************************
!  ESTABLISH FUELS CONSUMPTION FOR COGENERATION.
!**********************************************************

            DO IF=1,4
                GENFUELT(IF,0)     =GENFUELT(IF,0)     +GENFUEL(IF)
                GENFUELT(IF,INDREG)=GENFUELT(IF,INDREG)+GENFUEL(IF)
                GENFUELT(IF,IGROUP)=GENFUELT(IF,IGROUP)+GENFUEL(IF)
                RPTGENT(IF,0)      =RPTGENT(IF,0)      +RPTGEN(IF)
                RPTGENT(IF,INDREG) =RPTGENT(IF,INDREG) +RPTGEN(IF)
                RPTGENT(IF,IGROUP) =RPTGENT(IF,IGROUP) +RPTGEN(IF)
                RPTCAPT(IF,0)      =RPTCAPT(IF,0)      +RPTCAP(IF)
                RPTCAPT(IF,INDREG) =RPTCAPT(IF,INDREG) +RPTCAP(IF)
                RPTCAPT(IF,IGROUP) =RPTCAPT(IF,IGROUP) +RPTCAP(IF)
            ENDDO


          ENDDO      !  END OF INPUT LOOP OVER REGIONS

!**********************************************************
!  THIS IS A SPECIAL SECTION FOR REFINERY DATA.
!**********************************************************
          if(GroupOpt.eq.0.or.(GroupOpt.eq.1.and.GroupSel.eq.1))THEN
            IF(INDNUM.EQ.INDMAX) THEN

              refine=0.
              do ifl=1,13
               do indreg=1,4
! Establish the range of census divisions for the current region using an innovative approach
                L=indreg*2+indreg/4-1  ! obviously, L will be 1,3,5, and 8 for indreg=1..4
                M=indreg*2+indreg/3    !            M will be 2,4,7, and 9 for indreg=1..4
                do icd=L,M
                  refine(ifl,indreg)=refine(ifl,indreg)+refin(ifl,icd)
                  refine(ifl,5)=refine(ifl,5)+refin(ifl,icd)
                enddo
               enddo
              enddo
              do i=0,6
                IF(I.EQ.5) CYCLE
                icr=5
                if(i.ge.1.and.i.le.4) icr=i

                ENPMQTYT( 1,i)=ENPMQTYT( 1,i)+ REFINE( 3,ICR)
                ENPMQTYT( 3,i)=ENPMQTYT( 3,i)+ REFINE( 6,ICR)
                ENPMQTYT( 7,i)=ENPMQTYT( 7,i)+ REFINE( 7,ICR)
                ENPMQTYT(10,i)=ENPMQTYT(10,i)+ REFINE( 8,ICR)
                ENPMQTYT(11,i)=ENPMQTYT(11,i)+ REFINE( 9,ICR)
                ENPMQTYT(12,i)=ENPMQTYT(12,i)+ REFINE(10,ICR)
                ENPMQTYT(15,i)=ENPMQTYT(15,i)+ REFINE(11,ICR)
                ENPMQTYT(16,i)=ENPMQTYT(16,i)+ REFINE(12,ICR)
                ENPMQTYT(22,i)=ENPMQTYT(22,i)+ REFINE(13,ICR)
              ENDDO
            ENDIF
          endif

      ENDDO  ! END OF LOOP OVER INDUSTRIES

!****
      LINE = 'NEMS Industrial Module Output'

        if(GroupOpt.eq.1) then
        if(GroupSel.eq.1) then
            LINE= 'The Following Reports are for Manufacturing Only'
          else
            LINE= 'The Following Reports are for NonManufacturing Only'
        endif
        endif

      if(once)CALL ckstr(I16,10,1,LINE,1,0,1)
      IROW = 0

      DO INDREG=0,4

!**********************************************************
!  WRITE THE TITLE OF THE TABLE.
!**********************************************************

        IF (INDREG .EQ. 0)  THEN
          LINE = 'TABLE 1.'// &
              '  ENERGY AND MACROECONOMIC PROFILE FOR INDUSTRIAL SECTOR'
          if(GroupOpt.eq.1) then
            if(GroupSel.eq.1) then
              LINE = 'TABLE 1.  ENERGY AND MACROECONOMIC PROFILE FOR Manufacturing '
            else
              LINE = 'TABLE 1.  ENERGY AND MACROECONOMIC PROFILE FOR NonManufacturing'
            endif
          endif

        ELSE
          LINE = 'TABLE 3.  ENERGY AND MACROECONOMIC PROFILE BY REGION'
          if(GroupOpt.eq.1) then
            if(GroupSel.eq.1) then
              LINE = 'TABLE 3.  ENERGY AND MACROECONOMIC PROFILE BY REGION'// &
             ' FOR Manufacturing '
            else
              LINE = 'TABLE 3.  ENERGY AND MACROECONOMIC PROFILE BY REGION'// &
             ' FOR NonManufacturing '
            endif
          endif

        ENDIF
        IROW = (IROW/20)*20 +21
        if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
        IROW = IROW + 1
        IF (INDREG .GT. 0)  THEN
          LINE = 'CENSUS REGION '// regname(indreg)
          if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
        ENDIF
        IROW = IROW + 1

        CALL ckint(I16,IROW,icol,curcalyr,0)

!**********************************************************
!  WRITE MACROECONOMIC SECTION.
!**********************************************************

        IROW = IROW + 2
        LINE = 'Macroeconomic Indicators'
        if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)

        Line =  '  Value of Output (billion 2005$)'
        IROW = IROW + 1
        if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
        CALL cknum(I16,IROW,icol,dble(outputval(indreg)),2,4)

        Line = '  Physical Output (million tonnes)'
        IROW = IROW + 1
        if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
        CALL cknum(I16,IROW,icol,dble(outputqty(indreg)),2,4)

        Line =  '  Employment (thousand)'
        IROW = IROW + 1
        if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
        CALL cknum(I16,IROW,Icol,dble(employ(indreg)),2,4)

!**********************************************************
!  WRITE TOTAL ENERGY CONSUMPTION BY FUEL SECTION.
!**********************************************************

         LINE =  'Total Energy Consumption (Trillion BTU)'

         IROW = IROW + 2
         if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)

         DO IF=1,22
           IF(IF.EQ.4) THEN   ! Non-core NG CHP added later so we need the label
             IFUEL(IF) = 1
           ELSEIF (IF.EQ.7) THEN   ! same for coal
             IFUEL(IF) = 1
           ELSEIF (ENPMQTYT(IF,INDREG).EQ.0.0) THEN  ! don't print needless rows
             IFUEL(IF) = 0
           ELSE
             IFUEL(IF) = 1
           ENDIF
         ENDDO

         DO IF=1,8
           IF(ENPRQTYT(IF,INDREG).EQ.0.0) THEN
             IFUEL(IF+40) = 0
           ELSE
             IFUEL(IF+40) = 1
           ENDIF
         ENDDO

         TOTAL = 0.

         DO IF=1,22
           IF(IFUEL(IF) .EQ. 1) THEN
             LINE =  '  ' // FUELNAME(IF)
             IROW = IROW + 1
             if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
             CALL cknum(I16,IROW,ICOL,dble(ENPMQTYT(IF,INDREG)),2,4)
             TOTAL=TOTAL+ENPMQTYT(IF,INDREG)
           ENDIF
           IF(IF.EQ.6.AND.IFUEL(3)+IFUEL(4)+IFUEL(5)+IFUEL(6).GT.1) THEN
             LINE = '    Natural Gas Total'
             IROW = IROW + 1
             if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
             WORK = ENPMQTYT(3,INDREG)+ENPMQTYT(4,INDREG) &
                   +ENPMQTYT(5,INDREG)+ENPMQTYT(6,INDREG)
             CALL cknum(I16,IROW,Icol,dble(work),2,4)
           ENDIF
         ENDDO

         DO IF=1,8
           IF(IFUEL(IF+40) .EQ. 1) THEN
             LINE =  '  ' // FUELNAME(IF+40)
             IROW = IROW + 1
             if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
             CALL cknum(I16,IROW,ICOL,dble(ENPRQTYT(IF,INDREG)),2,4)
             TOTAL = TOTAL + ENPRQTYT(IF,INDREG)
           ENDIF
         ENDDO

         Line =  '          Total'
         IROW = IROW + 1
         if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
         CALL cknum(I16,IROW,ICOL,dble(total),2,4)

!  WRITE UNIT ENERGY CONSUMPTION BY FUEL.

          IROW = IROW + 2
         LINE =  'Unit Energy Consumption (Thousand BTU/2005$)'
         if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)

         DO IF=1,22
           IF(IFUEL(IF) .EQ. 1) THEN
             LINE =  '  ' // FUELNAME(IF)

             IF(OUTPUTVAL(INDREG) .EQ. 0.) THEN
               WORK = 0.
             ELSE
               WORK = ENPMQTYT(IF,INDREG)/OUTPUTVAL(INDREG)
             ENDIF

             IROW = IROW + 1
             if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
             CALL cknum(I16,IROW,ICOL,dble(work),2,4)

           ENDIF
           IF(IF.EQ.6.AND.IFUEL(3)+IFUEL(4)+IFUEL(5)+IFUEL(6).GT.1)THEN
             LINE = '    Natural Gas Total'
             IROW = IROW + 1
             if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
             IF (OUTPUTVAL(INDREG) .EQ. 0.) THEN
                WORK = 0.
             ELSE
                WORK =(ENPMQTYT(3,INDREG)+ENPMQTYT(4,INDREG) &
                      +ENPMQTYT(5,INDREG)+ENPMQTYT(6,INDREG)) &
                      /OUTPUTVAL(INDREG)
             ENDIF
             CALL cknum(I16,IROW,ICOL,dble(work),2,4)
           ENDIF
         ENDDO

         DO IF=1,7
           IF(IFUEL(IF+40) .EQ. 1) THEN
             LINE =  '  ' // FUELNAME(IF+40)
             IF (OUTPUTVAL(INDREG) .EQ. 0.) THEN
               WORK = 0.
             ELSE
               WORK = ENPRQTYT(IF,INDREG)/OUTPUTVAL(INDREG)
             ENDIF

             IROW = IROW + 1
             if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
             CALL cknum(I16,IROW,ICOL,dble(work),2,4)
           ENDIF
         ENDDO

!  WRITE ENERGY CONSUMPTION IN THE BUILDINGS COMPONENT.


           LINE = 'BUILDINGS COMPONENT'
           IROW = IROW + 2
           if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
           total=sum(BLDENCONS(1:12,INDREG))

           LINE = 'Energy Consumption for Buildings (TR BTU)'
           IROW = IROW + 2
           if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)

           do i=1,12
             LINE=BLDNAME(I)
             IROW = IROW + 1
             if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
             CALL cknum(I16,IROW,ICOL,dble(BLDENCONS(I,indreg)),2,4)
           enddo
           Line =  '          Total Building Energy Use'

           IROW = IROW + 1
           if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)

           CALL cknum(I16,IROW,ICOL,DBLE(total),2,4)
           IF (BLDENCONS(4,indreg) .NE. 0.)  THEN
             Line =  '          Total less Steam'
             IROW = IROW + 1
             if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
             TOTAL = TOTAL - BLDENCONS(4,indreg)
             CALL cknum(I16,IROW,ICOL,DBLE(total),2,4)
           ENDIF

!  WRITE VARIOUS VARIABLES IN THE PA COMPONENT.

         LINE = 'PROCESS AND ASSEMBLY COMPONENT'
         IROW = IROW + 2
         if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)

!  WRITE ENERGY CONSUMPTION FOR EACH PROCESS STEP.

         LINE='Energy consumption for Process and Assembly (Trillion BTU)'
         IROW = IROW + 2
         if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
         TOTAL = 0.
         DO IF=1,50
           IF(ENPQTYTR(IF,INDREG) .NE. 0.)  THEN
             LINE = '    ' // FUELNAME(IF)
             IROW = IROW + 1
             if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
             CALL cknum(I16,IROW,ICOL,dble(ENPQTYTR(IF,INDREG)),2,4)
             TOTAL = TOTAL + ENPQTYTR(IF,INDREG)
           ENDIF
           IF(IF .EQ. 6) THEN
             LINE = '    Natural Gas Total'
             IROW = IROW + 1
             if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
             WORK = ENPQTYTR(3,INDREG)+ENPQTYTR(4,INDREG) &
                   +ENPQTYTR(5,INDREG)+ENPQTYTR(6,INDREG)
             CALL cknum(I16,IROW,ICOL,dble(work),2,4)
           ENDIF
         ENDDO

         Line =  '          Total'
         IROW = IROW + 1
         if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
         CALL cknum(I16,IROW,ICOL,DBLE(TOTAL),2,4)

!  WRITE ENERGY CONSUMPTION FOR BSC COMPONENT.

 
		 LINE = 'BOILER/STEAM/COGENERATION COMPONENT'
		 IROW = IROW + 2
		 if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)

		 LINE = 'Energy Consumption for Boiler/Steam/Cogeneration' &
		 // ' (Trillion BTU)'
		 IROW = IROW + 2
		 if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)

		 TOTAL = 0.
		 DO IF=1,22
		   IF ((ENSQTYT(IF,INDREG).gt.0.0).OR.((IF.EQ.1).OR.(IF.EQ.4).OR.(IF.EQ.7))) then !Force non-core gas and coal
			 LINE = '  ' // FUELNAME(IF)                            !b/c it's non-zero later
			 IROW = IROW + 1
			 if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
			 CALL cknum(I16,IROW,ICOL,dble(ENSQTYT(IF,INDREG)),2,4)
			 TOTAL = TOTAL + ENSQTYT(IF,INDREG)
		   ENDIF
		 ENDDO




		 DO IF=1,8
		   IF(BYPQTYTR(IF,INDREG).ne.0.0) THEN
			 LINE = '  ' // FUELNAME(IF+40)
			 IROW = IROW + 1
			 if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
			 CALL cknum(I16,IROW,ICOL,dble(BYPQTYTR(IF,INDREG)),2,4)
			 TOTAL = TOTAL + BYPQTYTR(IF,INDREG)

		   ENDIF
		 ENDDO

		 DO IF=2,6
		   IF(dble(BYPQTYTR(IF,INDREG)).ne.0.) THEN
			 LINE = '  ' // FUELNAME(IF+30)
			 IROW = IROW + 1
			 if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
			 CALL cknum(I16,IROW,ICOL,dble(BYPQTYTI(IF,INDREG)),2,4)
			 TOTAL = TOTAL + BYPQTYTI(IF,INDREG)

		   ENDIF
		 ENDDO

		 Line =  '          Total'
		 IROW = IROW + 1
		 if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
		 CALL cknum(I16,IROW,ICOL,dble(total),2,4)

!  WRITE STEAM GENERATION.

		 LINE = 'Total Steam Generation (Tr. BTU)'
		 IROW = IROW + 2
		 if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
		 CALL cknum(I16,IROW,ICOL,dble(STEMCURT(INDREG)),2,4)

		 LINE = '  CHP Steam Generation'
		 IROW = IROW + 1
		 if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
		 CALL cknum(I16,IROW,icol,dble(COGSTEAMT(indreg)),2,4)

		 LINE = '  Total Non-CHP Steam Generation'
		 IROW = IROW + 1
		 if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
		 CALL cknum(I16,IROW,icol,dble(NONCOGSTEAMT(indreg)),2,4)

		 LINE = '      Non-CHP Fossil Steam Generation'
		 IROW = IROW + 1
		 if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
		 CALL cknum(I16,IROW,icol,dble(NONCOGFOSSTEAMT(indreg)),2,4)

		 LINE = '      Non-CHP Biomass Steam Generation'
		 IROW = IROW + 1
		 if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
		 CALL cknum(I16,IROW,icol,dble(BIOSTEAMT(indreg)),2,4)

!**********************************************************
!  WRITE ELECTRICITY/CHP  VARIABLES.
!**********************************************************

		 LINE = 'ELECTRICITY CAPACITY, GENERATION, AND FUEL USE'
		 IROW = IROW + 2
		 if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)

		 Line = '  Generating Capacity (MW)'
		 total=0.
		 IROW = IROW + 1
		 if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
		  do if=1,4
		   i=genorder(if)
		   IROW = IROW + 1
		   Line = genname(if)
		   if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
		   CALL cknum(I16,IROW,icol,dble(RPTCAPT(i,indreg)),2,4)
		   TOTAL = TOTAL + RPTCAPT(i,indreg)
		 enddo
		 Line =  '          Total'
		 IROW = IROW + 1
		 if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
		 CALL cknum(I16,IROW,ICOL,dble(total),2,4)

		 Line = '  Generation (GWH)'
		 Total=0.
		 IROW = IROW + 1
		 if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
		  do if=1,4
		   i=genorder(if)
		   IROW = IROW + 1
		   Line = genname(if)
		   if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
		   CALL cknum(I16,IROW,icol,dble(RPTGENT(i,indreg)),2,4)
		   TOTAL = TOTAL + RPTGENT(i,indreg)
		 enddo
		 Line =  '          Total'
		 IROW = IROW + 1
		 if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
		 CALL cknum(I16,IROW,ICOL,dble(total),2,4)

		 Line = '    Own Use'
		 IROW = IROW + 2
		 if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
		 CALL cknum(I16,IROW,icol,dble(ELOWNT(indreg)),2,4)

		 Line = '    Grid Sales'
		 IROW = IROW + 1
		 if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
		 CALL cknum(I16,IROW,icol,dble(ELSALET(indreg)),2,4)

		 Line = '    Fuel Consumption (Trillion Btu)'
		 TOTAL = 0.
		 IROW = IROW + 2
		 if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
		 do if=1,4
		   i=genorder(if)
		   IROW = IROW + 1
		   Line = genname(if)
		   if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
		   CALL cknum(I16,IROW,icol,dble(GENFUELT(i,indreg)),2,4)
		   TOTAL = TOTAL + GENFUELT(i,indreg)
		 enddo
		 Line =  '          Total'
		 IROW = IROW + 1
		 if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
		 CALL cknum(I16,IROW,ICOL,dble(total),2,4)
	  
	  
	  ENDDO  ! OF INDREG=0,4
		 

      if(GroupOpt.ne.1) then  ! if this is an optional manuf/nonmanuf report, skip remainder
!**********************************************************
!  THIS PART WRITES A TABLE OF ENERGY CONSUMPTION BY FUEL FOR
!  EACH OF THREE INDUSTRY GROUPS
!**********************************************************
      DO IGROUP=6,8

         LINE = 'TABLE 5.  ENERGY CONSUMPTION BY INDUSTRY GROUP'
         IROW = (IROW/20)*20 +21
         if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
         IROW = IROW + 2
         LINE = GROUPNAME(IGROUP)
         if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
         IROW = IROW + 1
         CALL ckint(I16,IROW,ICOL,curcalyr,0)

         LINE =  'Total Energy Consumption (Trillion BTU)'
         IROW = IROW + 2
         if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)

         DO IF=1,22
           IF(ENPMQTYT(IF,IGROUP).EQ.0.0) THEN
             IFUEL(IF) = 0
           ELSE
             IFUEL(IF) = 1
           ENDIF
         ENDDO

         DO IF=1,8
           IF(ENPRQTYT(IF,IGROUP).EQ.0.0) THEN
             IFUEL(IF+40) = 0
           ELSE
             IFUEL(IF+40) = 1
           ENDIF
         ENDDO

         TOTAL = 0.


         DO IF=1,22
           IF(IFUEL(IF) .EQ. 1) THEN
             LINE =  '  ' // FUELNAME(IF)
             IROW = IROW + 1
             if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
             CALL cknum(I16,IROW,ICOL,dble(ENPMQTYT(IF,IGROUP)),2,4)
             TOTAL = TOTAL + ENPMQTYT(IF,IGROUP)
           ENDIF
           IF(IF.EQ.6.AND.IFUEL(3)+IFUEL(4)+IFUEL(5)+IFUEL(6).GT.1) THEN
              LINE = '    Natural Gas Total'
              IROW = IROW + 1
              if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
              WORK = ENPMQTYT(3,IGROUP)+ENPMQTYT(4,IGROUP) &
                    +ENPMQTYT(5,IGROUP)+ENPMQTYT(6,IGROUP)
              CALL cknum(I16,IROW,ICOL,dble(work),2,4)
           ENDIF
         ENDDO

         DO IF=1,8
           IF(IFUEL(IF+40) .EQ. 1) THEN
             LINE =  '  ' // FUELNAME(IF+40)
             IROW = IROW + 1
             if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
             CALL cknum(I16,IROW,ICOL,dble(ENPRQTYT(IF,IGROUP)),2,4)
             TOTAL = TOTAL + ENPRQTYT(IF,IGROUP)
           ENDIF
         ENDDO

         Line =  '          Total'
         IROW = IROW + 1
         if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
         CALL cknum(I16,IROW,ICOL,dble(TOTAL),2,4)

 !  WRITE ENERGY CONSUMPTION IN THE BUILDINGS COMPONENT.


           LINE = 'BUILDINGS COMPONENT'
           IROW = IROW + 2
           if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
           total=sum(BLDENCONS(1:12,IGROUP))

           LINE = 'Energy Consumption for Buildings (Trillion BTU)'
           IROW = IROW + 2
           if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)

           do i=1,12
             LINE=BLDNAME(I)
             IROW = IROW + 1
             if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
             CALL cknum(I16,IROW,ICOL,dble(BLDENCONS(I,IGROUP)),2,4)
           enddo
           Line =  '          Total Building Energy Use'

           IROW = IROW + 1
           if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)

           CALL cknum(I16,IROW,ICOL,DBLE(total),2,4)
           IF (BLDENCONS(4,indreg) .NE. 0.)  THEN
             Line =  '          Total less Steam'
             IROW = IROW + 1
             if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
             TOTAL = TOTAL - BLDENCONS(4,IGROUP)
             CALL cknum(I16,IROW,ICOL,DBLE(total),2,4)
           ENDIF

!
         LINE = 'PROCESS AND ASSEMBLY COMPONENT'
         IROW = IROW + 2
         if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)

!  WRITE ENERGY CONSUMPTION FOR EACH PROCESS STEP.

         LINE='Energy Consumption for Process and Assembly (Trillion BTU)'
         IROW = IROW + 2
         if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
         TOTAL = 0.
         DO IF=1,50
           IF(ENPQTYTR(IF,IGROUP) .NE. 0.)  THEN
             LINE = '    ' // FUELNAME(IF)
             IROW = IROW + 1
             if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
             CALL cknum(I16,IROW,ICOL,dble(ENPQTYTR(IF,IGROUP)),2,4)
             TOTAL = TOTAL + ENPQTYTR(IF,IGROUP)
           ENDIF
           IF(IF .EQ. 6) THEN
             LINE = '    Natural Gas Total'
             IROW = IROW + 1
             if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
             WORK = ENPQTYTR(3,IGROUP)+ENPQTYTR(4,IGROUP) &
                   +ENPQTYTR(5,IGROUP)+ENPQTYTR(6,IGROUP)
             CALL cknum(I16,IROW,ICOL,dble(work),2,4)
           ENDIF
         ENDDO

         Line =  '          Total'
         IROW = IROW + 1
         if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
         CALL cknum(I16,IROW,ICOL,DBLE(TOTAL),2,4)

!  WRITE ENERGY CONSUMPTION FOR BSC COMPONENT.

         LINE = 'BOILER/STEAM/COGENERATION COMPONENT'
         IROW = IROW + 2
         if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)

         LINE = 'Energy Consumption for Boiler/Steam/Cogeneration' &
         // ' (Trillion BTU)'
         IROW = IROW + 2
         if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)

         TOTAL = 0.
         DO IF=1,22
           IF(ENSQTYT(IF,IGROUP).gt.0.0) then
             LINE = '  ' // FUELNAME(IF)
             IROW = IROW + 1
             if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
             CALL cknum(I16,IROW,ICOL,dble(ENSQTYT(IF,IGROUP)),2,4)
             TOTAL = TOTAL + ENSQTYT(IF,IGROUP)
           ENDIF
         ENDDO

         DO IF=1,8
           IF(BYPQTYTR(IF,IGROUP).ne.0.0) THEN
             LINE = '  ' // FUELNAME(IF+40)
             IROW = IROW + 1
             if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
             CALL cknum(I16,IROW,ICOL,dble(BYPQTYTR(IF,IGROUP)),2,4)
             TOTAL = TOTAL + BYPQTYTR(IF,IGROUP)
           ENDIF
         ENDDO

         DO IF=2,6
           IF(dble(BYPQTYTR(IF,IGROUP)).ne.0.) THEN
             LINE = '  ' // FUELNAME(IF+30)
             IROW = IROW + 1
             if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
             CALL cknum(I16,IROW,ICOL,dble(BYPQTYTI(IF,IGROUP)),2,4)
             TOTAL = TOTAL + BYPQTYTI(IF,IGROUP)
           ENDIF
         ENDDO

         Line =  '          Total'
         IROW = IROW + 1
         if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
         CALL cknum(I16,IROW,ICOL,dble(total),2,4)

!  WRITE STEAM GENERATION.

         LINE = 'Total Steam Generation (Tr. BTU)'
         IROW = IROW + 2
         if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
         CALL cknum(I16,IROW,ICOL,dble(STEMCURT(IGROUP)),2,4)
         LINE = '  CHP Steam Generation'
         IROW = IROW + 1
         if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
         CALL cknum(I16,IROW,icol,dble(COGSTEAMT(IGROUP)),2,4)

         LINE = '  Total Non-CHP Steam Generation'
         IROW = IROW + 1
         if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
         CALL cknum(I16,IROW,icol,dble(NONCOGSTEAMT(IGROUP)),2,4)

         LINE = '      Non-CHP Fossil Steam Generation'
         IROW = IROW + 1
         if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
         CALL cknum(I16,IROW,icol,dble(NONCOGFOSSTEAMT(IGROUP)),2,4)

         LINE = '      Non-CHP Biomass Steam Generation'
         IROW = IROW + 1
         if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
         CALL cknum(I16,IROW,icol,dble(BIOSTEAMT(IGROUP)),2,4)

!**********************************************************
!  WRITE ELECTRICITY/CHP  VARIABLES.
!**********************************************************

         LINE = 'ELECTRICITY CAPACITY, GENERATION, AND FUEL USE'
         IROW = IROW + 2
         if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)

         LINE = '  Generating Capacity (MW)'
         total=0.
         IROW = IROW + 1
         if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
          do if=1,4
           i=genorder(if)
           IROW = IROW + 1
           Line = genname(if)
           if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
           CALL cknum(I16,IROW,icol,dble(RPTCAPT(i,IGROUP)),2,4)
           TOTAL = TOTAL + RPTCAPT(i,IGROUP)
         enddo
         Line =  '          Total'
         IROW = IROW + 1
         if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
         CALL cknum(I16,IROW,ICOL,dble(total),2,4)

         Line = '  Generation (GWH)'
         Total=0.
         IROW = IROW + 1
         if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
          do if=1,4
           i=genorder(if)
           IROW = IROW + 1
           Line = genname(if)
           if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
           CALL cknum(I16,IROW,icol,dble(RPTGENT(i,IGROUP)),2,4)
           TOTAL = TOTAL + RPTGENT(i,IGROUP)
         enddo
         Line =  '          Total'
         IROW = IROW + 1
         if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
         CALL cknum(I16,IROW,ICOL,dble(total),2,4)

         Line = '    Own Use'
         IROW = IROW + 1
         if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
         CALL cknum(I16,IROW,icol,dble(ELOWNT(IGROUP)),2,4)

         Line = '    Grid Sales'
         IROW = IROW + 1
         if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
         CALL cknum(I16,IROW,icol,dble(ELSALET(IGROUP)),2,4)

         Line = '    Fuel Consumption (Trillion Btu)'
         TOTAL = 0.
         IROW = IROW + 1
         if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
         do if=1,4
           i=genorder(if)
           IROW = IROW + 1
           Line = genname(if)
           if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
           CALL cknum(I16,IROW,icol,dble(GENFUELT(i,IGROUP)),2,4)
           TOTAL = TOTAL + GENFUELT(i,IGROUP)
         enddo
         Line =  '          Total'
         IROW = IROW + 1
         if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
         CALL cknum(I16,IROW,ICOL,dble(total),2,4)


      ENDDO  ! of IGROUP=6,8
    ENDIF ! of if(GroupOpt.ne.1)


    IROW = (IROW/20)*20 +21
    if(GroupSel.eq.0) then
      LINE='Table 4.  NATIONAL AVERAGE BENCHMARK FACTORS'
      if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
      IROW = IROW + 2
      CALL ckint(I16,IROW,icol,curcalyr,0)

      DO IF=1,17
        irow=irow+1
        Line = benchvars(if)
        if(once)CALL ckstr(I16,IROW,1,LINE,1,0,1)
        CALL cknum(I16,IROW,ICOL,dble(benchfac(if,5)),2,4)
      enddo
! benchmark section.  Single table for each year, so write labels every time through and
! skip over previously written tables by starting at the ending row of the prior year.
      if(benchrow(GroupSel).eq.0) benchrow(GroupSel)=irow
      IROW = benchrow(GroupSel)+5
      WRITE(LINE,'(A,I4)') 'TABLE 4.  REGIONAL BENCHMARK FACTORS FOR ', curcalyr
      IROW = benchrow(GroupSel)+5
      CALL ckstr(I16,IROW,1,LINE,1,0,1)
      IROW = IROW + 2

      DO I=1,5
         WRITE(IRNAME,'(I2)') I
         if(i.eq.5) iRname='US'
         LINE = 'Region '//IRNAME
         CALL ckstr(I16,IROW,i+2,LINE,1,0,1)
      ENDDO

      IROW = IROW + 2
      DO IF=1,17
         LINE = BENCHVARS(IF)
         CALL ckstr(I16,IROW,1,LINE,1,0,1)
         CALL cknum(i16,IROW,3,dble(benchfac(if,1)),3,4)
         CALL cknum(i16,IROW,4,dble(benchfac(if,2)),3,4)
         CALL cknum(i16,IROW,5,dble(benchfac(if,3)),3,4)
         CALL cknum(i16,IROW,6,dble(benchfac(if,4)),3,4)
         CALL cknum(i16,IROW,7,dble(benchfac(if,5)),3,4)
         IROW = IROW + 1
      ENDDO

      benchrow(GroupSel)=irow
    endif


    OncePerGroup(GroupSel)=.false.

    if(curiyr.eq.lastyr) then
         irow=1
         read(i16,'(a)',rec=irow) longline
         nul=char(0)
         do while (.not. eof(i16))
            read(i16,'(a)',rec=irow,err=999) longline
            do i=1,irecl-2
              if(longline(i:i).eq.nul) longline(i:i)=' '
            enddo
            do i=irecl-2,1,-1
              if(longline(i:i).ne.','.and.longline(i:i).ne.' ') then
!                if(i.lt.irecl-2) longline(i+1:i+1)=','
                exit
              else
                if(longline(i:i).eq.',') then
                  longline(i:i)=' '
                endif
              endif
            enddo
            longline(irecl-1:irecl)=char(13)//char(10)
!            if(len_trim(longline(:irecl-2)).eq.0) then
!              longline(1:4)='" ",'
!            endif
            write(i16,'(a)',rec=irow) longline
999         continue
            irow=irow+1
         enddo

      CLOSE(I16)
    endif

    RETURN
1001  continue
    write(6,*) ' error opening ', trim(blnkfile)
    notopen=.true.
   END SUBROUTINE INDGRP
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
      SUBROUTINE motors
   use i_
      implicit none
      real acceptance
      external acceptance
      integer do_once/0/

!====================================

! Motor Model Variables, Currently for 10 industries: Food, Bulk Chemicals, FabMetals, Machinery, Computers,
! TranEquip, ElecEquip, Wood, Plastic, and BalOfMfg

! Global motorsizes see above
!     integer motorsizes           ! parameter--number of motor size classes for stock model
!     parameter(motorsizes=7)      ! Motor size groups: 1-5 hp, 6-20 hp, 21-50 hp, 51-100 hp, 101-200 hp, 201-500 hp, >500 hp
      integer ibbyr                ! Base year
      integer wkunit               ! input file unit number from file_mgr
      integer s,y,ps,t             ! Looping counters
!     integer NI                   ! number of industries programmed for motors
!     parameter(NI=10)
!     real    IndGO(MNUMYR,NI)     ! Industrial Gross Output
      real    disrate              ! Discount rate
      real    PVSav                ! Savings accumulator for time value of money
      real    ReMoYr, PEMoYr       ! Time (in yr) for payback
      real    IndElecP             ! Industrial Electricity Price (1987$/mbtu)
      real    tempm(motorsizes)
      real    IndShipGr(NI,dimreg,mnumyr)                ! Industrial Growth Rate
! Motor stock model inputs (some also outputs for # of projection years: base - end year)
      real    MotorStock(NI,motorsizes,dimreg,mnumyr)    ! Motor stock: NI industries, 7 motor sizes, # of model years (base - end year)
      real    MotAvgEnergy(NI,motorsizes,dimreg,mnumyr)  ! Motor average energy consumption: NI industries, 7 motor sizes, # of model years (base - end year)
      real    MotAvgEff(NI,motorsizes,dimreg,mnumyr)     ! Motor average energy efficiency: NI industries, 7 motor sizes, # of model years (base - end year)
      real    FailurePct(NI,motorsizes)           ! Percentage of motors failed: NI industries, 7 motor sizes
      real    MotRewDrop(NI,motorsizes)           ! Drop in efficiency for rewound motors: NI industries, 7 motor sizes
      real    MotSysLife(NI,motorsizes)           ! Motor system efficiency program life: NI industries, 7 motor sizes
      real    PumpAppPct(NI,motorsizes)           ! System efficiency applicability, % pumps: NI industries, 7 motor sizes
      real    FanAppPct(NI,motorsizes)            ! System efficiency applicability, % fans: NI industries, 7 motor sizes
      real    CompAppPct(NI,motorsizes)           ! System efficiency applicability, % compressors: NI industries, 7 motor sizes
      real    PumpSavPct(NI,motorsizes)           ! System efficiency savings fraction, pumps: NI industries, 7 motor sizes
      real    FanSavPct(NI,motorsizes)            ! System efficiency savings fraction, fans: NI industries, 7 motor sizes
      real    CompSavPct(NI,motorsizes)           ! System efficiency savings fraction, compressors: NI industries, 7 motor sizes

! HiTech Motor stock model inputs (some also outputs for projection years: 2003 - endyr)
      real    HiFailurePct(NI,motorsizes)         ! Percentage of motors failed: NI industries, 7 motor sizes
      real    HiMotRewDrop(NI,motorsizes)         ! Drop in efficiency for rewound motors: NI industries, 7 motor sizes
      real    HiMotSysLife(NI,motorsizes)         ! Motor system efficiency program life: NI industries, 7 motor sizes
      real    HiPumpAppPct(NI,motorsizes)         ! System efficiency applicability, % pumps: NI industries, 7 motor sizes
      real    HiFanAppPct(NI,motorsizes)          ! System efficiency applicability, % fans: NI industries, 7 motor sizes
      real    HiCompAppPct(NI,motorsizes)         ! System efficiency applicability, % compressors: NI industries, 7 motor sizes
      real    HiPumpSavPct(NI,motorsizes)         ! System efficiency savings fraction, pumps: NI industries, 7 motor sizes
      real    HiFanSavPct(NI,motorsizes)          ! System efficiency savings fraction, fans: NI industries, 7 motor sizes
      real    HiCompSavPct(NI,motorsizes)         ! System efficiency savings fraction, compressors: NI industries, 7 motor sizes

! FrzTech Motor stock model inputs (some also outputs for projection years: 2003 - endyr)
      real    FrzFailurePct(NI,motorsizes)        ! Percentage of motors failed: NI industries, 7 motor sizes
      real    FrzMotRewDrop(NI,motorsizes)        ! Drop in efficiency for rewound motors: NI industries, 7 motor sizes
      real    FrzMotSysLife(NI,motorsizes)        ! Motor system efficiency program life: NI industries, 7 motor sizes
      real    FrzPumpAppPct(NI,motorsizes)        ! System efficiency applicability, % pumps: NI industries, 7 motor sizes
      real    FrzFanAppPct(NI,motorsizes)         ! System efficiency applicability, % fans: NI industries, 7 motor sizes
      real    FrzCompAppPct(NI,motorsizes)        ! System efficiency applicability, % compressors: NI industries, 7 motor sizes
      real    FrzPumpSavPct(NI,motorsizes)        ! System efficiency savings fraction, pumps: NI industries, 7 motor sizes
      real    FrzFanSavPct(NI,motorsizes)         ! System efficiency savings fraction, fans: NI industries, 7 motor sizes
      real    FrzCompSavPct(NI,motorsizes)        ! System efficiency savings fraction, compressors: NI industries, 7 motor sizes

! Inputs for motor cost/performance choice model
      real    IndElecPrice(dimreg,mnumyr)   ! Industrial Electricity Price (2002 cents/kwh)
      real    MotorHP(NI,motorsizes)         ! Rated motor horsepower: NI industries, 7 motor sizes
      real    AvgPartLoad(NI,motorsizes)     ! Average motor part load: NI industries, 7 motor sizes
      real    MotorOpHr(NI,motorsizes)       ! Annual operating hours: NI industries, 7 motor sizes
      real    EEPctEff(NI,motorsizes)        ! Efficiency rating for basic motor: NI industries, 7 motor sizes
!     real    PEPctEff(NI,motorsizes-1)      ! Efficiency rating for "premium" motor: NI industries, 7 motor sizes
      real    PEPctEff(NI,motorsizes)      ! Efficiency rating for "premium" motor: NI industries, 7 motor sizes
      real    HPtoKW                        ! Conversion factor from horsepower to kilowatts
      real    RewindCost(NI,motorsizes)      ! Cost to rewind failed motors: 7 motor sizes
      real    EEListPrice(NI,motorsizes)     ! Purchase price for EPACT minimum (up to 200 hp) or standard efficiency motors: 7 motor sizes
!     real    PEListPrice(NI,motorsizes-1)   ! Purchase price for premium efficiency motors (up to 200 hp): 5 motor sizes (2 largest n/a)
      real    PEListPrice(NI,motorsizes)     ! Purchase price for premium efficiency motors (up to 200 hp): 5 motor sizes (2 largest n/a)
      real    DealerDisc(1,motorsizes)      ! Dealer discount on motor purchases, both EPACT and premium efficiency: 7 motor sizes
      real    PremAccept(20)                ! Payback acceptance curve for premium motor purchase

! HiTech Inputs for motor cost/performance choice model
      real    HiEEPctEff(NI,motorsizes)      ! Efficiency rating for basic motor: NI industries, 7 motor sizes
!     real    HiPEPctEff(NI,motorsizes-1)    ! Efficiency rating for "premium" motor: NI industries, 7 motor sizes
      real    HiPEPctEff(NI,motorsizes)      ! Efficiency rating for "premium" motor: NI industries, 7 motor sizes
      real    HiRewindCost(NI,motorsizes)    ! Cost to rewind failed motors: 7 motor sizes
      real    HiEEListPrice(NI,motorsizes)   ! Purchase price for EPACT minimum (up to 200 hp) or standard efficiency motors: 7 motor sizes
!     real    HiPEListPrice(NI,motorsizes-1) ! Purchase price for premium efficiency motors (up to 200 hp): 5 motor sizes (2 largest n/a)
      real    HiPEListPrice(NI,motorsizes)   ! Purchase price for premium efficiency motors (up to 200 hp): 5 motor sizes (2 largest n/a)
      real    HiDealerDisc(1,motorsizes)    ! Dealer discount on motor purchases, both EPACT and premium efficiency: 7 motor sizes
      real    HiPremAccept(20)              ! Payback acceptance curve for premium motor purchase

! FrzTech Inputs for motor cost/performance choice model
      real    FrzEEPctEff(NI,motorsizes)     ! Efficiency rating for basic motor: NI industries, 7 motor sizes
!     real    FrzPEPctEff(NI,motorsizes-1)   ! Efficiency rating for "premium" motor: NI industries, 7 motor sizes
      real    FrzPEPctEff(NI,motorsizes)     ! Efficiency rating for "premium" motor: NI industries, 7 motor sizes
      real    FrzRewindCost(NI,motorsizes)   ! Cost to rewind failed motors: 7 motor sizes
      real    FrzEEListPrice(NI,motorsizes)  ! Purchase price for EPACT minimum (up to 200 hp) or standard efficiency motors: 7 motor sizes
!     real    FrzPEListPrice(NI,motorsizes-1)! Purchase price for premium efficiency motors (up to 200 hp): 5 motor sizes (2 largest n/a)
      real    FrzPEListPrice(NI,motorsizes)  ! Purchase price for premium efficiency motors (up to 200 hp): 5 motor sizes (2 largest n/a)
      real    FrzDealerDisc(1,motorsizes)   ! Dealer discount on motor purchases, both EPACT and premium efficiency: 7 motor sizes
      real    FrzPremAccept(20)             ! Payback acceptance curve for premium motor purchase

! Motor cost/performance choice model variables
      real    CopyArray(NI,motorsizes-1)
      real    ReplaceAnnSav(NI,motorsizes,dimreg,MNUMYR) ! Expected annual 2002$ savings from purchase of EPACT motor instead of repairing: NI industries, 7 motor sizes, 28 years
      real    ReplacePrPrem(NI,motorsizes)        ! Price premium, 2002$, EPACT minimum efficiency over rewinding motor: 7 motor sizes (2 largest n/a)
      real    ReplacePayback(NI,motorsizes,dimreg,mnumyr)! Payback, in years, for replacing motors: NI industries, 7 motor sizes, # of model years (base - end year)
      real    ReplaceAccept(NI,motorsizes,dimreg,mnumyr)! Interpolated acceptance fraction: NI industries, 7 motor sizes, # of model years (base - end year)
!      real    PEAnnSav(NI,motorsizes-1,dimreg,mnumyr) ! Expected annual 2002$ savings from purchase of premium motor: NI industries, 6 motor sizes (largest n/a), # of model years (base - end year)
!      real    PEPrPrem(NI,motorsizes-1)        ! Price premium, 2002$, premium efficiency over minimum efficiency motor: 6 motor sizes (largest n/a)
!      real    PEPayback(NI,motorsizes-1,dimreg,mnumyr)! Payback, in years, for premium efficiency motors: NI industries, 6 motor sizes (largest n/a), # of model years (base - end year)
      real    PEAnnSav(NI,motorsizes,dimreg,mnumyr) ! Expected annual 2002$ savings from purchase of premium motor: NI industries, 6 motor sizes (largest n/a), # of model years (base - end year)
      real    PEPrPrem(NI,motorsizes)        ! Price premium, 2002$, premium efficiency over minimum efficiency motor: 6 motor sizes (largest n/a)
      real    PEPayback(NI,motorsizes,dimreg,mnumyr)! Payback, in years, for premium efficiency motors: NI industries, 6 motor sizes (largest n/a), # of model years (base - end year)
      real    MotAccept(NI,motorsizes,dimreg,mnumyr)!th4 Interpolated acceptance fraction: NI industries, 7 (not 6) motor sizes (largest n/a), # of model years (base - end year)
!     real    MotAccept(NI,motorsizes-1,dimreg,mnumyr)! Interpolated acceptance fraction: NI industries, 6 motor sizes (largest n/a), # of model years (base - end year)

! Motor stock model variables
      real    FailedMotors(NI,motorsizes,dimreg,mnumyr)       ! Number of failed motors: NI industries, 7 motor sizes, # of model years (base - end year)
      real    RepMotorFlow(NI,motorsizes,dimreg,mnumyr)       ! Number of failed motors replaced: NI industries, 7 motor sizes, # of model years (base - end year)
      real    TotalMotorFlow(NI,motorsizes,dimreg,mnumyr)     ! Number of motors purchased: NI industries, 7 motor sizes, # of model years (base - end year)
      real    GrowthMotorFlow(NI,motorsizes,dimreg,mnumyr)    ! Number of motors purchased to satisfy growth: NI industries, 7 motor sizes, # of model years (base - end year)
      real    EffMotorFlow(NI,motorsizes,dimreg,mnumyr)       ! Number of efficient motors purchased: NI industries, 7 motor sizes, # of model years (base - end year)
      real    PremMotorFlow(NI,motorsizes,dimreg,mnumyr)      ! Number of premium motors purchased: NI industries, 7 motor sizes, # of model years (base - end year)
      real    RewoundMotors(NI,motorsizes,dimreg,mnumyr)      ! Number of rewound motors: NI industries, 7 motor sizes, # of model years (base - end year)
      real    RetiredMotors(NI,motorsizes,dimreg,mnumyr)      ! Number of retired motors: NI industries, 7 motor sizes, # of model years (base - end year)
      real    NewMotorEff(NI,motorsizes,dimreg,mnumyr)        ! Efficiency of new motors: NI industries, 7 motor sizes, # of model years (base - end year)
      real    RewoundEff(NI,motorsizes,dimreg,mnumyr)         ! Efficiency of rewound motors: NI industries, 7 motor sizes, # of model years (base - end year)
      real    NewMotorEnergy(NI,motorsizes,dimreg,mnumyr)     ! Average energy of new motors: NI industries, 7 motor sizes, # of model years (base - end year)
      real    RewMotorEnergy(NI,motorsizes,dimreg,mnumyr)     ! Average energy of rewound motors: NI industries, 7 motor sizes, # of model years (base - end year)
      real    MotAdjEnergy(NI,motorsizes,dimreg,mnumyr)       ! Adjusted average energy consumption of motor stock: NI industries, 7 motor sizes, # of model years (base - end year)
      real    TotalMotorEnergy(NI,motorsizes+1,dimreg,mnumyr) ! Total motor energy consumption: NI industries, 7 motor sizes + total, # of model years (base - end year)
!      real    TotAdjMotorEnergy(NI+1,motorsizes+1,dimreg,mnumyr)! Total adjusted energy consumption: NI industries, 7 motor sizes + total, # of model years (base - end year)
      real    SystemSavingsR(NI,motorsizes)                    ! Overall savings from fan, pump, and compressor system improvements: NI industries, 7 motor sizes
      real    jfracm,mscalel,totqm                             ! Variables 'borrowed' from calgen
      integer l,m                                   ! (pyear) Variables 'borrowed' from calgen

      integer rtovalue   ! POT_MOTOR eliminate nrg2007

      character*6 nmit(NI)
      integer imit(NI)
      integer do_one/0/
      save do_one

      nmit=(/'Food','BChem','FabMet','Machin','Comput','TranEq','ElecEq', &
        'WoodPr','Plasti','BOMOth'/)

      imit=(/7,9,14,15,16,17,18,19,20,21/)
      do i=1,NI
        if(imit(i).eq.inddir) then
          mind=i
          exit ! exit do loop
        endif
      enddo

      ibbyr=ibyr2-baseyr+1

    ! POT_MOTOR eliminate nrg2007=RTOVALUE("NRG2007 ",0)

      if(do_one.eq.0) then
         do_one=1
         NEW=.FALSE.
         FNAME='INDMOTORX'  !  indmotorx.xlsx


!  OPEN WORKSHEET FILE USING FILE MANAGER
         WKUNIT = FILE_MGR('O',FNAME,NEW)

!  CALL SUBROUTINE TO READ ALL DEFINED RANGES FROM WORKSHEET
!  This stores the ranges in a temporary data area that can
!  get overwritten by the next model if they use it.  So all
!  ranges have to be extracted from the temporary area immediately.

         CALL ReadRngXLSX(WKUNIT,'motors')  ! read range names and corresponding data from indmotorx.xlsx, worksheet "motors"
!  CLOSE WORKSHEET FILE
        WKUNIT = FILE_MGR('C',FNAME,NEW)
!  Copy each range from worksheet data area to variables
!  GETRNGI : Copies an Integer*2 variable from the worksheet
!            data area into the variable.  The variable
!            dimensions are passed as the 3rd,4th,&5th
!            arguments, (eg, ... 1,1,1).
!            A variable with dimensions of 1,1,1 is a scalar.
!            A variable with dimensions of 26,1,1 is a one-
!            dimensional array with 26 elements.
!  GETRNGR:  Copies a REAL variable from the worksheet
!            data area into the variable.

! Other NEMS module variables, read from worksheet for now, replace with common variables
! Assign year parameters



! Motor stock model inputs (some also outputs for projection years: 2003 - endyr)
         call getrngr('MOTORSTOCKREG   ',MotorStock(1,1,1,ibbyr),NI,motorsizes,4)

         call getrngr('AVGENERGY       ',MotAvgEnergy(1,1,1,ibbyr),NI,motorsizes,1)
         Motavgenergy(:,:,2,ibbyr)=Motavgenergy(:,:,1,ibbyr)
         Motavgenergy(:,:,3,ibbyr)=Motavgenergy(:,:,1,ibbyr)
         Motavgenergy(:,:,4,ibbyr)=Motavgenergy(:,:,1,ibbyr)

         call getrngr('AVGEFF          ',MotAvgEff(1,1,1,ibbyr),NI,motorsizes,1)
         MotAvgEff(:,:,2,ibbyr)=MotAvgEff(:,:,1,ibbyr)
         MotAvgEff(:,:,3,ibbyr)=MotAvgEff(:,:,1,ibbyr)
         MotAvgEff(:,:,4,ibbyr)=MotAvgEff(:,:,1,ibbyr)

         call getrngr('FAILUREPCT      ',FailurePct,NI,motorsizes,1)
         call getrngr('REWINDDROP      ',MotRewDrop,NI,motorsizes,1)
         call getrngr('SYSLIFE         ',MotSysLife,NI,motorsizes,1)
         call getrngr('PUMPAPPL        ',PumpAppPct,NI,motorsizes,1)
         call getrngr('FANAPPL         ',FanAppPct,NI,motorsizes,1)
         call getrngr('COMPAPPL        ',CompAppPct,NI,motorsizes,1)
         call getrngr('PUMPSAV         ',PumpSavPct,NI,motorsizes,1)
         call getrngr('FANSAV          ',FanSavPct,NI,motorsizes,1)
         call getrngr('COMPSAV         ',CompSavPct,NI,motorsizes,1)

! HiTech Motor stock model inputs (some also outputs for projection years: 2003 - endyr)
!       if (hitech.eq.1) then

         call getrngr('HIFAILUREPCT    ',HiFailurePct,NI,motorsizes,1)
         call getrngr('HIREWINDDROP    ',HiMotRewDrop,NI,motorsizes,1)
         call getrngr('HISYSLIFE       ',HiMotSysLife,NI,motorsizes,1)
         call getrngr('HIPUMPAPPL      ',HiPumpAppPct,NI,motorsizes,1)
         call getrngr('HIFANAPPL       ',HiFanAppPct,NI,motorsizes,1)
         call getrngr('HICOMPAPPL      ',HiCompAppPct,NI,motorsizes,1)
         call getrngr('HIPUMPSAV       ',HiPumpSavPct,NI,motorsizes,1)
         call getrngr('HIFANSAV        ',HiFanSavPct,NI,motorsizes,1)
         call getrngr('HICOMPSAV       ',HiCompSavPct,NI,motorsizes,1)

! FrzTech Motor stock model inputs (some also outputs for projection years: 2003 - endyr)
!       elseif (frztech.eq.1) then

         call getrngr('FRZFAILUREPCT   ',FrzFailurePct,NI,motorsizes,1)
         call getrngr('FRZREWINDDROP   ',FrzMotRewDrop,NI,motorsizes,1)
         call getrngr('FRZSYSLIFE      ',FrzMotSysLife,NI,motorsizes,1)
         call getrngr('FRZPUMPAPPL     ',FrzPumpAppPct,NI,motorsizes,1)
         call getrngr('FRZFANAPPL      ',FrzFanAppPct,NI,motorsizes,1)
         call getrngr('FRZCOMPAPPL     ',FrzCompAppPct,NI,motorsizes,1)
         call getrngr('FRZPUMPSAV      ',FrzPumpSavPct,NI,motorsizes,1)
         call getrngr('FRZFANSAV       ',FrzFanSavPct,NI,motorsizes,1)
         call getrngr('FRZCOMPSAV      ',FrzCompSavPct,NI,motorsizes,1)

!       endif

! Inputs for motor cost/performance choice model
         call getrngr('MOTORHP         ',MotorHP,NI,motorsizes,1)
         call getrngr('PARTLOAD        ',AvgPartLoad,NI,motorsizes,1)
         call getrngr('OPERHOURS       ',MotorOpHr,NI,motorsizes,1)
         call getrngr('EEPCTEFF        ',EEPctEff,NI,motorsizes,1)
         call getrngr('PEPCTEFF        ',PEPctEff,NI,motorsizes-1,1)
         call getrngr('REWINDCOST      ',RewindCost,NI,motorsizes,1)
         call getrngr('EELISTPRICE     ',EEListPrice,NI,motorsizes,1)
         call getrngr('PELISTPRICE     ',PEListPrice,NI,motorsizes-1,1)
         call getrngr('DEALERDISC      ',DealerDisc,1,motorsizes,1)
         call getrngr('HPTOKW          ',HPtoKW,1,1,1)
         call getrngr('PREMACCEPT      ',PremAccept,1,20,1)

! HiTech Inputs for motor cost/performance choice model
!       if (hitech.eq.1) then

         call getrngr('HIEEPCTEFF      ',HiEEPctEff,NI,motorsizes,1)
         call getrngr('HIPEPCTEFF      ',HiPEPctEff,NI,motorsizes-1,1)
         call getrngr('HIREWINDCOST    ',HiRewindCost,NI,motorsizes,1)
         call getrngr('HIEELISTPRICE   ',HiEEListPrice,NI,motorsizes,1)
         call getrngr('HIPELISTPRICE   ',HiPEListPrice,NI,motorsizes-1,1)
         call getrngr('HIDEALERDISC    ',HiDealerDisc,1,motorsizes,1)
         call getrngr('HIPREMACCEPT    ',HiPremAccept,1,20,1)

! FrzTech Inputs for motor cost/performance choice model

         call getrngr('FRZEEPCTEFF     ',FrzEEPctEff,NI,motorsizes,1)
         call getrngr('FRZPEPCTEFF     ',FrzPEPctEff,NI,motorsizes-1,1)
         call getrngr('FRZREWINDCOST   ',FrzRewindCost,NI,motorsizes,1)
         call getrngr('FRZEELISTPRICE  ',FrzEEListPrice,NI,motorsizes,1)
         call getrngr('FRZPELISTPRICE  ',FrzPEListPrice,NI,motorsizes-1,1)
         call getrngr('FRZDEALERDISC   ',FrzDealerDisc,1,motorsizes,1)
         call getrngr('FRZPREMACCEPT   ',FrzPremAccept,1,20,1)

       endif

       ID=11
       y=curiyr

      IF(INDREG.EQ.1) THEN
        L = 1
        M = 2
      ELSE IF(INDREG.EQ.2) THEN
        L = 3
        M = 4
      ELSE IF(INDREG.EQ.3) THEN
        L = 5
        M = 7
      ELSE IF(INDREG.EQ.4) THEN
        L = 8
        M = 9
      ENDIF

! Estimate economic attractiveness of typical motor systems for various steam loads.
!   1) Assign Projection of next few years' price in 2002 dollars for motor evaluation
        IndElecP=0.
        jfracm=0.

!        pyear=curcalyr
        y=curiyr

!       lookahead=0                      ! assume myopic--zero future years considered
        jfracm=1./(1.+float(lookahead))  ! used for price averaging over the current and "lookahead" years
        do j=0,lookahead                 ! loop over current year and once for each lookahead year
          mscalel=0.
          totqm=0.
          do i=L,M  ! get average escalation across divisions in this region
            totqm=totqm+QELIN(i,y)
          enddo
          do i=L,M
            mscalel=mscalel+ &
               (aELIN(i,MIN(ijumpyr,y+j))/aELIN(i,y)) &
               * qelin(i,y)/totqm
          enddo

! Use industry specific electricity prices based on load characteristics:
! 23:  from pelinp (primary industry--lowest prices)
! 24:  from pelins (shift industry - medium prices)
! 25:  from pelinm (miscellaneous industry--highest prices)
          i=mind ! i will be the industry from 1 to NI
          if(i.eq.1.or.i.eq.2) then
            IndElecP=IndElecP+PRCX(23,INDREG,3)*mscalel ! $87/mmbtu
          elseif(i.GE.3.and.i.le.7) then
            IndElecP=IndElecP+PRCX(24,INDREG,3)*mscalel ! $87/mmbtu
          elseif(i.ge.8.and.i.le.10) then
            IndElecP=IndElecP+PRCX(25,INDREG,3)*mscalel ! $87/mmbtu
          endif
        enddo

! Convert electricity prices from 1987$/mbtu to 2002 dollars/kwh for use in choice algorithms

         IndElecPrice(indreg,y) = ((IndElecP * 3412.) / 1000000.) * jfracm * MC_JPGDP(2002-baseyr+1)

        if(y.eq.ibbyr) then
! Calculate motor electricity use for base year



          TotalMotorEnergy(i,1:motorsizes+1,indreg,y)  = 0.
          TotAdjMotorEnergy(i,1:motorsizes+1,indreg,y) = 0.

          do s=1,7

           TotalMotorEnergy(i,s,indreg,y)  = TotalMotorEnergy(i,s,indreg,y) + &
                                      ((MotorStock(i,s,indreg,y) * MotAvgEnergy(i,s,indreg,y)) * 3412.) / 10.**12
           TotAdjMotorEnergy(i,s,indreg,y) = TotalMotorEnergy(i,s,indreg,y)
           TotalMotorEnergy(i,motorsizes+1,indreg,y)  =   TotalMotorEnergy(i,motorsizes+1,indreg,y)   &
                                    + TotalMotorEnergy(i,s,indreg,y)
           TotAdjMotorEnergy(i,motorsizes+1,indreg,y) = TotAdjMotorEnergy(i,motorsizes+1,indreg,y)    &
                                    + TotAdjMotorEnergy(i,s,indreg,y)

           MotAdjEnergy(i,s,indreg,y)                 = MotAvgEnergy(i,s,indreg,y)

          enddo

        else ! past base year
! POT_MOTOR eliminate the code to go to some HITECH data when NRG2007 is equal to 1


! Copy HiTech Motor Model Assumptions if a HiTech Run

       if (curcalyr.eq.techstrtyr.and.curitr.eq.1) then
         if (hitech.eq.1) then

! Print assumptions before change to hitech
!        if(prtdbgi.ge.2) then
!          write(7,'(///a)') 'Reference Case Assumptions'

!            write(7,'(1x,a)') 'Percentage of Motors Rewound Upon Failure'
!               write(7,500) y,indreg,inddir,(MotRewPct(i,s),s=1,7)

!            write(7,'(1x,a)') 'Drop in Efficiency when Rewound'
!               write(7,500) y,indreg,inddir,(MotRewDrop(i,s),s=1,7)

!            write(7,'(1x,a)') 'Percentage of Motors Retired Upon Failure'
!               write(7,500) y,indreg,inddir,(MotRetPct(i,s),s=1,7)

!            write(7,'(1x,a)') 'Premium Motor Payback Acceptance Curve'
!               write(7,504) y,indreg,inddir,(PremAccept(s),s=1,20)

!        endif

! HiTech Motor stock model inputs (some also outputs for projection years: 2003 - endyr)
         FailurePct = HiFailurePct

         MotRewDrop = HiMotRewDrop

         MotSysLife = HiMotSysLife

         PumpAppPct = HiPumpAppPct

         FanAppPct  = HiFanAppPct

         CompAppPct = HiCompAppPct

         PumpSavPct = HiPumpSavPct

         FanSavPct  = HiFanSavPct

         CompSavPct = HiCompSavPct

! HiTech Inputs for motor cost/performance choice model
         EEPctEff     = HiEEPctEff

         PEPctEff     = HiPEPctEff

         RewindCost   = HiRewindCost

         EEListPrice  = HiEEListPrice

         PEListPrice  = HiPEListPrice

         DealerDisc   = HiDealerDisc

         PremAccept   = HiPremAccept

! Print assumptions after change to hitech
!        if(prtdbgi.ge.2) then
!          write(7,'(///a)') 'Reference Case Assumptions'

!            write(7,'(1x,a)') 'Percentage of Motors Rewound Upon Failure'
!               write(7,500) y,indreg,inddir,(MotRewPct(i,s),s=1,7)

!            write(7,'(1x,a)') 'Drop in Efficiency when Rewound'
!               write(7,500) y,indreg,inddir,(MotRewDrop(i,s),s=1,7)

!            write(7,'(1x,a)') 'Percentage of Motors Retired Upon Failure'
!               write(7,500) y,indreg,inddir,(MotRetPct(i,s),s=1,7)

!            write(7,'(1x,a)') 'Premium Motor Payback Acceptance Curve'
!               write(7,504) y,indreg,inddir,(PremAccept(s),s=1,20)

!        endif

! Copy FrzTech Motor Model Assumptions if a FrzTech Run

         elseif (frztech.eq.1) then

! FrzTech Motor stock model inputs (some also outputs for projection years: 2003 - endyr)

         FailurePct = FrzFailurePct

         MotRewDrop = FrzMotRewDrop

         MotSysLife = FrzMotSysLife

         PumpAppPct = FrzPumpAppPct

         FanAppPct  = FrzFanAppPct

         CompAppPct = FrzCompAppPct

         PumpSavPct = FrzPumpSavPct

         FanSavPct  = FrzFanSavPct

         CompSavPct = FrzCompSavPct

! FrzTech Inputs for motor cost/performance choice model

         EEPctEff     = FrzEEPctEff

         PEPctEff     = FrzPEPctEff

         RewindCost   = FrzRewindCost

         EEListPrice  = FrzEEListPrice

         PEListPrice  = FrzPEListPrice

         DealerDisc   = FrzDealerDisc

         PremAccept   = FrzPremAccept

        endif

       endif

! Cost/Performance choice model for repair/replace decision for failed motors.  Choice is
! between repairing (rewinding) the motor and replacing with an EPACT minimum efficiency
! motor.  Used to allocate FailedMotors to the two efficiency groups.  Get Economic Fraction
! based on the Payback Acceptance Curve.  The evaluation is made for all motor size groups.

           i=mind ! i is the industry number from 1 to NI
           do s=1,7 ! all 7 motor size groups
             RewoundEff(i,s,indreg,y)     = MotAvgEff(i,s,indreg,y-1) - MotRewDrop(i,s)
             ReplaceAnnSav(i,s,indreg,y)  = MotorHP(i,s) * AvgPartLoad(i,s) * HPtoKW * MotorOpHr(i,s) &
                         * IndElecPrice(indreg,y) * ((1 / RewoundEff(i,s,indreg,y)) - (1 / EEPctEff(i,s)))
             ReplacePrPrem(i,s)           = EEListPrice(i,s) * (1 - DealerDisc(1,s)) - RewindCost(i,s)
             if (ReplaceAnnSav(i,s,indreg,y) .le. 0.05) then
               ReplacePayback(i,s,indreg,y)= 0.  ! keeps running when no motors in a size class (MotorOpHr=0) bul 4/27/06
             else
             ! Use new economic choice model, ROI breakeven period rather than payback
             ! variables have been kept as "payback" to keep it simple and because the acceptance curve still holds
               ReplacePayback(i,s,indreg,y)=20.  ! POT_MOTOR 99 to 20
               PVSav=0
               t=0
               disrate=(MC_RMTCM10Y(curiyr) &                 ! Nominal discount rate is 10 yr treasury rate
                        -((MC_CPI(11,curiyr)/MC_CPI(11,curiyr-1))-1)*100 &  ! convert to real rate
                        +2.)/100.                             ! plus a 2% ref risk premium
               DO t=1,20   ! Any breakeven greater than 99 years stinks POT_MOTOR 99 to 20
                  ReMoYr=real(t)
                  PVSav=(ReplaceAnnSav(i,s,indreg,y)/((1+disrate)**ReMoYr))+PVSav
                  IF (PVSav .ge. ReplacePrPrem(i,s)) THEN
                     ReplacePayback(i,s,indreg,y)=ReMoYr-(PVSav-ReplacePrPrem(i,s))/(ReplaceAnnSav(i,s,indreg,y)/((1+disrate)**ReMoYr))
                     EXIT
                  ENDIF
               ENDDO
             ! IF (t .gt. 20) THEN
             !    ReplacePayback(i,s,indreg,y)=99.
             ! ENDIF
             ! ReplacePayback(i,s,indreg,y) = ReplacePrPrem(i,s) / ReplaceAnnSav(i,s,indreg,y)   ***Old econ calc***
             endif

             if (ReplacePayback(i,s,indreg,y) .le. 0.05) then
                ReplaceAccept(i,s,indreg,y)= 0.
             else
                ReplaceAccept(i,s,indreg,y) = Acceptance(PremAccept(1),20,ReplacePayback(i,s,indreg,y))
             endif
           enddo

! calculation of current motor stock:

         i=mind ! i is the industry number from 1 to NI
         do s=1,7
           FailedMotors(i,s,indreg,y)    = MotorStock(i,s,indreg,y-1) * FailurePct(i,s)
           RepMotorFlow(i,s,indreg,y)    = FailedMotors(i,s,indreg,y) * ReplaceAccept(i,s,indreg,y)
           RewoundMotors(i,s,indreg,y)   = FailedMotors(i,s,indreg,y) - RepMotorFlow(i,s,indreg,y)
           IndShipGr(i,indreg,y)         = (prodvx/prodvxlag)-1.              !(IndGO(y,i) / IndGO(y-1,i)-1.)
           GrowthMotorFlow(i,s,indreg,y) = MotorStock(i,s,indreg,y-1) * IndShipGr(i,indreg,y)
           TotalMotorFlow(i,s,indreg,y)  = GrowthMotorFlow(i,s,indreg,y) + RepMotorFlow(i,s,indreg,y)
           MotorStock(i,s,indreg,y)      = MotorStock(i,s,indreg,y-1) - FailedMotors(i,s,indreg,y) &
                                         + RewoundMotors(i,s,indreg,y) + TotalMotorFlow(i,s,indreg,y)
         enddo


! Cost/Performance choice model for motor purchases.  Choice is between an EPACT minimum
! efficiency motor and a NEMA premium efficiency motor for motors up to 500 hp.  Used to
! allocate TotalMotorFlow to the two efficiency groups.  Get Economic Fraction based on
! the Payback Acceptance Curve.  The evaluation is only made for motors up to 500 hp
! because there is no NEMA premium efficiency motor specified for motors larger than 500 hp.

           i=mind ! i is the industry number from 1 to NI
           do s=1,6 ! no premium option for the largest size
             PEAnnSav(i,s,indreg,y)  = MotorHP(i,s) * AvgPartLoad(i,s) * HPtoKW * MotorOpHr(i,s) &
                         * IndElecPrice(indreg,y) * ((1 / EEPctEff(i,s)) - (1 / PEPctEff(i,s)))
             PEPrPrem(i,s)           = (PEListPrice(i,s) - (EEListPrice(i,s)) * (1 - DealerDisc(1,s)))
             if (PEAnnSav(i,s,indreg,y) .le. 0.05) then
               PEPayback(i,s,indreg,y)= 0.  ! keeps running when no motors in a size class (MotorOpHr=0) bul 4/27/06
             else
             ! Use new economic choice model, ROI breakeven period rather than payback
             ! variables have been kept as "payback" to keep it simple and because the acceptance curve still holds
               PEPayback(i,s,indreg,y)=20.  ! POT_MOTOR 99 to 20
               PVSav=0
               t=0
               disrate=(MC_RMTCM10Y(curiyr) &                 ! Nominal discount rate is 10 yr treasury rate
                        -((MC_CPI(11,curiyr)/MC_CPI(11,curiyr-1))-1)*100 &  ! convert to real rate
                        +2.)/100.                             ! plus a 2% ref risk premium
               DO t=1,20   ! Any breakeven greater than 99 years stinks  POT_MOTOR 99 to 20
                  PEMoYr=REAL(t)
                  PVSav=(PEAnnSav(i,s,indreg,y)/((1+disrate)**PEMoYr))+PVSav
                  IF (PVSav .ge. PEPrPrem(i,s)) THEN
                     PEPayback(i,s,indreg,y)=PEMoYr-(PVSav-PEPrPrem(i,s))/(PEAnnSav(i,s,indreg,y)/((1+disrate)**PEMoYr))
                     EXIT
                  ENDIF
               ENDDO
             ! IF (t .gt. 20) THEN
             !    PEPayback(i,s,indreg,y)=99.
             ! ENDIF
             ! PEPayback(i,s,indreg,y) = PEPrPrem(i,s) / PEAnnSav(i,s,indreg,y)   ***Old econ calc***
             endif

             if (PEPayback(i,s,indreg,y) .le. 0.05) then
                MotAccept(i,s,indreg,y)= 0.
             else
                MotAccept(i,s,indreg,y) = Acceptance(PremAccept(1),20,PEPayback(i,s,indreg,y))
             endif
         enddo
         MotAccept(i,motorsizes,indreg,y) = 0.  !th4 7th one has no premium counterpart



! Motor stock model calculations


          TotalMotorEnergy(i,1:motorsizes+1,indreg,y)  = 0.
          TotAdjMotorEnergy(i,1:motorsizes+1,indreg,y) = 0.

          do s=1,7
           PremMotorFlow(i,s,indreg,y)  = TotalMotorFlow(i,s,indreg,y) * MotAccept(i,s,indreg,y)
           EffMotorFlow(i,s,indreg,y)   = TotalMotorFlow(i,s,indreg,y) - PremMotorFlow(i,s,indreg,y)
            if(TotalMotorFlow(i,s,indreg,y).gt.0) then !th4 ijumpcalyr
              NewMotorEff(i,s,indreg,y)    = ((EEPctEff(i,s) * EffMotorFlow(i,s,indreg,y))      &
                         + (PEPctEff(i,s) * PremMotorFlow(i,s,indreg,y))) / TotalMotorFlow(i,s,indreg,y)
              NewMotorEnergy(i,s,indreg,y) = MotAdjEnergy(i,s,indreg,y-1) * (1. - ((NewMotorEff(i,s,indreg,y)          &
                         - MotAvgEff(i,s,indreg,y-1)) / NewMotorEff(i,s,indreg,y)))
            else
             NewMotorEff(i,s,indreg,y)=MotAvgEff(i,s,indreg,y-1)  ! Not Zero
             NewMotorEnergy(i,s,indreg,y)=0.0
            endif
           RewMotorEnergy(i,s,indreg,y) = MotAdjEnergy(i,s,indreg,y-1) * (1. - ((RewoundEff(i,s,indreg,y)                   &
                         - MotAvgEff(i,s,indreg,y-1)) / RewoundEff(i,s,indreg,y)))
            if (MotorStock(i,s,indreg,y).gt.0) then  ! calculate if stock in a size class, bul 4/27/06
             MotAvgEnergy(i,s,indreg,y) = ((MotorStock(i,s,indreg,y-1) - FailedMotors(i,s,indreg,y)) * MotAdjEnergy(i,s,indreg,y-1)   &
                         + TotalMotorFlow(i,s,indreg,y) * NewMotorEnergy(i,s,indreg,y)     &
                         + RewoundMotors(i,s,indreg,y) * RewMotorEnergy(i,s,indreg,y)) / MotorStock(i,s,indreg,y)
             MotAvgEff(i,s,indreg,y)    = ((MotorStock(i,s,indreg,y-1) - FailedMotors(i,s,indreg,y)) * MotAvgEff(i,s,indreg,y-1)       &
                         + EffMotorFlow(i,s,indreg,y) * EEPctEff(i,s)                  &
                         + PremMotorFlow(i,s,indreg,y) * PEPctEff(i,s)                                      &
                         + RewoundMotors(i,s,indreg,y) * RewoundEff(i,s,indreg,y)) / MotorStock(i,s,indreg,y)
            else  ! keep going if no stock in a size class, bul 4/27/06
             MotAvgEnergy(i,s,indreg,y) = 0.0
             MotAvgEff(i,s,indreg,y) = 0.0
            endif
           SystemSavingsR(i,s)   = ((PumpAppPct(i,s) * PumpSavPct(i,s)) + (FanAppPct(i,s) * FanSavPct(i,s)) +  &
                                     (CompAppPct(i,s) * CompSavPct(i,s))) / MotSysLife(i,s)
           MotAdjEnergy(i,s,indreg,y)   = MotAvgEnergy(i,s,indreg,y) * (1 - SystemSavingsR(i,s))
           TotalMotorEnergy(i,s,indreg,y)  = TotalMotorEnergy(i,s,indreg,y) + &
                                      ((MotorStock(i,s,indreg,y) * MotAvgEnergy(i,s,indreg,y)) * 3412.) / 10.**12
           TotAdjMotorEnergy(i,s,indreg,y) = TotAdjMotorEnergy(i,s,indreg,y) + &
                                      ((MotorStock(i,s,indreg,y) * MotAdjEnergy(i,s,indreg,y)) * 3412.) / 10.**12
           TotalMotorEnergy(i,motorsizes+1,indreg,y)  =   TotalMotorEnergy(i,motorsizes+1,indreg,y)   &
                                    + TotalMotorEnergy(i,s,indreg,y)
           TotAdjMotorEnergy(i,motorsizes+1,indreg,y) = TotAdjMotorEnergy(i,motorsizes+1,indreg,y)    &
                                    + TotAdjMotorEnergy(i,s,indreg,y)
          enddo
        endif  ! of y.gt.ibbyr

        if(prtdbgi.ge.2.and.y.eq.lastyr) then           ! POT_MOTOR eliminate fcrl.eq.1
          write(7,'(///a,i3)') 'Motor Model Outputs, Region ',indreg

            write(7,'(1x,a)') 'Industrial Electricity Price (2000$/kWh)'
            do y = ibbyr,ijumpyr
               write(7,505) y,indreg,inddir,(IndElecPrice(indreg,y))
            enddo


            write(7,'(1x,a)') nmit(i)  ! name of this industry

            write(7,'(1x,a)') 'Rewound Motors'
            do y = ibbyr,ijumpyr
               write(7,501) y,indreg,inddir,(RewoundMotors(i,s,indreg,y),s=1,7)
            enddo

            write(7,'(1x,a)') 'Drop in Efficiency when Rewound'
               write(7,500) y,indreg,inddir,(MotRewDrop(i,s),s=1,7)

            write(7,'(1x,a)') 'Replaced Motors'
            do y = ibbyr,ijumpyr
               write(7,501) y,indreg,inddir,(RepMotorFlow(i,s,indreg,y),s=1,7)
            enddo

            write(7,'(1x,a)') 'Industry Shipments Growth'
            do y = ibbyr,ijumpyr
               write(7,505) y,indreg,inddir,(IndShipGr(i,indreg,y))
            enddo

            write(7,'(1x,a)') 'Motor Additions to Satisfy Growth'
            do y = ibbyr,ijumpyr
               write(7,501) y,indreg,inddir,(GrowthMotorFlow(i,s,indreg,y),s=1,7)
            enddo

            write(7,'(1x,a)') 'Total Motor Additions'
            do y = ibbyr,ijumpyr
               write(7,501) y,indreg,inddir,(TotalMotorFlow(i,s,indreg,y),s=1,7)
            enddo

            write(7,'(1x,a)') 'Motor Horsepower'
               write(7,501) y,indreg,inddir,(MotorHP(i,s),s=1,7)

            write(7,'(1x,a)') 'Average Part Load'
               write(7,500) y,indreg,inddir,(AvgPartLoad(i,s),s=1,7)

            write(7,'(1x,a)') 'Conversion from Horsepower to KW'
               write(7,500) y,indreg,inddir,(HPtoKW)

            write(7,'(1x,a)') 'Motor Operating Hours'
               write(7,501) y,indreg,inddir,(MotorOpHr(i,s),s=1,7)

            write(7,'(1x,a)') 'Annual $ Savings for Replacing over Rewinding'
            do y = ibbyr,ijumpyr
               write(7,503) y,indreg,inddir,(ReplaceAnnSav(i,s,indreg,y),s=1,7)
            enddo

            write(7,'(1x,a)') 'Annual $ Savings for Premium Motor Choice'
            do y = ibbyr,ijumpyr
               write(7,503) y,indreg,inddir,(PEAnnSav(i,s,indreg,y),s=1,6)
            enddo

            write(7,'(1x,a)') 'List Price for EPACT Minimum Motor'
            do y = ibbyr,ijumpyr
               write(7,503) y,indreg,inddir,(EEListPrice(i,s),s=1,7)
            enddo

            write(7,'(1x,a)') 'Cost of Rewinding a Failed Motor'
            do y = ibbyr,ijumpyr
               write(7,503) y,indreg,inddir,(RewindCost(i,s),s=1,7)
            enddo

            write(7,'(1x,a)') 'Cost Differential for Replacing over Rewinding'
            do y = ibbyr,ijumpyr
               write(7,503) y,indreg,inddir,(ReplacePrPrem(i,s),s=1,7)
            enddo

            write(7,'(1x,a)') 'List Price for Premium Motor'
            do y = ibbyr,ijumpyr
               write(7,503) y,indreg,inddir,(PEListPrice(i,s),s=1,6)
            enddo

            write(7,'(1x,a)') 'Cost Differential for Premium Motor Choice'
            do y = ibbyr,ijumpyr
               write(7,503) y,indreg,inddir,(PEPrPrem(i,s),s=1,6)
            enddo

            write(7,'(1x,a)') 'ROI Breakeven for Replacing over Rewinding in Years'
            do y = ibbyr,ijumpyr
               write(7,503) y,indreg,inddir,(ReplacePayback(i,s,indreg,y),s=1,7)
            enddo

            write(7,'(1x,a)') 'ROI Breakeven for Premium Motor Choice in Years'
            do y = ibbyr,ijumpyr
               write(7,503) y,indreg,inddir,(PEPayback(i,s,indreg,y),s=1,6)
            enddo

            write(7,'(1x,a)') 'Premium Motor Efficiency'
               write(7,500) y,indreg,inddir,(PEPctEff(i,s),s=1,6)

            write(7,'(1x,a)') 'Premium Motor Additions'
            do y = ibbyr,ijumpyr
               write(7,501) y,indreg,inddir,(PremMotorFlow(i,s,indreg,y),s=1,6)
            enddo

            write(7,'(1x,a)') 'EPACT Minimum Motor Efficiency'
               write(7,500) y,indreg,inddir,(EEPctEff(i,s),s=1,7)

            write(7,'(1x,a)') 'EPACT Minimum Motor Additions'
            do y = ibbyr,ijumpyr
               write(7,501) y,indreg,inddir,(EffMotorFlow(i,s,indreg,y),s=1,7)
            enddo

            write(7,'(1x,a)') 'Motor Stock'
            do y = ibbyr,ijumpyr
               write(7,501) y,indreg,inddir,(MotorStock(i,s,indreg,y),s=1,7)
            enddo

            write(7,'(1x,a)') 'New Motor Efficiency'
            do y = ibbyr,ijumpyr
               write(7,500) y,indreg,inddir,(NewMotorEff(i,s,indreg,y),s=1,7)
            enddo

            write(7,'(1x,a)') 'Rewound Motor Efficiency'
            do y = ibbyr,ijumpyr
               write(7,500) y,indreg,inddir,(RewoundEff(i,s,indreg,y),s=1,7)
            enddo

            write(7,'(1x,a)') 'New Motor Average Energy'
            do y = ibbyr,ijumpyr
               write(7,501) y,indreg,inddir,(NewMotorEnergy(i,s,indreg,y),s=1,7)
            enddo

            write(7,'(1x,a)') 'Rewound Motor Average Energy'
            do y = ibbyr,ijumpyr
               write(7,501) y,indreg,inddir,(RewMotorEnergy(i,s,indreg,y),s=1,7)
            enddo

            write(7,'(1x,a)') 'Motor Average Energy'
            do y = ibbyr,ijumpyr
               write(7,501) y,indreg,inddir,(MotAvgEnergy(i,s,indreg,y),s=1,7)
            enddo

            write(7,'(1x,a)') 'Motor Average Efficiency'
            do y = ibbyr,ijumpyr
               write(7,500) y,indreg,inddir,(MotAvgEff(i,s,indreg,y),s=1,7)
            enddo

            write(7,'(1x,a)') 'Motor Adjusted Energy'
            do y = ibbyr,ijumpyr
               write(7,501) y,indreg,inddir,(MotAdjEnergy(i,s,indreg,y),s=1,7)
            enddo

            write(7,'(1x,a)') 'Total Motor Energy'
            do y = ibbyr,ijumpyr
               write(7,502) y,indreg,inddir,(TotalMotorEnergy(i,s,indreg,y),s=1,8)
            enddo

            write(7,'(1x,a)') 'Total Adjusted Motor Energy'
            do y = ibbyr,ijumpyr
               write(7,502) y,indreg,inddir,(TotAdjMotorEnergy(i,s,indreg,y),s=1,8)
            enddo

            write(7,'(1x,a)') 'Motor System Improvement Life'
               write(7,500) y,indreg,inddir,(MotSysLife(i,s),s=1,7)

            write(7,'(1x,a)') 'Pump System Improvement Applicability'
               write(7,500) y,indreg,inddir,(PumpAppPct(i,s),s=1,7)

            write(7,'(1x,a)') 'Fan System Improvement Applicability'
               write(7,500) y,indreg,inddir,(FanAppPct(i,s),s=1,7)

            write(7,'(1x,a)') 'Compressor System Improvement Applicability'
               write(7,500) y,indreg,inddir,(CompAppPct(i,s),s=1,7)

            write(7,'(1x,a)') 'Pump System Improvement Potential'
               write(7,500) y,indreg,inddir,(PumpSavPct(i,s),s=1,7)

            write(7,'(1x,a)') 'Fan System Improvement Potential'
               write(7,500) y,indreg,inddir,(FanSavPct(i,s),s=1,7)

            write(7,'(1x,a)') 'Compressor System Improvement Potential'
               write(7,500) y,indreg,inddir,(CompSavPct(i,s),s=1,7)

            write(7,'(1x,a)') 'Premium Motor ROI Acceptance Curve'
               write(7,504) y,indreg,inddir,(PremAccept(s),s=1,20)

         endif


500 Format(3i4,7f11.4)
501 Format(3i4,7f11.0)
502 Format(3i4,8f11.4)
503 Format(3i4,7f11.2)
504 Format(3i4,20f11.4)
505 Format(3i4,7f11.6)


       return
        end subroutine motors

! ==============================================================================
   function divshr(a,icd,icr)
   real divshr
   ! calculate the a census division's share of its census region total given a census division array.
     real a(11)
     integer icr,icd,ibeg_div(4),iend_div(4),ie,ib
     real regtot
     data ibeg_div/1,3,5,8/
     data iend_div/2,4,7,9/

       divshr=0.
       ib=ibeg_div(icr)
       ie=iend_div(icr)
       regtot=sum(a(ib:ie))
       if(regtot.ne.0) then
         divshr=a(icd)/regtot
       else
         divshr=1./real(ie-ib+1)
       endif
     return
   end function divshr


!END SUBROUTINE IND

      REAL FUNCTION SumCDIV(DivArray,CensusReg)
      IMPLICIT NONE
! Sums the values from a census division array belonging to a given census region
! The first argument is an array of Census 9 division values.  It can be called with a
! subscripted multi-dimensional array as long as the first dimension is the Census detail
!  and it is passed with a 1 as the first subscript.  For example, all of these would
!  be valid calls:
!     R2 = SumCDIV( X9, 2)               ! to get region 2 total of one-dimension array X9(9)
!     R2 = SumCDIV( QELIN(1,CURIYR), 2)  ! to get region 2 total of QELIN(11,29)
!     R3 = SumCDIV( CGOGSQ(1,IY,ING1), ICR ) to get region 3 total of CCOGQ(11,...) where
!                                                 the first dimension is the census region
!
      INTEGER NCENSREG,NCENSDIV,MDivPerReg
      PARAMETER(NCENSREG=4,NCENSDIV=9,MDivPerReg=3)

      REAL DivArray(NCENSDIV)   ! Array Passed as argument--first dimension must be census region
      INTEGER CensusReg

      INTEGER             NDivPerReg(NCENSREG)/2,  2,  3,  2/

!                                             R1   R2  R3  R4
      INTEGER CDivByReg(NCENSREG,MDivPerReg)/  1,  3,  5,  8,     & ! the Census Division #s in the 4 Regions
                                               2,  4,  6,  9, &
                                               0,  0,  7,  0/

      INTEGER I,ICD
      REAL SUM
      SUM=0.
      DO I=1,NdivPerReg(CensusReg)
        ICD=CDivByReg(CensusReg,I)
        SUM=SUM + DivArray(ICD)
      ENDDO
      SumCDIV=SUM
      RETURN
      END FUNCTION SumCDiv
!================================================================================
      function isinf(r)
      logical isinf
      real r
      real z
      isinf=.false.
      z=r
      if(isnan(r-z)) then
        isinf=.true.
      endif
      return
      end function isinf
!================================================================================
      subroutine ckstr(unit,row,col,string,iform,iprot,ivis)
      implicit none
! ckstr is designed to perform like wkstr in fwk1io.f which writes a string to a wk1 file, but
! instead is designed to produce a csv file
! Arguments:
!   unit   Fortran unit number of an open direct access output file
!   row    record number
!   col    column number
!   string string to output
!
!   iform, iprot, and ivis not used but carried to avoid some editing of numerous function calls

      integer unit,row,col
      character*(*) string
      integer iform,iprot,ivis ! not used. carried for compatibility with ckstr
      integer irecl,nfields,i,is,ie,ios,k,itest
      parameter (irecl=400,nfields=49)
      character*irecl line,init


!
      integer fields(2,nfields)
      integer cnt ! number of fields found on a record
      character*100 afields(nfields)

! create an initialization record
      logical once/.true./
      if(once) then
         init=' '
         line=' '
         once=.false.
         do i=1,nfields-1
           init(i:i)=','
         enddo
!         init(irecl-1:)=char(13)//char(10)
      endif
!
! read any preexisting record.  if there is none yet, goto 10 to initialize
      line=' '
      read(unit,100,rec=row,iostat=ios) line
      k=len_trim(line)
      itest=ichar(line(1:1))
      if(ios.ne.0.or.k.eq.0.or.itest.eq.0) then
        line=init
      endif
      call csv_field(line,nfields,fields,afields,cnt) ! determine starting and end positions of fields
      if(col.le.cnt) then
        is=fields(1,col)
        ie=fields(2,col)
        if(is.lt.len(line))then
          if(is.gt.1) then
            line=line(:is-1)//'"'//trim(string)//'"'//line(ie:)
          else
            line='"'//trim(string)//'"'//line(ie:)
          endif
        endif
!        line(irecl-1:)=char(13)//char(10)
        write(unit,100,rec=row) line
      endif

100   format(a)
      return
      end
!================================================================================
      subroutine ckint(unit,row,col,ival,iform)
      implicit none
! ckint is designed to perform like wkint in fwk1io.f which writes an integer to a wk1 file, but
! instead is designed to produce a csv file
! Arguments:
!   unit   Fortran unit number of an open direct access output file
!   row    record number
!   col    column number
!   ival   integer value to write
!
!   iform not used but carried to avoid some editing of numerous function calls

      integer unit,row,col
      integer ival
      integer iform ! not used. carried for compatibility with cknum
      integer irecl,nfields,i,is,ie,ios,k,itest
      parameter (irecl=400,nfields=49)
      character*irecl line,init
      character*7 string


!
      integer fields(2,nfields)
      integer cnt ! number of fields found on a record
      character*100 afields(nfields)

! create an initialization record
      logical once/.true./
      if(once) then
         once=.false.
         do i=1,nfields-1
           init(i:i)=','
         enddo
         init(irecl-1:)=char(13)//char(10)
      endif

      write(string,'(i7)') ival
!
! read any preexisting record.  if there is none yet, goto 10 to initialize
      read(unit,100,rec=row,iostat=ios) line
      k=len_trim(line)
      itest=ichar(line(1:1))
      if(ios.ne.0.or.k.eq.0.or.itest.eq.0) then
        line=init
      endif
      call csv_field(line,nfields,fields,afields,cnt) ! determine starting and end positions of fields
      if(col.le.cnt) then
        is=fields(1,col)
        ie=fields(2,col)
        if(is.lt.len(line))then
          if(is.gt.1) then
            line=line(:is-1)//trim(string)//line(ie:)
          else
            line=trim(string)//line(ie:)
          endif
        endif
        line(irecl-1:)=char(13)//char(10)
        write(unit,100,rec=row) line
      endif
100   format(a)
      return
      end
!================================================================================
      subroutine cknum(unit,row,col,val,ndigit,iform )
      implicit none
! cknum is designed to perform like wkint in fwk1io.f which writes a double precision value to a wk1 file, but
! instead is designed to produce a csv file
! Arguments:
!   unit   Fortran unit number of an open direct access output file
!   row    record number
!   col    column number
!   val    double precision(real*8) value to write
!   ndigit number of digits to right of decimal
!   iform not used but carried to avoid some editing of numerous function calls

      integer unit,row,col,ndigit
      real*8 val
      integer iform,iprot,ivis ! not used. carried for compatibility with ckstr
      integer irecl,nfields,i,is,ie,ios,k,itest
      parameter (irecl=400,nfields=49)
      character*irecl line,init
      character*16 string


!
      integer fields(2,nfields)
      integer cnt ! number of fields found on a record
      character*100 afields(nfields)

! create an initialization record
      logical once/.true./
      if(once) then
         once=.false.
         do i=1,nfields-1
           init(i:i)=','
         enddo
         init(irecl-1:)=char(13)//char(10)
      endif

      write(string,'(f16.<ndigit+1>)') val
!
! read any preexisting record.  if there is none yet, goto 10 to initialize
      read(unit,100,rec=row,iostat=ios) line
      k=len_trim(line)
      itest=ichar(line(1:1))
      if(ios.ne.0.or.k.eq.0.or.itest.eq.0) then
        line=init
      endif
      call csv_field(line,nfields,fields,afields,cnt) ! determine starting and end positions of fields
      if(col.le.cnt) then
        is=fields(1,col)
        ie=fields(2,col)
        if(is.lt.len(line))then
          if(is.gt.1) then
            line=line(:is-1)//trim(adjustl(string))//line(ie:)
          else
            line=trim(adjustl(string))//line(ie:)
          endif
        endif
        line(irecl-1:)=char(13)//char(10)
        write(unit,100,rec=row) line
      endif
 100  format(a)
      return
      end
!==========================================================================
!  This subroutine counts the comma-delimited fields on a line
! and sets the starting and ending position of each field number

 subroutine csv_field(line,maxfield,fields,afields,cnt)
 implicit none

! arguments
 integer maxfield
 integer fields(2,maxfield) ! column start, end of each comma delimited field
 character*(*) line
 character*100 afields(maxfield)
 integer cnt ! number of fields

! other
  integer ipos,icomma,iquote,line_len

 cnt=1
 line_len=len_trim(line)
 ipos=0
 fields=0
 if(line_len.eq.0) then
   cnt=0
   return
 endif
 do while (ipos.le.(line_len) .and. cnt .le. maxfield)

! set field count, position, and starting position of field

   ipos=ipos+1
   fields(1,cnt)=ipos

   ! if field starts with a " find next "
   if(line(ipos:ipos).eq.'"') then
      iquote=index(line(ipos+1:line_len),'"')
      if(iquote.ne.0) then
        ipos=ipos+iquote
      endif
   endif
   ! find next comma
   icomma=index(line(ipos:line_len),',')
   if(icomma.ne.0) then
     fields(2,cnt)=ipos+icomma-2
     if(fields(2,cnt).lt.fields(1,cnt)) fields(2,cnt)=fields(1,cnt)
     cnt=cnt+1
     ipos=ipos+icomma-1

   elseif(line(line_len:line_len).eq.'"') then  ! last field, ends in a "
     fields(2,cnt)=line_len-1
     if(fields(2,cnt).lt.fields(1,cnt)) fields(2,cnt)=fields(1,cnt)
!     cnt=cnt+1
     ipos=line_len+1
   else                                         ! last field, ends in a character is empty
     fields(2,cnt)=line_len
     if(fields(2,cnt).lt.fields(1,cnt)) fields(2,cnt)=fields(1,cnt)
!     cnt=cnt+1
     ipos=line_len+1
   endif

 enddo
 return
 end subroutine csv_field


!***************************************************************************************end AE
! All includes in new modules have been moved to module i_ for IDM consistency
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!   New Subroutine for Agriculture TPC Calculation
!
      SUBROUTINE AGTPC(IFUEL,ISTEP)
      use i_
      implicit none

      real temp(3),temp2(3)
      integer istep,iv,ifuel,ifx,ify,ift,isc
      integer ifx_map(48), if_map(7)                                ! Maps IDM fuel indices to the 5 fuels used in this section (zeros otherwise)

!     Real   WHSE_ShellIndex(4,mnumyr)                              ! Global Variables from
!     Real   WHSE_LightIndex(4,mnumyr)                              ! Commercial Module:
!     Real   WHSE_VentIndex(4,mnumyr)                               ! 4 Regions, Electricity only
!     Real   WHSE_HeatIndex(4,5,mnumyr)                             ! this var 3 Fuels (EL, NG, DS)
      Real   BLD_Index(4,6,mnumyr)                                  ! Marginal change for buildings: heat, light, shell, all 5 fuels
      Real   VEH_Index(8,mnumyr)                                    ! Marginal change for vehicles, by fuel
      Real   IRR_Index(4,mnumyr)                                    ! Marginal change for irrigation, by region
      Real   Trk_Intens(mnumyr,8)                                   ! Weighted Average Energy Intensity for Trucks
	  Real	 TPC_Limit												! Upper Constraint on TPC (ensures minimal level of improvement)
	  Real	 TPC_Scale(5)											! Manual Scaling Factors to keep TPC within reasonable bounds

!     common /TPC/WHSE_ShellIndex,WHSE_HeatIndex,WHSE_VentIndex,WHSE_LightIndex

      Real AG_Bldg_Wt(3,8)                                          ! Building functional weights by fuel (5)
!     Real Weight_AG(4,3,5)                                         ! Component weights, by census region(4),
                                                                    ! function(3):  buildings, vehicles, irrigation,
                                                                    ! and fuels(5): electricity, NG, Dist, LPG, Gasoline

!*********** Data for weighting relative influence on TPC ******************************

!   These weights are now used offline to produce the itech file - ESE 9/30/2011
!	Region 1                   EL	  NG	 DS     LP 	   GS
!	Data Weight_AG(1,1,1:5) /0.996, 0.900, 0.242, 0.891, 0.000/     ! Buildings
!	Data Weight_AG(1,2,1:5) /0.000, 0.100, 0.750, 0.100, 0.998/     ! Vehicles
!	Data Weight_AG(1,3,1:5) /0.004, 0.000, 0.008, 0.009, 0.002/     ! Irrigation

!	Region 2                   EL	  NG	 DS     LP 	   GS
!	Data Weight_AG(2,1,1:5) /0.806, 0.400, 0.200, 0.876, 0.000/
!	Data Weight_AG(2,2,1:5) /0.000, 0.100, 0.750, 0.100, 1.000/
!	Data Weight_AG(2,3,1:5) /0.194, 0.500, 0.050, 0.024, 0.000/

!	Region 3                   EL	  NG	 DS     LP 	   GS
!	Data Weight_AG(3,1,1:5) /0.775, 0.400, 0.166, 0.892, 0.000/
!	Data Weight_AG(3,2,1:5) /0.000, 0.100, 0.750, 0.100, 0.996/
!	Data Weight_AG(3,3,1:5) /0.225, 0.500, 0.084, 0.008, 0.004/

!	Region 4                   EL	  NG	 DS     LP 	   GS
!	Data Weight_AG(4,1,1:5) /0.500, 0.704, 0.194, 0.892, 0.000/
!	Data Weight_AG(4,2,1:5) /0.000, 0.100, 0.750, 0.100, 0.999/
!	Data Weight_AG(4,3,1:5) /0.500, 0.196, 0.056, 0.008, 0.001/

!	Functional Weights for Buildings

!                           Heat  Light Shell
	Data AG_Bldg_Wt(1:3,1) /0.25, 0.25, 0.50/                       ! Electricity
	Data AG_Bldg_Wt(1:3,2) /0.25, 0.00, 0.75/                       ! Natural Gas
	Data AG_Bldg_Wt(1:3,3) /0.25, 0.00, 0.75/                       ! Distillate
	Data AG_Bldg_Wt(1:3,4) /0.25, 0.00, 0.75/                       ! LPG
	Data AG_Bldg_Wt(1:3,5) /0.25, 0.00, 0.75/                       ! Gasoline
    Data AG_Bldg_Wt(1:3,6) /0.25, 0.00, 0.75/                       ! MSW
    Data AG_Bldg_Wt(1:3,5) /0.25, 0.00, 0.75/                       ! OP
    Data AG_Bldg_Wt(1:3,6) /0.25, 0.00, 0.75/                       ! Steam

!						 Heat Light	Shell Veh  IRR
	Data TPC_Scale(1:5) /1.0, 10.0, 1.0,  10.0, 10.0/				! Ad Hoc scaling factors for TPC components
!***************** End Data *************************************************************

	ifx=ifloc(ifuel,istep)	! Identifies the specific fuel associated with the IFUEL index for this industry

!					ifx
!	Electricity		1
!	Natural Gas		3
!	Distillate		11
!	LPG				12
!	Coal			7
!	Gasoline		14
!	Other Pet.		22
!	Steam			31
!   Renewables MSW  48

	ifx_map = 0        ! Initialize:  ifx_map(ifx) should provide fuel indices in the proper order

	   ifx_map(1)  = 1  ! EL
	  ifx_map(3)  = 2  ! NG
	  ifx_map(11) = 3  ! DS
	  ifx_map(12) = 4  ! LG
	  ifx_map(14) = 5  ! GS
	 ! ifx_map(48) = 6  ! MSW
      ifx_map(22) = 6  ! OP  (Other Petroleum) !td add/change
      ifx_map(31) = 7  ! ST   (Steam)          !td add/change

	IF(ifx_map(ifx).EQ.0) RETURN    ! If not one of the considered fuels, skip the rest of the subroutine.

	ift = ifx_map(ifx) ! For brevity (the variable ifuel is not uniquely linked to the ifx indices)

!	************ Stock-Weighted Energy Intensity for Freight Trucks **************************

!	Tran Variables:	TFR_FTMPG(year,size,fuel,existing stock=2)	    Gasoline-Equivalent MPG
!					TFR_TRK_FAS_T(year,size,fuel,existing stock=2)  Existing Stock

!	Fuel Indices:   if_map(ift) = (1) Diesel, (2) Gasoline, (3) Propane, (4) CNG, (5) Ethanol flex
!                                  (6) Electric, (7) plug in diesel, (8) Plug in gasoline, (9) fuel cell

	data if_map /0,4,1,3,2,0,0/        ! if_map(ift) should return the matching truck fuel (no electricity, OP, or steam)
!      if_map(1:7)=(//0,4,1,3,2,0,0/)

	Trk_Intens(curiyr,ift) = 1.0         ! Initialize to 1.0 every year, to avoid error messages
        IF (curcalyr.eq.ibyr2+1) Trk_Intens(curiyr-1,ift) = 1.0    ! avoid divide by 0 first time through

        IF (if_map(ift).ne.0) THEN     ! All remaining years skip over electricity for trucks

	  Trk_Intens(curiyr,ift)=(    TFR_TRK_FAS_T(curiyr,1,if_map(ift),2) / TFR_FTMPG(curiyr,1,if_map(ift),2)   &
                                 + TFR_TRK_FAS_T(curiyr,2,if_map(ift),2) / TFR_FTMPG(curiyr,2,if_map(ift),2)  &
								+ TFR_TRK_FAS_T(curiyr,3,if_map(ift),2) / TFR_FTMPG(curiyr,3,if_map(ift),2) ) &
                                 / sum(TFR_TRK_FAS_T(curiyr,1:3,if_map(ift),2))
        ENDIF

! Print new indexes to nohup to allow debugging (may be removed later) tdm
  IF (curitr.eq.1.and.inddir.eq.1.and.indreg.eq.1) Then
      write(IUNITBUG,6670) curcalyr, WHSE_LightIndex(indreg,curiyr), WHSE_ShellIndex(indreg,curiyr), WHSE_VentIndex(indreg,curiyr), WHSE_HeatIndex(indreg,1:5,curiyr)
  Endif
 6670  Format("Indexes for Light, Shell, Vent, Heat (last 5):",i6, 2x, 8(f10.4))


!	***********************************************
	TPC_Limit = -0.001

!	Marginal Change in Energy Intensity from Prior Year
    if (ift .lt. 6) BLD_Index(indreg,1,curiyr)= MIN(((WHSE_HeatIndex(indreg,ift,curiyr)/WHSE_HeatIndex(indreg,ift,curiyr-1)-1.0)/TPC_Scale(1)), TPC_Limit)
	BLD_Index(indreg,2,curiyr)= MIN(((WHSE_LightIndex(indreg,curiyr)/WHSE_LightIndex(indreg,curiyr-1)-1.0)/TPC_Scale(2)), TPC_Limit)
	BLD_Index(indreg,3,curiyr)= MIN(((WHSE_ShellIndex(indreg,curiyr)/WHSE_ShellIndex(indreg,curiyr-1)-1.0)/TPC_Scale(3)), TPC_Limit)

	if (ift .ne. 6) VEH_Index(ift,curiyr)= MIN(((Trk_Intens(curiyr,ift)/Trk_Intens(curiyr-1,ift) -1.0)/TPC_Scale(4)), TPC_Limit)

	IRR_Index(indreg,curiyr)= MIN(((WHSE_VentIndex(indreg,curiyr)/WHSE_VentIndex(indreg,curiyr-1)-1.0)/TPC_Scale(5)), TPC_Limit)

!	Calculate replacement TPC (BCSC) for each region and fuel for Agricultural sectors

    IF(curcalyr.eq.ibyr2+1) GOTO 6666       ! Jump over calculations in the first year to avoid dividing by zero

	IF (ISTEP.EQ.1) THEN
	   BCSC(1,IFUEL,ISTEP)= AG_Bldg_Wt(1,ift)*BLD_Index(indreg,1,curiyr) &
	                        + AG_Bldg_Wt(2,ift)*BLD_Index(indreg,2,curiyr) &
							+ AG_Bldg_Wt(3,ift)*BLD_Index(indreg,3,curiyr)
    ELSEIF (ISTEP.EQ.2) THEN
       BCSC(1,IFUEL,ISTEP)= VEH_Index(ift,curiyr)
    ELSE
       BCSC(1,IFUEL,ISTEP)= IRR_Index(indreg,curiyr)
    ENDIF

	BCSC(3,IFUEL,ISTEP)=1.5*BCSC(1,IFUEL,ISTEP)                          ! Well, this is what it is in the ITECH file.
    ! Debugging write outs are temp. disabled
	IF (curitr.eq.1) Then
         write(IUNITBUG,6611) CURCALYR, inddir, istep, ifuel, ifx, indreg, BCSC(1,ifuel,istep)
6611	Format(6(I6),2x,(F10.5))
	ENDIF

 6666  CONTINUE

! Print new TPCs to nohup to allow debugging (may be removed later)
!	IF (curitr.eq.1) Then
!	  write(IUNITBUG,6664) curcalyr, ifx, ifuel, inddir, indreg, BCSC(1,IFUEL,ISTEP)

6664	  format(5(i5),2x,(f10.6))
!	ENDIF

      RETURN
      END SUBROUTINE AGTPC
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!   Test Subroutine for Coal Mining TPC Calculation
!
          SUBROUTINE COALTPC(IFUEL,ISTEP)
      use i_
      implicit none
      !include 'tranrep'
!      include 'cdsparms'
!include 'coalrep'

      integer istep,iv,ifuel,ifx,ify,ift,isc,ifn,iy
	integer ifx_map(31), if_map(6)                                  ! Maps IDM fuel indices to the 5 fuels used in this section (zeros otherwise)

	 Real   VEH_Index(6,mnumyr)                                     ! Marginal change for vehicles, by fuel
	 Real   Trk_Intens(mnumyr,6)                                    ! Weighted Average Energy Intensity for Trucks

	 Real   EQP_Index(4,3,mnumyr)                                   ! Marginal change for equipment: heat, light, ventillation, by region
	 Real   Wt_EQP_Index(4,mnumyr)                                  ! Weighted Equipment index for the fuel in question
	 Real   Raw_Grind_Eff	                                        ! Raw Grinding Efficiency, from Cement subroutine
       Real   Raw_Grind_Eff_Lag	                                    ! Raw Grinding Efficiency, from Cement subroutine lag year

	 Real   CL_Surface(4,mnumyr)                                    ! Surface Coal production, by census region
	 Real   CL_Underground(4,mnumyr)                                ! Underground Coal production, by census region
	 Real   Under_Share(4,mnumyr)                                   ! Share of underground coal production
	 Real   Under_Index(4,mnumyr)                                   ! Fractional change in underground production share

	 Real   Elec_Weight(4,3)                                        ! Weighting factors for electric equipment components (3), by region (4)
	 Real   TPC_Weight(4,3,6)                                       ! Weighting factors for Equipment, Underground Share & Productivity in TPC Calculation
	 Real   NonEl_Weight(2:6,2)                                       ! Weighting factors for non-electric equipment:  Heating & Vehicles, by fuel type
	 Real   CL_L_Prod(4,2,16:mnumyr)                                   ! Production-weighted Labor Productivity rates, derived from CLUSER File.
	 Real   L_Prod_Index(4,2,mnumyr)                                ! Labor productivity indices by region, underground/surface, and year (2005 on)

       Real Elec_Met_Wt(4,3)
       Real Elec_NM_Wt(4,3)
       Real NonEl_Met_Wt(2:6,2)
       Real NonEl_NM_Wt(2:6,2)
       Real TPC_Met_Wt(4,2,6)
       Real TPC_NM_Wt(4,2,6)
       Real Reg_MetlShr(4)


       COMMON /IN_COAL/Elec_Weight,TPC_Weight,NonEl_Weight,CL_L_Prod, &
                       Elec_Met_Wt,Elec_NM_Wt,NonEl_Met_Wt,NonEl_NM_Wt, &
                       TPC_Met_Wt,TPC_NM_Wt,Reg_MetlShr


!***************** Map IDM Fuel Numbers to the Indices Used for Mining ******************

	ifx=ifloc(ifuel,istep)	! Identifies the specific fuel associated with the IFUEL index for this industry

!					ifx
!	Electricity		1
!	Natural Gas		3
!	Residual Oil	10
!	Distillate		11
!	LPG				12
!	Coal			7
!	Gasoline		14
!	Other Pet.		22
!	Steam			31

	ifx_map = 0        ! Initialize:  ifx_map(ifx) should provide fuel indices in the proper order

	  ifx_map(1)  = 1  ! EL
	  ifx_map(3)  = 2  ! NG
	  ifx_map(11) = 3  ! DS
	  ifx_map(14) = 4  ! GS
	  ifx_map(7)  = 5  ! CL
	  ifx_map(10) = 6  ! RS         ! Newly-added Residual.  Update UEC in itech.txt file

	IF(ifx_map(ifx).EQ.0) RETURN    ! If not one of the considered fuels, skip the rest of the subroutine.

	ift = ifx_map(ifx) ! For brevity  (the variable ifuel is not uniquely linked to the ifx indices)

!	***********************************************

	     TPC_Weight(indreg,2,ift) = (1.0 - TPC_Weight(indreg,1,ift)) / 2.0    ! Weight of Underground Mining Index

	     TPC_Weight(indreg,3,ift) =  1.0 - ( TPC_Weight(indreg,1,ift)  &     ! Weight of Productivity Index (to be further divided between
		                                   + TPC_Weight(indreg,2,ift) )      !   Surface and Underground production, which changes yearly)



!***************** End Data *************************************************************


!	*** Calculate Surface and Underground Production by Census Region, Mapping the 14 Coal Production Regions ***

	iy = curiyr
     if (curiyr.le.ICURIYR+2) then !cement not calculated yet, POT_ibyr2 19 to ICURIYR+2
	  Raw_Grind_Eff_lag=246.6
	  raw_grind_eff=246.6
	 else
	    if (curitr.eq.1) Raw_Grind_Eff_lag=raw_grind_eff   !save last year's value in first iterarion
          Raw_Grind_Eff=(elec_use_rpt(1)+elec_use_rpt(2)) / (tot_prodg(1)+tot_prodg(2))

       endif
!	Surface

	CL_Surface(1,iy) = PMTS(1,iy)

	CL_Surface(2,iy) = PMTS(2,iy) + PMTS(3,iy) + PMTS(6,iy)

	CL_Surface(3,iy) = PMTS(4,iy) + PMTS(5,iy) + PMTS(7,iy)

	CL_Surface(4,iy) = sum(PMTS(8:14,iy))

!	Undergound

	CL_Underground(1,iy) = PMTD(1,iy)

	CL_Underground(2,iy) = PMTD(2,iy) + PMTD(3,iy) + PMTD(6,iy)

	CL_Underground(3,iy) = PMTD(4,iy) + PMTD(5,iy) + PMTD(7,iy)

	CL_Underground(4,iy) = sum(PMTD(8:14,iy))


!	Underground Mining Share

	Under_Share(indreg,iy) =  CL_Underground(indreg,iy)                         &
	                       / (CL_Underground(indreg,iy) + CL_Surface(indreg,iy))

        IF (Under_Share(indreg,iy-1) .NE. 0.0) THEN
           Under_Index(indreg,iy) = Under_Share(indreg,iy)/Under_Share(indreg,iy-1) - 1.0
        ELSE
           Under_Index(indreg,iy) = 0.0         ! assuming no change
        ENDIF


!	Underground and Surface Mining Labor Productivity Indices

	L_Prod_Index(indreg,1,iy) = 1.0 - (CL_L_Prod(indreg,1,iy)/CL_L_Prod(indreg,1,iy-1))   ! Underground

	L_Prod_Index(indreg,2,iy) = 1.0 - (CL_L_Prod(indreg,2,iy)/CL_L_Prod(indreg,2,iy-1))   ! Surface





!	************ Stock-Weighted Energy Intensity for Freight Trucks **************************

!	Tran Variables:	TFR_FTMPG(year,size,fuel,existing stock=2)	    Gasoline-Equivalent MPG
!                       TFR_TRK_FAS_T(year,size,fuel,existing stock=2)      Existing Stock

!	Fuel Indices:   ify= (1)Diesel, (2)Gasoline, (3)LPG, (4)CNG


	data if_map /0,4,1,2,0,0/      ! if_map(ift) should return the matching truck fuel (no electricity, coal, or residual)

	Trk_Intens(curiyr,ift) = 1.0   ! Initialize to 1.0, to avoid error messages

	IF (if_map(ift).ne.0) THEN     ! Skip over electricity and coal for trucks

	  Trk_Intens(curiyr,ift) =  (  TFR_TRK_FAS_T(curiyr,1,if_map(ift),2)/TFR_FTMPG(curiyr,1,if_map(ift),2)   &
	                             + TFR_TRK_FAS_T(curiyr,2,if_map(ift),2)/TFR_FTMPG(curiyr,2,if_map(ift),2)   &
								 + TFR_TRK_FAS_T(curiyr,3,if_map(ift),2)/TFR_FTMPG(curiyr,3,if_map(ift),2) ) &
	                            / sum(TFR_TRK_FAS_T(curiyr,1:3,if_map(ift),2))

	ENDIF



!	******************** End of Vehicle Calculations  **************************



!	******************** Calculate Weighted Equipment Indices **************************

	IF (ift.eq.1) THEN          ! For Electric Equipment

	EQP_Index(indreg,1,curiyr) = (Raw_Grind_Eff / Raw_Grind_Eff_lag -1.0)  ! From cement subroutine, no regional component
	EQP_Index(indreg,2,curiyr) = (WHSE_LightIndex(indreg,curiyr)  / WHSE_LightIndex(indreg,curiyr-1) -1.0)
	EQP_Index(indreg,3,curiyr) = (WHSE_VentIndex(indreg,curiyr)   / WHSE_VentIndex(indreg,curiyr-1)  -1.0)


	Wt_EQP_Index(indreg,curiyr) = EQP_Index(indreg,1,curiyr) * Elec_Weight(indreg,1) &        ! Grinding
	                            + EQP_Index(indreg,2,curiyr) * Elec_Weight(indreg,2) &        ! Lighting
	                            + EQP_Index(indreg,3,curiyr) * Elec_Weight(indreg,3)          ! Ventilation

	if(curitr.eq.1)then
	  !write (IUNITBUG,6667) iyr,ift,indreg,eqp_index(indreg,1,curiyr), tot_prodg(1), tot_prodg(2), Raw_Grind_Eff
6667	  format (3(i5),4(f12.5,2x))
	endif

	  ELSE                      ! For Other Fuels (ift = 2-6)

	    IF(ift.eq.6) THEN           ! Temporary fix to include residual, without editing the CDM code
	EQP_Index(indreg,1,curiyr) = (WHSE_HeatIndex(indreg,3,curiyr)  / WHSE_HeatIndex(indreg,3,curiyr-1)  -1.0) ! Use Distillate values of Heat Index

            ELSE                  ! For Fuels 2-5

	EQP_Index(indreg,1,curiyr) = (WHSE_HeatIndex(indreg,ift,curiyr)  / WHSE_HeatIndex(indreg,ift,curiyr-1)  -1.0) ! Re-using this variable from above.
          ENDIF

        IF (Trk_Intens(curiyr-1,ift) .NE. 0.0) THEN
           VEH_Index(ift,curiyr) = (Trk_Intens(curiyr,ift)/Trk_Intens(curiyr-1,ift) -1.0)   ! Energy intensity improvement index for trucks
        ELSE
           VEH_Index(ift,curiyr) = 0.0    ! assuming no change
        ENDIF

	Wt_EQP_Index(indreg,curiyr) = EQP_Index(indreg,1,curiyr) * NonEl_Weight(ift,1) &        ! Heating
                                  + VEH_Index(ift,curiyr)      * NonEl_Weight(ift,2)          ! Vehicles

	ENDIF

!*******************************************************************************************


!	Calculate replacement TPC (BCSC) for each region and fuel for Coal Mining sector



	IF(iyr.eq.ibyr2+1) GOTO 6688       ! Jump over calculations in the first year to avoid dividing by zero


	BCSC(1,IFUEL,ISTEP) =      TPC_Weight(indreg,1,ift) * Wt_EQP_Index(indreg,curiyr) &
	                         + TPC_Weight(indreg,2,ift) * Under_Index(indreg,curiyr)  &
	                         + TPC_Weight(indreg,3,ift) * Under_Share(indreg,curiyr)  &
							                            * L_Prod_Index(indreg,1,iy)   &
	                         + TPC_Weight(indreg,3,ift) * (1.0-Under_Share(indreg,curiyr))  &
							                            * L_Prod_Index(indreg,2,iy)



	BCSC(3,IFUEL,ISTEP) = 1.5 * BCSC(1,IFUEL,ISTEP)                          ! Well, this is what it is in the ITECH file.

6688	CONTINUE

	IF (curitr.eq.1) Then
	 ! write(IUNITBUG,6664) curcalyr,ifx,ifuel,inddir,indreg,BCSC(1,IFUEL,ISTEP)
6664	  format(5(i5),2x,(f10.6))
	ENDIF


	IF (curitr.eq.1) Then
	!  write(IUNITBUG,6662) curcalyr,ift,indreg,Wt_EQP_Index(indreg,curiyr),Under_Index(indreg,curiyr),Under_Share(indreg,curiyr),L_Prod_Index(indreg,1,curiyr),L_Prod_Index(indreg,2,curiyr)
6662	  format(3(i5),2x,5(f10.6))
	ENDIF


      RETURN
      END SUBROUTINE COALTPC
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!   Test Subroutine for Oil & Gas TPC Calculation - JRM
!
      SUBROUTINE OGSMTPC(IFUEL,ISTEP)
      use i_
      implicit none


      integer istep,iv,ifuel,ifx,ify,ift,isc,ifn,iy,K,R
	integer ifx_map(42), if_map(6)                                  ! Maps IDM fuel indices to the 6 fuels used in this section (zeros otherwise)


	 Real   VEH_Index(6,mnumyr)                                     ! Marginal change for vehicles, by fuel
	 Real   Trk_Intens(mnumyr,6)                                    ! Weighted Average Energy Intensity for Trucks

	 Real   OGSM_Map(MNL48N,4)                                      ! Mapping Factor: 6 OGSM regions to 4 Census Regions
	 Real   OG_Prod_Tmp(7,4,mnumyr,MNL48N)                          ! Oil & Gas Production (Temp): 7 fuel types, 4 CRs, 6 OGSM regions
	 Real   OG_Prod(7,4,mnumyr)                                     ! Cumulative O&G production in 4 CRs for 7 fuels (2 oil & 5 gas)
	 Real   Oil_Convert                                             ! Factor to convert MMBbl/Day of oil to Trills/Year
	 Real   Gas_Convert                                             ! Factor to convert TCF of NG to Trills
	 Real   Oil_Share(4,mnumyr)                                     ! Oil Share of Production, by region

	 Real   PROD_Wt(7)                                              ! Ad-Hoc factor reflecting relative difficulty of extraction by fuel type
	 Real   OG_ProdSum(7,4,mnumyr)                                  ! Intermediate value for calculating production factors
	 Real   OG_ProdFac(2,4,mnumyr)                                  ! Production Factors for Oil (1) and Natural Gas (2), by region
	 Real   Prod_Index(4,mnumyr)                                    ! Production-Weighted Factors for TPC Calculation, by region



	REAL Success_Well_Reg(7,4,mnumyr,MNL48N)
	REAL Dry_Well_Reg(7,4,mnumyr,MNL48N)
	REAL Success_Well(7,4,mnumyr)
	REAL Dry_Well(7,4,mnumyr)
	REAL Total_Well(7,4,mnumyr)

	REAL Dry_Well_Percent(5,4,mnumyr)                               ! Percentage of dry wells (condensed conventional oil & NG indices) by region
	REAL Wtd_OG_WellFac(4,mnumyr)                                   ! Weighted average dry well percentage by region
	REAL TPC_Fac_Wt(6,3)                                            ! Contribution to TPC from each of three drivers, by fuel type
	REAL Well_Index(4,mnumyr)




!***************** Map IDM Fuel Numbers to the Indices Used for Oil & Gas ******************

	ifx=ifloc(ifuel,istep)	! Identifies the specific fuel associated with the IFUEL index for this industry

!					ifx
!	Electricity		1
!	Natural Gas		3
!	Distillate		11
!	Residual Oil	10
!	LPG				12
!	Coal			7
!	Gasoline		14
!	Other Pet.		22
!	Steam			31

	ifx_map = 0        ! Initialize:  ifx_map(ifx) should provide fuel indices in the proper order

	  ifx_map(1)  = 1  ! EL
	  ifx_map(3)  = 2  ! NG
	  ifx_map(11) = 3  ! DS
	  ifx_map(14) = 4  ! GS
	  ifx_map(42) = 5  ! RN  (Renewables/wood)  Currently in ITECH, don't now why.
	  ifx_map(10) = 6  ! RS

	IF(ifx_map(ifx).EQ.0) RETURN    ! If not one of the considered fuels, skip the rest of the subroutine.

	ift = ifx_map(ifx) ! For brevity  (the variable ifuel is not uniquely linked to the ifx indices)


!*************** Map OGSM Regional Results to Census Regions  *************************

!                   OGSM Regions:   1      2      3      4      5      6      7
	Data OGSM_Map(1:MNL48N,1) /0.229, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000 /
	Data OGSM_Map(1:MNL48N,2) /0.380, 0.000, 0.713, 0.000, 0.155, 0.155, 0.000 /
	Data OGSM_Map(1:MNL48N,3) /0.391, 1.000, 0.287, 0.570, 0.000, 0.000, 0.000 /
	Data OGSM_Map(1:MNL48N,4) /0.000, 0.000, 0.000, 0.430, 0.845, 0.845, 1.000 /

	Data PROD_Wt(1:7) /1.0, 3.0, 1.0, 1.0, 3.0, 2.0, 3.0 /           ! Ad Hoc factors from spreadsheet

!                              EL    NG    DS    GS    RN    RS
	Data TPC_Fac_Wt(1:6,1) /0.00, 0.50, 0.50, 0.50, 0.00, 0.00 /     ! Vehicles
	Data TPC_Fac_Wt(1:6,2) /0.80, 0.40, 0.40, 0.40, 0.80, 0.80 /     ! Production Factor
	Data TPC_Fac_Wt(1:6,3) /0.20, 0.10, 0.10, 0.10, 0.20, 0.20 /     ! Dry Well Index


	iy = curiyr         ! for brevity
	Oil_Convert = 2026.2                                             ! Factor to convert MMBbl/Day of oil to Trils/Year
	Gas_Convert = 1031.0                                             ! Factor to convert TCF of NG to Trills/Year


	DO K=1,7

	  DO R=1,MNL48N
	    OG_Prod_Tmp(K,indreg,iy,R) = OGREGPRD(R,K,iy)*OGSM_Map(R,indreg)     ! Allocate OGSM output to Census Regions
        ENDDO

	  IF (K.le.2) THEN                                                          ! For Oil (Conventional & EOR)
	    OG_Prod(K,indreg,iy) = SUM(OG_Prod_Tmp(K,indreg,iy,1:MNL48N)) * Oil_Convert  !   Sum across OGSM Region, & Convert to Trils/yr
	  ELSE                                                                      ! For Natural Gas
	    OG_Prod(K,indreg,iy) = SUM(OG_Prod_Tmp(K,indreg,iy,1:MNL48N)) * Gas_Convert  !   Sum across OGSM Region, & Convert to Trils/yr
	  ENDIF

	ENDDO

	Oil_Share(indreg,iy) = SUM(OG_Prod(1:2,indreg,iy))/SUM(OG_Prod(1:7,indreg,iy))  ! Share of Production (in Trils) represented by Oil

	! Calculate Production Factors

	DO K=1,7
	    OG_ProdSum(K,indreg,iy) = OG_Prod(K,indreg,iy) * PROD_Wt(K)
	ENDDO

	IF (iy.le.18) THEN

	  OG_ProdFac(1,indreg,iy) = 1.0
	  OG_ProdFac(2,indreg,iy) = 1.0

	ELSE

	  OG_ProdFac(1,indreg,iy) = SUM(OG_ProdSum(1:2,indreg,iy))/SUM(OG_Prod(1:2,indreg,iy))  ! For Oil Production
	  OG_ProdFac(2,indreg,iy) = SUM(OG_ProdSum(3:7,indreg,iy))/SUM(OG_Prod(3:7,indreg,iy))  ! For Gas Production


          ! Zero out (assume no change) this factor to avoid extreme volatility pre-2012 and divide by 0
          IF(iy .le. 22 .or. OG_ProdFac(1,indreg,iy-1) .EQ. 0.0 .OR. OG_ProdFac(2,indreg,iy-1) .EQ. 0.0) THEN
             Prod_Index(indreg,iy) = 0.0
          ELSE

             Prod_Index(indreg,iy) = Oil_Share(indreg,iy)*(OG_ProdFac(1,indreg,iy)/OG_ProdFac(1,indreg,iy-1) - 1.0) &
                         + (1.0 - Oil_Share(indreg,iy)) * (OG_ProdFac(2,indreg,iy)/OG_ProdFac(2,indreg,iy-1) - 1.0)
          ENDIF
	ENDIF

	DO K=1,7

	  DO R = 1,MNL48N
	    Success_Well_Reg(K,indreg,iy,R) = ogsrl48(R,K,iy) * ogwellsl48(R,K,iy) * OGSM_Map(R,indreg)      ! Allocate to Census Regions
	    Dry_Well_Reg(K,indreg,iy,R) = (1.0 - ogsrl48(R,K,iy)) * ogwellsl48(R,K,iy) * OGSM_Map(R,indreg)
	  ENDDO

	  Success_Well(K,indreg,iy) = SUM(Success_Well_Reg(K,indreg,iy,1:MNL48N))          ! Collapse OGSM Regions within Census Region
	  Dry_Well(K,indreg,iy)     = SUM(Dry_Well_Reg(K,indreg,iy,1:MNL48N))

	  Total_Well(K,indreg,iy)   = Success_Well(K,indreg,iy) + Dry_Well(K,indreg,iy)

	ENDDO


!	Conventional Oil (K=1,2) and Natural Gas (K=3,4) are combined in the following calculations.

    if (SUM(Total_Well(1:2,indreg,iy)).lt.0.00001) then
       Dry_Well_Percent(1,indreg,iy) = 0.0
       if(prtdbgi.gt.1) write (6,'("WARNING: well count for conventional oil = ",F8.2," in region ",I4)'),SUM(Total_Well(1:2,indreg,iy)),indreg
    else
	   Dry_Well_Percent(1,indreg,iy) = SUM(Dry_Well(1:2,indreg,iy)) / SUM(Total_Well(1:2,indreg,iy))   ! Conventional Oil
    end if

    if (SUM(Total_Well(3:4,indreg,iy)).lt.0.00001) then
       Dry_Well_Percent(2,indreg,iy) = 0.0
       if(prtdbgi.gt.1) write (6,'("WARNING: well count for conventional gas = ",F8.2," in region ",I4)'),SUM(Total_Well(3:4,indreg,iy)),indreg
    else
	   Dry_Well_Percent(2,indreg,iy) = SUM(Dry_Well(3:4,indreg,iy)) / SUM(Total_Well(3:4,indreg,iy))   ! Conventional Natural Gas
    end if

    if (Total_Well(5,indreg,iy).lt.0.00001) then
       Dry_Well_Percent(3,indreg,iy) = 0.0
       if(prtdbgi.gt.1) write (6,'("WARNING: well count for tight gas = ",F8.2," in region ",I4)'),Total_Well(5,indreg,iy),indreg
    else
	   Dry_Well_Percent(3,indreg,iy) = Dry_Well(5,indreg,iy) / Total_Well(5,indreg,iy)                 ! Tight Gas
    end if

    if (Total_Well(6,indreg,iy).lt.00001) then
       Dry_Well_Percent(4,indreg,iy) = 0.0
       if(prtdbgi.gt.1) write (6,'("WARNING: well count for shale gas = ",F8.2," in region ",I4)'),Total_Well(6,indreg,iy),indreg
    else
	   Dry_Well_Percent(4,indreg,iy) = Dry_Well(6,indreg,iy) / Total_Well(6,indreg,iy)                 ! Shale Gas
    end if
	write (IFEEDOUT,*) 'year and region and total_well(7) =  ',curiyr,indreg,Total_Well(7,indreg,iy)
    if (Total_Well(7,indreg,iy).lt.00001) then
       Dry_Well_Percent(5,indreg,iy) = 0.0
       if(prtdbgi.gt.1) write (6,'("WARNING: well count for coalbed methane = ",F8.2," in region ",I4)'),Total_Well(7,indreg,iy),indreg
    else
  	   Dry_Well_Percent(5,indreg,iy) = Dry_Well(7,indreg,iy) / Total_Well(7,indreg,iy)                 ! Coal Bed Methane
    end if

!	Calculate Weighted Average Dry Well Percentage by Region

	Wtd_OG_WellFac(indreg,iy) = ( Dry_Well_Percent(1,indreg,iy) * SUM(OG_Prod(1:2,indreg,iy))  &
	                            + Dry_Well_Percent(2,indreg,iy) * SUM(OG_Prod(3:4,indreg,iy))  &
	                            + Dry_Well_Percent(3,indreg,iy) * OG_Prod(5,indreg,iy)         &
	                            + Dry_Well_Percent(4,indreg,iy) * OG_Prod(6,indreg,iy)         &
                                  + Dry_Well_Percent(5,indreg,iy) * OG_Prod(7,indreg,iy)  )      &
                                / SUM(OG_Prod(1:7,indreg,iy))

	Well_Index(indreg,iy) = Wtd_OG_WellFac(indreg,iy) - Wtd_OG_WellFac(indreg,iy-1)


!	************ Stock-Weighted Energy Intensity for Freight Trucks **************************

!	Tran Variables:	TFR_FTMPG(year,size,fuel,existing stock=2)	    Gasoline-Equivalent MPG
!					TFR_TRK_FAS_T(year,size,fuel,existing stock=2)  Existing Stock

!	Fuel Indices:   ify= (1)Diesel, (2)Gasoline, (3)LPG, (4)CNG


	data if_map /0,4,1,2,0,0 /      ! if_map(ift) should return the matching truck fuel (no electricity, renewables, or residual)

	Trk_Intens(curiyr,ift) = 1.0   ! Initialize to 1.0, to avoid error messages

	IF (if_map(ift).ne.0) THEN     ! Skip over electricity and coal for trucks

	  Trk_Intens(curiyr,ift) =  (  TFR_TRK_FAS_T(curiyr,1,if_map(ift),2)/TFR_FTMPG(curiyr,1,if_map(ift),2)   &
	                             + TFR_TRK_FAS_T(curiyr,2,if_map(ift),2)/TFR_FTMPG(curiyr,2,if_map(ift),2)   &
								 + TFR_TRK_FAS_T(curiyr,3,if_map(ift),2)/TFR_FTMPG(curiyr,3,if_map(ift),2) ) &
	                            / sum(TFR_TRK_FAS_T(curiyr,1:3,if_map(ift),2))

	ENDIF

        IF (Trk_Intens(curiyr-1,ift) .NE. 0.0) THEN
           VEH_Index(ift,curiyr) = (Trk_Intens(curiyr,ift)/Trk_Intens(curiyr-1,ift) -1.0)   ! Energy intensity improvement index for trucks
        ELSE
           VEH_Index(ift,curiyr) = 0.0             !  assume no change
        ENDIF


!	******************** End of Vehicle Calculations  **************************


!	Calculate replacement TPC (BCSC) for each region and fuel for Oil & Gas Mining sector

	IF(iyr.eq.ibyr2+1) GOTO 6689       ! Jump over calculations in the first year to avoid dividing by zero


	BCSC(1,IFUEL,ISTEP) =      TPC_Fac_Wt(ift,1) * VEH_Index(ift,curiyr)  &
	                         + TPC_Fac_Wt(ift,2) * Prod_Index(indreg,iy)  &
	                         + TPC_Fac_Wt(ift,3) * Well_Index(indreg,iy)


	BCSC(3,IFUEL,ISTEP) = 1.5 * BCSC(1,IFUEL,ISTEP)                          ! Well, this is what it is in the ITECH file.

6689	CONTINUE

      RETURN
      END SUBROUTINE OGSMTPC
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

!   Test Subroutine for Metals and Non-Metals Mining TPC Calculation
!
      SUBROUTINE OTH_MINTPC(IFUEL,ISTEP)
      use i_
      implicit none
	!include 'tranrep'
      !include 'coalrep'

      integer istep,iv,ifuel,ifx,ify,ift,isc,ifn,iy
	integer ifx_map(31), if_map(6)                                  ! Maps IDM fuel indices to the 5 fuels used in this section (zeros otherwise)


	 Real   VEH_Index(6,mnumyr)                                     ! Marginal change for vehicles, by fuel
	 Real   Trk_Intens(mnumyr,6)                                    ! Weighted Average Energy Intensity for Trucks

	 Real   EQP_Index(4,3,mnumyr)                                   ! Marginal change for equipment: heat, light, ventillation, by region
	 Real   Wt_Met_EQP_Index(4,mnumyr)                              ! Metals: Weighted Equipment index for the fuel in question
	 Real   Wt_NM_EQP_Index(4,mnumyr)                               ! Non-Metals: Weighted Equipment index for the fuel in question

	 Real   Raw_Grind_Eff     	                                    ! Raw Grinding Efficiency, from Cement subroutine
       Real   Raw_Grind_Eff_Lag	                                    ! Raw Grinding Efficiency, from Cement subroutine lag year

	 Real   Elec_Met_Wt(4,3)                                        ! Metal Mining Weighting factors for electric equipment components (3), by region (4)
	 Real   Elec_NM_Wt(4,3)                                         ! Non-Metal Mining Weighting factors for electric equipment components (3), by region (4)

	 Real   TPC_Met_Wt(4,2,6)                                       ! Metal Mining Weighting factors for Equipment & Productivity in TPC Calculation
	 Real   TPC_NM_Wt(4,2,6)                                        ! Non-Metal Mining Weighting factors for Equipment& Productivity in TPC Calculation

	 Real   NonEl_Met_Wt(2:6,2)                                       ! Metal Mining Weighting factors for non-electric equipment:  Heating & Vehicles, by fuel type
	 Real   NonEl_NM_Wt(2:6,2)                                        ! Non-Metal Mining Weighting factors for non-electric equipment:  Heating & Vehicles, by fuel type

	 Real   CL_L_Prod(4,2,16:mnumyr)                                   ! Production-weighted Labor Productivity rates, derived from CLUSER File.
	 Real   L_Prod_Index(4,2,mnumyr)                                ! Labor productivity indices by region, underground/surface, and year (2005 on)

	 Real   MetlShr(mnumyr)                                         ! Share of Non-Coal Mining that is Metals Mining
	 Real   Reg_MetlShr(4)                                          ! Normalized allocation of Metal Mining shares across regions

	 Real   Elec_Weight(4,3)                                        ! Not used: superseded by metal/non-metal factors above
	 Real   TPC_Weight(4,3,6)                                       ! Not used
	 Real   NonEl_Weight(2:6,2)                                     ! Not used



       COMMON /IN_COAL/Elec_Weight,TPC_Weight,NonEl_Weight,CL_L_Prod, &
                       Elec_Met_Wt,Elec_NM_Wt,NonEl_Met_Wt,NonEl_NM_Wt, &
                       TPC_Met_Wt,TPC_NM_Wt,Reg_MetlShr


  !	Derived from Macro model figures (components of MCREVIND_35)  POT_2050CHG add hardcode

	Data MetlShr(16:51) / 0.3635, 0.3641, 0.3745, 0.4167, 0.4336, 0.4557, 0.4672, 0.4677, 0.4389, 0.4191, &
	                      0.4067, 0.3973, 0.3871, 0.3781, 0.3699, 0.3606, 0.3507, 0.3409, 0.3309, 0.3220, &
						  0.3144, 0.3082, 0.3019, 0.2962, 0.2909, 0.2855, 0.2797, 0.2739, 0.2677, 0.2615, &
						  0.2550, 0.2485, 0.2406, 0.2327, 0.2259, 0.2196 /

	if(curiyr.gt.51) MetlShr(curiyr) = MetlShr(51)   !  Just wait till I get more numbers. POT_2050CHG 51 to 61 if add hardcode


!***************** Map IDM Fuel Numbers to the Indices Used for Mining ******************

	ifx=ifloc(ifuel,istep)	! Identifies the specific fuel associated with the IFUEL index for this industry

!					ifx
!	Electricity		1
!	Natural Gas		3
!	Distillate		11
!	Residual Oil	10
!	LPG				12
!	Coal			7
!	Gasoline		14
!	Other Pet.		22
!	Steam			31

	ifx_map = 0        ! Initialize:  ifx_map(ifx) should provide fuel indices in the proper order

	 ifx_map(1)  = 1  ! EL
	  ifx_map(3)  = 2  ! NG
	  ifx_map(11) = 3  ! DS
	  ifx_map(14) = 4  ! GS
	  ifx_map(7)  = 5  ! CL
	  ifx_map(10) = 6  ! RS

	IF(ifx_map(ifx).EQ.0) RETURN    ! If not one of the considered fuels, skip the rest of the subroutine.

	ift = ifx_map(ifx) ! For brevity  (the variable ifuel is not uniquely linked to the ifx indices)

      TPC_Met_Wt(indreg,2,ift) = (1.0 - TPC_Met_Wt(indreg,1,ift))   ! Weight of Labor Productivity Index for Metal Mining


      TPC_NM_Wt(indreg,2,ift) = (1.0 - TPC_NM_Wt(indreg,1,ift))   ! Weight of Labor Productivity Index for Non-Metal Mining



!	************ Stock-Weighted Energy Intensity for Freight Trucks **************************

!	Tran Variables:	TFR_FTMPG(year,size,fuel,existing stock=2)	    Gasoline-Equivalent MPG
!					TFR_TRK_FAS_T(year,size,fuel,existing stock=2)  Existing Stock

!	Fuel Indices:   ify= (1)Diesel, (2)Gasoline, (3)LPG, (4)CNG


	data if_map /0,4,1,2,0,0 /      ! if_map(ift) should return the matching truck fuel (no electricity, coal, or residual)

	Trk_Intens(curiyr,ift) = 1.0   ! Initialize to 1.0, to avoid error messages

	IF (if_map(ift).ne.0) THEN     ! Skip over electricity and coal for trucks

	  Trk_Intens(curiyr,ift) =  (  TFR_TRK_FAS_T(curiyr,1,if_map(ift),2)/TFR_FTMPG(curiyr,1,if_map(ift),2)   &
	                             + TFR_TRK_FAS_T(curiyr,2,if_map(ift),2)/TFR_FTMPG(curiyr,2,if_map(ift),2)   &
								 + TFR_TRK_FAS_T(curiyr,3,if_map(ift),2)/TFR_FTMPG(curiyr,3,if_map(ift),2) ) &
	                            / sum(TFR_TRK_FAS_T(curiyr,1:3,if_map(ift),2))

	ENDIF



!	******************** End of Vehicle Calculations  **************************



!	******************** Calculate Weighted Indices ****************************

	iy = curiyr       ! For brevity

!	Raw Grinding Efficiency from Cement Module
	
    if (curiyr.le.ICURIYR2+1) then !cement not calculated yet, POT_IBYR 19 to ICURIYR+2
	  Raw_Grind_Eff_lag=246.6
	  raw_grind_eff=246.6
	 else
	    if (curitr.eq.1) Raw_Grind_Eff_lag=raw_grind_eff        !save last year's value in first iterarion

          Raw_Grind_Eff = (elec_use_rpt(1)+elec_use_rpt(2))  &
		              / (tot_prodg(1)+tot_prodg(2))

       endif

!	Surface Mining Labor Productivity Index

        IF (CL_L_Prod(indreg,2,iy-1) .NE. 0.0) THEN
           L_Prod_Index(indreg,2,iy) = 1.0 - (CL_L_Prod(indreg,2,iy)/CL_L_Prod(indreg,2,iy-1))   ! Surface Mining Productivity (Underground is not used)
        ELSE
           L_Prod_Index(indreg,2,iy) = 0.0        ! assume no change
        ENDIF



	IF (ift.eq.1) THEN          ! For Electric Equipment

	EQP_Index(indreg,1,iy) = (Raw_Grind_Eff / Raw_Grind_Eff_lag -1.0)  ! From cement subroutine, no regional component
	EQP_Index(indreg,2,iy) = (WHSE_LightIndex(indreg,iy)  / WHSE_LightIndex(indreg,iy-1) -1.0)
	EQP_Index(indreg,3,iy) = (WHSE_VentIndex(indreg,iy)   / WHSE_VentIndex(indreg,iy-1)  -1.0)


!	Metals Mining
	Wt_Met_EQP_Index(indreg,iy) =     EQP_Index(indreg,1,iy) * Elec_Met_Wt(indreg,1) &        ! Grinding
	                                + EQP_Index(indreg,2,iy) * Elec_Met_Wt(indreg,2) &        ! Lighting
	                                + EQP_Index(indreg,3,iy) * Elec_Met_Wt(indreg,3)          ! Ventilation

!	Non-Metals Mining
	Wt_NM_EQP_Index(indreg,iy) =      EQP_Index(indreg,1,iy) * Elec_NM_Wt(indreg,1) &        ! Grinding
	                                + EQP_Index(indreg,2,iy) * Elec_NM_Wt(indreg,2) &        ! Lighting
	                                + EQP_Index(indreg,3,iy) * Elec_NM_Wt(indreg,3)          ! Ventilation


	  ELSE                      ! For Other Fuels (ift = 2-6)

        IF (ift.eq.6) THEN      ! For Residual Fuel Oil only
            EQP_Index(indreg,1,iy) = (WHSE_HeatIndex(indreg,3,iy)  / WHSE_HeatIndex(indreg,3,iy-1)  -1.0) ! Use Distillate results for Residual.
        ELSE
            EQP_Index(indreg,1,iy) = (WHSE_HeatIndex(indreg,ift,iy)  / WHSE_HeatIndex(indreg,ift,iy-1)  -1.0) ! Re-using this variable from above.
        ENDIF

        IF (Trk_Intens(iy-1,ift) .NE. 0.0) THEN
           VEH_Index(ift,iy) = (Trk_Intens(iy,ift)/Trk_Intens(iy-1,ift) -1.0)   ! Energy intensity improvement index for trucks
        ELSE
           VEH_Index(ift,iy) = 0.0         ! assume no change
        ENDIF

!	Metals Mining
	Wt_Met_EQP_Index(indreg,iy) = EQP_Index(indreg,1,iy) * NonEl_Met_Wt(ift,1) &        ! Heating
                                  + VEH_Index(ift,iy)      * NonEl_Met_Wt(ift,2)          ! Vehicles
!	Non-Metals Mining
	Wt_NM_EQP_Index(indreg,iy)  = EQP_Index(indreg,1,iy) * NonEl_NM_Wt(ift,1) &        ! Heating
                                  + VEH_Index(ift,iy)      * NonEl_NM_Wt(ift,2)          ! Vehicles


	ENDIF


!*******************************************************************************************


!	Calculate replacement TPC (BCSC) for each region and fuel for Other Mining sectors


	IF(iyr.eq.ibyr2+1) GOTO 6699       ! Jump over calculations in the first year to avoid dividing by zero


	BCSC(1,IFUEL,ISTEP) =    ( TPC_Met_Wt(indreg,1,ift) * Wt_Met_EQP_Index(indreg,iy)   &  ! Metals mining contribution
	                         + TPC_Met_Wt(indreg,2,ift) * L_Prod_Index(indreg,2,iy)  )  &
                               * ( MetlShr(iy)*Reg_MetlShr(indreg))                       &
                              +                                                           &
	                         ( TPC_NM_Wt(indreg,1,ift) * Wt_NM_EQP_Index(indreg,iy)     &  ! Non-Metals contribution
	                         +   TPC_NM_Wt(indreg,2,ift) * L_Prod_Index(indreg,2,iy) )  &
                               * ( 1.0 - MetlShr(iy)*Reg_MetlShr(indreg))


	BCSC(3,IFUEL,ISTEP) = 1.5 * BCSC(1,IFUEL,ISTEP)                          !

6699	CONTINUE

	IF (curitr.eq.1) Then
	 !! write(IUNITBUG,6664) curcalyr,ifx,ifuel,inddir,indreg,BCSC(1,IFUEL,ISTEP)
6664	  format(5(i5),2x,(f10.6))
	ENDIF

	CONTINUE

      RETURN
      END SUBROUTINE OTH_MINTPC
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX



!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!   Test Subroutine for Construction TPC Calculation
!
      SUBROUTINE CONTPC(IFUEL,ISTEP)
      use i_
      implicit none

     integer istep,iv,ifuel,ifx,ify,ift,isc,ifn,iy !,ir
	 integer ifx_map(31), if_map(5)                                  ! Maps IDM fuel indices to the 5 fuels used in this section (zeros otherwise)

     Real   EQP_Index(4,3,mnumyr)                                   ! Marginal change for equipment: heat, light, ventillation, by region
     Real   VEH_Index_SC(5,3,mnumyr)                                ! Marginal change for vehicles, by fuel & Size Class
     Real   Trk_Intens_SC(mnumyr,3,5)                               ! Weighted Average Energy Intensity for Trucks for 2 size classes, and cumulative
     Real   Wt_EQP_Index(indreg,curiyr)                             ! Weighted Equipment index for the fuel in question
     Real   Wt_VEH_Index(indreg,curiyr)                             ! Weighted Vehicle index for the fuel in question
     Real CON_Proxy_Wt(3,5)                                          ! Weighting shares for proxy measures: heat, light, ventilation
!	 Real CON_Equip_Wt(2,5)                                          ! Vehicle & Equipment functional weights by fuel (5)
     Real Weight_CON(4,3,5)                                          ! Component weights, by census region (ir=4),
	                                                                ! Components (ifn=3):  Buildings, Civil Engineering, Trade
                                                                      !  and Fuels (ift=5):  Electricity, NG, Dist, Other Petroleum, Gasoline
     Real GI_Hwy_Invest(mnumyr)                                     ! Gross investment in highways and streets, from GI Model (hard-coded temporarily)
     Real GI_Hwy_Index(4,mnumyr)                                    ! Index of Highway Spending for Asphalt & Road Oil TPC

	 Real TPC_Limit_CON												! Upper Constraint on TPC (ensures minimal level of improvement)
	 Real TPC_Scale_CON(4)											! Manual Scaling Factors to keep TPC within reasonable bounds
!*********** Data for weighting relative influence on TPC ******************************

!	Region 1                   EL	  NG	 DS     OT 	   GS
	Data Weight_CON(1,1,1:5) /0.354, 0.243, 0.185, 0.110, 0.185/      ! Buildings
	Data Weight_CON(1,2,1:5) /0.201, 0.363, 0.188, 0.346, 0.188/      ! Civil Engineering
	Data Weight_CON(1,3,1:5) /0.445, 0.394, 0.628, 0.545, 0.628/      ! Trade

!	Region 2                   EL	  NG	 DS     OT 	   GS
	Data Weight_CON(2,1,1:5) /0.333, 0.221, 0.174, 0.100, 0.174/
	Data Weight_CON(2,2,1:5) /0.235, 0.409, 0.218, 0.390, 0.218/
	Data Weight_CON(2,3,1:5) /0.432, 0.369, 0.608, 0.510, 0.608/


!	Region 3                   EL	  NG	 DS     OT 	   GS
	Data Weight_CON(3,1,1:5) /0.317, 0.199, 0.167, 0.091, 0.167/
	Data Weight_CON(3,2,1:5) /0.293, 0.484, 0.276, 0.467, 0.276/
	Data Weight_CON(3,3,1:5) /0.390, 0.317, 0.557, 0.442, 0.557/


!	Region 4                   EL	  NG	 DS     OT 	   GS
	Data Weight_CON(4,1,1:5) /0.335, 0.225, 0.173, 0.101, 0.173/
	Data Weight_CON(4,2,1:5) /0.221, 0.390, 0.205, 0.370, 0.205/
	Data Weight_CON(4,3,1:5) /0.444, 0.385, 0.622, 0.529, 0.622/

!	Functional Weights for Vehicles & Equipment (Currently ad-hoc)

!                              Vehicles Equipment
!	Data CON_Equip_Wt(1:2,1) /0.00, 1.00/                                   ! Electricity
!	Data CON_Equip_Wt(1:2,2) /0.20, 0.80/                                   ! Natural Gas
!	Data CON_Equip_Wt(1:2,3) /0.50, 0.50/                                   ! Distillate
!	Data CON_Equip_Wt(1:2,4) /0.00, 1.00/                                   ! Other Petroleum
!	Data CON_Equip_Wt(1:2,5) /0.25, 0.75/                                   ! Gasoline


!	Proxy Weights for Equipment Indices

!                               Heat  Light Ventilation
	Data CON_Proxy_Wt(1:3,1) /0.20, 0.20, 0.60/                              ! Electricity
	Data CON_Proxy_Wt(1:3,2) /1.00, 0.00, 0.00/                              ! Natural Gas
	Data CON_Proxy_Wt(1:3,3) /1.00, 0.00, 0.00/                              ! Distillate
	Data CON_Proxy_Wt(1:3,4) /1.00, 0.00, 0.00/                              ! LPG
	Data CON_Proxy_Wt(1:3,5) /1.00, 0.00, 0.00/                              ! Gasoline

!						     Heat Light	Vent Veh
	Data TPC_Scale_CON(1:4) /1.0, 10.0, 10.0, 10.0/				! Ad Hoc scaling factors for TPC components

!	Data GI_Hwy_Invest(8:51)     /61.4897, 62.6888, 66.5798, 68.3509, 73.5015, &  ! State and local government real gross investment
!                                    70.6026, 68.7994, 68.4532, 65.2309, 66.0548, &  !   in highways and streets.  (2005$)  1997 - 2040
!                                    58.8301, 57.2044, 56.3068, 55.4900, 50.6383, &  ! From GI Model (MCEVWORK.wk1)
!                                    48.1674, 47.2923, 47.3310, 47.7127, 48.1399, &  ! Variable name:  GSLGISNHWYR_0 (annualized quarterly results)
!                                    48.5999, 49.1389, 49.6229, 49.8638, 50.1417, &  !
!                                    50.7719, 51.9162, 53.4217, 54.7916, 56.2198, &  ! Temporary hard-code pending coordination w/ MAM
!                                    57.7712, 59.3605, 60.9875, 62.6648, 64.4154, &  !
!                                    66.2464, 68.1535, 70.1272, 72.1302, 74.1888, &  ! Used to calculate asphalt and road oil consumption
!                                    76.3551, 78.6520, 81.0608, 83.5334/

! overwrite with Russ's road investment variable
      write (IFEEDOUT,*)
       GI_Hwy_Invest(curiyr) = mc_gslgisnhwyr(curiyr)
       GI_Hwy_Invest(curiyr-1) = mc_gslgisnhwyr(curiyr-1)
      write (IFEEDOUT,*) 'check current year NEW hwy ',curiyr,mc_gslgisnhwyr(curiyr)
      write (IFEEDOUT,*) 'check last years   NEW hwy ',curiyr,mc_gslgisnhwyr(curiyr-1)
      write (IFEEDOUT,*) 'after current year hwy ',curiyr,GI_Hwy_Invest(curiyr)
      write (IFEEDOUT,*) 'after last years   hwy ',curiyr,GI_Hwy_Invest(curiyr-1)
      write (IFEEDOUT,*)

!***************** End Data *************************************************************


	ifx = ifloc(ifuel,istep)	! Identifies the specific fuel associated with the IFUEL index for this industry

!                             ifx             ift
!Electricity                    1               1
!Natural Gas                    3               2
!Distillate                    11               3
!LPG                           12               -
!Coal                           7               -
!Gasoline                      14               5
!Other Petroleum               17               4
!Steam                         31               -

	ifx_map = 0        ! Initialize:  ifx_map(ifx) should provide fuel indices in the proper order

	  ifx_map(1)  = 1  ! EL
	  ifx_map(3)  = 2  ! NG
	  ifx_map(11) = 3  ! DS
	  ifx_map(17) = 4  ! OT
	  ifx_map(14) = 5  ! GS

	IF(ifx_map(ifx).EQ.0) RETURN    ! If not one of the considered fuels, skip the rest of the subroutine.

	ift = ifx_map(ifx) ! For brevity  (the variable ifuel is not uniquely linked to the ifx indices)

!	************ Stock-Weighted Energy Intensity for Freight Trucks **************************

!	Tran Variables:	TFR_FTMPG(year,size,fuel,existing stock=2)	    Gasoline-Equivalent MPG
!					TFR_TRK_FAS_T(year,size,fuel,existing stock=2)  Existing Stock

!	Fuel Indices:   ify= (1)Diesel, (2)Gasoline, (3)LPG, (4)CNG   (LPG is assumed to be zero in construction)


	data if_map /0,4,1,1,2/      ! if_map(ift) should return the matching truck fuel (no electricity or LPG) ("Other" uses Diesel as a proxy)

	DO isc = 1,3
	   Trk_Intens_SC(ibyr2-1-1989,isc,ift) = 1.0   ! Initialize to 1.0, to avoid error messages
	   Trk_Intens_SC(curiyr,isc,ift) = 1.0   ! Initialize to 1.0, to avoid error messages
	ENDDO

	IF (if_map(ift).ne.0) THEN     ! Skip over electricity and LPG for trucks

      ! All Trucks  (Buildings Function)

	  Trk_Intens_SC(curiyr,1,ift) =  (  TFR_TRK_FAS_T(curiyr,1,if_map(ift),2)/TFR_FTMPG(curiyr,1,if_map(ift),2)   &
	                              +     TFR_TRK_FAS_T(curiyr,2,if_map(ift),2)/TFR_FTMPG(curiyr,2,if_map(ift),2)   &
							  	  +     TFR_TRK_FAS_T(curiyr,3,if_map(ift),2)/TFR_FTMPG(curiyr,3,if_map(ift),2) ) &
	                              / sum(TFR_TRK_FAS_T(curiyr,1:3,if_map(ift),2))


      ! Heavy Trucks  (Civil Engineering Function)

	  Trk_Intens_SC(curiyr,2,ift) =  1 / TFR_FTMPG(curiyr,3,if_map(ift),2)


      ! Medium & Medium-Heavy Trucks  (Trade Function)

	  Trk_Intens_SC(curiyr,3,ift) =  (  TFR_TRK_FAS_T(curiyr,1,if_map(ift),2)/TFR_FTMPG(curiyr,1,if_map(ift),2) &
	                              +     TFR_TRK_FAS_T(curiyr,2,if_map(ift),2)/TFR_FTMPG(curiyr,2,if_map(ift),2)) &
	                              / sum(TFR_TRK_FAS_T(curiyr,1:2,if_map(ift),2))

	ENDIF


! *********************************************************************

!	Calculate marginal changes in energy intensity


!	Vehicles

	DO isc=1,3
	  VEH_Index_SC(ift,isc,curiyr) =  MIN(((Trk_Intens_SC(curiyr,isc,ift)/Trk_Intens_SC(curiyr-1,isc,ift) -1.0)/TPC_Scale_CON(4)), TPC_Limit_CON)

!      write(IUNITBUG,6644) curiyr, ift, isc, Trk_Intens_SC(curiyr-1,1:3,ift),Trk_Intens_SC(curiyr,1:3,ift), VEH_Index_SC(ift,1:3,curiyr)

	ENDDO
!6644  Format(3(i5),9(f7.4))

	Wt_VEH_Index(indreg,curiyr) = VEH_Index_SC(ift,1,curiyr) * Weight_CON(indreg,1,ift) &
	                            + VEH_Index_SC(ift,2,curiyr) * Weight_CON(indreg,2,ift) &
	                            + VEH_Index_SC(ift,3,curiyr) * Weight_CON(indreg,3,ift)


!	Equipment (Weighted average for electricity, Heating Index for other fuels)

	EQP_Index(indreg,1,curiyr) = MIN(((WHSE_HeatIndex(indreg,ift,curiyr) / WHSE_HeatIndex(indreg,ift,curiyr-1) -1.0)/TPC_Scale_CON(1)), TPC_Limit_CON)
	EQP_Index(indreg,2,curiyr) = MIN(((WHSE_LightIndex(indreg,curiyr)    / WHSE_LightIndex(indreg,curiyr-1) -1.0)   /TPC_Scale_CON(2)), TPC_Limit_CON)
	EQP_Index(indreg,3,curiyr) = MIN(((WHSE_VentIndex(indreg,curiyr)     / WHSE_VentIndex(indreg,curiyr-1)  -1.0)   /TPC_Scale_CON(3)), TPC_Limit_CON)

	Wt_EQP_Index(indreg,curiyr) = EQP_Index(indreg,1,curiyr) * CON_Proxy_Wt(1,ift) &
	                            + EQP_Index(indreg,2,curiyr) * CON_Proxy_Wt(2,ift) &
	                            + EQP_Index(indreg,3,curiyr) * CON_Proxy_Wt(3,ift)


!	Specific measure for Asphalt & Road Oil (IFX = 17).  Link to State & Local Highway spending

!	GI_Hwy_Index(indreg,curiyr) =   - 1.0 + ((GI_Hwy_Invest(curiyr)/GI_Hwy_Invest(curiyr-1))   &
!	                                      /  (PRODX/PRODXlag))
    GI_Hwy_Index(indreg,curiyr) = (GI_Hwy_Invest(curiyr)/GI_Hwy_Invest(22)) * 0.008

    write (IFEEDOUT,*) 'highway year ',curiyr
    write (IFEEDOUT,*) 'GI_Hwy  ',GI_Hwy_Index(indreg,curiyr)
    write (IFEEDOUT,*) 'ratio =  ',GI_Hwy_Invest(curiyr)/GI_Hwy_Invest(curiyr-1)
    write (IFEEDOUT,*) 'new ratio =  ',GI_Hwy_Invest(curiyr)/GI_Hwy_Invest(22)
!************************************************************************

	!IF ((CURIYR.EQ.LASTYR).AND.(NCRL.EQ.1).and.(prtdbgi.gt.1)) THEN

	!write(IUNITBUG,*)
	!write(IUNITBUG,*) '  Heat Index'

	!do iy=15,lastyr
	! write(IUNITBUG,6530) iy,(WHSE_HeatIndex(ir,1,iy),ir=1,4),(WHSE_HeatIndex(ir,2,iy),ir=1,4),(WHSE_HeatIndex(ir,3,iy),ir=1,4)
	!enddo

	!write(IUNITBUG,*)
	!write(IUNITBUG,*) '  Vent Index'

	!do iy=15,lastyr
	 !write(IUNITBUG,6531) iy,(WHSE_VentIndex(ir,iy),ir=1,4)
	!enddo

	!write(IUNITBUG,*)
	!write(IUNITBUG,*) '  Light Index'

	!do iy=15,lastyr
	! write(IUNITBUG,6531) iy,(WHSE_LightIndex(ir,iy),ir=1,4)
	!enddo


	!endif

6530	Format (i4,2x,12(f8.4,2x))
6531  Format (i4,2x,4(f8.4,2x))

!*********************************************************************

!	IF(iyr.eq.ibyr2+1) GOTO 6677       ! Jump over calculations in the first year to avoid dividing by zero
	IF(curiyr.lt.ICURIYR+6) GOTO 6677       ! Jump over calculations in the first year to avoid dividing by zero POT_ibyr2OTHER 23 to ICURIYR+6
    
       write (IFEEDOUT,*) 'istep = ',istep
! ******************** Calculate TPCs as weighted average of components ************************
!    IF (ISTEP.eq.1) THEN          ! ISTEP 1 is Vehicles
       write (IFEEDOUT,*) 'ifx ift = ',ifx,ift
       IF (ifx.ne.17) then
          BCSC(1,IFUEL,ISTEP) = Wt_VEH_Index(indreg,curiyr)
          BCSC(3,IFUEL,ISTEP) = 1.5 * BCSC(1,IFUEL,ISTEP)       ! Well, this is what it is in the ITECH file.
       ELSE
!          BCSC(1,IFUEL,ISTEP) = 0.0                             ! Asphalt & road oil is reported in equipment
!       ENDIF
!	ELSE                          ! ISTEP 2 is currently the only alternative so "Equipment"
!       IF (ifx.ne.17) then
!                 write (IFEEDOUT,*) 'asphalt check 7'
!                 write (IFEEDOUT,*) 'ifx ift = ',ifx,ift
!          BCSC(1,IFUEL,ISTEP) = Wt_EQP_Index(indreg,curiyr)
!          BCSC(3,IFUEL,ISTEP) = 1.5 * BCSC(1,IFUEL,ISTEP)       ! Well, this is what it is in the ITECH file.
!       ELSE
!          BCSC(1,IFUEL,ISTEP) = 0.5 * GI_Hwy_Index(indreg,curiyr) + 0.5 * Wt_VEH_Index(indreg,curiyr)
          BCSC(1,IFUEL,ISTEP) = 0.3 * GI_Hwy_Index(indreg,curiyr) + 0.7 * Wt_VEH_Index(indreg,curiyr)
          IF (BCSC(1,IFUEL,ISTEP).GE.0.0) THEN
             BCSC(3,IFUEL,ISTEP) = BCSC(1,IFUEL,ISTEP)/1.5      ! Sometimes the TPC will be positive.  If so, moderate growth.
          ELSE
             BCSC(3,IFUEL,ISTEP) = BCSC(1,IFUEL,ISTEP)* 1.5
          END IF
          ENDIF
!	ENDIF

6677  CONTINUE

	IF (curitr.eq.1) then
	  write(IUNITBUG,*) 'year',curcalyr,'fuel',ifx,'reg',indreg,'step',istep,BCSC(1,IFUEL,ISTEP)
	ENDIF


      RETURN
      END SUBROUTINE CONTPC

!**********************************************************************************
!SUSAN_UPDATE

      SUBROUTINE CHECK_CON_VARS

      use i_

      IMPLICIT NONE
	  INTEGER IFUEL, IREG, IFF, IS, IFN, IY
	  character*16 FUELNAME(18)
! Corresponding Indices in Con and QTYMAIN array
!
!             con   qtymain
! elec          1    1,2
! ngas          2    3,4,6
! steam coal    3    7
! met coal      4    8
! net coke imp  5    9
! resid         6   10
! dist          7   11
! lpg           8   12
! mogas         9   14
! still gas    10   15
! petrol coke  11   16
! asphalt      12   17
! petrol feed  13   18,19,21 ! lubes,petrochemfeedstock, oth pet feedstoc
! kero         14   20
! oth ind      15   22
! ng feed      16   5
! lpg feed     17   13
! renew        18

      DATA  FUELNAME/&
      'Electricity         ', & !   1
      'Natural Gas         ', & !   2
	  'Steam Coal          ', & !   3
	  'Met Coal            ', & !   4
	  'Net Coke Imports    ', & !   5
	  'Residual Fuel       ', & !   6
	  'Distillate          ', & !   7
	  'LPG                 ', & !   8
	  'MOGAS               ', & !   9
	  'Still Gas           ', & !  10
	  'Pet Coke            ', & !  11
	  'Asphalt             ', & !  12
	  'PetroChem Feed      ', & !  13
	  'Kerosene            ', & !  14
	  'Other Industrial    ', & !  15
	  'NG Feedstock        ', & !  16
	  'LPG Feedstock       ', & !  17
	  'Renewables          '/ ! 18

	    IY=IYR-1989

      IF (CURCALYR .EQ. ibyr2) THEN
	  WRITE(IUNITBUG,'(7(A12,","),A11)') "CURCALYR","YEAR INDEX","FUEL_CODE","FUEL NAME","CON VARNAME","CON VALUE", "CO2 EMISSIONS", "CO2 FACTOR"
	  ENDIF


	  DO IFUEL=1,18


		WRITE(IUNITBUG,811) CURCALYR, IY, IFUEL, FUELNAME(IFUEL), "AGRICULTURE         ", AGCON(IFUEL,5,IY), AGCO2(IFUEL,IY),CO2EM(IFUEL,IY)
		WRITE(IUNITBUG,811) CURCALYR, IY, IFUEL, FUELNAME(IFUEL), "MINING              ", MINECON(IFUEL,5,IY), MINECO2(IFUEL,IY), CO2EM(IFUEL,IY)
		WRITE(IUNITBUG,811) CURCALYR, IY, IFUEL, FUELNAME(IFUEL), "CONSTRUCTION        ", CONSTCON(IFUEL,5,IY), CONSTCO2(IFUEL,IY), CO2EM(IFUEL,IY)
		WRITE(IUNITBUG,811) CURCALYR, IY, IFUEL, FUELNAME(IFUEL), "FOOD                ", FOODCON(IFUEL,5,IY), FOODCO2(IFUEL,IY), CO2EM(IFUEL,IY)
		WRITE(IUNITBUG,811) CURCALYR, IY, IFUEL, FUELNAME(IFUEL), "PAPER               ", PAPERCON(IFUEL,5,IY),PAPERCO2(IFUEL,IY), CO2EM(IFUEL,IY)
		WRITE(IUNITBUG,811) CURCALYR, IY, IFUEL, FUELNAME(IFUEL), "CHEMICALS           ", CHEMCON(IFUEL,5,IY), CHEMCO2(IFUEL,IY), CO2EM(IFUEL,IY)
		WRITE(IUNITBUG,811) CURCALYR, IY, IFUEL, FUELNAME(IFUEL), "GLASS               ", GLASSCON(IFUEL,5,IY), GLASSCO2(IFUEL,IY), CO2EM(IFUEL,IY)
		WRITE(IUNITBUG,811) CURCALYR, IY, IFUEL, FUELNAME(IFUEL), "CEMENT&LIME         ", CEMENTCON(IFUEL,5,IY), CEMENTCO2(IFUEL,IY), CO2EM(IFUEL,IY)
		WRITE(IUNITBUG,811) CURCALYR, IY, IFUEL, FUELNAME(IFUEL), "IRON&STEEL          ", STEELCON(IFUEL,5,IY), STEELCO2(IFUEL,IY), CO2EM(IFUEL,IY)
		WRITE(IUNITBUG,811) CURCALYR, IY, IFUEL, FUELNAME(IFUEL), "ALUMINUM            ", ALUMCON(IFUEL,5,IY), ALUMCO2(IFUEL,IY), CO2EM(IFUEL,IY)
		WRITE(IUNITBUG,811) CURCALYR, IY, IFUEL, FUELNAME(IFUEL), "FABRICATED METALS   ", FABMETALCON(IFUEL,5,IY), FABMETALCO2(IFUEL,IY), CO2EM(IFUEL,IY)
		WRITE(IUNITBUG,811) CURCALYR, IY, IFUEL, FUELNAME(IFUEL), "MACHINE EQUIPMENT   ", MACHINECON(IFUEL,5,IY), MACHINECO2(IFUEL,IY), CO2EM(IFUEL,IY)
		WRITE(IUNITBUG,811) CURCALYR, IY, IFUEL, FUELNAME(IFUEL), "COMPUTER EQUIPMENT  ", COMPUTECON(IFUEL,5,IY), COMPUTECO2(IFUEL,IY), CO2EM(IFUEL,IY)
		WRITE(IUNITBUG,811) CURCALYR, IY, IFUEL, FUELNAME(IFUEL), "TRANSPORTATION EQUIP", TRANEQUIPCON(IFUEL,5,IY), TRANEQUIPCO2(IFUEL,IY), CO2EM(IFUEL,IY)
		WRITE(IUNITBUG,811) CURCALYR, IY, IFUEL, FUELNAME(IFUEL), "ELECTRICAL EQUIP    ", ELECEQUIPON(IFUEL,5,IY), ELECEQUIPCO2(IFUEL,IY), CO2EM(IFUEL,IY)
		WRITE(IUNITBUG,811) CURCALYR, IY, IFUEL, FUELNAME(IFUEL), "PLASTICS            ", PLASTICCON(IFUEL,5,IY), PLASTICCO2(IFUEL,IY), CO2EM(IFUEL,IY)
		WRITE(IUNITBUG,811) CURCALYR, IY, IFUEL, FUELNAME(IFUEL), "WOOD PRODUCTS       ", WOODPRODCON(IFUEL,5,IY), WOODPRODCO2(IFUEL,IY), CO2EM(IFUEL,IY)
		WRITE(IUNITBUG,811) CURCALYR, IY, IFUEL, FUELNAME(IFUEL), "BOM                 ", BOMOTHCON(IFUEL,5,IY), BOMOTHCO2(IFUEL,IY), CO2EM(IFUEL,IY)
		WRITE(IUNITBUG,811) CURCALYR, IY, IFUEL, FUELNAME(IFUEL), "REFINING            ", REFCON(IFUEL,5,IY), REFCO2(IFUEL,IY),CO2EM(IFUEL,IY)



	  END DO

811    FORMAT(3(I4,","),2(A20,","),3(F14.4,","))


	  END SUBROUTINE CHECK_CON_VARS
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!SUSAN_UPDATE

	  SUBROUTINE CHECK_FOR_STUFF

	  use i_

	  IMPLICIT NONE
	  INTEGER IFUEL, IREG, IFF, IS, IFN
	  character*16 FUELNAME(48)
      character*14 INDNAME2(21)
	  INTEGER INTERMAP(6)/31,32,33,34,35,36/
	  INTEGER RENEWMAP(8)/41,42,43,44,45,46,47,48/
      CHARACTER*16 GENFUELNAME(4)

	  DATA GENFUELNAME/&
	  'NG              ', & ! 1
	  'Coal            ', & ! 2
	  'Oil             ', & ! 3
	  'Other           ' / ! 4

      DATA  FUELNAME/&
      'Electricity     ', & !   1
      'NA              ', & !   2
      'NG_Core         ', & !   3
      'NG_Noncore      ', & !   4
      'NG_Feedstock    ', & !   5
      'Lease&Plant     ', & !   6
      'Steam_coal      ', & !   7
      'Met_coal        ', & !   8
      'Net_coke_import ', & !   9
      'Residual_fuel   ', & !  10
      'Distillate      ', & !  11
      'LPG_HP          ', & !  12
      'LPG_Feedstock   ', & !  13
      'Mogas           ', & !  14
      'Still_gas       ', & !  15
      'Pet_coke        ', & !  16
      'Asphalt         ', & !  17
   	  'Lubes_Waxes     ', & !  18
	  'Pet_chem_feed   ', & !  19
	  'Kerosene        ', & !  20
	  'OT_Petro_feed   ', & !  21
	  'OT_Petro        ', & !  22
	  'NA              ', & !  23
	  'NA              ', &  !  24
	  'NA              ', &  !  25
	  'NA              ', &  !  26
	  'NA              ', &  !  27
	  'NA              ', &  !  28
	  'NA              ', &  !  29
	  'NA              ', &  !  30
      'Steam           ', &  !  31
	  'Coke_oven_gas   ', &  !  32
	  'Blast_furn_gas  ', &  !  33
	  'Other_byprod_gas', &  !  34
      'Waste_heat      ', &  !  35
	  'Coke            ', &  !  36
	  'NA              ', &  !  37
	  'NA              ', &  !  38
	  'NA              ', &  !  39
	  'NA              ', &  !  40
	  'Hydropower      ', &  !  41
	  'Biomass_wood    ', &  !  42
	  'Biomass_pulp_liq', &  !  43
	  'Geothermal      ', &  !  44
      'Solar           ', &  !  45
	  'Photovoltaic    ', &  !  46
      'Wind            ', &  !  47
      'MS_Waste        '/   !  48

	  DATA  INDNAME2/&
      'AG_CROPS      ', & !   1
      'AG_OTHER      ', & !   2
      'COAL_MINING   ', & !   3
      'OIL_AND_GAS   ', & !   4
      'MINING_OTHER  ', & !   5
      'CONSTRUCTION  ', & !   6
	  'FOOD          ', & !   7
	  'PAPER         ', & !   8
	  'CHEMICALS     ', & !   9
      'GLASS         ', & !  10
	  'CEMENT_LIME   ', & !  11
	  'IRON_STEEL    ', & !  12
	  'ALUMINUM      ', & !  13
	  'FAB_METALS    ', & !  14
	  'MACHINERY     ', & !  15
	  'COMPUTER_EQUIP', & !  16
	  'TRANS_EQUIP   ', & !  17
	  'APPLIANCES    ', & !  18
	  'WOOD_PRODUCTS ', & !  19
	  'PLASTICS      ', & !  20
	  'BOM           '/  !  21


	  WRITE(IUNITOUTF,108) "CURCALYR","IND_CODE","INDUSTRY","REGION","VARNAME","FUEL_CODE","FUEL","VALUE"
108   FORMAT(7(A10,","),A8)

	  DO INDNUM=1,INDMAX
	     INDDIR=INDNUM

       DO IREG=1,4
	      INDREG=IREG

!**********************************************************
!  copy region-industry data to local
!**********************************************************

          CALL RDBIN

		  DO IFUEL=1,22
			IF (QTYMAIN(IFUEL,INDREG) .NE. 0.0) &
			   WRITE(IUNITOUTF,810) CURCALYR, INDNUM, INDNAME2(INDNUM), INDREG, "QTYMAIN", IFUEL, FUELNAME(IFUEL), QTYMAIN(IFUEL,INDREG)
            IF (ENPMQTY(IFUEL) .NE. 0.0) &
			   WRITE(IUNITOUTF,810) CURCALYR, INDNUM, INDNAME2(INDNUM), INDREG, "ENPMQTY", IFUEL, FUELNAME(IFUEL), ENPMQTY(IFUEL)
            IF (BYPBSCM(IFUEL) .NE. 0.0) &
			   WRITE(IUNITOUTF,810) CURCALYR, INDNUM, INDNAME2(INDNUM), INDREG, "BYPBSCM", IFUEL, FUELNAME(IFUEL), BYPBSCM(IFUEL)
		  END DO


		  DO IFUEL=1,6
		    IF (QTYINTR(IFUEL,INDREG) .NE. 0.0) &
			   WRITE(IUNITOUTF,810) CURCALYR, INDNUM, INDNAME2(INDNUM), INDREG, "QTYINTR", INTERMAP(IFUEL), &
			   FUELNAME(INTERMAP(IFUEL)), QTYINTR(IFUEL,INDREG)
			IF(ENPIQTY(IFUEL) .NE. 0.0) &
			   WRITE(IUNITOUTF,810) CURCALYR, INDNUM, INDNAME2(INDNUM), INDREG, "ENPIQTY", INTERMAP(IFUEL), &
			   FUELNAME(INTERMAP(IFUEL)), ENPIQTY(IFUEL)
			IF (BYPBSCI(IFUEL) .NE. 0.0) &
			   WRITE(IUNITOUTF,810) CURCALYR, INDNUM, INDNAME2(INDNUM), INDREG, "BYPBSCI", INTERMAP(IFUEL), &
			   FUELNAME(INTERMAP(IFUEL)), BYPBSCI(IFUEL)
		  END DO

		  DO IFUEL=1,8
		    IF (QTYRENW(IFUEL,INDREG) .NE. 0.0) &
			   WRITE(IUNITOUTF,810) CURCALYR, INDNUM, INDNAME2(INDNUM), INDREG, "QTYRENW", RENEWMAP(IFUEL), &
			   FUELNAME(RENEWMAP(IFUEL)), QTYRENW(IFUEL,INDREG)
			IF (ENPRQTY(IFUEL) .NE. 0.0) &
			   WRITE(IUNITOUTF,810) CURCALYR, INDNUM, INDNAME2(INDNUM), INDREG, "ENPRQTY", RENEWMAP(IFUEL), &
			   FUELNAME(RENEWMAP(IFUEL)), ENPRQTY(IFUEL)
			IF (BYPBSCR(IFUEL) .NE. 0.0) &
			   WRITE(IUNITOUTF,810) CURCALYR, INDNUM, INDNAME2(INDNUM), INDREG, "BYPBSCR", RENEWMAP(IFUEL), &
			   FUELNAME(RENEWMAP(IFUEL)), BYPBSCR(IFUEL)

		  END DO

		    IF (ENBQTY(5,1) .NE. 0.0) &
			   WRITE(IUNITOUTF,810) CURCALYR, INDNUM, INDNAME2(INDNUM), INDREG, "ENBQTY", 1, FUELNAME(1), ENBQTY(5,1)
			IF (ENBQTY(5,2) .NE. 0.0) &
			   WRITE(IUNITOUTF,810) CURCALYR, INDNUM, INDNAME2(INDNUM), INDREG, "ENBQTY", 3, FUELNAME(3), ENBQTY(5,2)
			IF (ENBQTY(5,4) .NE. 0.0) &
			   WRITE(IUNITOUTF,810) CURCALYR, INDNUM, INDNAME2(INDNUM), INDREG, "ENBQTY", 11, FUELNAME(11), ENBQTY(5,4)
			IF (ENBQTY(5,5) .NE. 0.0) &
			   WRITE(IUNITOUTF,810) CURCALYR, INDNUM, INDNAME2(INDNUM), INDREG, "ENBQTY", 12, FUELNAME(12), ENBQTY(5,5)
			IF (ENBQTY(5,3) .NE. 0.0) &
			   WRITE(IUNITOUTF,810) CURCALYR, INDNUM, INDNAME2(INDNUM), INDREG, "ENBQTY", 31, FUELNAME(31), ENBQTY(5,3)

          DO IFUEL=1,IFSMAX
             IFF = IFSLOC(IFUEL)
             IF (ENSQTY(IFUEL) .NE. 0.0) &
			    WRITE(IUNITOUTF,810) CURCALYR, INDNUM, INDNAME2(INDNUM), INDREG, "ENSQTY", IFF, FUELNAME(IFF), ENSQTY(IFUEL)
          END DO

		  IF (ELOWN .NE. 0.0) &
		     WRITE(IUNITOUTF,810) CURCALYR, INDNUM, INDNAME2(INDNUM), INDREG, "ELOWN", 1, FUELNAME(1), ELOWN
          IF (ELSALE .NE. 0.0) &
		     WRITE(IUNITOUTF,810) CURCALYR, INDNUM, INDNAME2(INDNUM), INDREG, "ELSALE", 1, FUELNAME(1), ELSALE
		  IF (COGSTEAM .NE. 0.0) &
		     WRITE(IUNITOUTF,810) CURCALYR, INDNUM, INDNAME2(INDNUM), INDREG, "COGSTEAM", 31, FUELNAME(31), COGSTEAM
		  IF (NONCOGSTEAM .NE. 0.0) &
		     WRITE(IUNITOUTF,810) CURCALYR, INDNUM, INDNAME2(INDNUM), INDREG, "NONCOGSTEAM", 31, FUELNAME(31), NONCOGSTEAM
		  IF (BIOSTEAM .NE. 0.0) &
		     WRITE(IUNITOUTF,810) CURCALYR, INDNUM, INDNAME2(INDNUM), INDREG, "BIOSTEAM", 31, FUELNAME(31), BIOSTEAM
		  IF (NONCOGFOSSTEAM .NE. 0.0) &
		     WRITE(IUNITOUTF,810) CURCALYR, INDNUM, INDNAME2(INDNUM), INDREG, "NONCOGFOSSTEAM", 31, FUELNAME(31), NONCOGFOSSTEAM
          IF (STEMCUR .NE. 0.0) &
		     WRITE(IUNITOUTF,810) CURCALYR, INDNUM, INDNAME2(INDNUM), INDREG, "STEMCUR", 31, FUELNAME(31), STEMCUR
          IF (EMPLX .NE. 0.0) &
		     WRITE(IUNITOUTF,810) CURCALYR, INDNUM, INDNAME2(INDNUM), INDREG, "EMPLX", 0, " ", EMPLX
          IF (PRODX .NE. 0.0) &
		     WRITE(IUNITOUTF,810) CURCALYR, INDNUM, INDNAME2(INDNUM), INDREG, "PRODX", 0, " ", PRODX
          IF (PRODVX .NE. 0.0) &
		     WRITE(IUNITOUTF,810) CURCALYR, INDNUM, INDNAME2(INDNUM), INDREG, "PRODVX", 0, " ", PRODVX



	      DO IFUEL=1,4
		    IF (RPTGEN(IFUEL) .NE. 0) &
			WRITE(IUNITOUTF,810) CURCALYR, INDNUM, INDNAME2(INDNUM), INDREG, "RPTGEN", IFUEL, GENFUELNAME(IFUEL), RPTGEN(IFUEL)
	        IF (RPTCAP(IFUEL) .NE. 0) &
			WRITE(IUNITOUTF,810) CURCALYR, INDNUM, INDNAME2(INDNUM), INDREG, "RPTCAP", IFUEL, GENFUELNAME(IFUEL), RPTCAP(IFUEL)
		 	IF (GENFUEL(IFUEL) .NE. 0) &
			WRITE(IUNITOUTF,810) CURCALYR, INDNUM, INDNAME2(INDNUM), INDREG, "GENFUEL", IFUEL, GENFUELNAME(IFUEL), GENFUEL(IFUEL)
		  END DO

		END DO  ! END REGION LOOP





	   END DO   ! END INDUSTRY LOOP

810    FORMAT(2(I4,","),A14,",",I4,",",A14,",",I4,",",A16,",",F12.4)

	  END SUBROUTINE CHECK_FOR_STUFF

!SUSAN_UPDATE

	  SUBROUTINE CALIBRATE
      use i_
      IMPLICIT NONE

	  INTEGER IFUEL, IREG, ICR, IFF, IS, IFn
	  REAL TQMCHECK(23,5)
      REAL TQRCHECK(9,5)
	  REAL SUMCDIV
	  ! Index Constants for Industrial Tables 35 to 44 not sure why this is here ?????
      !integer ixEL/1/,ixNG/2/,ixCL/3/,ixMC/4/, &
      !        ixCI/5/,ixRF/6/,ixDS/7/,ixLG/8/,ixMG/9/, &
      !        ixSG/10/,ixPC/11/,ixAS/12/,ixPF/13/,ixKS/14/, &
      !        ixOP/15/,ixNF/16/,ixLF/17/,ixRN/18/

              integer ixNG/2/,ixCL/3/,ixRF/6/


	  TQMCHECK( : , : ) = 0.0D0
	  TQRCHECK( : , : ) = 0.0D0

	  DO INDNUM=1,INDMAX
	     INDDIR=INDNUM

       DO IREG=1,4
	      INDREG=IREG

!**********************************************************
!  copy region-industry data to local
!**********************************************************
          CALL RDBIN

	      QTYMAIN(1:22,INDREG) = QTYMAIN(1:22,INDREG) * BF(CURIYR,1:22,INDREG)
          QTYRENW(1:8,INDREG) = QTYRENW(1:8,INDREG) * RBF(CURIYR,1:8,INDREG)

		  ELOWN = ELOWN * BF(CURIYR,1,INDREG)
          ENPMQTY(1:22) = ENPMQTY(1:22) * BF(CURIYR,1:22,INDREG)
		  ENBQTY(1:5,1) = ENBQTY(1:5,1) * BF(CURIYR,1,INDREG)
		  ENBQTY(1:5,2) = ENBQTY(1:5,2) * BF(CURIYR,3,INDREG)
		  ENBQTY(1:5,4) = ENBQTY(1:5,4) * BF(CURIYR,11,INDREG)
		  ENBQTY(1:5,5) = ENBQTY(1:5,5) * BF(CURIYR,12,INDREG)
          
          DO IFUEL = 1,IFSMAX
		    IFF = IFSLOC(IFUEL)
		    IF (IFF .GT. 0 .AND. IFF .LT. 30) THEN
		       ENSQTY(IFUEL) = ENSQTY(IFUEL) * BF(CURIYR,IFF,INDREG)
	        END IF
	 ! ADD IN CODE TO ADJUST RENEWABLES
		  END DO

		  BYPBSCM(1:22) = BYPBSCM(1:22) * BF(CURIYR,1:22,INDREG)

		  ! CODE COPIED FROM INDSIC AND MODIFIED
		  DO IS=1,MPASTP

           DO IFn=1,IFMAX(IS)
              IFF = IFLOC(IFn,IS)
			
			  IF (IFF .GT. 0 .AND. IFF .LE. 22) THEN
               ENPQTY(1:4,IFn,IS)= ENPQTY(1:4,IFn,IS) * BF(CURIYR,IFF,INDREG)
			  END IF
            END DO
		  END DO

340  FORMAT(I3,I3,4F9.3)
360  FORMAT(A,I3,I3,4F9.3)

          CALL WRBIN

		  TQMCHECK(1:22,INDREG) = TQMCHECK(1:22,INDREG) + QTYMAIN(1:22,INDREG)
		  TQRCHECK(1:8,INDREG) = TQRCHECK(1:8,INDREG) + QTYRENW(1:8,INDREG)

       CALL CONTAB(INDREG)

	   END DO

		DO IFUEL=1,22
	       QTYMAIN(IFUEL,5) =  SUM(QTYMAIN(IFUEL,1:4))
		   TQMCHECK(IFUEL,5) = TQMCHECK(IFUEL,5) + QTYMAIN(IFUEL,5)
		END DO
		DO IFUEL=1,8
		   QTYRENW(IFUEL,5) = SUM(QTYRENW(IFUEL,1:4))
		   TQRCHECK(IFUEL,5) = TQRCHECK(IFUEL,5) + QTYRENW(IFUEL,5)
 		END DO

! CODE FROM NATTOTAL
	    DO 100 INDREG=1,5
        QTYMAIN(23,INDREG)=0.0
        DO 100 IFUEL=1,22
          QTYMAIN(23,INDREG)=QTYMAIN(23,INDREG)+QTYMAIN(IFUEL,INDREG)
  100 CONTINUE

        DO 105 INDREG=1,5
        QTYRENW(9,INDREG)=0.0
        DO 105 IFUEL=1,8
          QTYRENW(9,INDREG)=QTYRENW(9,INDREG)+QTYRENW(IFUEL,INDREG)
  105 CONTINUE

        TQMCHECK(23,1:5) = TQMCHECK(23,1:5) + QTYMAIN(23,1:5)
        TQRCHECK(9,1:5) = TQRCHECK(9,1:5) + QTYRENW(9,1:5)

!**********************************************************
!  copy local back to buffer so it is there for INDUSA
!**********************************************************

	  CALL CONTAB(5)

	  ! GO TO NEXT INDUSTRY

	  END DO

	  ! CODE FROM WEXOG ... NEEDS TO BE ADDED TO CONTAB IN FUTURE
	  do icr=1,4
        MINECON(ixNG,icr,CURIYR)=MINECON(ixNG,icr,CURIYR)+SumCDIV(CGOGSQ(1,CURIYR,3),icr)
        MINECON(ixCL,icr,CURIYR)=MINECON(ixCL,icr,CURIYR)+SumCDIV(CGOGSQ(1,CURIYR,1),icr)
        MINECON(ixRF,icr,CURIYR)=MINECON(ixRF,icr,CURIYR)+SumCDIV(CGOGSQ(1,CURIYR,2),icr)

      enddo
      MINECON(ixNG,5,CURIYR)=MINECON(ixNG,5,CURIYR)+CGOGSQ(11,CURIYR,3)
      MINECON(ixCL,5,CURIYR)=MINECON(ixCL,5,CURIYR)+CGOGSQ(11,CURIYR,1)
      MINECON(ixRF,5,CURIYR)=MINECON(ixRF,5,CURIYR)+CGOGSQ(11,CURIYR,2)

	  END SUBROUTINE

      SUBROUTINE CO2CALC

        USE i_
		IMPLICIT NONE
		INTEGER IFUEL,iyy
		Real CarbF

		include 'ghgrep'

	      CarbF=44./12.

		  iyy = curiyr

          CO2EM(1,IYY)=em_indy(17,11,curcalyr)/qelin(11,iyy)
!          CO2EM(1,IYY) = 0.
          CO2EM(2,IYY)=engin(iyy) * CarbF             ! ngas
          CO2EM(3,IYY)=eclin(iyy) * CarbF             ! steam coal
          CO2EM(4,IYY)=emcin(iyy) * CarbF             ! met coal
          CO2EM(5,IYY)=eclin(iyy) * CarbF             ! net coke import (steel only)
          CO2EM(6,IYY)=erlin(iyy) * CarbF             ! resid (low sulphur)
          CO2EM(7,IYY)=edsin(iyy) * CarbF             ! distillate
          CO2EM(8,IYY)=elgin(iyy) * CarbF             ! liquid petrol gases
          CO2EM(9,IYY)=emgin(iyy) * CarbF             ! motor gasoline
          CO2EM(10,IYY)=esgin(iyy) * CarbF            ! still gas (refine only)
          CO2EM(11,IYY)=epcin(iyy) * CarbF            ! petroleum coke
          CO2EM(12,IYY)=0.0                           ! asphalt, all sequestered
          CO2EM(13,IYY)=epfin(iyy) * CarbF            ! petroleum feedstock
          CO2EM(14,IYY)=eksin(iyy) * CarbF            ! kerosene
          CO2EM(15,IYY)=eotin(iyy) * CarbF            ! other ind
          CO2EM(16,IYY)=enqngpf(iyy) * CarbF          ! nat gas feed stocks
          CO2EM(17,IYY)=enqlgpf(iyy) * CarbF          ! lpg feedstock
          CO2EM(18,IYY)=0.0                           ! renewables, all sequestered

          write(IUNITBUG,'(" QEL:  ",I6,I4,5F12.3)') curcalyr,iyy, em_elec(8,11,curcalyr),qelas(11,iyy), em_indy(17,11,curcalyr), qelin(11,iyy),co2em(1,iyy)

          DO IFUEL=1,18

             AGCO2(IFUEL,iyy) = AGCON(IFUEL,5,iyy) * CO2EM(IFUEL,iyy) / 1000.0
             MINECO2(IFUEL,iyy) = MINECON(IFUEL,5,iyy) * CO2EM(IFUEL,iyy) / 1000.0
             CONSTCO2(IFUEL,iyy) = CONSTCON(IFUEL,5,iyy) * CO2EM(IFUEL,iyy) / 1000.0
             FOODCO2(IFUEL,iyy) = FOODCON(IFUEL,5,iyy) * CO2EM(IFUEL,iyy) / 1000.0
             PAPERCO2(IFUEL,iyy) = PAPERCON(IFUEL,5,iyy) * CO2EM(IFUEL,iyy) / 1000.0
             CHEMCO2(IFUEL,iyy) = CHEMCON(IFUEL,5,iyy) * CO2EM(IFUEL,iyy) / 1000.0
             GLASSCO2(IFUEL,iyy) = GLASSCON(IFUEL,5,iyy) * CO2EM(IFUEL,iyy) / 1000.0
             CEMENTCO2(IFUEL,iyy) = CEMENTCON(IFUEL,5,iyy) * CO2EM(IFUEL,iyy) / 1000.0
             STEELCO2(IFUEL,iyy) = STEELCON(IFUEL,5,iyy) * CO2EM(IFUEL,iyy) / 1000.0
             ALUMCO2(IFUEL,iyy) = ALUMCON(IFUEL,5,iyy) * CO2EM(IFUEL,iyy) / 1000.0
             FABMETALCO2(IFUEL,iyy) = FABMETALCON(IFUEL,5,iyy) * CO2EM(IFUEL,iyy) / 1000.0
             MACHINECO2(IFUEL,iyy) = MACHINECON(IFUEL,5,iyy) * CO2EM(IFUEL,iyy) / 1000.0
             COMPUTECO2(IFUEL,iyy) = COMPUTECON(IFUEL,5,iyy) * CO2EM(IFUEL,iyy) / 1000.0
             TRANEQUIPCO2(IFUEL,iyy) = TRANEQUIPCON(IFUEL,5,iyy) * CO2EM(IFUEL,iyy) / 1000.0
             ELECEQUIPCO2(IFUEL,iyy)  = ELECEQUIPON(IFUEL,5,iyy) * CO2EM(IFUEL,iyy) / 1000.0
             WOODPRODCO2(IFUEL,iyy) = WOODPRODCON(IFUEL,5,iyy) * CO2EM(IFUEL,iyy) / 1000.0
             PLASTICCO2(IFUEL,iyy) = PLASTICCON(IFUEL,5,iyy) * CO2EM(IFUEL,iyy) / 1000.0
             BOMOTHCO2(IFUEL,iyy) = BOMOTHCON(IFUEL,5,iyy) * CO2EM(IFUEL,iyy) / 1000.0
             REFCO2(IFUEL,iyy) = REFCON(IFUEL,5,iyy) * CO2EM(IFUEL,iyy) / 1000.0

          ENDDO

          END SUBROUTINE

!***********************************************************

       subroutine ind_nextdat(unitnum,cline)
       use i_
       implicit none

       integer*4 unitnum,jj  ! j is already an integer
       character*(*) cline

! read past all lines with # in column 1

      read(unitnum,'(a)') cline
      do while (cline(1:1) .eq. '#')
      read(unitnum,'(a)') cline
      enddo

! do not read anything after a ! character

      do 100 j = 1,132
         if (cline(j:j).eq.'!') then
            do 99 jj = j,132
               cline(jj:jj)=' '
99          continue
            go to 101
         end if
100   continue
101   continue

      return
      end subroutine ind_nextdat

!****************************************************



! end lime industry submodule
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
! cement and lime industry submodule

! finish grinding, kiln, burner, raw grinding

       subroutine Cement_Industry
       use i_
       IMPLICIT NONE

        if (HITECH.eq.1) then
           scenario=2
        else if (FRZTECH.eq.1) then
           scenario=3
        else if (EETECH.eq.1) then
           scenario=4
        else
           scenario=1
        endif
        IS_FISYR(inddir)=CM_FISYR(1)
        call TECH_STEP(1)
        if ((FRZTECH.eq.1) .or. (HITECH.eq.1) )then
         call kiln_capacity(1)  !if tech case then use wet retirements
        else
         call kiln_capacity(2)
        endif
        call kiln_allocation
        call cm_burner
        call cm_raw_grind
      !lime
        call TECH_STEP(5)
       return
       END subroutine Cement_Industry

!***************************************************************************************
! CEMENT Kiln Capacity
       subroutine kiln_capacity(tech)
       use i_
       implicit none

       integer tech
       real needed_capacity(MNUMYR)    !Year is installation year not survival year (current loop)
       real surviving_capacity
       real sumup
       real baseline_capacity_IBYR
       integer iy,stepnum
       real new_cap_survk(MNUMYR)
       real BCapWet      ! Allocated Wet Process baseline capacity
       real BCapDry      ! Allocated Dry Process baseline capacity
       real BCapWet_lag      ! Allocated Wet Process baseline capacity -previous year
       real BCapDry_lag      ! Allocated Dry Process baseline capacity - previous year
       real BCapWet_IBYR      ! Allocated Wet Process baseline capacity-beginning year
       real BCapDry_IBYR      ! Allocated Dry Process baseline capacity-beginning year
       real basecap_lag(8:13,maxstep)                            ! Lagged baseline capacity

	   real CO2_Cement_Process_Emission_Factor ! for just process emissions based on clinker production
	   real CO2_Lime_Process_Emission_Factor ! for just process emissions for lime production
	   real Clinker_Scalar              ! hardcoded (for now) scaling factor to allow baseline historical year
										! clinker production to be equal to USGS data (in ironstlx.xlsx)
       real Lime_Base 					! base year lime production from USGS, via ironstlx.xlsx
	   real Lime_Shipment_Base			! base year lime shipments

        stepnum=2
        is_calib(inddir)=cm_calib(stepnum)
        is_lifetime(inddir)=cm_lifetime(stepnum)
        is_baselifecr(inddir)= cm_baselifecr(stepnum)

        do i=0,30
          new_cap_survk(i+1)=1.0/(1.0+exp(-is_calib(inddir)-(i*(-is_calib(inddir))/(is_lifetime(inddir)/2.0))))  ! POT_INPUT lifespanc to cm_lifetimek
        end do
        if (curiyr.ge.ICURIYR2+1) then  ! POT_IBYR 19 to ICURIYR2+2
          process_outputk=grinding_tonnes*(1.0-(cm_import_clink+cm_add))
          if (curiyr.eq.ICURIYR2+1) then       ! POT_IBYR to ICURIYR2+2
            is_basecap(inddir,stepnum) = process_outputk
            baseline_capacity_IBYR = is_basecap(inddir,stepnum) ! Baseline capacity 2008
            basecap_lag(inddir,stepnum) = baseline_capacity_IBYR
            if (tech==1) then
              BCapWet_IBYR = baseline_capacity_IBYR * cm_capshr(1)       ! Split baseline capacity into Wet and Dry Processes
              BCapDry_IBYR = baseline_capacity_IBYR * cm_capshr(2)
              BCapWet_lag = BCapWet_IBYR
              BCapDry_lag = BCapDry_IBYR
            endif
          else
            if(curitr.eq.1) basecap_lag(inddir,stepnum) = is_basecap(inddir,stepnum)            ! Save result from prior year on first iteration
          endif
          if (tech==1) then
            if (curitr.eq.1) then  ! save result from prior year on first iteration
              BCapWet_lag = BCapWet
              BCapDry_lag = BCapDry
            endif
	        BCapWet = BCapWet_lag - (BCapWet_IBYR/cm_BaseLifeWet2(scenario))  ! Wet and Dry capacities may retire at different rates
	        if (BCapWet.lt.0.0) BCapWet = 0.0
	        BCapDry = BCapDry_lag - (BCapDry_IBYR/cm_BaseLifeDry)
	        if (BCapDry.LT.0.0) BCapDry = 0.0
            is_basecap(inddir,stepnum) = BCapWet + BCapDry        ! Recombine to get total surviving baseline capacity
          else
            is_basecap(inddir,stepnum)=basecap_lag(inddir,stepnum)-(baseline_capacity_IBYR/is_baselifecr(inddir))    ! POT_INPUT baselifec to cm_baselifek
          endif
          if (is_basecap(inddir,stepnum).lt.0.0) is_basecap(inddir,stepnum)=0.0
        endif

        if (curiyr.le.CM_FISYR(stepnum)) then
            surviving_capacity=is_basecap(inddir,stepnum)
        else
           sumup=0.0
           do i=CM_FISYR(stepnum),curiyr-1
             is_incr_adds(inddir,stepnum,i)=needed_capacity(i)*new_cap_survk(curiyr-i+1)
           end do
           do i=CM_FISYR(stepnum),curiyr-1
              sumup=sumup+is_incr_adds(inddir,stepnum,i)
           end do
           surviving_capacity=is_basecap(inddir,stepnum)+sumup
        end if

        needed_capacity(curiyr)=process_outputk-surviving_capacity
        if (needed_capacity(curiyr).lt.0.0) needed_capacity(curiyr)=0.0
        is_incr_adds(inddir,stepnum,curiyr) = needed_capacity(curiyr)

! below we compute process emissions for the cement & lime industry (metric tons of CO2)
	    if (curcalyr.ge.ibyr) then
	     continue
		 if (curcalyr.eq.ibyr) then						            ! for base year scale clinker production
            Clinker_Scalar = is_production(11,2) / process_outputk	! to USGS 2018 historical value of clinker production
            Lime_Base = is_production(11,5)                         ! use base year (2018) USGS lime data to set initial lime production (thousand metric tons)
			Lime_Shipment_Base = OUTIND(23,11)			        ! base year national lime shipments
		 end if
		 CO2_Cement_Process_Emission_Factor = 0.507 ! units are tonnes CO2 / tonne clinker produced
													! from page 177 of 
! https://www.ipcc-nggip.iges.or.jp/public/gp/bgp/3_1_Cement_Production.pdf

		 CO2_Lime_Process_Emission_Factor = 0.751 ! units are tonnes CO2 / tonne quicklime produced
												  ! from page 31 of
! https://www.eula.eu/wp-content/uploads/2019/02/A-Competitive-and-Efficient-Lime-Industry-Technical-report-by-Ecofys_0.pdf

		 co2_clink(curiyr,5) = CO2_Cement_Process_Emission_Factor * Clinker_Scalar * process_outputk
									! emissions in CO2_Process_Emissions are given in thousand metric tons (tonnes) CO2
									! because clinker_prod variable is also in thousand metric tons (tonnes)

		 co2_lime(curiyr,5) = CO2_Lime_Process_Emission_Factor * Lime_base * OUTIND(23,11) / Lime_Shipment_Base
									! compute lime process emissions by making assumption regarding growth of lime 
									! product based on lime shipments and using this lime physical product to compute
									! lime process emissions via a lime process emissions factor
									! units of co2_lime are in thousand metric tons (just like co2_clink)

! GHG_PROCESSIN(industry, year) contains national level process emissions by industry and year
	     GHG_PROCESSIN(1:21,curiyr) = 0.0 ! SET ALL INDUSTRY'S PROCESS EMISSIONS AS ZERO BY DEFAULT
		 GHG_PROCESSIN(11,CURIYR) = 0.001 * (co2_clink(curiyr,5) + co2_lime(curiyr,5)) ! SET CEMENT & LIME PROCESS EMISSIONS
																					   ! units: million tonnes CO2
	    end if
        return
        end subroutine kiln_capacity
!*********************************************************************************************
! CEMENT Kiln Allocation
       subroutine kiln_allocation
       use i_
       implicit none

       real dry_process

! baseline capacity of Kilns
       real wet_rotary(MNUMYR), wet_rotaryIBYR  !, wet_rotaryLag
       real dry_rotary(MNUMYR,NUMROT), dry_rotaryIBYR(NUMROT) !, dry_rotaryLag(NUMROT)
       real wet_processIBYR  !, wet_processLag
       real CRF                   ! POT_INPUT delete lifetimec
       real totfixcst(NUMROT)
       real clinker_prod(NUMROT+1)
       real surv_dry_base
       real need_dry_cap
       real logit_comp(NUMROT)
       real shares(NUMROT,MNUMYR)
       real surviving_added_capacity(NUMROT)
       real elec_used(NUMROT+1)
       real temp
       real alpha_kiln(NUMROT)
       real adjust_factork(NUMROT)
       integer k
       integer iy
       integer numiter
       integer imaxitr ! max number of iterations when calculating new alpha_kiln
       real calib_k  ! POT_INPUT delete delta
       real vintage
       real alpha_decay(2)
       real scale_min
       real scale_comp(numrot)
       real scale_adj
       real scale_fctr
       integer stepnum, inumtech
       real vintage_index
       real oyr  !obsolete year switch
       real sum_logit_comp
       
       ! oyr = 0.
	   stepnum=2
       IS_WACC(inddir)=CM_WACC(stepnum)
       is_alpha_decay(inddir,:)=cm_alpha_decay(stepnum,scenario,:)

      cm_logit_coeff_k(1:6)=IS_LOGIT_COEFF(inddir,1:6,stepnum)/-1000000.0
      calib_k=is_ecalib(inddir,stepnum)
      is_alpha_decay(inddir,:)=cm_alpha_decay(stepnum,scenario,:)
      alpha_decay(1)=IS_ALPHA_DECAY(inddir,1)
      alpha_decay(2)=IS_ALPHA_DECAY(inddir,2)

       imaxitr=1000                                      ! Previously 50, but was causing instability in results for renewable/waste boilers (NSK 7/2022)
       if ((curcalyr.eq.ibyr2+1).and.(curitr.eq.1)) then ! POT_ibyr2 2007 to ibyr2+1set inital values for alpha_kiln
         do inumtech=1,numrot
         alpha_kiln(inumtech)=is_alpha(inddir,stepnum,inumtech)
         enddo
       endif

       vintage=vintage_index(stepnum)

        crf=is_wacc(inddir)*(1.0+is_wacc(inddir))**is_lifetime(inddir)/((1.0+is_wacc(inddir))**is_lifetime(inddir)-1.0) ! Same for all technologies

       do inumtech=1,NUMROT
         totfixcst(inumtech)=crf*is_capcost(inddir,stepnum,inumtech)+is_av_om(inddir,stepnum,inumtech)
       enddo
            
       if (curiyr.ge.ICURIYR2-1) then  ! POT_ibyr2 16 to ICURIYR2-1
         continue
         if (curiyr.le.ICURIYR2+1) then
           wet_process(curiyr)=process_outputk*cm_capshr(1) !pwet
           dry_process=process_outputk*cm_capshr(2) !pdry
           wet_rotary(curiyr)=wet_process(curiyr)
           wet_processIBYR = wet_process(curiyr)
           wet_rotaryIBYR = wet_rotary(curiyr)

           do i=1,NUMROT
             dry_rotary(curiyr,i)=dry_process*is_base_tech_share(inddir,stepnum,i)
             if (curiyr.eq.ICURIYR2+1) then
                dry_rotaryIBYR(i) = dry_rotary(curiyr,i)
                dry_rotary(curiyr-1,i) = dry_rotaryIBYR(i)
             end if
           enddo
         else

           wet_process(curiyr)=wet_process(curiyr-1)-(wet_processIBYR/is_baselifecr(inddir))        ! POT_INPUT baselifec to cm_baselifek
           if (wet_process(curiyr).lt.0.0) wet_process(curiyr)=0.0
           dry_process = process_outputk-wet_process(curiyr)

           do i=1,NUMROT
             dry_rotary(curiyr,i)=dry_rotary(curiyr-1,i)-(dry_rotaryIBYR(i)/is_baselifecr(inddir))      ! POT_INPUT baselifec to cm_baselifek
             if (dry_rotary(curiyr,i).lt.0.0) dry_rotary(curiyr,i)=0.0
           enddo

! baseline kiln capacity
           wet_rotary(curiyr)=wet_rotary(curiyr-1)-(wet_rotaryIBYR/is_baselifecr(inddir))             ! POT_INPUT baselifec to cm_baselifek
           if (wet_rotary(curiyr).lt.0.0) wet_rotary(curiyr)=0.0
         endif
         surv_dry_base=dry_rotary(curiyr,1)+dry_rotary(curiyr,2)+dry_rotary(curiyr,3)
         need_dry_cap=dry_process-surv_dry_base
         if (need_dry_cap.lt.0.0) need_dry_cap=0.0

        numiter=0
1667    if (curcalyr.eq.ibyr2+1) numiter=numiter+1  ! POT_ibyr2 2007 to ibyr2+1
        if (numiter.eq.imaxitr) write(iunit1,*) "WARNING: MAX ITER REACHED in kiln_grind_alloc"
        scale_min=0.0
        oyr = 0.0
		do i=1,NUMROT                                                                       ! POT_INPUT change calibrationc to cm_logit_coeff_k
          if (int(obsoleteyr(inddir,stepnum,i)) .LE. curcalyr) then
  !          oyr=1.0
			scale_comp(i) = 1.0e-7
          else
!            oyr=0.0
!          endif
			  scale_comp(i)=cm_logit_coeff_k(1)*totfixcst(i)* (1 + oyr*99.0)  + &           ! Fixed costs term
						   cm_logit_coeff_k(2)*IS_fuel_use(inddir,stepnum,1,i) *&           ! Electricity costs term
						   (PELIN(MNUMCR,curiyr)*MC_JPGDP(20))+ &  !convert to $09
                           cm_logit_coeff_k(3)*part_matter(2,i)+ &                          ! Particulate emissions term
						   cm_logit_coeff_k(5)*ht_serv(i)+&                                 ! Heat service term
						   alpha_kiln(i)*exp(-IS_ALPHA_DECAY(inddir,1)*(curiyr+1989-ibyr2-1)*ln2/IS_ALPHA_DECAY(inddir,2))
			  ! Test initial calculations to ensure values won't go out of bounds
			   if (scale_comp(i).lt.scale_min) scale_min=scale_comp(i)
		  endif
       enddo
         scale_adj = 30.0
      if (scale_min.LT.(- scale_adj)) then                                !
	      scale_fctr = -(scale_min + scale_adj)                            ! Uniform additive factor to bring calculations back into line
	  else                                                                !
	      scale_fctr = 0.0                                                !
	  endif
      sum_logit_comp=0.0
      do i=1,NUMROT
           if (int(obsoleteyr(inddir,stepnum,i)) .LE. curiyr+1989) then
             ! oyr=1.0
			logit_comp(i)= 1.0e-7 
           else
	!              oyr=0.0
	!            endif         ! POT_INPUT change calibrationc to cm_logit_coeff_k
				logit_comp(i)=exp(cm_logit_coeff_k(1)*totfixcst(i)* (1 + oyr*99.0)+ &           ! Fixed costs term
						   cm_logit_coeff_k(2)*IS_fuel_use(inddir,stepnum,1,i) *&               ! Electricity cost term
						   PELIN(MNUMCR,curiyr)*MC_JPGDP(20)+ &  !convert to $09
                           cm_logit_coeff_k(3)*part_matter(2,i)+ &                              ! Particulate emissions term
						   cm_logit_coeff_k(5)*ht_serv(i)+&                                     ! Heat service term
                           alpha_kiln(i)*exp(-IS_ALPHA_DECAY(inddir,1)*(curiyr+1989-ibyr2-1)*ln2/IS_ALPHA_DECAY(inddir,2)))+scale_fctr
			endif
            !sum logit_comp
            sum_logit_comp=logit_comp(i)+sum_logit_comp
         enddo
         do i=1,NUMROT
            if (sum_logit_comp.ne.0.0) then
             shares(i,curiyr)=logit_comp(i)/sum_logit_comp
           else
             shares(i,curiyr)=0.0
           endif
           is_shares(inddir,stepnum,i,curiyr)=shares(i,curiyr)
         enddo

         !!	Adjust alternative specific constants (ASC) to ensure initial equipment shares match historical values
!    if ((FRZTECH.eq.1) .or. (HITECH.eq.1) )then
            if ((curcalyr.eq.ibyr2+1).and.(curitr.eq.1)) then  ! POT_ibyr2 2007 to ibyr2+1

              do i=1,NUMROT
                adjust_factork(i)=0.0
                if (is_base_tech_share(inddir,stepnum,i).ne.0.0) then
                    adjust_factork(i) = log(is_add_tech_share(inddir,stepnum,i)/shares(i,curiyr))  ! Should be using base year added shares, not existing shares (NSK 7/2022)
                    !adjust_factork(i) = log(is_base_tech_share(inddir,stepnum,i)/shares(i,curiyr))  ! Calculate deviation from historical values
                    alpha_kiln(i) = alpha_kiln(i) + adjust_factork(i)            ! Modify the ASC accordingly
                endif
              enddo
              do i=1,NUMROT
                 if ((ABS(adjust_factork(i)).GT.0.001).and.(numiter.le.imaxitr)) GOTO 1667                ! If any of the factors exceeds the limit, redo the calculation
              enddo
            endif

         do i=1,NUMROT
           surviving_added_capacity(i)=0.0
           if (curiyr.ge.CM_FISYR(stepnum))then
             do k=CM_FISYR(stepnum),curiyr
               surviving_added_capacity(i)=surviving_added_capacity(i)+shares(i,k)*is_incr_adds(inddir,stepnum,k)
             enddo
           endif
         enddo

!total clinker production

         clinker_prod(1)=wet_process(curiyr)

         do i=1,NUMROT
           if (surv_dry_base.ne.0.0) then
             temp=dry_process/surv_dry_base
             if (temp.gt.1.0)temp=1.0
           else
             temp=1.0
           endif
           clinker_prod(i+1)=temp*dry_rotary(curiyr,i)+surviving_added_capacity(i)
         enddo

! heating requirement
         do i=1,NUMROT+1
           heat_req(i)=clinker_prod(i)*cm_heatcoef(i)
           if (i.eq.1) then
             elec_used(i)=clinker_prod(i)*cm_eleccoef(i)
           else
             elec_used(i)=clinker_prod(i)*(cm_eleccoef(i)-is_delta(inddir,2,i-1)*(1.0-exp(-calib_k*vintage)))
           endif
         enddo

!total heat demand  (col AK)
         heat_demand=0.0
         ElecCons(stepnum,curiyr)=0.0
         do i=1,NUMROT+1
           heat_demand=heat_demand+heat_req(i)
           ElecCons(stepnum,curiyr)=ElecCons(stepnum,curiyr)+elec_used(i)
         enddo

       end if
       return
       end

!***************************************************************
! CEMENT Burner
       subroutine cm_burner
       use i_
       implicit none

       real sumlogit
       real basecapb(MNUMYR,NUMTYP),  basecapIBYR(NUMTYP)
       real CRF
       real ann_cc(NUMTYP)
       real av_om(NUMTYP)
       real totfixcst(NUMTYP)
       real surv_base
       real tot_burn_outw(NUMTYP)
       real tot_burn_outd(NUMTYP)
       real logit_comp(NUMTYP)
       real shares(NUMTYP,MNUMYR)
       real surviving_added_capacity(NUMTYP)
       real heat_demandb
       real price(NUMTYP)
       real adjust_factorb(NUMTYP)
       real co2_emiss_dum(MNUMYR)
       integer k
       integer numiter
       integer imaxitr ! max number of iterations when calculating new alpha_burner
       integer f       ! max number of burner fuels
       real vintage
       real scale_min
       real scale_comp(numtyp)
       real scale_adj
       real scale_fctr
       real asf_adj(MNUMYR)      ! POT_2050 51 to MNUMYR
       real asf_inc
       integer asf_index
       real bb_asf_mix
       real bb_coal_mix
       real lag_max_asf_inc
       real asf_inc_temp

       real fuel_mixbw(NUMTYP,NUMFUELB)
       integer inumtech
       integer stepnum

       real vintage_index                            !vintage index
       real oyr  !obsolete year switch
       stepnum=3

       is_calib(inddir)=cm_calib(stepnum)
       is_lifetime(inddir)=cm_lifetime(stepnum)
       is_baselifecr(inddir)= cm_baselifecr(stepnum)
       dry_heat_req = heat_demand - heat_req(1)

        CALL Step_Capacity(stepnum,        &
                         is_FISYR(inddir),       &
                         is_baselifecr(inddir),  &
                         is_lifetime(inddir),    &
                         is_calib(inddir),       &
                         dry_heat_req)

       fuel_mixbd=cm_fuelmix
       fuel_mixbw(:,:)=fuel_mixbd(:,:)  ! Overwrite for fuel mix of wet process kiln burners, until fuel-switching becomes more integrated
       fuel_mixbw(7,3)=.51
       fuel_mixbw(7,4)=.20
       fuel_mixbw(7,5)=.29
       burner_fuel(:,:)=0.0
       write(IUNITBUG,*) 'Cement burner HITECH=',HITECH
! quality check on fuel mix for burners
       do i=1,NUMTYP
         if(sum(fuel_mixbd(i,1:NUMFUELB)).ne.1.0) then
           write(6,*) '===== Error: Sum of shares is not 1.0 for dry process burner = ',i
           write(6,'(5x,a,5(f6.2,2x),3(1x,i4))') '==== Kiln burners fuel mix = ',fuel_mixbd(i,1:5), i, curcalyr, curiyr
         end if
         if(sum(fuel_mixbw(i,1:NUMFUELB)).ne.1.0) then
           write(6,*) '===== Error: Sum of shares is not 1.0 for wet process burner = ',i
           write(6,'(5x,a,5(f6.2,2x),3(1x,i4))') '==== Kiln burners fuel mix = ',fuel_mixbw(i,1:5), i, curcalyr, curiyr
         end if
       end do

       cm_logit_coeff_b(1:6)=IS_LOGIT_COEFF(inddir,1:6,stepnum)/-1000000.0
       is_alpha_decay(inddir,:)=cm_alpha_decay(stepnum,scenario,:)

       imaxitr=1000                    ! Previously 50, but was causing instability in results for renewable/waste boilers (NSK 7/2022)
       asf_index=0                     ! Set inital values for asf_index
       lag_max_asf_inc=0.              ! Set inital values for lag_max_asf_inc

       if(curiyr.eq.ICURIYR2+1) then    ! POT_ibyr2 19 to ICURIYR+2
         bb_asf_mix=fuel_mixbd(7,5)    ! Set baseyear burner value for asf fuel share
         bb_coal_mix=fuel_mixbd(7,3)   ! Set baseyear burner value for coal fuel share
       end if

       do i = 0,50
         if (bb_asf_mix>.5) bb_asf_mix=.5        ! Check on shares to avoid a value greater than 1.
         asf_adj(i+1)= (2.*bb_asf_mix)/(1.0+(1.*exp(-0.1*i)))
       end do

         !calculate vintage for elec use

       If (curiyr.ge.ICURIYR2+1) then    ! POT_ibyr2 20 to ICURIYR+3
         do i=ICURIYR2+3,curiyr                 ! POT_ibyr2 to ICURIYR+3
           if (IS_incr_adds(inddir,stepnum,i).gt.0.0) then
             asf_index=asf_index+1
           endif
         enddo
         if(HITECH.EQ.1) then
           if(asf_index.eq.0) asf_index=1
           if(asf_inc.gt.0.) lag_max_asf_inc=asf_inc
           asf_inc_temp=(asf_adj(asf_index)-bb_asf_mix)
           asf_inc=max(lag_max_asf_inc,asf_inc_temp,0.)    ! Incremental change in ASF and coal mix is set to max value
           fuel_mixbd(7,5)=bb_asf_mix+asf_inc
           fuel_mixbd(7,3)=bb_coal_mix-asf_inc
           if(fcrl.eq.1) write(6,*) '==== ASF Adjustment: = ', asf_inc, curcalyr
           if(fcrl.eq.1) write(6,'(5x,a,5(f6.2,2x),2(1x,i4))') '==== Multi-channel burner fuel mix = ',fuel_mixbd(7,1:5), curcalyr, curiyr
         end if
         vintage=vintage_index(stepnum)
       end if

       do i=1,MNUMYR
         co2_emiss_dum(i)=1.0
       enddo

      crf=is_wacc(inddir)*(1.0+is_wacc(inddir))**is_lifetime(inddir)/((1.0+is_wacc(inddir))**is_lifetime(inddir)-1.0) ! Same for all technologies

       do inumtech=1,NUMTYP !
         ann_cc(inumtech)= crf*is_capcost(inddir,stepnum,inumtech)       !annualized capital costs
         av_OM(inumtech)=is_av_om(inddir,stepnum,inumtech)
         totfixcst(inumtech)=ann_cc(inumtech)+av_OM(inumtech)
         fuel_useb(inumtech)=cm_heatsrv_fuel(inumtech)                  ! fuel needs for heat service (MMBtu fuel in/GJ heat service out)
       enddo
! baseline capacity (burner output)
     !  If (curiyr.ge.ICURIYR-1) then  ! POT_ibyr2 16 to ICURIYR-1
         write(IUNITBUG,'(A,2I4)') 'test',curiyr,icuriyr2+1
         do i=1,NUMTYP

           if (curiyr==ICURIYR) then    ! POT_ibyr2 20 to ICURIYR2+3
             basecapb(curiyr,i)=dry_heat_req*is_base_tech_share(inddir,stepnum,i)
             basecapIBYR(i) = basecapb(curiyr,i)
             basecapb(curiyr-1,i) = basecapIBYR(i)
           else
              basecapb(curiyr,i)=basecapb(curiyr-1,i)-(basecapIBYR(i)/is_baselifecr(inddir))           ! POT_INPUT change baselifec to cm_baselifeb
              if (basecapb(curiyr,i).lt.0.0) basecapb(curiyr,i)=0.0
           endif 
         enddo

!Surviving Baseline Output (col I)
         surv_base=0.0
         do i=1,NUMTYP
           surv_base = surv_base+basecapb(curiyr,i)  
         enddo
         do i=1,NUMTYP
           price(i) =   PGFIN(MNUMCR,curiyr)*fuel_mixbd(i,1)+&
                        PRLIN(MNUMCR,curiyr)*fuel_mixbd(i,2)+&
                        PCLIN(MNUMCR,curiyr)*fuel_mixbd(i,3)+&
                        PPCIN(MNUMCR,curiyr)*fuel_mixbd(i,4)+&
                        0.0*fuel_mixbd(i,5) ! fuel_mixbd index: 1=NG; 2=oil; 3=coal; 4=pet coke; 5=ASF
           price(i)=price(i)*MC_JPGDP(20) !convert to $09
         enddo

1668    if (curcalyr.eq.IBYR2+1) numiter=numiter+1  ! POT_ibyr2 2007 to ibyr2
        if (numiter.eq.imaxitr) write(iunit1,*) "WARNING: MAX ITER REACHED in burner_alloc", curcalyr
        scale_min=0.0
        oyr = 0.
		do i=1,NUMTYP                                ! POT_INPUT calibrationc to cm_logit_coeff_b
         if (int(obsoleteyr(inddir,stepnum,i)) .LE. curiyr+1989) then
           ! oyr=1.0
		   scale_comp(i)=1.0e-7
          else
!            oyr=0.0
!          endif
			  scale_comp(i)=cm_logit_coeff_b(1)*totfixcst(i)* (1 + oyr*0.*99.0)  + &                        ! fixed costs term
						   cm_logit_coeff_b(2)*fuel_useb(i)*price(i)+ &                                     ! fuel use (MMBtu fuel in/GJ heat service out) term
						   cm_logit_coeff_b(3)*part_matter(3,i)+ &                                          ! particulate emissions term
						   cm_logit_coeff_b(4)*cm_combco2(3,i)*co2_emiss_dum(curiyr)+&                      ! CO2 emissions (T/GJ heat service) term
                           is_alpha(inddir,stepnum,i)* &      
                           exp(-IS_ALPHA_DECAY(inddir,1)*(curiyr+1989-ibyr2-1)*ln2/IS_ALPHA_DECAY(inddir,2))                                
			  ! Test initial calculations to ensure values won't go out of bounds
			   if (scale_comp(i).lt.scale_min) scale_min=scale_comp(i)
		   endif
		enddo
         scale_adj = 30.0
         if (scale_min.LT.(- scale_adj)) then                             !
	      scale_fctr = -(scale_min + scale_adj)                           ! Uniform additive factor to bring calculations back into line
	  else                                                                !
	      scale_fctr = 0.0                                                !
	  endif
		 oyr = 0.
         do i=1,NUMTYP
          if (int(obsoleteyr(inddir,stepnum,i)) .LE. curiyr+1989) then
           ! oyr=1.0
			logit_comp(i)=1.0e-7
          else
        !    oyr=0.0
        !  endif         ! POT_INPUT calibrationc to cm_logit_coeff_b
			   logit_comp(i)=exp(cm_logit_coeff_b(1)*totfixcst(i)* (1 + oyr*99.0)+ &                ! fixed costs term
						   cm_logit_coeff_b(2)*fuel_useb(i)*price(i)+ &                             ! fuel costs term
						   cm_logit_coeff_b(3)*part_matter(3,i)+ &                                  ! particulate emissions term              
						   cm_logit_coeff_b(4)*cm_combco2(3,i)*co2_emiss_dum(curiyr)+ &             ! CO2 emissions (T/GJ heat service) term
                           is_alpha(inddir,stepnum,i)*exp(-IS_ALPHA_DECAY(inddir,1)* &
                           (curiyr+1989-ibyr2-1)*ln2/IS_ALPHA_DECAY(inddir,2)))+scale_fctr    

             !if((i.gt.2).and.(i.lt.7)) then     ! Assume no new cement capacity will be built using coal, resid, or petcoke as burner fuel (NSK 7/2022)
             !if((i.ge.1).and.(i.lt.7)) then     ! Undo these assumptions (NSK 9/2022)
             !   logit_comp(i)=0.0
             !endif
		  endif	
        enddo
        sumlogit=0.0
        do i=1,NUMTYP
           sumlogit=sumlogit+logit_comp(i)
        enddo
        do i=1,NUMTYP
           if (sumlogit.ne.0.0) then
             shares(i,curiyr)=logit_comp(i)/sumlogit
           else
             shares(i,curiyr)=0.0
           endif
           is_shares(inddir,stepnum,i,curiyr)=shares(i,curiyr)
         enddo
         
!****************
        if ((curcalyr.eq.ibyr2+1).and.(curitr.eq.1)) then  ! POT_ibyr2 2007 to ibyr2

              do i=1,NUMTYP
                adjust_factorb(i) = log(is_add_tech_share(inddir,stepnum,i)/shares(i,curiyr))  ! Should be using base year added shares, not existing shares (NSK 7/2022)
                !adjust_factorb(i) = log(is_base_tech_share(inddir,stepnum,i)/shares(i,curiyr))  ! Calculate deviation from historical values
                is_alpha(inddir,stepnum,i) = is_alpha(inddir,stepnum,i) + adjust_factorb(i)    ! Modify the ASC accordingly
              end do
              do i=1,NUMTYP
                 if ((ABS(adjust_factorb(i)).GT.0.001).and.(numiter.le.imaxitr)) GOTO 1668                ! If any of the factors exceeds the limit, redo the calculation
              end do
              write(IUNITBUG,*) '***** new alpha_burner=',(is_alpha(inddir,stepnum,i),i=1,NUMTYP)
        endif
!****************        
         
         do i=1,NUMTYP
           surviving_added_capacity(i)=0.0
           if (curiyr.ge.CM_FISYR(stepnum))then
             do k=CM_FISYR(stepnum),curiyr
               surviving_added_capacity(i)=surviving_added_capacity(i)+shares(i,k)*IS_incr_adds(inddir,stepnum,k)
             enddo
           endif
         enddo
         heat_demandb=cm_heatdcoef* wet_process(curiyr)                        ! from Kiln Allocation, BO
         do i=1,NUMTYP
           tot_burn_outw(i)=heat_demandb*cm_wetcoef(i) !wet_coeff(i)                         ! BQ-BU  Wet Process energy, by burner type
           if ((surv_base.ne.0.0).and.((dry_heat_req/surv_base).le.1.0)) then
             tot_burn_outd(i)=dry_heat_req/surv_base*basecapb(curiyr,i)+surviving_added_capacity(i)
           else
             tot_burn_outd(i)=basecapb(curiyr,i)+surviving_added_capacity(i)
             endif
             
           do f=1,NUMFUELB
             burner_fuel(i,f) =((tot_burn_outw(i)*fuel_mixbw(i,f))+(tot_burn_outd(i)*fuel_mixbd(i,f)))*cm_heatsrv_fuel(i)
           end do
         end do
         do f=1,NUMFUELB
           tot_burner_fuel(f)=sum(burner_fuel(1:NUMTYP,f))
         end do
         write(IUNITBUG,*) 'tot_burner_fuel(5)=',curiyr+1989,tot_burner_fuel(5)
         NgCons(stepnum,curiyr)=tot_burner_fuel(1)
         HFOCons(stepnum,curiyr)=tot_burner_fuel(2)
         CoalSCons(stepnum,curiyr)=tot_burner_fuel(3)
         PetCons(stepnum,curiyr)=tot_burner_fuel(4)
         
           if(fcrl.eq.1) write(6,'(5x,a,6(f15.2,2x),2(i4,1x))') '==== Total burner fuel = ',tot_burner_fuel(1:NUMFUELB), sum(tot_burner_fuel(1:NUMFUELB)), curcalyr, curiyr
       return
       end

!***************************************************************
! CEMENT Raw Grinding
       subroutine cm_raw_grind
       use i_
       implicit none

       real basecapg(MNUMYR,NUMTYPG), basecapIBYR(NUMTYPG), basecapLag(NUMTYPG)

       real CRF                                                           ! POT_INPUT delete baselifec and lifetimec
       real ann_cc(NUMTYPG)
       real av_om(NUMTYPG)

       real totfixcst(NUMTYPG)
       real surv_base
       real logit_comp(NUMTYPG)
       real surviving_added_capacity(NUMTYPG)
       real wet_prod(NUMTYPG)
       real shares(NUMTYPG,MNUMYR)
       real mass_loss_rat

       real adjust_factorg(NUMTYPG)
       integer k
       integer iy
       real vintage
       real vintage_index                            !vintage index

       integer numiter
       integer imaxitr ! max number of iterations when calculating new alpha_rg
       real scale_min
       real scale_comp(NUMTYPG)
       real scale_adj
       real scale_fctr
       integer stepnum, inumtech
       real oyr
       real sum_logit_comp

       stepnum=4
       is_calib(inddir)=cm_calib(stepnum)
       is_lifetime(inddir)=cm_lifetime(stepnum)
       is_baselifecr(inddir)= cm_baselifecr(stepnum)
       raw_material = (process_outputk-wet_process(curiyr)) * C_MASS_LOSS

       CALL Step_Capacity(stepnum,        &
                         is_FISYR(inddir),       &
                         is_baselifecr(inddir),  &
                         is_lifetime(inddir),    &
                         is_calib(inddir),       &
                         raw_material)


       cm_logit_coeff_r(1:6)=IS_LOGIT_COEFF(inddir,1:6,stepnum)/-1000000.0
       is_alpha_decay(inddir,:)=cm_alpha_decay(stepnum,scenario,:)
       imaxitr=50

       mass_loss_rat=c_mass_loss
       vintage=vintage_index(stepnum)
       crf=is_wacc(inddir)*(1.0+is_wacc(inddir))**is_lifetime(inddir)/((1.0+is_wacc(inddir))**is_lifetime(inddir)-1.0) ! Same for all technologies
       do inumtech=1,NUMTYPG
         ann_cc(inumtech)= crf*is_capcost(inddir,stepnum,inumtech)      !annualized CC
         av_OM(inumtech)=is_av_om(inddir,stepnum,inumtech)
         totfixcst(inumtech)=ann_cc(inumtech)+av_OM(inumtech)

       enddo
! baseline capacity
       if (curiyr.ge.ICURIYR2-1) then ! POT_ibyr2 16 to ICURIYR2-1
         continue
! clean up with respect to lag variable set in base year-1
         do i=1,NUMTYPg
           if (curiyr.lt.ICURIYR2+3) then  ! POT_ibyr2 20 to ICURIYR2+3
             basecapg(curiyr,i)=is_basecap(inddir,stepnum)*is_base_tech_share(inddir,stepnum,i)
             if (curiyr.eq.ICURIYR2+2) then  ! POT_ibyr2 19 to ICURIYR2+2
                basecapIBYR(i) = basecapg(curiyr,i)
             end if
           else
              basecapg(curiyr,i)=basecapg(curiyr-1,i)-(basecapIBYR(i)/is_baselifecr(inddir))
              if (basecapg(curiyr,i).lt.0.0) basecapg(curiyr,i)=0.0
           end if
         end do

!Surviving Baseline Capacity (col F)
         surv_base=0.0
         do i=1,NUMTYPg
           surv_base = surv_base+basecapg(curiyr,i)
         end do
        scale_min=0.0
		oyr = 0.
        do i=1,NUMTYPG
          if (int(obsoleteyr(inddir,stepnum,i)) .LE. curiyr+1989) then
			scale_comp(i)=1.0e-7
            ! oyr=1.0
          else
           ! oyr=0.0
          ! endif
			   scale_comp(i)=( cm_logit_coeff_r(1)*totfixcst(i)*(1 + oyr*99.0)+ &           ! Fixed cost term
					 cm_logit_coeff_r(2)*IS_fuel_use(inddir,stepnum,1,i)*&                  ! Electricity costs term
					 (PELIN(MNUMCR,curiyr)*MC_JPGDP(20))+ &
					 cm_logit_coeff_r(6)*IS_fuel_use(inddir,stepnum,2,i)* &                 ! Natural gas costs
					 (PGFIN(MNUMCR,curiyr)*MC_JPGDP(20))+ &
					 cm_logit_coeff_r(4)*IS_EMISS(inddir,stepnum,i)+ &                      ! CO2 emissions (T/kT output) term
                     (is_alpha(inddir,stepnum,i)* &
					 (exp(-IS_ALPHA_DECAY(inddir,1)*(curiyr+1989-IBYR2-1)*ln2/IS_ALPHA_DECAY(inddir,2)))))
			   if (scale_comp(i).lt.scale_min) scale_min=scale_comp(i)
		  endif
        enddo
        scale_adj = 30.0
        if (scale_min.LT.(- scale_adj)) then                                
	       scale_fctr = -(scale_min + scale_adj)                            ! Uniform additive factor to bring calculations back into line
	    else
	       scale_fctr = 0.0
	    endif

1669    if (curcalyr.eq.ibyr2+1) numiter=numiter+1  ! POT_ibyr2 2007 to ibyr2+1
        if (numiter.eq.imaxitr) write(iunit1,*) "WARNING: MAX ITER REACHED in raw_grind_alloc"
        sum_logit_comp=0.0
         do i=1,NUMTYPG
           if (int(obsoleteyr(inddir,stepnum,i)) .LE. curiyr+1989) then
				logit_comp(i) = 1.0e-7
          !    oyr=1.0
            else
          !    oyr=0.0
          !  endif         ! POT_INPUT calibrationc to cm_logit_coeff_r
            logit_comp(i)=exp(cm_logit_coeff_r(1)*totfixcst(i)* (1 + oyr*99.0) + &          ! Fixed costs term
                       cm_logit_coeff_r(2)*IS_fuel_use(inddir,stepnum,1,i)*&                ! Electricity costs term
                       (PELIN(MNUMCR,curiyr)*MC_JPGDP(20))+ &
                       cm_logit_coeff_r(6)*IS_fuel_use(inddir,stepnum,2,i)* &               ! Natural gas costs term
                       (PGFIN(MNUMCR,curiyr)*MC_JPGDP(20))+ &
                       cm_logit_coeff_r(4)*IS_EMISS(inddir,stepnum,i)+ &                    ! CO2 emissions (T/kT output) term
                       (is_alpha(inddir,stepnum,i)* &
                       (exp(-IS_ALPHA_DECAY(inddir,1)*float(curcalyr-ibyr2-1)*ln2/IS_ALPHA_DECAY(inddir,2))))+scale_fctr)
			endif
            !sum logit
              sum_logit_comp=sum_logit_comp+logit_comp(i)
            if (logit_comp(i).eq.0.0) write(iunit1,*) 'ERROR in Raw Grinding Allocation logit'
         end do
         do i=1,NUMTYPG
           if (sum_logit_comp.ne.0.0) then
              shares(i,curiyr)=logit_comp(i)/sum_logit_comp
           else
              shares(i,curiyr)=0.0
           endif
           is_shares(inddir,stepnum,i,curiyr)=shares(i,curiyr)
         enddo
!!	Adjust alternative specific constants (ASC) to ensure initial equipment shares match historical values
!!               Only do this in 2005
!    if ((FRZTECH.eq.1) .or. (HITECH.eq.1) )then
            if ((curcalyr.eq.ibyr2+1).and.(curitr.eq.1)) then
              do i=1,NUMTYPG
                if (is_base_tech_share(inddir,stepnum,i) .ne. 0.0 .and. shares(i,curiyr) .ne. 0.0) then
                   adjust_factorg(i) = log(is_base_tech_share(inddir,stepnum,i)/shares(i,curiyr))  ! Calculate deviation from historical values
                else
                   adjust_factorg(i) = 0.0
                endif
                is_alpha(inddir,stepnum,i) = is_alpha(inddir,stepnum,i) + adjust_factorg(i)            ! Modify the ASC accordingly
              enddo
              do i=1,NUMTYPg
                 if ((ABS(adjust_factorg(i)).GT.0.001).and.(numiter.le.imaxitr)) GOTO 1669                ! If any of the factors exceeds the limit, redo the calculation
              enddo
            endif
         do i=1,NUMTYPG
           surviving_added_capacity(i)=0.0
           if (curiyr.ge.CM_FISYR(stepnum))then
             do k=CM_FISYR(stepnum),curiyr
               surviving_added_capacity(i)=surviving_added_capacity(i)+shares(i,k)*IS_incr_adds(inddir,stepnum,k)
             end do
           end if
         end do
          if(curiyr.eq.ibyr2) then  ! POT_ibyr2 17 to ibyr2
             wet_process(curiyr) = mass_loss_rat*wet_process(curiyr) ! from Kiln Allocation, BO
          end if

          do i=1,is_numtech(inddir,stepnum)
           wet_prod(i)=wet_process(curiyr)*cm_rawtech(i) !BJ-BK
           wet_elecg(i)=wet_prod(i)*cm_wetcoef2(i)                               ! BL-BM  Wet Process Grinding Energy, by mill type
           if (surv_base.ne.0.0) then
             if ((raw_material/surv_base).gt.1.0) then
               tot_prodg(i)=basecapg(curiyr,i)+surviving_added_capacity(i)
             else
               tot_prodg(i)=raw_material/surv_base*basecapg(curiyr,i)+surviving_added_capacity(i)
             end if
           else
             tot_prodg(i)=basecapg(curiyr,i)+surviving_added_capacity(i)
           end if
           elec_use_rpt(i)=tot_prodg(i)*(IS_fuel_use(inddir,stepnum,1,i)-is_delta(inddir,4,i)*(1.0-exp(-is_ecalib(inddir,stepnum)*vintage)))

           ng_use_rpt(i)=tot_prodg(i)*IS_fuel_use(inddir,stepnum,2,i)
         end do
          ElecCons(stepnum,curiyr)=elec_use_rpt(1)+elec_use_rpt(2)+wet_elecg(1)+wet_elecg(2)
          NGCons(stepnum,curiyr)=ng_use_rpt(1)+ng_use_rpt(2)

       end if
       return
       end

!********************************************************************
! IDM Input
       SUBROUTINE READ_IDMinput
       use i_
       IMPLICIT NONE
       integer ifile1,k,jj,ii,f
       character*255 cline
       Real Elec_Weight(4,3)                          ! Weighting factors for electric equipment components (3), by region (4)
       Real TPC_Weight(4,3,6)                         ! Weighting factors for Equipment, Underground Share & Productivity in TPC Calculation
       Real NonEl_Weight(2:6,2)                       ! Weighting factors for non-electric equipment:  Heating & Vehicles, by fuel type
       Real CL_L_Prod(4,2,16:mnumyr)                  ! Production-weighted Labor Productivity rates, derived from CLUSER File.
       Real Elec_Met_Wt(4,3)
       Real Elec_NM_Wt(4,3)
       Real NonEl_Met_Wt(2:6,2)
       Real NonEl_NM_Wt(2:6,2)
       Real TPC_Met_Wt(4,2,6)
       Real TPC_NM_Wt(4,2,6)
       Real Reg_MetlShr(4)

       COMMON /IN_COAL/Elec_Weight,TPC_Weight,NonEl_Weight,CL_L_Prod, &
                       Elec_Met_Wt,Elec_NM_Wt,NonEl_Met_Wt,NonEl_NM_Wt, &
                       TPC_Met_Wt,TPC_NM_Wt,Reg_MetlShr

       FNAME='INDCMENT          '
       NEW=.FALSE.
       ifile1=FILE_MGR('O',FNAME,NEW)


!     Coal Mining input

       do ii=1,4
         call ind_nextdat(ifile1,cline)
         READ (cline,*) (Elec_Weight(ii,jj),jj=1,3)

       enddo

       do ii=1,2
         call ind_nextdat(ifile1,cline)
         READ (cline,*) (NonEl_Weight(jj,ii),jj=2,6)

       enddo

       do ii=1,4
         call ind_nextdat(ifile1,cline)
         READ (cline,*) (TPC_Weight(ii,1,jj),jj=1,6)
       enddo

       do jj=1,2
         do ii=1,4
           call ind_nextdat(ifile1,cline)
           READ (cline,*) (CL_L_Prod(ii,jj,k),k=16,40)
           call ind_nextdat(ifile1,cline)
           READ (cline,*) (CL_L_Prod(ii,jj,k),k=41,mnumyr)
         enddo
       enddo

    ! Non-Coal Mining Input

       do ii=1,4
         call ind_nextdat(ifile1,cline)
         READ (cline,*) (Elec_Met_Wt(ii,jj),jj=1,3)
       enddo
       do ii=1,4
         call ind_nextdat(ifile1,cline)
         READ (cline,*) (Elec_NM_Wt(ii,jj),jj=1,3)
       enddo
       do jj=1,2
         call ind_nextdat(ifile1,cline)
         READ (cline,*) (NonEl_Met_Wt(ii,jj),ii=2,6)
       enddo
       do jj=1,2
         call ind_nextdat(ifile1,cline)
         READ (cline,*) (NonEl_NM_Wt(ii,jj),ii=2,6)
       enddo
       do ii=1,4
         call ind_nextdat(ifile1,cline)
         READ (cline,*) (TPC_Met_Wt(ii,1,jj),jj=1,6)
       enddo
       do ii=1,4
         call ind_nextdat(ifile1,cline)
         READ (cline,*) (TPC_NM_Wt(ii,1,jj),jj=1,6)
       enddo
       call ind_nextdat(ifile1,cline)
       READ (cline,*) (Reg_MetlShr(jj),jj=1,4)

       ifile1=FILE_MGR('C',FNAME,NEW)
       RETURN
       END SUBROUTINE READ_IDMinput

! end cement industry submodule
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
! aluminum industry submodule


       subroutine Aluminum_Industry
       use i_
       IMPLICIT NONE

       integer istep

       call TECH_STEP(1)
       call AL_anode_prd
       do istep=3,5
         call TECH_STEP(istep)
       enddo
       call AL_prod_form  !fuel use for product formation
       return
       END subroutine Aluminum_Industry
 !*******************************************************************************************
subroutine AL_prod_form
!Product formation fuel use (aluminum)

      use i_
      implicit none

      real  dom_prod  !domestic production (1000 tonnes)
      real index

	  ! kpe code change to account for USGS production - change made 10/13/2017
	
	  !if (curcalyr.le.IBYR)  is_production(inddir,1) = 5280.0            ! POT_IBYR
	  !if (curcalyr.eq.IBYR+1)  is_production(inddir,1) = 4967.0          ! POT_IBYR15
	  !if (curcalyr.eq.2016)  is_production(inddir,1) = 4421.0

	  if (curcalyr.le.2016) index=1.0       ! old index=OUTIND(13,11)/ALUMIBYR
	  if (curcalyr.gt.2016) index = outind(13,11)/ALUMIBYR    ! shipments - current year to ibyr2 year. POT_ibyr2 Departure from other models - sets base year to ibyr2 POT_ibyr2

	  ! end kkpe code change 10/13/17

      dom_prod=is_production(inddir,1)*index
      ElecCons(6,curiyr)=dom_prod*al_pf_fuel(1)*1000000.2
      NGCons(6,curiyr)=dom_prod*al_pf_fuel(2)*1000000.0

      return
      end

!*******************************************************************************************
subroutine AL_anode_prd
!Anode Production

      use i_
      implicit none

      integer ii
      real AnodeReq(8) ! KiloTonnes of Anode Required (Col B-H,K) PB_1,PB_2,PB_3,PB_4,IA_1,SOD_EX,PB_EX,Total 1-4
      real FuelInput(2,3) !Fuel Input: (Electricity,Natural Gas: SBA_NG1,PBA_NG1,PBA_NG2)
      real ProcInput(2,3) !Process Input: (Petroleum Coke,Petroleum Pitch: SBA_NG1,PBA_NG1,PBA_NG2)
      real baseline_prod(2)   ! baseline Production, 1- Soderberg 2- Pre-Bake (Smelt Col D&E)
      real AL_TotalSmeltOut(7)     !Total Smelting Output (Col AG - AM)

      !Anode Production
      real Al_AnodeSum(4)                  !Anode Production Energy Use Elec,NG,Pet Coke, Other Pet
      integer stepnum
      integer SmeltStep

      stepnum=2
      SmeltStep=1
!******************************************************************
      ! SOD_EX, PB_EX Baseline Production (Col D and E)

      if (curiyr.le.ICURIYR2+1) then
        do ii=1,2
          baseline_prod(ii)=sumprodcur(inddir,stepnum)*IS_BASE_TECH_SHARE(inddir,1,ii+is_numtech(inddir,SmeltStep)) ! Col D and E 2005 - 2008
        enddo

	  else
	    do ii=1,2
	      baseline_prod(ii) = MIN(sumprodcur(inddir,stepnum),is_surviving_cap(inddir))*IS_BASE_TECH_SHARE(inddir,1,ii+is_numtech(inddir,SmeltStep))
          if (  baseline_prod(ii).lt.0.0) baseline_prod(ii)=0.0
	    enddo

      endif


      tot_production_tech(inddir,is_numtech(inddir,SmeltStep)+1)= baseline_prod(1) !SOD_EX
      tot_production_tech(inddir,is_numtech(inddir,SmeltStep)+2)= baseline_prod(2) !PB_EX
 !*********************************************************************************************

!Anode required (kT) (Col B- H)
      AnodeReq(is_numtech(inddir,SmeltStep)+1)=tot_production_tech(inddir,is_numtech(inddir,SmeltStep)+1)*AnodeRatio(6)
      AnodeReq(is_numtech(inddir,SmeltStep)+2)=tot_production_tech(inddir,is_numtech(inddir,SmeltStep)+2)*AnodeRatio(7)
      do ii=1,is_numtech(inddir,SmeltStep)
        AnodeReq(ii)=tot_production_tech(inddir,ii)*AnodeRatio(ii)
      enddo


!Anode Requirement by Type (kT) Col I-K
!Col I&J=Col B&C
!AnodeReq(8)=sum AnodeReq(3-7)

        AnodeReq(8)=0.0
        do ii=1,is_numtech(inddir,SmeltStep) !number of smelting technolgies
          AnodeReq(8)=AnodeReq(8)+AnodeReq(ii)
        enddo


!Fuel Input (Col N-S)
   !Electricity (MMBtu) and Natural Gas (MMBtu)

      do ii=1,2
        FuelInput(1,ii)=IS_FUEL_USE(inddir,stepnum,1,ii)*AnodeReq(ii+is_numtech(inddir,SmeltStep))
        FuelInput(2,ii)=IS_FUEL_USE(inddir,stepnum,2,ii)*AnodeReq(ii+is_numtech(inddir,SmeltStep))
      enddo
      FuelInput(1,3)=IS_FUEL_USE(inddir,stepnum,1,3)*AnodeReq(8)
      FuelInput(2,3)=IS_FUEL_USE(inddir,stepnum,2,3)*AnodeReq(8)


!Process Inputs (Col T- Y)

      do ii=1,2
        ProcInput(1,ii)=IS_FUEL_USE(inddir,stepnum,6,ii)*AnodeReq(ii+is_numtech(inddir,SmeltStep))!pet coke
        ProcInput(2,ii)=IS_FUEL_USE(inddir,stepnum,7,ii)*AnodeReq(ii+is_numtech(inddir,SmeltStep)) !other pet
      enddo
      ProcInput(1,3)=IS_FUEL_USE(inddir,stepnum,6,3)*AnodeReq(8) !pet coke
      ProcInput(2,3)=IS_FUEL_USE(inddir,stepnum,7,3)*AnodeReq(8)  !other pet


!Anode Production Energy Summary (MmBtu) (Col AB - AE)

       ElecCons(stepnum,curiyr)=(FuelInput(1,1)+FuelInput(1,2)+FuelInput(1,3))  !elec
       NGCons(stepnum,curiyr)=(FuelInput(2,1)+FuelInput(2,2)+FuelInput(2,3))  !gas
       PetCons(stepnum,curiyr)=(ProcInput(1,1)+ProcInput(1,2)+ProcInput(1,3)) !pet coke
       OPetCons(stepnum,curiyr)=(ProcInput(2,1)+ProcInput(2,2)+ProcInput(2,3)) ! other pet
       return
       end


!****************************************************************
!
! GLASS
! glass industry submodule

       subroutine Glass_Industry
       use i_
       IMPLICIT NONE

       integer ii

       do ii=1,4
          Gl_add_elec(ii)=gl_cryo*gl_oxy(2,ii)*0.907185*1000.0  !cell C17-C20 Oxy Fuel sheet!
       enddo
       call GL_Shipping

       do ii=1,3
         call TECH_STEP(ii)
       enddo
       CALL GL_OxyFuel(1)
       do ii=4,6
         call TECH_STEP(ii)
       enddo
       CALL GL_OxyFuel(2)
       do ii=7,10
         call TECH_STEP(ii)
       enddo
       CALL GL_OxyFuel(3)
       do ii=7,13
         call TECH_STEP(ii)
       enddo
       CALL GL_OxyFuel(4)
       call TECH_STEP(14)

       return
       END subroutine Glass_Industry


!*************************************************
! SUSAN UPDATED WITH MC_REVIND_ADJ
!  yg(2) was based on apparel, which is now gone, so I quickly calculated 8/(7+8+25)
!                    (apparel's share of the new group of textile+apparel+leather)
!    from the Q:/output/aeo2014/ref2014/d070513a  run
!    which turned out to be a surprisingly steady (Freddy) percentage
!    starting at 23.38% in 2014 and rising slowly to 24.08% in 2040, thus 24% is used below.

       Subroutine GL_Shipping
! individual glass shipments

       use i_
       IMPLICIT NONE

       integer ii
       real yg(4)
       real ytot

       if (curiyr.gt.ICURIYR2+5) then ! use historical shipping shares before 2016 POT_ibyr2 22 to ICURIYR2+5

         yg(1)=0.00171*(mc_revind(mnumcr,39,curiyr) * MC_REVIND_ADJ(39) + mc_revind(mnumcr,48,curiyr) * MC_REVIND_ADJ(48) )-0.1756         !flat glass
         yg(2)=0.048151*.24*mc_revind(mnumcr,7,curiyr)*MC_REVIND_ADJ(7) + 2.932934 ! blown glass
         yg(3)=0.003772*mc_revind(mnumcr,1,curiyr)*MC_REVIND_ADJ(1) + 2.533845     ! container glass
         yg(4)=0.070395*mc_revind(mnumcr,27,curiyr)*MC_REVIND_ADJ(27) - 2.77323    ! glass products
         ytot=sum(yg(1:4))
         do ii=1,4
           gl_ship(ii)=yg(ii)/ytot*mc_revind(mnumcr,28,curiyr)*MC_REVIND_ADJ(28)    ! flat glass shipments
         enddo
       endif
!over write with history
       if (curiyr.le.ICURIYR2+5) then    ! POT_ibyr2 22 to ICURIYR2 + 5
         do ii=1,4
           gl_ship(ii)=gl_hist_ship(curiyr-ICURIYR2+1,ii)* mc_revind(mnumcr,28,curiyr)*MC_REVIND_ADJ(28)     ! POT_ibyr2 16 to ICURIYR2+1       NSK CHECK
         enddo
       endif

       end

!***************************************************
       Subroutine GL_OxyFuel(gtype)
! Glass Adjustments to Fuel Consumptions for Oxy-Fuel Furnaces

       use i_
       IMPLICIT NONE

        integer gtype !1=flat 2=container 3=blown  4=fiber
        integer nfurn ! number of furnaces for glass type
        ! furnace steps are 3,6,10 and 13


        real el_cost ! Electric cost
        real NGSave(maxtech) ! NG savings
        real NetSave(maxtech) ! Net Savings
        real gl_flfuropt(maxtech)  ! Furnace options

        real pca(maxtech) ! Percent Cost Advantage

         el_cost=Gl_add_elec(gtype)*(DPRCX(1,MNUMCR,1)*MC_JPGDP(20))    ! Electric Costs $/tonne

        SELECT CASE (gtype)
           CASE (1)
             nfurn=is_numtech(inddir,3)
             do i=1,nfurn
                Gl_FlFurOpt(i)=IS_FUEL_USE(10,3,2,i) !flat
             enddo
           CASE (2)
             nfurn=is_numtech(inddir,6)
             do i=1,nfurn
                Gl_FlFurOpt(i)=IS_FUEL_USE(10,6,2,i) !container
             enddo
           CASE (3)
             nfurn=is_numtech(inddir,10)
             do i=1,nfurn
                Gl_FlFurOpt(i)=IS_FUEL_USE(10,10,2,i) !blown
             enddo
           CASE (4)
             nfurn=is_numtech(inddir,13)
             do i=1,nfurn
                Gl_FlFurOpt(i)=IS_FUEL_USE(10,13,2,i) !fiber
             enddo
           CASE DEFAULT
             nfurn=1
             write(iunit1,'(a,I4)') 'ERROR in oxy fuel, gtype=', gtype
        END SELECT

         do i=1, nfurn
            NgSave(i)=-gl_oxy(1,gtype)*Gl_FlFurOpt(i)*(DPRCX(3,MNUMCR,1)*MC_JPGDP(20))/1000.0                        ! Natural Gas Savings $/tonne
            NetSave(i)=NgSave(i)-el_cost
            if (-gl_oxy(1,gtype).ne.0.0) then
             if (NgSave(i).ne.0.0) then                                                                                                                                  !Net Savings $/tonne
              pca(i)= NetSave(i)/(NgSave(i)/-gl_oxy(1,gtype))
             endif
            endif                                                                                                 !Percent Cost Advantage
            gl_oshares(i)=gl_Oxy(3,1)+ (gl_Oxy(3,2)-gl_Oxy(3,1))/(1+EXP(-gl_Oxy(3,4)*(pca(i)-gl_Oxy(3,3))+10))  !Oxy Shares
         enddo
        return
        end

!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
! This group of subroutines is common for the tech choice industries
!*********************************************************************************************************************
! calculates energy usage for a specified iron and steel step; step is identified by variable stepnum
! called for Hot Roll, Casting,BOF, EAF and DRI; Cold Roll and Coke are calculated in other subroutines
! common for the tech choice industries
! Called from: IronSteel_Industry, Paper_Industry
! CALLS: Step_Capacity, logit_calc, shares_calc, SurvivingAddedCapacity

      subroutine TECH_STEP(stepnum)
      use i_
      implicit none

      integer stepnum                               !step number
      integer ifuel                                 !index for fuel type
      integer inumtech                              !loop counter for technologies
      integer numiter                               ! Number of iterations calculating base-year alpha coefficients
      integer imaxitr
      integer ii,kk,ix                                   !counter
      real is_adjfac(maxtech)
      real totsumprodcur                             !national prodcur for DRI

!********* Production & Capacity *******************
      real surviving_added_capacity(maxtech)        ! Surviving added capacity


!********* Technology Characteristics **************
      real crf                                      ! Capital Recovery Factor (CRF)
      real ann_cc                                   ! Annualized Cost of Capital
      real totfixcst (maxstep,maxtech)              ! Total fixed cost of technology

!********* Technology Share Variables **************
      real*16 logit_comp(maxtech)                   ! Logit component
      real logit_steam(maxtech)                     ! steam for paper
      real shares2(maxtech)                         ! Technology shares for current year
      real*16 scale_comp                            ! Preliminary computation to test the scale of the logit function
      real scale_fac                                ! Scale factor
      real scale_min                                ! Minimum scale factor
      real scale_adj                                ! Scale Adjustment

!********* Energy Use Variables *****************
      real IS_tot_energy_use(IS_MAXFUEL+3,maxtech)  ! Total energy use by fuel and technology
      real IS_tot_nonfuel_use(2,maxtech)            ! Total non fuel energy use by technology
      real  Oxygen_Intensity
!*** CO2 ****************************
      real co2_use(maxstep,maxtech)
!********* Functions **************
      real*16 logit_calc                            ! logit function
      real*16 scale_fctr2                           ! scale factor function
      real SurvivingAddedCapacity                   ! added capacity function
      real vintage_index                            ! vintage index
      real OXY_Steel(9) !IS_MAXSTPS)                    ! Oxygen Demand (GJ)
      real ELEC_OXY(9) !IS_MAXSTPS)

      real index2006 ,v
      real TotBliq
	  real Bliqtot 								 !Total Black Liquor for paper (kilotonnes)
      real particulate_dummy

      ! initialization block
	  
	  
       ifuel  =0; inumtech = 0; numiter=0;  imaxitr = 0
       ! ii,kk	,ix                                   !counter
	   ! real variables 
       is_adjfac(:) = 0.0; totsumprodcur=0.0; 
	   surviving_added_capacity(:) = 0.0

       crf = 0.0; ann_cc = 0.0; totfixcst (:,:) = 0.0; 
	   logit_comp(:) = 0.0; logit_steam(:) = 0.0; shares2(:) = 0.0                         ! Technology shares for current year
       scale_comp = 0.0; scale_fac = 0.0;       scale_min = 0.0;                               ! Minimum scale factor
       scale_adj = 0.0; IS_tot_energy_use(:,:) = 0.0;  IS_tot_nonfuel_use(:,:) = 0.0;           ! Total non fuel energy use by technology
       Oxygen_Intensity = 0.0;  co2_use(:,:) = 0.0; 
       OXY_Steel(:) = 0.0; ELEC_OXY(:) = 0.0; 

	  index2006= 0.0;  v = 0.0
	  
	  TotBliq = 0.0
	  Bliqtot = 0.0

        if (HITECH.eq.1) then
           scenario=2
        else if (FRZTECH.eq.1) then
           scenario=3
        else if (EETECH.eq.1) then
           scenario=4
        else
           scenario=1
        endif
        if (inddir == 10) then  !glass
            SELECT CASE (stepnum)
              CASE (1:4)
                index2006=GL_ship(1)/GLASSIBYR(2)
              CASE (5:7)
                index2006=GL_ship(2)/GLASSIBYR(3)
              CASE (8:11)
                index2006=GL_ship(3)/GLASSIBYR(4)
              CASE (12:14)
                index2006=GL_ship(4)/GLASSIBYR(5)
              CASE DEFAULT
                 WRITE(*,*)  "no index set for glass"
            END SELECT
            sumprodcur(inddir,stepnum)=IS_PRODUCTION(inddir,stepnum)*index2006!*(flat_adjfac(curiyr))
            gl_prodcurrpt(stepnum,curiyr)=sumprodcur(inddir,stepnum) !save for TECHSHR_RPT
            is_alpha_decay(inddir,:)=gl_alpha_decay(stepnum,scenario,:)


       else if (inddir==13) then !aluminum
           index2006=OUTIND(13,11)/ALUMIBYR     ! ALUMIBYR now updated to ibyr2 values POT_ibyr2
           if (stepnum==1) then
             sumprodcur(inddir,stepnum)=is_production(inddir,stepnum)*index2006*primprod_percent(curiyr)      ! Total AL production, percent allocated to primary

           else if(stepnum==5) then
             sumprodcur(inddir,stepnum) = is_production(inddir,1) * index2006 * (1-primprod_percent(curiyr))          ! Total AL production, percent allocated to secondary

           else if (stepnum.eq.3) then
             sumprodcur(inddir,stepnum)=( sumprodcur(inddir,1)/al_mass_loss) * (1.0+al_non_met) *(1 - alumina_percent(curiyr))       ! Changed to percent imports—hold at 43.6% for now

           else if (stepnum.eq.4) then!boilers
             sumprodcur(inddir,stepnum)=(SUM(IS_tot_nonfuel_use(2,1:is_numtech(inddir,3))) /1000000.0)*1054.615

           endif
           al_prodcurrpt(stepnum,curiyr)=sumprodcur(inddir,stepnum) !save for TECHSHR_RPT
           is_alpha_decay(inddir,:)=al_alpha_decay(stepnum,scenario,:)

        else if (inddir==11) then !cement values are by step so copy into industry variable
            if (stepnum<5) then
              IS_BASELIFECR(INDDIR)= CM_BASELIFECR(stepnum)
	          IS_LIFETIME(INDDIR)=CM_LIFETIME(stepnum)
              IS_CALIB(INDDIR)=CM_CALIB(stepnum)
	          IS_WACC(inddir)=CM_WACC(stepnum)
	          IS_FISYR(inddir)=ICURIYR2+1 !CM_FISYR(stepnum)
              index2006=OUTIND(22,11)/CEMENTIBYR
              
              sumprodcur(inddir,stepnum)=is_production(inddir,stepnum)*index2006
              cm_prodcurrpt(stepnum,curiyr)=sumprodcur(inddir,stepnum)
              is_alpha_decay(inddir,:)=cm_alpha_decay(stepnum,scenario,:)
              grinding_tonnes=sumprodcur(inddir,stepnum)
              !WRITE(6,*) 'NSK test', curcalyr, curitr,stepnum,index2006,CEMENTIBYR,grinding_tonnes
              If (curiyr.ge.ICURIYR2+3) then               ! POT_ibyr2 20 to ICURIYR2+3
                v=vintage_index(stepnum)  !calc vintage index
              endif
            else
               index2006=OUTIND(23,11)/LIMEIBYR
               sumprodcur(inddir,stepnum)=is_production(inddir,stepnum)*index2006
               v=vintage_index(stepnum)  !calc vintage index
            endif

        endif

        CALL Step_Capacity(stepnum,        &
                         is_FISYR(inddir),       &
                         is_baselifecr(inddir),  &
                         is_lifetime(inddir),    &
                         is_calib(inddir),       &
                         sumprodcur(inddir,stepnum))

!***** Calculate the Annualized Cost of Each Technology *************************
        crf=is_wacc(inddir)*(1.0+is_wacc(inddir))**is_lifetime(inddir)/((1.0+is_wacc(inddir))**is_lifetime(inddir)-1.0) ! Same for all technologies

        DO inumtech=1,is_numtech(inddir,stepnum)                                       ! For Each Competing Technology
           ann_cc = crf * is_capcost(inddir,stepnum,inumtech)                          ! Annualized Capital Cost of Technology
           totfixcst(stepnum,inumtech) = ann_cc + is_av_OM(inddir,stepnum,inumtech)    ! Total Fixed Cost of Technology
        ENDDO


!***** Calculate Scale Factor (prevents Fortran functions from going out-of-bounds) ************

        numiter = 0
        imaxitr=1000

1666    if (curiyr.eq.IS_FISYR(inddir)) numiter=numiter+1        ! Ensure first-year tech shares match history
        if (numiter.eq.imaxitr)  &                               ! But don't let things get out of hand
            write(iunit1,'("WARNING: MAX ITER REACHED, Industry=",I4,"  step=",I4)') inddir,stepnum

        scale_min = 0.0; scale_fac = 0.0
        scale_adj = 30.0                                         ! Additive Adjustment Factor

! do we need an is_steam evenutality?

        DO inumtech=1,is_numtech(inddir,stepnum)                 ! For each technology
            if (inddir.eq.8) then
               logit_steam(inumtech)=pp_steam(stepnum,inumtech)  !is_nfuel_use(inddir,stepnum,2,inumtech)
            else if (inddir.eq.13) then
               logit_steam(inumtech)=is_nfuel_use(inddir,stepnum,2,inumtech)
            else
               logit_steam(inumtech)=0.0
            endif
            
            IF ((inddir.eq.11).and.(stepnum.lt.5)) THEN
                particulate_dummy=part_matter(stepnum,inumtech)
            ELSE
                particulate_dummy=1
            ENDIF

           scale_comp = scale_fctr2(is_logit_coeff(inddir,:,stepnum),   & ! Function to calculate the un-exponentiated logit component
                                totfixcst(stepnum,inumtech),            &
                                IS_fuel_use(inddir,stepnum,:,inumtech), &   
                                IS_emiss(inddir,stepnum,inumtech),      &
                                is_co2penalty(inddir,curiyr),           &
                                is_alpha_decay(inddir,:),               &
                                is_alpha(inddir,stepnum,inumtech),logit_steam(inumtech),obsoleteyr(inddir,stepnum,inumtech),stepnum,particulate_dummy)

            IF (scale_comp.lt.scale_min) scale_min = scale_comp   ! Select the smallest value generated by the various technologies
        ENDDO

        IF (scale_min.LT.(- scale_adj)) THEN                           ! Test if the value falls below a pre-set minimum
           scale_fac = -(scale_min + scale_adj)                       ! If so, add a constant factor to bring calculations back into line
        ELSE                                                         ! Otherwise,
           scale_fac = 0.0                                            ! Don't bother adjusting
        ENDIF


!***** Pass the Technology Characteristics to the Logit Calculation Function *********
        DO inumtech=1,is_numtech(inddir,stepnum)                            ! For Each Competing Technology
            logit_comp(inumtech) = logit_calc(is_logit_coeff(inddir,:,stepnum),                  &
                                          totfixcst(stepnum,inumtech),     &
                                          IS_fuel_use(inddir,stepnum,:,inumtech), &
                                          IS_emiss(inddir,stepnum,inumtech),      &
                                          is_co2penalty(inddir,curiyr),           &
                                          is_alpha_decay(inddir,:),               &
                                          is_alpha(inddir,stepnum,inumtech),      &
                                          scale_fac,logit_steam(inumtech),obsoleteyr(inddir,stepnum,inumtech),stepnum,particulate_dummy)
        ENDDO

!***** Allocate Additional Production Among Competing Technologies ********

        CALL shares_calc(logit_comp,shares2,is_numtech(inddir,stepnum))

!***** In Base Year, Calibrate Alternate-Specific Constants ***************
! obsoleteyr(inumind,4,1:8),1,8,1)
! int(obsoleteyr(inddir,stepnum,i))

        IF ((curiyr.eq.IS_FISYR(inddir)).and.(curitr.eq.1)) then
          do i = 1,is_numtech(inddir,stepnum)
            if (shares2(i) .ne. 0.0 .and. is_add_tech_share(inddir,stepnum,i) .ne. 0.0) then
               is_adjfac(i) = log(is_add_tech_share(inddir,stepnum,i)/shares2(i))  ! Calculate deviation from historical values
            else
               is_adjfac(i) = 0.0
               if (curcalyr .lt. int(obsoleteyr(inddir,stepnum,i))) write(6,'( "shares2 is 0.0 for ",I6,3I4)') curcalyr,inddir,stepnum,i  ! *** if statement added by kpe 8/6/18 to prevent 																								  ! error messages from obsolesent technologies			
            endif																																  !  obsolescent industry from generating warning message
            is_alpha(inddir,stepnum,i) = is_alpha(inddir,stepnum,i) + is_adjfac(i)            ! Modify the ASC accordingly
          enddo

          do i=1,is_numtech(inddir,stepnum)
            if ((ABS(is_adjfac(i)).GT.0.001).and.(numiter.le.imaxitr)) GOTO 1666   ! If any of the factors exceeds the limit, redo the calculation
          enddo
        ENDIF                                                     ! End of Base Year Calibration Calculation

!***** Calculate Total Process Output from Each Technology *******************
      ! set base year shares variable from inputs for reporting only
        if (curcalyr.eq.ibyr2+1) then
           DO inumtech=1,is_numtech(inddir,stepnum)
              is_shares(inddir,stepnum,inumtech,curiyr-1)=is_add_tech_share(inddir,stepnum,inumtech)
           enddo
        endif
		
        is_shares(inddir,stepnum,1:is_numtech(inddir,stepnum),curiyr) = shares2(1:is_numtech(inddir,stepnum))      ! Keep Track of Historical Technology Shares

        IS_tot_energy_use=0.0  !initialize energy use
        DO inumtech=1,is_numtech(inddir,stepnum)         ! For Each Technology
           surviving_added_capacity(inumtech) = SurvivingAddedCapacity(stepnum,inumtech,is_shares)      ! Function for Added Technology Production
 	   tot_production_tech(inddir,inumtech) = MIN(is_basecap(inddir,stepnum),is_surviving_cap(inddir)) * is_base_tech_share(inddir,stepnum,inumtech) & ! Production from Baseline Technologies
                                      + surviving_added_capacity(inumtech)

           if (inddir.eq.8) then !paper 
               tot_production_tech(inddir,inumtech) = MIN(sumprodcur(inddir,stepnum),is_basecap(inddir,stepnum)) * is_base_tech_share(inddir,stepnum,inumtech) & ! Production from Baseline Technologies
                                        + surviving_added_capacity(inumtech)
                                 
                ! KPE comments -- tot production tech for steps 24:26 is the sum of pulp proudction
				! for steps 2 & 3--gets translated to black liquor below

										
           endif
		   
		   if (inddir.eq.10) then ! glass
               tot_production_tech(inddir,inumtech) = MIN(sumprodcur(inddir,stepnum),is_basecap(inddir,stepnum)) * is_base_tech_share(inddir,stepnum,inumtech) & ! Production from Baseline Technologies
                                        + surviving_added_capacity(inumtech)						
           endif

		   
           if ((inddir.eq.13).and.(stepnum.eq.1)) then
              do ii=1,2   !smelting has two baseline production types (Soderberg and Pre-Bake Anode)
                 tot_production_tech(inddir,is_numtech(inddir,stepnum) +ii) = MIN(sumprodcur(inddir,stepnum),is_basecap(inddir,stepnum)) * is_base_tech_share(inddir,stepnum,inumtech+ii)
              enddo
           endif
           if ((inddir.eq.11).and.(stepnum.eq.1)) then   !cement
              if (is_surviving_cap(inddir).ne.0.0) then
                 if ((sumprodcur(inddir,stepnum)/is_surviving_cap(inddir)).gt.1.0) then
                    tot_production_tech(inddir,inumtech)=is_basecap(inddir,stepnum)*is_base_tech_share(inddir,stepnum,inumtech)+surviving_added_capacity(inumtech)
                 else
                    tot_production_tech(inddir,inumtech)=sumprodcur(inddir,stepnum)/is_surviving_cap(inddir)*is_basecap(inddir,stepnum)*is_base_tech_share(inddir,stepnum,inumtech)+surviving_added_capacity(inumtech)
                 endif
              else
                 tot_production_tech(inddir,inumtech)=is_basecap(inddir,stepnum)*is_base_tech_share(inddir,stepnum,inumtech)+surviving_added_capacity(inumtech)
              endif
           endif

          tot_production_tech(inddir,inumtech)= tot_production_tech(inddir,inumtech)*prod_adjust_fact !ensure that total production matches PRODCUR **new
          
          tot_prd_rpt(inddir,stepnum,inumtech,curiyr)=tot_production_tech(inddir,inumtech) !save for reporting in itechprod.txt

 !!! Calculate SOA_Adj here for testing
            !!*************************************************************
            SOA_Offset=2
            SOA_Inflection=15.0
            SOA_Beta=2.0
            do i = 1,is_numtech(inddir,stepnum)  !!this won't do anything to alum anode since num technologies is set to zero
                 SOA_adj(inddir,stepnum,i) =  1.0+ ( is_rei(inddir,stepnum,i)- 1.0)*(1.0-1.0/(1+((MAX(((curiyr+1989)-(ibyr2+1)-SOA_Offset),0))/(SOA_Inflection-SOA_Offset))**SOA_Beta))
                ! SOA_adj(inddir,stepnum,i)=1.0 ! for no effects set SOA_adj=1.0
            enddo
            !!*************************************************************
 !***** Calculate Process Fuel Demand for Each Technology ************************

           DO ifuel=1,is_numfuel(inddir,stepnum)                                                           ! For Each Fuel: Elec,NG,HFO,Coal
              IS_tot_energy_use(ifuel,inumtech) = tot_production_tech(inddir,inumtech)       &           ! Total Production (kT)
                                                * IS_fuel_use(inddir,stepnum,ifuel,inumtech)       &      ! Energy Intensity (MMBTU/kT)
                                                 * SOA_adj(inddir,stepnum,inumtech)

!***** Special Case: Iron and Steel Casting Step Has an Additional Electricity Intensity Across all Technologies ***************
              if (inddir==12) then  !iron and steel
                  if ((stepnum.eq.3).and.(ifuel.eq.1).and.(inumtech.eq.1)) then    !add electricity for ladle refining
                      IS_tot_energy_use(ifuel,inumtech) = IS_tot_energy_use(ifuel,inumtech)+ &
                         (SUM(tot_production_tech(inddir,1:inumtech))* IS_fuel_use(inddir,stepnum,ifuel,3) &
                          * SOA_adj(inddir,stepnum,inumtech))
                  endif

!***** Special Case: Glass Furnace - Oxy ***************
!glass steps 3,6,10,13 are furnace

              else if (inddir == 10) then  !glass
                 if (ifuel == 2) then  !gas
                    SELECT CASE (stepnum)
                      CASE (3)
                        IS_tot_energy_use(ifuel,inumtech) = (1.0-gl_oshares(inumtech))*IS_tot_energy_use(ifuel,inumtech)+ &
                                                 gl_oshares(inumtech)* IS_tot_energy_use(ifuel,inumtech)*(1.0+gl_oxy(1,1)) &
                                                    * SOA_adj(inddir,stepnum,inumtech)
                      CASE (6)
                        IS_tot_energy_use(ifuel,inumtech) = (1.0-gl_oshares(inumtech))*IS_tot_energy_use(ifuel,inumtech)+ &
                                                 gl_oshares(inumtech)* IS_tot_energy_use(ifuel,inumtech)*(1.0+gl_oxy(1,2)) &
                                                    * SOA_adj(inddir,stepnum,inumtech)
                      CASE (10)
                        IS_tot_energy_use(ifuel,inumtech) = (1.0-gl_oshares(inumtech))*IS_tot_energy_use(ifuel,inumtech)+ &
                                                 gl_oshares(inumtech)* IS_tot_energy_use(ifuel,inumtech)*(1.0+gl_oxy(1,3)) &
                                                    * SOA_adj(inddir,stepnum,inumtech)
                      CASE (13)
                        IS_tot_energy_use(ifuel,inumtech) = (1.0-gl_oshares(inumtech))*IS_tot_energy_use(ifuel,inumtech)+ &
                                                gl_oshares(inumtech)* IS_tot_energy_use(ifuel,inumtech)*(1.0+gl_oxy(1,4)) &
                                                    * SOA_adj(inddir,stepnum,inumtech)
                    END SELECT

                  else if ((ifuel == 1) .and. (IS_fuel_use(inddir,stepnum,2,inumtech) >0.0)) then         !electric with some gas usage
                    SELECT CASE (stepnum)
                      CASE (3)
                        IS_tot_energy_use(ifuel,inumtech) = IS_tot_energy_use(ifuel,inumtech)+ gl_oshares(inumtech)*tot_production_tech(inddir,inumtech)*gl_add_elec(1) &
                                                            * SOA_adj(inddir,stepnum,inumtech)
                      CASE (6)
                        IS_tot_energy_use(ifuel,inumtech) = IS_tot_energy_use(ifuel,inumtech)+ gl_oshares(inumtech)*tot_production_tech(inddir,inumtech)*gl_add_elec(2) &
                                                            * SOA_adj(inddir,stepnum,inumtech)
                      CASE (10)
                        IS_tot_energy_use(ifuel,inumtech) = IS_tot_energy_use(ifuel,inumtech)+ gl_oshares(inumtech)*tot_production_tech(inddir,inumtech)*gl_add_elec(3) &
                                                            * SOA_adj(inddir,stepnum,inumtech)
                      CASE (13)
                        IS_tot_energy_use(ifuel,inumtech) = IS_tot_energy_use(ifuel,inumtech)+ gl_oshares(inumtech)*tot_production_tech(inddir,inumtech)*gl_add_elec(4) &
                                                            * SOA_adj(inddir,stepnum,inumtech)
                    END SELECT
                endif

!***** Special Case: Aluminum  *************** !! look here
              else if (inddir == 13) then
                 IF ((stepnum == 1).or.(stepnum == 3)) then
                    IS_tot_energy_use(ifuel,inumtech) = tot_production_tech(inddir,inumtech)       &           ! Total Production (kT)
                                                * IS_fuel_use(inddir,stepnum,ifuel,inumtech) &!-is_delta(inddir,stepnum,inumtech) &
                                   !             (1.0-exp(-is_ecalib(inddir,stepnum)*vintage_index(stepnum))))   &          ! Energy Intensity (MMBTU/kT) 
                                                * SOA_adj(inddir,stepnum,inumtech)

                 endif


!***** Special Case: Aluminum Smelting ***************
                 if (stepnum == 1) then
                   v=vintage_index(stepnum)
                   do ii=1,2   !smelting has two baseline production types (Soderberg and Pre-Bake Anode)
	 	             IS_tot_energy_use(ifuel,inumtech+ii) = tot_production_tech(inddir,inumtech+ii)       &           ! Total Production (kT)
                                          * (IS_fuel_use(inddir,stepnum,ifuel,inumtech+ii))  &   !! check this  -is_delta(inddir,stepnum,inumtech+ii)*(1.0-exp(-is_ecalib(inddir,stepnum)* v)))
                                            * SOA_adj(inddir,stepnum,inumtech+ii)
                   enddo
                 endif

!***** Special Case: Cement Finish Grinding  ***************
              else  if ((inddir == 11).and.(stepnum == 1)) then
                 v=vintage_index(stepnum)
                 IS_tot_energy_use(ifuel,inumtech)= tot_production_tech(inddir,inumtech)* &
                                                  (IS_FUEL_USE(inddir,stepnum,stepnum,inumtech))  &
                                            !      is_delta(inddir,stepnum,inumtech)*(1.0-exp(-is_ecalib(inddir,stepnum)*v))) &
                                                    * SOA_adj(inddir,stepnum,inumtech)

             endif   !inddir

           ENDDO  !ifuel
!  PAPER has STEAM, BLACK LIQUOR and HOG FUEL   KPE -- these can be positive & negative
           if (inddir == 8) then
              IS_tot_energy_use(is_numfuel(inddir,stepnum) +1,inumtech) = tot_production_tech(inddir,inumtech)       &           ! Total Production (kT)
                                                * PP_STEAM(stepnum,inumtech) & !is_nfuel_use(inddir,stepnum,2,inumtech) &
                          * SOA_adj(inddir,stepnum,inumtech)
              IS_tot_energy_use(is_numfuel(inddir,stepnum) +2,inumtech) = tot_production_tech(inddir,inumtech)       &           ! Total Production (kT)
                                                * PP_BLKLIQ(stepnum,inumtech) &  !is_nfuel_use(inddir,stepnum,1,inumtech) &
                          * SOA_adj(inddir,stepnum,inumtech)
              IS_tot_energy_use(is_numfuel(inddir,stepnum) +3,inumtech) = tot_production_tech(inddir,inumtech)       &           ! Total Production (kT)
                                                * PP_HOG(stepnum,inumtech) &
                          * SOA_adj(inddir,stepnum,inumtech)
           endif ! if industry = 8

!***** Calculate Process Non-Fuel Demand for Each Technology *********************

           DO ifuel=1,2                                                           ! For Each Non-Fuel: Oxygen, Steam
               IS_tot_nonfuel_use(ifuel,inumtech) = tot_production_tech(inddir,inumtech)       & ! Total Production (kT)
                                                * IS_nfuel_use(inddir,stepnum,ifuel,inumtech) &  ! Non-Fuel Intensity (GJ/kT) 
                          * SOA_adj(inddir,stepnum,inumtech)
           ENDDO
        ENDDO !inumtech
!***** Non-Fuel Summary  for steel and paper ****************************************************
        if (inddir == 12) then !steel
           Oxygen_Intensity = 0.162318                                                                 ! MMBtu per GJ of Oxygen
           OXY_Steel(stepnum)   = SUM(IS_tot_nonfuel_use(1,1:is_numtech(inddir,stepnum)))               ! Oxygen Demand (GJ)
           STM_Steel(stepnum)   = SUM(IS_tot_nonfuel_use(2,1:is_numtech(inddir,stepnum)))               ! Steam Demand  (GJ)
           ELEC_OXY(stepnum)    = OXY_Steel(stepnum) * Oxygen_Intensity                  ! Electricity for Oxygen Production (MMBtu)
        endif
        if (inddir.eq.8) STM_Steel(stepnum)   = SUM(IS_tot_nonfuel_use(2,1:is_numtech(inddir,stepnum))) ! paper Steam Demand  (GJ)
		! KPE -- when do we use above equation? --- never for paper

!***** Energy Consumption Summary ******************************************
! Initialize arrays
        ElecCons(stepnum,curiyr) = 0.0;    NgCons(stepnum,curiyr) = 0.0;  HFOCons(stepnum,curiyr) = 0.0
		ElecGen_pap26(stepnum,curiyr) = 0.0 ! KPE only valid for step26, techs 1 & 6
        CoalSCons(stepnum,curiyr) = 0.0;   CoalMCons(stepnum,curiyr)=0.0;  PAPER_STEAM(stepnum,curiyr)=0.0
		PAPER_STEAM_GRS(stepnum,curiyr) = 0.0  ! KPE added variable
         PAPER_BLIQUOR(stepnum,curiyr)=0.0; PAPER_HOG(stepnum,curiyr)=0.0; Bliqtot=0.0
! some, but not all consumption, is=0 in trills 
        if (inddir > 8) then
          if (inddir == 12) then !steel
               ElecCons(stepnum,curiyr)  = (SUM(IS_tot_energy_use(1,1:is_numtech(inddir,stepnum))) &            ! Electricity Consumption  (Trils)
                                  + SUM(ELEC_OXY(1:is_numtech(inddir,stepnum))))/1000000.0
          else if ((inddir == 13).and.(stepnum == 1)) then !Aluminum
             ElecCons(stepnum,curiyr)  = SUM(IS_tot_energy_use(1,1:is_numtech(inddir,stepnum)+2))
          else
             ElecCons(stepnum,curiyr)  = SUM(IS_tot_energy_use(1,1:is_numtech(inddir,stepnum)))
          endif
          NgCons(stepnum,curiyr)    = SUM(IS_tot_energy_use(2,1:is_numtech(inddir,stepnum)))/1000000.0     ! NG Consumption  (Trils)
          if ((inddir.eq.13).and.(stepnum.eq.5))  NgCons(stepnum,curiyr) = SUM(IS_tot_energy_use(2,1:is_numtech(inddir,stepnum)))
          HFOCons(stepnum,curiyr)   = SUM(IS_tot_energy_use(3,1:is_numtech(inddir,stepnum)))/1000000.0     ! HFO Consumption (Trils)
          CoalSCons(stepnum,curiyr) = SUM(IS_tot_energy_use(4,1:is_numtech(inddir,stepnum)))/1000000.0     ! Sub-Bit Coal Consumption (Trils)
          CoalMCons(stepnum,curiyr) = SUM(IS_tot_energy_use(5,1:is_numtech(inddir,stepnum)))/1000000.0     ! Met Coal Consumption (Trils)
        endif
! 
        if (inddir == 8) then  ! 
		  ElecCons(stepnum,curiyr)  = SUM(IS_tot_energy_use(1,1:is_numtech(inddir,stepnum)))/1000000.0 ! ww
		  if (stepnum == 26) then ! if (stepnum == 26) !  KPE Add-- for the recovery furnace step, split elec cons & elec gen; these are correct
			ElecCons(stepnum,curiyr)  =  + SUM(IS_tot_energy_use(1,2:5))/1000000.0  ! these steps consume energy
			ElecGen_pap26(stepnum,curiyr)  = abs(IS_tot_energy_use(1,1) + IS_tot_energy_use(1,6))/1000000.0 ! generate energy trilBTU
		  endif
   		  ! Electricity Consumption  (Trils)
          if (stepnum.eq.1) then !Pulp and Paper, Wood Prep
	    !add chip electricity   KPE--pp_chip is in ironstlx and not documented must be wood chipping technology--OK
		! 
   	        ElecCons(stepnum,curiyr)=ElecCons(stepnum,curiyr)+SUM(tot_production_tech(inddir,1:is_numtech(inddir,stepnum)))*pp_chip/1000000.0
		  endif   ! kpe the next statements look odd. Why gt used insetead of eq? -- I think it's OK.
		  if (is_numfuel(inddir,stepnum).gt.1) &
	          NgCons(stepnum,curiyr)= SUM(IS_tot_energy_use(2,1:is_numtech(inddir,stepnum)))/1000000.0 ! NG Consumption  (Trils) -- 
          if (is_numfuel(inddir,stepnum).gt.2) &
             HFOCons(stepnum,curiyr)= SUM(IS_tot_energy_use(3,1:is_numtech(inddir,stepnum)))/1000000.0     ! HFO Consumption (Trils)
          if (is_numfuel(inddir,stepnum).gt.3) &
	           CoalSCons(stepnum,curiyr)= SUM(IS_tot_energy_use(4,1:is_numtech(inddir,stepnum)))/1000000.0     ! Sub-Bit Coal Consumption (Trils)
          if (is_numfuel(inddir,stepnum).gt.4) &
	          CoalMCons(stepnum,curiyr)= SUM(IS_tot_energy_use(5,1:is_numtech(inddir,stepnum)))/1000000.0     ! Met Coal Consumption (Trils)
		 ! KPE paper steam to pass to boiler / steam variables 
		 ! has to be treated specially--because negative steam (supply) has to be genrated too so we need energy for that
		 ! new variable:  PAPER_STEAM_GRS used only for passing to CHP and boiler variables
		 ! PAPER_STEAM will continue to be used for other parts of the program and will be divided by 10.0**6.
		 ! PAPER_STEAM_GRS and HOG_STEAM will be in GJ -- no dividing is this program an no multiplying in other parts of the program
		 ! KPE added code--two steps--calculate negative steam, then add net steam to it 
		 !  new variable:  PAPER_STEAM_GRS --- "gross steam" -- used for boilers and and CHP calculations -- includes negative steam 
		 ! FIRST, calculate the papersteam variable, which we will use for PAPER_STEAM_GRS & throughout the program
		 PAPER_STEAM(stepnum,curiyr)=SUM(IS_tot_energy_use(is_numfuel(inddir,stepnum)+1,1:is_numtech(inddir,stepnum)))/1000000.0 ! GJ--10.0**-6--too many places where *10.0**6
		  do inumtech=1,is_numtech(inddir,stepnum)    ! PAPER_STM_GRS sum of paper_steam gross & the absolute value of PAPER_STEAM in GJ
			PAPER_STEAM_GRS(stepnum,curiyr) = PAPER_STEAM_GRS(stepnum,curiyr) + &
				abs(min(0.0,IS_tot_energy_use(is_numfuel(inddir,stepnum)+1,inumtech)))  ! KPE GJ
		  enddo
		  ! PAPER_STEAM_GRS(stepnum,curiyr)=
		  ! NOW put in original equation--will capture net steam use if second term is positive
		  PAPER_STEAM_GRS(stepnum,curiyr)=PAPER_STEAM_GRS(stepnum,curiyr) + & ! /1000000.0 + &  removed scaling so result will be in GJ
				max(0.0,PAPER_STEAM(stepnum,curiyr))*(10.0**6)    !(GJ)  NOTE:  KPE-- PAPER_STEAM  in GJ when scaled 
	
		  ! END KPE code change, August 17, 2020--rechecked 8/27 some refinements
		  !PAPER_STEAM(stepnum,curiyr)=SUM(IS_tot_energy_use(is_numfuel(inddir,stepnum)+1,1:is_numtech(inddir,stepnum)))/1000000.0
          PAPER_HOG(stepnum,curiyr)=SUM(IS_tot_energy_use(is_numfuel(inddir,stepnum)+3,1:is_numtech(inddir,stepnum))) ! GJ /1000000.0  ! KPE 8/18/20 added scaling like others
         PAPER_BLIQUOR(stepnum,curiyr)= SUM(IS_tot_energy_use(is_numfuel(inddir,stepnum)+2,1:is_numtech(inddir,stepnum))) ! GJ  /1000000.0  !(GJ)        
		!Total BLiquor and convert to kT for reporting and steps 24:26 calcs
	    
		  
        ! KPE reset black liquor variables so they don't accumulate
		
			if (stepnum == 26) then
				Bliqtot = 0.0
				PAPER_BLIQ = 0.0; 
			endif
		endif

	    If((inddir.eq.11).and.(stepnum.eq.5)) Then                                                ! POT_2050lime start cement industry with stepnum 5 for lime to step 4 in reporting
               ElecCons(stepnum,curiyr)  = SUM(IS_tot_energy_use(1,1:is_numtech(inddir,stepnum)))     ! Electricity Consumption
               NgCons(stepnum,curiyr)    = SUM(IS_tot_energy_use(2,1:is_numtech(inddir,stepnum)))     ! NG Consumption
               HFOCons(stepnum,curiyr)   = SUM(IS_tot_energy_use(3,1:is_numtech(inddir,stepnum)))     ! HFO Consumption assigned to Distl and Resid ENPQTY
               CoalSCons(stepnum,curiyr) = SUM(IS_tot_energy_use(4,1:is_numtech(inddir,stepnum)))     ! Sub-Bit Coal Consumption
               CoalMCons(stepnum,curiyr) = SUM(IS_tot_energy_use(5,1:is_numtech(inddir,stepnum)))     ! Met Coal Consumption
            endif                                                                                     ! POT_2050lime end units converted to trills in reporting

	  !***** Steam Demand ***************  KPE address steam total for paper later; 
	  !td note: zero out STM_STEEL at the beginning of paper and steel so I can sum the whole array without reference to which industry
        if (inddir == 12) STEAM_Total = SUM(STM_Steel(1:IS_MAXSTPS)) / 1.054615   !Total Steam Demand (GJ converted to MMBtu): AKA ENPIQTY(1) Check units.
        if (inddir == 8) STEAM_Total   = SUM(STM_Steel(1:PP_MAXSTPS)) / 1.054615   !Total Steam Demand (GJ converted to MMBtu): AKA ENPIQTY(1) Check units.

        DO inumtech=1,is_numtech(inddir,stepnum)
          co2_use(stepnum,inumtech)=tot_production_tech(inddir,inumtech)*is_emiss(inddir,stepnum,inumtech)
        enddo
        CO2_Tech(stepnum,curiyr)  =SUM(co2_use(stepnum,1:is_numtech(inddir,stepnum)))
        if ((inddir == 11) .and. (stepnum.eq.5)) CO2_Process=CO2_Tech(stepnum,curiyr) !lime
        return
        end

!************************************************************************************************************
! This subroutine calculates capacity variables:
!    IS_incr_adds: incremental capacity additions
!    surviving_cap: surviving capacity
!    needed_capacity: needed capacity

! Called from: TECH_STEP
! Calls to: none

      Subroutine Step_Capacity(stepnum,FISYR,baselifecr,lifetime,calib,production)
      use i_
      IMPLICIT NONE


      integer stepnum                                         ! Step number
      integer ii                                              ! Loop counter
      integer FISYR                                           ! First calculated year
      integer baselifecr                                      ! Baseline capacity lifetime (generally 20 years)
      integer calib                                           ! Constant to calibrate shape of survival curve
      real prod_IBYR                                          ! Base-year productive capacity
      real basecap_lag(8:13,maxstep)                            ! Lagged baseline capacity
      real needed_cap(8:13,maxstep,17:MNUMYR)                   ! Needed capacity
      real sumup                                              ! Sum of incremental capacity additions for a year
      real production                                         ! Production by process step (1000 tonnes),2006:MNUMYR
      real surviving(MNUMYR)                                  ! Surviving percentage of added technology
      real lifetime                                           ! Life of added technologies (generally 30 years)
      
    ! initialization block
	 prod_IBYR  = 0.0;        basecap_lag(:,:) =  0.0; needed_cap(:,:,:) = 0.0                   ! Needed capacity
     sumup = 0.0; surviving(:) = 0.0;                                   ! Surviving percentage of added technology
      
		 prod_IBYR = is_production(inddir,stepnum)            !historical production years


         if (inddir.eq.12)    prodcurrpt(stepnum,ibyr2-1989)=prod_IBYR
         if (inddir.eq. 8) pp_prodcurrpt(stepnum,ibyr2-1989)=prod_IBYR
         if (inddir.eq.13) al_prodcurrpt(stepnum,ibyr2-1989)=prod_IBYR
         if (inddir.eq.10) gl_prodcurrpt(stepnum,ibyr2-1989)=prod_IBYR

         if (inddir.eq.12) write(IUNITBUG,'(A,3F12.3,2I6,3I4)') &
                'is_production, PROD_IBYR, prodcurrpt, ibyr2, CURCALYR, ICURIYR2, inddir, stepnum', &
                is_production(inddir,stepnum),PROD_IBYR,prodcurrpt(stepnum,ibyr2-1989), &
                ibyr2,CURCALYR,ICURIYR2,inddir,stepnum

!***** Retirement Function for Added Capacity *****************
      DO ii=0,mnumyr-1
        surviving(ii+1)=1.0/(1.0+exp(-calib-(ii*(-calib)/(lifetime/2.0))))
      ENDDO

      IF (curiyr.lt.FISYR)  then                                           ! Prior to First Calculated Year
        is_basecap(inddir,stepnum) = prod_IBYR
        if ((inddir.eq.8) .or. (inddir.eq.11) .or. (inddir.eq.13)) then
          is_basecap(inddir,stepnum) = IBYR_SurvCap(inddir,stepnum)
        endif

      elseif (curiyr.ge.FISYR) then                                      ! For Each Calculated Year

        if(curitr.eq.1) basecap_lag(inddir,stepnum) = is_basecap(inddir,stepnum)            ! Save result from prior year on first iteration
        is_basecap(inddir,stepnum) = basecap_lag(inddir,stepnum) - (prod_IBYR/baselifecr) ! Baseline capacity is reduced linearly

        if ((inddir.eq.8) .or. (inddir.eq.11) .or. (inddir.eq.13)) then
              is_basecap(inddir,stepnum) =  basecap_lag(inddir,stepnum) - (IBYR_SurvCap(inddir,stepnum)/baselifecr)
        endif
          if (is_basecap(inddir,stepnum).lt.0.0) is_basecap(inddir,stepnum)=0.0                ! Until it is zero
      ENDIF

      if (curiyr.lt.FISYR) then
         is_surviving_cap(inddir)=is_basecap(inddir,stepnum)     !No Added Capacity Prior to First Year
         if (inddir.eq.8) is_surviving_cap(inddir)=IBYR_SurvCap(inddir,stepnum)  !is_basecap(inddir,stepnum)
         if (inddir.eq.11) is_surviving_cap(inddir)=IBYR_SurvCap(inddir,stepnum)  !is_basecap(inddir,stepnum)
      else
        sumup=0.0
        do ii=FISYR,curiyr-1
           IS_incr_adds(inddir,stepnum,ii) = needed_cap(inddir,stepnum,ii) * surviving(curiyr-ii+1)  ! Added Capacity Surviving to Current Year

           sumup = sumup + IS_incr_adds(inddir,stepnum,ii)
        enddo
        is_surviving_cap(inddir)=is_basecap(inddir,stepnum)+sumup  !surviving capacity

      end if

      needed_cap(inddir,stepnum,curiyr)=production-is_surviving_cap(inddir) 
      prod_adjust_fact = 1.0			! Initialize a production adjustment factor **new
      if (needed_cap(inddir,stepnum,curiyr).lt.0.0) then
             needed_cap(inddir,stepnum,curiyr)=0.0  ! Don't need to add more capacity
             prod_adjust_fact = production/is_surviving_cap(inddir)	! This factor should proportionately reduce production    **new
            !  if (prod_adjust_fact.ne.1.0) write(IUNITBUG,*) 'debug new stuff', curiyr+1989,curitr,inddir,stepnum,prod_adjust_fact
      endif
      IS_incr_adds(inddir,stepnum,curiyr) = needed_cap(inddir,stepnum,curiyr)

      ! copy into next steps
      if ((inddir.eq.10).and.(stepnum.eq.2)) then
        IS_incr_adds(inddir,stepnum,curiyr)=IS_incr_adds(inddir,1,curiyr)
        is_basecap(inddir,stepnum)=is_basecap(inddir,1)
      endif
     return
      end

!*********************************************************************************************************************
! logit calculator
! Called from: TECH_STEP
! Calls to: none

      function logit_calc(logit_coeff,tot_cost,lfuel_use,lemiss,co2penalty,alpha_decay,alpha,scale_fac,logit_steam,Obsolete_Yr,stepnum,cement_particulates)
      use i_
      implicit none

      real*16 logit_calc                     ! Logit component for technology
      real logit_coeff(6)                    ! Logit coefficient
      real calibrationc(6)                   ! Coefficients for fixed cost, fuel cost, emissions
      real tot_cost                          ! Total Fixed Cost for Technology
      real lfuel_use(IS_MAXFUEL)             ! Fuel Intensity 1=electricity 2=natural gas 3=hfo 4=coal
      real lemiss                            ! CO2 emissions intensity
      real alpha_decay(2)                    ! Alpha Decay Parameters (Governs reduction of alternative-specific constant)
      real co2penalty                        ! CO2 Emissions Penalty
      real alpha                             ! Alternative-Specific Constant
      real scale_fac                         ! Scale Factor
      real logit_steam                       ! steam factor for paper industry
      real Obsolete_Yr                       ! technology obsolesence year
      integer stepnum
      real OYr                               ! obsolesence switch
      real cement_particulates

      if (inddir.ne.12) co2penalty=1.0  !only iron and steel has CO2 penalty ** add data for all industries so it could be used ??
      do i=1,5
         calibrationc(i) = logit_coeff(i)/(-1000000.0)      ! Transforms Logit Coefficients for Use in Calculation
      enddo
      if (int(Obsolete_Yr) .LE. curcalyr) then
         logit_calc = 1.0E-15
      else
      !   oyr=0.0
    !  endif
         logit_calc =  exp(calibrationc(1) * tot_cost * (1.0 + oyr*99.0)     &
                    +  calibrationc(2) * (lfuel_use(1) * PELIN(MNUMCR,curiyr)*MC_JPGDP(ICURIYR2)+ & ! Electricity; convert to base year dollars
                                          lfuel_use(2) * PGFIN(MNUMCR,curiyr)*MC_JPGDP(ICURIYR2)+ & ! Natural Gas
                                          lfuel_use(3) * PRLIN(MNUMCR,curiyr)*MC_JPGDP(ICURIYR2)+ & ! Residual Fuel Oil
                                          lfuel_use(4) * PCLIN(MNUMCR,curiyr)*MC_JPGDP(ICURIYR2)+ & ! Sub-bit Coal
                                          lfuel_use(5) * PMCIN(MNUMCR,curiyr)*MC_JPGDP(ICURIYR2)) & ! Met coal
                    +  calibrationc(2) * logit_steam   &
                    +  calibrationc(3) * lemiss *  co2penalty   &
                    +  alpha*exp(-alpha_decay(1)*float(curcalyr-ibyr2-1)*ln2/alpha_decay(2)))+scale_fac
		endif

            if (inddir.eq.11) then     ! Cement has different logit coefficients
            
                calibrationc(6) = logit_coeff(6)/(-1000000.0)

				logit_calc =  exp(  calibrationc(1) * tot_cost * (1 + oyr*99.0)     &             ! Fixed costs
                    +  calibrationc(2) * lfuel_use(1) * PELIN(MNUMCR,curiyr)*MC_JPGDP(ICURIYR2) & ! Electricity cost; converted to base year dollars
                    +  calibrationc(3) * cement_particulates   &                                  ! Particulate emissions
                    + alpha*exp(-alpha_decay(1)*float(curcalyr-ibyr2-1)*ln2/alpha_decay(2)))+scale_fac
			  
            endif
        
        if ((inddir.eq.13) .and. (stepnum.ne.5)) then
		      if (int(Obsolete_Yr) .LE. curcalyr) then
				logit_calc = 1.0E-15
    		  else

    			logit_calc =  exp(  calibrationc(1) * tot_cost * (1 + oyr*99.0)     &
                    +  calibrationc(2) * lfuel_use(1) * PELIN(MNUMCR,curiyr)*MC_JPGDP(ICURIYR2) & ! Electricity; convert to base year dollars
                    +  calibrationc(4) * lfuel_use(2) * PGFIN(MNUMCR,curiyr)*MC_JPGDP(ICURIYR2) & ! Natural Gas
                    +  calibrationc(2) * (lfuel_use(3) * PRLIN(MNUMCR,curiyr)*MC_JPGDP(ICURIYR2)+ & ! Residual Fuel Oil
                                          lfuel_use(4) * PCLIN(MNUMCR,curiyr)*MC_JPGDP(ICURIYR2)+ & ! Sub-bit Coal
                                          lfuel_use(5) * PMCIN(MNUMCR,curiyr)*MC_JPGDP(ICURIYR2)) & ! Met coal
                    +  calibrationc(5) * logit_steam   &
                    +  calibrationc(3) * lemiss * co2penalty   &
                    + alpha*exp(-alpha_decay(1)*float(curcalyr-ibyr2-1)*ln2/alpha_decay(2)))+scale_fac
			  endif
        endif

      return
      end function logit_calc
!*********************************************************************************************************************
! technology shares calculator
! Called from: TECH_STEP
! Calls to: none

      subroutine shares_calc(logit_comp,shares,numtech2)
      use i_
      implicit none

      integer*2 numtech2    ! number of technologies (step dependent ie: hot roll has 3 techs, casting 2 techs, ...)
      real*16 logit_comp(maxtech)  ! logits for each technology
      real shares(maxtech)         ! shares for each technology
      real*16 sumlogit             ! sum of the logits for a step
      integer itech                ! loop counter for technologies

      sumlogit=0.0
      do itech=1,numtech2
        sumlogit=sumlogit+logit_comp(itech)
      enddo

      do itech=1,numtech2
        if (sumlogit.ne.0.0) then
            shares(itech) = logit_comp(itech)/sumlogit
        else
            shares(itech) = 0.0
        endif
      enddo
      return
      end subroutine shares_calc


!*********************************************************************************************************************
!  Surviving Added Capacity calculator
! Called from: TECH_STEP
! Calls to: none

      function SurvivingAddedCapacity(stepnum,numtech2,shares)
      use i_
      implicit none

      integer numtech2                 ! number of technologies (step dependent ie: hot roll has 3 techs, casting 2 techs, ...)
      integer stepnum                 !step 1: Hot Roll 3: Continuous Casting 4: BF/BOF  5: EAF 6: DRI
      real survaddcap                 ! surviving added capacity
      real shares(8:13,maxstep,maxtech,MNUMYR)     ! technology shares
      integer k
      real SurvivingAddedCapacity     ! function surviving added capacity


      survaddcap=0.0
      if (curiyr.ge.IS_FISYR(inddir))then
        do k=IS_FISYR(inddir),curiyr
            survaddcap=survaddcap + &
            shares(inddir,stepnum,numtech2,k)*IS_incr_adds(inddir,stepnum,k)
        enddo
      endif
      SurvivingAddedCapacity = survaddcap
      return
      end function SurvivingAddedCapacity


!*************************************************************************************
! This function calculates a scale factor
! Called from: TECH_STEP
! Calls to: none

      function scale_fctr2(logit_coeff,tot_cost,IS_fuel_use2,IS_emiss2,co2penalty,alpha_decay,alpha,logit_steam,Obsolete_Yr,stepnum,cement_particulates)
     use i_
     implicit none

      real*16 scale_fctr2
      real logit_coeff(6), calibrationc(6)  ! Fixed Cost, Fuel Cost, Emissions
      real tot_cost                         ! Total Technology Cost
      real IS_fuel_use2(IS_MAXFUEL)         ! Fuel use 1=Electricity 2=NG 3=HFO 4=Bit.Coal 5=Met.Coal
      real IS_emiss2                        ! CO2 Emissions
      real alpha_decay(2)                   ! Alpha Decay
      real co2penalty                       ! CO2 penalty
      real alpha                            ! Alpha (Alternative-Specific Constant)
      real logit_steam                      ! steam factor
      real Obsolete_Yr                      ! technology obsolesence year
      integer stepnum
      real OYr                              ! obsolesence switch
      real cement_particulates              ! Cement particulate emissions

      if (int(Obsolete_Yr) .LE. curcalyr) then
         oyr=1.0
      else
         oyr=0.0
      endif
      do i=1,5
         calibrationc(i) = logit_coeff(i)/(-1000000.0)
      enddo

      scale_fctr2 = calibrationc(1) * tot_cost     &
                  + calibrationc(2) * (IS_fuel_use2(1) * PELIN(MNUMCR,curiyr)*MC_JPGDP(ICURIYR2)+ &   ! Electricity - Convert to base year dollars
                                       IS_fuel_use2(2) * PGFIN(MNUMCR,curiyr)*MC_JPGDP(ICURIYR2)+ &   ! Natural gas
                                       IS_fuel_use2(3) * PRLIN(MNUMCR,curiyr)*MC_JPGDP(ICURIYR2)+ &   ! Residual fuel oil
                                       IS_fuel_use2(4) * PCLIN(MNUMCR,curiyr)*MC_JPGDP(ICURIYR2)+ &   ! Coal: Sub-Bituminous
                                       IS_fuel_use2(5) * PMCIN(MNUMCR,curiyr)*MC_JPGDP(ICURIYR2)) &   ! Coal: Metallurgical
                  + calibrationc(5) * logit_steam  &
                  + calibrationc(3) * IS_emiss2 * co2penalty       &
                  +alpha*exp(-alpha_decay(1)*float(curcalyr-ibyr2-1)*ln2/alpha_decay(2))

        if (inddir.eq.11) then      ! Cement has different logit coefficients
        
            calibrationc(6) = logit_coeff(6)/(-1000000.0)
        
            scale_fctr2 = calibrationc(1) * tot_cost  &                                                 ! Fixed costs
                     + calibrationc(2) * IS_fuel_use2(1) * PELIN(MNUMCR,curiyr)*MC_JPGDP(ICURIYR2)  &   ! Electricity costs; converted to base year dollars
                     + calibrationc(3) * cement_particulates   &                                        ! Particulate emissions
                     +alpha*exp(-alpha_decay(1)*float(curcalyr-ibyr2-1)*ln2/alpha_decay(2))
        endif
                  
        if ((inddir.eq.13) .and.(stepnum.ne.5))then
            scale_fctr2 = calibrationc(1) * tot_cost  &
                     + calibrationc(2) * IS_fuel_use2(1) * PELIN(MNUMCR,curiyr)*MC_JPGDP(ICURIYR2)  & ! Electricity; convert to base year dollars
                     + calibrationc(4) * IS_fuel_use2(2) * PGFIN(MNUMCR,curiyr)*MC_JPGDP(ICURIYR2)  & ! Natural gas
                     + calibrationc(2) *(IS_fuel_use2(3) * PRLIN(MNUMCR,curiyr)*MC_JPGDP(ICURIYR2)  & ! Residual fuel oil
                     +                   IS_fuel_use2(4) * PCLIN(MNUMCR,curiyr)*MC_JPGDP(ICURIYR2)  & ! Sub-bit coal
                     +                   IS_fuel_use2(5) * PMCIN(MNUMCR,curiyr)*MC_JPGDP(ICURIYR2)) & ! Met coal
                     + calibrationc(5) * logit_steam   &
                     + calibrationc(3) * IS_emiss2 *  co2penalty   &
                     +alpha*exp(-alpha_decay(1)*float(curcalyr-ibyr2-1)*ln2/alpha_decay(2))
        endif

       return
       end

!***********************************************************
! linear interpolation function
! solves for y2 given x1, x2, x3, y1 and y3
! Called from: IS_ContCastNoTech, IS_HotRollNoTech, IS_STEAM
! Calls: none

      function q_interp2(x1,x3,y1,y3,x2)
      implicit none

      real x1,x2,x3,y1,y2,y3,q_interp2

      y2 = ((x2 - x1) * (y3 - y1) / ( x3 - x1 )) + y1
      q_interp2 = y2

      return
      end

!*******************************************************************************************************
! data inputs for iron and steel and paper industry
! Called from:
! Calls: none

      subroutine IS_GETDATA
      use i_
      implicit none

      CHARACTER*30 WNAME
	  INTEGER WKUNIT,iret,inumind
	  character*16 rangen
      character*16 cm_rangen(4)
	  character*2 strij, strkk
	  integer ij,kk
      integer technum

!***** Steel Step 6: DRI/BOF Data **********************
      MinBOF= 0.10

!***** Steel Step 7: DRI EAF Data *************************************
      MaxEAF= 1.0

	  FNAME='IRONSTLX'
      NEW=.FALSE.
      WKUNIT=FILE_MGR('O',FNAME,NEW)
	  CALL ReadRngXLSX(WKUNIT,'steel')   !read range names & coerresponding data

	  ! IRON and STEEL INPUTS
	  inumind=12

      CALL GETRNGR('steam_adj       ',IS_steam_adj,1,1,1)
      CALL GETRNGI4('numtech         ',IS_NUMTECH(inumind,1:IS_MAXSTPS),IS_MAXSTPS,1,1)                 ! row, col, group
      CALL GETRNGI('NUMFUEL         ',IS_NUMFUEL(inumind,1:IS_MAXSTPS),IS_MAXSTPS,1,1)
      CALL GETRNGI4('BASELIFECR      ',IS_BASELIFECR(inumind),1,1,1)
	  CALL GETRNGR('LIFETIME        ',IS_LIFETIME(inumind),1,1,1)
      CALL GETRNGI4('CALIB           ',IS_CALIB(inumind),1,1,1)
	  CALL GETRNGR('WACC            ',IS_WACC(inumind),1,1,1)
	  CALL GETRNGI('FISYR           ',IS_FISYR(inumind),1,1,1)
	  CALL GETRNGR('ADECAY          ',IS_ALPHA_DECAY(inumind,:),2,1,1)
	  CALL GETRNGR('BaseCold        ',Base_Cold,1,4,1)
      CALL GETRNGR('BASEEAF         ',Base_EAF,1,4,1)
	  CALL GETRNGR('BASEBOF         ',Base_BOF,1,4,1)
      CALL GETRNGR('BASECOKE        ',Base_Coke,1,4,1)
      CALL GETRNGR('IS_MAXDELTA     ',is_max_delta,1,4,1)
      CALL GETRNGR('IS_ALPHA_FURNACE',is_alpha_furnace,1,4,1)
	  CALL GETRNGR('CO2PEN          ',IS_CO2PENALTY(inumind,:),41,1,1)    ! POT_2050 already to 2050 no change
	  CALL GETRNGR('DRI_Tot_Phase1  ',DRI_Tot_Phase1,1,4,1)
      CALL GETRNGR('DRI_Tot_Phase2  ',DRI_Tot_Phase2,1,4,1)
      CALL GETRNGI('Phase1_YR       ',Phase1_YR,1,4,1)
      CALL GETRNGI('Phase2_YR       ',Phase2_YR,1,4,1)
      CALL GETRNGR('IS_LOGIT_COEFF1 ',IS_LOGIT_COEFF(inumind,1:3,1),3,1,1)
	  CALL GETRNGR('IS_LOGIT_COEFF2 ',IS_LOGIT_COEFF(inumind,1:3,3:8),3,6,1)
	  CALL GETRNGR('SLABTECH11      ',SLABTECH1(1),1,1,1)
      CALL GETRNGR('SLABTECH21      ',SLABTECH2(1),1,1,1)
      CALL GETRNGR('SLABTECH12      ',SLABTECH1(2),1,1,1)
      CALL GETRNGR('SLABTECH22      ',SLABTECH2(2),1,1,1)
      CALL GETRNGR('SLABSKIN        ',SLABSKIN,1,2,1)
      CALL GETRNGR('BASETECHSHR1    ',IS_BASE_TECH_SHARE(inumind,1,1:IS_NUMTECH(inumind,1)),1,IS_NUMTECH(inumind,1),1)  
	  CALL GETRNGR('BASETECHSHR3    ',IS_BASE_TECH_SHARE(inumind,3,1:IS_NUMTECH(inumind,3)),1,IS_NUMTECH(inumind,3),1)
	  CALL GETRNGR('BASETECHSHR4    ',IS_BASE_TECH_SHARE(inumind,4,1:IS_NUMTECH(inumind,4)),1,IS_NUMTECH(inumind,4),1)
	  CALL GETRNGR('BASETECHSHR5    ',IS_BASE_TECH_SHARE(inumind,5,1:IS_NUMTECH(inumind,5)),1,IS_NUMTECH(inumind,5),1)
	  CALL GETRNGR('BASETECHSHR6    ',IS_BASE_TECH_SHARE(inumind,6,1:IS_NUMTECH(inumind,6)),1,IS_NUMTECH(inumind,6),1)
	  CALL GETRNGR('BASETECHSHR7    ',IS_BASE_TECH_SHARE(inumind,7,1:IS_NUMTECH(inumind,7)),1,IS_NUMTECH(inumind,7),1)
      CALL GETRNGR('ADDTECHSHR1     ',IS_ADD_TECH_SHARE(inumind,1,1:IS_NUMTECH(inumind,1)),1,IS_NUMTECH(inumind,1),1)
	  CALL GETRNGR('ADDTECHSHR3     ',IS_ADD_TECH_SHARE(inumind,3,1:IS_NUMTECH(inumind,3)),1,IS_NUMTECH(inumind,3),1)
	  CALL GETRNGR('ADDTECHSHR4     ',IS_ADD_TECH_SHARE(inumind,4,1:IS_NUMTECH(inumind,4)),1,IS_NUMTECH(inumind,4),1)
	  CALL GETRNGR('ADDTECHSHR5     ',IS_ADD_TECH_SHARE(inumind,5,1:IS_NUMTECH(inumind,5)),1,IS_NUMTECH(inumind,5),1)
	  CALL GETRNGR('ADDTECHSHR6     ',IS_ADD_TECH_SHARE(inumind,6,1:IS_NUMTECH(inumind,6)),1,IS_NUMTECH(inumind,6),1)
	  CALL GETRNGR('ADDTECHSHR7     ',IS_ADD_TECH_SHARE(inumind,7,1:IS_NUMTECH(inumind,7)),1,IS_NUMTECH(inumind,7),1)
      CALL GETRNGR('IS_CAPCOST1     ',IS_CAPCOST(inumind,1,1:IS_NUMTECH(inumind,1)),1,IS_NUMTECH(inumind,1),1)
	  CALL GETRNGR('IS_CAPCOST3     ',IS_CAPCOST(inumind,3,1:IS_NUMTECH(inumind,3)),1,IS_NUMTECH(inumind,3),1)
	  CALL GETRNGR('IS_CAPCOST4     ',IS_CAPCOST(inumind,4,1:IS_NUMTECH(inumind,4)),1,IS_NUMTECH(inumind,4),1)
	  CALL GETRNGR('IS_CAPCOST5     ',IS_CAPCOST(inumind,5,1:IS_NUMTECH(inumind,5)),1,IS_NUMTECH(inumind,5),1)
	  CALL GETRNGR('IS_CAPCOST6     ',IS_CAPCOST(inumind,6,1:IS_NUMTECH(inumind,6)),1,IS_NUMTECH(inumind,6),1)
	  CALL GETRNGR('IS_CAPCOST7     ',IS_CAPCOST(inumind,7,1:IS_NUMTECH(inumind,7)),1,IS_NUMTECH(inumind,7),1)
       CALL GETRNGR('IS_CAPCOST8     ',IS_CAPCOST(inumind,8,1:2),1,2,1) !new
      CALL GETRNGR('avom1           ',IS_AV_OM(inumind,1,1:IS_NUMTECH(inumind,1)),1,IS_NUMTECH(inumind,1),1)  
      CALL GETRNGR('avom3           ',IS_AV_OM(inumind,3,1:IS_NUMTECH(inumind,3)),1,IS_NUMTECH(inumind,3),1)
      CALL GETRNGR('avom4           ',IS_AV_OM(inumind,4,1:IS_NUMTECH(inumind,4)),1,IS_NUMTECH(inumind,4),1)
      CALL GETRNGR('avom5           ',IS_AV_OM(inumind,5,1:IS_NUMTECH(inumind,5)),1,IS_NUMTECH(inumind,5),1)
      CALL GETRNGR('avom6           ',IS_AV_OM(inumind,6,1:IS_NUMTECH(inumind,6)),1,IS_NUMTECH(inumind,6),1)
      CALL GETRNGR('avom7           ',IS_AV_OM(inumind,7,1:IS_NUMTECH(inumind,7)),1,IS_NUMTECH(inumind,7),1)
      CALL GETRNGR('avom8           ',IS_AV_OM(inumind,8,1:2),1,2,1)  !new
      CALL GETRNGR('IS_FUEL_USE1    ',IS_FUEL_USE(inumind,1,1:5,1:IS_NUMTECH(inumind,1)),5,IS_NUMTECH(inumind,1),1)
      CALL GETRNGR('IS_FUEL_USE3    ',IS_FUEL_USE(inumind,3,1:5,1:IS_NUMTECH(inumind,3)),5,IS_NUMTECH(inumind,3),1)
      CALL GETRNGR('IS_FUEL_USE4    ',IS_FUEL_USE(inumind,4,1:5,1:IS_NUMTECH(inumind,4)),5,IS_NUMTECH(inumind,4),1)
      CALL GETRNGR('IS_FUEL_USE5    ',IS_FUEL_USE(inumind,5,1:5,1:IS_NUMTECH(inumind,5)),5,IS_NUMTECH(inumind,5),1)
      CALL GETRNGR('IS_FUEL_USE6    ',IS_FUEL_USE(inumind,6,1:5,1:IS_NUMTECH(inumind,6)),5,IS_NUMTECH(inumind,6),1)
      CALL GETRNGR('IS_FUEL_USE7    ',IS_FUEL_USE(inumind,7,1:5,1:IS_NUMTECH(inumind,7)),5,IS_NUMTECH(inumind,7),1)
      CALL GETRNGR('IS_FUEL_USE8    ',IS_FUEL_USE(inumind,8,1:5,1:2),5,2,1) !new
      CALL GETRNGR('IS_NFUEL_USE1   ',IS_NFUEL_USE(inumind,1,1:2,1:IS_NUMTECH(inumind,1)),2,IS_NUMTECH(inumind,1),1)
      CALL GETRNGR('IS_NFUEL_USE3   ',IS_NFUEL_USE(inumind,3,1:2,1:IS_NUMTECH(inumind,3)),2,IS_NUMTECH(inumind,3),1)
      CALL GETRNGR('IS_NFUEL_USE4   ',IS_NFUEL_USE(inumind,4,1:2,1:IS_NUMTECH(inumind,4)),2,IS_NUMTECH(inumind,4),1)
      CALL GETRNGR('IS_NFUEL_USE5   ',IS_NFUEL_USE(inumind,5,1:2,1:IS_NUMTECH(inumind,5)),2,IS_NUMTECH(inumind,5),1)
      CALL GETRNGR('IS_NFUEL_USE6   ',IS_NFUEL_USE(inumind,6,1:2,1:IS_NUMTECH(inumind,6)),2,IS_NUMTECH(inumind,6),1)
      CALL GETRNGR('IS_NFUEL_USE7   ',IS_NFUEL_USE(inumind,7,1:2,1:IS_NUMTECH(inumind,7)),2,IS_NUMTECH(inumind,7),1)
      CALL GETRNGR('IS_NFUEL_USE8   ',IS_NFUEL_USE(inumind,8,1:2,1:2),2,2,1)  !new
      do ij=1,7
         IS_NFUEL_USE(inumind,ij,2,1:8)=IS_NFUEL_USE(inumind,ij,2,1:8)*is_steam_adj  !SIMS Steam adjustment
      enddo
      CALL GETRNGR('is_obyr1        ',obsoleteyr(inumind,1,1:IS_NUMTECH(inumind,1)),1,IS_NUMTECH(inumind,1),1)
      CALL GETRNGR('is_obyr3        ',obsoleteyr(inumind,3,1:IS_NUMTECH(inumind,3)),1,IS_NUMTECH(inumind,3),1)
      CALL GETRNGR('is_obyr4        ',obsoleteyr(inumind,4,1:IS_NUMTECH(inumind,4)),1,IS_NUMTECH(inumind,4),1)
      CALL GETRNGR('is_obyr5        ',obsoleteyr(inumind,5,1:IS_NUMTECH(inumind,5)),1,IS_NUMTECH(inumind,5),1)
      CALL GETRNGR('is_obyr6        ',obsoleteyr(inumind,6,1:IS_NUMTECH(inumind,6)),1,IS_NUMTECH(inumind,6),1)
      CALL GETRNGR('is_obyr7        ',obsoleteyr(inumind,7,1:IS_NUMTECH(inumind,7)),1,IS_NUMTECH(inumind,7),1)
      CALL GETRNGR('is_obyr8        ',obsoleteyr(inumind,8,1:2),1,2,1)  !new
      CALL GETRNGR('IS_EMISS1       ',IS_EMISS(inumind,1,1:IS_NUMTECH(inumind,1)),1,IS_NUMTECH(inumind,1),1)
      CALL GETRNGR('IS_EMISS3       ',IS_EMISS(inumind,3,1:IS_NUMTECH(inumind,3)),1,IS_NUMTECH(inumind,3),1)
      CALL GETRNGR('IS_EMISS4       ',IS_EMISS(inumind,4,1:IS_NUMTECH(inumind,4)),1,IS_NUMTECH(inumind,4),1)
      CALL GETRNGR('IS_EMISS5       ',IS_EMISS(inumind,5,1:IS_NUMTECH(inumind,5)),1,IS_NUMTECH(inumind,5),1)
      CALL GETRNGR('IS_EMISS6       ',IS_EMISS(inumind,6,1:IS_NUMTECH(inumind,6)),1,IS_NUMTECH(inumind,6),1)
      CALL GETRNGR('IS_EMISS7       ',IS_EMISS(inumind,7,1:IS_NUMTECH(inumind,7)),1,IS_NUMTECH(inumind,7),1)
      CALL GETRNGR('IS_EMISS8       ',IS_EMISS(inumind,8,1:2),1,2,1)  !new
      CALL GETRNGR('IS_ALPHA1       ',IS_ALPHA(inumind,1,1:IS_NUMTECH(inumind,1)),1,IS_NUMTECH(inumind,1),1)
      CALL GETRNGR('IS_ALPHA3       ',IS_ALPHA(inumind,3,1:IS_NUMTECH(inumind,3)),1,IS_NUMTECH(inumind,3),1)
      CALL GETRNGR('IS_ALPHA4       ',IS_ALPHA(inumind,4,1:IS_NUMTECH(inumind,4)),1,IS_NUMTECH(inumind,4),1)
      CALL GETRNGR('IS_ALPHA5       ',IS_ALPHA(inumind,5,1:IS_NUMTECH(inumind,5)),1,IS_NUMTECH(inumind,5),1)
      CALL GETRNGR('IS_ALPHA6       ',IS_ALPHA(inumind,6,1:IS_NUMTECH(inumind,6)),1,IS_NUMTECH(inumind,6),1)
      CALL GETRNGR('IS_ALPHA7       ',IS_ALPHA(inumind,7,1:IS_NUMTECH(inumind,7)),1,IS_NUMTECH(inumind,7),1)
      CALL GETRNGR('IS_ALPHA8       ',IS_ALPHA(inumind,8,1:2),1,2,1)  !new bof/eaf shift
      CALL GETRNGR('IS_REI1         ',IS_REI(inumind,1,1:IS_NUMTECH(inumind,1)),1,IS_NUMTECH(inumind,1),1)
      CALL GETRNGR('IS_REI3         ',IS_REI(inumind,3,1:IS_NUMTECH(inumind,3)),1,IS_NUMTECH(inumind,3),1)
      CALL GETRNGR('IS_REI4         ',IS_REI(inumind,4,1:IS_NUMTECH(inumind,4)),1,IS_NUMTECH(inumind,4),1)
      CALL GETRNGR('IS_REI5         ',IS_REI(inumind,5,1:IS_NUMTECH(inumind,5)),1,IS_NUMTECH(inumind,5),1)
      CALL GETRNGR('IS_REI6         ',IS_REI(inumind,6,1:IS_NUMTECH(inumind,6)),1,IS_NUMTECH(inumind,6),1)
      CALL GETRNGR('IS_REI7         ',IS_REI(inumind,7,1:IS_NUMTECH(inumind,7)),1,IS_NUMTECH(inumind,7),1)
      CALL GETRNGR('IS_REI8         ',IS_REI(inumind,8,1:2),1,2,1)  !new bof/eaf shift
      CALL GETRNGR('INTENSITY       ',INTENSITY,6,3,1)
      CALL GETRNGR('CO2_INTENSITY   ',CO2_INTENSITY,6,2,1)
      CALL GETRNGR('SHARES          ',ISCR_SHARES(2:6),5,1,1)
      CALL GETRNGR('NG_SHARE        ',NG_SHARE,1,1,1)
      CALL GETRNGR('HFO_SHARE       ',HFO_SHARE,1,1,1)
      CALL GETRNGR('FORMSHARES      ',FORMSHARES,3,1,1)
      CALL GETRNGR('CC_SHRSTART     ',cc_SHRSTART(1:2),1,2,1)
      CALL GETRNGR('CC_SHRFINAL     ',cc_SHRFINAL(1:2),1,2,1)
      CALL GETRNGR('CC_NGAS         ',cc_ngas(1:4),1,4,1)
      CALL GETRNGR('CC_OIL          ',cc_oil(1:4),1,4,1)
      CALL GETRNGR('SHRSTART        ',SHRSTART,1,12,1)
      CALL GETRNGR('SHRFINAL        ',SHRFINAL,1,12,1)
      CALL GETRNGR('BLOOMTUBES      ',BLOOMTUBES,4,1,1)
      CALL GETRNGR('BLOOMSTRUCT     ',BLOOMSTRUCT,4,1,1)
      CALL GETRNGR('BILLBAR         ',BILLBAR,4,1,1)
      CALL GETRNGR('BILLROD         ',BILLROD,4,1,1)
      CALL GETRNGR('BILLSHAPE       ',BILLSHAPE,4,1,1)
      CALL GETRNGR('BOIL_INTENSITY  ',BOIL_INTENSITY,5,5,1)
      CALL GETRNGR('CHP_INTENSITY   ',CHP_INTENSITY,5,4,1)
      CALL GETRNGR('IS_CPROCESS     ',IS_CPROCESS,1,4,1)
      CALL GETRNGR('IS_CEnergy_Use  ',IS_CEnergy_Use,1,7,1) !coke production energy use
      IS_CEnergy_Use(4)=IS_CEnergy_Use(4)*is_steam_adj  !SIMS Steam adjustment

      CALL GETRNGR('B_YEAR          ',B_YEAR,2,1,1)
      CALL GETRNGR('B_SHR           ',B_SHR,2,1,1)
      CALL GETRNGR('B_T_YEAR        ',B_T_YEAR,2,1,1)
      CALL GETRNGR('B_T_Start       ',B_T_Start,1,5,1)
      CALL GETRNGR('B_T_Final       ',B_T_Final,1,5,1)
      CALL GETRNGR('C_T_YEAR        ',C_T_YEAR,2,1,1)
      CALL GETRNGR('C_T_Start       ',C_T_Start,1,4,1)
      CALL GETRNGR('C_T_Final       ',C_T_Final,1,4,1)
      CALL GETRNGR('ISPROD          ',is_production(inumind,1:IS_MAXSTPS),IS_MAXSTPS,1,1)
      CALL GETRNGR('ibyrVALS        ',is_ibyrvals,5,5,1)
      CALL GETRNGR('ST_capfacavg    ',is_CapFacAvg(1:3),1,3,1) !Capacity Factor Weighted Average
      CALL GETRNGR('ST_bldchpshr    ',is_BldCHPShr,1,1,1) !building CHP share
      CALL GETRNGR('St_MECS         ',MECS_Data(inumind,1:5,1:9),5,9,1)                 ! row, col, group

! PAPER INPUTS
      CALL ReadRngXLSX(WKUNIT,'paper')   !read range names & coerresponding data

inumind=8
      CALL GETRNGI4('pnumtech        ',IS_NUMTECH(inumind,1:PP_MAXSTPS),PP_MAXSTPS,1,1)                 ! row, col, group
      CALL GETRNGI('pNUMFUEL        ',IS_NUMFUEL(inumind,1:PP_MAXSTPS),PP_MAXSTPS,1,1)
      CALL GETRNGR('PPROD           ',is_production(inumind,1:PP_MAXSTPS),PP_MAXSTPS,1,1)
      CALL GETRNGR('ibyrsurvcap     ',ibyr_survcap(inumind,1:PP_MAXSTPS),PP_MAXSTPS,1,1)
      CALL GETRNGI4('pBASELIFECR     ',IS_BASELIFECR(inumind),1,1,1)
      CALL GETRNGR('pLIFETIME       ',IS_LIFETIME(inumind),1,1,1)
      CALL GETRNGI4('pCALIB          ',IS_CALIB(inumind),1,1,1)
      CALL GETRNGR('pWACC           ',IS_WACC(inumind),1,1,1)
      CALL GETRNGI('pFISYR          ',IS_FISYR(inumind),1,1,1)
      CALL GETRNGR('pADECAY         ',IS_ALPHA_DECAY(inumind,:),2,1,1)
      CALL GETRNGR('P_LOGIT_COEFF2  ',IS_LOGIT_COEFF(inumind,1:3,1:PP_MAXSTPS),3,PP_MAXSTPS,1)
      CALL GETRNGR('pp_chip         ',PP_CHIP,1,1,1)
      CALL GETRNGR('PP_STM_RYCL     ',PP_STM_RYCL,1,1,1)
      

      do ij=1,PP_MAXSTPS
        write(strij,'(I2)') ij
		strij=adjustl(strij)
		rangen='pBASETECHSHR'//strij//'  '
		CALL GETRNGR(rangen,IS_BASE_TECH_SHARE(inumind,ij,1:IS_NUMTECH(inumind,ij)),1,IS_NUMTECH(inumind,ij),1)
		rangen='pADDTECHSHR'//strij//'   '
		CALL GETRNGR(rangen,IS_ADD_TECH_SHARE(inumind,ij,1:IS_NUMTECH(inumind,ij)),1,IS_NUMTECH(inumind,ij),1)
		rangen='P_CAPCOST'//strij//'     '
		CALL GETRNGR(rangen,IS_CAPCOST(inumind,ij,1:IS_NUMTECH(inumind,ij)),1,IS_NUMTECH(inumind,ij),1)
		rangen='pavom'//strij//'         '
		CALL GETRNGR(rangen,IS_AV_OM(inumind,ij,1:IS_NUMTECH(inumind,ij)),1,IS_NUMTECH(inumind,ij),1)
		rangen='p_FUEL_USE'//strij//'    '
		CALL GETRNGR(rangen,IS_FUEL_USE(inumind,ij,1:5,1:IS_NUMTECH(inumind,ij)),5,IS_NUMTECH(inumind,ij),1)
		rangen='p_NFUEL_USE'//strij//'   '
		CALL GETRNGR(rangen,IS_NFUEL_USE(inumind,ij,1:2,1:IS_NUMTECH(inumind,ij)),2,IS_NUMTECH(inumind,ij),1)
        rangen='p_obyr'//strij//'       '
		CALL GETRNGR(rangen,obsoleteyr(inumind,ij,1:IS_NUMTECH(inumind,ij)),1,IS_NUMTECH(inumind,ij),1)
        rangen='p_emiss'//strij//'       '
		CALL GETRNGR(rangen,IS_EMISS(inumind,ij,1:IS_NUMTECH(inumind,ij)),1,IS_NUMTECH(inumind,ij),1)
    	rangen='ppblkliq'//strij//'      '
		CALL GETRNGR(rangen,PP_BLKLIQ(ij,1:IS_NUMTECH(inumind,ij)),1,IS_NUMTECH(inumind,ij),1)
		rangen='p_alpha'//strij//'    '
		CALL GETRNGR(rangen,is_alpha(inumind,ij,1:IS_NUMTECH(inumind,ij)),1,IS_NUMTECH(inumind,ij),1)
        rangen='pp_rei'//strij//'     '
		CALL GETRNGR(rangen,is_rei(inumind,ij,1:IS_NUMTECH(inumind,ij)),1,IS_NUMTECH(inumind,ij),1)
		rangen='ppsteam'//strij//'       '
		CALL GETRNGR(rangen,PP_Steam(ij,1:IS_NUMTECH(inumind,ij)),1,IS_NUMTECH(inumind,ij),1)
		rangen='pphog'//strij//'       '
		if (ij.eq.25) CALL GETRNGR(rangen,PP_Hog(ij,1:IS_NUMTECH(inumind,ij)),1,IS_NUMTECH(inumind,ij),1)
	  enddo
      CALL GETRNGR('pp_proxydat     ',pp_proxydat(17:61),1,45,1)	!temp paper proxy data  POT_2050CHG change when change input file 51 to 61 35 to 45
      CALL GETRNGR('mech_share2     ',mech_share(17:24),1,8,1)	!mechanical share for splitting therm+mech prodcur years 2006-2013
      CALL GETRNGR('paper_share     ',paper_share(1:5,17:24),5,8,1)	!shares to split prodcur among paper types years 2006-2013
      CALL GETRNGR('pp_stmfuel_chp  ',pp_stmfuel_chp(1:9,1:5),9,5,1) !chp fuel use for paper steam
      CALL GETRNGR('pp_stmfuel_bl   ',pp_stmfuel_bl(1:4,1:5),4,5,1) !boiler fuel use for paper steam
      CALL GETRNGR('ppst_shrstart   ',ppst_shrstart(1:17,1:2),17,2,1) !starting shares for paper steam
      CALL GETRNGR('ppst_shrfinal   ',ppst_shrfinal(1:17,1:2),17,2,1) !final shares for paper steam
      CALL GETRNGR('pp_BioBoilEff   ',pp_BioBoilEff,1,1,1) !IDM Boiler Efficency (Biomass)
      CALL GETRNGR('hog_pulp        ',hog_pulp,1,1,1) !Tons Wood/Ton of Pulp
      CALL GETRNGR('hog_heat        ',hog_heat,1,1,1) !HOG Net Heat Content
      CALL GETRNGR('hog_waste       ',hog_waste,1,1,1) !% of waste to hog fuel
      CALL GETRNGR('capfacavg       ',CapFacAvg(1:2,1:4),2,4,1) !Capacity Factor Weighted Average
      CALL GETRNGR('bldchpshr       ',BldCHPShr,1,1,1) !building CHP share
      CALL GETRNGR('pp_ibyrVALS     ',pp_ibyrvals,5,5,1)
      CALL GETRNGR('pp_hfoshr       ',pp_hfoshr,4,1,1) !resid,pet coke,dist,other
        ! TD add MECS reads
      CALL GETRNGR('Pa_MECS         ',MECS_Data(inumind,1:5,1:9),5,9,1)                 ! row, col, group
      

      ! Aluminum INPUTS
      CALL ReadRngXLSX(WKUNIT,'Aluminum')   !read range names & coerresponding data

      inumind=13
      CALL GETRNGI4('anumtech        ',IS_NUMTECH(inumind,1:AL_MAXSTPS),AL_MAXSTPS,1,1)                 ! row, col, group
	  CALL GETRNGI('aNUMFUEL        ',IS_NUMFUEL(inumind,1:AL_MAXSTPS),AL_MAXSTPS,1,1)
	  CALL GETRNGR('aPROD           ',is_production(inumind,1:AL_MAXSTPS),AL_MAXSTPS,1,1)
      CALL GETRNGR('abyrsurvcap     ',ibyr_survcap(inumind,1:AL_MAXSTPS),AL_MAXSTPS,1,1)
      CALL GETRNGR('al_imp_perc     ',alumina_percent,1,41,1)

      CALL GETRNGI4('aBASELIFECR     ',IS_BASELIFECR(inumind),1,1,1)
	  CALL GETRNGR('aLIFETIME       ',IS_LIFETIME(inumind),1,1,1)
      CALL GETRNGI4('aCALIB          ',IS_CALIB(inumind),1,1,1)
	  CALL GETRNGR('aWACC           ',IS_WACC(inumind),1,1,1)
	  CALL GETRNGI('aFISYR          ',IS_FISYR(inumind),1,1,1)
      CALL GETRNGR('anon_met        ',AL_NON_MET,1,1,1)
      CALL GETRNGR('amass_loss      ',AL_MASS_LOSS,1,1,1)
      CALL GETRNGR('aADECAY1        ',AL_ALPHA_DECAY(1,:,:),4,2,1)
      CALL GETRNGR('aADECAY3        ',AL_ALPHA_DECAY(3,:,:),4,2,1)
      CALL GETRNGR('aADECAY4        ',AL_ALPHA_DECAY(4,:,:),4,2,1)
      CALL GETRNGR('aADECAY5        ',AL_ALPHA_DECAY(5,:,:),4,2,1)
      CALL GETRNGR('AL_LOGIT_COEFF1 ',IS_LOGIT_COEFF(inumind,1:5,1),5,1,1)
	  CALL GETRNGR('AL_LOGIT_COEFF3 ',IS_LOGIT_COEFF(inumind,1:5,3),5,1,1)
      CALL GETRNGR('AL_LOGIT_COEFF4 ',IS_LOGIT_COEFF(inumind,1:5,4),5,1,1)
	  CALL GETRNGR('AL_LOGIT_COEFF5 ',IS_LOGIT_COEFF(inumind,1:5,5),5,1,1)
      CALL GETRNGR('ABASETECHSHR1   ',IS_BASE_TECH_SHARE(inumind,1,1:IS_NUMTECH(inumind,1)+2),1,IS_NUMTECH(inumind,1)+2,1) 
      
	!  CALL GETRNGR('ABASETECHSHR3   ',IS_BASE_TECH_SHARE(inumind,3,1:IS_NUMTECH(inumind,3)),1,IS_NUMTECH(inumind,3),1)
      CALL GETRNGR('ABASETECHSHR3   ',IS_BASE_TECH_SHARE(inumind,3,1:3),1,3,1)
	  CALL GETRNGR('ABASETECHSHR4   ',IS_BASE_TECH_SHARE(inumind,4,1:IS_NUMTECH(inumind,4)),1,IS_NUMTECH(inumind,4),1)
	  CALL GETRNGR('ABASETECHSHR5   ',IS_BASE_TECH_SHARE(inumind,5,1:IS_NUMTECH(inumind,5)),1,IS_NUMTECH(inumind,5),1)

      CALL GETRNGR('aADDTECHSHR1    ',IS_ADD_TECH_SHARE(inumind,1,1:IS_NUMTECH(inumind,1)),1,IS_NUMTECH(inumind,1),1) 
	  CALL GETRNGR('aADDTECHSHR3    ',IS_ADD_TECH_SHARE(inumind,3,1:IS_NUMTECH(inumind,3)),1,IS_NUMTECH(inumind,3),1)
	  CALL GETRNGR('aADDTECHSHR4    ',IS_ADD_TECH_SHARE(inumind,4,1:IS_NUMTECH(inumind,4)),1,IS_NUMTECH(inumind,4),1)
	  CALL GETRNGR('aADDTECHSHR5    ',IS_ADD_TECH_SHARE(inumind,5,1:IS_NUMTECH(inumind,5)),1,IS_NUMTECH(inumind,5),1)

      CALL GETRNGR('a_capcost1      ',IS_CAPCOST(inumind,1,1:IS_NUMTECH(inumind,1)),1,IS_NUMTECH(inumind,1),1) 
	  CALL GETRNGR('a_CAPCOST3      ',IS_CAPCOST(inumind,3,1:IS_NUMTECH(inumind,3)),1,IS_NUMTECH(inumind,3),1)
	  CALL GETRNGR('a_CAPCOST4      ',IS_CAPCOST(inumind,4,1:IS_NUMTECH(inumind,4)),1,IS_NUMTECH(inumind,4),1)
	  CALL GETRNGR('a_CAPCOST5      ',IS_CAPCOST(inumind,5,1:IS_NUMTECH(inumind,5)),1,IS_NUMTECH(inumind,5),1)

      CALL GETRNGR('aavom1          ',IS_AV_OM(inumind,1,1:IS_NUMTECH(inumind,1)),1,IS_NUMTECH(inumind,1),1) 
	  CALL GETRNGR('aavom3          ',IS_AV_OM(inumind,3,1:IS_NUMTECH(inumind,3)),1,IS_NUMTECH(inumind,3),1)
	  CALL GETRNGR('aavom4          ',IS_AV_OM(inumind,4,1:IS_NUMTECH(inumind,4)),1,IS_NUMTECH(inumind,4),1)
	  CALL GETRNGR('aavom5          ',IS_AV_OM(inumind,5,1:IS_NUMTECH(inumind,5)),1,IS_NUMTECH(inumind,5),1)

      CALL GETRNGR('a_FUEL_USE1     ',IS_FUEL_USE(inumind,1,1:5,1:IS_NUMTECH(inumind,1)+2),5,IS_NUMTECH(inumind,1)+2,1)
      CALL GETRNGR('a_FUEL_USE2     ',IS_FUEL_USE(inumind,2,1:3,1:4),3,4,1) !find paramters TD
      CALL GETRNGR('a_FUEL_USE2a    ',IS_FUEL_USE(inumind,2,6:7,1:4),2,4,1) !Pet Coke, Pet Pitch (find parameters - td)
	  CALL GETRNGR('a_FUEL_USE3     ',IS_FUEL_USE(inumind,3,1:5,1:IS_NUMTECH(inumind,3)),5,IS_NUMTECH(inumind,3),1)
	  CALL GETRNGR('a_FUEL_USE4     ',IS_FUEL_USE(inumind,4,1:5,1:IS_NUMTECH(inumind,4)),5,IS_NUMTECH(inumind,4),1)
	  CALL GETRNGR('a_FUEL_USE5     ',IS_FUEL_USE(inumind,5,1:5,1:IS_NUMTECH(inumind,5)),5,IS_NUMTECH(inumind,5),1)

      CALL GETRNGR('a_NFUEL_USE1    ',IS_NFUEL_USE(inumind,1,1:2,1:IS_NUMTECH(inumind,1)),2,IS_NUMTECH(inumind,1),1)
	  CALL GETRNGR('a_NFUEL_USE3    ',IS_NFUEL_USE(inumind,3,1:2,1:IS_NUMTECH(inumind,3)),2,IS_NUMTECH(inumind,3),1)
	  CALL GETRNGR('a_NFUEL_USE4    ',IS_NFUEL_USE(inumind,4,1:2,1:IS_NUMTECH(inumind,4)),2,IS_NUMTECH(inumind,4),1)
	  CALL GETRNGR('a_NFUEL_USE5    ',IS_NFUEL_USE(inumind,5,1:2,1:IS_NUMTECH(inumind,5)),2,IS_NUMTECH(inumind,5),1)

	  CALL GETRNGR('a_obsyr1        ',obsoleteyr(inumind,1,1:IS_NUMTECH(inumind,1)),1,IS_NUMTECH(inumind,1),1)
	  CALL GETRNGR('a_obsyr3        ',obsoleteyr(inumind,3,1:IS_NUMTECH(inumind,3)),1,IS_NUMTECH(inumind,3),1)
	  CALL GETRNGR('a_obsyr4        ',obsoleteyr(inumind,4,1:IS_NUMTECH(inumind,4)),1,IS_NUMTECH(inumind,4),1)
	  CALL GETRNGR('a_obsyr5        ',obsoleteyr(inumind,5,1:IS_NUMTECH(inumind,5)),1,IS_NUMTECH(inumind,5),1)

      CALL GETRNGR('a_emiss1        ',IS_EMISS(inumind,1,1:IS_NUMTECH(inumind,1)),1,IS_NUMTECH(inumind,1),1)
	  CALL GETRNGR('a_EMISS3        ',IS_EMISS(inumind,3,1:IS_NUMTECH(inumind,3)),1,IS_NUMTECH(inumind,3),1)
	  CALL GETRNGR('a_EMISS4        ',IS_EMISS(inumind,4,1:IS_NUMTECH(inumind,4)),1,IS_NUMTECH(inumind,4),1)
	  CALL GETRNGR('a_EMISS5        ',IS_EMISS(inumind,5,1:IS_NUMTECH(inumind,5)),1,IS_NUMTECH(inumind,5),1)

      CALL GETRNGR('a_ALPHA1        ',IS_ALPHA(inumind,1,1:IS_NUMTECH(inumind,1)),1,IS_NUMTECH(inumind,1),1)
      CALL GETRNGR('a_ALPHA3        ',IS_ALPHA(inumind,3,1:IS_NUMTECH(inumind,3)),1,IS_NUMTECH(inumind,3),1)
      CALL GETRNGR('a_ALPHA4        ',IS_ALPHA(inumind,4,1:IS_NUMTECH(inumind,4)),1,IS_NUMTECH(inumind,4),1)
      CALL GETRNGR('a_ALPHA5        ',IS_ALPHA(inumind,5,1:IS_NUMTECH(inumind,5)),1,IS_NUMTECH(inumind,5),1)
      CALL GETRNGR('a_REI1          ',IS_REI(inumind,1,1:IS_NUMTECH(inumind,1)),1,IS_NUMTECH(inumind,1),1)
      CALL GETRNGR('a_REI2          ',IS_REI(inumind,1,1:4),1,4,1) !no number of technologies for anode in ironstlx so hardwire 4
      CALL GETRNGR('a_REI3          ',IS_REI(inumind,3,1:IS_NUMTECH(inumind,3)),1,IS_NUMTECH(inumind,3),1)
      CALL GETRNGR('a_REI4          ',IS_REI(inumind,4,1:IS_NUMTECH(inumind,4)),1,IS_NUMTECH(inumind,4),1)
      CALL GETRNGR('a_REI5          ',IS_REI(inumind,5,1:IS_NUMTECH(inumind,5)),1,IS_NUMTECH(inumind,5),1)

      CALL GETRNGR('AnodeRatio      ',AnodeRatio(1:7),1,7,1)
      CALL GETRNGR('al_pf_fuel      ',al_pf_fuel(1:2),1,2,1)
      CALL GETRNGR('al_ecalib       ',is_ecalib(inumind,1:5),1,5,1)
      CALL GETRNGR('al_delta1       ',is_delta(inumind,1,1:IS_NUMTECH(inumind,1)+2),1,IS_NUMTECH(inumind,1)+2,1)
      CALL GETRNGR('al_delta3       ',is_delta(inumind,3,1:IS_NUMTECH(inumind,3)),1,IS_NUMTECH(inumind,3),1)
      CALL GETRNGR('AL_CO2PEN       ',IS_CO2PENALTY(inumind,:),41,1,1)        ! POT_2050 already to 2050 no change
      CALL GETRNGR('Al_MECS         ',MECS_Data(inumind,1:5,1:9),5,9,1)                 ! row, col, group

    ! Glass INPUTS
      CALL ReadRngXLSX(WKUNIT,'Glass')   !read range names & coerresponding data
	  
      inumind=10
      CALL GETRNGI4('gnumtech        ',IS_NUMTECH(inumind,1:GL_MAXSTPS),GL_MAXSTPS,1,1)                 ! row, col, group
      CALL GETRNGI('gNUMFUEL        ',IS_NUMFUEL(inumind,1:GL_MAXSTPS),GL_MAXSTPS,1,1)
	  CALL GETRNGR('gPROD           ',is_production(inumind,1:GL_MAXSTPS),GL_MAXSTPS,1,1)
      CALL GETRNGI4('gBASELIFECR     ',IS_BASELIFECR(inumind),1,1,1)
	  CALL GETRNGR('gLIFETIME       ',IS_LIFETIME(inumind),1,1,1)
      CALL GETRNGI4('gCALIB          ',IS_CALIB(inumind),1,1,1)
	  CALL GETRNGR('gWACC           ',IS_WACC(inumind),1,1,1)
      CALL GETRNGI('gFISYR          ',IS_FISYR(inumind),1,1,1)
      CALL GETRNGR('gloxy           ',GL_OXY(1:3,1:4),3,4,1)
      CALL GETRNGR('glmecs          ',GL_MECS(1:2),1,2,1)
      CALL GETRNGR('glcryo          ',GL_CRYO,1,1,1)
      CALL GETRNGR('gl_histship     ',GL_hist_ship(1:6,1:4),6,4,1)

      do ij=1,GL_MAXSTPS
        write(strij,'(I2)') ij
		strij=adjustl(strij)
		rangen='gADECAY'//strij//'       '
		CALL GETRNGR(rangen,GL_ALPHA_DECAY(ij,:,:),4,2,1)
        rangen='G_LOGIT_COEFF'//strij//' '
        CALL GETRNGR(rangen,IS_LOGIT_COEFF(inumind,1:3,ij),3,1,1)
        technum=IS_NUMTECH(inumind,ij)
        rangen='GBASETECHSHR'//strij//'  '
        CALL GETRNGR(rangen,IS_BASE_TECH_SHARE(inumind,ij,1:technum),1,technum,1)
        rangen='GADDTECHSHR'//strij//'   '
        CALL GETRNGR(rangen,IS_ADD_TECH_SHARE(inumind,ij,1:technum),1,technum,1)
        rangen='g_capcost'//strij//'     '
        CALL GETRNGR(rangen,IS_CAPCOST(inumind,ij,1:technum),1,technum,1)
        rangen='gavom'//strij//'         '
        CALL GETRNGR(rangen,IS_AV_OM(inumind,ij,1:technum),1,technum,1)
        rangen='g_FUEL_USE'//strij//'    '
        CALL GETRNGR(rangen,IS_FUEL_USE(inumind,ij,1:2,1:technum),2,technum,1)
        rangen='g_obsyr'//strij//'       '
        CALL GETRNGR(rangen,obsoleteyr(inumind,ij,1:technum),1,technum,1)
        rangen='g_emiss'//strij//'       '
        CALL GETRNGR(rangen,IS_EMISS(inumind,ij,1:technum),1,technum,1)
        rangen='g_ALPHA'//strij//'       '
        CALL GETRNGR(rangen,IS_ALPHA(inumind,ij,1:technum),1,technum,1)
        rangen='g_REI'//strij//'       '
        CALL GETRNGR(rangen,IS_REI(inumind,ij,1:technum),1,technum,1)
      enddo

      CALL GETRNGR('Gl_MECS         ',MECS_Data(inumind,1:5,1:9),5,9,1)                 ! row, col, group

! Lime INPUTS
       CALL ReadRngXLSX(WKUNIT,'Lime')   !read range names & coerresponding data
	  inumind=11
      !add a step to cement data for lime storage
      CALL GETRNGI4('lnumtech        ',IS_NUMTECH(inumind,CM_MAXSTPS+1),1,1,1)                 ! row, col, group
      CALL GETRNGI('lNUMFUEL        ',IS_NUMFUEL(inumind,CM_MAXSTPS+1),1,1,1)
      CALL GETRNGR('lPROD           ',is_production(inumind,CM_MAXSTPS+1),1,1,1)
      CALL GETRNGR('LBASETECHSHR1   ',IS_BASE_TECH_SHARE(inumind,CM_MAXSTPS+1,1:IS_NUMTECH(inumind,CM_MAXSTPS+1)),1,IS_NUMTECH(inumind,CM_MAXSTPS+1),1)
      CALL GETRNGR('LADDTECHSHR2    ',IS_ADD_TECH_SHARE(inumind,CM_MAXSTPS+1,1:IS_NUMTECH(inumind,CM_MAXSTPS+1)),1,IS_NUMTECH(inumind,CM_MAXSTPS+1),1)
      CALL GETRNGR('l_CAPCOST1      ',IS_CAPCOST(inumind,CM_MAXSTPS+1,1:IS_NUMTECH(inumind,CM_MAXSTPS+1)),1,IS_NUMTECH(inumind,CM_MAXSTPS+1),1)
      CALL GETRNGR('lvom1           ',IS_AV_OM(inumind,CM_MAXSTPS+1,1:IS_NUMTECH(inumind,CM_MAXSTPS+1)),1,IS_NUMTECH(inumind,CM_MAXSTPS+1),1)
      CALL GETRNGR('l_FUEL_USE      ',IS_FUEL_USE(inumind,CM_MAXSTPS+1,1:4,1:IS_NUMTECH(inumind,CM_MAXSTPS+1)),4,IS_NUMTECH(inumind,CM_MAXSTPS+1),1)
      CALL GETRNGR('lobyr           ',obsoleteyr(inumind,CM_MAXSTPS+1,1:IS_NUMTECH(inumind,CM_MAXSTPS+1)),1,IS_NUMTECH(inumind,CM_MAXSTPS+1),1)
      CALL GETRNGR('l_EMISS         ',IS_EMISS(inumind,CM_MAXSTPS+1,1:IS_NUMTECH(inumind,CM_MAXSTPS+1)),1,IS_NUMTECH(inumind,CM_MAXSTPS+1),1)
      CALL GETRNGR('l_ALPHA         ',IS_ALPHA(inumind,CM_MAXSTPS+1,1:IS_NUMTECH(inumind,CM_MAXSTPS+1)),1,IS_NUMTECH(inumind,CM_MAXSTPS+1),1)
      CALL GETRNGR('L_LOGIT_COEFF   ',IS_LOGIT_COEFF(inumind,1:3,CM_MAXSTPS+1),3,1,1)
        ! TD add MECS reads; temp store in industry 9 until added to cement
      CALL GETRNGR('Li_MECS         ',MECS_Data(9,1:5,1:9),5,9,1)                 ! row, col, group
      !CALL GETRNGR('lm_hfo          ',lm_hfoshr(1:3),3,1,1) !resid,dist,other

     ! Cement INPUTS

      CALL ReadRngXLSX(WKUNIT,'Cement')   !read range names & coerresponding data
      
      WKUNIT = FILE_MGR('C',FNAME,NEW)   !close xml input file
      inumind=11
      CALL GETRNGI4('cnumtech        ',IS_NUMTECH(inumind,1:CM_MAXSTPS),CM_MAXSTPS,1,1)                 ! row, col, group
	  CALL GETRNGI('cNUMFUEL        ',IS_NUMFUEL(inumind,1:CM_MAXSTPS),CM_MAXSTPS,1,1)
	  CALL GETRNGR('cPROD           ',is_production(inumind,1:CM_MAXSTPS),CM_MAXSTPS,1,1)
      CALL GETRNGR('cbyrsurvcap     ',ibyr_survcap(inumind,1:CM_MAXSTPS),CM_MAXSTPS,1,1)
      CALL GETRNGI4('cBASELIFECR     ',CM_BASELIFECR(1:4),1,4,1)
	  CALL GETRNGR('cLIFETIME       ',CM_LIFETIME(1:4),1,4,1)
      CALL GETRNGI4('cCALIB          ',CM_CALIB(1:4),1,4,1)
	  CALL GETRNGR('cWACC           ',CM_WACC(1:4),1,4,1)
	  CALL GETRNGI4('cFISYR          ',CM_FISYR(1:4),1,4,1)
      CALL GETRNGR('cmass_loss      ',C_MASS_LOSS,1,1,1)
      CALL GETRNGR('cm_add          ',CM_ADD,1,1,1)
      CALL GETRNGR('cADECAY1        ',CM_ALPHA_DECAY(1,:,:),4,2,1)
      CALL GETRNGR('cADECAY2        ',CM_ALPHA_DECAY(2,:,:),4,2,1)
      CALL GETRNGR('cADECAY3        ',CM_ALPHA_DECAY(3,:,:),4,2,1)
      CALL GETRNGR('cADECAY4        ',CM_ALPHA_DECAY(4,:,:),4,2,1)
      
      
! select logit coeffs for the sceanrio
      if (HITECH.eq.1) then
         cm_rangen(1)='C_LOGIT_COEFF1H '
         cm_rangen(2)='C_LOGIT_COEFF2H '
         cm_rangen(3)='C_LOGIT_COEFF3H '
         cm_rangen(4)='C_LOGIT_COEFF4H '
     else if (FRZTECH.eq.1) then
         cm_rangen(1)='C_LOGIT_COEFF1F '
         cm_rangen(2)='C_LOGIT_COEFF2F '
         cm_rangen(3)='C_LOGIT_COEFF3F '
         cm_rangen(4)='C_LOGIT_COEFF4F '
      else if (EETECH.eq.1) then
         cm_rangen(1)='C_LOGIT_COEFF1E '
         cm_rangen(2)='C_LOGIT_COEFF2E '
         cm_rangen(3)='C_LOGIT_COEFF3E '
         cm_rangen(4)='C_LOGIT_COEFF4E '
      else !Ref case
         cm_rangen(1)='C_LOGIT_COEFF1  '
         cm_rangen(2)='C_LOGIT_COEFF2  '
         cm_rangen(3)='C_LOGIT_COEFF3  '
         cm_rangen(4)='C_LOGIT_COEFF4  '
      endif
      do ij=1,4
         CALL GETRNGR(cm_rangen(ij),IS_LOGIT_COEFF(inumind,1:6,ij),6,1,1)
	  enddo
      CALL GETRNGR('CBASETECHSHR1   ',IS_BASE_TECH_SHARE(inumind,1,1:IS_NUMTECH(inumind,1)),1,IS_NUMTECH(inumind,1),1)
      CALL GETRNGR('CBASETECHSHR2   ',IS_BASE_TECH_SHARE(inumind,2,1:IS_NUMTECH(inumind,2)),1,IS_NUMTECH(inumind,2),1)
      CALL GETRNGR('CBASETECHSHR3   ',IS_BASE_TECH_SHARE(inumind,3,1:IS_NUMTECH(inumind,3)),1,IS_NUMTECH(inumind,3),1)
      CALL GETRNGR('CBASETECHSHR4   ',IS_BASE_TECH_SHARE(inumind,4,1:IS_NUMTECH(inumind,4)),1,IS_NUMTECH(inumind,4),1)

      CALL GETRNGR('cADDTECHSHR1    ',IS_ADD_TECH_SHARE(inumind,1,1:IS_NUMTECH(inumind,1)),1,IS_NUMTECH(inumind,1),1)
      CALL GETRNGR('cADDTECHSHR2    ',IS_ADD_TECH_SHARE(inumind,2,1:IS_NUMTECH(inumind,2)),1,IS_NUMTECH(inumind,2),1)
      CALL GETRNGR('cADDTECHSHR3    ',IS_ADD_TECH_SHARE(inumind,3,1:IS_NUMTECH(inumind,3)),1,IS_NUMTECH(inumind,3),1)
      CALL GETRNGR('cADDTECHSHR4    ',IS_ADD_TECH_SHARE(inumind,4,1:IS_NUMTECH(inumind,4)),1,IS_NUMTECH(inumind,4),1)

      CALL GETRNGR('c_capcost1      ',IS_CAPCOST(inumind,1,1:IS_NUMTECH(inumind,1)),1,IS_NUMTECH(inumind,1),1)
      CALL GETRNGR('c_CAPCOST2      ',IS_CAPCOST(inumind,2,1:IS_NUMTECH(inumind,2)),1,IS_NUMTECH(inumind,2),1)
      CALL GETRNGR('c_CAPCOST3      ',IS_CAPCOST(inumind,3,1:IS_NUMTECH(inumind,3)),1,IS_NUMTECH(inumind,3),1)
      CALL GETRNGR('c_CAPCOST4      ',IS_CAPCOST(inumind,4,1:IS_NUMTECH(inumind,4)),1,IS_NUMTECH(inumind,4),1)

      CALL GETRNGR('cavom1          ',IS_AV_OM(inumind,1,1:IS_NUMTECH(inumind,1)),1,IS_NUMTECH(inumind,1),1)
      CALL GETRNGR('cavom2          ',IS_AV_OM(inumind,2,1:IS_NUMTECH(inumind,2)),1,IS_NUMTECH(inumind,2),1)
      CALL GETRNGR('cavom3          ',IS_AV_OM(inumind,3,1:IS_NUMTECH(inumind,3)),1,IS_NUMTECH(inumind,3),1)
      CALL GETRNGR('cavom4          ',IS_AV_OM(inumind,4,1:IS_NUMTECH(inumind,4)),1,IS_NUMTECH(inumind,4),1)

      CALL GETRNGR('c_FUEL_USE1     ',IS_FUEL_USE(inumind,1,1:5,1:IS_NUMTECH(inumind,1)),5,IS_NUMTECH(inumind,1),1)
      CALL GETRNGR('c_FUEL_USE2     ',IS_FUEL_USE(inumind,2,1:5,1:IS_NUMTECH(inumind,2)),5,IS_NUMTECH(inumind,2),1)
      CALL GETRNGR('c_FUEL_USE3     ',IS_FUEL_USE(inumind,3,1:5,1:IS_NUMTECH(inumind,3)),5,IS_NUMTECH(inumind,3),1)
      CALL GETRNGR('c_FUEL_USE4     ',IS_FUEL_USE(inumind,4,1:5,1:IS_NUMTECH(inumind,4)),5,IS_NUMTECH(inumind,4),1)

      CALL GETRNGR('c_obsyr1        ',obsoleteyr(inumind,1,1:IS_NUMTECH(inumind,1)),1,IS_NUMTECH(inumind,1),1)
      CALL GETRNGR('c_obsyr2        ',obsoleteyr(inumind,2,1:IS_NUMTECH(inumind,2)),1,IS_NUMTECH(inumind,2),1)
      CALL GETRNGR('c_obsyr3        ',obsoleteyr(inumind,3,1:IS_NUMTECH(inumind,3)),1,IS_NUMTECH(inumind,3),1)
      CALL GETRNGR('c_obsyr4        ',obsoleteyr(inumind,4,1:IS_NUMTECH(inumind,4)),1,IS_NUMTECH(inumind,4),1)

      CALL GETRNGR('c_emiss1        ',IS_EMISS(inumind,1,1:IS_NUMTECH(inumind,1)),1,IS_NUMTECH(inumind,1),1)
      CALL GETRNGR('c_EMISS2        ',IS_EMISS(inumind,2,1:IS_NUMTECH(inumind,2)),1,IS_NUMTECH(inumind,2),1)
      CALL GETRNGR('c_EMISS3        ',IS_EMISS(inumind,3,1:IS_NUMTECH(inumind,3)),1,IS_NUMTECH(inumind,3),1)
      CALL GETRNGR('c_EMISS4        ',IS_EMISS(inumind,4,1:IS_NUMTECH(inumind,4)),1,IS_NUMTECH(inumind,4),1)
      
      CALL GETRNGR('C_PART1         ',part_matter(1,1:IS_NUMTECH(inumind,1)),1,IS_NUMTECH(inumind,1),1)
      CALL GETRNGR('C_PART2         ',part_matter(2,1:IS_NUMTECH(inumind,2)),1,IS_NUMTECH(inumind,2),1)
      CALL GETRNGR('C_PART3         ',part_matter(3,1:IS_NUMTECH(inumind,3)),1,IS_NUMTECH(inumind,3),1)
      CALL GETRNGR('C_PART4         ',part_matter(4,1:IS_NUMTECH(inumind,4)),1,IS_NUMTECH(inumind,4),1)

      CALL GETRNGR('c_ALPHA1        ',IS_ALPHA(inumind,1,1:IS_NUMTECH(inumind,1)),1,IS_NUMTECH(inumind,1),1)
      CALL GETRNGR('c_ALPHA2        ',IS_ALPHA(inumind,2,1:IS_NUMTECH(inumind,2)),1,IS_NUMTECH(inumind,2),1)
      CALL GETRNGR('c_ALPHA3        ',IS_ALPHA(inumind,3,1:IS_NUMTECH(inumind,3)),1,IS_NUMTECH(inumind,3),1)
      CALL GETRNGR('c_ALPHA4        ',IS_ALPHA(inumind,4,1:IS_NUMTECH(inumind,4)),1,IS_NUMTECH(inumind,4),1)
      CALL GETRNGR('cm_REI1          ',IS_REI(inumind,1,1:IS_NUMTECH(inumind,1)),1,IS_NUMTECH(inumind,1),1)
      CALL GETRNGR('cm_REI2          ',IS_REI(inumind,2,1:IS_NUMTECH(inumind,2)),1,IS_NUMTECH(inumind,2),1)
      CALL GETRNGR('cm_REI3          ',IS_REI(inumind,3,1:IS_NUMTECH(inumind,3)),1,IS_NUMTECH(inumind,3),1)
      CALL GETRNGR('cm_REI4          ',IS_REI(inumind,4,1:IS_NUMTECH(inumind,4)),1,IS_NUMTECH(inumind,4),1)

      CALL GETRNGR('cm_delta1       ',is_delta(inumind,1,1:IS_NUMTECH(inumind,1)),1,IS_NUMTECH(inumind,1),1)
      CALL GETRNGR('cm_delta2       ',is_delta(inumind,2,1:IS_NUMTECH(inumind,2)),1,IS_NUMTECH(inumind,2),1)
      CALL GETRNGR('cm_delta4       ',is_delta(inumind,4,1:IS_NUMTECH(inumind,4)),1,IS_NUMTECH(inumind,4),1)

      CALL GETRNGR('cm_calib_k      ',is_ecalib(inumind,1:4),1,4,1)
      CALL GETRNGR('cm_wet          ',cm_baselifewet2(1:4),4,1,1)
      CALL GETRNGR('cm_cap_shr      ',cm_capshr(1:2),2,1,1)
      CALL GETRNGR('cm_import       ',cm_import_clink,1,1,1)
      CALL GETRNGR('comb_co23       ',cm_combco2(3,1:IS_NUMTECH(inumind,3)),1,IS_NUMTECH(inumind,3),1)
      !CALL GETRNGR('comb_co24       ',cm_combco2(4,1:IS_NUMTECH(inumind,4)),1,IS_NUMTECH(inumind,4),1)
      CALL GETRNGR('cm_heatsrv      ',cm_heatsrv(1:IS_NUMTECH(inumind,2)),1,IS_NUMTECH(inumind,2),1)
      CALL GETRNGR('cm_heatsrv_fuel ',cm_heatsrv_fuel(1:IS_NUMTECH(inumind,3)),1,IS_NUMTECH(inumind,3),1)      
      CALL GETRNGR('cm_basedry      ',cm_baselifedry,1,1,1)
      CALL GETRNGR('elec_coeff      ',cm_eleccoef(1:4),1,4,1)
      CALL GETRNGR('heat_coeff      ',cm_heatcoef(1:4),1,4,1)
      CALL GETRNGR('cm_heatdcoef    ',cm_heatdcoef,1,1,1)

      CALL GETRNGR('cm_wetcoef      ',cm_wetcoef(1:IS_NUMTECH(inumind,3)),1,IS_NUMTECH(inumind,3),1)
      CALL GETRNGR('cm_wetcoef2     ',cm_wetcoef2(1:IS_NUMTECH(inumind,4)),1,IS_NUMTECH(inumind,4),1)
      CALL GETRNGR('cm_rawtech      ',cm_rawtech(1:2),1,2,1)
      CALL GETRNGR('cm_fuelmix      ',cm_fuelmix(1:7,1:5),7,5,1)
  
        ! TD add MECS reads
      CALL GETRNGR('Ce_MECS         ',MECS_Data(inumind,1:5,1:9),5,9,1)                 ! row, col, group
     ! CALL GETRNGR('cm_hfo          ',cm_hfoshr(1:3),3,1,1) !hfo shared to resid,dist,other
      
    ! Read End-Use model coefficients
    !inumind=7
     ! CALL GETRNGR('f_beta1        ',eu_beta1(inumind,1:16)),1,16,1)
     ! CALL GETRNGR('f_tmid         ',eu_tmid(inumind,1:16)),1,16,1)
     ! CALL GETRNGR('f_tshift       ',eu_tshift(inumind,1:16)),1,16,1)
     ! CALL GETRNGR('f_alpha1       ',eu_alpha1(inumind,1:16)),1,16,1)
     ! CALL GETRNGR('f_alpha2       ',eu_alpha2(inumind,1:16)),1,16,1)
    ! inumind=20
     ! CALL GETRNGR('pl_beta1       ',eu_beta1(inumind,1:5)),1,5,1)
     ! CALL GETRNGR('pl_tmid        ',eu_tmid(inumind,1:5)),1,5,1)
     ! CALL GETRNGR('pl_tshift      ',eu_tshift(inumind,1:5)),1,5,1)
     ! CALL GETRNGR('pl_alpha1      ',eu_alpha1(inumind,1:5)),1,5,1)
     ! CALL GETRNGR('pl_alpha2      ',eu_alpha2(inumind,1:5)),1,5,1)
     !inumind=21
     ! CALL GETRNGR('bom_beta1      ',eu_beta1(inumind,1:5)),1,5,1)
     ! CALL GETRNGR('bom_tmid       ',eu_tmid(inumind,1:5)),1,5,1)
     ! CALL GETRNGR('bom_tshift     ',eu_tshift(inumind,1:5)),1,5,1)
     ! CALL GETRNGR('bom_alpha1     ',eu_alpha1(inumind,1:5)),1,5,1)
     ! CALL GETRNGR('bom_alpha2     ',eu_alpha2(inumind,1:5)),1,5,1)
     !inumind=9
     ! CALL GETRNGR('c_beta1        ',eu_beta1(inumind,1:24)),1,24,1)
     ! CALL GETRNGR('c_tmid         ',eu_tmid(inumind,1:24)),1,24,1)
     ! CALL GETRNGR('c_tshift       ',eu_tshift(inumind,1:24)),1,24,1)
     ! CALL GETRNGR('c_alpha1       ',eu_alpha1(inumind,1:24)),1,24,1)
     ! CALL GETRNGR('c_alpha2       ',eu_alpha2(inumind,1:24)),1,24,1)
     !inumind=19
     ! CALL GETRNGR('w_beta1        ',eu_beta1(inumind,1:5)),1,5,1)
     ! CALL GETRNGR('w_tmid         ',eu_tmid(inumind,1:5)),1,5,1)
     ! CALL GETRNGR('w_tshift       ',eu_tshift(inumind,1:5)),1,5,1)
     ! CALL GETRNGR('w_alpha1       ',eu_alpha1(inumind,1:5)),1,5,1)
     ! CALL GETRNGR('w_alpha2       ',eu_alpha2(inumind,1:5)),1,5,1)
      return
      end

 !***********************************************
! This subroutine is common to the tech choice industries
! Technology Share Report Writer - write isteel.csv
! Called from: IronSteel_Industry, Paper_Industry
! Calls: none

     subroutine TECHSHR_RPT
      use i_
      IMPLICIT NONE

	  INTEGER IY,ISTEP,IS,IFUEL(50)
       INTEGER IROW/0/

      !  steel technolgy names
      CHARACTER*35 TECHNAME(28)                                                   !technology names
	  DATA TECHNAME /"   --Recuperated Reheating (NG)", &
	                  "   --Unrecuperated Reheating (NG)", &
					  "   --Direct Rolling Reheating (NG)", &
                      "   --Heat PM", &
					  "   --Electric Ladle", &
					  "   --NG Ladle", &
                      "   --Ladle PM", &
					  "   --BOF w/Plasma Torch (NG)", &
					  "   --BOF (NG)", &
                      "   --BOF w/Plasma Torch (HFO)", &
                      "   --BOF (HFO)", &
                      "   --BOF Gas Recovery (NG)", &
                      "   --BOF Gas Recovery (HFO)", &
                      "   --BOF Recovery w/Plasma (NG)", &
                      "   --BOF Recovery w/Plasma (HFO)", &
                      "   --BF PM", &
                      "   --EAF (NG)", &
                      "   --EAF w/Oxy Lance (NG)", &
                      "   --EAF PM", &
                      "   --ELRED Process (NG)", &
                      "   --Corex Process (NG)", &
                      "   --Corex Process (HFO)", &
                      "   --Hismelt Process (NG)", &
                      "   --DRI_BOF_PM", &
                      "   --EAF w/Midrex Process (NG)", &
                      "   --EAF w/Corex Process (NG)", &
                      "   --EAF w/Corex Process (HFO)", &
                      "   --DRI_EAF_PM"/
	! steel sub technology names
      CHARACTER*35 TECHNAMESUB(2)
	  DATA TECHNAMESUB / &
	                  "   -DRI to BOF           ",&
	                  "   -DRI to EAF           "/

    ! aluminum step names
       CHARACTER*40 AINDSTEPNAME(5)
       DATA AINDSTEPNAME /"Smelting", &
                          "Anode Production", &
                          "Primary Alumina", &
                          "Boilers", &
                          "Secondary Production"/

      !  aluminum technolgy names
      CHARACTER*35 ATECHNAME(20)                                                   !technology names
	  DATA ATECHNAME /"   --PB_1", &
	                  "   --PB_2", &
					  "   --PB_3", &
					  "   --PB_4", &
					  "   --IA_1", &
                      "   --PB_PM", &
					
                      "   --BAY_NG1", &
                      "   --BAY_NG2", &
                      "   --BAY_PM", &

                      "   --COGN_1", &
                      "   --COGN_2", &
                      "   --COGN_3", &
                      "   --COGN_4", &
                      "   --COGN_5", &
					  "   --CONV_1", &
					  "   --CONV_2", &
					  "   --CONV_3", &

                      "   --SEC_NG1", &
                      "   --SEC_NG2", &
                      "   --SEC_PM"/
     ! paper step names
       CHARACTER*40 PINDSTEPNAME(26)
       DATA PINDSTEPNAME /"Wood Prep", &
                          "Kraft Pulp", &
                          "Semi-Chem Pulp", &
                          "Mechanical Pulp", &
                          "Thermomechanical Pulp", &
                          "Recycled Pulp", &
                          "Pulp Wash", &
                          "Pulp  Dry", &
                          "Bleaching", &
                          "Newsprint Production (Drying)", &
                          "Newsprint Production (Finishing)", &
                          "Paperboard Production (Drying)", &
                          "Paperboard Production (Finishing)", &
                          "Paperboard Production (Stock Prep)", &
                          "Uncoated Paper Production (Drying)", &
                          "Uncoated Paper Production (Finishing)", &
                          "Uncoated Paper Production (Stock Prep)", &
                          "Coated Paper Production (Drying)", &
                          "Coated Paper Production (Finishing)", &
                          "Coated Paper Production (Stock Prep)", &
                          "Tissue Paper Production (Drying)", &
                          "Tissue Paper Production (Finishing)", &
                          "Tissue Paper Production (Stock Prep)", &
                          "Black Liquor Evaporators", &
                          "Lime Kilns", &
                          "Recovery Furnaces"/
     ! paper technology names
	  CHARACTER*65 PTECHNAME(115)                                                   !technology names
	  DATA PTECHNAME /"   --Debarker: Ring", &
                      "   --Debarker: Rosser Head", &
                      "   --Debarker: Bio", &
                      "   --Debarker: PM", &
                      
                      "   --Batch Digester w/ comp control", &
                      "   --Batch Digester w/ heat recovery", &
                      "   --Batch Digester w/ comp control & heat recovery", &
                      "   --Batch Digester, RDH Process", &
                      "   --Continuous Digester", &
                      "   --Continuous Digester w/ comp control", &
                      "   --Kraft_PM",&
                      
                      "   --Batch Digester w/ comp control", &
                      "   --Batch Digester w/ comp control & heat recovery", &
                      "   --Continuous Digester w/ comp control", &
                      "   --S-Chem_4",&
                      
                      "   --Stone Grinder", &
                      "   --Mechanical Refiner", &
                      "   --Thermo-Mech Refiner", &
                      "   --Thermo-Mech Refiner, High Speed", &
                      "   --Mech_PM",&
                      
                      "   --Chemical Thermo-Mech Pulping", &
                      "   --Explosion Thermo-Mech Pulping (Hardwood)", &
                      "   --TMP_PM",&
                      
                      "   --Wash De-inking", &
                      "   --Flotation De-inking", &
                      "   --Explosion De-inking", &
                      "   --Recycle_PM",&
                      
                      "   --Drum Washer", &
                      "   --Diffusion Washer", &
                      "   --Wash_PM",&

                      "   --Steam", &
                      "   --Steam w/ vapor recompression", &
                      "   --Dry_PM",&
                      
                      "   --Full Bleach w/ ClO2 in 1st Stage", &
                      "   --Full Bleach w/ Hypochlorite in 1st Stage", &
                      "   --Full Bleach w/ Hypochlorite in 1st Stage & comp control", &
                      "   --Oxygen delignification w/ ClO2 in 1st Stage", &
                      "   --Oxygen delignification w/ ClO2 in 2nd Stage", &
                      "   --Bleach_PM",&
                      
                      "   --Electric w/ comp control", &
                      "   --Steam", &
                      "   --Steam w/ comp control", &
                      "   --Steam, High Intensity", &
                      "   --NS_DRY_PM",&
                      
                      "   --Electric", &
                      "   --Electric w/ induction heat", &
                      "   --Electric w/ nip press", &
                      "   --Electric w/ nip press & induction heat", &
                      "   --NS_FIN_PM",&
                      
                      "   --Steam", &
                      "   --Steam w/ comp control", &
                      "   --Steam w/ recompression", &
                      "   --Steam, High Intensity", &
                      "   --PB_DRY_PM",&
                      
                      "   --Electric", &
                      "   --Electric w/ nip press", &
                      "   --Electric, High Efficiency", &
                      "   --Electric, High Efficiency w/ nip press", &
                      "   --PB_FIN_PM",&
                      
                      "   --Conical Refining", &
                      "   --Disk Refining", &
                      "   --PB_PREP_PM",&
                      
                      "   --Steam", &
                      "   --Steam w/ comp control", &
                      "   --Steam, High Intensity", &
                      "   --Steam, High Humidity Hood", &
                      "   --UNC_DRY_PM",&
                      
                      "   --Electric ", &
                      "   --Electric w/ nip press", &
                      "   --Electric, High Efficiency", &
                      "   --Electric, High Efficiency w/ nip press", &
                      "   --UNC_FIN_PM",&
                      
                      "   --Conical Refining", &
                      "   --Disk Refining", &
                      "   --NC_PREP_PM",&
                      
                      "   --Steam ", &
                      "   --Steam w/ IR radiation", &
                      "   --Steam w/ high intensity drying", &
                      "   --Steam w/ electricity & high intensity drying", &
                      "   --CTD_DRY_PM",&
                      
                      "   --Electric ", &
                      "   --Electric w/ nip press", &
                      "   --Electric, High Efficiency", &
                      "   --Electric, High Efficiency w/ nip press", &
                      "   --CTD_FIN_PM",&
                      
                      "   --Disk Refining", &
                      "   --Disk Refining, High Efficiency", &
                      "   --TD_PREP_PM",&
                      
                      "   --Steam", &
                      "   --Steam w/ comp control", &
                      "   --Steam w/ high humidity hood", &
                      "   --TIS_DRY_PM",&
                      
                      "   --Electric", &
                      "   --Electric, High Efficiency", &
                      "   --TIS_FIN_PM",&
                      
                      "   --Conical Refining", &
                      "   --Disk Refining", &
                      "   --TIS_PREP_PM",&
                      
                      "   --Black Liquor Evaporator", &
                      "   --Evaporator w/ comp control", &
                      "   --Evaporator w/ standalone concentrator", &
                      "   --Evaporator w/ integrated concentrator", &
                      "   --EVAP_PM",&
                      
                      "   --NG", &
                      "   --NG w/ flash dryer", &
                      "   --HFO w/ flash dryer", &
                      "   --Coal", &
                      "   --HFO & Hog Fuel", &
                      "   --Furn_PM",&
                      
                      "   --Low Pressure Cogen", &
                      "   --Direct Evaporator", &
                      "   --Conventional", &
                      "   --Conventional w/ comp control", &
                      "   --High Solids Firing & comp control", &
                      "   --High Pressure Cogen"/
                      

        ! glass step names
       CHARACTER*40 GINDSTEPNAME(14)
        DATA GINDSTEPNAME /"Flat Tempering", &
                           "Flat Form and Finish", &
                           "Flat Furnace", &
                           "Flat Glass Preparation", &
                           "Container  Form and Finish", &
                           "Container Furnace", &
                           "Container Preparation", &
                           "Blown Polish", &
                           "Blown Form and Finish", &
                           "Blown Furnace", &
                           "Blown Preperation", &
                           "Fiber Form and Finish", &
                           "Fiber Furnace", &
                           "Fiber Preperation"/


       !  glass technolgy names
      CHARACTER*35 gTECHNAME(61)                                                   !technology names
	  DATA gTECHNAME /"   --FT_1", "   --FT_2", "   --FT_PM", &
                      "   --FORM_1","   --FORM_2","   --FORM_3", "   --FORM_PM",&
					  "   --FURN_1","   --FURN_2", "   --FURN_3","   --FURN_4","   --FURN_5", "   --FURN_PM",&
                      "   --PREP_1","   --PREP_2","   --PREP_PM", &
                      "   --CFORM_1","   --CFORM_2", "   --CFORM_3",  "   --CFORM_PM",&
                      "   --CFURN_1",  "   --CFURN_2", "   --CFURN_3", "   --CFURN_4","   --CFURN_5","   --CFURN_6",  "   --CFURN_7","   --CFURN_8", &
                      "   --CFURN_9", "   --CFURN_10",  "   --CFURN_PM",&
                      "   --CPREP_1","   --CPREP_2", "   --CPREP_PM",&
                      "   --BPOLISH_1","   --BPOLISH_2", "   --BPOLISH_PM", &
                      "   --BFORM_1","   --BFORM_2", "   --BFORM_3",  "   --BFORM_PM",&
                      "   --BFURN_1",  "   --BFURN_2", "   --BFURN_3", "   --BFURN_4","   --BFURN_5", "   --BFURN_PM",&
                      "   --BPREP_1","   --BPREP_2", "   --BPREP_PM",&
                      "   --FFORM_1","   --FFORM_2", "   --FFORM_PM",&
                      "   --FFURN_1",  "   --FFURN_2", "   --FFURN_3", "   --FFURN_4", "   --FFURN_PM", &
                      "   --FPREP_1","   --FPREP_2","   --FPREP_PM"/
       ! cement step names
       CHARACTER*40 CINDSTEPNAME(5) !added lime as a cement step -- TD
       DATA CINDSTEPNAME /"Finish Grinding", &
                          "Kiln", &
                          "Burner", &
                          "Raw Grinding", &
                          "Lime"/


      !  cement and lime technolgy names
      CHARACTER*35 CTECHNAME(23)                                                   !technology names
	  DATA CTECHNAME /"   --Ball_Mill_1", &
                      "   --Ball_Mill_2", &
                      "   --Roller_Mill_1", &
                      "   --Roller_Mill_2", &
                      "   --Grind_PM", &

                      "   --Rotary 1", &
	                  "   --Rotary_2", &
					  "   --Rotary_3", &
                      "   --Rotary_PM", &
										
                      "   --NG_1", &
                      "   --NG_2", &
                      "   --Oil_1", &
                      "   --Oil_2", &
                      "   --Coal", &
                      "   --PetCoke", &
                      "   --alt_solid", &


					  "   --Ball_Mill", &
					  "   --Roller_Mill", &
                      "   --Mill_PM", &
                      
                      "   --Coal", &
                      "   --HFO", &
					  "   --NG", &
                      "   --LIME_PM"/

      CHARACTER*166 LINE ! length must match the 166 character length declaration in ckstr (in fwk1io.f)
      character*50 blnkfile
      character*166 rundoc(2)
      integer l,jj
      integer I15,vers,icol,numstep
      integer cwk1unit
      integer gfmax(12,maxstep+1),gfloc(16,12,maxstep+1),indcnt,bsize
	  INTEGER*4 iro(5),ius
      save iro,ius
      character*2 argc
      logical lexist,notopen/.false./
      integer irecl
      character*1 nul
      parameter (irecl=400)
      character*irecl longline
	  character*4 technum
	  integer icount
      integer jcount        ! Dummy counter for isteel print routine

	  vers=1
      blnkfile='isteel.csv'
      fname='ISTEEL' ! for file_mgr
      iro(vers)=file_mgr('O',fname,.true.) ! get a free unit number from file_mgr
      inquire(unit=iro(vers),opened=lexist)
      if(lexist) close(unit=iro(vers),status='delete')
      if(iro(vers).le.0) iro(vers)=950+vers
      cwk1unit=iro(vers)
      inquire(file=blnkfile,exist=lexist)
      if(lexist) then
         OPEN(UNIT=cwk1unit,FILE=blnkfile,FORM='FORMATTED', &
              ACCESS='DIRECT',recl=irecl,err=2001)
         close(cwk1unit,status='delete',err=2001)
2001     continue
      endif
      OPEN(UNIT=cwk1unit,FILE=blnkfile,FORM='FORMATTED', &
      ACCESS='DIRECT',RECL=irecl,status='new',err=1002)
      i15=iro(vers)
      cwk1unit=i15
! get scenario identification of run
      rundoc(1)=' Scenario '//scen
      ICOL=4
      irow=2
!**********************************************************
!  INITIALIZE THE SPREADSHEET FILE:
!**********************************************************
      CALL ckstr(I15,1,1,rundoc(1),1,0,1)

      write(line,*) 'Table 1', &
                '  Iron and Steel Technology Percentage '

      IROW = irow+2
      CALL ckstr(I15,IROW,1,LINE,1,0,1)
      LINE='Technology Choice for each Step'
      IROW = IROW + 3
      CALL ckstr(I15,IROW,1,LINE,1,0,1)
      numstep=mpastp
	  IROW = IROW + 1
      icount=1
      do jj=ibyr2+1,IEYR !ENDYR  POT_2050 2040 to IEYR
	  IROW=8
      CALL ckint(I15,IROW,icol,jj,0)
      DO ISTEP=1,numstep
        if ((IS_NUMTECH(12,istep).gt.0).and.(istep.ne.2)) then
            LINE = '  ' // INDSTEPNAME(ISTEP)
            if (istep.ne.7) IROW = IROW + 1

            if((jj.eq.ibyr2+1).and.(istep.ne.7)) CALL ckstr(I15,IROW,1,LINE,1,0,1)
			if (istep.ne.7) CALL cknum(I15,IROW,icol,dble(prodcurrpt(ISTEP,jj-1989)),0,4)     ! POT_2050NDIGIT 2 to 0
			if(istep.eq.6) then
			   IROW=IROW+1
			   if(jj.eq.ibyr2+1)LINE = '  ' // TECHNAMESUB(1)
			  if(jj.eq.ibyr2+1) CALL ckstr(I15,IROW,1,LINE,1,0,1)

			endif
			if(istep.eq.7) then
			   IROW=IROW+1
			   if(jj.eq.ibyr2+1) LINE = '  ' // TECHNAMESUB(2)
			   if(jj.eq.ibyr2+1) CALL ckstr(I15,IROW,1,LINE,1,0,1)

			endif

            DO IF=1,IS_NUMTECH(12,istep)
			    if(jj.eq.ibyr2+1) LINE= techname(icount)
				icount=icount+1
               IROW = IROW + 1
               if(jj.eq.ibyr2+1)CALL ckstr(I15,IROW,1,LINE,1,0,1)
			   CALL cknum(I15,IROW,icol,dble(is_shares(inddir,ISTEP,if,jj-1989)),2,4)

            ENDDO
		endif
      ENDDO
      icol=icol+1
      enddo
      !!!!!!!!!  PAPER  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      IROW = IROW + 5   ! 48
      ICOL=4 !curcalyr-ibyr2+3
      write(line,*) 'Table 2', &
                '  Pulp and Paper Technology Percentage '
      CALL ckstr(I15,IROW,1,LINE,1,0,1)
      IROW = IROW + 3   ! 51
      LINE='Technology Choice for each Step'
      CALL ckstr(I15,IROW,1,LINE,1,0,1)
      numstep=26 !mpastp
      icount=1
      jcount=0
      IROW = IROW + 1
      do jj=ibyr2+1,IEYR !LASTYR    POT_2050 2040 to IEYR
        IROW=IROW-jcount ! Return to first row for this industry by subtracting jcount
        jcount=0
        CALL ckint(I15,IROW,icol,jj,0) !write year
        DO ISTEP=1,numstep
          if (IS_NUMTECH(8,istep).gt.0) then
            LINE = '  ' // PINDSTEPNAME(ISTEP)
            IROW = IROW + 1
            jcount = jcount + 1
            if((jj.eq.ibyr2+1)) CALL ckstr(I15,IROW,1,LINE,1,0,1)
            CALL cknum(I15,IROW,icol,dble(pp_prodcurrpt(ISTEP,jj-1989)),0,4)        ! POT_2050NDIGIT 2 to 0
            DO IF=1,IS_NUMTECH(8,istep)
			    if(jj.eq.ibyr2+1) LINE= ptechname(icount)
				icount=icount+1
               IROW = IROW + 1
               jcount = jcount + 1
               if(jj.eq.ibyr2+1)CALL ckstr(I15,IROW,1,LINE,1,0,1)
			   CALL cknum(I15,IROW,icol,dble(is_shares(8,ISTEP,if,jj-1989)),2,4)
            ENDDO
		  endif
        ENDDO
        icol=icol+1
      enddo

           !!!!!!!!!  Aluminum  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      IROW = IROW + 5   ! 198
      ICOL=4 !curcalyr-ibyr2+3
      write(line,*) 'Table 3', &
                '  Aluminum Technology Percentage '
      CALL ckstr(I15,IROW,1,LINE,1,0,1)
      IROW = IROW + 3   ! 201
      LINE='Technology Choice for each Step'
      CALL ckstr(I15,IROW,1,LINE,1,0,1)
      numstep=5
      icount=1
      jcount=0
      IROW = IROW + 1
      do jj=ibyr2+1,IEYR !LASTYR  POT_2050 2040 to IEYR
        IROW=IROW-jcount ! Return to first row for this industry by subtracting jcount
        jcount=0
        CALL ckint(I15,IROW,icol,jj,0) !write year
        DO ISTEP=1,numstep
          if (IS_NUMTECH(13,istep).gt.0) then
            LINE = '  ' // AINDSTEPNAME(ISTEP)
            IROW = IROW + 1
            jcount = jcount + 1
            if((jj.eq.ibyr2+1)) CALL ckstr(I15,IROW,1,LINE,1,0,1)

            CALL cknum(I15,IROW,icol,dble(al_prodcurrpt(ISTEP,jj-1989)),0,4)      ! POT_2050NDIGIT 2 to 0

            DO IF=1,IS_NUMTECH(13,istep)
             ! if (if.ne.2) then  !no tech choices for step 2 anode
			    if(jj.eq.ibyr2+1) LINE= atechname(icount)
				icount=icount+1
                IROW = IROW + 1
                jcount = jcount + 1
                if(jj.eq.ibyr2+1)CALL ckstr(I15,IROW,1,LINE,1,0,1)
			    CALL cknum(I15,IROW,icol,dble(is_shares(13,ISTEP,if,jj-1989)),2,4)
             ! endif
            ENDDO

		  endif
        ENDDO
        icol=icol+1
      enddo

                !!!!!!!!!  Glass  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      IROW = IROW + 5   ! 231
      ICOL=4 !curcalyr-ibyr2+3
      write(line,*) 'Table 4', &
                '  Glass Technology Percentage '
      CALL ckstr(I15,IROW,1,LINE,1,0,1)
      IROW = IROW + 3   ! 234
      LINE='Technology Choice for each Step'
      CALL ckstr(I15,IROW,1,LINE,1,0,1)
      numstep=14
      icount=1
      jcount=0
      IROW = IROW + 1
      do jj=ibyr2+1,IEYR !LASTYR  POT_2050 2040 to IEYR
        IROW=IROW-jcount ! Return to first row for this industry by subtracting jcount
        jcount=0
        CALL ckint(I15,IROW,icol,jj,0) !write year
        DO ISTEP=1,numstep
          if (IS_NUMTECH(10,istep).gt.0) then
            LINE = '  ' // GINDSTEPNAME(ISTEP)
            IROW = IROW + 1
            jcount = jcount + 1
            if((jj.eq.ibyr2+1)) CALL ckstr(I15,IROW,1,LINE,1,0,1)

            CALL cknum(I15,IROW,icol,dble(gl_prodcurrpt(ISTEP,jj-1989)),0,4)     ! POT_2050NDIGIT 2 to 0

            DO IF=1,IS_NUMTECH(10,istep)
               if(jj.eq.ibyr2+1) LINE= gtechname(icount)
				icount=icount+1
                IROW = IROW + 1
                jcount = jcount + 1
                if(jj.eq.ibyr2+1)CALL ckstr(I15,IROW,1,LINE,1,0,1)
			    CALL cknum(I15,IROW,icol,dble(is_shares(10,ISTEP,if,jj-1989)),2,4)
            ENDDO
		  endif
        ENDDO
        icol=icol+1
      enddo

                   !!!!!!!!!  Cement  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      IROW = IROW + 5   ! 315
      ICOL=4 !curcalyr-ibyr2+3
      write(line,*) 'Table 5', &
                '  Cement Technology Percentage '
      CALL ckstr(I15,IROW,1,LINE,1,0,1)
      IROW = IROW + 3   ! 318
      LINE='Technology Choice for each Step'
      CALL ckstr(I15,IROW,1,LINE,1,0,1)
      numstep=4
      icount=1
      jcount=0
      IROW = IROW + 1
      do jj=ibyr2+1,IEYR !LASTYR  POT_2050 2040 to IEYR
        IROW=IROW-jcount ! Return to first row for this industry by subtracting jcount
        jcount=0
        CALL ckint(I15,IROW,icol,jj,0) !write year
        DO ISTEP=1,numstep+1 !add lime here
          if (IS_NUMTECH(11,istep).gt.0) then
            LINE = '  ' // CINDSTEPNAME(ISTEP)
            IROW = IROW + 1
            jcount = jcount + 1
            if((jj.eq.ibyr2+1)) CALL ckstr(I15,IROW,1,LINE,1,0,1)
            DO IF=1,IS_NUMTECH(11,istep)
               if(jj.eq.ibyr2+1) LINE= ctechname(icount)
				icount=icount+1
                IROW = IROW + 1
                jcount = jcount + 1
                if(jj.eq.ibyr2+1)CALL ckstr(I15,IROW,1,LINE,1,0,1)
			    CALL cknum(I15,IROW,icol,dble(is_shares(11,ISTEP,if,jj-1989)),2,4)
            ENDDO
		  endif
        ENDDO
        icol=icol+1
      enddo


!**********************************************************
!  CLOSE THE SPREADSHEET FILE:
!**********************************************************

      irow=1
      read(i15,'(a)',rec=irow) longline
      nul=char(0)
      do while (.not. eof(i15))
         read(i15,'(a)',rec=irow,err=998) longline
         do i=1,irecl-2
           if(longline(i:i).eq.nul) longline(i:i)=' '
         enddo
         do i=irecl-2,1,-1
           if(longline(i:i).ne.','.and.longline(i:i).ne.' ') then
             exit
           else
             if(longline(i:i).eq.',') then
               longline(i:i)=' '
             endif
           endif
         enddo
         longline(irecl-1:irecl)=char(13)//char(10)
         write(i15,'(a)',rec=irow) longline
998      continue
         irow=irow+1
      enddo
      CLOSE(I15)

      RETURN
1002  continue
      write(6,*) ' error opening ', trim(blnkfile)
      notopen=.true.
      return
      END
      !*****************************************************

! This subroutine is common to the tech choice industries
      subroutine IAMatrix(IPRODX,irx)
      use i_
      implicit none

      REAL IPRODX(inumreg)               ! Regional Paper Production
      integer irx                        !region identifier
	  integer is,it
      INTEGER MAXSTPS                         !max steps
      PARAMETER (MAXSTPS=maxstep+1)
      real*4 xold(maxstps+1)
      REAL*4 IAold(MAXSTPS+1,MAXSTPS+1)      ! I-A Matrix of I/O Coefficients, Old capacity
      REAL*4 IAold_inv(MAXSTPS+1,MAXSTPS+1)  ! Inverse of I-A matrix of I/O Coefficients, New Capacity
      REAL*4 D(MAXSTPS+1)      ! vector of final demands (output). usually, only D(1) is nonzero.
      real*4 Det
      INTEGER DOWN_STEP ! Constants Used to Refer to Subscripts by Name
      REAL*8 Real8A1(MAXSTPS+1,MAXSTPS+1)
      REAL*8 Real8A2(MAXSTPS+1,MAXSTPS+1)
      real MinVert
      external MinVert

!******* Construct the I-A Matrix & Fill with PRODFLOW Elements ********
! Keep the "Old" Matrix name -- possibly rename, since we don't need a "New" one

      Xold(1:maxstps+1)                   = 0.
      IAold(1:MAXSTPS+1,1:MAXSTPS+1)      = 0.
      IAold_inv(1:MAXSTPS+1,1:MAXSTPS+1)  = 0.
      IAold(1,1)                          = 1.
      D(1:MAXSTPS+1)                      = 0.
      D(1)                                = IPRODX(irx)  ! Set up the demand vector

      DO IS=1,MPASTP                                      ! for each process step
        IAold(is+1,is+1) = 1.0                            ! 1s along dominant diagonal represent the Identity matrix
        DO IT=1,NTMAX(IS)                                 ! for each downstep.. (note, IT<>IS)
          DOWN_STEP = IPASTP(IS,IT)
          IAold(IS+1,down_step+1) = 0. -prodflow(1,is,it)
		 enddo
      enddo

! Invert the input-output matrices.
      DO IS=1,mpastp+1                                      !   Initialize inverted matrices as the identity matrix
        IAold_inv(is,is)=1.
      enddo
      det = MINVERT(IAold,IAold_inv,mpastp+1,mpastp+1,Real8A1,Real8A2,maxstps+1)  ! Check if Matrix is Singular
      if(det.eq.0. .and. prtdbgi.gt.1) then
         write(6,*) ' singular matrix: AIMAtrix, indreg=',irx
      endif
      Xold = MATMUL(IAold_inv , D)                          ! Calculate PRODCUR Elements for this year and region
      if(irx.eq.1) IS_IND_FLOW(:,:) = 0.                       ! Initialize the regional PRODCUR array
      IS_IND_FLOW(1:MPASTP,irx) = Xold(2:MPASTP+1)             ! Reassign X values to regional PRODCUR array
      PRODCUR(irx,1:MPASTP)= Xold(2:MPASTP+1)

	  return
      End Subroutine IAMatrix
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
! iron and steel industry submodule
! Called from: MODCAL
! Calls: IS_GETDATA, IS_ColdRoll, TECH_STEP, IS_Coke, IS_HotRollNoTech, IS_ContCastNoTech, IS_Steam, TECHSHR_RPT

 !steps         1: Hot Roll
 !              2: Cold Roll
 !              3: Continuous Casting
 !              4: BF/BOF
 !              5: EAF
 !              6a: DRI Feed to BOF
 !              6b: DRI Feed to EAF
 !              7: Coke

 !Notes:  These two iron and steel subroutines are called from subroutine MODCAL:
 !        IS_GETDATA        - Reads input for Iron and Steel industry
 !        prodflow_steel    - replaces CALPROD for iron and steel


       SUBROUTINE IronSteel_Industry
       use i_
       IMPLICIT NONE
	
       integer istep                               ! loop counter for steps

       call IS_ProdcurBreakout                     !assign prodcur national totals
       call IS_ColdRoll                            ! Step 2: No Technology Choice required
       call TECH_STEP(1)                             ! Call for each step that requires technology choice (hot roll)
       call IS_HotRollNoTech                       ! hot roll with no tech choices
	   do istep=3,7
          call TECH_STEP(istep)                      ! Call for each step that requires technology choice
		  if (istep.eq.3) call IS_ContCastNoTech   ! Continuous casting with no tech choice
       enddo
       call IS_Coke                                ! Step 8: Coke - No Technology Choice
	   call IS_Steam                               ! Steam demand
	   if (curiyr.eq.LASTYR) then
          call TECHSHR_RPT ! print the technology shares output file isteel.csv
       
       endif   
	   return
       END SUBROUTINE IronSteel_Industry

!*********************************************************************
! IRON and STEEL Industry Production Flow calculator
!
!Called from: MODCAL (replaces call to CALPROD)
!Calls: MINVERT, AveFPrc


      Subroutine PRODFLOW_STEEL
      use i_
      implicit none

      real AveFPrc         ! function returns ratio of a fuel price in year iy to price in base year
      external AveFPrc     ! for a given fuel (IFX) in a given census region
	  integer RTOVALUE
	  external RTOVALUE

	  integer INDBMOVR2
	  integer prcprm
	  

      INTEGER irx          ! Temporary regional index
      INTEGER ifx          ! Temporary fuel index
      INTEGER prx          !Index for proxy variables (4) used in calculating Cold-Rolled percentages
      INTEGER IS,IT        !loop counters
	  ! use IS_MAXSTPS here?
      INTEGER MAXSTPS                         !max steps
      PARAMETER (MAXSTPS=maxstep+1)
      real Cold_Pct(inumreg)                  !Initial Cold Percent


!****** Variables for Cold-Roll Percentage *******
      Real MacroProxy(inumreg,4)              ! Temporary array to hold Macro output (region, industry)
      Real Cold_Proxy(inumreg)                ! Intermediate value used to construct Cold_Index
      Real Cold_BYR(inumreg)                  ! Holds regional values in Base Year (2010)
      Real Cold_Index(inumreg)                ! Index to adjust cold-roll percent for PRODFLOW

!****** Variables for PHDRAT Adjustment *********
      Real Val_Add                            ! Value added to price of cold rolled steel (percent)
      Real Base_Price(inumreg)                ! Baseline steel price, linked to 2010 MECS data
      REAL New_Price(inumreg)                 ! Implied price of hot rolled steel, given price margin and cold share
      REAL PRODVX_Steel(inumreg)              ! Regional Value of Steel Production

!****** Variables for EAF/BOF Adjustment ********
      REAL Normalize(inumreg)                 ! Regional total to which EAF/BOF shares will be normalized
     ! REAL IS_Alpha_Furnace                   ! Sensitivity Parameter (Currently uniform across regions/fuels, for simplicity)
      REAL EAF(inumreg)                       ! Temporary holding variable: EAF Share of Production
      REAL BOF(inumreg)                       ! Temporary holding variable: BOF Share of Production
      REAL EAF_Fact(inumreg)                  ! Modified value for EAF Element
      REAL BOF_Fact(inumreg)                  ! Modified value for BOF Element
	  REAL BOF_Fact_curitr1(inumreg)          ! avoid accumulation over iterations of BOF percentage
	  REAL EAF_Fact_curitr1(inumreg)          ! avoid accumulation over iterations of EAF percentage
      REAL BOF_Fact_Lag(inumreg)              ! Lagged value of BOF Element, also used in calculating Coke Element
      REAL EAF_Fact_Lag(inumreg)              ! Lagged value of EAF Element,
     ! REAL IS_Max_Delta                       ! Constraint on annual changes to EAF/BOF shares

!****** Variables for DRI Factors ***************

      REAL EAF_Share                          ! Maximum percentage of EAF production that may be supplied by DRI
      REAL BOF_Share                          ! Minimum percentage of DRI production that must go to BOFs
      REAL DRI_Tot(inumreg)
      REAL DRI_Fact(2,inumreg)                ! PRODFLOW Factors (IS=6) associated with (1)BOF and (2)EAF
      REAL PriceFac(2)                        ! Price change since base year, expressed as ratio
      REAL PriceFacLag(2)                     ! lagged price change since base year, expressed as ratio KP add22
      REAL PriceDelta(7)                      ! change in price from this year to last year

!***** Variables for Coke Factors *****************
      REAL Coke_Calib                         ! Adjustable factor to calibrate Coke/BOF ratio
      REAL Coke_Fact(inumreg)                 ! PRODFLOW Factors (IS=7) associated with Coke production
      REAL Coke_Fact_Lag(inumreg)             ! Lagged value of Coke_Fact

!******* Variables for PRODCUR Calculations ***********
      integer IX,IY

 !******* Variables for BOF/EAF shares calc
      real shares2(2)                         ! Technology shares for current year
      real*16 logit_calc                      ! logit function
      real*16 scale_fctr2                     ! scale factor function
      integer inumtech, stepnum
      real scale_fac
      real scale_min                          ! Minimum scale factor
      real scale_adj                          ! Scale Adjustment
      real*16 logit_comp(2)                   ! Logit component
      real*16 scale_comp
      real logit_steam ,ann_cc, totfixcst(2),crf
	  integer testyear(4)

      integer RGNMAP(inumreg,2)               ! census region mapping (census regions 1-2 are covered by IDM region 1, 3-4 by IDM region 2, 5-7 by IDM region 3, 8-9 by IDM region 4)
	  DATA RGNMAP /1,3,5,8, &
	               2,4,7,9/

 !    EAF_Share = 1                                  ! No more than 5% of EAF output may be from DRI
!        BOF_Share = 0.1                                ! A minimum of 50% of DRI production must go to BOF



      !!! ************************   new  ******************************************************************************************************************************** !!!!!!!!!!!!!!!!!!!

        inddir=12
        stepnum=8  !BOF/EAF Shift
        logit_steam=0.0
      !***** Calculate the Annualized Cost  *************************
        crf=is_wacc(inddir)*(1.0+is_wacc(inddir))**is_lifetime(inddir)/((1.0+is_wacc(inddir))**is_lifetime(inddir)-1.0) ! Same for all technologies
        DO inumtech=1,2                                     ! For Each Competing Technology
           ann_cc = crf * is_capcost(inddir,stepnum,inumtech)                          ! Annualized Capital Cost of Technology
           totfixcst(inumtech) = ann_cc + is_av_OM(inddir,stepnum,inumtech)    ! Total Fixed Cost of Technology
	ENDDO
        DO inumtech=1,2  ! EAF, BOF
           scale_comp = scale_fctr2(is_logit_coeff(inddir,:,stepnum),                 & ! Function to calculate the un-exponentiated logit component
                                totfixcst(inumtech),     &
                                IS_fuel_use(inddir,stepnum,:,inumtech), &
                                IS_emiss(inddir,stepnum,inumtech),      &
                                is_co2penalty(inddir,curiyr),           &
                                is_alpha_decay(inddir,:),                  &
                             !    t_is_alpha_decay(scenario,inddir,inumtech,:,stepnum), &
                                is_alpha(inddir,stepnum,inumtech),logit_steam,obsoleteyr(inddir,stepnum,inumtech),stepnum,1)

            IF (scale_comp.lt.scale_min) scale_min = scale_comp            ! Select the smallest value generated by the various technologies
        ENDDO

        IF (scale_min.LT.(- scale_adj)) THEN                           ! Test if the value falls below a pre-set minimum
           scale_fac = -(scale_min + scale_adj)                       ! If so, add a constant factor to bring calculations back into line
        ELSE                                                         ! Otherwise,
           scale_fac = 0.0                                            ! Don't bother adjusting
        ENDIF

        DO inumtech=1,2  ! EAF, BOF

            logit_comp(inumtech) = logit_calc(is_logit_coeff(inddir,:,stepnum),                  &
                                          totfixcst(inumtech),     &
                                          IS_fuel_use(inddir,stepnum,:,inumtech), &
                                          IS_emiss(inddir,stepnum,inumtech),      &
                                          is_co2penalty(inddir,curiyr),           &
                                          is_alpha_decay(inddir,:),               &
                                          is_alpha(inddir,stepnum,inumtech),      &
                                          scale_fac,logit_steam,obsoleteyr(inddir,stepnum,inumtech),stepnum,1)
        ENDDO
        CALL shares_calc(logit_comp,shares2,2)

        EAF_Share = shares2(1)
        BOF_Share = shares2(2)

      !  if (curitr.eq.1)  write(IUNITBUG,*) 'debug new shares',shares2(1),shares2(2)
      !!!!!!!!!   new  ********************************************************************************************************************************************************************!!!!!!!!!!!!!!!!!


      DO irx = 1,inumreg                                   ! Loops through all census regions

!****************** Get Macro Data and Squish it Into Shape *****************
! Get data for the 4 proxy variables & consolidate to census region
!prx = 1: Fabricated Metals; 2: Machinery; 3: Transportation Equipment; 4: Construction
        DO prx = 1,4
            MacroProxy(irx,prx)=SUM(OUTIND(ndx(prx),rgnmap(irx,1):rgnmap(irx,2)))                  ! Consolidate divisional values within each region
        ENDDO
	PRODVX_Steel(irx)=SUM(OUTIND(inddir,rgnmap(irx,1):rgnmap(irx,2)))   ! Consolidate divisional values of steel production
   !  POT_2050STEEL arbitrary region change delete when macro change
        PRODVX_STEEL(irx) = PRODVX_Steel(irx) * (OUTIND(inddir,11)/SUM(OUTIND(inddir,1:10)))

        !NSK 10/2021
	! kpe new steel values for 2014 - 2016	- added 10/09/17
	! first for ibyr2 POT_ibyr2, apportioning out regional values by shipments, then 2015 and 2016
	! the legacy code is using PHDRAT for this, which doesn't make a lot of sense
! I think these hard codes should remain at the original years (ibyr2, ibyr2+1, ibyr2+2)?
!	if (curcalyr.eq.ibyr2) then
!		PRODX_Base(inddir,1) = 86878.0 * (sum(OUTIND(inddir,1:2))/OUTIND(inddir,11)) * 1000 ! scaling it to conform to prodx - from 000 tonnes to just tonnes
!		PRODX_Base(inddir,2) = 86878.0 * (sum(OUTIND(inddir,3:4))/OUTIND(inddir,11)) * 1000 !
!		PRODX_Base(inddir,3) = 86878.0 * (sum(OUTIND(inddir,5:7))/OUTIND(inddir,11)) * 1000
!		PRODX_Base(inddir,4) = 86878.0 * (sum(OUTIND(inddir,8:9))/OUTIND(inddir,11)) * 1000
!	endif

!	if (curcalyr.eq.ibyr2+1) then
!		PRODX_Base(inddir,1) = 88174.0 * (sum(OUTIND(inddir,1:2))/OUTIND(inddir,11)) * 1000 ! scaling it to conform to prodx
!		PRODX_Base(inddir,2) = 88174.0 * (sum(OUTIND(inddir,3:4))/OUTIND(inddir,11)) * 1000 !
!		PRODX_Base(inddir,3) = 88174.0 * (sum(OUTIND(inddir,5:7))/OUTIND(inddir,11)) * 1000
!		PRODX_Base(inddir,4) = 88174.0 * (sum(OUTIND(inddir,8:9))/OUTIND(inddir,11)) * 1000
!	endif


!	if (curcalyr.eq.ibyr2+2) then
!		PRODX_Base(inddir,1) = 78500.0 * (sum(OUTIND(inddir,1:2))/OUTIND(inddir,11)) * 1000
!		PRODX_Base(inddir,2) = 78500.0 * (sum(OUTIND(inddir,3:4))/OUTIND(inddir,11)) * 1000
!		PRODX_Base(inddir,3) = 78500.0 * (sum(OUTIND(inddir,5:7))/OUTIND(inddir,11)) * 1000
!		PRODX_Base(inddir,4) = 78500.0 * (sum(OUTIND(inddir,8:9))/OUTIND(inddir,11)) * 1000
!	endif

	! ****************** end kpe additions 10/9/17 ***********************
	  !************* Calculate Cold-Rolled Percentage ******************
        Cold_Proxy(irx) = sum(MacroProxy(irx,1:3))/sum(MacroProxy(irx,1:4)) ! Infer share of production to cold-rolled steel
        if (curcalyr.eq.ibyr2+1) Cold_BYR(irx) = Cold_Proxy(irx)             ! Set base year value for indexing
        Cold_Index(irx) = Cold_Proxy(irx)/Cold_BYR(irx)                     ! Index subsequent years to base year
        Cold_Pct(irx) = Cold_Index(irx) * Base_Cold(irx)                    ! Adjust initial Cold Percent to reflect changes in mfg output

!************** Adjust PHDRAT/PRODX ********************
        Val_Add = 0.15                                                      ! Fixed, ad-hoc assignment for price premium

        if ((curcalyr.ge.ibyr2).AND.(curcalyr.le.ibyr2+2)) then                                        ! Base Year (ibyr2) Calculations POT_ibyr2
            PRODX_Steel(irx)  = PRODX_Base(inddir,irx)  / 1000.0                ! Initialize Base Year Values, in 1000 Tonnes - looks silly because I just multiplied by 1000, but this is all over the program

           Base_Price(irx) = (PRODVX_Steel(irx)/PRODX_Steel(irx)) &          ! Value calculated for base year (2010), & held constant after.
                          /(1+ Val_Add * Cold_Pct(irx))                      ! Not sure of units, may need to adjust scale
        else
        New_Price(irx) = Base_Price(irx) * (1+ Val_Add * Cold_Pct(irx))     ! Adjust price to account for changing cold-roll %
        PRODX_Steel(irx) = PRODVX_Steel(irx) / New_Price(irx)               ! Price-adjusted volume of steel production-
		endif

        if (inddir.eq.12) write(IUNITBUG,'(A,F12.2,F10.2,F16.2,F12.2,2I5,2I3)') &
                'PRODX_Steel, PRODVX_Steel, PRODX_Base(), PHDRAT, CURCALYR, CURIYR, inddir region', &
                 PRODX_Steel(irx),PRODVX_Steel(irx),PRODX_Base(12,irx),PHDRAT,CURCALYR,CURIYR,inddir,irx

!*************** Calculate EAF/BOF Shares of Production *************
! Based on changes in fuel prices from base year (2010) for Electricity (ifx=1) and NG (ifx=3) I think.
! IN this section, adding hard codes to account for decline in primary steel production froom 2014=2016 kpe add 10/9/17
	! begin kpe addition 10/9/17
    ! NSK 10/2021
	 !if (irx.eq.2) then
	!	if(curcalyr.eq.ibyr2+1) Base_EAF(irx) = 0.55    !  takes account of the precipitous decline of BOF steel in Region 2 POT_ibyr215
	!	if (curcalyr.ge.2016) Base_EAF(irx) = 0.6	 !	- the midwest - this has a big effect
	!	Base_BOF(irx) = 1 - BASE_EAF(irx)
     !endif

!      IS_Alpha_Furnace = -2.0 (now read from ironstl.xml)    ! Ad-hoc sensitivity parameter for EAF/BOF Shares
        Normalize(irx) = Base_EAF(irx) + Base_BOF(irx)                      ! Subject to change, given greater wisdom
        
		prcprm = 0
		prcprm = min(5,max(0,curiyr-(ibyr2-1989)))            ! so that we incrase price parameter slowly until it reaches 3
															 ! which still seems arbitrary as hell
		! prcprm = 5                 ! 5 year change in price refcase
		! if (INDBMOVR2.eq.2) prcprm = 2 ! 2 year price change in the sides
		! if (curiyr-prcprm.lt.ibyr2-1989) prcprm=0 ! but don't go out of bounds in the first years
		
!PGR        do ifx=1,2 !elec, ng
        do ifx = 7,7  ! steam coal only
           ! PriceFac(ifx) = AveFprc(irx,ibyr2-1989,curiyr,(2*ifx-1)+1)          ! AveFPrc returns price change since base year (2010)
		   ! PriceFacLag(ifx) = AveFprc(irx,ibyr2-1989,curiyr-prcprm,(2*ifx-1)+1)     ! Price change since year before base year
		     
           PriceDelta(ifx) = 4.0 * pclin(11,curiyr) / (pclin(11,curiyr-1) + &
		                              pclin(11,curiyr-2) + &
									  pclin(11,curiyr-3) + & 
									  pclin(11,curiyr-4) )

!			write (6,*) 'pclin before ',pclin(11,curiyr), pclin(11,curiyr-1),pclin(11,curiyr-2), &
!			   pclin(11,curiyr-3),pclin(11,curiyr-4)
!            write (6,*) 'price delta before = ',PriceDelta(ifx)

! ********************* test accelerated coal price increase		    
!			write (6,*) 'pclin after ', pclin(11,curiyr) * (1.0 + exp(-0.3*(61 - curiyr))), & 
!									    pclin(11,curiyr-1) * (1.0 + exp(-0.3*(61 - (curiyr - 1)))), &
!		                                pclin(11,curiyr-2) * (1.0 + exp(-0.3*(61 - (curiyr - 2)))), &
!									    pclin(11,curiyr-3) * (1.0 + exp(-0.3*(61 - (curiyr - 3)))), & 
!									    pclin(11,curiyr-4) * (1.0 + exp(-0.3*(61 - (curiyr - 4))))
!			PriceDelta(ifx) = 4.0 * pclin(11,curiyr) * (1.0 + exp(-0.3*(61 - curiyr))) / & 
!									 (pclin(11,curiyr-1) * (1.0 + exp(-0.3*(61 - (curiyr - 1)))) + &
!		                              pclin(11,curiyr-2) * (1.0 + exp(-0.3*(61 - (curiyr - 2)))) + &
!									  pclin(11,curiyr-3) * (1.0 + exp(-0.3*(61 - (curiyr - 3)))) + & 
!									  pclin(11,curiyr-4) * (1.0 + exp(-0.3*(61 - (curiyr - 4)))) )
!           write (6,*) 'price delta after = ',PriceDelta(ifx)

!		   PriceDelta(ifx) = AveFprc(irx,curiyr-prcprm,curiyr,ifx)   ! if this works, let's use (simplified via PGR 07/2022)
		  								! kpe change: 10/9/17 - rather than using a cumulative
																			  ! price change, make it a marginal price change. Can be
																			  ! further improved to use only a persistent price change
																			   ! for example, if a 5 year price range exceeds a certain threshold
        ENDDO
    	if (curcalyr.eq.ibyr2+1) then                              ! Save the Lagged value of BOF_Fact last MECS year
           testyear(irx) = curcalyr									   ! avoids mysterious accumulation of results
           BOF_Fact_Lag(irx) = Base_BOF(irx)                       ! for use in calculating the change in
           EAF_Fact_Lag(irx) = Base_EAF(irx)                       ! the Coke PRODFLOW element.
           BOF(irx) = Base_BOF(irx)
		   EAF(irx) = Base_EAF(irx)
        else                                                       ! Also, use lagged values to constrain the magnitude
           BOF_Fact_Lag(irx) = BOF_Fact(irx)                    ! of annual change in the shares of output
           EAF_Fact_Lag(irx) = EAF_Fact(irx)
        endif

           if (testyear(irx).eq.curcalyr) then

             if (BOF_Fact_Lag(irx).lt.0.15) then  ! BF/BOF percent cannot keep declining if below a minimum threshold
!                write (6,*) 'fail safe'
				BOF(irx) = BOF_Fact_Lag(irx)
				EAF(irx) = EAF_Fact_Lag(irx)
             else
			    continue
				if (PriceDelta(7).le.1.0) then
				   BOF(irx) = BOF_Fact_Lag(irx) - 0.001 ! minimum decline in BOF portion of steel production if price of coal 
				                                         ! does not increase, i.e., the natural trend towards more EAF will
														 ! continue regardless
!                   write (6,*) 'PriceDelta is less than 1'														 
                else
				   continue				   
!				   write (6,*) '1.0 - PriceDelta(7)**IS_Alpha_Furnace(irx) = ', 1.0 - PriceDelta(7)**IS_Alpha_Furnace(irx)
				   if (curcalyr.gt.ibyr2+1 .and. 0.02 * (1.0 - PriceDelta(7)**IS_Alpha_Furnace(irx)).ge.0.001) then
				      BOF(irx) = BOF_Fact_Lag(irx) - 0.02 * (1.0 - PriceDelta(7)**IS_Alpha_Furnace(irx))  ! PGR
!				      write (6,*) 'no min'
                   else ! 
				      BOF(irx) = BOF_Fact_Lag(irx) - 0.001 ! BOF percentage must decline by the minimum
!					  write (6,*) 'hit min'
                   end if
			 end if !PGR
             EAF(irx) = EAF_Fact_Lag(irx) + (BOF_Fact_Lag(irx) - BOF(irx)) ! increase in EAF = decrease in BOF

             end if
!			 write (6,*) 'BOF(irx) after = ',BOF(irx)
!	         write (6,*) 'EAF(irx) after = ',EAF(irx)
!	         write (6,*)
!			 write (6,*)
             EAF_Fact(irx) = Normalize(irx) * EAF(irx) / (EAF(irx) + BOF(irx))   ! Normalize PRODFLOW Element (IS=5, IT=1)
             BOF_Fact(irx) = Normalize(irx) * BOF(irx) / (EAF(irx) + BOF(irx))   ! Normalize PRODFLOW Element (IS=4, IT=1)
		     testyear(irx) = curcalyr + 1
           end if ! avoid accumulation of iterations to results
		


      !********* Calculate DRI PRODFLOW Elements *************
! Based on Exogenous projections of total DRI production, allocated between EAF and BOF, backed into a PRODFLOW element


        DRI_Tot(irx) = 0.0                                                 ! Initialize
        IF (curcalyr.ge.Phase1_YR(irx)) DRI_Tot(irx) = DRI_Tot_Phase1(irx) * 1000.   ! Specified initial capacity (convert to 1000 Tonnes)
        IF (curcalyr.ge.Phase2_YR(irx)) DRI_Tot(irx) = DRI_Tot_Phase2(irx) * 1000.   ! Specified final capacity (convert to 1000 Tonnes)

        DRI_BOF(irx) = DRI_Tot(irx) * BOF_Share &                          ! Minimum tonnage to BOF, plus
                    + MAX(0.,(DRI_Tot(irx) * (1.0-BOF_Share) &           ! Remainder after maximum tonnage is given to EAF.
                           - (PRODX_Steel(irx) * EAF_Fact(irx) * EAF_Share))) !

        DRI_EAF(irx) = DRI_Tot(irx) - DRI_BOF(irx)                         ! Whatever doesn't go to BOF goes to EAF

        if ((PRODX_Steel(irx) * BOF(irx)) .ne.0.0) then
           DRI_Fact(1,irx) = DRI_BOF(irx) / (PRODX_Steel(irx) * BOF(irx))     ! PRODFLOW Element: IS=6, IT=1
        else
           DRI_Fact(1,irx) =0.0
        endif
        if ( (PRODX_Steel(irx) * EAF(irx)) .ne.0.0) then
           DRI_Fact(2,irx) = DRI_EAF(irx) / (PRODX_Steel(irx) * EAF(irx))     ! PRODFLOW Element: IS=6, IT=2
        else
           DRI_Fact(2,irx) =0.0
        endif

!******** Calculate Coke PRODFLOW Elements **************
        Coke_Calib = 0.60

        IF (curcalyr.eq.ibyr2+1) Coke_Fact(irx) = Base_Coke(irx)

        Coke_Fact_Lag(irx) = Coke_Fact(irx)
        if (BOF_Fact_Lag(irx).ne.0.0) then
          Coke_Fact(irx) = Coke_Fact_Lag(irx) &
                       *(1.0 + Coke_Calib*(BOF_Fact(irx)/BOF_Fact_Lag(irx) -1.0))
	else
	    Coke_Fact(irx)=0.0
	endif

!******** Construct the PRODFLOW Array by manually inserting the factors calculated above *********

        do is=2,MPASTP
          do IT=1,NTMAX(IS)    ! for each downstep: In most cases, NTMAX = 1, so it's just one number.
             if (is.eq.2) then    ! Cold Rolling
              prodflow(1,is,it) = Cold_Pct(irx)           ! Won't need both old and new vintages, but keep both temporarily
              prodflow(2,is,it) = Cold_Pct(irx)
            else if (is.eq.4) then         ! BF/BOF
              prodflow(1,is,it) = BOF_Fact(irx)           ! Won't need both old and new vintages, but keep both temporarily
              prodflow(2,is,it) = BOF_Fact(irx)
            else if (is.eq.5) then   ! EAF
              prodflow(1,is,it) = EAF_Fact(irx)           ! Won't need both old and new vintages, but keep both temporarily
              prodflow(2,is,it) = EAF_Fact(irx)
            else if (is.eq.6) then    !DRI
              prodflow(1,is,it) = DRI_Fact(it ,irx)        ! Won't need both old and new vintages, but keep both temporarily
              prodflow(2,is,it) = DRI_Fact(it,irx)
		   else if (is.eq.7) then              ! Coke
              prodflow(1,is,it) = Coke_Fact(irx)          ! Won't need both old and new vintages, but keep both temporarily
              prodflow(2,is,it) = Coke_Fact(irx)
           endif
          enddo
        enddo

!******* Construct the I-A Matrix & Fill with PRODFLOW Elements ********
        call IAMatrix(PRODX_Steel,irx)

	IF (irx.eq.4) THEN                                    ! After calculating the final region,
          DO IS=1,MPASTP
             IS_IND_FLOW(is,5) = SUM(IS_IND_FLOW(is,1:4))           ! Add across regions to get national total: Units = 1000 Tonnes

	  ENDDO
        ENDIF

      ENDDO  ! End regional loop


	                                     ! After calculating the final region,
      DO IS=1,MPASTP
        IS_IND_FLOW(is,5) = SUM(IS_IND_FLOW(is,1:4))           ! Add across regions to get national total: Units = 1000 Tonnes

	 ENDDO

!******* Calculate regional shares of output by process step.  Used to allocate fuel demand later ***************

      DO IS=1,MPASTP
       DO irx = 1,4
	   if (IS_IND_FLOW(is,5) .ne.0.0) then
          IND_FLOW_SHARE(inddir,is,irx) = IS_IND_FLOW(is,irx) / IS_IND_FLOW(is,5)    ! Calculate regional shares of output by process step
  	   else
	      IND_FLOW_SHARE(inddir,is,irx) =0.0
	   endif
	   ENDDO
	   prodcurrpt(IS,curiyr)=SUM(PRODCUR(1:4,IS)) !save for TECHSHR_RPT
      ENDDO
      End Subroutine PRODFLOW_STEEL

!*******************************************************************************************
!Cold-Rolling Steel Production
! Called by: IronSteel
! Calls : none
!
!Sub Processes:          1)Cold Roll Reduction!
!                        2)Galvanize!
!                        3)Electroclean
!                        4)Anneal/Temper
!                        5)Tin Plate
!                        6)Electric Steel
!
!Fuels:               1) Natural GAs
!                        2) Electricity
!                        3) HFO
!
      Subroutine IS_ColdRoll
      use i_
      implicit none

      integer nsubproc                                    ! Number of Sub-Processes
      integer isubproc                                    ! Loop counter for sub process
      integer nfuel                                       ! Number of fuels
      integer stepnum                                     ! Steel process step

      PARAMETER (nsubproc=6)
      PARAMETER (nfuel=3)

      Real flow(nsubproc)                                 ! Flows by sub process (1000 Tonnes)
      real consumption(nfuel,nsubproc)                    ! Consumption for each fuel and Sub-Process (Trils)
      REAL CO2_COLD(nsubproc)                             ! CO2 Emissions for each Sub-Process (million tonnes)


      stepnum   = 2                         ! Cold Roll is Step 2

!****** Calculate Flows for Each Sub-Process (1000 Tonnes) **************************

     flow(1) = SUM(PRODCUR(1:4,stepnum))   ! PRODCUR for Step 2, Summed across regions
     flow(2) = flow(1) * iscr_shares(2)
     flow(3) = flow(1) * iscr_shares(3)
     flow(4) = flow(3) * iscr_shares(4)
     flow(5) = flow(3) * iscr_shares(5)
     flow(6) = flow(3) * iscr_shares(6)

!****** Calculate Energy Consumption & Emissions for Each Sub-Process *****************

      do ISUBPROC=1,2
        consumption(1,isubproc) = flow(isubproc) * NG_Share  * Intensity(1,isubproc) /1000000     ! NG Demand (Trils)
        consumption(2,isubproc) = flow(isubproc) * Intensity(2,isubproc) /1000000                 ! Elec Demand (Trills)
        consumption(3,isubproc) = flow(isubproc) * HFO_Share * Intensity(3,isubproc) /1000000     ! HFO Demand (Trils)
        CO2_COLD(isubproc)  = flow(isubproc) * (NG_Share  * CO2_Intensity(isubproc,1) &           ! CO2 Emissions (million tonnes)
                                + HFO_Share * CO2_Intensity(isubproc,2)) /1000000

      enddo

      do ISUBPROC=3,nsubproc
        consumption(1,isubproc) = flow(isubproc) * Intensity(1,isubproc)  /1000000                ! NG Demand (Trils)
        consumption(2,isubproc) = flow(isubproc) * Intensity(2,isubproc) /1000000                 ! Elec Demand (Trills)
        consumption(3,isubproc) = flow(isubproc) * Intensity(3,isubproc) /1000000                 ! HFO Demand (Trils)
        CO2_COLD(isubproc)  = flow(isubproc) * CO2_Intensity(isubproc,1) /1000000                 ! CO2 Emissions (million tonnes) (NG & HFO Shares no longer relevant)
      enddo

!***** Aggregate Across Step 2 Sub-Processes ********************************************

      NgCons(stepnum,curiyr)   = SUM(consumption(1,1:nsubproc))                                ! NG Consumption for Step 2 (Trils)
      HFOCons(stepnum,curiyr)  = SUM(consumption(3,1:nsubproc))                               ! HFO Consumption for Step 2 (Trils)
      ElecCons(stepnum,curiyr) = SUM(consumption(2,1:nsubproc))                              ! Electricity Consumption for Step 2 (Trils)
      CO2_Tech(stepnum,curiyr)  = SUM(CO2_COLD(1:nsubproc))                               ! CO2 Emissions for Step 2 (million tonnes)

      return
      end


	!*******************************************************
! Hot Rolling Steel Production with No Technology Choices
!Called from: IronSteel_Industry
!Calls: q_interp2

	  Subroutine IS_HotRollNoTech
	  use i_
      implicit none

	  integer stepnum                  ! Steel process step
	  real hotshares(11)                ! hotroll shares by product
      Real flow(3)                     ! Flows by product (1000 Tonnes)
      real consumption(3,4)            ! Consumption for each fuel and product(blooms,billets,slab,slab skin (Trils)
      REAL HRCO2_emiss(2)                ! CO2 Emissions for blooms and billets (million tonnes)
	  real steel_output
	  real forecast
	  real q_interp2
	  integer ii
	  integer ifuel

      stepnum=1  !Hot Roll step

      steel_output = SUM(PRODCUR(1:4,stepnum))   ! PRODCUR for Step 1, Summed across regions
	  do ii=1,3
        flow(ii) = steel_output * formshares(ii)
      enddo

      do ii=2,12
        forecast=q_interp2(shrfinal(1),shrstart(1),shrfinal(ii),shrstart(ii),curiyr+1989.0)
        If(shrfinal(1).gt.shrstart(1)) then
	      hotshares(ii-1)=MIN(forecast,shrfinal(ii))
	    else
	      hotshares(ii-1)=MAX(forecast,shrfinal(ii))
	    endif
      enddo


!****** Calculate Energy Consumption & Emissions *****************

	 do ifuel=1,3
        consumption(ifuel,1) = flow(1) * (hotshares(1)*bloomtubes(ifuel)+(1.0-hotshares(1))*bloomstruct(ifuel)) /1000000.0
      enddo
      HRCO2_Emiss(1) = flow(1) * (hotshares(1)*bloomtubes(4)+(1.0-hotshares(1))*bloomstruct(4)) /1000.0     ! CO2 Emissions million tonnes

      do ifuel=1,3
        consumption(ifuel,2) = flow(2) * (hotshares(4)*billrod(ifuel)+hotshares(3)*billbar(ifuel)+hotshares(5)*billshape(ifuel)) /1000000.0
      enddo
      HRCO2_Emiss(2) = flow(2) * (hotshares(4)*billrod(4)+hotshares(3)*billbar(4)+hotshares(5)*billshape(ifuel)) /1000.0     ! CO2 Emissions million tonnes

      do ifuel=1,2
        consumption(ifuel,3) = flow(3) * (hotshares(6)*slabtech1(ifuel)+hotshares(7)*slabtech2(ifuel)) /1000000.0
      enddo

      do ifuel=1,2
        consumption(ifuel,4) = flow(3) * (hotshares(9+ifuel)*slabskin(ifuel)) /1000000.0
      enddo


!***** Add consumption to values previously calculated in hot roll with technology choice ********************************************

      NgCons(stepnum,curiyr)   = NgCons(stepnum,curiyr)+SUM(consumption(1,1:2))                                ! NG Consumption for Step 2 (Trils)
      HFOCons(stepnum,curiyr)  = HFOCons(stepnum,curiyr)+SUM(consumption(2,1:2))                               ! HFO Consumption for Step 2 (Trils)
      ElecCons(stepnum,curiyr) = ElecCons(stepnum,curiyr)+&
	                             SUM(consumption(3,1:2))+ &
								 SUM(consumption(1:2,3))+ &
								 SUM(consumption(1:2,4)) ! Electricity Consumption for Step 2 (Trils)
      CO2_Tech(stepnum,curiyr)  = CO2_Tech(stepnum,curiyr)+SUM(HRCO2_Emiss(1:2))                               ! CO2 Emissions for Step 2 (million tonnes)

      return
      end

!*******************************************************
! Continuous Casting Production with No Technology Choices
! Called from: IronSteel_Industry
! Calls: q_interp2

      Subroutine IS_ContCastNoTech
      use i_
      implicit none

      real steel_output
      real forecast   !forecasted ng shares
      real q_interp2
      integer stepnum,ii
      real consumption(4)             !ng,hfo,elec,co2
	  real ng_share2

      stepnum=3
      steel_output = SUM(PRODCUR(1:4,stepnum))   ! PRODCUR for Step 3, Summed across regions
      forecast=q_interp2(cc_shrfinal(2),cc_shrstart(2),cc_shrfinal(1),cc_shrstart(1),curiyr+1989.0)
      if(cc_shrfinal(2).gt.cc_shrstart(2)) then
        ng_share2=MIN(forecast,cc_shrfinal(1))
      else
        ng_share2=MAX(forecast,cc_shrfinal(1))
      endif

      do ii=1,4
        consumption(ii) =steel_output*(ng_share2*cc_ngas(ii) + (1-ng_share2)*cc_oil(ii))/1000000
      enddo

!***** Add consumption to values previously calculated in continuous casting with technology choice ********************************************

      NgCons(stepnum,curiyr)   = NgCons(stepnum,curiyr)+consumption(1)        ! NG Consumption for Step 3 (Trils)
      HFOCons(stepnum,curiyr)  = HFOCons(stepnum,curiyr)+consumption(2)     !HFO Consumption for Step 3 (Trils)
      ElecCons(stepnum,curiyr) = ElecCons(stepnum,curiyr)+consumption(3)  !ELEC Consumption
      CO2_Tech(stepnum,curiyr)  = CO2_Tech(stepnum,curiyr)+consumption(4)      ! CO2 Emissions for Step 3 (million tonnes)

      return
      end

!************************************************************************
! Coke Steel Production
! Called from: IronSteel_Industry
! Calls: none

      Subroutine IS_Coke
	  use i_
      implicit none

	  integer stepnum
	  REAL DRI_BOF_TOT(17:MNUMYR)             ! National Tonnage of DRI devoted to BOF
	  REAL BOF_X_DRI(17:MNUMYR)               ! National Total Non-DRI BOF steel production
	  REAL Net_Coke                           ! Reduced required Coke by DRI avoided production
	  REAL Coke_Prod                          ! Required production of Coke, considering net imports
	  REAL NI_Coeff(2)
	  REAL NI_Max_Shr
	  REAL Coke_Conversion
	  REAL Coke_Process(4) !breeze,cog,tars,lt oil
	  REAL netcog  !net COG production
	  integer ii,irg !counters
	  INTEGER MAXSTPS
      PARAMETER (MAXSTPS=maxstep+1)
	  INTEGER INDBMOVR,INDBMOVR2
	  EXTERNAL RTOVALUE
	  INTEGER RTOVALUE
	  INDBMOVR2 = RTOVALUE('INDBMOVR',0)

      NI_Coeff(1)     = -0.3872
      NI_Coeff(2)     = 0.1239
      NI_Max_Shr      = 0.10
      Coke_Conversion = 0.39                                     ! Average Tonnes of Coke per Tonne of BOF Steel

      stepnum = 7                                                ! Step 7:  Coke demand

!***** Calculate Coke Production Required to Meet Demand **************

      DRI_BOF_TOT(curiyr) = SUM(DRI_BOF(1:4))                    ! Total DRI to BOF, for Coke Calculation
      BOF_X_DRI(curiyr)   =  is_IND_FLOW(5,4)   - DRI_BOF_TOT(curiyr)  ! Total Non-DRI BOF steel production;
      Net_Coke = is_IND_FLOW(stepnum,5) - (DRI_BOF_TOT(curiyr))*(Coke_Conversion)  ! Reduce required Coke by DRI avoided production ;

	  IF (CURIYR .LE. MSEDYR) THEN
	    NI_COKE(CURIYR) = QSCIIN(11,CURIYR) * 36.57644
      ELSE IF ( (CURIYR .GT. MSEDYR) .AND. (CURCALYR .LE. STEOLASTYR)) THEN
		NI_COKE(CURIYR) = STEOQ(CURCALYR,17) * 36.57644
	  ELSE
        NI_Coke(curiyr) = NI_Coke(curiyr-1) &
            + NI_Coeff(1) * (NI_Coke(curiyr-1) - NI_Coke(curiyr-2)) &
            + NI_Coeff(2) * (BOF_X_DRI(curiyr) - BOF_X_DRI(curiyr-1))
      ENDIF

      NI_Coke(curiyr) = MAX(NI_Coke(curiyr),(-1.0) * Net_Coke * NI_Max_Shr)  ! Set minimum negative value of NI_Coke (i.e., maximum exports)
      Coke_Prod = Net_Coke - NI_Coke(curiyr)                                 ! Required production of Coke, considering net imports

!***** Calculate Energy Required to Produce Coke **************
       ElecCons(8,curiyr) =Coke_Prod*IS_CEnergy_Use(1)/1000000.0
       NgCons(8,curiyr)  =Coke_Prod*IS_CEnergy_Use(2)/1000000.0
       HFOCons(8,curiyr)=Coke_Prod*IS_CEnergy_Use(3)/1000000.0
       CoalMCons(8,curiyr) =Coke_Prod*IS_CEnergy_Use(5)/1000000.0
	   STM_Steel(8)=Coke_Prod*IS_CEnergy_Use(4)*1.054615
!***** Calculate Coke Process Outputs *************************

    do ii=1,4 !breeze,cog,tars,lt oil
      Coke_Process(ii)=Coke_Prod*IS_CProcess(ii)
    enddo
! adjust NG by subtracting COG
    netcog=(coke_process(2)-Coke_Prod*IS_CEnergy_Use(7))/1000000.0 !net cog production
	NgCons(8,curiyr)=NgCons(8,curiyr)-netcog

    END SUBROUTINE IS_COKE

!***********************************************************************************************************
! This subroutine totals Steam and shares it out to the 4 industrial regions. It then takes the total steam demand and allocates it between Conventional and CHP systems,
! further subdividing it among the 5 Conventional and 4 CHP technologies.  This is not a "tech choice" model,
! since initial and final shares are specified by the user and the values for intermediate years are calculated
! by linear interpolation.
! Called from: IronSteel_Industry
! Calls: Q_Interp2

    SUBROUTINE IS_STEAM
    use i_
    IMPLICIT NONE

    INTEGER ii,jj,irg                       ! counter
    REAL Q_Interp2                          ! Interpolation function
    REAL BOIL_SHARE                         ! Share of steam produced by Conventional Boilers (GJ)
    REAL B_T_SHARE(N_Boil_Tech)             ! Relative Shares of Conventional Boiler Technology
    REAL C_T_SHARE(N_CHP_Tech)              ! Relative Shares of CHP Technology
    REAL BOIL_Consump(5)                    !Boiler consumption by fuel
    real fac1,fac2,fac3                     ! steam share factors


!***** Steam Demand ***************
! total steam for all steps
    STEAM_Total =SUM(STM_Steel(1:IS_MAXSTPS)) / 1.054615   !Total Steam Demand (GJ converted to MMBtu): AKA ENPIQTY(1) Check units.
 ! calculate steam regional shares
    do irg=1,4
	    if (SUM(PRODCUR(1:4,4)).ne.0.0) then
	      Fac1=prodcur(irg,4)/SUM(PRODCUR(1:4,4))
	    else
	      Fac1=0.0
	    endif
	    if (SUM(PRODCUR(1:4,6)) .ne.0.0) then
	      Fac2=prodcur(irg,6)/SUM(PRODCUR(1:4,6))
	    else
	      Fac2=0.0
	    endif
	    if (SUM(PRODCUR(1:4,7)) .ne.0.0) then
	      Fac3=prodcur(irg,7)/SUM(PRODCUR(1:4,7))
	    else
	      Fac3=0.0
	    endif

        SteamRgShr(inddir,irg)=(STM_STEEL(4)*Fac1+ &
             (STM_STEEL(6)+STM_STEEL(7))*Fac2+ &
              STM_STEEL(8)*Fac3) / STEAM_Total
	enddo

	  !***** Determine current share of steam produced by conventional boilers **********************

    IF (curcalyr.le.int(B_YEAR(1))) THEN
       BOIL_SHARE = B_SHR(1)
    ELSE
       IF (curcalyr.ge.int(B_YEAR(2))) then
          BOIL_SHARE = B_SHR(2)
       else
          BOIL_SHARE = Q_Interp2(B_YEAR(2),B_YEAR(1),B_SHR(2),B_SHR(1),REAL(curcalyr))
       endif
    ENDIF
    CHP_SHARE = 1.0 - BOIL_SHARE

!***** Determine allocation among conventional boiler technologies ******************************

    DO ii = 1,N_Boil_Tech
        IF (curcalyr.le.int(B_T_YEAR(1))) THEN
          B_T_SHARE(ii) = B_T_Start(ii)
        ELSE
          IF (curcalyr.ge.int(B_T_YEAR(2))) then
            B_T_SHARE(ii) = B_T_Final(ii)
          else
            B_T_SHARE(ii) = Q_Interp2(B_T_YEAR(2),B_T_YEAR(1),B_T_Final(ii),B_T_Start(ii),REAL(curcalyr))
          endif
        ENDIF
    ENDDO

!***** Determine allocation among CHP technologies ******************************

    DO ii = 1,N_CHP_Tech
       IF (curcalyr.le.int(C_T_YEAR(1))) THEN
          C_T_SHARE(ii) = C_T_Start(ii)
       ELSE
          IF (curcalyr.ge.int(C_T_YEAR(2))) then
            C_T_SHARE(ii) = C_T_Final(ii)
          else
            C_T_SHARE(ii) = Q_Interp2(C_T_YEAR(2),C_T_YEAR(1),C_T_Final(ii),C_T_Start(ii),REAL(curcalyr))
          endif
       ENDIF
    ENDDO

!***** Calculate Fuel Consumption and CO2 Emissions from Boiler and CHP Systems ********
      BOIL_Consump=0.0
    DO ii = 1,N_Boil_Tech                               ! Conventional Boiler Technologies
        DO jj = 1,5                                      ! (1)NG, (2)HFO, (3)Elec, (4)Coal, (5)CO2
            BOIL_Consump(JJ) = BOIL_Consump(JJ)+(STEAM_Total * BOIL_SHARE &
                                 * B_T_Share(ii) * BOIL_Intensity(jj,ii) / 1000000.0)    ! Trillion Btu
        ENDDO
    ENDDO
    is_CHP_Consump=0.0 !trillion BTU
    DO ii = 1,N_CHP_Tech                                ! CHP Technologies
        DO jj = 1,5                                      ! (1)NG, (2)HFO, (3)Elec, (4)Coal, (5)CO2
            is_CHP_Consump(JJ) = is_CHP_Consump(JJ)+(STEAM_Total * CHP_SHARE &
                                 * C_T_Share(ii) * CHP_Intensity(jj,ii) / (1.054615*1000000.0))      ! Trillion Btu
        ENDDO
    ENDDO
    IS_ElecGen(1)=-1.0*(C_T_Share(4) * CHP_Intensity(3,4)+C_T_Share(1) * CHP_Intensity(3,1))*STEAM_Total * CHP_SHARE/3412.0/1.054615 !gas (GWh)
    IS_ElecGen(2)=-1.0*C_T_Share(3) * CHP_Intensity(3,3)*STEAM_Total * CHP_SHARE/3412.0/1.054615  !oil
    IS_ElecGen(4)=-1.0*C_T_Share(2) * CHP_Intensity(3,2)*STEAM_Total * CHP_SHARE/3412.0/1.054615  !coal
    IS_ElecGen(3)=0.0

!  Add these into corresponding fuel demands to get total
    DO jj = 1,5
		is_fsteam(jj)=(is_CHP_Consump(jj)+Boil_Consump(jj))  !Trill BTU
    enddo
    RETURN
    END SUBROUTINE IS_STEAM


!***********************************************************
! STEEL prodcur breakout
	  subroutine IS_ProdcurBreakout
      use i_
      implicit none

	  integer ii   !counter

      do ii=1,5
        sumprodcur(inddir,ii)=SUM(PRODCUR(1:4,ii))
	  enddo

	 ! need to split prodcur for step 6 between EAF and BOF for Iron and steel

	  sumprodcur(inddir,6)=SUM(DRI_BOF(1:4))
      sumprodcur(inddir,7)=SUM(DRI_EAF(1:4))

      return
      end

!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
! paper and pulp industry submodule
! Called from: MODCAL
! Calls: TECH_STEP, PPSTEAM, PP_ProdcurBreakout, PP_Proxy   KPE PROCESS CHECK OF PPSTEM, PP_PRODCURBREAKOUT, AND PP_PROXY
!steps
!   1: Wood Prep
!   2: Kraft Pulp
!   3: Semi-Chem Pulp
!   4: Mechanical Pulp
!   5: Thermomechanical Pulp (included in the ?echanical Pulp Technologies?tab)
!   6: Recycled Pulp
!   7: Pulp Wash
!   8: Pulp Dry
!   9: Bleaching
!  10: Newsprint production (2 tech choice calculations)
!  11: Paperboard production (3 tech choice calculations)
!  12: Uncoated Paper production  (3 tech choice calculations)
!  13: Coated Paper production  (3 tech choice calculations)
!  14: Tissue Paper production  (3 tech choice calculations)
!  15: Black Liquor Evaporators
!  16: Lime Kilns
!  17: Recovery Furnaces


       SUBROUTINE PaperPulp_Industry
       use i_
       IMPLICIT NONE
       integer jj,istep                         ! loop counter for steps

       if (curitr.eq.1) call PP_Proxy           ! process proxy data
       call PP_ProdcurBreakout                  ! allocate 7 itech prodcur steps into 26 steps
       do istep=1,26 !PP_MAXSTEP
          call TECH_STEP(istep)                 ! Call for each step that requires technology choice
       enddo

       CALL PPSTEAM                             ! Steam
       return
       END SUBROUTINE PaperPulp_Industry
!***********************************************************************
! PRODFLOW_PAPER replaces CALPROD for paper
! Called from: MODCAL
! Calls: IAMatrix

	Subroutine PRODFLOW_PAPER
    use i_
    IMPLICIT NONE
    INTEGER irx,irx2                  ! regional index
    INTEGER ifx                       ! fuel index
    INTEGER ii                        ! index
    INTEGER prx                       ! Index for proxy variables
    INTEGER IS,IT                     !counters
    INTEGER MAXSTPS                   !max steps
    PARAMETER (MAXSTPS=maxstep+1)
    REAL PRODVX_Paper(inumreg)              ! Regional Value of Paper Production

!* Variables for Adjusting PRODFLOW Elements
    REAL WPrep_Factor(3)                             ! PRODFLOW Elements for Wood Prep:  Mechanical, Semi-Chemical, Kraft.  Same across regions
    REAL WPrep_Initial(3,2)                          ! Initial Factor/Year, for interpolation
    REAL WPrep_Final(3,2)                            ! Final Factor/Year, for interpolation
    REAL q_interp2                                   ! Interpolation Function
    REAL forecast                                    ! Result of Interpolation Function
    integer RGNMAP(inumreg,2)                        !census region mapping (census regions 1-2 are covered by IDM region 1, 3-4 by IDM region 2, 5-7 by IDM region 3, 8-9 by IDM region 4)
    DATA RGNMAP /1,3,5,8, &
	               2,4,7,9/

    DATA WPrep_Initial / 1.075, 1.429, 1.818, &
                          2010,  2010,  2010 /               ! Mechanical Pulp
                                           ! Semi-Chemical Pulp
                                          ! Kraft Pulp
    DATA WPrep_Final / 1.053, 1.176, 1.818, &
                        2020,  2020,  2020 /                 ! Kraft Pulp

    PRODX_Base(8,1)=13528670.0 !13817803.0   !Now updated to IBYR values from mecs2014 spreadsheet! 2010 values immediately to right POT_IBYR
    PRODX_Base(8,2)=22343728.0  !23361330.0
    PRODX_Base(8,3)=33264800.0 !34946522.0
    PRODX_Base(8,4)=10164572.0 !10842344.0
!******** Interpolate Wood Prep Factors between Initial and Final Values *************** Not sure I did this correctly

    DO ii = 1,3
      forecast = q_interp2(WPrep_Final(ii,2),WPrep_Initial(ii,2),WPrep_Final(ii,1),WPrep_Initial(ii,1),float(curcalyr))
      if (curcalyr .lt. int(WPrep_Initial(ii,2))) then
          WPrep_Factor(ii)=WPrep_Initial(ii,1)
      else
          WPrep_Factor(ii) = MAX(forecast,WPrep_Final(ii,1))
      endif
    ENDDO

 !* Edit the PRODFLOW Array by manually inserting the Wood Prep factors calculated above
 !* All other array elements are currently static & read in from the prodflow.txt file
 ! since prodflow is static, need to save first year and reassign each year
    if ((curcalyr.eq.ibyr2+1).and.(curitr.eq.1)) then
	  prodflow_IBYR(indreg,:,:,:)=prodflow(:,:,:)
    else
      prodflow(:,:,:) =prodflow_IBYR(indreg,:,:,:)
    endif

    is=7 !Wood Step
    DO IT=1,NTMAX(IS)                              ! For each downstep
      prodflow(1,is,it) = WPrep_Factor(IT)        ! Won't need both old and new vintages, but keep both temporarily
      prodflow(2,is,it) = WPrep_Factor(IT)
    ENDDO

    DO irx = 1,inumreg        ! Loops through all idm regions
!*Get Macro Data and Squish it Into Shape
	    PRODVX_Paper(irx)=SUM(OUTIND(inddir,rgnmap(irx,1):rgnmap(irx,2)))
        If (curcalyr.eq.ibyr2+1) THEN                            ! Do Base Year (2010) Calculations
          PRODX_Paper(irx)  = PRODX_Base(inddir,irx)/1000.0      ! Initialize Base Year Values, in 1000 Tonnes
          Paper_PriceIBYR(irx)  =SUM(OUTINDIBYR(rgnmap(irx,1):rgnmap(irx,2)))/PRODX_Paper(irx)
        endif
        PRODX_Paper(irx) = PRODVX_Paper(irx)/Paper_PriceIBYR(irx)               ! Post-2010 tonnage of paper production
         call IAMatrix(PRODX_Paper,irx) !one region, all steps set
	    if (irx.eq.4) then
          DO IS=1,MPASTP
            IS_IND_FLOW(is,5) = SUM(IS_IND_FLOW(is,1:4))           ! Add across regions to get national total: Units = 1000 Tonnes
          ENDDO
	    endif
    ENDDO !end region loop

!*Calculate regional shares of output by process step.  Used to allocate fuel demand later
    DO IS=1,MPASTP
        DO irx2 = 1,inumreg
		   IF (is_ind_flow(IS,5).NE.0.0) THEN
             IND_FLOW_SHARE(inddir,is,irx2) = IS_IND_FLOW(is,irx2) / IS_IND_FLOW(is,5)
		   ELSE
		     IND_FLOW_SHARE(inddir,is,irx2) = 0.0
		   ENDIF
        ENDDO
		prodcurrpt(IS,curiyr)=SUM(PRODCUR(1:4,IS)) !save for TECHSHR_RPT  KPE-this is new . . .
    ENDDO

    return
    End Subroutine PRODFLOW_PAPER

!*************************************************************
! organize new macro data for Pulp & Paper industry and calculate normalized shares
! Called from: PaperPulp_Industry
! Calls: none

    Subroutine PP_Proxy
    use i_
    implicit none
    REAL PP_ProdNDX(5,17:MNUMYR)                     ! Paper Production Share Indices (5 Paper Types)
    REAL paper_temp(5)
	integer prx,ii

 ! Construct Paper Production Share Indices
 ! note: need new OUTIND variables for MC_REVIND(11:14)
    
   ! fill in gap between read in data and ibyr2+1
    If (curcalyr.eq.ibyr2+1) THEN  
       do ii=24,curiyr-1
        PP_ProdNDX(1,ii) = MC_REVIND(11,14,ii)/PP_ProxyDat(ii) ! Newsprint Index
        PP_ProdNDX(2,ii) = MC_REVIND(11,12,ii)/MC_REVIND(11,11,ii) ! Paperboard Index
        PP_ProdNDX(3,ii) = MC_REVIND(11,14,ii)/MC_REVIND(11,11,ii) ! Print Index (Coated)
        PP_ProdNDX(4,ii) = PP_ProdNDX(3,ii)                        ! Print Index (Uncoated)--Same as Coated
        PP_ProdNDX(5,ii) = MC_REVIND(11,13,ii)/MC_REVIND(11,12,ii) ! Tissue Index
        DO prx = 1,5
         Paper_Temp(prx) = PP_ProdNDX(prx,ii)*Paper_Share(prx,2013-1989)          ! Calculate Un-normalized Shares
        ENDDO
        if (ii.gt.24)  then!already have shares for 2013
          DO prx = 1,5
             Paper_Share(prx,ii) = Paper_Temp(prx)/SUM(Paper_Temp(1:5))     ! Calculate Normalized Shares
          ENDDO
          Mech_Share(ii) = Mech_Share(ii-1) &                                         ! Shift according to relative shares of newsprint/tissue production
                           * (Paper_Share(1,ii)/(Paper_Share(1,ii) + Paper_Share(5,ii))) &
                          / (Paper_Share(1,ii-1)/(Paper_Share(1,ii-1) + Paper_Share(5,ii-1))) 
        endif
       enddo
    endif  

    PP_ProdNDX(1,curiyr) = MC_REVIND(11,14,curiyr)/PP_ProxyDat(curiyr) ! Newsprint Index
    PP_ProdNDX(2,curiyr) = MC_REVIND(11,12,curiyr)/MC_REVIND(11,11,curiyr) ! Paperboard Index
    PP_ProdNDX(3,curiyr) = MC_REVIND(11,14,curiyr)/MC_REVIND(11,11,curiyr) ! Print Index (Coated)
    PP_ProdNDX(4,curiyr) = PP_ProdNDX(3,curiyr)                        ! Print Index (Uncoated)--Same as Coated
    PP_ProdNDX(5,curiyr) = MC_REVIND(11,13,curiyr)/MC_REVIND(11,12,curiyr) ! Tissue Index

    IF (curiyr .gt. 24) THEN   ! For years after 2013 (2006-2013 read in)
        DO prx = 1,5
         Paper_Temp(prx) = PP_ProdNDX(prx,curiyr)*Paper_Share(prx,2013-1989)          ! Calculate Un-normalized Shares
        ENDDO
        DO prx = 1,5
         Paper_Share(prx,curiyr) = Paper_Temp(prx)/SUM(Paper_Temp(1:5))     ! Calculate Normalized Shares
        ENDDO
        Mech_Share(curiyr) = Mech_Share(curiyr-1) &                                         ! Shift according to relative shares of newsprint/tissue production
                             * (Paper_Share(1,curiyr)/(Paper_Share(1,curiyr) + Paper_Share(5,curiyr))) &
                          / (Paper_Share(1,curiyr-1)/(Paper_Share(1,curiyr-1) + Paper_Share(5,curiyr-1))) 
         ENDIF

    RETURN
    END SUBROUTINE PP_Proxy

!***********************************************************
! Paper Prodcur breakout: divides the 7 prodcur steps into 26 pulp and paper steps
! Called from: PaperPulp_Industry
! Calls: none

	subroutine PP_ProdcurBreakout
    use i_
    implicit none

	real cton   !convert to tonnes
	cton=0.90718
	
	! initialize 
	
	sumprodcur(inddir,:) = 0.0
	

    sumprodcur(inddir,1)=SUM(PRODCUR(1:4,7))*cton  !wood
    sumprodcur(inddir,2)=SUM(PRODCUR(1:4,6))*cton  !kraft
    sumprodcur(inddir,3)=SUM(PRODCUR(1:4,5))*cton
    sumprodcur(inddir,4)=SUM(PRODCUR(1:4,4))*Mech_Share(curiyr)*cton
    sumprodcur(inddir,5)=SUM(PRODCUR(1:4,4))*(1.0-mech_share(curiyr))*cton
    sumprodcur(inddir,6)=(SUM(PRODCUR(1:4,1))-SUM(PRODCUR(1:4,4))-SUM(PRODCUR(1:4,5))-SUM(PRODCUR(1:4,6)))*cton
    sumprodcur(inddir,7:8)=(SUM(PRODCUR(1:4,2))+SUM(PRODCUR(1:4,3))+SUM(PRODCUR(1:4,4))+SUM(PRODCUR(1:4,5)))*cton
    sumprodcur(inddir,9)=SUM(PRODCUR(1:4,2))*cton
    sumprodcur(inddir,10:11)=SUM(PRODCUR(1:4,1))*paper_share(1,curiyr)*cton
    sumprodcur(inddir,12:14)=SUM(PRODCUR(1:4,1))*paper_share(2,curiyr)*cton
    sumprodcur(inddir,15:17)=SUM(PRODCUR(1:4,1))*paper_share(3,curiyr)*cton
    sumprodcur(inddir,18:20)=SUM(PRODCUR(1:4,1))*paper_share(4,curiyr)*cton
    sumprodcur(inddir,21:23)=SUM(PRODCUR(1:4,1))*paper_share(5,curiyr)*cton
	! KPE to get sumprodcur for steps 24-26, find total black liquor energy produced (GJ) in steps 2 & 3
    ! black liquor intensity in GJ/kT * (kraft and chemical pulp produced in kT)
	! divide by 12.8 GJ black liquor/tonne (from Ppsteam orginally), then scale to kilotonnes
	! black liquor GJ/kT is same for each technology, so we just use the technology 1 from steps 2 &3
	! PP_BLKLIQ(stepnum,inumtech). Black liquor is produced, so it's negative.
	sumprodcur(inddir,24:26) =  (abs(sum(PP_BLKLIQ(2:3,1))) * sum(sumprodcur(inddir,2:3))/12.8)*1.0E-3

  ! initializing for now; variable calculated in <subroutine>
	pp_prodcurrpt(:,curiyr)=sumprodcur(inddir,:) !save for TECHSHR_RPT
	return
	end


!*************************************************************
! Calculates Steam for the paper industry
! Called from: PaperPulp_Industry
! Calls: q_interp2

    SUBROUTINE PPSTEAM
    use i_
    IMPLICIT NONE

    real TotalSteam             	!GJ of Process Steam Demanded
    real netproc                	!Net Process Steam Demand
    real NetSteamConv           	!Net Steam from conventional fuels
    real cogenx                  	!amount of cogenx net steam from conventional fuels
    real boilersx                	!amount of boiler net steam from conventional fuels
    real share(17)              	!forecasted shares
    real RcySteam               	!Recycled steam
    real forecast               	!results of q_interp2 (shares forecast)
    real q_interp2              	!linear interpolation function
    integer ii,jj,step,irg,is,kk   !counters  KPE added kk
    real fac(6)                 	! multiplier to determine shares
    real stm(6)                 	!steam summed into 6 prodcur steps
    real HOGFuel                	! hog fuel produced GJ
    real HOGFSteam              	! Remaining Hog Fuel for steam (GJ)
    real pulpsum(2)
    real ratio1   !wood prep / pulp ratio
	real tot_paper					! kpe variable -- total paper produced
    real TotBliq                           !Total Black Liquor for paper (GJ)
	real TotalSteamx(5)             ! kpe intermediate steam summation variable
    ! initialize local variables here
	
	TotalSteam  = 0.0
	TotalSteamx(:) = 0.0
    netproc = 0.0
	NetSteamConv = 0.0
	cogenx = 0.0
	boilersx =0.0               	
	share(:) = 0.0
	RcySteam = 0.0
	forecast = 0.0 
    ! integer ii,jj,step,irg,is,kk   !counters  KPE added kk
    fac(:) = 0.0
	stm(:) = 0.0
	HOGFuel = 0.0
	HOGFSteam = 0.0
	pulpsum(:) = 0.0
	ratio1=0.0
	tot_paper=0.0
	TotBliq = 0.0
		! end of initialization
	
	! kpe variable tot_paper
	
	tot_paper =  sumprodcur(inddir,10) + sumprodcur(inddir,12) + & 
		sumprodcur(inddir,15) + sumprodcur(inddir,18) + sumprodcur(inddir,21)
	
!
	
	do kk=0,4
		TotalSteamx(kk+1) = SUM(PAPER_STEAM_GRS(kk*1+1:kk*1+5,curiyr))
	enddo
	
	TotalSteam = SUM(TotalSteamx(1:5))
	! TotalSteam=SUM(PAPER_STEAM_GRS(1:25,curiyr))  ! KPE 1-26?  Col B, GJ of Process Steam Demanded KPE--generated (negative)steam included
    
	RcySteam=TotalSteam*pp_stm_rycl           !Col C
    netproc=TotalSteam-RcySteam               !Col D, Net Process Steam Demand

 !!!!!!!!!!!!!  CALC hog steam   !!!!!!!!!!
  ! hog fuel produced GJ
    ratio1=sumprodcur(inddir,1)/SUM(sumprodcur(inddir,2:5))  ! wood tonnes to pulp tonnes ratio
	! old equation
    ! PP_HOGFuel=(hog_pulp/ratio1-1.0) &
    !         *sumprodcur(inddir,1)*hog_waste*hog_heat*1000.0   ! hog_heat GJ/T !GJ  KPE--hog fuel steam is >=0 so no "gross" adjustments needed; what are units?
    ! new equation---in GJ  ((woodtonnes/pulptonnes)*(pulp kilotonnes) - paper kilotonnes)* %(unitless) * GJ/(tonne wood) * 1000/kilo= GJ of fuel
	PP_HOGFuel=(hog_pulp*SUM(sumprodcur(inddir,2:5))-tot_paper)*hog_waste*hog_heat*(10.0**3) !GJ -- KPE   
 ! hog steam--all goes to chp 
 ! Remaining Hog Fuel for steam (GJ)  in CHP !  boilersx . . .
    HOGFSteam=(pp_HogFuel-PAPER_HOG(25,curiyr))*pp_BioBoilEff ! KPE--this is usaable steam in GJ;  (old /1000000.0) -- this is energy


 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ! below is net steam from conventional fuels
    NetSteamConv=netproc-HOGFSteam ! KPE PAPER_STEAM_GRS(26,curiyr) NOT subtracted   no step 26 in netprc from conventional fuels GJ  (KPE more accurate nonhog steam)

	! interpolate chp shares
    do ii=1,17
     if ((ibyr2+1).ge.curcalyr) then
        share(ii)=ppst_shrstart(ii,1)
      else
        forecast=q_interp2(ppst_shrstart(ii,2),ppst_shrfinal(ii,2),ppst_shrstart(ii,1),ppst_shrfinal(ii,1),float(curcalyr))
        share(ii)=forecast
      endif
    enddo 

    cogenx=abs(NetSteamConv)*share(2) !GJ   KPE confirmed -these two equations are fossil cogenx and boiler steam in GJ. 
    boilersx=abs(NetSteamConv)*share(1)  !GJ

	
 ! KPE on next run, let's reconfirm which units everything is in 
 !Boiler Steam -- PP_Steam_boiler is in fuel units 
    do ii=1,5
      PP_Steam_Boiler(ii)=0.0
      do jj=1,9
		PP_Steam_Boiler(ii)=PP_Steam_Boiler(ii)+(pp_stmfuel_bl(jj,ii)*share(jj+4))  ! running through matrix gives fuel units
      enddo
      PP_Steam_Boiler(ii)=max(PP_Steam_Boiler(ii)*boilersx/(1.054615*(10.0**6)),1.0) !elec,ng,hfo,coal,CO2 COL AP-AS, AU  KPE-in trills
    enddo

 !Steam_cogenx  ---in fuel units--conventional only
    do ii=1,5  !  KP fuel 1 is electricity, fuel 2-4 fossil, and fuel 5 is co2
      PP_Steam_cogen(ii)=0.0
      do jj=1,9
			PP_Steam_cogen(ii)=PP_Steam_cogen(ii)+(pp_stmfuel_chp(jj,ii)*share(jj+8))  !  GJ fuel * gj steam 
      enddo
      PP_Steam_cogen(ii)=max(abs(PP_Steam_cogen(ii))*cogenx/(1.054615*(10.0**6)),1.0) ! KPE (GJ fuel/GJ steam)*GJ steam/(GJ/MMBTU)*trill/mill = trills OK elec,ng,hfo,coal,CO2 COL AP-AS, AU  KPE--in trills
    enddo

 
  !  PP_Steam_cogen(1)=PP_Steam_cogen(1)+ &             ! PP_Steam_cogen has already been converted to SAE (trills?)
  !                 (pp_stmfuel_chp(7,1)*PAPER_STEAM_GRS(26,curiyr) + &   ! KPE ABS() FOR PAPER_STEAM Col O, Black Liquor Electricity(Trils)
  !                (pp_stmfuel_chp(6,1)*share(3) +pp_stmfuel_chp(7,1)*share(4))*HOGFSteam)/1.054615*(10.0**-6) !Col P Hog Fuel Electricity(Trils)
   ! this is in trills
    ! GJ /(GJ/MMBTU) * (trills/million)
   ! PP steam cogen	--- all renewable steam is assumed to be cogen; this is steam converted to fuel units
   PP_Steam_cogen(6)=max(((PAPER_STEAM_GRS(26,curiyr) + abs(HOGFSteam))/pp_BioBoilEff)/(1.054615*(10.0**6)),1.0)    ! HOG Col AT  KPE ADD ABS() --- trills energy  
	

    ! pp_elecgen=0.0 !Electric Generation (Gwh) -- not yet. The next series of equations is abs(GJ elec/GJ steam) 
	PP_ElecGen(1:4) = 0.0

    do jj=1,2
      pp_elecgen(1)=PP_ElecGen(1)+ABS(pp_stmfuel_chp(jj,1)*share(jj+8)) !ng   KPE:  electricity per GJ steam  
    enddo
    do jj=8,9
      PP_ElecGen(2)=PP_ElecGen(2)+ABS(pp_stmfuel_chp(jj,1)*share(jj+8)) !hfo
    enddo
    do jj=4,5
      PP_ElecGen(3)=PP_ElecGen(3)+ABS(pp_stmfuel_chp(jj,1)*share(jj+8)) !coal 
	enddo
! all net hogfuel per documentation is chp, 	
	do jj=3,7  ! KPE new loop for hog fuel . .. -- fuels 4 and 5 are not added
	  if ((jj == 3).or.(jj>=6)) then
		PP_ElecGen(4)=PP_ElecGen(4)+ABS(pp_stmfuel_chp(jj,1)*share(jj+8))  ! hog fuel renewables GJ electric/GJ steam
	  endif
    enddo
    do ii=1,3  ! conventional
   ! old equation  PP_ElecGen(ii)=(PP_ElecGen(ii)*cogenx*1000.0/1.054615)/3.412   ! KPE:  ((GJ ELEC/GJ STEAM)*(GJ STEAM)*10.0**3/(GJ/mmbtu))/((btu/kwh)*10.0**-3) = not GWh 
     PP_ElecGen(ii)=max((PP_ElecGen(ii)*cogenx/1.054615)/3412.0,1.0)   ! KPE:  ((GJ ELEC/GJ STEAM)*(GJ STEAM)/(GJ/mmbtu))/((btu/kwh)) = MMkwh = GWh 
    enddo
    PP_ElecGen(4) =  abs(PP_ElecGen(4)*HOGFSteam) ! KPE GJ energy/GJ hog steam * GJ hog steam = GJ energy  convert in final equation 
    ! because this equation has to be substantially rewritte! n, I will do so
	! old equation
	! PP_ElecGen(4)=ABS((pp_stmfuel_chp(7,1)*PAPER_STEAM_GRS(26,curiyr)/1.054615) + & !  !Col O, Black Liquor Electricity(Trils)  
    ! ((pp_stmfuel_chp(6,1)*share(3) +pp_stmfuel_chp(7,1)*share(4))*HOGFSteam/1.054615))& !Col P Hog Fuel Electricity(Trils)
    ! *1000000.0/3412.0
	! KPE GJ/(GJ/MMBTU)*(1/(btu/kwh)) = MMkWh = GWh
	! this is renewable electric generation from hog fuel and black liquor steps 1 & 6   
	 PP_ElecGen(4)=max(((PP_ElecGen(4) + abs(ElecGen_pap26(26,curiyr)))/1.054615)/3412.0,1.0) ! confirmed KPE GJ/(GJ/MMBTU)*(1/(btu/kwh)) = MMkWh = GWh

!***** Steam Demand ***************

 ! get shares to distribute wash and dry pulp fuel use
    pulpsum(1)=SUM(ElecCons(2:5,curiyr)) !trills
    pulpsum(2)=SUM(PAPER_STEAM_GRS(2:5,curiyr)) !GJ 
    do is=2,5
      if (pulpsum(1).ne.0.0) then
        pulpshare(1,is)=ElecCons(is,curiyr)/pulpsum(1)
      else
        pulpshare(1,is)=0.0
      endif
      if (pulpsum(2).ne.0.0) then
        pulpshare(2,is)=PAPER_STEAM_GRS(is,curiyr)/pulpsum(2)
      else
        pulpshare(2,is)=0.0
      endif
    enddo
! calculate steam regional shares
    STM(1)=SUM(PAPER_STEAM_GRS(10:25,curiyr))
    STM(2)=PAPER_STEAM_GRS(9,curiyr)
    STM(3)=(PAPER_STEAM_GRS(6,curiyr)+SUM(PAPER_STEAM_GRS(7:8,curiyr))*pulpshare(2,5))
    STM(4)=(SUM(PAPER_STEAM_GRS(4:5,curiyr))+SUM(PAPER_STEAM_GRS(7:8,curiyr))*pulpshare(2,4))
    STM(5)=(PAPER_STEAM_GRS(3,curiyr)+SUM(PAPER_STEAM_GRS(7:8,curiyr))*pulpshare(2,3))
    STM(6)=(PAPER_STEAM_GRS(2,curiyr)+SUM(PAPER_STEAM_GRS(7:8,curiyr))*pulpshare(2,2))
    do irg=1,4
      SteamRgShr(inddir,irg)=0.0
      do step=1,6
	    if (SUM(PRODCUR(1:4,step)).ne.0.0) then
	        Fac(step)=prodcur(irg,step)/SUM(PRODCUR(1:4,step))
	    else
	        Fac(step)=0.0
	    endif
        SteamRgShr(inddir,irg)=SteamRgShr(inddir,irg)+(STM(step)*Fac(step))
	  enddo
      SteamRgShr(inddir,irg)=SteamRgShr(inddir,irg)/ TotalSteam
	enddo
    pp_cogshr=share(2) !used in ppis_bsc
    return
    end subroutine PPSTEAM
	


!***********************************
! Vintage Index function for aluminum and cement
    FUNCTION VINTAGE_INDEX(stepnum)
    use i_
    implicit none

    real sum1, prodsum, vintage_index
    integer stepnum

    if (curiyr.ge.ICURIYR2+3) then
        prodsum=0.0
        sum1=0.0
        do i=is_FISYR(inddir),curiyr-1
            if (IS_incr_adds(inddir,stepnum,i).gt.0.0) then
               prodsum=prodsum+(IS_incr_adds(inddir,stepnum,i)*(i+1989))
               sum1=sum1+IS_incr_adds(inddir,stepnum,i)
            endif
        enddo
        if (prodsum.lt.0.0) prodsum=0.0
        prodsum=prodsum+is_basecap(inddir,stepnum)*(ibyr2+2)  ! POT_ibyr2 2008 to (ibyr2+2)
        if (sum1.lt.0.0) sum1=0.0
        sum1=sum1+is_basecap(inddir,stepnum)
        if (sum1.ne.0.0) then
           vintage_index=(prodsum/sum1)-(ibyr2+3.0)            ! POT_ibyr2 2009 to (ibyr2+3.0)
        else
           vintage_index=0.0
        endif
        if (vintage_index.lt.0.0) vintage_index=0.0
    else
        vintage_index=0.0
    endif
    RETURN
    END

   !*****************************************************************************
    subroutine ppis_bsc
!paper and steel bsc
! BSC is bypassed for paper and steel because BSC is included in P&A
! This subroutine sets (or zeros out) variables that would have been set in the BSC subroutines
! Called from: MODCAL
! Calls: none
    use i_
    IMPLICIT NONE

    real totcogen !total cogen
    integer incap  !switch to use ibyr2+1 weighted average or ibyr2+2 weighted average
    integer ifuel,jfuel,ncap,kkx,regionx,dlx,dly
    real coggenshr(MNUMCR-2,numflchp) !gen paper census region shares
    real cogcapshr(MNUMCR-2,numflchp)  !cap paper census region shares
    real cogthrshr(MNUMCR-2,numflchp) !thr paper census region shares
    real cogelfshr(MNUMCR-2,numflchp)  !elf census region shares	
	real cogthrmelecshr(numflchp+1)		! KPE add divides steam energy into thermal and electric by fuel -- national total for now
	real*16 renewchpfac, natgaschpfac ! kpe variables--hardcoded chp factors for 2020+ chp
	
	! initialization block
	
	totcogen = 0.; incap =0.; 
    coggenshr(:,:)=1.0E-3; cogcapshr(:,:)= 0.; cogthrshr(:,:) = 0.; cogelfshr(:,:) = 0.
     	
	cogthrmelecshr(:) = 0. 
	renewchpfac = 1. ; natgaschpfac = 1.
	

    !  KPE -- initialize coginit across all 4 regions
	
	if (curiyr > maxcogyr) then
		do regionx=1,4
			CALL COGINIT(regionx)
		enddo
	endif
	 
    
!	if (inddir == 8) then  ! universalized for both steel and paper
		cogthrmelecshr(:) = 0.
		if (curiyr.le.maxcogyr) then	     
			do kkx=1,numflchp           ! call do loop after if statement, rather than before
				cogthrmelecshr(kkx) = sum(cogthr(1:9,curcalyr-1989,inddir,kkx))*(1/0.8) / &     ! Divide cogthr by 0.8 to convert from steam to fuel (0.8 is assumed CHP efficiency)
				   (SUM(cogthr(1:9,curcalyr-1989,inddir,kkx))*(1/0.8) + SUM(cogelf(1:9,curcalyr-1989,inddir,kkx)))
                If (ISNAN(cogthrmelecshr(kkx))) cogthrmelecshr(kkx)=0.001       ! Account for dividing by 0
            enddo		
        else
			cogthrmelecshr(kkx) = 0.75     !
		endif
!	endif
	! end kpe add code
    do ir=1,9 !census regions
        do ifuel=1,numflchp
            if (SUM(coggen(1:9,ibyr2-1989,inddir,ifuel)).ne.0.0) coggenshr(ir,ifuel)=coggen(ir,ibyr2-1989,inddir,ifuel) / SUM(coggen(1:9,ibyr2-1989,inddir,ifuel))
            if (SUM(cogcap(1:9,ibyr2-1989,inddir,ifuel)).ne.0.0) cogcapshr(ir,ifuel)=cogcap(ir,ibyr2-1989,inddir,ifuel) / SUM(cogcap(1:9,ibyr2-1989,inddir,ifuel))
            if (SUM(cogthr(1:9,ibyr2-1989,inddir,ifuel)).ne.0.0) cogthrshr(ir,ifuel)=cogthr(ir,ibyr2-1989,inddir,ifuel) / SUM(cogthr(1:9,ibyr2-1989,inddir,ifuel))
            if (SUM(cogelf(1:9,ibyr2-1989,inddir,ifuel)).ne.0.0) cogelfshr(ir,ifuel)=cogelf(ir,ibyr2-1989,inddir,ifuel) / SUM(cogelf(1:9,ibyr2-1989,inddir,ifuel))

        enddo
	enddo  ! KPE new enddo-- calculate all the shares first

! used for paper
	   	 renewchpfac = 6.190613661
		 natgaschpfac = 4.82629345


	!
    if (inddir==8) then

 
	   !old equation
       ! totcogen=abs(PP_Steam_Cogen(1))/3412)*10.0**6 
	   ! old eq.  total electric cogen (GWh)! KPE trills to btu, btu to kwh, kwh to GWh (compressed scaling factor 10.0**12 * 10.0**-6) 
       ! new equation--we already have cogen in GWH, so we should use it
	   ! total cogen--natgascapfactors and renew are ==1 when year <= maxcogyr so works
	   totcogen = PP_ElecGen(1)*natgaschpfac + sum(PP_ElecGen(2:3)) + PP_ElecGen(4)*renewchpfac  ! already in GWh, so no conversion
   else
       totcogen=(-1.0*is_CHP_Consump(3))/.003412 !total cogen (GWh)  this is for steel
   endif

!paper uses this

    if (curcalyr.eq.ibyr2+1) then
         incap=1 !use ibyr2+1 weighted average
    else
         incap=2 !hold ibyr2+2 weighted average constant after ibyr2+1
    endif

! new  models are national so regional data is set using shares based on ibyr2
! below todo done with the creation of ElecGen_pap26 variable


! CHP generation by fuel GWH --- 
	if ((inddir.eq.8).and.(curiyr .gt. maxcogyr)) then
       ! factor is default 2020 generation / raw model 2020 generation for natural gas and renewables
	!  see \\nem2\L\mid\kpe\AEO\AEO2021\paper_steam\chpinputvoutput.xlsx for 
	! factor calculation
!		if (curcalyr.gt.maxcogyr) then  
!		endif


		do ir=1,9 !census divisions --- do loop is inside the if loop
		!pp_elec_gen indices: gas,hfo,coal, bio--KPE confirmed GWh
            coggen(ir,curiyr,inddir,3)=PP_ElecGen(1)*coggenshr(ir,3)*natgaschpfac !gas
            coggen(ir,curiyr,inddir,2)=PP_ElecGen(2)*coggenshr(ir,2) !hfo
            coggen(ir,curiyr,inddir,1)=PP_ElecGen(3)*coggenshr(ir,1) !coal
            coggen(ir,curiyr,inddir,7)=PP_ElecGen(4)*coggenshr(ir,7)*renewchpfac !biofuel
            coggen(ir,curiyr,inddir,11)=SUM(coggen(ir,curiyr,inddir,1:3))+coggen(ir,curiyr,inddir,7)  !total

		!PP_Steam_Cogen indices : elec,gas,hfo,coal,co2,bio   -- PP_STEAM_cogen is in trills -- confirmed KP
           cogelf(ir,curiyr,inddir,3)=PP_Steam_Cogen(2)*cogelfshr(ir,3)*(1-cogthrmelecshr(3)) !gas
           cogelf(ir,curiyr,inddir,2)=PP_Steam_Cogen(3)*cogelfshr(ir,2)*(1-cogthrmelecshr(2)) !hfo
           cogelf(ir,curiyr,inddir,1)=PP_Steam_Cogen(4)*cogelfshr(ir,1)*(1-cogthrmelecshr(1)) !coal
           cogelf(ir,curiyr,inddir,7)=PP_Steam_Cogen(6)*cogelfshr(ir,7)*(1-cogthrmelecshr(7)) !biofuel
           cogelf(ir,curiyr,inddir,11)=SUM(cogelf(ir,curiyr,inddir,1:3)) + cogelf(ir,curiyr,inddir,7)  !total
		   ! now for cogthrm
		   cogthr(ir,curiyr,inddir,3)=PP_Steam_Cogen(2)*cogthrshr(ir,3)*cogthrmelecshr(3) !gas
           cogthr(ir,curiyr,inddir,2)=PP_Steam_Cogen(3)*cogthrshr(ir,2)*cogthrmelecshr(2) !hfo
           cogthr(ir,curiyr,inddir,1)=PP_Steam_Cogen(4)*cogthrshr(ir,1)*cogthrmelecshr(1) !coal
           cogthr(ir,curiyr,inddir,7)=PP_Steam_Cogen(6)*cogthrshr(ir,7)*cogthrmelecshr(7) !biofuel
           cogthr(ir,curiyr,inddir,11)=SUM(cogthr(ir,curiyr,inddir,1:3)) +cogthr(ir,curiyr,inddir,7)  !total
	   enddo  ! ir looop
	   ! now for national totals
        do i=1,3 ! conventional fuels --- this if block OK
           coggen(11,curiyr,inddir,i) = sum(coggen(1:9,curiyr,inddir,i))
	       cogelf(11,curiyr,inddir,i) = sum(cogelf(1:9,curiyr,inddir,i))
        enddo
	    coggen(11,curiyr,inddir,7) = sum(coggen(1:9,curiyr,inddir,7))
	    coggen(11,curiyr,inddir,11) =  sum(coggen(11,curiyr,inddir,1:3)) + coggen(11,curiyr,inddir,7)
	    cogelf(11,curiyr,inddir,7) = sum(cogelf(1:9,curiyr,inddir,7))
	    cogelf(11,curiyr,inddir,11) =  sum(cogelf(11,curiyr,inddir,1:3)) + cogelf(11,curiyr,inddir,7)




	else if ((inddir.eq.12).and.(curiyr.gt.maxcogyr)) then
		do ir=1,9
           coggen(ir,curiyr,inddir,3)=IS_ElecGen(1)*coggenshr(ir,3) !gas
           coggen(ir,curiyr,inddir,2)=IS_ElecGen(2)*coggenshr(ir,2) !hfo
           coggen(ir,curiyr,inddir,1)=IS_ElecGen(4)*coggenshr(ir,1) !coal
           coggen(ir,curiyr,inddir,4)=coggen(ir,maxcogyr,inddir,4) ! bfg--setting regional share equal to coal share
	
           coggen(ir,curiyr,inddir,11)=SUM(coggen(ir,curiyr,inddir,1:4))  ! generation divisional total, all fuels

           cogelf(ir,curiyr,inddir,3)=is_CHP_Consump(1)*cogelfshr(ir,3) !gas
           cogelf(ir,curiyr,inddir,2)=is_CHP_Consump(2)*cogelfshr(ir,2) !hfo
           cogelf(ir,curiyr,inddir,1)=is_CHP_Consump(4)*cogelfshr(ir,1) !coal
           cogelf(ir,curiyr,inddir,11)=SUM(cogelf(ir,curiyr,inddir,1:3))  !total
	    enddo !ir loop
		 ! national totals
		do i=1,4 !fuels
           coggen(11,curiyr,inddir,i) = sum(coggen(1:9,curiyr,inddir,i))
           cogelf(11,curiyr,inddir,i) = sum(cogelf(1:9,curiyr,inddir,i))
        enddo
	    coggen(11,curiyr,inddir,11) = sum(coggen(1:9,curiyr,inddir,11))
	    cogelf(11,curiyr,inddir,11) = sum(cogelf(1:9,curiyr,inddir,11))

    endif

	
	! now for capacity
    if (inddir.eq.8) then   
	 ! new equation -- rearranges some terms cogcap	= share * generation /capacity factor * conversion constants = capacity MW
	 ! = = (coggen(11,curiyr,inddir,3)/SUM(PP_ElecGen(1:4)))((1+BldChpShr)*totcogen*1000)/(GWH/(GW*8760))
	 ! units now GW*8760; divide by 8760 & multiply by 1000 to get GW

	 
        if ((coggen(11,curiyr,inddir,11).ne.0.0).and.(curiyr.gt.maxcogyr)) then
	        do kkx = 1,3 ! for fossil fuels--coal,hfo, and natgas capacity MW 
				cogcap(11,curiyr,inddir,kkx) = 	(coggen(11,curiyr,inddir,kkx)/coggen(11,curiyr,inddir,11))* & 
				((1+BldChpShr)*totcogen/CapFacAvg(incap,4-kkx))*(1000/8760.0)       ! MWh (later converted back to GW)
			enddo		
			cogcap(11,curiyr,inddir,7) = (coggen(11,curiyr,inddir,7)/coggen(11,curiyr,inddir,11))* &       ! biofuel
				((1+BldChpShr)*totcogen/CapFacAvg(incap,4))*(1000/8760.0)                             ! MW (later converted back to GW)
			! total cogcap	
			cogcap(11,curiyr,inddir,11)=SUM(cogcap(11,curiyr,inddir,1:3)) +cogcap(11,curiyr,inddir,7) !total
			!
			! KPE comments 8/20/2020
			! thermal energy  -- old equation cogthr(11,curiyr,inddir,1)= -1.0*(PP_Steam_Cogen(1)+ElecCons(26,curiyr))/3.412
			! I don't know if we can really get a cogthr equation from what we know -- we may not be able to distinguish between.
			! we may not use cogthr, but will fix in the interests of completeness
			! KPE below is cogthr for electric generation---which doesn't really make a lot of sense because cogthr is
		    ! (we believe) the form 923 steam used for electricity
			! now and correct if there's a problem.
			cogthr(11,curiyr,inddir,1)= (PP_Steam_Cogen(1)+ElecCons(26,curiyr))/(3.412*0.8) ! not quite (cogen steam + recovery furnance in tBtu)/(3412 Btu/kWh) = billion kWh of fuel; multiplied by 0.8 (assumed CHP efficiency) to put in units of steam

		do ir=1,9
			do j=1,3 !fuels
				cogcap(ir,curiyr,inddir,j)=cogcapshr(ir,j)*cogcap(11,curiyr,inddir,j)
			enddo
            cogcap(ir,curiyr,inddir,7)=cogcapshr(ir,7)*cogcap(11,curiyr,inddir,7)
            cogthr(ir,curiyr,inddir,7)=cogthrshr(ir,7)*cogthr(11,curiyr,inddir,7)
		
		enddo      ! is this OK, to keep an if statement in a do loop?

        endif
    else if (inddir.eq.12) then
        if (SUM(IS_ElecGen(1:4)).ne.0.0) then
            do i=1,4
               if (is_CapFacAvg(i).ne.0.0) &
                  cogcap(11,curiyr,inddir,i)=(coggen(11,curiyr,inddir,i)*(1.0+is_BldChpShr*totcogen/SUM(IS_ElecGen(1:4)))/is_CapFacAvg(i))/8.76
               cogthr(11,curiyr,inddir,1)= -1.0*(is_CHP_Consump(3)+ElecCons(26,curiyr))/3.412 !cogen steam + recovery furnance GWH
            enddo
        endif
        cogcap(11,curiyr,inddir,11)=SUM(cogcap(11,curiyr,inddir,1:4))  !total capacity
        cogthr(11,curiyr,inddir,11)=SUM(cogthr(11,curiyr,inddir,1:4))  !total thermal
		
		do ir=1,9
			do j=1,3 !fuels
            cogcap(ir,curiyr,inddir,j)=cogcapshr(ir,j)*cogcap(11,curiyr,inddir,j)
			enddo
		enddo      ! is this OK, to keep an if statement in a do loop?

		
    endif


    
	   if (inddir==8) then
	    ! we already have these variables, dont't we, from PPSTEAM, or can build them
		! variables:  cogeneration steam, noncogen steam, biosteam, 
        STEMCUR=SteamRgShr(inddir,indreg)*SUM(PAPER_STEAM_GRS(1:26,curiyr))/(1.054615*(10.0**6))  ! this is in trills		
        COGSTEAM=STEMCUR*pp_cogshr                                                           ! CHP Steam Generation--same as in PPSTEAM ?
        NONCOGSTEAM=STEMCUR-COGSTEAM                                                         ! Total Non-CHP Steam Generation
        NONCOGFOSSTEAM=NONCOGSTEAM                                ! we                          ! Non-CHP Fossil Steam Generation
        BIOSTEAM=0.0  !Non-CHP Biomass Steam Generation  KPE -verified coorect
        ! KPE -- these equations look OK. . . this is steam fuel use
        ensqty(1)=max((PP_Steam_Cogen(2)+PP_Steam_Boiler(2)),1.0)*SteamRgShr(inddir,indreg)  !ng -add steam fuel consumption calc'ed in subroutine IS_STEAM
        ensqty(3)=max((PP_Steam_Cogen(3)+PP_Steam_Boiler(3)),1.0)*pp_hfoshr(1)*SteamRgShr(inddir,indreg)  !% HFO is resid-add steam fuel consumption calc'ed in subroutine IS_STEAM
        ensqty(2)=max((PP_Steam_Cogen(4)+PP_Steam_Boiler(4)),1.0)*SteamRgShr(inddir,indreg)  !coal -add steam fuel consumption calc'ed in subroutine IS_STEAM
        ensqty(5)=0.0   !Propane
        ensqty(4)=max((PP_Steam_Cogen(3)+PP_Steam_Boiler(3)),1.0)*pp_hfoshr(3)*SteamRgShr(inddir,indreg) !% of HFO is distilate
        ensqty(6)=max((PP_Steam_Cogen(3)+PP_Steam_Boiler(3)),1.0)*pp_hfoshr(2)*SteamRgShr(inddir,indreg) !% of HFO is pet coke
        ensqty(7)=max((PP_Steam_Cogen(3)+PP_Steam_Boiler(3)),1.0)*pp_hfoshr(4)*SteamRgShr(inddir,indreg) !% of HFO is other petroleum
        ensqty(8)=0.0
        !zero out other fuels -- why no bio?
        ! KPE old equation ELOWN=  -1.0*pp_Steam_Cogen(1)*SteamRgShr(inddir,indreg)/3412.0*1000000.0
		! new equation 
		! also, don't we have electricity in PPSTEAM?
		! KPE changed the steam variable to coggen . . . we can do regional if we want 
        
	else if (inddir==12) then
        STEMCUR=ENPIQTY(1)
        COGSTEAM=STEMCUR*CHP_SHARE
        NONCOGSTEAM=STEMCUR-COGSTEAM
        ensqty(1)=IS_FSTEAM(1)*SteamRgShr(inddir,indreg)  !ng -add steam fuel consumption calc'ed in subroutine IS_STEAM
        ensqty(3)=IS_FSTEAM(2)*SteamRgShr(inddir,indreg)  !TD changed to all resid based on 2014 Mecs;PREVIOUS: 10% HFO is resid-add steam fuel consumption calc'ed in subroutine IS_STEAM
        ensqty(2)=IS_FSTEAM(4)*SteamRgShr(inddir,indreg)  !coal -add steam fuel consumption calc'ed in subroutine IS_STEAM
        ensqty(7)=0.0 !IS_FSTEAM(2)*0.90*SteamRgShr(inddir,indreg) !no other pet in MEcs 2014; previously: 90% of HFO is other petroleum
        ensqty(4:6)=0.0
        ensqty(8:)=0.0
        GENFUEL=0.  ! sum of cogen fuel for this industry and region ; stored in buffers; for indy rep writer
	endif

    ! elown and elsale formulas the same for both paper and steel.  First, we have last year's grid share that we can use for own and sale

	! ELOWN=(1-chpgrdshr(inddir,curiyr-1))*coggen(11,curiyr,inddir,11)
    ! ELSALE=chpgrdshr(inddir,curiyr-1)*coggen(11,curiyr,inddir,11)
	
	! now we regionalize elown and elsale---from 
	
	do regionx=1,4
		if (regionx == 1) then
			dlx = 1
			dly = 2
		else if (regionx == 2) then
			dlx = 3
			dly = 4
		else if (regionx == 3) then
			dlx = 5
			dly = 7
		else
			dlx = 8
			dly = 9
		endif

		elownx(inddir,regionx) = sum(coggen(dlx:dly,curiyr,inddir,11))*(1-chpgrdshr(inddir,curiyr-1))
		elsalex(inddir,regionx) = sum(coggen(dlx:dly,curiyr,inddir,11))*chpgrdshr(inddir,curiyr-1)
    enddo 

 
	  PP_STEAM_Cogen(:) = 0.0
	  PP_Steam_Boiler(:) = 0.0
	  PP_ElecGen(:) = 0.0

	
    return
    end subroutine ppis_bsc

!******************************************************************    
! subroutine used to incorporate STEOBLOCK variables
  SUBROUTINE INDEASY

    IMPLICIT NONE
    INCLUDE 'PARAMETR'
    INCLUDE 'STEOBLOCK'
                     
common/ind_easy/INDETTCBUS, INDC4TCBUS, INDPRTCBUS, INDPPTCBUS, INDDFTCBUS, INDRFTCBUS, INDMGTCBUS, &
                  INDFETCBUS, INDARTCBUS, INDLUTCBUS, INDPCTCBUS, INDWXTCBUS, INDABTCBUS, INDUOTCBUS, INDMSTCBUS, INDSNTCBUS, &
                  INDNGNUKUS, INDNGINX, INDZSAJQUS, INDCLYCBUS, INDCLKCBUS, INDCCNIBUS, INDEXICPUS, INDHVICBUS, INDHVCCBUS, INDWWICBUS, INDOWICBUS, INDPCEPCONB


    real INDETTCBUS(mnumyr)   ! Ethane/Ethylene Product Supplied
    real INDC4TCBUS(mnumyr)   ! Butanes/Butylenes Product Supplied
    real INDPRTCBUS(mnumyr)   ! Propane/Propylene Product Supplied
    real INDPPTCBUS(mnumyr)   ! Natural Gasoline (Pentanes Plus) Product Supplied    
    Real INDDFTCBUS(mnumyr)    ! Distillate Fuel Oil Product Supplied
    Real INDRFTCBUS(mnumyr)    ! Residual Fuel Oil Product Supplied
    Real INDMGTCBUS(mnumyr)    ! Motor Gasoline Product Supplied
    Real INDFETCBUS(mnumyr)    ! Petrochemical Feedstocks Product Supplied
    Real INDARTCBUS(mnumyr)    ! Asphalt and Road Oil Product Supplied
    Real INDLUTCBUS(mnumyr)    ! Total lubricants consumed
    Real INDPCTCBUS(mnumyr)    ! Petroleum Coke Product Supplied
    Real INDWXTCBUS(mnumyr)    ! Total waxes consumed
    Real INDABTCBUS(mnumyr)    ! Aviation Gasoline Blend Components Refinery Input
    Real INDUOTCBUS(mnumyr)    ! Unfinished Oils Product Supplied
    Real INDMSTCBUS (mnumyr)   ! Miscellaneous petroleum products consumed
    Real INDSNTCBUS(mnumyr)    ! Special naphthas consumed
    Real INDNGNUKUS(mnumyr)    ! Btu/cubic foot natural gas, U.S. Total
    Real INDNGINX(mnumyr)      ! Natural Gas Consumption Industrial Sector, U.S. Total (Bcf/d); main.f converts to Tcf, which is what it gets read in as
    Real INDZSAJQUS(mnumyr)    ! Days in year
    Real INDCLYCBUS(mnumyr)    ! Other Industrial Coal Consumption
    Real INDCLKCBUS(mnumyr)    ! Coke Plants Coal Consumption
    Real INDCCNIBUS(mnumyr)    ! Coal coke net imports into the United States
    Real INDEXICPUS(mnumyr)    ! Electricity consumed by (i.e., sold to) the industrial sector
    Real INDHVICBUS(mnumyr)    ! Industrial sector consumption of conventional hydroelectric energy
    Real INDHVCCBUS(mnumyr)    ! Commercial sector consumption of conventional hydroelectric energy
    Real INDWWICBUS(mnumyr)    ! Industrial sector consumption of wood and wood waste biomass energy
    Real INDOWICBUS(mnumyr)    ! Industrial sector consumption of non-wood waste biomass energy (municipal solid waste)
    Real INDPCEPCONB(mnumyr)    ! Electricity sector consumption of petcoke
    
integer k


      INDETTCBUS = ETTCBUS*1000       ! multiply by 1000 to put in trillion Btu
      INDC4TCBUS = C4TCBUS*1000
      INDPRTCBUS = PRTCBUS*1000
!      INDC3TCPUS = C3TCPUS*1000
      INDPPTCBUS = PPTCBUS*1000
      INDDFTCBUS=DFTCBUS*1000
      INDRFTCBUS=RFTCBUS*1000
      INDMGTCBUS=MGTCBUS*1000
      INDFETCBUS=FETCBUS*1000
      INDARTCBUS=ARTCBUS*1000
      INDLUTCBUS=LUTCBUS*1000
      INDPCTCBUS=PCTCBUS*1000
      INDWXTCBUS=WXTCBUS*1000
      INDABTCBUS=ABTCBUS*1000
      INDUOTCBUS=UOTCBUS*1000
      INDMSTCBUS =MSTCBUS*1000 
      INDSNTCBUS=SNTCBUS*1000
      INDNGNUKUS=NGNUKUS
      INDNGINX=NGINX          ! main.f converts to Tcf from Bcf/d
      INDZSAJQUS=ZSAJQUS
      INDCLYCBUS=CLYCBUS*1000
      INDCLKCBUS=CLKCBUS*1000
      INDCCNIBUS=CCNIBUS*1000
      INDEXICPUS=EXICPUS*3.412
      INDHVICBUS=HVICBUS*1000
      INDHVCCBUS=HVCCBUS*1000
      INDWWICBUS=WWICBUS*1000
      INDOWICBUS=OWICBUS*1000
      INDPCEPCONB=PCEPCONB*1000

        
    
  RETURN
  END SUBROUTINE INDEASY
!******************************************************************
  
  
!******************************************************************
! Subroutine to read in HGL and natural gas feedstock projections and recent data; added 6/25/2019 by NSK and NAL
  
Subroutine Read_feedstock (SEDSLASTYR, MAX_YEARS, FEEDYEARS, START_YR_FEEDSTOCK, IUNITFEED, NG, LPG, ETH, PROP, &
                              PPRLNE, NBUT, IBUT, NGASOL, NAPH)   ! These are dummy variables whose values are passed to aerngfeedhistory,
                                                                  ! aerlpgfeedhistory, aerethfeedhistory, aerpropanefeedhistory, aerpropylenefeedhistory,
                                                                  ! aernormbutanefeedhistory, aerisobutanefeedhistory, aernatgasolinefeedhistory, and aernaphfeedhistory, respectively
    
    Implicit None

    Integer, INTENT(IN) :: SEDSLASTYR, MAX_YEARS, FEEDYEARS, START_YR_FEEDSTOCK, IUNITFEED
    Integer IYEARFEED/0/, COUNT/0/   					                        ! IYEAR, COUNT initialized to 0 using /<number>/
    Real*8  NGAS_FEED, LPG_FEED, ETH_FEED, PROP_FEED, PPRLNE_FEED, NBUT_FEED, IBUT_FEED, NGASOL_FEED, NAPH_FEED       ! These values are a mix of SEDS data, MER data, STEO projections, and estimates from real-world research
    Real, intent(out), dimension (MAX_YEARS) :: NG            ! Natural gas feedstock
    Real, intent(out), dimension (MAX_YEARS) :: LPG           ! LPG total feedstock (to be removed after testing is finished in 2019)
    Real, intent(out), dimension (MAX_YEARS) :: ETH           ! Ethane feedstock
    Real, intent(out), dimension (MAX_YEARS) :: PROP          ! Propane feedstock
    Real, intent(out), dimension (MAX_YEARS) :: PPRLNE        ! Propylene feedstock
    Real, intent(out), dimension (MAX_YEARS) :: NBUT          ! Normal butane feedstock 
    Real, intent(out), dimension (MAX_YEARS) :: IBUT          ! Isobutane feedstock
    Real, intent(out), dimension (MAX_YEARS) :: NGASOL        ! Natural gasoline feedstock
    Real, intent(out), dimension (MAX_YEARS) :: NAPH          ! Naphtha feedstock
    
	Read(IUNITFEED, '()' )                          ! Skip first line (header)
        
    Do while (COUNT < MAX_YEARS)         				! Go from start year (as of 6/25/2019, currently 2006 is index 1) to last year (as of 6/25/2019 2021; index 16)
        Read(IUNITFEED,*) IYEARFEED, NGAS_FEED, LPG_FEED, ETH_FEED, PROP_FEED, PPRLNE_FEED, NBUT_FEED, IBUT_FEED, NGASOL_FEED, NAPH_FEED
 
        COUNT = IYEARFEED-START_YR_FEEDSTOCK+1  		! Go from start year (currently 2006) to last year (currently newest SEDS year plus 4)
        NG(COUNT)=NGAS_FEED                           ! Pass output values to WEXOG arrays
        LPG(COUNT)=LPG_FEED								
        ETH(COUNT)=ETH_FEED
        PROP(COUNT)=PROP_FEED
        PPRLNE(COUNT)=PPRLNE_FEED
        NBUT(COUNT)=NBUT_FEED
        IBUT(COUNT)=IBUT_FEED
        NGASOL(COUNT)=NGASOL_FEED
        NAPH(COUNT)=NAPH_FEED
    End do



End Subroutine Read_feedstock


Subroutine Read_coal (QCR_YEARS, IUNITCOAL, qcrdata, MNUMYR, NUMIND, IBYR, qcrcokeplnt, qcrindchp, qcrindnchp)
    
    Implicit None

    Integer, INTENT(IN) :: QCR_YEARS, MNUMYR, NUMIND, IBYR, IUNITCOAL
    Integer IYEARCOAL/0/, COUNT/0/, i/0/, j/0/			                        ! IYEAR, COUNT initialized to 0 using /<number>/
    Real*8  COKEPLNT, INDCHP, INDNCHP, FOOD, PAPER, BULKCHEM, GLASS, CEMENTLIME, IRONSTEEL, ALUMINUM, FABMETALS, MACHINERY, &
            COMPUTERS, TRANSEQUIP, ELECEQUIP, WOODPROD, PLASTIC, BALANCE       ! These values are a mix of SEDS data, MER data, STEO projections, and estimates from real-world research
    Real, intent(out), dimension (QCR_YEARS) :: qcrcokeplnt            ! Coke Plants
    Real, intent(out), dimension (QCR_YEARS) :: qcrindchp           ! Other Industrial CHP
    Real, intent(out), dimension (QCR_YEARS) :: qcrindnchp           ! Other Industrial Non-CHP
    Real, intent(out), dimension (MNUMYR,NUMIND,5) :: qcrdata          ! array of data across IDM classifications and census regions
    
	Read(IUNITCOAL, '()' )                          ! Skip first line (header)

	Do while (j < MNUMYR)
		j = j + 1
		Do while (i < NUMIND)
			i = i + 1
			qcrdata(i, j, 5) = 0
		End do
	End do
	
    Do while (COUNT < QCR_YEARS)         				! Go from last year in MECS to last year in QCR
		
		Read(IUNITCOAL,*) IYEARCOAL, COKEPLNT, INDCHP, INDNCHP, FOOD, PAPER, BULKCHEM, GLASS, CEMENTLIME, IRONSTEEL, ALUMINUM, FABMETALS,&
                            MACHINERY, COMPUTERS, TRANSEQUIP, ELECEQUIP, WOODPROD, PLASTIC, BALANCE

        COUNT = IYEARCOAL-ibyr+1  		! Go from start year (last MECS year) to last year (newest QCR year)

        qcrcokeplnt(COUNT)=COKEPLNT                           ! Pass output values to WEXOG arrays
        qcrindchp(COUNT)=INDCHP
        qcrindnchp(COUNT)=INDNCHP
		qcrdata(COUNT+IBYR-1989-1,7,5)=FOOD
		qcrdata(COUNT+IBYR-1989-1,8,5)=PAPER
		qcrdata(COUNT+IBYR-1989-1,9,5)=BULKCHEM
		qcrdata(COUNT+IBYR-1989-1,10,5)=GLASS
		qcrdata(COUNT+IBYR-1989-1,11,5)=CEMENTLIME
		qcrdata(COUNT+IBYR-1989-1,12,5)=IRONSTEEL
		qcrdata(COUNT+IBYR-1989-1,13,5)=ALUMINUM
        qcrdata(COUNT+IBYR-1989-1,14,5)=FABMETALS
		qcrdata(COUNT+IBYR-1989-1,15,5)=MACHINERY
        qcrdata(COUNT+IBYR-1989-1,16,5)=COMPUTERS
		qcrdata(COUNT+IBYR-1989-1,17,5)=TRANSEQUIP
        qcrdata(COUNT+IBYR-1989-1,18,5)=ELECEQUIP
        qcrdata(COUNT+IBYR-1989-1,19,5)=WOODPROD
        qcrdata(COUNT+IBYR-1989-1,20,5)=PLASTIC
		qcrdata(COUNT+IBYR-1989-1,21,5)=BALANCE
    End do

End Subroutine Read_coal


Subroutine Read_electric (ASM_YEARS, IUNITCOAL, asmdata, MNUMYR, NUMIND, IBYR)
    
    Implicit None

    Integer, INTENT(IN) :: ASM_YEARS, MNUMYR, NUMIND, IBYR, IUNITCOAL
    Integer IYEARCOAL/0/, COUNT/0/, i/0/, j/0/	                        ! IYEAR, COUNT initialized to 0 using /<number>/
    Real*8  FOOD, PAPER, BULKCHEM, GLASS, CEMENTLIME, IRONSTEEL, ALUMINUM, FABMETALS, MACHINERY, COMPUTERS, TRANSEQUIP, ELECEQUIP, WOODPROD, &
            PLASTIC, BALANCE       ! IDM industrial classifications
    Real, intent(out), dimension (MNUMYR,NUMIND,5) :: asmdata          ! array of data across IDM classifications and census regions
    
	Read(IUNITCOAL, '()' )                          ! Skip first line (header)
    
	Do while (j < MNUMYR)
		j = j + 1
		Do while (i < NUMIND)
			i = i + 1
			asmdata(i, j, 5) = 0
		End do
	End do

    Do while (COUNT < ASM_YEARS)         				! Go from last year in MECS to last year in QCR
		
		Read(IUNITCOAL,*) IYEARCOAL, FOOD, PAPER, BULKCHEM, GLASS, CEMENTLIME, IRONSTEEL, ALUMINUM, FABMETALS, MACHINERY, COMPUTERS, &
                            TRANSEQUIP, ELECEQUIP, WOODPROD, PLASTIC, BALANCE

        COUNT = IYEARCOAL-ibyr+1  		! Go from start year (currently 2006) to last year (currently newest SEDS year plus 4)
		asmdata(COUNT+IBYR-1989-1,7,5)=FOOD
		asmdata(COUNT+IBYR-1989-1,8,5)=PAPER
        asmdata(COUNT+IBYR-1989-1,9,5)=BULKCHEM
		asmdata(COUNT+IBYR-1989-1,10,5)=GLASS
		asmdata(COUNT+IBYR-1989-1,11,5)=CEMENTLIME
		asmdata(COUNT+IBYR-1989-1,12,5)=IRONSTEEL
		asmdata(COUNT+IBYR-1989-1,13,5)=ALUMINUM
		asmdata(COUNT+IBYR-1989-1,14,5)=FABMETALS
		asmdata(COUNT+IBYR-1989-1,15,5)=MACHINERY
		asmdata(COUNT+IBYR-1989-1,16,5)=COMPUTERS
		asmdata(COUNT+IBYR-1989-1,17,5)=TRANSEQUIP
		asmdata(COUNT+IBYR-1989-1,18,5)=ELECEQUIP
		asmdata(COUNT+IBYR-1989-1,19,5)=WOODPROD
		asmdata(COUNT+IBYR-1989-1,20,5)=PLASTIC
		asmdata(COUNT+IBYR-1989-1,21,5)=BALANCE
	End do

	
End Subroutine Read_electric


!Subroutine to read in LPG and natural gas feedstock history numbers; added 6/25/2019 by NSK and NAL
!************************************
  
Subroutine Read_feedstock_AER (IUNITFAER, AER_NG, AER_LPG, AER_ETH, AER_PROP, AER_PPLNE, AER_NBUT, AER_IBUT, AER_NATGASOL, AER_NAPH)  ! These are dummy variables whose values are passed to aerngfeedhistory,
																																	  
    Implicit None

    Integer, INTENT(IN) :: IUNITFAER
    Integer IYEARFEED_AER/0/, COUNT_AER/0/                                   ! IYEARFEED_AER, COUNT_AER initialized to 0 using /<number>/
    Real*8  AER_NGAS_FEED, AER_LPG_FEED, AER_ETH_FEED, AER_PROP_FEED, AER_PPLNE_FEED, AER_NBUT_FEED,  AER_IBUT_FEED, AER_NATGASOL_FEED, AER_NAPH_FEED       ! These data are from the State Energy Data System
    Real, intent(out), dimension (16) :: AER_NG           ! Natural gas feedstock history
    Real, intent(out), dimension (16) :: AER_LPG          ! LPG total feedstock history (to be removed after testing is finished in 2019)
    Real, intent(out), dimension (16) :: AER_ETH          ! Ethane feedstock history
    Real, intent(out), dimension (16) :: AER_PROP         ! Propane feedstock history
    Real, intent(out), dimension (16) :: AER_PPLNE        ! Propylene feedstock history
    Real, intent(out), dimension (16) :: AER_NBUT         ! Normal butane feedstock history
    Real, intent(out), dimension (16) :: AER_IBUT         ! Isobutane feedstock history
    Real, intent(out), dimension (16) :: AER_NATGASOL     ! Natural gasoline feedstock history
    Real, intent(out), dimension (16) :: AER_NAPH         ! Naphtha feedstock history
    
    Read(IUNITFAER, '()' )                              ! Skip first line (header)
        
    Do while (COUNT_AER < 16)         				    ! Go from 1990 (1) to 2005 (16), inclusive
        Read(IUNITFAER,*) IYEARFEED_AER, AER_NGAS_FEED, AER_LPG_FEED, AER_ETH_FEED, AER_PROP_FEED, AER_PPLNE_FEED, &
							AER_NBUT_FEED, AER_IBUT_FEED, AER_NATGASOL_FEED, AER_NAPH_FEED
							
        COUNT_AER = IYEARFEED_AER-1990+1  			    ! Go from 1990 (index 1) to 2005 (index 16), inclusive

        AER_NG(COUNT_AER)=AER_NGAS_FEED					! Pass output values to WEXOG arrays
        AER_LPG(COUNT_AER)=AER_LPG_FEED
        AER_ETH(COUNT_AER)=AER_ETH_FEED
        AER_PROP(COUNT_AER)=AER_PROP_FEED
        AER_PPLNE(COUNT_AER)=AER_PPLNE_FEED
        AER_NBUT(COUNT_AER)=AER_NBUT_FEED
        AER_IBUT(COUNT_AER)=AER_IBUT_FEED
        AER_NATGASOL(COUNT_AER)=AER_NATGASOL_FEED
        AER_NAPH(COUNT_AER)=AER_NAPH_FEED
	End do


End Subroutine Read_feedstock_AER

!*************************************************************************
! Subroutine to benchmark to MECS data for the tech industries. The MECS data is read from ironstl.xlsx

SUBROUTINE BENCHMECS(con,mecsbench)
!bench one year after MECS using MECS actual data from ironstl and MECS year model results
    use i_
    IMPLICIT NONE
    real con(18,5)
    real mecsbench(9)
    integer ii,iff,ifuel
	
    
     ! this if block looks OK.  it computes the mecsbench factors in 2015 as the ratio of 
	 ! mecs data to the con variables-- then recomputes the con variables in 2015
	 ! the problem is after 2015 (ibyr2+2)-- not the code, the 
	if ((CURCALYR==(ibyr2+2)).and.(curitr.eq.1)) then
        if (inddir.eq.11) then !if cement add lime and cement MECS data
          do ii=1,9
            MECS_Data(inddir,INDREG,ii)=MECS_Data(inddir,INDREG,ii)+MECS_Data(9,INDREG,ii)
          enddo
         ! MECS_Data(inddir,INDREG,2)=asrdata(29,11,INDREG)      ! Make electricity match ASM data, which should already include lime
          MECS_Data(inddir,INDREG,7)=qcrdata(29,11,INDREG)      ! Make steam coal match read in QCR data, which already includes lime
        endif
        if (con(1,indreg).ne.0.0) mecsbench(1)=MECS_Data(inddir,INDREG,2)/CON(1,indreg)   !elec
        if (con(2,indreg).ne.0.0) mecsbench(2)=MECS_Data(inddir,INDREG,5)/CON(2,indreg)   !ngas
        if (con(6,indreg).ne.0.0) mecsbench(3)=MECS_Data(inddir,INDREG,3)/CON(6,indreg)   !resid
        if (con(3,indreg).ne.0.0) mecsbench(4)=MECS_Data(inddir,INDREG,7)/CON(3,indreg)   !steam coal
        if (con(7,indreg).ne.0.0) mecsbench(5)=MECS_Data(inddir,INDREG,4)/CON(7,indreg)   !distillate
        if (con(8,indreg).ne.0.0) mecsbench(6)=MECS_Data(inddir,INDREG,6)/CON(8,indreg)   !propane
        if (con(11,indreg).ne.0.0) mecsbench(7)=MECS_Data(inddir,INDREG,8)/CON(11,indreg) !pet coke
        if (con(18,indreg).ne.0.0) mecsbench(8)=MECS_Data(inddir,INDREG,9)/CON(18,indreg) !renewables
        if (inddir.eq.12) then
           if (con(4,indreg).ne.0.0) mecsbench(9)=MECS_Data(inddir,INDREG,8)/CON(4,indreg) !met coal
        else
            mecsbench(9)=0.0
        endif
        con(1,indreg)=con(1,indreg)*mecsbench(1)      !elec
        con(2,indreg)=con(2,indreg)*mecsbench(2)      !ngas
        con(3,indreg)=con(3,indreg)*mecsbench(4)      !steam coal
        con(4,indreg)=con(4,indreg)*mecsbench(9)      !met coal
        con(6,indreg)=con(6,indreg)*mecsbench(3)      !resid
        con(7,indreg)=con(7,indreg)*mecsbench(5)      !distillate
        con(8,indreg)=con(8,indreg)*mecsbench(6)      !propane
        con(11,indreg)=con(11,indreg)*mecsbench(7)    !pet coke
        con(18,indreg)=con(18,indreg)*mecsbench(8)    !renewables
        if (indreg.eq.4) then !retally totals
           con(1,5)=SUM(con(1,1:4))                   !elec
           con(2,5)=SUM(con(2,1:4))                   !ngas
           con(6,5)=SUM(con(6,1:4))                   !resid
           con(3,5)=SUM(con(3,1:4))                   !steam coal
           con(4,5)=SUM(con(4,1:4))                   !met coal
           con(7,5)=SUM(con(7,1:4))                   !distillate
           con(8,5)=SUM(con(8,1:4))                   !propane
           con(11,5)=SUM(con(11,1:4))                 !pet coke
           con(18,5)=SUM(con(18,1:4))                 !renewables
        endif   
    endif

    if (CURCALYR.ge.(ibyr2+2)) then 
	    ENPMQTY(1)=mecsbench(1)*ENPMQTY(1) !ixEL
	    ENPMQTY(3)=mecsbench(2)*ENPMQTY(3) !ngas
        ENPMQTY(4)=mecsbench(2)*ENPMQTY(4) !non core gas
        ENPMQTY(6)=mecsbench(2)*ENPMQTY(6) !lease and plant gas
!NSK        ENPMQTY(7)=mecsbench(4)*ENPMQTY(7) !ixCL
	    ENPMQTY(10)=mecsbench(3)*ENPMQTY(10) !ixRF
	    
        if (inddir.eq.12) then 
          ENPMQTY(8)=mecsbench(9)*ENPMQTY(8) !ixMC
          bypbscm(8)=mecsbench(9)*bypbscm(8)
        else
          ENPMQTY(8)=0.0 !no met coal in MECS
          bypbscm(8)=0.0
        endif
        ENPMQTY(11)=mecsbench(5)*ENPMQTY(11) !distillate
        ENPMQTY(12)=mecsbench(6)*ENPMQTY(12) !propane
        ENPMQTY(16)=mecsbench(7)*ENPMQTY(16) !pet coke
        ENPMQTY(18)=mecsbench(6)*ENPMQTY(18) !renewables---KPE-lubes & waxes; using propane bench for now
        ENPMQTY(22)=0.0                      !other petroleum
        
	    ensqty(1)=mecsbench(2)*ensqty(1)  !non core ng
	    ensqty(3)=mecsbench(3)*ensqty(3) !resid
!NSK	    ensqty(2)=mecsbench(4)*ensqty(2) !steam coal
        ensqty(4)=mecsbench(5)*ensqty(4) !distillate
        ensqty(5)=mecsbench(6)*ensqty(5) ! propane
        if ((inddir.eq.8) .or.(inddir.eq.12)) then
          ensqty(6)=mecsbench(7)*ensqty(6) !pet coke
          ensqty(7)=0.0 !mecsbench()*ensqty(7) !other pet
          ensqty(8)=mecsbench(8)*ensqty(7) !renewables
          ensqty(9)=mecsbench(8)*ensqty(7) !renewables
        else
          ensqty(6)=mecsbench(8)*ensqty(6) !renewables
          ensqty(7)=mecsbench(8)*ensqty(7) !renewables
        endif
        
        enbqty(1:5,1)=mecsbench(1)*enbqty(1:5,1) !elec
        enbqty(1:5,2)=mecsbench(2)*enbqty(1:5,2) !ng
        !enbqty(1:5,3)=mecsbench()*enbqty(1:5,3) !steam
        enbqty(1:5,4)=mecsbench(5)*enbqty(1:5,4) !dist
        enbqty(1:5,5)=mecsbench(6)*enbqty(1:5,5) !lpg
        
        bypbscm(1)=mecsbench(1)*bypbscm(1) !ixEL
	    bypbscm(3)=mecsbench(2)*bypbscm(3) !ngas
        bypbscm(4)=mecsbench(2)*bypbscm(4) !non core gas
        bypbscm(6)=mecsbench(2)*bypbscm(6) !lease and plant gas
!NSK        bypbscm(7)=mecsbench(4)*bypbscm(7) !ixCL
	    bypbscm(10)=mecsbench(3)*bypbscm(10) !RF     
        bypbscr(1:9)=mecsbench(8)*bypbscr(1:9) !renewables
        enprqty(1:9)=mecsbench(8)*enprqty(1:9) !renewables

    endif
	
	return
	end

!*************************************************************************
! Subroutine to benchmark coal consumption by industry to Quarterly Coal Report (QCR) data and electricity to Annual Survey of Manufacturers (ASM)

SUBROUTINE BENCHHIST(con,icr)
    use i_
    IMPLICIT NONE
    real con(18,5)
    real hist_bench(mnumyr,numind,5,9)   ! steam coal and electricity benchmark as a function of year, industry, census region, and fuel (fuel codes match mecsbench fuel codes)
                                         ! index 1 is purchased electricity and 4 is steam coal
    integer ii,iff,ifuel,icr
    DO ii=1,4   ! dummy variable for icr

     ! E  IF ((con(1,5).ne.0.0).and.(NCRL.ne.1)) THEN   ! purchased electricity benchmarking
     ! E      IF ((curcalyr.ge.ibyr2+2).and.(curcalyr.le.END_YR_ASM)) THEN  ! 
     ! E          hist_bench(curiyr,inddir,ii,1)=asmdata(curiyr,inddir,5)/con(1,5)
     ! E      ELSEIF (curcalyr.gt.END_YR_ASM) THEN
     ! E          hist_bench(curiyr,inddir,ii,1)=hist_bench(curiyr-1,inddir,ii,1)
     ! E      ELSE
     ! E          hist_bench(curiyr,inddir,ii,1)=1.0
     ! E      ENDIF
            
     ! E      con(1,ii)=con(1,ii)*hist_bench(curiyr,inddir,ii,1)      ! purchased electricity
            
     ! E      IF (ii.eq.4) THEN 				! retally totals
     ! E          con(1,5)=SUM(con(1,1:4))	! purchased electricity
     ! E          IF (inddir.eq.8) WRITE(6,*) 'NSK test 1', curcalyr, curitr, con(1,5)
     ! E      ENDIF
            
     ! E  ENDIF
        
        IF (con(3,5).ne.0.0) THEN   ! steam coal benchmarking
            IF ((curcalyr.ge.ibyr).and.(curcalyr.le.END_YR_QCR)) THEN
                hist_bench(curiyr,inddir,ii,4)=qcrdata(curiyr,inddir,5)/con(3,5)
            ELSEIF (curcalyr.gt.END_YR_QCR) THEN
                hist_bench(curiyr,inddir,ii,4)=hist_bench(curiyr-1,inddir,ii,4)
            ELSE
                hist_bench(curiyr,inddir,ii,4)=1.0
            ENDIF
     
            con(3,ii)=con(3,ii)*hist_bench(curiyr,inddir,ii,4)      ! steam coal
            
            IF (ii.eq.4) THEN 				! retally totals
                con(3,5)=SUM(con(3,1:4))    ! steam coal
            ENDIF
        ENDIF
        
    ENDDO 
	return
END SUBROUTINE BENCHHIST

Subroutine Read_eth_frac(MAX_FRAC_YEARS, IUNITFRACETH, Eth_Frac)   ! Eth_frac is a dummy variable whose value is passed to EthaneDivFrac
    
    Implicit None

    Integer, INTENT(IN) :: MAX_FRAC_YEARS, IUNITFRACETH
    Integer IYEARFEED_FRAC/0/, COUNT_FRAC/0/   					                        ! IYEAR, COUNT initialized to 0 using /<number>/
    Real*8  Eth_Frac_1, Eth_Frac_2, Eth_Frac_3, Eth_Frac_4, Eth_Frac_5, Eth_Frac_6, Eth_Frac_7, Eth_Frac_8, Eth_Frac_9
    Real, intent(out), dimension (9, MAX_FRAC_YEARS) :: Eth_Frac
    
    Read(IUNITFRACETH, '()' )                          ! Skip first line (header)
        
    Do while (COUNT_FRAC < MAX_FRAC_YEARS)         				! Go from 1990 to last year (STEOLASTYR+4); each column corresponds to a Census Division
        Read(IUNITFRACETH,*) IYEARFEED_FRAC, Eth_Frac_1, Eth_Frac_2, Eth_Frac_3, Eth_Frac_4, Eth_Frac_5, Eth_Frac_6, Eth_Frac_7, Eth_Frac_8, Eth_Frac_9
        
        COUNT_FRAC = COUNT_FRAC+1
      
        ! Pass output values to EthaneDivFrac array; each column corresponds to a Census Division
        
        Eth_Frac(1, COUNT_FRAC)=Eth_Frac_1            ! New England                    
        Eth_Frac(2, COUNT_FRAC)=Eth_Frac_2            ! Middle Atlantic  
        Eth_Frac(3, COUNT_FRAC)=Eth_Frac_3            ! East_North_Central
        Eth_Frac(4, COUNT_FRAC)=Eth_Frac_4            ! West North Central
        Eth_Frac(5, COUNT_FRAC)=Eth_Frac_5            ! South Atlantic
        Eth_Frac(6, COUNT_FRAC)=Eth_Frac_6            ! East South Central
        Eth_Frac(7, COUNT_FRAC)=Eth_Frac_7            ! West South Central
        Eth_Frac(8, COUNT_FRAC)=Eth_Frac_8            ! Mountain
        Eth_Frac(9, COUNT_FRAC)=Eth_Frac_9            ! Pacific             
    End Do
    
End Subroutine Read_eth_frac


Subroutine Read_prop_frac(MAX_FRAC_YEARS, IUNITFRACPROP, Prop_Frac)   ! Prop_frac is a dummy variable whose value is passed to PropaneDivFrac
    
    Implicit None

    Integer, INTENT(IN) :: MAX_FRAC_YEARS, IUNITFRACPROP
    Integer IYEARFEED_FRAC/0/, COUNT_FRAC/0/   					                        ! IYEAR, COUNT initialized to 0 using /<number>/
    Real*8  Prop_Frac_1, Prop_Frac_2, Prop_Frac_3, Prop_Frac_4, Prop_Frac_5, Prop_Frac_6, Prop_Frac_7, Prop_Frac_8, Prop_Frac_9
    Real, intent(out), dimension (9, MAX_FRAC_YEARS) :: Prop_Frac

    Read(IUNITFRACPROP, '()' )                          ! Skip first line (header)
        
    Do while (COUNT_FRAC < MAX_FRAC_YEARS)         				! Go from 1990 to last year (STEOLASTYR+4); each column corresponds to a Census Division
        Read(IUNITFRACPROP,*) IYEARFEED_FRAC, Prop_Frac_1, Prop_Frac_2, Prop_Frac_3, Prop_Frac_4, Prop_Frac_5, Prop_Frac_6, Prop_Frac_7, Prop_Frac_8, Prop_Frac_9
        
        COUNT_FRAC = COUNT_FRAC+1
      
        ! Pass output values to PropaneDivFrac array; each column corresponds to a Census Division
        
        Prop_Frac(1, COUNT_FRAC)=Prop_Frac_1            ! New England                    
        Prop_Frac(2, COUNT_FRAC)=Prop_Frac_2            ! Middle Atlantic  
        Prop_Frac(3, COUNT_FRAC)=Prop_Frac_3            ! East_North_Central
        Prop_Frac(4, COUNT_FRAC)=Prop_Frac_4            ! West North Central
        Prop_Frac(5, COUNT_FRAC)=Prop_Frac_5            ! South Atlantic
        Prop_Frac(6, COUNT_FRAC)=Prop_Frac_6            ! East South Central
        Prop_Frac(7, COUNT_FRAC)=Prop_Frac_7            ! West South Central
        Prop_Frac(8, COUNT_FRAC)=Prop_Frac_8            ! Mountain
        Prop_Frac(9, COUNT_FRAC)=Prop_Frac_9            ! Pacific             
    End Do


End Subroutine Read_prop_frac

! New function to calculate the fade factor in WEXOG based on fade years & if sidecase 
    FUNCTION fade_factor(fadexyrs,indbmov) ! (fadexyrs,feath,indbmov)  !  
    use i_
    implicit none
	integer fadexyrs,indbmov,feath
	integer ix
!	real FADE
    real fade_factor   ! fade variable 
	real, parameter :: pi = 3.1415927


    ! real sum1, prodsum, vintage_index
    ! integer stepnum]
	
	fade_factor = 0.0  ! initialize
	
 !	if (CURCALYR .GT. SedsLastYr) then
	!	if (CURCALYR .LE. (SedsLastYr + fadexyrs - feath )) then
	!		do ix = 1,fadexyrs-feath`
	!			if (curcalyr .eq. (SedsLastYr + 1 + ix - indbmov)) fade_factor = (ix - indbmov)/fadexyrs
	!		enddo
	!	else if (CURCALYR .LE. (SedsLastYr + fadexyrs)) then
	!	   do ix = fadexyrs-feath+1,fadexyrs`
	!			if (curcalyr .eq. (SedsLastYr ix - indbmov)) fade_factor = 0.5*(ix - indbmov)/fadexyrs
	!		enddo
	!	else fade_factor = 0.0
	!	endif
	
	! alternative --- use sin() function backwards from pi/2 to 0 so we 
	! get the "feathering" automatically
	 
!		if (CURCALYR .LE. SedsLastYr) fade_factor = 1.0
	  
		if ((CURCALYR .GT. SedsLastYr).and.(CURCALYR .LE. (STEOLastYr + fadexyrs - indbmov))) then
		  IF (CURCALYR .LE. (STEOLastYr - indbmov)) THEN
			fade_factor=1.0         ! STEO Years 2010-2013
          else ! if (curcalyr .GT. (STEOLastYr - indbmov)) then
!			if (indbmovr == 0) then
				do ix = 1,fadexyrs
					if (curcalyr .eq. (STEOLastYr + ix - indbmov)) then
					   fade_factor = max(0.0,1.0 - sin((pi/2)*ix/fadexyrs)) ! last # in ix - inbmov exp empirical
					   GO TO 380 ! we have our factor, so no use hanging around
				!	else
				!	   fade_factor = 0.0
					endif   
				enddo
!			 else
!			 	do ix = 1,fadexyrs
!					if (curcalyr .eq. (STEOLastYr + ix - indbmov)) then
!					   fade_factor = max(0.0,1.0 - sin((pi/2)*(ix - indbmov + 0.5)/fadexyrs)) ! last # in ix - inbmov exp empirical
!					   GO TO 380 ! we have our factor, so no use hanging around
				!	else
				!	   fade_factor = 0.0
!					endif   
!				enddo

!			 endif
380			CONTINUE
		  endif
		endif

    RETURN 
    END  function fade_factor