/*  $Header: M:/default/source/RCS/gdxf9glu.c,v 1.3 2018/03/13 13:11:05 dsa Exp $ /*
/*  C code generated by apiwrapper for GAMS Version 24.2.1 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <ctype.h>
#include <errno.h>
#include <gdxf9glu.h>

#if defined(_WIN32)
# include <windows.h>
# define GDX_CALLCONV __stdcall
# if ! defined F9_CALLCONV
#  define F9_CALLCONV __stdcall
# endif
  static char winErr[] = "Windows error";
  typedef HINSTANCE soHandle_t;
#else
# define GDX_CALLCONV
# if ! defined F9_CALLCONV
#  define F9_CALLCONV
# endif
# include <unistd.h>
# include <dlfcn.h>
# include <sys/utsname.h>
  typedef void *soHandle_t;
#endif

typedef int (GDX_CALLCONV *errorCallbackFort_t) (int *errCount, const char *msg, int msgLen);
#if defined(_WIN32)
typedef __int64 INT64;
#elif defined(__LP64__) || defined(__axu__) || defined(_FCGLU_LP64_)
typedef signed long int INT64;
#else
typedef signed long long int INT64;
#endif


#include "gclgms.h"
static soHandle_t hLibGlobal;  /* global shared library handle */
static int isLoaded = 0;
static int objectCount = 0;
static int screenIndicator = 1;
static int exceptionIndicator = 0;
static int exitIndicator = 1;
static errorCallbackFort_t errorCallbackFort = NULL;
static int APIErrorCount = 0;
static int trimflag  = 1;

#if defined(HAVE_MUTEX)
#include "gcmt.h"
static GC_mutex_t libMutex;
static GC_mutex_t objMutex;
static GC_mutex_t exceptMutex;
static int MutexIsInitialized = 0;

void gdxF90InitMutexes(void)
{
  int rc;

  if (!MutexIsInitialized) {
    rc = GC_mutex_init (&libMutex);     assert(0==rc);
    rc = GC_mutex_init (&objMutex);     assert(0==rc);
    rc = GC_mutex_init (&exceptMutex);  assert(0==rc);
    MutexIsInitialized = 1;
  }
} /* gdxF90InitMutexes */

void gdxF90FiniMutexes(void)
{
  if (MutexIsInitialized) {
    GC_mutex_delete (&libMutex);
    GC_mutex_delete (&objMutex);
    GC_mutex_delete (&exceptMutex);
    MutexIsInitialized = 0;
  }
} /* gdxF90FiniMutexes */

#  define lock(MUTEX)   if(MutexIsInitialized) GC_mutex_lock (&MUTEX);
#  define unlock(MUTEX) if(MutexIsInitialized) GC_mutex_unlock (&MUTEX);
#else
#  define lock(MUTEX)   ;
#  define unlock(MUTEX) ;
void gdxF90InitMutexes(void) {}
void gdxF90FiniMutexes(void) {}
#endif

typedef char string255[256];
typedef char stringf255[255];
typedef char cBuf512_t[512];
typedef int gdxBoolean_t;
typedef union foo { void *p; INT64 i; } u64_t;


static void convertF2PAS (const char* src, char *dest, int s_len, int p_len)
{
  int i;
  int len;

  len = s_len;
  if (trimflag)
    for (;;) {
      if (len==0) break;
      if (src[len-1] != ' ') break;
      --len;
    }
  if (p_len<len)
    len = p_len;
  for (i=0; i<len; ++i)
    dest[i+1] = src[i];
  dest[0] = len;
} /* convertF2PAS */


static void convertPAS2F (const char *src, char *dest, int s_len)
{
  int i, len;
  unsigned char s0;

  for (i = 0;  i < s_len;  i++)
    dest[i] = ' ';
  s0 = src[0];
  len = s_len;
  if (s0 < len)
    len = s0;
  for (i = 0;  i < len;  i++)
    dest[i] = src[i+1];
} /* convertPAS2F */


static void convertF2C(const char* sf, char *sc, int fSize, int cSize)
{
  int i;
  int count;

  count = fSize;
  while ((count>0) && (sf[count-1]==' '))
    --count;
  if (cSize-1<count)
    count = cSize-1;
  for (i=0; i<count; ++i)
    sc[i] = sf[i];
  sc[count] = '\0';
} /* convertF2C */


static void convertC2F(const char* sc, char *sf, int s_len)
{
  int i, len;
  unsigned char s0;
  for (i=0; i<s_len; ++i)
    sf[i] = ' ';
  s0 = strlen(sc);
  len = s_len;
  if (s0 < len)
    len = s0;
  for (i=0; i<len; ++i)
    sf[i] = sc[i];
} /* convertC2F */

/* pad the buffer with blanks, including whacking the terminating nul */
static void blankPad (char *buf, int len, int siz)
{
  if (siz >= len) {
    memset (buf+len, ' ', siz-len);
  }
}

typedef gdxBoolean_t (GDX_CALLCONV *XCreate_t) (void *pgdx);
static XCreate_t XCreate = NULL;
typedef gdxBoolean_t (GDX_CALLCONV *XFree_t)   (void *pgdx);
static XFree_t   XFree = NULL;
typedef int (GDX_CALLCONV *XAPIVersion_t) (int api, char *msg, int *cl);
static XAPIVersion_t XAPIVersion = NULL;
typedef int (GDX_CALLCONV *XCheck_t) (char *ep, int nargs, int s[], char *msg);
static XCheck_t XCheck = NULL;


typedef void (GDX_CALLCONV *TDataStoreProc_F_t) (const int Indx[], const double Vals[]);
typedef void (GDX_CALLCONV *TDomainIndexProc_F_t) (int *RawIndex, int *MappedIndex, void *Uptr);

static void errorHandling (const char *msg)
{
  int msgLen;
  int tmp;

  APIErrorCount++;
  if (screenIndicator) {
    printf("FIX ME in C glu: %s\n", msg);
    fflush(stdout);
  }
  lock(exceptMutex);
  if (errorCallbackFort) {
    msgLen = strlen(msg);
    tmp = APIErrorCount;
    if (errorCallbackFort(&tmp, msg, msgLen)) {
      unlock(exceptMutex);
      exit(123);
    }
  }
  unlock(exceptMutex);
  assert(!exceptionIndicator);
  if (exitIndicator)
    exit(123);
}



typedef void (GDX_CALLCONV *gdxSetLoadPath_t) (const char *s);
static gdxSetLoadPath_t gdxSetLoadPath = NULL;
typedef void (GDX_CALLCONV *gdxGetLoadPath_t) (char *s);
static gdxGetLoadPath_t gdxGetLoadPath = NULL;

/* Prototypes for Dummy Functions */
int  GDX_CALLCONV d_gdxAcronymAdd (void *pgdx, const char *AName, const char *Txt, int AIndx);
int  GDX_CALLCONV d_gdxAcronymCount (void *pgdx);
int  GDX_CALLCONV d_gdxAcronymGetInfo (void *pgdx, int N, char *AName, char *Txt, int *AIndx);
int  GDX_CALLCONV d_gdxAcronymGetMapping (void *pgdx, int N, int *orgIndx, int *newIndx, int *autoIndex);
int  GDX_CALLCONV d_gdxAcronymIndex (void *pgdx, double V);
int  GDX_CALLCONV d_gdxAcronymName (void *pgdx, double V, char *AName);
int  GDX_CALLCONV d_gdxAcronymNextNr (void *pgdx, int NV);
int  GDX_CALLCONV d_gdxAcronymSetInfo (void *pgdx, int N, const char *AName, const char *Txt, int AIndx);
double  GDX_CALLCONV d_gdxAcronymValue (void *pgdx, int AIndx);
int  GDX_CALLCONV d_gdxAddAlias (void *pgdx, const char *Id1, const char *Id2);
int  GDX_CALLCONV d_gdxAddSetText (void *pgdx, const char *Txt, int *TxtNr);
int  GDX_CALLCONV d_gdxAutoConvert (void *pgdx, int NV);
int  GDX_CALLCONV d_gdxClose (void *pgdx);
int  GDX_CALLCONV d_gdxDataErrorCount (void *pgdx);
int  GDX_CALLCONV d_gdxDataErrorRecord (void *pgdx, int RecNr, int KeyInt[], double Values[]);
int  GDX_CALLCONV d_gdxDataReadDone (void *pgdx);
int  GDX_CALLCONV d_gdxDataReadFilteredStart (void *pgdx, int SyNr, const int FilterAction[], int *NrRecs);
int  GDX_CALLCONV d_gdxDataReadMap (void *pgdx, int RecNr, int KeyInt[], double Values[], int *DimFrst);
int  GDX_CALLCONV d_gdxDataReadMapStart (void *pgdx, int SyNr, int *NrRecs);
int  GDX_CALLCONV d_gdxDataReadRaw (void *pgdx, int KeyInt[], double Values[], int *DimFrst);
int  GDX_CALLCONV d_gdxDataReadRawFast (void *pgdx, int SyNr, TDataStoreProc_F_t DP, int *NrRecs);
int  GDX_CALLCONV d_gdxDataReadRawStart (void *pgdx, int SyNr, int *NrRecs);
int  GDX_CALLCONV d_gdxDataReadSlice (void *pgdx, const char *UelFilterStr[], int *Dimen, TDataStoreProc_F_t DP);
int  GDX_CALLCONV d_gdxDataReadSliceStart (void *pgdx, int SyNr, int ElemCounts[]);
int  GDX_CALLCONV d_gdxDataReadStr (void *pgdx, char *KeyStr[], double Values[], int *DimFrst);
int  GDX_CALLCONV d_gdxDataReadStrStart (void *pgdx, int SyNr, int *NrRecs);
int  GDX_CALLCONV d_gdxDataSliceUELS (void *pgdx, const int SliceKeyInt[], char *KeyStr[]);
int  GDX_CALLCONV d_gdxDataWriteDone (void *pgdx);
int  GDX_CALLCONV d_gdxDataWriteMap (void *pgdx, const int KeyInt[], const double Values[]);
int  GDX_CALLCONV d_gdxDataWriteMapStart (void *pgdx, const char *SyId, const char *ExplTxt, int Dimen, int Typ, int UserInfo);
int  GDX_CALLCONV d_gdxDataWriteRaw (void *pgdx, const int KeyInt[], const double Values[]);
int  GDX_CALLCONV d_gdxDataWriteRawStart (void *pgdx, const char *SyId, const char *ExplTxt, int Dimen, int Typ, int UserInfo);
int  GDX_CALLCONV d_gdxDataWriteStr (void *pgdx, const char *KeyStr[], const double Values[]);
int  GDX_CALLCONV d_gdxDataWriteStrStart (void *pgdx, const char *SyId, const char *ExplTxt, int Dimen, int Typ, int UserInfo);
int  GDX_CALLCONV d_gdxGetDLLVersion (void *pgdx, char *V);
int  GDX_CALLCONV d_gdxErrorCount (void *pgdx);
int  GDX_CALLCONV d_gdxErrorStr (void *pgdx, int ErrNr, char *ErrMsg);
int  GDX_CALLCONV d_gdxFileInfo (void *pgdx, int *FileVer, int *ComprLev);
int  GDX_CALLCONV d_gdxFileVersion (void *pgdx, char *FileStr, char *ProduceStr);
int  GDX_CALLCONV d_gdxFilterExists (void *pgdx, int FilterNr);
int  GDX_CALLCONV d_gdxFilterRegister (void *pgdx, int UelMap);
int  GDX_CALLCONV d_gdxFilterRegisterDone (void *pgdx);
int  GDX_CALLCONV d_gdxFilterRegisterStart (void *pgdx, int FilterNr);
int  GDX_CALLCONV d_gdxFindSymbol (void *pgdx, const char *SyId, int *SyNr);
int  GDX_CALLCONV d_gdxGetElemText (void *pgdx, int TxtNr, char *Txt, int *Node);
int  GDX_CALLCONV d_gdxGetLastError (void *pgdx);
INT64  GDX_CALLCONV d_gdxGetMemoryUsed (void *pgdx);
int  GDX_CALLCONV d_gdxGetSpecialValues (void *pgdx, double AVals[]);
int  GDX_CALLCONV d_gdxGetUEL (void *pgdx, int UelNr, char *Uel);
int  GDX_CALLCONV d_gdxMapValue (void *pgdx, double D, int *sv);
int  GDX_CALLCONV d_gdxOpenAppend (void *pgdx, const char *FileName, const char *Producer, int *ErrNr);
int  GDX_CALLCONV d_gdxOpenRead (void *pgdx, const char *FileName, int *ErrNr);
int  GDX_CALLCONV d_gdxOpenWrite (void *pgdx, const char *FileName, const char *Producer, int *ErrNr);
int  GDX_CALLCONV d_gdxOpenWriteEx (void *pgdx, const char *FileName, const char *Producer, int Compr, int *ErrNr);
int  GDX_CALLCONV d_gdxResetSpecialValues (void *pgdx);
int  GDX_CALLCONV d_gdxSetHasText (void *pgdx, int SyNr);
int  GDX_CALLCONV d_gdxSetReadSpecialValues (void *pgdx, const double AVals[]);
int  GDX_CALLCONV d_gdxSetSpecialValues (void *pgdx, const double AVals[]);
int  GDX_CALLCONV d_gdxSetTextNodeNr (void *pgdx, int TxtNr, int Node);
int  GDX_CALLCONV d_gdxSetTraceLevel (void *pgdx, int N, const char *s);
int  GDX_CALLCONV d_gdxSymbIndxMaxLength (void *pgdx, int SyNr, int LengthInfo[]);
int  GDX_CALLCONV d_gdxSymbMaxLength (void *pgdx);
int  GDX_CALLCONV d_gdxSymbolAddComment (void *pgdx, int SyNr, const char *Txt);
int  GDX_CALLCONV d_gdxSymbolGetComment (void *pgdx, int SyNr, int N, char *Txt);
int  GDX_CALLCONV d_gdxSymbolGetDomain (void *pgdx, int SyNr, int DomainSyNrs[]);
int  GDX_CALLCONV d_gdxSymbolGetDomainX (void *pgdx, int SyNr, char *DomainIDs[]);
int  GDX_CALLCONV d_gdxSymbolDim (void *pgdx, int SyNr);
int  GDX_CALLCONV d_gdxSymbolInfo (void *pgdx, int SyNr, char *SyId, int *Dimen, int *Typ);
int  GDX_CALLCONV d_gdxSymbolInfoX (void *pgdx, int SyNr, int *RecCnt, int *UserInfo, char *ExplTxt);
int  GDX_CALLCONV d_gdxSymbolSetDomain (void *pgdx, const char *DomainIDs[]);
int  GDX_CALLCONV d_gdxSymbolSetDomainX (void *pgdx, int SyNr, const char *DomainIDs[]);
int  GDX_CALLCONV d_gdxSystemInfo (void *pgdx, int *SyCnt, int *UelCnt);
int  GDX_CALLCONV d_gdxUELMaxLength (void *pgdx);
int  GDX_CALLCONV d_gdxUELRegisterDone (void *pgdx);
int  GDX_CALLCONV d_gdxUELRegisterMap (void *pgdx, int UMap, const char *Uel);
int  GDX_CALLCONV d_gdxUELRegisterMapStart (void *pgdx);
int  GDX_CALLCONV d_gdxUELRegisterRaw (void *pgdx, const char *Uel);
int  GDX_CALLCONV d_gdxUELRegisterRawStart (void *pgdx);
int  GDX_CALLCONV d_gdxUELRegisterStr (void *pgdx, const char *Uel, int *UelNr);
int  GDX_CALLCONV d_gdxUELRegisterStrStart (void *pgdx);
int  GDX_CALLCONV d_gdxUMFindUEL (void *pgdx, const char *Uel, int *UelNr, int *UelMap);
int  GDX_CALLCONV d_gdxUMUelGet (void *pgdx, int UelNr, char *Uel, int *UelMap);
int  GDX_CALLCONV d_gdxUMUelInfo (void *pgdx, int *UelCnt, int *HighMap);
int  GDX_CALLCONV d_gdxGetDomainElements (void *pgdx, int SyNr, int DimPos, int FilterNr, TDomainIndexProc_F_t DP, int *NrElem, void *Uptr);
int  GDX_CALLCONV d_gdxCurrentDim (void *pgdx);
int  GDX_CALLCONV d_gdxAcronymAdd (void *pgdx, const char *AName, const char *Txt, int AIndx)
{
  errorHandling("gdxAcronymAdd could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxAcronymCount (void *pgdx)
{
  errorHandling("gdxAcronymCount could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxAcronymGetInfo (void *pgdx, int N, char *AName, char *Txt, int *AIndx)
{
  errorHandling("gdxAcronymGetInfo could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxAcronymGetMapping (void *pgdx, int N, int *orgIndx, int *newIndx, int *autoIndex)
{
  errorHandling("gdxAcronymGetMapping could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxAcronymIndex (void *pgdx, double V)
{
  errorHandling("gdxAcronymIndex could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxAcronymName (void *pgdx, double V, char *AName)
{
  errorHandling("gdxAcronymName could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxAcronymNextNr (void *pgdx, int NV)
{
  errorHandling("gdxAcronymNextNr could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxAcronymSetInfo (void *pgdx, int N, const char *AName, const char *Txt, int AIndx)
{
  errorHandling("gdxAcronymSetInfo could not be loaded or has wrong signature!");
  return 0;
}

double  GDX_CALLCONV d_gdxAcronymValue (void *pgdx, int AIndx)
{
  errorHandling("gdxAcronymValue could not be loaded or has wrong signature!");
  return 0.0;
}

int  GDX_CALLCONV d_gdxAddAlias (void *pgdx, const char *Id1, const char *Id2)
{
  errorHandling("gdxAddAlias could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxAddSetText (void *pgdx, const char *Txt, int *TxtNr)
{
  errorHandling("gdxAddSetText could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxAutoConvert (void *pgdx, int NV)
{
  errorHandling("gdxAutoConvert could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxClose (void *pgdx)
{
  errorHandling("gdxClose could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataErrorCount (void *pgdx)
{
  errorHandling("gdxDataErrorCount could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataErrorRecord (void *pgdx, int RecNr, int KeyInt[], double Values[])
{
  errorHandling("gdxDataErrorRecord could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataReadDone (void *pgdx)
{
  errorHandling("gdxDataReadDone could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataReadFilteredStart (void *pgdx, int SyNr, const int FilterAction[], int *NrRecs)
{
  errorHandling("gdxDataReadFilteredStart could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataReadMap (void *pgdx, int RecNr, int KeyInt[], double Values[], int *DimFrst)
{
  errorHandling("gdxDataReadMap could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataReadMapStart (void *pgdx, int SyNr, int *NrRecs)
{
  errorHandling("gdxDataReadMapStart could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataReadRaw (void *pgdx, int KeyInt[], double Values[], int *DimFrst)
{
  errorHandling("gdxDataReadRaw could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataReadRawFast (void *pgdx, int SyNr, TDataStoreProc_F_t DP, int *NrRecs)
{
  errorHandling("gdxDataReadRawFast could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataReadRawStart (void *pgdx, int SyNr, int *NrRecs)
{
  errorHandling("gdxDataReadRawStart could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataReadSlice (void *pgdx, const char *UelFilterStr[], int *Dimen, TDataStoreProc_F_t DP)
{
  errorHandling("gdxDataReadSlice could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataReadSliceStart (void *pgdx, int SyNr, int ElemCounts[])
{
  errorHandling("gdxDataReadSliceStart could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataReadStr (void *pgdx, char *KeyStr[], double Values[], int *DimFrst)
{
  errorHandling("gdxDataReadStr could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataReadStrStart (void *pgdx, int SyNr, int *NrRecs)
{
  errorHandling("gdxDataReadStrStart could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataSliceUELS (void *pgdx, const int SliceKeyInt[], char *KeyStr[])
{
  errorHandling("gdxDataSliceUELS could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataWriteDone (void *pgdx)
{
  errorHandling("gdxDataWriteDone could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataWriteMap (void *pgdx, const int KeyInt[], const double Values[])
{
  errorHandling("gdxDataWriteMap could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataWriteMapStart (void *pgdx, const char *SyId, const char *ExplTxt, int Dimen, int Typ, int UserInfo)
{
  errorHandling("gdxDataWriteMapStart could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataWriteRaw (void *pgdx, const int KeyInt[], const double Values[])
{
  errorHandling("gdxDataWriteRaw could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataWriteRawStart (void *pgdx, const char *SyId, const char *ExplTxt, int Dimen, int Typ, int UserInfo)
{
  errorHandling("gdxDataWriteRawStart could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataWriteStr (void *pgdx, const char *KeyStr[], const double Values[])
{
  errorHandling("gdxDataWriteStr could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataWriteStrStart (void *pgdx, const char *SyId, const char *ExplTxt, int Dimen, int Typ, int UserInfo)
{
  errorHandling("gdxDataWriteStrStart could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxGetDLLVersion (void *pgdx, char *V)
{
  errorHandling("gdxGetDLLVersion could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxErrorCount (void *pgdx)
{
  errorHandling("gdxErrorCount could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxErrorStr (void *pgdx, int ErrNr, char *ErrMsg)
{
  errorHandling("gdxErrorStr could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxFileInfo (void *pgdx, int *FileVer, int *ComprLev)
{
  errorHandling("gdxFileInfo could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxFileVersion (void *pgdx, char *FileStr, char *ProduceStr)
{
  errorHandling("gdxFileVersion could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxFilterExists (void *pgdx, int FilterNr)
{
  errorHandling("gdxFilterExists could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxFilterRegister (void *pgdx, int UelMap)
{
  errorHandling("gdxFilterRegister could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxFilterRegisterDone (void *pgdx)
{
  errorHandling("gdxFilterRegisterDone could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxFilterRegisterStart (void *pgdx, int FilterNr)
{
  errorHandling("gdxFilterRegisterStart could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxFindSymbol (void *pgdx, const char *SyId, int *SyNr)
{
  errorHandling("gdxFindSymbol could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxGetElemText (void *pgdx, int TxtNr, char *Txt, int *Node)
{
  errorHandling("gdxGetElemText could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxGetLastError (void *pgdx)
{
  errorHandling("gdxGetLastError could not be loaded or has wrong signature!");
  return 0;
}

INT64  GDX_CALLCONV d_gdxGetMemoryUsed (void *pgdx)
{
  errorHandling("gdxGetMemoryUsed could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxGetSpecialValues (void *pgdx, double AVals[])
{
  errorHandling("gdxGetSpecialValues could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxGetUEL (void *pgdx, int UelNr, char *Uel)
{
  errorHandling("gdxGetUEL could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxMapValue (void *pgdx, double D, int *sv)
{
  errorHandling("gdxMapValue could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxOpenAppend (void *pgdx, const char *FileName, const char *Producer, int *ErrNr)
{
  errorHandling("gdxOpenAppend could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxOpenRead (void *pgdx, const char *FileName, int *ErrNr)
{
  errorHandling("gdxOpenRead could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxOpenWrite (void *pgdx, const char *FileName, const char *Producer, int *ErrNr)
{
  errorHandling("gdxOpenWrite could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxOpenWriteEx (void *pgdx, const char *FileName, const char *Producer, int Compr, int *ErrNr)
{
  errorHandling("gdxOpenWriteEx could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxResetSpecialValues (void *pgdx)
{
  errorHandling("gdxResetSpecialValues could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxSetHasText (void *pgdx, int SyNr)
{
  errorHandling("gdxSetHasText could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxSetReadSpecialValues (void *pgdx, const double AVals[])
{
  errorHandling("gdxSetReadSpecialValues could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxSetSpecialValues (void *pgdx, const double AVals[])
{
  errorHandling("gdxSetSpecialValues could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxSetTextNodeNr (void *pgdx, int TxtNr, int Node)
{
  errorHandling("gdxSetTextNodeNr could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxSetTraceLevel (void *pgdx, int N, const char *s)
{
  errorHandling("gdxSetTraceLevel could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxSymbIndxMaxLength (void *pgdx, int SyNr, int LengthInfo[])
{
  errorHandling("gdxSymbIndxMaxLength could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxSymbMaxLength (void *pgdx)
{
  errorHandling("gdxSymbMaxLength could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxSymbolAddComment (void *pgdx, int SyNr, const char *Txt)
{
  errorHandling("gdxSymbolAddComment could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxSymbolGetComment (void *pgdx, int SyNr, int N, char *Txt)
{
  errorHandling("gdxSymbolGetComment could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxSymbolGetDomain (void *pgdx, int SyNr, int DomainSyNrs[])
{
  errorHandling("gdxSymbolGetDomain could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxSymbolGetDomainX (void *pgdx, int SyNr, char *DomainIDs[])
{
  errorHandling("gdxSymbolGetDomainX could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxSymbolDim (void *pgdx, int SyNr)
{
  errorHandling("gdxSymbolDim could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxSymbolInfo (void *pgdx, int SyNr, char *SyId, int *Dimen, int *Typ)
{
  errorHandling("gdxSymbolInfo could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxSymbolInfoX (void *pgdx, int SyNr, int *RecCnt, int *UserInfo, char *ExplTxt)
{
  errorHandling("gdxSymbolInfoX could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxSymbolSetDomain (void *pgdx, const char *DomainIDs[])
{
  errorHandling("gdxSymbolSetDomain could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxSymbolSetDomainX (void *pgdx, int SyNr, const char *DomainIDs[])
{
  errorHandling("gdxSymbolSetDomainX could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxSystemInfo (void *pgdx, int *SyCnt, int *UelCnt)
{
  errorHandling("gdxSystemInfo could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxUELMaxLength (void *pgdx)
{
  errorHandling("gdxUELMaxLength could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxUELRegisterDone (void *pgdx)
{
  errorHandling("gdxUELRegisterDone could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxUELRegisterMap (void *pgdx, int UMap, const char *Uel)
{
  errorHandling("gdxUELRegisterMap could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxUELRegisterMapStart (void *pgdx)
{
  errorHandling("gdxUELRegisterMapStart could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxUELRegisterRaw (void *pgdx, const char *Uel)
{
  errorHandling("gdxUELRegisterRaw could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxUELRegisterRawStart (void *pgdx)
{
  errorHandling("gdxUELRegisterRawStart could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxUELRegisterStr (void *pgdx, const char *Uel, int *UelNr)
{
  errorHandling("gdxUELRegisterStr could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxUELRegisterStrStart (void *pgdx)
{
  errorHandling("gdxUELRegisterStrStart could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxUMFindUEL (void *pgdx, const char *Uel, int *UelNr, int *UelMap)
{
  errorHandling("gdxUMFindUEL could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxUMUelGet (void *pgdx, int UelNr, char *Uel, int *UelMap)
{
  errorHandling("gdxUMUelGet could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxUMUelInfo (void *pgdx, int *UelCnt, int *HighMap)
{
  errorHandling("gdxUMUelInfo could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxGetDomainElements (void *pgdx, int SyNr, int DimPos, int FilterNr, TDomainIndexProc_F_t DP, int *NrElem, void *Uptr)
{
  errorHandling("gdxGetDomainElements could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxCurrentDim (void *pgdx)
{
  errorHandling("gdxCurrentDim could not be loaded or has wrong signature!");
  return 0;
}


/* return dirName on success, NULL on failure */
static char *
extractFileDirFileName (const char *fileName, char *dirName, char *fName)
{
  int fileNameLen, shave=0;
  const char *end, *s;
  char *t;

  if (NULL == fileName || NULL == dirName || fName == NULL) {
    return NULL;
  }
  fileNameLen = (int) strlen(fileName);

#if defined(_WIN32)
  /* get the last delimiter */
  for (end = fileName + fileNameLen - 1;
       end >= fileName && '\\' != *end && ':' != *end;  end--);
  /* shave off the trailing delimiter if:
   *  it isn't the first char,
   *  it is a backslash, and
   *  it is not preceded by a delimiter
   */
  if (end > fileName && '\\' == *end
   && (! ('\\' == *(end-1) || ':' == *(end-1)))
     ) {
    end--; shave=1;
  }
#else
  /* non-Windows: implicitly, this is the Unix version */
  /* get the last delimiter */
  for (end = fileName + fileNameLen - 1;
       end >= fileName && '/' != *end;  end--);

  if (end > fileName && '/' == *end) {
    end--; shave=1;
  }
#endif  /* if defined(_WIN32) */

  for (s = fileName, t = dirName;  s <= end;  s++, t++)
    *t = *s;
  *t = '\0';

  if (shave) s++;
  for (t = fName;  s <= fileName + fileNameLen - 1;  s++, t++)
    *t = *s;
  *t = '\0';

  return dirName;
} /* extractFileDirFileName */



typedef int (GDX_CALLCONV *gdxAcronymAdd_t) (void *pgdx, const char *AName, const char *Txt, int AIndx);
static gdxAcronymAdd_t gdxAcronymAdd = NULL;
typedef int (GDX_CALLCONV *gdxAcronymCount_t) (void *pgdx);
static gdxAcronymCount_t gdxAcronymCount = NULL;
typedef int (GDX_CALLCONV *gdxAcronymGetInfo_t) (void *pgdx, int N, char *AName, char *Txt, int *AIndx);
static gdxAcronymGetInfo_t gdxAcronymGetInfo = NULL;
typedef int (GDX_CALLCONV *gdxAcronymGetMapping_t) (void *pgdx, int N, int *orgIndx, int *newIndx, int *autoIndex);
static gdxAcronymGetMapping_t gdxAcronymGetMapping = NULL;
typedef int (GDX_CALLCONV *gdxAcronymIndex_t) (void *pgdx, double V);
static gdxAcronymIndex_t gdxAcronymIndex = NULL;
typedef int (GDX_CALLCONV *gdxAcronymName_t) (void *pgdx, double V, char *AName);
static gdxAcronymName_t gdxAcronymName = NULL;
typedef int (GDX_CALLCONV *gdxAcronymNextNr_t) (void *pgdx, int NV);
static gdxAcronymNextNr_t gdxAcronymNextNr = NULL;
typedef int (GDX_CALLCONV *gdxAcronymSetInfo_t) (void *pgdx, int N, const char *AName, const char *Txt, int AIndx);
static gdxAcronymSetInfo_t gdxAcronymSetInfo = NULL;
typedef double (GDX_CALLCONV *gdxAcronymValue_t) (void *pgdx, int AIndx);
static gdxAcronymValue_t gdxAcronymValue = NULL;
typedef int (GDX_CALLCONV *gdxAddAlias_t) (void *pgdx, const char *Id1, const char *Id2);
static gdxAddAlias_t gdxAddAlias = NULL;
typedef int (GDX_CALLCONV *gdxAddSetText_t) (void *pgdx, const char *Txt, int *TxtNr);
static gdxAddSetText_t gdxAddSetText = NULL;
typedef int (GDX_CALLCONV *gdxAutoConvert_t) (void *pgdx, int NV);
static gdxAutoConvert_t gdxAutoConvert = NULL;
typedef int (GDX_CALLCONV *gdxClose_t) (void *pgdx);
static gdxClose_t gdxClose = NULL;
typedef int (GDX_CALLCONV *gdxDataErrorCount_t) (void *pgdx);
static gdxDataErrorCount_t gdxDataErrorCount = NULL;
typedef int (GDX_CALLCONV *gdxDataErrorRecord_t) (void *pgdx, int RecNr, int KeyInt[], double Values[]);
static gdxDataErrorRecord_t gdxDataErrorRecord = NULL;
typedef int (GDX_CALLCONV *gdxDataReadDone_t) (void *pgdx);
static gdxDataReadDone_t gdxDataReadDone = NULL;
typedef int (GDX_CALLCONV *gdxDataReadFilteredStart_t) (void *pgdx, int SyNr, const int FilterAction[], int *NrRecs);
static gdxDataReadFilteredStart_t gdxDataReadFilteredStart = NULL;
typedef int (GDX_CALLCONV *gdxDataReadMap_t) (void *pgdx, int RecNr, int KeyInt[], double Values[], int *DimFrst);
static gdxDataReadMap_t gdxDataReadMap = NULL;
typedef int (GDX_CALLCONV *gdxDataReadMapStart_t) (void *pgdx, int SyNr, int *NrRecs);
static gdxDataReadMapStart_t gdxDataReadMapStart = NULL;
typedef int (GDX_CALLCONV *gdxDataReadRaw_t) (void *pgdx, int KeyInt[], double Values[], int *DimFrst);
static gdxDataReadRaw_t gdxDataReadRaw = NULL;
typedef int (GDX_CALLCONV *gdxDataReadRawFast_t) (void *pgdx, int SyNr, TDataStoreProc_F_t DP, int *NrRecs);
static gdxDataReadRawFast_t gdxDataReadRawFast = NULL;
typedef int (GDX_CALLCONV *gdxDataReadRawStart_t) (void *pgdx, int SyNr, int *NrRecs);
static gdxDataReadRawStart_t gdxDataReadRawStart = NULL;
typedef int (GDX_CALLCONV *gdxDataReadSlice_t) (void *pgdx, const char *UelFilterStr[], int *Dimen, TDataStoreProc_F_t DP);
static gdxDataReadSlice_t gdxDataReadSlice = NULL;
typedef int (GDX_CALLCONV *gdxDataReadSliceStart_t) (void *pgdx, int SyNr, int ElemCounts[]);
static gdxDataReadSliceStart_t gdxDataReadSliceStart = NULL;
typedef int (GDX_CALLCONV *gdxDataReadStr_t) (void *pgdx, char *KeyStr[], double Values[], int *DimFrst);
static gdxDataReadStr_t gdxDataReadStr = NULL;
typedef int (GDX_CALLCONV *gdxDataReadStrStart_t) (void *pgdx, int SyNr, int *NrRecs);
static gdxDataReadStrStart_t gdxDataReadStrStart = NULL;
typedef int (GDX_CALLCONV *gdxDataSliceUELS_t) (void *pgdx, const int SliceKeyInt[], char *KeyStr[]);
static gdxDataSliceUELS_t gdxDataSliceUELS = NULL;
typedef int (GDX_CALLCONV *gdxDataWriteDone_t) (void *pgdx);
static gdxDataWriteDone_t gdxDataWriteDone = NULL;
typedef int (GDX_CALLCONV *gdxDataWriteMap_t) (void *pgdx, const int KeyInt[], const double Values[]);
static gdxDataWriteMap_t gdxDataWriteMap = NULL;
typedef int (GDX_CALLCONV *gdxDataWriteMapStart_t) (void *pgdx, const char *SyId, const char *ExplTxt, int Dimen, int Typ, int UserInfo);
static gdxDataWriteMapStart_t gdxDataWriteMapStart = NULL;
typedef int (GDX_CALLCONV *gdxDataWriteRaw_t) (void *pgdx, const int KeyInt[], const double Values[]);
static gdxDataWriteRaw_t gdxDataWriteRaw = NULL;
typedef int (GDX_CALLCONV *gdxDataWriteRawStart_t) (void *pgdx, const char *SyId, const char *ExplTxt, int Dimen, int Typ, int UserInfo);
static gdxDataWriteRawStart_t gdxDataWriteRawStart = NULL;
typedef int (GDX_CALLCONV *gdxDataWriteStr_t) (void *pgdx, const char *KeyStr[], const double Values[]);
static gdxDataWriteStr_t gdxDataWriteStr = NULL;
typedef int (GDX_CALLCONV *gdxDataWriteStrStart_t) (void *pgdx, const char *SyId, const char *ExplTxt, int Dimen, int Typ, int UserInfo);
static gdxDataWriteStrStart_t gdxDataWriteStrStart = NULL;
typedef int (GDX_CALLCONV *gdxGetDLLVersion_t) (void *pgdx, char *V);
static gdxGetDLLVersion_t gdxGetDLLVersion = NULL;
typedef int (GDX_CALLCONV *gdxErrorCount_t) (void *pgdx);
static gdxErrorCount_t gdxErrorCount = NULL;
typedef int (GDX_CALLCONV *gdxErrorStr_t) (void *pgdx, int ErrNr, char *ErrMsg);
static gdxErrorStr_t gdxErrorStr = NULL;
typedef int (GDX_CALLCONV *gdxFileInfo_t) (void *pgdx, int *FileVer, int *ComprLev);
static gdxFileInfo_t gdxFileInfo = NULL;
typedef int (GDX_CALLCONV *gdxFileVersion_t) (void *pgdx, char *FileStr, char *ProduceStr);
static gdxFileVersion_t gdxFileVersion = NULL;
typedef int (GDX_CALLCONV *gdxFilterExists_t) (void *pgdx, int FilterNr);
static gdxFilterExists_t gdxFilterExists = NULL;
typedef int (GDX_CALLCONV *gdxFilterRegister_t) (void *pgdx, int UelMap);
static gdxFilterRegister_t gdxFilterRegister = NULL;
typedef int (GDX_CALLCONV *gdxFilterRegisterDone_t) (void *pgdx);
static gdxFilterRegisterDone_t gdxFilterRegisterDone = NULL;
typedef int (GDX_CALLCONV *gdxFilterRegisterStart_t) (void *pgdx, int FilterNr);
static gdxFilterRegisterStart_t gdxFilterRegisterStart = NULL;
typedef int (GDX_CALLCONV *gdxFindSymbol_t) (void *pgdx, const char *SyId, int *SyNr);
static gdxFindSymbol_t gdxFindSymbol = NULL;
typedef int (GDX_CALLCONV *gdxGetElemText_t) (void *pgdx, int TxtNr, char *Txt, int *Node);
static gdxGetElemText_t gdxGetElemText = NULL;
typedef int (GDX_CALLCONV *gdxGetLastError_t) (void *pgdx);
static gdxGetLastError_t gdxGetLastError = NULL;
typedef INT64 (GDX_CALLCONV *gdxGetMemoryUsed_t) (void *pgdx);
static gdxGetMemoryUsed_t gdxGetMemoryUsed = NULL;
typedef int (GDX_CALLCONV *gdxGetSpecialValues_t) (void *pgdx, double AVals[]);
static gdxGetSpecialValues_t gdxGetSpecialValues = NULL;
typedef int (GDX_CALLCONV *gdxGetUEL_t) (void *pgdx, int UelNr, char *Uel);
static gdxGetUEL_t gdxGetUEL = NULL;
typedef int (GDX_CALLCONV *gdxMapValue_t) (void *pgdx, double D, int *sv);
static gdxMapValue_t gdxMapValue = NULL;
typedef int (GDX_CALLCONV *gdxOpenAppend_t) (void *pgdx, const char *FileName, const char *Producer, int *ErrNr);
static gdxOpenAppend_t gdxOpenAppend = NULL;
typedef int (GDX_CALLCONV *gdxOpenRead_t) (void *pgdx, const char *FileName, int *ErrNr);
static gdxOpenRead_t gdxOpenRead = NULL;
typedef int (GDX_CALLCONV *gdxOpenWrite_t) (void *pgdx, const char *FileName, const char *Producer, int *ErrNr);
static gdxOpenWrite_t gdxOpenWrite = NULL;
typedef int (GDX_CALLCONV *gdxOpenWriteEx_t) (void *pgdx, const char *FileName, const char *Producer, int Compr, int *ErrNr);
static gdxOpenWriteEx_t gdxOpenWriteEx = NULL;
typedef int (GDX_CALLCONV *gdxResetSpecialValues_t) (void *pgdx);
static gdxResetSpecialValues_t gdxResetSpecialValues = NULL;
typedef int (GDX_CALLCONV *gdxSetHasText_t) (void *pgdx, int SyNr);
static gdxSetHasText_t gdxSetHasText = NULL;
typedef int (GDX_CALLCONV *gdxSetReadSpecialValues_t) (void *pgdx, const double AVals[]);
static gdxSetReadSpecialValues_t gdxSetReadSpecialValues = NULL;
typedef int (GDX_CALLCONV *gdxSetSpecialValues_t) (void *pgdx, const double AVals[]);
static gdxSetSpecialValues_t gdxSetSpecialValues = NULL;
typedef int (GDX_CALLCONV *gdxSetTextNodeNr_t) (void *pgdx, int TxtNr, int Node);
static gdxSetTextNodeNr_t gdxSetTextNodeNr = NULL;
typedef int (GDX_CALLCONV *gdxSetTraceLevel_t) (void *pgdx, int N, const char *s);
static gdxSetTraceLevel_t gdxSetTraceLevel = NULL;
typedef int (GDX_CALLCONV *gdxSymbIndxMaxLength_t) (void *pgdx, int SyNr, int LengthInfo[]);
static gdxSymbIndxMaxLength_t gdxSymbIndxMaxLength = NULL;
typedef int (GDX_CALLCONV *gdxSymbMaxLength_t) (void *pgdx);
static gdxSymbMaxLength_t gdxSymbMaxLength = NULL;
typedef int (GDX_CALLCONV *gdxSymbolAddComment_t) (void *pgdx, int SyNr, const char *Txt);
static gdxSymbolAddComment_t gdxSymbolAddComment = NULL;
typedef int (GDX_CALLCONV *gdxSymbolGetComment_t) (void *pgdx, int SyNr, int N, char *Txt);
static gdxSymbolGetComment_t gdxSymbolGetComment = NULL;
typedef int (GDX_CALLCONV *gdxSymbolGetDomain_t) (void *pgdx, int SyNr, int DomainSyNrs[]);
static gdxSymbolGetDomain_t gdxSymbolGetDomain = NULL;
typedef int (GDX_CALLCONV *gdxSymbolGetDomainX_t) (void *pgdx, int SyNr, char *DomainIDs[]);
static gdxSymbolGetDomainX_t gdxSymbolGetDomainX = NULL;
typedef int (GDX_CALLCONV *gdxSymbolDim_t) (void *pgdx, int SyNr);
static gdxSymbolDim_t gdxSymbolDim = NULL;
typedef int (GDX_CALLCONV *gdxSymbolInfo_t) (void *pgdx, int SyNr, char *SyId, int *Dimen, int *Typ);
static gdxSymbolInfo_t gdxSymbolInfo = NULL;
typedef int (GDX_CALLCONV *gdxSymbolInfoX_t) (void *pgdx, int SyNr, int *RecCnt, int *UserInfo, char *ExplTxt);
static gdxSymbolInfoX_t gdxSymbolInfoX = NULL;
typedef int (GDX_CALLCONV *gdxSymbolSetDomain_t) (void *pgdx, const char *DomainIDs[]);
static gdxSymbolSetDomain_t gdxSymbolSetDomain = NULL;
typedef int (GDX_CALLCONV *gdxSymbolSetDomainX_t) (void *pgdx, int SyNr, const char *DomainIDs[]);
static gdxSymbolSetDomainX_t gdxSymbolSetDomainX = NULL;
typedef int (GDX_CALLCONV *gdxSystemInfo_t) (void *pgdx, int *SyCnt, int *UelCnt);
static gdxSystemInfo_t gdxSystemInfo = NULL;
typedef int (GDX_CALLCONV *gdxUELMaxLength_t) (void *pgdx);
static gdxUELMaxLength_t gdxUELMaxLength = NULL;
typedef int (GDX_CALLCONV *gdxUELRegisterDone_t) (void *pgdx);
static gdxUELRegisterDone_t gdxUELRegisterDone = NULL;
typedef int (GDX_CALLCONV *gdxUELRegisterMap_t) (void *pgdx, int UMap, const char *Uel);
static gdxUELRegisterMap_t gdxUELRegisterMap = NULL;
typedef int (GDX_CALLCONV *gdxUELRegisterMapStart_t) (void *pgdx);
static gdxUELRegisterMapStart_t gdxUELRegisterMapStart = NULL;
typedef int (GDX_CALLCONV *gdxUELRegisterRaw_t) (void *pgdx, const char *Uel);
static gdxUELRegisterRaw_t gdxUELRegisterRaw = NULL;
typedef int (GDX_CALLCONV *gdxUELRegisterRawStart_t) (void *pgdx);
static gdxUELRegisterRawStart_t gdxUELRegisterRawStart = NULL;
typedef int (GDX_CALLCONV *gdxUELRegisterStr_t) (void *pgdx, const char *Uel, int *UelNr);
static gdxUELRegisterStr_t gdxUELRegisterStr = NULL;
typedef int (GDX_CALLCONV *gdxUELRegisterStrStart_t) (void *pgdx);
static gdxUELRegisterStrStart_t gdxUELRegisterStrStart = NULL;
typedef int (GDX_CALLCONV *gdxUMFindUEL_t) (void *pgdx, const char *Uel, int *UelNr, int *UelMap);
static gdxUMFindUEL_t gdxUMFindUEL = NULL;
typedef int (GDX_CALLCONV *gdxUMUelGet_t) (void *pgdx, int UelNr, char *Uel, int *UelMap);
static gdxUMUelGet_t gdxUMUelGet = NULL;
typedef int (GDX_CALLCONV *gdxUMUelInfo_t) (void *pgdx, int *UelCnt, int *HighMap);
static gdxUMUelInfo_t gdxUMUelInfo = NULL;
typedef int (GDX_CALLCONV *gdxGetDomainElements_t) (void *pgdx, int SyNr, int DimPos, int FilterNr, TDomainIndexProc_F_t DP, int *NrElem, void *Uptr);
static gdxGetDomainElements_t gdxGetDomainElements = NULL;
typedef int (GDX_CALLCONV *gdxCurrentDim_t) (void *pgdx);
static gdxCurrentDim_t gdxCurrentDim = NULL;

static soHandle_t
loadLib (const char *libName, char **errMsg)
{
  soHandle_t h;

#if defined(_WIN32)
  h = LoadLibrary (libName);
  if (NULL == h) {
    *errMsg = winErr;
  }
  else {
    *errMsg = NULL;
  }
#else
  (void) dlerror();
  h = dlopen (libName, RTLD_NOW);
  if (NULL == h) {
    *errMsg = dlerror();
  }
  else {
    *errMsg = NULL;
  }
#endif

  return h;
} /* loadLib */

static int
unLoadLib (soHandle_t h)
{
  int rc;

#if defined(_WIN32)
  rc = FreeLibrary (h);
  return ! rc;
#else
  rc = dlclose (h);
#endif
  return rc;
} /* unLoadLib */

static void *
loadSym (soHandle_t h, const char *sym, char **errMsg)
{
  void *s;
  const char *from;
  char *to;
  const char *tripSym;
  char lcbuf[257];
  char ucbuf[257];
  char ocbuf[257];
  size_t symLen;
  int trip;

  /* search in this order:
   *  1. original
   *  2. lower_
   *  3. upper_
   *  4. original_
   *  5. lower
   *  6. upper
   */

  symLen = 0;
  for (trip = 1;  trip <= 6;  trip++) {
    switch (trip) {
    case 1:                             /* original */
      tripSym = sym;
      break;
    case 2:                             /* lower_ */
      for (from = sym, to = lcbuf;  *from;  from++, to++) {
        *to = tolower(*from);
      }
      symLen = from - sym;
      *to++ = '_';
      *to = '\0';
      tripSym = lcbuf;
      break;
    case 3:                             /* upper_ */
      for (from = sym, to = ucbuf;  *from;  from++, to++) {
        *to = toupper(*from);
      }
      *to++ = '_';
      *to = '\0';
      tripSym = ucbuf;
      break;
    case 4:                             /* original_ */
      memcpy (ocbuf, sym, symLen);
      ocbuf[symLen] = '_';
      ocbuf[symLen+1] = '\0';
      tripSym = ocbuf;
      break;
    case 5:                             /* lower */
      lcbuf[symLen] = '\0';
      tripSym = lcbuf;
      break;
    case 6:                             /* upper */
      ucbuf[symLen] = '\0';
      tripSym = ucbuf;
      break;
    default:
      tripSym = sym;
    } /* end switch */
#if defined(_WIN32)
#  if defined(HAVE_INTPTR_T)
    s = (void *)(intptr_t)GetProcAddress (h, tripSym);
#  else
    s = (void *)GetProcAddress (h, tripSym);
#  endif
    if (NULL != s) {
      return s;
    }
#else
    (void) dlerror();
    s = dlsym (h, tripSym);
    *errMsg = dlerror();
    if (NULL == *errMsg) {
      return s;
    }
#endif
  } /* end loop over symbol name variations */

  return NULL;
} /* loadSym */

/* TNAME = type name, ENAME = exported name */
#if defined(HAVE_INTPTR_T)
#  define LOADIT(TNAME,ENAME) symName = ENAME; TNAME = (TNAME##_t) (intptr_t) loadSym (hLibGlobal, symName, &errMsg); if (NULL == TNAME) goto symMissing
#  define LOADIT_ERR_OK(TNAME,ENAME) symName = ENAME; TNAME = (TNAME##_t) (intptr_t) loadSym (hLibGlobal, symName, &errMsg)
#else
#  define LOADIT(TNAME,ENAME) symName = ENAME; TNAME = (TNAME##_t) loadSym (hLibGlobal, symName, &errMsg); if (NULL == TNAME) goto symMissing
#  define LOADIT_ERR_OK(TNAME,ENAME) symName = ENAME; TNAME = (TNAME##_t) loadSym (hLibGlobal, symName, &errMsg)
#endif

#if ! defined(GMS_DLL_BASENAME)
# define GMS_DLL_BASENAME "gdxdclib"
#endif
#if defined(_WIN32)
# if ! defined(GMS_DLL_PREFIX)
#  define GMS_DLL_PREFIX ""
# endif
# if ! defined(GMS_DLL_EXTENSION)
#  define GMS_DLL_EXTENSION ".dll"
# endif
# if ! defined(GMS_DLL_SUFFIX)
#  if defined(_WIN64)
#   define GMS_DLL_SUFFIX "64"
#  else
#   define GMS_DLL_SUFFIX ""
#  endif
# endif

#else  /* start non-Windows */

# if ! defined(GMS_DLL_PREFIX)
#  define GMS_DLL_PREFIX "lib"
# endif
# if ! defined(GMS_DLL_EXTENSION)
#  if defined(__APPLE__)
#   define GMS_DLL_EXTENSION ".dylib"
#  else
#   define GMS_DLL_EXTENSION ".so"
#  endif
# endif
# if ! defined(GMS_DLL_SUFFIX)
#  if defined(__WORDSIZE)
#   if 64 == __WORDSIZE
#    define GMS_DLL_SUFFIX "64"
#   else
#    define GMS_DLL_SUFFIX ""
#   endif
#  elif defined(__SIZEOF_POINTER__)
#   if 4 == __SIZEOF_POINTER__
#    define GMS_DLL_SUFFIX ""
#   elif 8 == __SIZEOF_POINTER__
#    define GMS_DLL_SUFFIX "64"
#   endif
#  elif defined(__sparcv9)
#   define GMS_DLL_SUFFIX "64"
#  elif defined(__sparc)
/*  check __sparc after __sparcv9, both are defined for 64-bit */
#   define GMS_DLL_SUFFIX ""
#  endif
# endif /* ! defined(GMS_DLL_SUFFIX) */
#endif

/* XLibraryLoad: return 0 on success, ~0 on failure */
static int
XLibraryLoad (const char *dllName, char *errBuf, int errBufSize)
{
  char *errMsg;
  const char *symName;
  int rc, elen, cl;
  char *ebuf;

  if (isLoaded)
    return 0;
  hLibGlobal = loadLib (dllName, &errMsg);
  if (NULL == hLibGlobal) {
    if (NULL != errBuf) {
      elen = errBufSize;  ebuf = errBuf;
      rc = sprintf (ebuf, "%.*s", elen, "Could not load shared library ");
      elen -= rc;  ebuf+= rc;
      rc = sprintf (ebuf, "%.*s", elen, dllName);
      elen -= rc;  ebuf+= rc;
      rc = sprintf (ebuf, "%.*s", elen, ": ");
      elen -= rc;  ebuf+= rc;
      rc = sprintf (ebuf, "%.*s", elen, errMsg);
      elen -= rc;  ebuf+= rc;
      errBuf[errBufSize-1] = '\0';
    }
    return 1;
  }
  else {
     /* printf ("Loaded shared library %s successfully\n", dllName); */
    if (errBuf && errBufSize)
      errBuf[0] = '\0';
  }

  LOADIT(XCreate, "XCreate");
  LOADIT(XFree, "XFree");
  LOADIT(XCheck, "CXCheck");
  LOADIT(XAPIVersion, "CXAPIVersion");

  if (!XAPIVersion(7,errBuf,&cl))
    return 1;

  LOADIT_ERR_OK(gdxSetLoadPath, "CgdxSetLoadPath");
  LOADIT_ERR_OK(gdxGetLoadPath, "CgdxGetLoadPath");

  { int s[]={3,11,11,3};
    if(!XCheck("gdxAcronymAdd",3,s,errBuf))  gdxAcronymAdd=&d_gdxAcronymAdd;
    else { LOADIT(gdxAcronymAdd,"gdxAcronymAdd"); }  }
  { int s[]={3};
    if(!XCheck("gdxAcronymCount",0,s,errBuf))  gdxAcronymCount=&d_gdxAcronymCount;
    else { LOADIT(gdxAcronymCount,"gdxAcronymCount"); }  }
  { int s[]={3,3,12,12,4};
    if(!XCheck("gdxAcronymGetInfo",4,s,errBuf))  gdxAcronymGetInfo=&d_gdxAcronymGetInfo;
    else { LOADIT(gdxAcronymGetInfo,"gdxAcronymGetInfo"); }  }
  { int s[]={3,3,4,4,4};
    if(!XCheck("gdxAcronymGetMapping",4,s,errBuf))  gdxAcronymGetMapping=&d_gdxAcronymGetMapping;
    else { LOADIT(gdxAcronymGetMapping,"gdxAcronymGetMapping"); }  }
  { int s[]={3,13};
    if(!XCheck("gdxAcronymIndex",1,s,errBuf))  gdxAcronymIndex=&d_gdxAcronymIndex;
    else { LOADIT(gdxAcronymIndex,"gdxAcronymIndex"); }  }
  { int s[]={3,13,12};
    if(!XCheck("gdxAcronymName",2,s,errBuf))  gdxAcronymName=&d_gdxAcronymName;
    else { LOADIT(gdxAcronymName,"gdxAcronymName"); }  }
  { int s[]={3,3};
    if(!XCheck("gdxAcronymNextNr",1,s,errBuf))  gdxAcronymNextNr=&d_gdxAcronymNextNr;
    else { LOADIT(gdxAcronymNextNr,"gdxAcronymNextNr"); }  }
  { int s[]={3,3,11,11,3};
    if(!XCheck("gdxAcronymSetInfo",4,s,errBuf))  gdxAcronymSetInfo=&d_gdxAcronymSetInfo;
    else { LOADIT(gdxAcronymSetInfo,"gdxAcronymSetInfo"); }  }
  { int s[]={13,3};
    if(!XCheck("gdxAcronymValue",1,s,errBuf))  gdxAcronymValue=&d_gdxAcronymValue;
    else { LOADIT(gdxAcronymValue,"gdxAcronymValue"); }  }
  { int s[]={3,11,11};
    if(!XCheck("gdxAddAlias",2,s,errBuf))  gdxAddAlias=&d_gdxAddAlias;
    else { LOADIT(gdxAddAlias,"gdxAddAlias"); }  }
  { int s[]={3,11,4};
    if(!XCheck("gdxAddSetText",2,s,errBuf))  gdxAddSetText=&d_gdxAddSetText;
    else { LOADIT(gdxAddSetText,"gdxAddSetText"); }  }
  { int s[]={3,3};
    if(!XCheck("gdxAutoConvert",1,s,errBuf))  gdxAutoConvert=&d_gdxAutoConvert;
    else { LOADIT(gdxAutoConvert,"gdxAutoConvert"); }  }
  { int s[]={3};
    if(!XCheck("gdxClose",0,s,errBuf))  gdxClose=&d_gdxClose;
    else { LOADIT(gdxClose,"gdxClose"); }  }
  { int s[]={3};
    if(!XCheck("gdxDataErrorCount",0,s,errBuf))  gdxDataErrorCount=&d_gdxDataErrorCount;
    else { LOADIT(gdxDataErrorCount,"gdxDataErrorCount"); }  }
  { int s[]={3,3,52,54};
    if(!XCheck("gdxDataErrorRecord",3,s,errBuf))  gdxDataErrorRecord=&d_gdxDataErrorRecord;
    else { LOADIT(gdxDataErrorRecord,"gdxDataErrorRecord"); }  }
  { int s[]={3};
    if(!XCheck("gdxDataReadDone",0,s,errBuf))  gdxDataReadDone=&d_gdxDataReadDone;
    else { LOADIT(gdxDataReadDone,"gdxDataReadDone"); }  }
  { int s[]={3,3,51,4};
    if(!XCheck("gdxDataReadFilteredStart",3,s,errBuf))  gdxDataReadFilteredStart=&d_gdxDataReadFilteredStart;
    else { LOADIT(gdxDataReadFilteredStart,"gdxDataReadFilteredStart"); }  }
  { int s[]={3,3,52,54,4};
    if(!XCheck("gdxDataReadMap",4,s,errBuf))  gdxDataReadMap=&d_gdxDataReadMap;
    else { LOADIT(gdxDataReadMap,"gdxDataReadMap"); }  }
  { int s[]={3,3,4};
    if(!XCheck("gdxDataReadMapStart",2,s,errBuf))  gdxDataReadMapStart=&d_gdxDataReadMapStart;
    else { LOADIT(gdxDataReadMapStart,"gdxDataReadMapStart"); }  }
  { int s[]={3,52,54,4};
    if(!XCheck("gdxDataReadRaw",3,s,errBuf))  gdxDataReadRaw=&d_gdxDataReadRaw;
    else { LOADIT(gdxDataReadRaw,"gdxDataReadRaw"); }  }
  { int s[]={3,3,59,4};
    if(!XCheck("gdxDataReadRawFast",3,s,errBuf))  gdxDataReadRawFast=&d_gdxDataReadRawFast;
    else { LOADIT(gdxDataReadRawFast,"gdxDataReadRawFast"); }  }
  { int s[]={3,3,4};
    if(!XCheck("gdxDataReadRawStart",2,s,errBuf))  gdxDataReadRawStart=&d_gdxDataReadRawStart;
    else { LOADIT(gdxDataReadRawStart,"gdxDataReadRawStart"); }  }
  { int s[]={3,55,4,59};
    if(!XCheck("gdxDataReadSlice",3,s,errBuf))  gdxDataReadSlice=&d_gdxDataReadSlice;
    else { LOADIT(gdxDataReadSlice,"gdxDataReadSlice"); }  }
  { int s[]={3,3,52};
    if(!XCheck("gdxDataReadSliceStart",2,s,errBuf))  gdxDataReadSliceStart=&d_gdxDataReadSliceStart;
    else { LOADIT(gdxDataReadSliceStart,"gdxDataReadSliceStart"); }  }
  { int s[]={3,56,54,4};
    if(!XCheck("gdxDataReadStr",3,s,errBuf))  gdxDataReadStr=&d_gdxDataReadStr;
    else { LOADIT(gdxDataReadStr,"gdxDataReadStr"); }  }
  { int s[]={3,3,4};
    if(!XCheck("gdxDataReadStrStart",2,s,errBuf))  gdxDataReadStrStart=&d_gdxDataReadStrStart;
    else { LOADIT(gdxDataReadStrStart,"gdxDataReadStrStart"); }  }
  { int s[]={3,51,56};
    if(!XCheck("gdxDataSliceUELS",2,s,errBuf))  gdxDataSliceUELS=&d_gdxDataSliceUELS;
    else { LOADIT(gdxDataSliceUELS,"gdxDataSliceUELS"); }  }
  { int s[]={3};
    if(!XCheck("gdxDataWriteDone",0,s,errBuf))  gdxDataWriteDone=&d_gdxDataWriteDone;
    else { LOADIT(gdxDataWriteDone,"gdxDataWriteDone"); }  }
  { int s[]={3,51,53};
    if(!XCheck("gdxDataWriteMap",2,s,errBuf))  gdxDataWriteMap=&d_gdxDataWriteMap;
    else { LOADIT(gdxDataWriteMap,"gdxDataWriteMap"); }  }
  { int s[]={3,11,11,3,3,3};
    if(!XCheck("gdxDataWriteMapStart",5,s,errBuf))  gdxDataWriteMapStart=&d_gdxDataWriteMapStart;
    else { LOADIT(gdxDataWriteMapStart,"gdxDataWriteMapStart"); }  }
  { int s[]={3,51,53};
    if(!XCheck("gdxDataWriteRaw",2,s,errBuf))  gdxDataWriteRaw=&d_gdxDataWriteRaw;
    else { LOADIT(gdxDataWriteRaw,"gdxDataWriteRaw"); }  }
  { int s[]={3,11,11,3,3,3};
    if(!XCheck("gdxDataWriteRawStart",5,s,errBuf))  gdxDataWriteRawStart=&d_gdxDataWriteRawStart;
    else { LOADIT(gdxDataWriteRawStart,"gdxDataWriteRawStart"); }  }
  { int s[]={3,55,53};
    if(!XCheck("gdxDataWriteStr",2,s,errBuf))  gdxDataWriteStr=&d_gdxDataWriteStr;
    else { LOADIT(gdxDataWriteStr,"gdxDataWriteStr"); }  }
  { int s[]={3,11,11,3,3,3};
    if(!XCheck("gdxDataWriteStrStart",5,s,errBuf))  gdxDataWriteStrStart=&d_gdxDataWriteStrStart;
    else { LOADIT(gdxDataWriteStrStart,"gdxDataWriteStrStart"); }  }
  { int s[]={3,12};
    if(!XCheck("gdxGetDLLVersion",1,s,errBuf))  gdxGetDLLVersion=&d_gdxGetDLLVersion;
    else { LOADIT(gdxGetDLLVersion,"gdxGetDLLVersion"); }  }
  { int s[]={3};
    if(!XCheck("gdxErrorCount",0,s,errBuf))  gdxErrorCount=&d_gdxErrorCount;
    else { LOADIT(gdxErrorCount,"gdxErrorCount"); }  }
  { int s[]={3,3,12};
    if(!XCheck("gdxErrorStr",2,s,errBuf))  gdxErrorStr=&d_gdxErrorStr;
    else { LOADIT(gdxErrorStr,"gdxErrorStr"); }  }
  { int s[]={3,4,4};
    if(!XCheck("gdxFileInfo",2,s,errBuf))  gdxFileInfo=&d_gdxFileInfo;
    else { LOADIT(gdxFileInfo,"gdxFileInfo"); }  }
  { int s[]={3,12,12};
    if(!XCheck("gdxFileVersion",2,s,errBuf))  gdxFileVersion=&d_gdxFileVersion;
    else { LOADIT(gdxFileVersion,"gdxFileVersion"); }  }
  { int s[]={3,3};
    if(!XCheck("gdxFilterExists",1,s,errBuf))  gdxFilterExists=&d_gdxFilterExists;
    else { LOADIT(gdxFilterExists,"gdxFilterExists"); }  }
  { int s[]={3,3};
    if(!XCheck("gdxFilterRegister",1,s,errBuf))  gdxFilterRegister=&d_gdxFilterRegister;
    else { LOADIT(gdxFilterRegister,"gdxFilterRegister"); }  }
  { int s[]={3};
    if(!XCheck("gdxFilterRegisterDone",0,s,errBuf))  gdxFilterRegisterDone=&d_gdxFilterRegisterDone;
    else { LOADIT(gdxFilterRegisterDone,"gdxFilterRegisterDone"); }  }
  { int s[]={3,3};
    if(!XCheck("gdxFilterRegisterStart",1,s,errBuf))  gdxFilterRegisterStart=&d_gdxFilterRegisterStart;
    else { LOADIT(gdxFilterRegisterStart,"gdxFilterRegisterStart"); }  }
  { int s[]={3,11,4};
    if(!XCheck("gdxFindSymbol",2,s,errBuf))  gdxFindSymbol=&d_gdxFindSymbol;
    else { LOADIT(gdxFindSymbol,"gdxFindSymbol"); }  }
  { int s[]={3,3,12,4};
    if(!XCheck("gdxGetElemText",3,s,errBuf))  gdxGetElemText=&d_gdxGetElemText;
    else { LOADIT(gdxGetElemText,"gdxGetElemText"); }  }
  { int s[]={3};
    if(!XCheck("gdxGetLastError",0,s,errBuf))  gdxGetLastError=&d_gdxGetLastError;
    else { LOADIT(gdxGetLastError,"gdxGetLastError"); }  }
  { int s[]={23};
    if(!XCheck("gdxGetMemoryUsed",0,s,errBuf))  gdxGetMemoryUsed=&d_gdxGetMemoryUsed;
    else { LOADIT(gdxGetMemoryUsed,"gdxGetMemoryUsed"); }  }
  { int s[]={3,58};
    if(!XCheck("gdxGetSpecialValues",1,s,errBuf))  gdxGetSpecialValues=&d_gdxGetSpecialValues;
    else { LOADIT(gdxGetSpecialValues,"gdxGetSpecialValues"); }  }
  { int s[]={3,3,12};
    if(!XCheck("gdxGetUEL",2,s,errBuf))  gdxGetUEL=&d_gdxGetUEL;
    else { LOADIT(gdxGetUEL,"gdxGetUEL"); }  }
  { int s[]={3,13,4};
    if(!XCheck("gdxMapValue",2,s,errBuf))  gdxMapValue=&d_gdxMapValue;
    else { LOADIT(gdxMapValue,"gdxMapValue"); }  }
  { int s[]={3,11,11,4};
    if(!XCheck("gdxOpenAppend",3,s,errBuf))  gdxOpenAppend=&d_gdxOpenAppend;
    else { LOADIT(gdxOpenAppend,"gdxOpenAppend"); }  }
  { int s[]={3,11,4};
    if(!XCheck("gdxOpenRead",2,s,errBuf))  gdxOpenRead=&d_gdxOpenRead;
    else { LOADIT(gdxOpenRead,"gdxOpenRead"); }  }
  { int s[]={3,11,11,4};
    if(!XCheck("gdxOpenWrite",3,s,errBuf))  gdxOpenWrite=&d_gdxOpenWrite;
    else { LOADIT(gdxOpenWrite,"gdxOpenWrite"); }  }
  { int s[]={3,11,11,3,4};
    if(!XCheck("gdxOpenWriteEx",4,s,errBuf))  gdxOpenWriteEx=&d_gdxOpenWriteEx;
    else { LOADIT(gdxOpenWriteEx,"gdxOpenWriteEx"); }  }
  { int s[]={3};
    if(!XCheck("gdxResetSpecialValues",0,s,errBuf))  gdxResetSpecialValues=&d_gdxResetSpecialValues;
    else { LOADIT(gdxResetSpecialValues,"gdxResetSpecialValues"); }  }
  { int s[]={3,3};
    if(!XCheck("gdxSetHasText",1,s,errBuf))  gdxSetHasText=&d_gdxSetHasText;
    else { LOADIT(gdxSetHasText,"gdxSetHasText"); }  }
  { int s[]={3,57};
    if(!XCheck("gdxSetReadSpecialValues",1,s,errBuf))  gdxSetReadSpecialValues=&d_gdxSetReadSpecialValues;
    else { LOADIT(gdxSetReadSpecialValues,"gdxSetReadSpecialValues"); }  }
  { int s[]={3,57};
    if(!XCheck("gdxSetSpecialValues",1,s,errBuf))  gdxSetSpecialValues=&d_gdxSetSpecialValues;
    else { LOADIT(gdxSetSpecialValues,"gdxSetSpecialValues"); }  }
  { int s[]={3,3,3};
    if(!XCheck("gdxSetTextNodeNr",2,s,errBuf))  gdxSetTextNodeNr=&d_gdxSetTextNodeNr;
    else { LOADIT(gdxSetTextNodeNr,"gdxSetTextNodeNr"); }  }
  { int s[]={3,3,11};
    if(!XCheck("gdxSetTraceLevel",2,s,errBuf))  gdxSetTraceLevel=&d_gdxSetTraceLevel;
    else { LOADIT(gdxSetTraceLevel,"gdxSetTraceLevel"); }  }
  { int s[]={3,3,52};
    if(!XCheck("gdxSymbIndxMaxLength",2,s,errBuf))  gdxSymbIndxMaxLength=&d_gdxSymbIndxMaxLength;
    else { LOADIT(gdxSymbIndxMaxLength,"gdxSymbIndxMaxLength"); }  }
  { int s[]={3};
    if(!XCheck("gdxSymbMaxLength",0,s,errBuf))  gdxSymbMaxLength=&d_gdxSymbMaxLength;
    else { LOADIT(gdxSymbMaxLength,"gdxSymbMaxLength"); }  }
  { int s[]={3,3,11};
    if(!XCheck("gdxSymbolAddComment",2,s,errBuf))  gdxSymbolAddComment=&d_gdxSymbolAddComment;
    else { LOADIT(gdxSymbolAddComment,"gdxSymbolAddComment"); }  }
  { int s[]={3,3,3,12};
    if(!XCheck("gdxSymbolGetComment",3,s,errBuf))  gdxSymbolGetComment=&d_gdxSymbolGetComment;
    else { LOADIT(gdxSymbolGetComment,"gdxSymbolGetComment"); }  }
  { int s[]={3,3,52};
    if(!XCheck("gdxSymbolGetDomain",2,s,errBuf))  gdxSymbolGetDomain=&d_gdxSymbolGetDomain;
    else { LOADIT(gdxSymbolGetDomain,"gdxSymbolGetDomain"); }  }
  { int s[]={3,3,56};
    if(!XCheck("gdxSymbolGetDomainX",2,s,errBuf))  gdxSymbolGetDomainX=&d_gdxSymbolGetDomainX;
    else { LOADIT(gdxSymbolGetDomainX,"gdxSymbolGetDomainX"); }  }
  { int s[]={3,3};
    if(!XCheck("gdxSymbolDim",1,s,errBuf))  gdxSymbolDim=&d_gdxSymbolDim;
    else { LOADIT(gdxSymbolDim,"gdxSymbolDim"); }  }
  { int s[]={3,3,12,4,4};
    if(!XCheck("gdxSymbolInfo",4,s,errBuf))  gdxSymbolInfo=&d_gdxSymbolInfo;
    else { LOADIT(gdxSymbolInfo,"gdxSymbolInfo"); }  }
  { int s[]={3,3,4,4,12};
    if(!XCheck("gdxSymbolInfoX",4,s,errBuf))  gdxSymbolInfoX=&d_gdxSymbolInfoX;
    else { LOADIT(gdxSymbolInfoX,"gdxSymbolInfoX"); }  }
  { int s[]={3,55};
    if(!XCheck("gdxSymbolSetDomain",1,s,errBuf))  gdxSymbolSetDomain=&d_gdxSymbolSetDomain;
    else { LOADIT(gdxSymbolSetDomain,"gdxSymbolSetDomain"); }  }
  { int s[]={3,3,55};
    if(!XCheck("gdxSymbolSetDomainX",2,s,errBuf))  gdxSymbolSetDomainX=&d_gdxSymbolSetDomainX;
    else { LOADIT(gdxSymbolSetDomainX,"gdxSymbolSetDomainX"); }  }
  { int s[]={3,4,4};
    if(!XCheck("gdxSystemInfo",2,s,errBuf))  gdxSystemInfo=&d_gdxSystemInfo;
    else { LOADIT(gdxSystemInfo,"gdxSystemInfo"); }  }
  { int s[]={3};
    if(!XCheck("gdxUELMaxLength",0,s,errBuf))  gdxUELMaxLength=&d_gdxUELMaxLength;
    else { LOADIT(gdxUELMaxLength,"gdxUELMaxLength"); }  }
  { int s[]={3};
    if(!XCheck("gdxUELRegisterDone",0,s,errBuf))  gdxUELRegisterDone=&d_gdxUELRegisterDone;
    else { LOADIT(gdxUELRegisterDone,"gdxUELRegisterDone"); }  }
  { int s[]={3,3,11};
    if(!XCheck("gdxUELRegisterMap",2,s,errBuf))  gdxUELRegisterMap=&d_gdxUELRegisterMap;
    else { LOADIT(gdxUELRegisterMap,"gdxUELRegisterMap"); }  }
  { int s[]={3};
    if(!XCheck("gdxUELRegisterMapStart",0,s,errBuf))  gdxUELRegisterMapStart=&d_gdxUELRegisterMapStart;
    else { LOADIT(gdxUELRegisterMapStart,"gdxUELRegisterMapStart"); }  }
  { int s[]={3,11};
    if(!XCheck("gdxUELRegisterRaw",1,s,errBuf))  gdxUELRegisterRaw=&d_gdxUELRegisterRaw;
    else { LOADIT(gdxUELRegisterRaw,"gdxUELRegisterRaw"); }  }
  { int s[]={3};
    if(!XCheck("gdxUELRegisterRawStart",0,s,errBuf))  gdxUELRegisterRawStart=&d_gdxUELRegisterRawStart;
    else { LOADIT(gdxUELRegisterRawStart,"gdxUELRegisterRawStart"); }  }
  { int s[]={3,11,4};
    if(!XCheck("gdxUELRegisterStr",2,s,errBuf))  gdxUELRegisterStr=&d_gdxUELRegisterStr;
    else { LOADIT(gdxUELRegisterStr,"gdxUELRegisterStr"); }  }
  { int s[]={3};
    if(!XCheck("gdxUELRegisterStrStart",0,s,errBuf))  gdxUELRegisterStrStart=&d_gdxUELRegisterStrStart;
    else { LOADIT(gdxUELRegisterStrStart,"gdxUELRegisterStrStart"); }  }
  { int s[]={3,11,4,4};
    if(!XCheck("gdxUMFindUEL",3,s,errBuf))  gdxUMFindUEL=&d_gdxUMFindUEL;
    else { LOADIT(gdxUMFindUEL,"gdxUMFindUEL"); }  }
  { int s[]={3,3,12,4};
    if(!XCheck("gdxUMUelGet",3,s,errBuf))  gdxUMUelGet=&d_gdxUMUelGet;
    else { LOADIT(gdxUMUelGet,"gdxUMUelGet"); }  }
  { int s[]={3,4,4};
    if(!XCheck("gdxUMUelInfo",2,s,errBuf))  gdxUMUelInfo=&d_gdxUMUelInfo;
    else { LOADIT(gdxUMUelInfo,"gdxUMUelInfo"); }  }
  { int s[]={3,3,3,3,59,4,1};
    if(!XCheck("gdxGetDomainElements",6,s,errBuf))  gdxGetDomainElements=&d_gdxGetDomainElements;
    else { LOADIT(gdxGetDomainElements,"FgdxGetDomainElements"); }  }
  { int s[]={3};
    if(!XCheck("gdxCurrentDim",0,s,errBuf))  gdxCurrentDim=&d_gdxCurrentDim;
    else { LOADIT(gdxCurrentDim,"gdxCurrentDim"); }  }

  return 0;

 symMissing:
  elen = errBufSize;  ebuf = errBuf;
  rc = sprintf (ebuf, "%.*s", elen, "Could not load symbol '");
  elen -= rc;  ebuf+= rc;
  rc = sprintf (ebuf, "%.*s", elen, symName);
  elen -= rc;  ebuf+= rc;
  rc = sprintf (ebuf, "%.*s", elen, "': ");
  elen -= rc;  ebuf+= rc;
  rc = sprintf (ebuf, "%.*s", elen, errMsg);
  elen -= rc;  ebuf+= rc;
  errBuf[errBufSize-1] = '\0';
  printf ("%s\n", errBuf);
  return 2;
} /* XLibraryLoad */

static int
libloader(const char *dllPath, const char *dllName, char *msgBuf, int msgBufSize)
{

  char dllNameBuf[512];
  int myrc = 0;
  char gms_dll_suffix[4];

#if ! defined(GMS_DLL_PREFIX)
# error "GMS_DLL_PREFIX expected but not defined"
#endif
#if ! defined(GMS_DLL_BASENAME)
# error "GMS_DLL_BASENAME expected but not defined"
#endif
#if ! defined(GMS_DLL_EXTENSION)
# error "GMS_DLL_EXTENSION expected but not defined"
#endif
#if ! defined(GMS_DLL_SUFFIX)
# if defined (_WIN32)
#   error "GMS_DLL_SUFFIX expected but not defined"
# else
  struct utsname uts;

  myrc = uname(&uts);
  if (myrc) {
    strcpy(msgBuf,"Error, cannot define library name suffix");
    return 0;
  }
  if (0 == strcmp(uts.sysname, "AIX")) /* assume AIX is 64-bit */
    strcpy (gms_dll_suffix, "64");
  else if (0 == strcmp(uts.sysname, "Darwin")) {
    /* keep Darwin test in here: fat binaries must check at run time */
    if (8 == (int)sizeof(void *))
      strcpy (gms_dll_suffix, "64");
    else
      strcpy (gms_dll_suffix, "");
  }
  else {
    strcpy(msgBuf,"Error, cannot define library name suffix");
    return 0;
  }
# endif
#else
  strcpy (gms_dll_suffix, GMS_DLL_SUFFIX);
#endif


  if (NULL != msgBuf) msgBuf[0] = '\0';

  if (! isLoaded) {
    if (NULL != dllPath && '\0' != *dllPath) {
      strncpy(dllNameBuf, dllPath, sizeof(dllNameBuf)-1);
      dllNameBuf[sizeof(dllNameBuf)-2] = '\0';
#if defined(_WIN32)
      if ('\\' != dllNameBuf[strlen(dllNameBuf)])
        strcat(dllNameBuf,"\\");
#else
      if ('/' != dllNameBuf[strlen(dllNameBuf)])
        strcat(dllNameBuf,"/");
#endif
    }
    else {
      dllNameBuf[0] = '\0';
    }
    if (NULL != dllName && '\0' != *dllName) {
      strncat(dllNameBuf, dllName, sizeof(dllNameBuf)-strlen(dllNameBuf));
      dllNameBuf[sizeof(dllNameBuf)-1] = '\0';
    }
    else {
      strncat(dllNameBuf, GMS_DLL_PREFIX GMS_DLL_BASENAME, sizeof(dllNameBuf)-strlen(dllNameBuf));
      strncat(dllNameBuf, gms_dll_suffix                 , sizeof(dllNameBuf)-strlen(dllNameBuf));
      strncat(dllNameBuf, GMS_DLL_EXTENSION              , sizeof(dllNameBuf)-strlen(dllNameBuf));
    }
    isLoaded = ! XLibraryLoad (dllNameBuf, msgBuf, msgBufSize);
    if (isLoaded) {
       if (NULL != gdxSetLoadPath && NULL != dllPath && '\0' != *dllPath) {
         gdxSetLoadPath(dllPath);
       }
       else {                            /* no setLoadPath call found */
         myrc |= 2;
       }
    }
    else {                              /* library load failed */
      myrc |= 1;
    }
  }
  return (myrc & 1) == 0;
}

#if   defined(APIWRAP_LCASE_DECOR)  /* fortran names: lower case, trailing _ */
# define C_GDXACRONYMADD            c_gdxacronymadd_
# define C_GDXACRONYMCOUNT          c_gdxacronymcount_
# define C_GDXACRONYMGETINFO        c_gdxacronymgetinfo_
# define C_GDXACRONYMGETMAPPING     c_gdxacronymgetmapping_
# define C_GDXACRONYMINDEX          c_gdxacronymindex_
# define C_GDXACRONYMNAME           c_gdxacronymname_
# define C_GDXACRONYMNEXTNR         c_gdxacronymnextnr_
# define C_GDXACRONYMSETINFO        c_gdxacronymsetinfo_
# define C_GDXACRONYMVALUE          c_gdxacronymvalue_
# define C_GDXADDALIAS              c_gdxaddalias_
# define C_GDXADDSETTEXT            c_gdxaddsettext_
# define C_GDXAUTOCONVERT           c_gdxautoconvert_
# define C_GDXCLOSE                 c_gdxclose_
# define C_GDXDATAERRORCOUNT        c_gdxdataerrorcount_
# define C_GDXDATAERRORRECORD       c_gdxdataerrorrecord_
# define C_GDXDATAREADDONE          c_gdxdatareaddone_
# define C_GDXDATAREADFILTEREDSTART c_gdxdatareadfilteredstart_
# define C_GDXDATAREADMAP           c_gdxdatareadmap_
# define C_GDXDATAREADMAPSTART      c_gdxdatareadmapstart_
# define C_GDXDATAREADRAW           c_gdxdatareadraw_
# define C_GDXDATAREADRAWFAST       c_gdxdatareadrawfast_
# define C_GDXDATAREADRAWSTART      c_gdxdatareadrawstart_
# define C_GDXDATAREADSLICE         c_gdxdatareadslice_
# define C_GDXDATAREADSLICESTART    c_gdxdatareadslicestart_
# define C_GDXDATAREADSTR           c_gdxdatareadstr_
# define C_GDXDATAREADSTRSTART      c_gdxdatareadstrstart_
# define C_GDXDATASLICEUELS         c_gdxdatasliceuels_
# define C_GDXDATAWRITEDONE         c_gdxdatawritedone_
# define C_GDXDATAWRITEMAP          c_gdxdatawritemap_
# define C_GDXDATAWRITEMAPSTART     c_gdxdatawritemapstart_
# define C_GDXDATAWRITERAW          c_gdxdatawriteraw_
# define C_GDXDATAWRITERAWSTART     c_gdxdatawriterawstart_
# define C_GDXDATAWRITESTR          c_gdxdatawritestr_
# define C_GDXDATAWRITESTRSTART     c_gdxdatawritestrstart_
# define C_GDXGETDLLVERSION         c_gdxgetdllversion_
# define C_GDXERRORCOUNT            c_gdxerrorcount_
# define C_GDXERRORSTR              c_gdxerrorstr_
# define C_GDXFILEINFO              c_gdxfileinfo_
# define C_GDXFILEVERSION           c_gdxfileversion_
# define C_GDXFILTEREXISTS          c_gdxfilterexists_
# define C_GDXFILTERREGISTER        c_gdxfilterregister_
# define C_GDXFILTERREGISTERDONE    c_gdxfilterregisterdone_
# define C_GDXFILTERREGISTERSTART   c_gdxfilterregisterstart_
# define C_GDXFINDSYMBOL            c_gdxfindsymbol_
# define C_GDXGETELEMTEXT           c_gdxgetelemtext_
# define C_GDXGETLASTERROR          c_gdxgetlasterror_
# define C_GDXGETMEMORYUSED         c_gdxgetmemoryused_
# define C_GDXGETSPECIALVALUES      c_gdxgetspecialvalues_
# define C_GDXGETUEL                c_gdxgetuel_
# define C_GDXMAPVALUE              c_gdxmapvalue_
# define C_GDXOPENAPPEND            c_gdxopenappend_
# define C_GDXOPENREAD              c_gdxopenread_
# define C_GDXOPENWRITE             c_gdxopenwrite_
# define C_GDXOPENWRITEEX           c_gdxopenwriteex_
# define C_GDXRESETSPECIALVALUES    c_gdxresetspecialvalues_
# define C_GDXSETHASTEXT            c_gdxsethastext_
# define C_GDXSETREADSPECIALVALUES  c_gdxsetreadspecialvalues_
# define C_GDXSETSPECIALVALUES      c_gdxsetspecialvalues_
# define C_GDXSETTEXTNODENR         c_gdxsettextnodenr_
# define C_GDXSETTRACELEVEL         c_gdxsettracelevel_
# define C_GDXSYMBINDXMAXLENGTH     c_gdxsymbindxmaxlength_
# define C_GDXSYMBMAXLENGTH         c_gdxsymbmaxlength_
# define C_GDXSYMBOLADDCOMMENT      c_gdxsymboladdcomment_
# define C_GDXSYMBOLGETCOMMENT      c_gdxsymbolgetcomment_
# define C_GDXSYMBOLGETDOMAIN       c_gdxsymbolgetdomain_
# define C_GDXSYMBOLGETDOMAINX      c_gdxsymbolgetdomainx_
# define C_GDXSYMBOLDIM             c_gdxsymboldim_
# define C_GDXSYMBOLINFO            c_gdxsymbolinfo_
# define C_GDXSYMBOLINFOX           c_gdxsymbolinfox_
# define C_GDXSYMBOLSETDOMAIN       c_gdxsymbolsetdomain_
# define C_GDXSYMBOLSETDOMAINX      c_gdxsymbolsetdomainx_
# define C_GDXSYSTEMINFO            c_gdxsysteminfo_
# define C_GDXUELMAXLENGTH          c_gdxuelmaxlength_
# define C_GDXUELREGISTERDONE       c_gdxuelregisterdone_
# define C_GDXUELREGISTERMAP        c_gdxuelregistermap_
# define C_GDXUELREGISTERMAPSTART   c_gdxuelregistermapstart_
# define C_GDXUELREGISTERRAW        c_gdxuelregisterraw_
# define C_GDXUELREGISTERRAWSTART   c_gdxuelregisterrawstart_
# define C_GDXUELREGISTERSTR        c_gdxuelregisterstr_
# define C_GDXUELREGISTERSTRSTART   c_gdxuelregisterstrstart_
# define C_GDXUMFINDUEL             c_gdxumfinduel_
# define C_GDXUMUELGET              c_gdxumuelget_
# define C_GDXUMUELINFO             c_gdxumuelinfo_
# define C_GDXGETDOMAINELEMENTS     c_gdxgetdomainelements_
# define C_GDXCURRENTDIM            c_gdxcurrentdim_
# define C_GDXCREATE                c_gdxcreate_
# define C_GDXCREATED               c_gdxcreated_
# define C_GDXCREATEL               c_gdxcreatel_
# define C_GDXGETREADY              c_gdxgetready_
# define C_GDXGETREADYD             c_gdxgetreadyd_
# define C_GDXGETREADYL             c_gdxgetreadyl_
# define C_GDXEXIT                  c_gdxexit_
# define C_GDXFREE                  c_gdxfree_
# define C_GDXGETAPIERRORCOUNT      c_gdxgetapierrorcount_
# define C_GDXGETSCREENINDICATOR    c_gdxgetscreenindicator_
# define C_GDXSETSCREENINDICATOR    c_gdxsetscreenindicator_
# define C_GDXGETEXITINDICATOR      c_gdxgetexitindicator_
# define C_GDXSETEXITINDICATOR      c_gdxsetexitindicator_
# define C_GDXSETERRORCALLBACK      c_gdxseterrorcallback_
#elif defined(APIWRAP_LCASE_NODECOR)/* fortran names: lower case, no _ */
# define C_GDXACRONYMADD            c_gdxacronymadd
# define C_GDXACRONYMCOUNT          c_gdxacronymcount
# define C_GDXACRONYMGETINFO        c_gdxacronymgetinfo
# define C_GDXACRONYMGETMAPPING     c_gdxacronymgetmapping
# define C_GDXACRONYMINDEX          c_gdxacronymindex
# define C_GDXACRONYMNAME           c_gdxacronymname
# define C_GDXACRONYMNEXTNR         c_gdxacronymnextnr
# define C_GDXACRONYMSETINFO        c_gdxacronymsetinfo
# define C_GDXACRONYMVALUE          c_gdxacronymvalue
# define C_GDXADDALIAS              c_gdxaddalias
# define C_GDXADDSETTEXT            c_gdxaddsettext
# define C_GDXAUTOCONVERT           c_gdxautoconvert
# define C_GDXCLOSE                 c_gdxclose
# define C_GDXDATAERRORCOUNT        c_gdxdataerrorcount
# define C_GDXDATAERRORRECORD       c_gdxdataerrorrecord
# define C_GDXDATAREADDONE          c_gdxdatareaddone
# define C_GDXDATAREADFILTEREDSTART c_gdxdatareadfilteredstart
# define C_GDXDATAREADMAP           c_gdxdatareadmap
# define C_GDXDATAREADMAPSTART      c_gdxdatareadmapstart
# define C_GDXDATAREADRAW           c_gdxdatareadraw
# define C_GDXDATAREADRAWFAST       c_gdxdatareadrawfast
# define C_GDXDATAREADRAWSTART      c_gdxdatareadrawstart
# define C_GDXDATAREADSLICE         c_gdxdatareadslice
# define C_GDXDATAREADSLICESTART    c_gdxdatareadslicestart
# define C_GDXDATAREADSTR           c_gdxdatareadstr
# define C_GDXDATAREADSTRSTART      c_gdxdatareadstrstart
# define C_GDXDATASLICEUELS         c_gdxdatasliceuels
# define C_GDXDATAWRITEDONE         c_gdxdatawritedone
# define C_GDXDATAWRITEMAP          c_gdxdatawritemap
# define C_GDXDATAWRITEMAPSTART     c_gdxdatawritemapstart
# define C_GDXDATAWRITERAW          c_gdxdatawriteraw
# define C_GDXDATAWRITERAWSTART     c_gdxdatawriterawstart
# define C_GDXDATAWRITESTR          c_gdxdatawritestr
# define C_GDXDATAWRITESTRSTART     c_gdxdatawritestrstart
# define C_GDXGETDLLVERSION         c_gdxgetdllversion
# define C_GDXERRORCOUNT            c_gdxerrorcount
# define C_GDXERRORSTR              c_gdxerrorstr
# define C_GDXFILEINFO              c_gdxfileinfo
# define C_GDXFILEVERSION           c_gdxfileversion
# define C_GDXFILTEREXISTS          c_gdxfilterexists
# define C_GDXFILTERREGISTER        c_gdxfilterregister
# define C_GDXFILTERREGISTERDONE    c_gdxfilterregisterdone
# define C_GDXFILTERREGISTERSTART   c_gdxfilterregisterstart
# define C_GDXFINDSYMBOL            c_gdxfindsymbol
# define C_GDXGETELEMTEXT           c_gdxgetelemtext
# define C_GDXGETLASTERROR          c_gdxgetlasterror
# define C_GDXGETMEMORYUSED         c_gdxgetmemoryused
# define C_GDXGETSPECIALVALUES      c_gdxgetspecialvalues
# define C_GDXGETUEL                c_gdxgetuel
# define C_GDXMAPVALUE              c_gdxmapvalue
# define C_GDXOPENAPPEND            c_gdxopenappend
# define C_GDXOPENREAD              c_gdxopenread
# define C_GDXOPENWRITE             c_gdxopenwrite
# define C_GDXOPENWRITEEX           c_gdxopenwriteex
# define C_GDXRESETSPECIALVALUES    c_gdxresetspecialvalues
# define C_GDXSETHASTEXT            c_gdxsethastext
# define C_GDXSETREADSPECIALVALUES  c_gdxsetreadspecialvalues
# define C_GDXSETSPECIALVALUES      c_gdxsetspecialvalues
# define C_GDXSETTEXTNODENR         c_gdxsettextnodenr
# define C_GDXSETTRACELEVEL         c_gdxsettracelevel
# define C_GDXSYMBINDXMAXLENGTH     c_gdxsymbindxmaxlength
# define C_GDXSYMBMAXLENGTH         c_gdxsymbmaxlength
# define C_GDXSYMBOLADDCOMMENT      c_gdxsymboladdcomment
# define C_GDXSYMBOLGETCOMMENT      c_gdxsymbolgetcomment
# define C_GDXSYMBOLGETDOMAIN       c_gdxsymbolgetdomain
# define C_GDXSYMBOLGETDOMAINX      c_gdxsymbolgetdomainx
# define C_GDXSYMBOLDIM             c_gdxsymboldim
# define C_GDXSYMBOLINFO            c_gdxsymbolinfo
# define C_GDXSYMBOLINFOX           c_gdxsymbolinfox
# define C_GDXSYMBOLSETDOMAIN       c_gdxsymbolsetdomain
# define C_GDXSYMBOLSETDOMAINX      c_gdxsymbolsetdomainx
# define C_GDXSYSTEMINFO            c_gdxsysteminfo
# define C_GDXUELMAXLENGTH          c_gdxuelmaxlength
# define C_GDXUELREGISTERDONE       c_gdxuelregisterdone
# define C_GDXUELREGISTERMAP        c_gdxuelregistermap
# define C_GDXUELREGISTERMAPSTART   c_gdxuelregistermapstart
# define C_GDXUELREGISTERRAW        c_gdxuelregisterraw
# define C_GDXUELREGISTERRAWSTART   c_gdxuelregisterrawstart
# define C_GDXUELREGISTERSTR        c_gdxuelregisterstr
# define C_GDXUELREGISTERSTRSTART   c_gdxuelregisterstrstart
# define C_GDXUMFINDUEL             c_gdxumfinduel
# define C_GDXUMUELGET              c_gdxumuelget
# define C_GDXUMUELINFO             c_gdxumuelinfo
# define C_GDXGETDOMAINELEMENTS     c_gdxgetdomainelements
# define C_GDXCURRENTDIM            c_gdxcurrentdim
# define C_GDXCREATE                c_gdxcreate
# define C_GDXCREATED               c_gdxcreated
# define C_GDXCREATEL               c_gdxcreatel
# define C_GDXGETREADY              c_gdxgetready
# define C_GDXGETREADYD             c_gdxgetreadyd
# define C_GDXGETREADYL             c_gdxgetreadyl
# define C_GDXEXIT                  c_gdxexit
# define C_GDXFREE                  c_gdxfree
# define C_GDXGETAPIERRORCOUNT      c_gdxgetapierrorcount
# define C_GDXGETSCREENINDICATOR    c_gdxgetscreenindicator
# define C_GDXSETSCREENINDICATOR    c_gdxsetscreenindicator
# define C_GDXGETEXITINDICATOR      c_gdxgetexitindicator
# define C_GDXSETEXITINDICATOR      c_gdxsetexitindicator
# define C_GDXSETERRORCALLBACK      c_gdxseterrorcallback
#elif defined(APIWRAP_UCASE_DECOR)  /* fortran names: upper case, trailing _ */
# define C_GDXACRONYMADD            C_GDXACRONYMADD_
# define C_GDXACRONYMCOUNT          C_GDXACRONYMCOUNT_
# define C_GDXACRONYMGETINFO        C_GDXACRONYMGETINFO_
# define C_GDXACRONYMGETMAPPING     C_GDXACRONYMGETMAPPING_
# define C_GDXACRONYMINDEX          C_GDXACRONYMINDEX_
# define C_GDXACRONYMNAME           C_GDXACRONYMNAME_
# define C_GDXACRONYMNEXTNR         C_GDXACRONYMNEXTNR_
# define C_GDXACRONYMSETINFO        C_GDXACRONYMSETINFO_
# define C_GDXACRONYMVALUE          C_GDXACRONYMVALUE_
# define C_GDXADDALIAS              C_GDXADDALIAS_
# define C_GDXADDSETTEXT            C_GDXADDSETTEXT_
# define C_GDXAUTOCONVERT           C_GDXAUTOCONVERT_
# define C_GDXCLOSE                 C_GDXCLOSE_
# define C_GDXDATAERRORCOUNT        C_GDXDATAERRORCOUNT_
# define C_GDXDATAERRORRECORD       C_GDXDATAERRORRECORD_
# define C_GDXDATAREADDONE          C_GDXDATAREADDONE_
# define C_GDXDATAREADFILTEREDSTART C_GDXDATAREADFILTEREDSTART_
# define C_GDXDATAREADMAP           C_GDXDATAREADMAP_
# define C_GDXDATAREADMAPSTART      C_GDXDATAREADMAPSTART_
# define C_GDXDATAREADRAW           C_GDXDATAREADRAW_
# define C_GDXDATAREADRAWFAST       C_GDXDATAREADRAWFAST_
# define C_GDXDATAREADRAWSTART      C_GDXDATAREADRAWSTART_
# define C_GDXDATAREADSLICE         C_GDXDATAREADSLICE_
# define C_GDXDATAREADSLICESTART    C_GDXDATAREADSLICESTART_
# define C_GDXDATAREADSTR           C_GDXDATAREADSTR_
# define C_GDXDATAREADSTRSTART      C_GDXDATAREADSTRSTART_
# define C_GDXDATASLICEUELS         C_GDXDATASLICEUELS_
# define C_GDXDATAWRITEDONE         C_GDXDATAWRITEDONE_
# define C_GDXDATAWRITEMAP          C_GDXDATAWRITEMAP_
# define C_GDXDATAWRITEMAPSTART     C_GDXDATAWRITEMAPSTART_
# define C_GDXDATAWRITERAW          C_GDXDATAWRITERAW_
# define C_GDXDATAWRITERAWSTART     C_GDXDATAWRITERAWSTART_
# define C_GDXDATAWRITESTR          C_GDXDATAWRITESTR_
# define C_GDXDATAWRITESTRSTART     C_GDXDATAWRITESTRSTART_
# define C_GDXGETDLLVERSION         C_GDXGETDLLVERSION_
# define C_GDXERRORCOUNT            C_GDXERRORCOUNT_
# define C_GDXERRORSTR              C_GDXERRORSTR_
# define C_GDXFILEINFO              C_GDXFILEINFO_
# define C_GDXFILEVERSION           C_GDXFILEVERSION_
# define C_GDXFILTEREXISTS          C_GDXFILTEREXISTS_
# define C_GDXFILTERREGISTER        C_GDXFILTERREGISTER_
# define C_GDXFILTERREGISTERDONE    C_GDXFILTERREGISTERDONE_
# define C_GDXFILTERREGISTERSTART   C_GDXFILTERREGISTERSTART_
# define C_GDXFINDSYMBOL            C_GDXFINDSYMBOL_
# define C_GDXGETELEMTEXT           C_GDXGETELEMTEXT_
# define C_GDXGETLASTERROR          C_GDXGETLASTERROR_
# define C_GDXGETMEMORYUSED         C_GDXGETMEMORYUSED_
# define C_GDXGETSPECIALVALUES      C_GDXGETSPECIALVALUES_
# define C_GDXGETUEL                C_GDXGETUEL_
# define C_GDXMAPVALUE              C_GDXMAPVALUE_
# define C_GDXOPENAPPEND            C_GDXOPENAPPEND_
# define C_GDXOPENREAD              C_GDXOPENREAD_
# define C_GDXOPENWRITE             C_GDXOPENWRITE_
# define C_GDXOPENWRITEEX           C_GDXOPENWRITEEX_
# define C_GDXRESETSPECIALVALUES    C_GDXRESETSPECIALVALUES_
# define C_GDXSETHASTEXT            C_GDXSETHASTEXT_
# define C_GDXSETREADSPECIALVALUES  C_GDXSETREADSPECIALVALUES_
# define C_GDXSETSPECIALVALUES      C_GDXSETSPECIALVALUES_
# define C_GDXSETTEXTNODENR         C_GDXSETTEXTNODENR_
# define C_GDXSETTRACELEVEL         C_GDXSETTRACELEVEL_
# define C_GDXSYMBINDXMAXLENGTH     C_GDXSYMBINDXMAXLENGTH_
# define C_GDXSYMBMAXLENGTH         C_GDXSYMBMAXLENGTH_
# define C_GDXSYMBOLADDCOMMENT      C_GDXSYMBOLADDCOMMENT_
# define C_GDXSYMBOLGETCOMMENT      C_GDXSYMBOLGETCOMMENT_
# define C_GDXSYMBOLGETDOMAIN       C_GDXSYMBOLGETDOMAIN_
# define C_GDXSYMBOLGETDOMAINX      C_GDXSYMBOLGETDOMAINX_
# define C_GDXSYMBOLDIM             C_GDXSYMBOLDIM_
# define C_GDXSYMBOLINFO            C_GDXSYMBOLINFO_
# define C_GDXSYMBOLINFOX           C_GDXSYMBOLINFOX_
# define C_GDXSYMBOLSETDOMAIN       C_GDXSYMBOLSETDOMAIN_
# define C_GDXSYMBOLSETDOMAINX      C_GDXSYMBOLSETDOMAINX_
# define C_GDXSYSTEMINFO            C_GDXSYSTEMINFO_
# define C_GDXUELMAXLENGTH          C_GDXUELMAXLENGTH_
# define C_GDXUELREGISTERDONE       C_GDXUELREGISTERDONE_
# define C_GDXUELREGISTERMAP        C_GDXUELREGISTERMAP_
# define C_GDXUELREGISTERMAPSTART   C_GDXUELREGISTERMAPSTART_
# define C_GDXUELREGISTERRAW        C_GDXUELREGISTERRAW_
# define C_GDXUELREGISTERRAWSTART   C_GDXUELREGISTERRAWSTART_
# define C_GDXUELREGISTERSTR        C_GDXUELREGISTERSTR_
# define C_GDXUELREGISTERSTRSTART   C_GDXUELREGISTERSTRSTART_
# define C_GDXUMFINDUEL             C_GDXUMFINDUEL_
# define C_GDXUMUELGET              C_GDXUMUELGET_
# define C_GDXUMUELINFO             C_GDXUMUELINFO_
# define C_GDXGETDOMAINELEMENTS     C_GDXGETDOMAINELEMENTS_
# define C_GDXCURRENTDIM            C_GDXCURRENTDIM_
# define C_GDXCREATE                C_GDXCREATE_
# define C_GDXCREATED               C_GDXCREATED_
# define C_GDXCREATEL               C_GDXCREATEL_
# define C_GDXGETREADY              C_GDXGETREADY_
# define C_GDXGETREADYD             C_GDXGETREADYD_
# define C_GDXGETREADYL             C_GDXGETREADYL_
# define C_GDXEXIT                  C_GDXEXIT_
# define C_GDXFREE                  C_GDXFREE_
# define C_GDXGETAPIERRORCOUNT      C_GDXGETAPIERRORCOUNT_
# define C_GDXGETSCREENINDICATOR    C_GDXGETSCREENINDICATOR_
# define C_GDXSETSCREENINDICATOR    C_GDXSETSCREENINDICATOR_
# define C_GDXGETEXITINDICATOR      C_GDXGETEXITINDICATOR_
# define C_GDXSETEXITINDICATOR      C_GDXSETEXITINDICATOR_
# define C_GDXSETERRORCALLBACK      C_GDXSETERRORCALLBACK_
#elif defined(APIWRAP_UCASE_NODECOR)/* fortran names: upper case, no _ */
# define C_GDXACRONYMADD            C_GDXACRONYMADD
# define C_GDXACRONYMCOUNT          C_GDXACRONYMCOUNT
# define C_GDXACRONYMGETINFO        C_GDXACRONYMGETINFO
# define C_GDXACRONYMGETMAPPING     C_GDXACRONYMGETMAPPING
# define C_GDXACRONYMINDEX          C_GDXACRONYMINDEX
# define C_GDXACRONYMNAME           C_GDXACRONYMNAME
# define C_GDXACRONYMNEXTNR         C_GDXACRONYMNEXTNR
# define C_GDXACRONYMSETINFO        C_GDXACRONYMSETINFO
# define C_GDXACRONYMVALUE          C_GDXACRONYMVALUE
# define C_GDXADDALIAS              C_GDXADDALIAS
# define C_GDXADDSETTEXT            C_GDXADDSETTEXT
# define C_GDXAUTOCONVERT           C_GDXAUTOCONVERT
# define C_GDXCLOSE                 C_GDXCLOSE
# define C_GDXDATAERRORCOUNT        C_GDXDATAERRORCOUNT
# define C_GDXDATAERRORRECORD       C_GDXDATAERRORRECORD
# define C_GDXDATAREADDONE          C_GDXDATAREADDONE
# define C_GDXDATAREADFILTEREDSTART C_GDXDATAREADFILTEREDSTART
# define C_GDXDATAREADMAP           C_GDXDATAREADMAP
# define C_GDXDATAREADMAPSTART      C_GDXDATAREADMAPSTART
# define C_GDXDATAREADRAW           C_GDXDATAREADRAW
# define C_GDXDATAREADRAWFAST       C_GDXDATAREADRAWFAST
# define C_GDXDATAREADRAWSTART      C_GDXDATAREADRAWSTART
# define C_GDXDATAREADSLICE         C_GDXDATAREADSLICE
# define C_GDXDATAREADSLICESTART    C_GDXDATAREADSLICESTART
# define C_GDXDATAREADSTR           C_GDXDATAREADSTR
# define C_GDXDATAREADSTRSTART      C_GDXDATAREADSTRSTART
# define C_GDXDATASLICEUELS         C_GDXDATASLICEUELS
# define C_GDXDATAWRITEDONE         C_GDXDATAWRITEDONE
# define C_GDXDATAWRITEMAP          C_GDXDATAWRITEMAP
# define C_GDXDATAWRITEMAPSTART     C_GDXDATAWRITEMAPSTART
# define C_GDXDATAWRITERAW          C_GDXDATAWRITERAW
# define C_GDXDATAWRITERAWSTART     C_GDXDATAWRITERAWSTART
# define C_GDXDATAWRITESTR          C_GDXDATAWRITESTR
# define C_GDXDATAWRITESTRSTART     C_GDXDATAWRITESTRSTART
# define C_GDXGETDLLVERSION         C_GDXGETDLLVERSION
# define C_GDXERRORCOUNT            C_GDXERRORCOUNT
# define C_GDXERRORSTR              C_GDXERRORSTR
# define C_GDXFILEINFO              C_GDXFILEINFO
# define C_GDXFILEVERSION           C_GDXFILEVERSION
# define C_GDXFILTEREXISTS          C_GDXFILTEREXISTS
# define C_GDXFILTERREGISTER        C_GDXFILTERREGISTER
# define C_GDXFILTERREGISTERDONE    C_GDXFILTERREGISTERDONE
# define C_GDXFILTERREGISTERSTART   C_GDXFILTERREGISTERSTART
# define C_GDXFINDSYMBOL            C_GDXFINDSYMBOL
# define C_GDXGETELEMTEXT           C_GDXGETELEMTEXT
# define C_GDXGETLASTERROR          C_GDXGETLASTERROR
# define C_GDXGETMEMORYUSED         C_GDXGETMEMORYUSED
# define C_GDXGETSPECIALVALUES      C_GDXGETSPECIALVALUES
# define C_GDXGETUEL                C_GDXGETUEL
# define C_GDXMAPVALUE              C_GDXMAPVALUE
# define C_GDXOPENAPPEND            C_GDXOPENAPPEND
# define C_GDXOPENREAD              C_GDXOPENREAD
# define C_GDXOPENWRITE             C_GDXOPENWRITE
# define C_GDXOPENWRITEEX           C_GDXOPENWRITEEX
# define C_GDXRESETSPECIALVALUES    C_GDXRESETSPECIALVALUES
# define C_GDXSETHASTEXT            C_GDXSETHASTEXT
# define C_GDXSETREADSPECIALVALUES  C_GDXSETREADSPECIALVALUES
# define C_GDXSETSPECIALVALUES      C_GDXSETSPECIALVALUES
# define C_GDXSETTEXTNODENR         C_GDXSETTEXTNODENR
# define C_GDXSETTRACELEVEL         C_GDXSETTRACELEVEL
# define C_GDXSYMBINDXMAXLENGTH     C_GDXSYMBINDXMAXLENGTH
# define C_GDXSYMBMAXLENGTH         C_GDXSYMBMAXLENGTH
# define C_GDXSYMBOLADDCOMMENT      C_GDXSYMBOLADDCOMMENT
# define C_GDXSYMBOLGETCOMMENT      C_GDXSYMBOLGETCOMMENT
# define C_GDXSYMBOLGETDOMAIN       C_GDXSYMBOLGETDOMAIN
# define C_GDXSYMBOLGETDOMAINX      C_GDXSYMBOLGETDOMAINX
# define C_GDXSYMBOLDIM             C_GDXSYMBOLDIM
# define C_GDXSYMBOLINFO            C_GDXSYMBOLINFO
# define C_GDXSYMBOLINFOX           C_GDXSYMBOLINFOX
# define C_GDXSYMBOLSETDOMAIN       C_GDXSYMBOLSETDOMAIN
# define C_GDXSYMBOLSETDOMAINX      C_GDXSYMBOLSETDOMAINX
# define C_GDXSYSTEMINFO            C_GDXSYSTEMINFO
# define C_GDXUELMAXLENGTH          C_GDXUELMAXLENGTH
# define C_GDXUELREGISTERDONE       C_GDXUELREGISTERDONE
# define C_GDXUELREGISTERMAP        C_GDXUELREGISTERMAP
# define C_GDXUELREGISTERMAPSTART   C_GDXUELREGISTERMAPSTART
# define C_GDXUELREGISTERRAW        C_GDXUELREGISTERRAW
# define C_GDXUELREGISTERRAWSTART   C_GDXUELREGISTERRAWSTART
# define C_GDXUELREGISTERSTR        C_GDXUELREGISTERSTR
# define C_GDXUELREGISTERSTRSTART   C_GDXUELREGISTERSTRSTART
# define C_GDXUMFINDUEL             C_GDXUMFINDUEL
# define C_GDXUMUELGET              C_GDXUMUELGET
# define C_GDXUMUELINFO             C_GDXUMUELINFO
# define C_GDXGETDOMAINELEMENTS     C_GDXGETDOMAINELEMENTS
# define C_GDXCURRENTDIM            C_GDXCURRENTDIM
# define C_GDXCREATE                C_GDXCREATE
# define C_GDXCREATED               C_GDXCREATED
# define C_GDXCREATEL               C_GDXCREATEL
# define C_GDXGETREADY              C_GDXGETREADY
# define C_GDXGETREADYD             C_GDXGETREADYD
# define C_GDXGETREADYL             C_GDXGETREADYL
# define C_GDXEXIT                  C_GDXEXIT
# define C_GDXFREE                  C_GDXFREE
# define C_GDXGETAPIERRORCOUNT      C_GDXGETAPIERRORCOUNT
# define C_GDXGETSCREENINDICATOR    C_GDXGETSCREENINDICATOR
# define C_GDXSETSCREENINDICATOR    C_GDXSETSCREENINDICATOR
# define C_GDXGETEXITINDICATOR      C_GDXGETEXITINDICATOR
# define C_GDXSETEXITINDICATOR      C_GDXSETEXITINDICATOR
# define C_GDXSETERRORCALLBACK      C_GDXSETERRORCALLBACK
#else
#error "No compile define for fortran naming convention"
No_compile_define_for_fortran_naming_convention;
#endif


/* gdxGetReady: return false on failure, true on success */
static int gdxGetReady (char *msgBuf, int msgBufSize)
{
  int rc;

  lock(libMutex);
  rc = libloader(NULL, NULL, msgBuf, msgBufSize);
  unlock(libMutex);
  return rc;
} /* gdxGetReady */

/* gdxGetReadyD: return false on failure to load library, true on success */
static int gdxGetReadyD (const char *dirName, char *msgBuf, int msgBufSize)
{
  int rc;

  lock(libMutex);
  rc = libloader(dirName, NULL, msgBuf, msgBufSize);
  unlock(libMutex);
  return rc;
} /* gdxGetReadyD */

/* gdxGetReadyL: return false on failure to load library, true on success */
static int gdxGetReadyL (const char *libName, char *msgBuf, int msgBufSize)
{
  char dirName[1024],fName[1024];
  int rc;

  extractFileDirFileName (libName, dirName, fName);
  lock(libMutex);
  rc = libloader(dirName, fName, msgBuf, msgBufSize);
  unlock(libMutex);
  return rc;
} /* gdxGetReadyL */

/* gdxGetReady: return false on failure, true on success */
gdxBoolean_t F9_CALLCONV
C_GDXGETREADY (char **msgBuf, int msgBufSiz)
{
  int gdxIsReady;
  gdxIsReady = gdxGetReady (*msgBuf, msgBufSiz);
  blankPad (*msgBuf, strlen(*msgBuf), msgBufSiz);
  return gdxIsReady;
} /* gdxGetReady */

/* gdxGetReadyD: return false on failure to load library, true on success */
gdxBoolean_t F9_CALLCONV
C_GDXGETREADYD (char **dirName, int dirNameSiz, char **msgBuf, int msgBufSiz)
{
  int gdxIsReady;
  char dirNameC[512];
  convertF2C (*dirName, dirNameC, dirNameSiz, sizeof(dirNameC));
  **msgBuf = '\0';
  gdxIsReady = gdxGetReadyD (dirNameC, *msgBuf, msgBufSiz);
  blankPad (*msgBuf, strlen(*msgBuf), msgBufSiz);
  return gdxIsReady;
} /* gdxGetReadyD */

/* gdxGetReadyL: return false on failure to load library, true on success */
gdxBoolean_t F9_CALLCONV
C_GDXGETREADYL (char **libName, int libNameSiz, char **msgBuf, int msgBufSiz)
{
  int gdxIsReady;
  char libNameC[512];
  convertF2C (*libName, libNameC, libNameSiz, sizeof(libNameC));
  **msgBuf = '\0';
  gdxIsReady = gdxGetReadyL (libNameC, *msgBuf, msgBufSiz);
  blankPad (*msgBuf, strlen(*msgBuf), msgBufSiz);
  return gdxIsReady;
} /* gdxGetReadyL */

/* gdxCreate: return false on failure, true on success */
gdxBoolean_t F9_CALLCONV
C_GDXCREATE (u64_t *h, char **msgBuf, int msgBufSiz)
{
  int gdxIsReady;

  gdxIsReady = gdxGetReady (*msgBuf, msgBufSiz);
  blankPad (*msgBuf, strlen(*msgBuf), msgBufSiz);
  if (! gdxIsReady) {
    return 0;
  }
  assert(XCreate);
  XCreate(&(h->p));
  if(NULL == h->p)
  { strcpy(*msgBuf,"Error while creating object"); return 0; }
  lock(objMutex);
  objectCount++;
  unlock(objMutex);

  return 1;                     /* return true */
} /* gdxCreate */

/* gdxCreateD: return false on failure to load library, true on success */
gdxBoolean_t F9_CALLCONV
C_GDXCREATED (u64_t *h, char **dirName, int dirNameSiz, char **msgBuf, int msgBufSiz)
{
  int gdxIsReady;
  char dirNameC[512];

  convertF2C (*dirName, dirNameC, dirNameSiz, sizeof(dirNameC));
  **msgBuf = '\0';
  gdxIsReady = gdxGetReadyD (dirNameC, *msgBuf, msgBufSiz);
  blankPad (*msgBuf, strlen(*msgBuf), msgBufSiz);
  if (! gdxIsReady) {
    return 0;
  }
  assert(XCreate);
  XCreate(&(h->p));
  if(NULL == h->p)
  { strcpy(*msgBuf,"Error while creating object"); return 0; }
  lock(objMutex);
  objectCount++;
  unlock(objMutex);

  return 1;                     /* return true */
} /* gdxCreateD */

/* gdxCreateL: return false on failure to load library, true on success */
gdxBoolean_t F9_CALLCONV
C_GDXCREATEL (u64_t *h, char **libName, int libNameSiz, char **msgBuf, int msgBufSiz)
{
  int gdxIsReady;
  char libNameC[512];

  convertF2C (*libName, libNameC, libNameSiz, sizeof(libNameC));
  **msgBuf = '\0';
  gdxIsReady = gdxGetReadyL (libNameC, *msgBuf, msgBufSiz);
  blankPad (*msgBuf, strlen(*msgBuf), msgBufSiz);
  if (! gdxIsReady) {
    return 0;
  }
  assert(XCreate);
  XCreate(&(h->p));
  if(NULL == h->p)
  { strcpy(*msgBuf,"Error while creating object"); return 0; }
  lock(objMutex);
  objectCount++;
  unlock(objMutex);

  return 1;                     /* return true */
} /* gdxCreateL */

void F9_CALLCONV
C_GDXEXIT (int i)
{
  exit (i);
} /* gdxExit */

gdxBoolean_t F9_CALLCONV
C_GDXFREE (u64_t *h)
{
  assert(XFree);
  XFree(&(h->p));
  lock(objMutex);
  objectCount--;
  if (isLoaded && 0 == objectCount) {
    (void) unLoadLib (hLibGlobal);
    isLoaded = 0;
  }
  unlock(objMutex);
  return 1;
} /* gdxFree */

int F9_CALLCONV
C_GDXGETSCREENINDICATOR ()
{
  return screenIndicator;
} /* gdxGetScreenIndicator */

void F9_CALLCONV
C_GDXSETSCREENINDICATOR (int scrInd)
{
  screenIndicator = scrInd;
  return;
} /* gdxSetScreenIndicator */

int F9_CALLCONV
C_GDXGETEXITINDICATOR ()
{
  return exitIndicator;
} /* gdxGetExitIndicator */

void F9_CALLCONV
C_GDXSETEXITINDICATOR (int extInd)
{
  exitIndicator = extInd;
  return;
} /* gdxSetExitIndicator */

void F9_CALLCONV
C_GDXSETERRORCALLBACK(errorCallbackFort_t func)
{
  lock(exceptMutex);
  errorCallbackFort = func;
  unlock(exceptMutex);
} /* gdxSetErrorCallback */

int F9_CALLCONV
C_GDXGETAPIERRORCOUNT ()
{
  return APIErrorCount;
} /* gdxGetAPIErrorCount */


/* start implementation of glue code for functions */

int F9_CALLCONV
C_GDXACRONYMADD (INT64 iptr_, const char **AName, int len_AName, const char **Txt, int len_Txt, int AIndx)
{
  u64_t h_;
  int result;
  string255 pas_AName;
  string255 pas_Txt;

  h_.i = iptr_;
  convertF2PAS(*AName, pas_AName, len_AName, 255);
  convertF2PAS(*Txt, pas_Txt, len_Txt, 255);
  result = gdxAcronymAdd(h_.p,pas_AName,pas_Txt,AIndx);
  return result;
}

int F9_CALLCONV
C_GDXACRONYMCOUNT (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxAcronymCount(h_.p);
  return result;
}

int F9_CALLCONV
C_GDXACRONYMGETINFO (INT64 iptr_, int N, char **AName, int len_AName, char **Txt, int len_Txt, int *AIndx)
{
  u64_t h_;
  int result;
  string255 pas_AName;
  string255 pas_Txt;

  h_.i = iptr_;
  result = gdxAcronymGetInfo(h_.p,N,pas_AName,pas_Txt,AIndx);
  convertPAS2F(pas_AName, *AName, len_AName);
  convertPAS2F(pas_Txt, *Txt, len_Txt);
  return result;
}

int F9_CALLCONV
C_GDXACRONYMGETMAPPING (INT64 iptr_, int N, int *orgIndx, int *newIndx, int *autoIndex)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxAcronymGetMapping(h_.p,N,orgIndx,newIndx,autoIndex);
  return result;
}

int F9_CALLCONV
C_GDXACRONYMINDEX (INT64 iptr_, double V)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxAcronymIndex(h_.p,V);
  return result;
}

int F9_CALLCONV
C_GDXACRONYMNAME (INT64 iptr_, double V, char **AName, int len_AName)
{
  u64_t h_;
  int result;
  string255 pas_AName;

  h_.i = iptr_;
  result = gdxAcronymName(h_.p,V,pas_AName);
  convertPAS2F(pas_AName, *AName, len_AName);
  return result;
}

int F9_CALLCONV
C_GDXACRONYMNEXTNR (INT64 iptr_, int NV)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxAcronymNextNr(h_.p,NV);
  return result;
}

int F9_CALLCONV
C_GDXACRONYMSETINFO (INT64 iptr_, int N, const char **AName, int len_AName, const char **Txt, int len_Txt, int AIndx)
{
  u64_t h_;
  int result;
  string255 pas_AName;
  string255 pas_Txt;

  h_.i = iptr_;
  convertF2PAS(*AName, pas_AName, len_AName, 255);
  convertF2PAS(*Txt, pas_Txt, len_Txt, 255);
  result = gdxAcronymSetInfo(h_.p,N,pas_AName,pas_Txt,AIndx);
  return result;
}

double F9_CALLCONV
C_GDXACRONYMVALUE (INT64 iptr_, int AIndx)
{
  u64_t h_;
  double result;

  h_.i = iptr_;
  result = gdxAcronymValue(h_.p,AIndx);
  return result;
}

int F9_CALLCONV
C_GDXADDALIAS (INT64 iptr_, const char **Id1, int len_Id1, const char **Id2, int len_Id2)
{
  u64_t h_;
  int result;
  string255 pas_Id1;
  string255 pas_Id2;

  h_.i = iptr_;
  convertF2PAS(*Id1, pas_Id1, len_Id1, 255);
  convertF2PAS(*Id2, pas_Id2, len_Id2, 255);
  result = gdxAddAlias(h_.p,pas_Id1,pas_Id2);
  return result;
}

int F9_CALLCONV
C_GDXADDSETTEXT (INT64 iptr_, const char **Txt, int len_Txt, int *TxtNr)
{
  u64_t h_;
  int result;
  string255 pas_Txt;

  h_.i = iptr_;
  convertF2PAS(*Txt, pas_Txt, len_Txt, 255);
  result = gdxAddSetText(h_.p,pas_Txt,TxtNr);
  return result;
}

int F9_CALLCONV
C_GDXAUTOCONVERT (INT64 iptr_, int NV)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxAutoConvert(h_.p,NV);
  return result;
}

int F9_CALLCONV
C_GDXCLOSE (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxClose(h_.p);
  return result;
}

int F9_CALLCONV
C_GDXDATAERRORCOUNT (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxDataErrorCount(h_.p);
  return result;
}

int F9_CALLCONV
C_GDXDATAERRORRECORD (INT64 iptr_, int RecNr, int KeyInt[], double Values[])
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxDataErrorRecord(h_.p,RecNr,KeyInt,Values);
  return result;
}

int F9_CALLCONV
C_GDXDATAREADDONE (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxDataReadDone(h_.p);
  return result;
}

int F9_CALLCONV
C_GDXDATAREADFILTEREDSTART (INT64 iptr_, int SyNr, const int FilterAction[], int *NrRecs)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxDataReadFilteredStart(h_.p,SyNr,FilterAction,NrRecs);
  return result;
}

int F9_CALLCONV
C_GDXDATAREADMAP (INT64 iptr_, int RecNr, int KeyInt[], double Values[], int *DimFrst)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxDataReadMap(h_.p,RecNr,KeyInt,Values,DimFrst);
  return result;
}

int F9_CALLCONV
C_GDXDATAREADMAPSTART (INT64 iptr_, int SyNr, int *NrRecs)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxDataReadMapStart(h_.p,SyNr,NrRecs);
  return result;
}

int F9_CALLCONV
C_GDXDATAREADRAW (INT64 iptr_, int KeyInt[], double Values[], int *DimFrst)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxDataReadRaw(h_.p,KeyInt,Values,DimFrst);
  return result;
}

int F9_CALLCONV
C_GDXDATAREADRAWFAST (INT64 iptr_, int SyNr, TDataStoreProc_F_t DP, int *NrRecs)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxDataReadRawFast(h_.p,SyNr,DP,NrRecs);
  return result;
}

int F9_CALLCONV
C_GDXDATAREADRAWSTART (INT64 iptr_, int SyNr, int *NrRecs)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxDataReadRawStart(h_.p,SyNr,NrRecs);
  return result;
}

int F9_CALLCONV
C_GDXDATAREADSLICE (INT64 iptr_, const char *UelFilterStr[], int len_UelFilterStr, int *Dimen, TDataStoreProc_F_t DP)
{
  u64_t h_;
  int result;
  string255 pas_UelFilterStr[GLOBAL_MAX_INDEX_DIM];
  int i_,sidim_;

  h_.i = iptr_;
  sidim_ = gdxCurrentDim(h_.p);
  for (i_ = 0;  i_ < sidim_;  i_++)
    convertF2PAS(*UelFilterStr + i_*len_UelFilterStr, pas_UelFilterStr[i_], len_UelFilterStr, 255);
  result = gdxDataReadSlice(h_.p,(const char **) pas_UelFilterStr,Dimen,DP);
  return result;
}

int F9_CALLCONV
C_GDXDATAREADSLICESTART (INT64 iptr_, int SyNr, int ElemCounts[])
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxDataReadSliceStart(h_.p,SyNr,ElemCounts);
  return result;
}

int F9_CALLCONV
C_GDXDATAREADSTR (INT64 iptr_, char *KeyStr[], int len_KeyStr, double Values[], int *DimFrst)
{
  u64_t h_;
  int result;
  string255 pas_KeyStr[GLOBAL_MAX_INDEX_DIM];
  int i_,sidim_;

  h_.i = iptr_;
  result = gdxDataReadStr(h_.p,(char **) pas_KeyStr,Values,DimFrst);
  sidim_ = gdxCurrentDim(h_.p);
  for (i_ = 0;  i_ < sidim_;  i_++)
    convertPAS2F(pas_KeyStr[i_], *KeyStr + i_*len_KeyStr, len_KeyStr);
  return result;
}

int F9_CALLCONV
C_GDXDATAREADSTRSTART (INT64 iptr_, int SyNr, int *NrRecs)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxDataReadStrStart(h_.p,SyNr,NrRecs);
  return result;
}

int F9_CALLCONV
C_GDXDATASLICEUELS (INT64 iptr_, const int SliceKeyInt[], char *KeyStr[], int len_KeyStr)
{
  u64_t h_;
  int result;
  string255 pas_KeyStr[GLOBAL_MAX_INDEX_DIM];
  int i_,sidim_;

  h_.i = iptr_;
  result = gdxDataSliceUELS(h_.p,SliceKeyInt,(char **) pas_KeyStr);
  sidim_ = gdxCurrentDim(h_.p);
  for (i_ = 0;  i_ < sidim_;  i_++)
    convertPAS2F(pas_KeyStr[i_], *KeyStr + i_*len_KeyStr, len_KeyStr);
  return result;
}

int F9_CALLCONV
C_GDXDATAWRITEDONE (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxDataWriteDone(h_.p);
  return result;
}

int F9_CALLCONV
C_GDXDATAWRITEMAP (INT64 iptr_, const int KeyInt[], const double Values[])
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxDataWriteMap(h_.p,KeyInt,Values);
  return result;
}

int F9_CALLCONV
C_GDXDATAWRITEMAPSTART (INT64 iptr_, const char **SyId, int len_SyId, const char **ExplTxt, int len_ExplTxt, int Dimen, int Typ, int UserInfo)
{
  u64_t h_;
  int result;
  string255 pas_SyId;
  string255 pas_ExplTxt;

  h_.i = iptr_;
  convertF2PAS(*SyId, pas_SyId, len_SyId, 255);
  convertF2PAS(*ExplTxt, pas_ExplTxt, len_ExplTxt, 255);
  result = gdxDataWriteMapStart(h_.p,pas_SyId,pas_ExplTxt,Dimen,Typ,UserInfo);
  return result;
}

int F9_CALLCONV
C_GDXDATAWRITERAW (INT64 iptr_, const int KeyInt[], const double Values[])
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxDataWriteRaw(h_.p,KeyInt,Values);
  return result;
}

int F9_CALLCONV
C_GDXDATAWRITERAWSTART (INT64 iptr_, const char **SyId, int len_SyId, const char **ExplTxt, int len_ExplTxt, int Dimen, int Typ, int UserInfo)
{
  u64_t h_;
  int result;
  string255 pas_SyId;
  string255 pas_ExplTxt;

  h_.i = iptr_;
  convertF2PAS(*SyId, pas_SyId, len_SyId, 255);
  convertF2PAS(*ExplTxt, pas_ExplTxt, len_ExplTxt, 255);
  result = gdxDataWriteRawStart(h_.p,pas_SyId,pas_ExplTxt,Dimen,Typ,UserInfo);
  return result;
}

int F9_CALLCONV
C_GDXDATAWRITESTR (INT64 iptr_, const char *KeyStr[], int len_KeyStr, const double Values[])
{
  u64_t h_;
  int result;
  string255 pas_KeyStr[GLOBAL_MAX_INDEX_DIM];
  int i_,sidim_;

  h_.i = iptr_;
  sidim_ = gdxCurrentDim(h_.p);
  for (i_ = 0;  i_ < sidim_;  i_++)
    convertF2PAS(*KeyStr + i_*len_KeyStr, pas_KeyStr[i_], len_KeyStr, 255);
  result = gdxDataWriteStr(h_.p,(const char **) pas_KeyStr,Values);
  return result;
}

int F9_CALLCONV
C_GDXDATAWRITESTRSTART (INT64 iptr_, const char **SyId, int len_SyId, const char **ExplTxt, int len_ExplTxt, int Dimen, int Typ, int UserInfo)
{
  u64_t h_;
  int result;
  string255 pas_SyId;
  string255 pas_ExplTxt;

  h_.i = iptr_;
  convertF2PAS(*SyId, pas_SyId, len_SyId, 255);
  convertF2PAS(*ExplTxt, pas_ExplTxt, len_ExplTxt, 255);
  result = gdxDataWriteStrStart(h_.p,pas_SyId,pas_ExplTxt,Dimen,Typ,UserInfo);
  return result;
}

int F9_CALLCONV
C_GDXGETDLLVERSION (INT64 iptr_, char **V, int len_V)
{
  u64_t h_;
  int result;
  string255 pas_V;

  h_.i = iptr_;
  result = gdxGetDLLVersion(h_.p,pas_V);
  convertPAS2F(pas_V, *V, len_V);
  return result;
}

int F9_CALLCONV
C_GDXERRORCOUNT (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxErrorCount(h_.p);
  return result;
}

int F9_CALLCONV
C_GDXERRORSTR (INT64 iptr_, int ErrNr, char **ErrMsg, int len_ErrMsg)
{
  u64_t h_;
  int result;
  string255 pas_ErrMsg;

  h_.i = iptr_;
  result = gdxErrorStr(h_.p,ErrNr,pas_ErrMsg);
  convertPAS2F(pas_ErrMsg, *ErrMsg, len_ErrMsg);
  return result;
}

int F9_CALLCONV
C_GDXFILEINFO (INT64 iptr_, int *FileVer, int *ComprLev)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxFileInfo(h_.p,FileVer,ComprLev);
  return result;
}

int F9_CALLCONV
C_GDXFILEVERSION (INT64 iptr_, char **FileStr, int len_FileStr, char **ProduceStr, int len_ProduceStr)
{
  u64_t h_;
  int result;
  string255 pas_FileStr;
  string255 pas_ProduceStr;

  h_.i = iptr_;
  result = gdxFileVersion(h_.p,pas_FileStr,pas_ProduceStr);
  convertPAS2F(pas_FileStr, *FileStr, len_FileStr);
  convertPAS2F(pas_ProduceStr, *ProduceStr, len_ProduceStr);
  return result;
}

int F9_CALLCONV
C_GDXFILTEREXISTS (INT64 iptr_, int FilterNr)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxFilterExists(h_.p,FilterNr);
  return result;
}

int F9_CALLCONV
C_GDXFILTERREGISTER (INT64 iptr_, int UelMap)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxFilterRegister(h_.p,UelMap);
  return result;
}

int F9_CALLCONV
C_GDXFILTERREGISTERDONE (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxFilterRegisterDone(h_.p);
  return result;
}

int F9_CALLCONV
C_GDXFILTERREGISTERSTART (INT64 iptr_, int FilterNr)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxFilterRegisterStart(h_.p,FilterNr);
  return result;
}

int F9_CALLCONV
C_GDXFINDSYMBOL (INT64 iptr_, const char **SyId, int len_SyId, int *SyNr)
{
  u64_t h_;
  int result;
  string255 pas_SyId;

  h_.i = iptr_;
  convertF2PAS(*SyId, pas_SyId, len_SyId, 255);
  result = gdxFindSymbol(h_.p,pas_SyId,SyNr);
  return result;
}

int F9_CALLCONV
C_GDXGETELEMTEXT (INT64 iptr_, int TxtNr, char **Txt, int len_Txt, int *Node)
{
  u64_t h_;
  int result;
  string255 pas_Txt;

  h_.i = iptr_;
  result = gdxGetElemText(h_.p,TxtNr,pas_Txt,Node);
  convertPAS2F(pas_Txt, *Txt, len_Txt);
  return result;
}

int F9_CALLCONV
C_GDXGETLASTERROR (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxGetLastError(h_.p);
  return result;
}

INT64 F9_CALLCONV
C_GDXGETMEMORYUSED (INT64 iptr_)
{
  u64_t h_;
  INT64 result;

  h_.i = iptr_;
  result = gdxGetMemoryUsed(h_.p);
  return result;
}

int F9_CALLCONV
C_GDXGETSPECIALVALUES (INT64 iptr_, double AVals[])
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxGetSpecialValues(h_.p,AVals);
  return result;
}

int F9_CALLCONV
C_GDXGETUEL (INT64 iptr_, int UelNr, char **Uel, int len_Uel)
{
  u64_t h_;
  int result;
  string255 pas_Uel;

  h_.i = iptr_;
  result = gdxGetUEL(h_.p,UelNr,pas_Uel);
  convertPAS2F(pas_Uel, *Uel, len_Uel);
  return result;
}

int F9_CALLCONV
C_GDXMAPVALUE (INT64 iptr_, double D, int *sv)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxMapValue(h_.p,D,sv);
  return result;
}

int F9_CALLCONV
C_GDXOPENAPPEND (INT64 iptr_, const char **FileName, int len_FileName, const char **Producer, int len_Producer, int *ErrNr)
{
  u64_t h_;
  int result;
  string255 pas_FileName;
  string255 pas_Producer;

  h_.i = iptr_;
  convertF2PAS(*FileName, pas_FileName, len_FileName, 255);
  convertF2PAS(*Producer, pas_Producer, len_Producer, 255);
  result = gdxOpenAppend(h_.p,pas_FileName,pas_Producer,ErrNr);
  return result;
}

int F9_CALLCONV
C_GDXOPENREAD (INT64 iptr_, const char **FileName, int len_FileName, int *ErrNr)
{
  u64_t h_;
  int result;
  string255 pas_FileName;

  h_.i = iptr_;
  convertF2PAS(*FileName, pas_FileName, len_FileName, 255);
  result = gdxOpenRead(h_.p,pas_FileName,ErrNr);
  return result;
}

int F9_CALLCONV
C_GDXOPENWRITE (INT64 iptr_, const char **FileName, int len_FileName, const char **Producer, int len_Producer, int *ErrNr)
{
  u64_t h_;
  int result;
  string255 pas_FileName;
  string255 pas_Producer;

  h_.i = iptr_;
  convertF2PAS(*FileName, pas_FileName, len_FileName, 255);
  convertF2PAS(*Producer, pas_Producer, len_Producer, 255);
  result = gdxOpenWrite(h_.p,pas_FileName,pas_Producer,ErrNr);
  return result;
}

int F9_CALLCONV
C_GDXOPENWRITEEX (INT64 iptr_, const char **FileName, int len_FileName, const char **Producer, int len_Producer, int Compr, int *ErrNr)
{
  u64_t h_;
  int result;
  string255 pas_FileName;
  string255 pas_Producer;

  h_.i = iptr_;
  convertF2PAS(*FileName, pas_FileName, len_FileName, 255);
  convertF2PAS(*Producer, pas_Producer, len_Producer, 255);
  result = gdxOpenWriteEx(h_.p,pas_FileName,pas_Producer,Compr,ErrNr);
  return result;
}

int F9_CALLCONV
C_GDXRESETSPECIALVALUES (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxResetSpecialValues(h_.p);
  return result;
}

int F9_CALLCONV
C_GDXSETHASTEXT (INT64 iptr_, int SyNr)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxSetHasText(h_.p,SyNr);
  return result;
}

int F9_CALLCONV
C_GDXSETREADSPECIALVALUES (INT64 iptr_, const double AVals[])
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxSetReadSpecialValues(h_.p,AVals);
  return result;
}

int F9_CALLCONV
C_GDXSETSPECIALVALUES (INT64 iptr_, const double AVals[])
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxSetSpecialValues(h_.p,AVals);
  return result;
}

int F9_CALLCONV
C_GDXSETTEXTNODENR (INT64 iptr_, int TxtNr, int Node)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxSetTextNodeNr(h_.p,TxtNr,Node);
  return result;
}

int F9_CALLCONV
C_GDXSETTRACELEVEL (INT64 iptr_, int N, const char **s, int len_s)
{
  u64_t h_;
  int result;
  string255 pas_s;

  h_.i = iptr_;
  convertF2PAS(*s, pas_s, len_s, 255);
  result = gdxSetTraceLevel(h_.p,N,pas_s);
  return result;
}

int F9_CALLCONV
C_GDXSYMBINDXMAXLENGTH (INT64 iptr_, int SyNr, int LengthInfo[])
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxSymbIndxMaxLength(h_.p,SyNr,LengthInfo);
  return result;
}

int F9_CALLCONV
C_GDXSYMBMAXLENGTH (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxSymbMaxLength(h_.p);
  return result;
}

int F9_CALLCONV
C_GDXSYMBOLADDCOMMENT (INT64 iptr_, int SyNr, const char **Txt, int len_Txt)
{
  u64_t h_;
  int result;
  string255 pas_Txt;

  h_.i = iptr_;
  convertF2PAS(*Txt, pas_Txt, len_Txt, 255);
  result = gdxSymbolAddComment(h_.p,SyNr,pas_Txt);
  return result;
}

int F9_CALLCONV
C_GDXSYMBOLGETCOMMENT (INT64 iptr_, int SyNr, int N, char **Txt, int len_Txt)
{
  u64_t h_;
  int result;
  string255 pas_Txt;

  h_.i = iptr_;
  result = gdxSymbolGetComment(h_.p,SyNr,N,pas_Txt);
  convertPAS2F(pas_Txt, *Txt, len_Txt);
  return result;
}

int F9_CALLCONV
C_GDXSYMBOLGETDOMAIN (INT64 iptr_, int SyNr, int DomainSyNrs[])
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxSymbolGetDomain(h_.p,SyNr,DomainSyNrs);
  return result;
}

int F9_CALLCONV
C_GDXSYMBOLGETDOMAINX (INT64 iptr_, int SyNr, char *DomainIDs[], int len_DomainIDs)
{
  u64_t h_;
  int result;
  string255 pas_DomainIDs[GLOBAL_MAX_INDEX_DIM];
  int i_,sidim_;

  h_.i = iptr_;
  result = gdxSymbolGetDomainX(h_.p,SyNr,(char **) pas_DomainIDs);
  sidim_ = gdxSymbolDim(h_.p, SyNr);
  for (i_ = 0;  i_ < sidim_;  i_++)
    convertPAS2F(pas_DomainIDs[i_], *DomainIDs + i_*len_DomainIDs, len_DomainIDs);
  return result;
}

int F9_CALLCONV
C_GDXSYMBOLDIM (INT64 iptr_, int SyNr)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxSymbolDim(h_.p,SyNr);
  return result;
}

int F9_CALLCONV
C_GDXSYMBOLINFO (INT64 iptr_, int SyNr, char **SyId, int len_SyId, int *Dimen, int *Typ)
{
  u64_t h_;
  int result;
  string255 pas_SyId;

  h_.i = iptr_;
  result = gdxSymbolInfo(h_.p,SyNr,pas_SyId,Dimen,Typ);
  convertPAS2F(pas_SyId, *SyId, len_SyId);
  return result;
}

int F9_CALLCONV
C_GDXSYMBOLINFOX (INT64 iptr_, int SyNr, int *RecCnt, int *UserInfo, char **ExplTxt, int len_ExplTxt)
{
  u64_t h_;
  int result;
  string255 pas_ExplTxt;

  h_.i = iptr_;
  result = gdxSymbolInfoX(h_.p,SyNr,RecCnt,UserInfo,pas_ExplTxt);
  convertPAS2F(pas_ExplTxt, *ExplTxt, len_ExplTxt);
  return result;
}

int F9_CALLCONV
C_GDXSYMBOLSETDOMAIN (INT64 iptr_, const char *DomainIDs[], int len_DomainIDs)
{
  u64_t h_;
  int result;
  string255 pas_DomainIDs[GLOBAL_MAX_INDEX_DIM];
  int i_,sidim_;

  h_.i = iptr_;
  sidim_ = gdxCurrentDim(h_.p);
  for (i_ = 0;  i_ < sidim_;  i_++)
    convertF2PAS(*DomainIDs + i_*len_DomainIDs, pas_DomainIDs[i_], len_DomainIDs, 255);
  result = gdxSymbolSetDomain(h_.p,(const char **) pas_DomainIDs);
  return result;
}

int F9_CALLCONV
C_GDXSYMBOLSETDOMAINX (INT64 iptr_, int SyNr, const char *DomainIDs[], int len_DomainIDs)
{
  u64_t h_;
  int result;
  string255 pas_DomainIDs[GLOBAL_MAX_INDEX_DIM];
  int i_,sidim_;

  h_.i = iptr_;
  sidim_ = gdxSymbolDim(h_.p, SyNr);
  for (i_ = 0;  i_ < sidim_;  i_++)
    convertF2PAS(*DomainIDs + i_*len_DomainIDs, pas_DomainIDs[i_], len_DomainIDs, 255);
  result = gdxSymbolSetDomainX(h_.p,SyNr,(const char **) pas_DomainIDs);
  return result;
}

int F9_CALLCONV
C_GDXSYSTEMINFO (INT64 iptr_, int *SyCnt, int *UelCnt)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxSystemInfo(h_.p,SyCnt,UelCnt);
  return result;
}

int F9_CALLCONV
C_GDXUELMAXLENGTH (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxUELMaxLength(h_.p);
  return result;
}

int F9_CALLCONV
C_GDXUELREGISTERDONE (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxUELRegisterDone(h_.p);
  return result;
}

int F9_CALLCONV
C_GDXUELREGISTERMAP (INT64 iptr_, int UMap, const char **Uel, int len_Uel)
{
  u64_t h_;
  int result;
  string255 pas_Uel;

  h_.i = iptr_;
  convertF2PAS(*Uel, pas_Uel, len_Uel, 255);
  result = gdxUELRegisterMap(h_.p,UMap,pas_Uel);
  return result;
}

int F9_CALLCONV
C_GDXUELREGISTERMAPSTART (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxUELRegisterMapStart(h_.p);
  return result;
}

int F9_CALLCONV
C_GDXUELREGISTERRAW (INT64 iptr_, const char **Uel, int len_Uel)
{
  u64_t h_;
  int result;
  string255 pas_Uel;

  h_.i = iptr_;
  convertF2PAS(*Uel, pas_Uel, len_Uel, 255);
  result = gdxUELRegisterRaw(h_.p,pas_Uel);
  return result;
}

int F9_CALLCONV
C_GDXUELREGISTERRAWSTART (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxUELRegisterRawStart(h_.p);
  return result;
}

int F9_CALLCONV
C_GDXUELREGISTERSTR (INT64 iptr_, const char **Uel, int len_Uel, int *UelNr)
{
  u64_t h_;
  int result;
  string255 pas_Uel;

  h_.i = iptr_;
  convertF2PAS(*Uel, pas_Uel, len_Uel, 255);
  result = gdxUELRegisterStr(h_.p,pas_Uel,UelNr);
  return result;
}

int F9_CALLCONV
C_GDXUELREGISTERSTRSTART (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxUELRegisterStrStart(h_.p);
  return result;
}

int F9_CALLCONV
C_GDXUMFINDUEL (INT64 iptr_, const char **Uel, int len_Uel, int *UelNr, int *UelMap)
{
  u64_t h_;
  int result;
  string255 pas_Uel;

  h_.i = iptr_;
  convertF2PAS(*Uel, pas_Uel, len_Uel, 255);
  result = gdxUMFindUEL(h_.p,pas_Uel,UelNr,UelMap);
  return result;
}

int F9_CALLCONV
C_GDXUMUELGET (INT64 iptr_, int UelNr, char **Uel, int len_Uel, int *UelMap)
{
  u64_t h_;
  int result;
  string255 pas_Uel;

  h_.i = iptr_;
  result = gdxUMUelGet(h_.p,UelNr,pas_Uel,UelMap);
  convertPAS2F(pas_Uel, *Uel, len_Uel);
  return result;
}

int F9_CALLCONV
C_GDXUMUELINFO (INT64 iptr_, int *UelCnt, int *HighMap)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxUMUelInfo(h_.p,UelCnt,HighMap);
  return result;
}

int F9_CALLCONV
C_GDXGETDOMAINELEMENTS (INT64 iptr_, int SyNr, int DimPos, int FilterNr, TDomainIndexProc_F_t DP, int *NrElem, INT64 Uptr)
{
  u64_t h_;
  int result;
  u64_t fptr_Uptr;

  h_.i = iptr_;
  fptr_Uptr.i = Uptr;
  result = gdxGetDomainElements(h_.p,SyNr,DimPos,FilterNr,DP,NrElem,fptr_Uptr.p);
  return result;
}

int F9_CALLCONV
C_GDXCURRENTDIM (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxCurrentDim(h_.p);
  return result;
}

